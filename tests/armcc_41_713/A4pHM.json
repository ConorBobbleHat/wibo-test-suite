{"compiler": "armcc_41_713", "compiler_flags": "--apcs=//interwork --cpu=MPCore --fpmode=fast --cpp --arm --force_new_nothrow --signed_chars --multibyte-chars --locale=japanese --vfe --no_rtti_data --no_rtti --no_exceptions --data-reorder -Otime", "source_code": "/* No decompiler yet implemented for arm32 */\nnamespace al {\n\nRailKeeper* tryCreateRailKeeper(const PlacementInfo& info)\n{\n    PlacementInfo railIter;\n    if (tryGetRailIter(&railIter, info))\n        return new RailKeeper(railIter);\n    return nullptr;\n}\n\n} // namespace al\n", "context": "#define NULL 0\n\ntypedef signed char s8;\ntypedef unsigned char u8;\ntypedef signed short s16;\ntypedef unsigned short u16;\ntypedef signed int s32;\ntypedef unsigned int u32;\ntypedef signed long long s64;\ntypedef unsigned long long u64;\n\ntypedef float f32;\ntypedef double f64;\n\n#ifdef __cplusplus\n\n#define nullptr NULL\n\ntypedef u32 uintptr_t;\ntypedef s32 intptr_t;\ntypedef u32 size_t;\n\n#endif\n\n#define static_assert(COND, MSG) typedef int __static_assert_balls[(COND) ? 1 : -1]\n#define split(S) __attribute__((section(\"i.\" #S))) S\n\nnamespace sead {\ntemplate <typename T>\nstruct BaseVec2 {\n    T x;\n    T y;\n};\n\ntemplate <typename T>\nstruct BaseVec3 {\n    T x;\n    T y;\n    T z;\n};\n\ntemplate <typename T>\nstruct BaseVec4 {\n    T x;\n    T y;\n    T z;\n    T w;\n};\n\ntemplate <typename T>\nstruct BaseQuat {\n    T x;\n    T y;\n    T z;\n    T w;\n};\n\ntemplate <typename T>\nstruct BaseMtx22 {\n    T m[2][2];\n};\n\ntemplate <typename T>\nstruct BaseMtx33 {\n    T m[3][3];\n};\n\ntemplate <typename T>\nstruct BaseMtx34 {\n    T m[3][4];\n};\n\ntemplate <typename T>\nstruct BaseMtx44 {\n    T m[4][4];\n};\n\n} // namespace sead\n\nnamespace sead {\ntemplate <typename T>\nclass Policies {\npublic:\n    typedef BaseVec2<T> Vec2Base;\n    typedef BaseVec3<T> Vec3Base;\n    typedef BaseVec4<T> Vec4Base;\n    typedef BaseQuat<T> QuatBase;\n    typedef BaseMtx22<T> Mtx22Base;\n    typedef BaseMtx33<T> Mtx33Base;\n    typedef BaseMtx34<T> Mtx34Base;\n    typedef BaseMtx44<T> Mtx44Base;\n};\n\n} // namespace sead\n\nnamespace sead {\nnamespace numbers {\n\n    const float e_v = 2.718281828459045235360287471352662;\n    const float log2e_v = 1.442695040888963407359924681001892;\n    const float log10e_v = 0.434294481903251827651128918916605;\n    const float pi_v = 3.141592653589793238462643383279502;\n    const float inv_pi_v = 0.318309886183790671537767526745028;\n    const float inv_sqrtpi_v = 0.564189583547756286948079451560772;\n    const float ln2_v = 0.693147180559945309417232121458176;\n    const float ln10_v = 2.302585092994045684017991454684364;\n    const float sqrt2_v = 1.414213562373095048801688724209698;\n    const float sqrt3_v = 1.732050807568877293527446341505872;\n    const float inv_sqrt3_v = 0.577350269189625764509148780501957;\n    const float egamma_v = 0.577215664901532860606512090082402;\n    const float phi_v = 1.618033988749894848204586834365638;\n\n} // namespace numbers\n} // namespace sead\n\nnamespace sead {\ntemplate <typename T>\nclass MathCalcCommon {\npublic:\n    static const u32 cQuarterRoundIdx = 0x40000000; //  90 degrees, PI/2 radians\n    static const u32 cHalfRoundIdx = 0x80000000; // 180 degrees, PI   radians\n\n    struct SinCosSample {\n        T sin_val;\n        T sin_delta;\n        T cos_val;\n        T cos_delta;\n    };\n\n    struct AtanSample {\n        u32 atan_val;\n        T atan_delta;\n    };\n\n    struct ExpSample {\n        T exp_val;\n        T exp_delta;\n    };\n\n    struct LogSample {\n        T log_val;\n        T log_delta;\n    };\n\n    static T piHalf() { return numbers::pi_v / static_cast<T>(2); }\n    static T pi() { return numbers::pi_v; }\n    static T pi2() { return numbers::pi_v * static_cast<T>(2); }\n    static T zero() { return static_cast<T>(0); }\n    static T one() { return static_cast<T>(1); }\n    static T ln2() { return numbers::ln2_v; }\n    static T ln2Inv() { return numbers::log2e_v; }\n\n    static T neg(T t);\n    static T inv(T t);\n\n    /// Returns -1 for strictly negative values and 1 otherwise.\n    static T sign(T value);\n\n    static T fitSign(T value, T sign_value) { return abs(value) * sign(sign_value); }\n\n    static T square(T t) { return t * t; }\n\n    static T sqrt(T t);\n    static T rsqrt(T t);\n\n    static T pow(T x, T y);\n    static T powTable(T, T);\n\n    static T sin(T t);\n    static T cos(T t);\n    static T tan(T t);\n\n    static T asin(T s);\n    static T acos(T c);\n    static T atan(T t);\n    static T atan2(T y, T x);\n\n    static T sinIdx(u32 idx);\n    static T cosIdx(u32 idx);\n    static T tanIdx(u32 idx);\n\n    static u32 asinIdx(T s);\n    static u32 acosIdx(T c);\n    static u32 atanIdx(T t);\n    static u32 atan2Idx(T y, T x);\n\n    static void sinCosIdx(T* p_sin, T* p_cos, u32 idx);\n\n    static T exp(T t);\n    static T log(T t);\n    static T log2(T n);\n    static T log10(T t);\n\n    static T expTable(T x);\n    static T logTable(T x);\n\n    static T minNumber();\n    static T maxNumber();\n    static T infinity();\n    static T nan();\n    /*static T epsilon() { return std::numeric_limits<T>::epsilon(); }\n\n    static bool equalsEpsilon(T lhs, T rhs, T eps = epsilon())\n    {\n        const T diff = lhs - rhs;\n        return -eps <= diff && diff <= eps;\n    }*/\n\n    static T abs(T x) { return x > 0 ? x : -x; }\n\n    static T max(T a, T b);\n    static T min(T a, T b);\n    static T max3(T a, T b, T c);\n    static T min3(T a, T b, T c);\n\n    static T deg2rad(T deg);\n    static T rad2deg(T rad);\n\n    static u32 deg2idx(T a);\n    static u32 rad2idx(T a);\n    static T idx2deg(u32 a);\n    static T idx2rad(u32 a);\n\n    static T roundAngle(T);\n    static T angleDist(T, T);\n    static T random();\n    static T getRand(T);\n    static T getRandRange(T, T);\n    static T getRandSign();\n    static s32 roundOff(T);\n    static s32 floor(T);\n    static s32 ceil(T);\n    static T roundUp(T x, s32 multNumber);\n    static s32 roundUpPow2(T x, s32 y);\n    static s32 roundDownN(T val, s32 multNumber);\n    static s32 roundDownPow2(T x, s32 y);\n    static T clampMax(T val, T max_);\n    static T clampMin(T val, T min_);\n    static T clamp2(T min_, T val, T max_); // is this the same function?\n    static T clamp(T value, T low, T high);\n    static T gcd(T x, T y);\n    static T lcm(T x, T y);\n    static bool isZero(T, T);\n    static bool isNan(T);\n    static bool isPow2(T);\n    static bool isMultiplePow2(T, T);\n    static bool isInfinity(T);\n    static bool isIntersect1d(T, T, T, T);\n\n    /// Adds or subtracts `step` from `value` towards `target`.\n    /// Returns whether the new value is equal to the target.\n    static bool chase(T* value, T target, T step);\n    static bool chaseAngle(T*, T, T);\n    static bool chaseAngleIdx(u32*, u32, s64);\n\n    static T lerp(T a, T b, f32 ratio);\n\nprotected:\n    static u32 atanIdx_(T t);\n    static T expLn2_(T x);\n    static T log1_2_(T x);\n    static void assertGreaterThanOrEqualToZero_(T);\n\npublic:\n    /// Note: this is only defined for T = float at the moment.\n    static const SinCosSample cSinCosTbl[256 + 1];\n    static const AtanSample cAtanTbl[128 + 1];\n    static const ExpSample cExpTbl[32 + 1];\n    static const LogSample cLogTbl[256 + 1];\n};\n\ntypedef MathCalcCommon<s32> Mathi;\ntypedef MathCalcCommon<u32> Mathu;\ntypedef MathCalcCommon<f32> Mathf;\ntypedef MathCalcCommon<size_t> MathSizeT;\n\ntemplate <>\nu32 MathCalcCommon<f32>::atanIdx_(f32 t);\n\n/*template <typename T>\nconstexpr T log2(T n)\n{\n    static_assert(std::is_integral<T>(), \"T must be an integral type\");\n    return n <= 1 ? 0 : 1 + log2(n >> 1);\n}*/\n\n} // namespace sead\n\nnamespace sead {\ntemplate <typename T>\nclass Vector2CalcCommon {\npublic:\n    typedef typename Policies<T>::Vec2Base Base;\n\npublic:\n    static void add(Base& o, const Base& a, const Base& b);\n    static void sub(Base& o, const Base& a, const Base& b);\n\n    static void set(Base& o, const Base& v);\n    static void set(Base& v, T x, T y);\n};\n\ntemplate <typename T>\nclass Vector3CalcCommon {\npublic:\n    typedef typename Policies<T>::Vec3Base Base;\n    typedef typename Policies<T>::Mtx33Base Mtx33;\n    typedef typename Policies<T>::Mtx34Base Mtx34;\n\n    static void add(Base& o, const Base& a, const Base& b);\n    static void sub(Base& o, const Base& a, const Base& b);\n    static void mul(Base& o, const Mtx33& m, const Base& a);\n    /// Apply a transformation `m` (rotation + translation) to the vector `a`.\n    static void mul(Base& o, const Mtx34& m, const Base& a);\n\n    static void cross(Base& o, const Base& a, const Base& b);\n    static T dot(const Base& a, const Base& b);\n    static T squaredLength(const Base& v);\n    static T length(const Base& v);\n    static bool equals(const Base& lhs, const Base& rhs, T epsilon);\n    static void multScalar(Base& o, const Base& v, T t);\n    static void multScalarAdd(Base& o, T t, const Base& a, const Base& b);\n    static T normalize(Base& v);\n    static void set(Base& o, const Base& v);\n    static void set(Base& v, T x, T y, T z);\n};\n\ntemplate <typename T>\nclass Vector4CalcCommon {\npublic:\n    typedef typename Policies<T>::Vec4Base Base;\n\npublic:\n    static void set(Base& o, const Base& v);\n    static void set(Base& v, T x, T y, T z, T w);\n};\n\n} // namespace sead\n\nnamespace sead {\ntemplate <typename T>\ninline void Vector2CalcCommon<T>::add(Base& o, const Base& a, const Base& b)\n{\n    o.x = a.x + b.x;\n    o.y = a.y + b.y;\n}\n\ntemplate <typename T>\ninline void Vector2CalcCommon<T>::sub(Base& o, const Base& a, const Base& b)\n{\n    o.x = a.x - b.x;\n    o.y = a.y - b.y;\n}\n\ntemplate <typename T>\ninline void Vector2CalcCommon<T>::set(Base& o, const Base& v)\n{\n    o.x = v.x;\n    o.y = v.y;\n}\n\ntemplate <typename T>\ninline void Vector2CalcCommon<T>::set(Base& v, T x, T y)\n{\n    v.x = x;\n    v.y = y;\n}\n\ntemplate <typename T>\ninline void Vector3CalcCommon<T>::add(Base& o, const Base& a, const Base& b)\n{\n    o.x = a.x + b.x;\n    o.y = a.y + b.y;\n    o.z = a.z + b.z;\n}\n\n#ifdef cafe\n\ntemplate <>\ninline void Vector3CalcCommon<f32>::add(Base& o, const Base& a, const Base& b)\n{\n    // TODO: Implement using intrinsics\n    ASM_VECAdd((const Vec*)&a, (const Vec*)&b, (Vec*)&o);\n}\n\n#endif // cafe\n\ntemplate <typename T>\ninline void Vector3CalcCommon<T>::sub(Base& o, const Base& a, const Base& b)\n{\n    o.x = a.x - b.x;\n    o.y = a.y - b.y;\n    o.z = a.z - b.z;\n}\n\n#ifdef cafe\n\ntemplate <>\ninline void Vector3CalcCommon<f32>::sub(Base& o, const Base& a, const Base& b)\n{\n    // TODO: Implement using intrinsics\n    ASM_VECSubtract((const Vec*)&a, (const Vec*)&b, (Vec*)&o);\n}\n\n#endif // cafe\n\ntemplate <typename T>\ninline void Vector3CalcCommon<T>::mul(Base& o, const Mtx33& m, const Base& a)\n{\n    const Base tmp = a;\n    o.x = m.m[0][0] * tmp.x + m.m[0][1] * tmp.y + m.m[0][2] * tmp.z;\n    o.y = m.m[1][0] * tmp.x + m.m[1][1] * tmp.y + m.m[1][2] * tmp.z;\n    o.z = m.m[2][0] * tmp.x + m.m[2][1] * tmp.y + m.m[2][2] * tmp.z;\n}\n\ntemplate <typename T>\ninline void Vector3CalcCommon<T>::mul(Base& o, const Mtx34& m, const Base& a)\n{\n    const Base tmp = a;\n    o.x = m.m[0][0] * tmp.x + m.m[0][1] * tmp.y + m.m[0][2] * tmp.z + m.m[0][3];\n    o.y = m.m[1][0] * tmp.x + m.m[1][1] * tmp.y + m.m[1][2] * tmp.z + m.m[1][3];\n    o.z = m.m[2][0] * tmp.x + m.m[2][1] * tmp.y + m.m[2][2] * tmp.z + m.m[2][3];\n}\n\ntemplate <typename T>\ninline void Vector3CalcCommon<T>::cross(Base& o, const Base& a, const Base& b)\n{\n    Vector3CalcCommon<T>::set(o, (a.y * b.z) - (a.z * b.y), (a.z * b.x) - (a.x * b.z),\n        (a.x * b.y) - (a.y * b.x));\n}\n\n#ifdef cafe\n\ntemplate <>\ninline void Vector3CalcCommon<f32>::cross(Base& o, const Base& a, const Base& b)\n{\n    ASM_VECCrossProduct((const Vec*)&a, (const Vec*)&b, (Vec*)&o);\n}\n\n#endif // cafe\n\ntemplate <typename T>\ninline T Vector3CalcCommon<T>::dot(const Base& a, const Base& b)\n{\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\n#ifdef cafe\n\ntemplate <>\ninline f32 Vector3CalcCommon<f32>::dot(const Base& a, const Base& b)\n{\n    // TODO: Implement using intrinsics\n    return ASM_VECDotProduct((const Vec*)&a, (const Vec*)&b);\n}\n\n#endif // cafe\n\ntemplate <typename T>\ninline T Vector3CalcCommon<T>::squaredLength(const Base& v)\n{\n    return v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\ntemplate <typename T>\ninline T Vector3CalcCommon<T>::length(const Base& v)\n{\n    return MathCalcCommon<T>::sqrt(squaredLength(v));\n}\n\n#ifdef cafe\n\ntemplate <>\ninline f32 Vector3CalcCommon<f32>::length(const Base& v)\n{\n    return ASM_VECMag((const Vec*)&v);\n}\n\n#endif // cafe\n\ntemplate <typename T>\ninline bool Vector3CalcCommon<T>::equals(const Base& lhs, const Base& rhs, T epsilon)\n{\n    return MathCalcCommon<T>::equalsEpsilon(lhs.x, rhs.x, epsilon) && MathCalcCommon<T>::equalsEpsilon(lhs.y, rhs.y, epsilon) && MathCalcCommon<T>::equalsEpsilon(lhs.z, rhs.z, epsilon);\n}\n\ntemplate <typename T>\ninline void Vector3CalcCommon<T>::multScalar(Base& o, const Base& v, T t)\n{\n    o.x = v.x * t;\n    o.y = v.y * t;\n    o.z = v.z * t;\n}\n\n#ifdef cafe\n\ntemplate <>\ninline void Vector3CalcCommon<f32>::multScalar(Base& o, const Base& v, f32 t)\n{\n    // TODO: Implement using intrinsics\n    ASM_VECScale((const Vec*)&v, (Vec*)&o, t);\n}\n\n#endif // cafe\n\ntemplate <typename T>\ninline void Vector3CalcCommon<T>::multScalarAdd(Base& o, T t, const Base& a, const Base& b)\n{\n    o.x = a.x * t + b.x;\n    o.y = a.y * t + b.y;\n    o.z = a.z * t + b.z;\n}\n\n#ifdef cafe\n\ntemplate <>\ninline void Vector3CalcCommon<f32>::multScalarAdd(Base& o, f32 t, const Base& a, const Base& b)\n{\n    // TODO: Implement using intrinsics\n    ASM_VECScale((const Vec*)&a, (Vec*)&o, t);\n    ASM_VECAdd((const Vec*)&o, (const Vec*)&b, (Vec*)&o);\n}\n\n#endif // cafe\n\ntemplate <typename T>\nT Vector3CalcCommon<T>::normalize(Base& v)\n{\n    const T len = length(v);\n    if (len > 0) {\n        const T inv_len = 1 / len;\n        v.x *= inv_len;\n        v.y *= inv_len;\n        v.z *= inv_len;\n    }\n\n    return len;\n}\n\ntemplate <typename T>\ninline void Vector3CalcCommon<T>::set(Base& o, const Base& v)\n{\n    o.x = v.x;\n    o.y = v.y;\n    o.z = v.z;\n}\n\ntemplate <typename T>\ninline void Vector3CalcCommon<T>::set(Base& v, T x, T y, T z)\n{\n    v.x = x;\n    v.y = y;\n    v.z = z;\n}\n\ntemplate <typename T>\ninline void Vector4CalcCommon<T>::set(Base& o, const Base& v)\n{\n    o.x = v.x;\n    o.y = v.y;\n    o.z = v.z;\n    o.w = v.w;\n}\n\ntemplate <typename T>\ninline void Vector4CalcCommon<T>::set(Base& v, T x, T y, T z, T w)\n{\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    v.w = w;\n}\n\n} // namespace sead\n\nnamespace sead {\ntemplate <typename T>\nstruct Vector2 : public Policies<T>::Vec2Base {\n    /// @warning This constructor leaves member variables uninitialized.\n    Vector2() { }\n    Vector2(const Vector2& other) {};\n    Vector2(T x, T y);\n\n    Vector2& operator=(const Vector2& other);\n\n    Vector2& operator+=(const Vector2& other);\n\n    friend Vector2 operator+(const Vector2& a, const Vector2& b)\n    {\n        Vector2 o;\n        Vector2CalcCommon<T>::add(o, a, b);\n        return o;\n    }\n\n    Vector2& operator-=(const Vector2& other);\n\n    friend Vector2 operator-(const Vector2& a, const Vector2& b)\n    {\n        Vector2 o;\n        Vector2CalcCommon<T>::sub(o, a, b);\n        return o;\n    }\n\n    Vector2& operator*=(T t);\n\n    friend Vector2 operator*(const Vector2& a, T t)\n    {\n        Vector2 o;\n        o.x = a.x * t;\n        o.y = a.y * t;\n        return o;\n    }\n\n    friend Vector2 operator*(T t, const Vector2& a) { return operator*(a, t); }\n\n    Vector2& operator/=(T t);\n\n    friend Vector2 operator/(const Vector2& a, T t) { return Vector2(a.x / t, a.y / t); }\n\n    bool operator==(const Vector2& rhs) const { return this->x == rhs.x && this->y == rhs.y; }\n    bool operator!=(const Vector2& rhs) const { return !operator==(rhs); }\n\n    void set(const Vector2& other);\n    void set(T x_, T y_);\n\n    static const Vector2 zero;\n    static const Vector2 ex;\n    static const Vector2 ey;\n    static const Vector2 ones;\n};\n\ntemplate <typename T>\nstruct Vector3 : public Policies<T>::Vec3Base {\n    typedef typename Policies<T>::Mtx33Base Mtx33;\n    typedef typename Policies<T>::Mtx34Base Mtx34;\n\n    /// @warning This constructor leaves member variables uninitialized.\n    Vector3() { }\n    Vector3(const Vector3& other) {};\n    Vector3(T x, T y, T z);\n\n    Vector3& operator=(const Vector3& other);\n    bool operator==(const Vector3& rhs) const;\n    bool operator!=(const Vector3& rhs) const;\n\n    Vector3& operator+=(const Vector3& other);\n    friend Vector3 operator+(const Vector3& a, const Vector3& b)\n    {\n        Vector3 o;\n        Vector3CalcCommon<T>::add(o, a, b);\n        return o;\n    }\n\n    Vector3& operator-=(const Vector3& other);\n    friend Vector3 operator-(const Vector3& a, const Vector3& b)\n    {\n        Vector3 o;\n        Vector3CalcCommon<T>::sub(o, a, b);\n        return o;\n    }\n\n    Vector3& operator*=(T t);\n    Vector3& operator*=(const Mtx33& m);\n    Vector3& operator*=(const Mtx34& m);\n    friend Vector3 operator*(const Vector3& a, T t)\n    {\n        Vector3 o;\n        Vector3CalcCommon<T>::multScalar(o, a, t);\n        return o;\n    }\n    friend Vector3 operator*(T t, const Vector3& a) { return operator*(a, t); }\n    friend Vector3 operator*(const Mtx33& m, const Vector3& a)\n    {\n        Vector3 o;\n        o.setMul(m, a);\n        return o;\n    }\n    friend Vector3 operator*(const Mtx34& m, const Vector3& a)\n    {\n        Vector3 o;\n        o.setMul(m, a);\n        return o;\n    }\n\n    Vector3& operator/=(T t);\n    friend Vector3 operator/(const Vector3& a, T t) { return Vector3(a.x / t, a.y / t, a.z / t); }\n\n    Vector3 operator-() const { return Vector3(-this->x, -this->y, -this->z); }\n\n    T dot(const Vector3& t) const;\n    T length() const;\n    T squaredLength() const;\n\n    /// Checks if the differences of all components of lhs and rhs are within `epsilon`.\n    /// (i.e. -epsilon <= lhs.x - rhs.x <= epsilon, and so on).\n    bool equals(const Vector3& rhs, T epsilon = 0) const;\n\n    void add(const Vector3& a);\n    /// Multiply m by this vector (self = m * self).\n    void mul(const Mtx33& m);\n    /// Apply a transformation `m` (rotation + translation) to this vector.\n    void mul(const Mtx34& m);\n    void multScalar(T t);\n\n    T normalize();\n    void set(const Vector3& other);\n    void set(T x, T y, T z);\n    void setCross(const Vector3<T>& a, const Vector3<T>& b);\n    void setScaleAdd(T t, const Vector3<T>& a, const Vector3<T>& b);\n    void setMul(const Mtx33& m, const Vector3& a);\n    void setMul(const Mtx34& m, const Vector3& a);\n\n    static const Vector3 zero;\n    static const Vector3 ex;\n    static const Vector3 ey;\n    static const Vector3 ez;\n    static const Vector3 ones;\n};\n\ntemplate <typename T>\nstruct Vector4 : public Policies<T>::Vec4Base {\n    /// @warning This constructor leaves member variables uninitialized.\n    Vector4() { }\n    Vector4(const Vector4& other) {};\n    Vector4(T x, T y, T z, T w);\n\n    Vector4& operator=(const Vector4& other);\n\n    Vector4& operator+=(const Vector4& other);\n\n    friend Vector4 operator+(const Vector4& a, const Vector4& b)\n    {\n        return Vector4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);\n    }\n\n    Vector4& operator-=(const Vector4& other);\n\n    friend Vector4 operator-(const Vector4& a, const Vector4& b)\n    {\n        return Vector4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);\n    }\n\n    Vector4& operator*=(T t);\n\n    friend Vector4 operator*(const Vector4& a, T t) { return Vector4(a.x * t, a.y * t, a.z * t, a.w * t); }\n\n    friend Vector4 operator*(T t, const Vector4& a) { return operator*(a, t); }\n\n    Vector4& operator/=(T t);\n\n    friend Vector4 operator/(const Vector4& a, T t) { return Vector4(a.x / t, a.y / t, a.z / t, a.w / t); }\n\n    bool operator==(const Vector4& rhs) const\n    {\n        return this->x == rhs.x && this->y == rhs.y && this->z == rhs.z && this->w == rhs.w;\n    }\n    bool operator!=(const Vector4& rhs) const { return !operator==(rhs); }\n\n    void set(const Vector4& v);\n    void set(T x_, T y_, T z_, T w_);\n\n    static const Vector4 zero;\n    static const Vector4 ex;\n    static const Vector4 ey;\n    static const Vector4 ez;\n    static const Vector4 ew;\n    static const Vector4 ones;\n};\n\ntypedef Vector2<f32> Vector2f;\ntypedef Vector2<s32> Vector2i;\ntypedef Vector3<f32> Vector3f;\ntypedef Vector4<f32> Vector4f;\n\ntemplate <>\nconst Vector2<f32> Vector2<f32>::zero;\n\ntemplate <>\nconst Vector2<f32> Vector2<f32>::ex;\n\ntemplate <>\nconst Vector2<f32> Vector2<f32>::ey;\n\ntemplate <>\nconst Vector2<f32> Vector2<f32>::ones;\n\ntemplate <>\nconst Vector3<f32> Vector3<f32>::zero;\n\ntemplate <>\nconst Vector3<f32> Vector3<f32>::ex;\n\ntemplate <>\nconst Vector3<f32> Vector3<f32>::ey;\n\ntemplate <>\nconst Vector3<f32> Vector3<f32>::ez;\n\ntemplate <>\nconst Vector3<f32> Vector3<f32>::ones;\n\ntemplate <>\nconst Vector4<f32> Vector4<f32>::zero;\n\ntemplate <>\nconst Vector4<f32> Vector4<f32>::ex;\n\ntemplate <>\nconst Vector4<f32> Vector4<f32>::ey;\n\ntemplate <>\nconst Vector4<f32> Vector4<f32>::ez;\n\ntemplate <>\nconst Vector4<f32> Vector4<f32>::ew;\n\ntemplate <>\nconst Vector4<f32> Vector4<f32>::ones;\n\n} // namespace sead\n\nnamespace sead {\ntemplate <typename T>\ninline Vector2<T>::Vector2(T x_, T y_)\n{\n    Vector2CalcCommon<T>::set(*this, x_, y_);\n}\n\ntemplate <typename T>\ninline Vector2<T>& Vector2<T>::operator+=(const Vector2<T>& other)\n{\n    Vector2CalcCommon<T>::add(*this, *this, other);\n    return *this;\n}\n\ntemplate <typename T>\ninline Vector2<T>& Vector2<T>::operator-=(const Vector2<T>& other)\n{\n    Vector2CalcCommon<T>::sub(*this, *this, other);\n    return *this;\n}\n\ntemplate <typename T>\ninline Vector2<T>& Vector2<T>::operator*=(T t)\n{\n    this->x *= t;\n    this->y *= t;\n    return *this;\n}\n\ntemplate <typename T>\ninline Vector2<T>& Vector2<T>::operator/=(T t)\n{\n    this->x /= t;\n    this->y /= t;\n    return *this;\n}\n\ntemplate <typename T>\ninline Vector2<T>& Vector2<T>::operator=(const Vector2<T>& other)\n{\n    Vector2CalcCommon<T>::set(*this, other);\n    return *this;\n}\n\ntemplate <typename T>\ninline void Vector2<T>::set(const Vector2<T>& other)\n{\n    Vector2CalcCommon<T>::set(*this, other);\n}\n\ntemplate <typename T>\ninline void Vector2<T>::set(T x_, T y_)\n{\n    Vector2CalcCommon<T>::set(*this, x_, y_);\n}\n\ntemplate <typename T>\ninline Vector3<T>::Vector3(T x_, T y_, T z_)\n{\n    Vector3CalcCommon<T>::set(*this, x_, y_, z_);\n}\n\ntemplate <typename T>\ninline Vector3<T>& Vector3<T>::operator=(const Vector3<T>& other)\n{\n    Vector3CalcCommon<T>::set(*this, other);\n    return *this;\n}\n\ntemplate <typename T>\ninline bool Vector3<T>::operator==(const Vector3& rhs) const\n{\n    return this->x == rhs.x && this->y == rhs.y && this->z == rhs.z;\n}\n\ntemplate <typename T>\ninline bool Vector3<T>::operator!=(const Vector3& rhs) const\n{\n    return !operator==(rhs);\n}\n\ntemplate <typename T>\ninline Vector3<T>& Vector3<T>::operator+=(const Vector3<T>& other)\n{\n    Vector3CalcCommon<T>::add(*this, *this, other);\n    return *this;\n}\n\ntemplate <typename T>\ninline Vector3<T>& Vector3<T>::operator-=(const Vector3<T>& other)\n{\n    Vector3CalcCommon<T>::sub(*this, *this, other);\n    return *this;\n}\n\ntemplate <typename T>\ninline Vector3<T>& Vector3<T>::operator*=(T t)\n{\n    Vector3CalcCommon<T>::multScalar(*this, *this, t);\n    return *this;\n}\n\ntemplate <typename T>\ninline Vector3<T>& Vector3<T>::operator*=(const Mtx33& m)\n{\n    mul(m);\n    return *this;\n}\n\ntemplate <typename T>\ninline Vector3<T>& Vector3<T>::operator*=(const Mtx34& m)\n{\n    mul(m);\n    return *this;\n}\n\ntemplate <typename T>\ninline Vector3<T>& Vector3<T>::operator/=(T t)\n{\n    this->x /= t;\n    this->y /= t;\n    this->z /= t;\n    return *this;\n}\n\ntemplate <typename T>\ninline T Vector3<T>::dot(const Vector3<T>& t) const\n{\n    return Vector3CalcCommon<T>::dot(*this, t);\n}\n\ntemplate <typename T>\ninline T Vector3<T>::length() const\n{\n    return Vector3CalcCommon<T>::length(*this);\n}\n\ntemplate <typename T>\ninline T Vector3<T>::squaredLength() const\n{\n    return Vector3CalcCommon<T>::squaredLength(*this);\n}\n\ntemplate <typename T>\ninline bool Vector3<T>::equals(const Vector3<T>& rhs, T epsilon) const\n{\n    return Vector3CalcCommon<T>::equals(*this, rhs, epsilon);\n}\n\ntemplate <typename T>\ninline void Vector3<T>::add(const Vector3<T>& a)\n{\n    Vector3CalcCommon<T>::add(*this, *this, a);\n}\n\ntemplate <typename T>\ninline void Vector3<T>::mul(const Mtx33& m)\n{\n    setMul(m, *this);\n}\n\ntemplate <typename T>\ninline void Vector3<T>::mul(const Mtx34& m)\n{\n    setMul(m, *this);\n}\n\ntemplate <typename T>\ninline void Vector3<T>::multScalar(T t)\n{\n    Vector3CalcCommon<T>::multScalar(*this, *this, t);\n}\n\ntemplate <typename T>\ninline T Vector3<T>::normalize()\n{\n    return Vector3CalcCommon<T>::normalize(*this);\n}\n\ntemplate <typename T>\ninline void Vector3<T>::set(const Vector3<T>& other)\n{\n    Vector3CalcCommon<T>::set(*this, other);\n}\n\ntemplate <typename T>\ninline void Vector3<T>::set(T x_, T y_, T z_)\n{\n    Vector3CalcCommon<T>::set(*this, x_, y_, z_);\n}\n\ntemplate <typename T>\ninline void Vector3<T>::setCross(const Vector3<T>& a, const Vector3<T>& b)\n{\n    Vector3CalcCommon<T>::cross(*this, a, b);\n}\n\ntemplate <typename T>\ninline void Vector3<T>::setScaleAdd(T t, const Vector3<T>& a, const Vector3<T>& b)\n{\n    Vector3CalcCommon<T>::multScalarAdd(*this, t, a, b);\n}\n\ntemplate <typename T>\ninline void Vector3<T>::setMul(const Mtx33& m, const Vector3<T>& a)\n{\n    Vector3CalcCommon<T>::mul(*this, m, a);\n}\n\ntemplate <typename T>\ninline void Vector3<T>::setMul(const Mtx34& m, const Vector3<T>& a)\n{\n    Vector3CalcCommon<T>::mul(*this, m, a);\n}\n\ntemplate <typename T>\ninline Vector4<T>::Vector4(T x_, T y_, T z_, T w_)\n{\n    Vector4CalcCommon<T>::set(*this, x_, y_, z_, w_);\n}\n\ntemplate <typename T>\ninline Vector4<T>& Vector4<T>::operator+=(const Vector4<T>& other)\n{\n    this->x += other.x;\n    this->y += other.y;\n    this->z += other.z;\n    this->w += other.w;\n    return *this;\n}\n\ntemplate <typename T>\ninline Vector4<T>& Vector4<T>::operator-=(const Vector4<T>& other)\n{\n    this->x -= other.x;\n    this->y -= other.y;\n    this->z -= other.z;\n    this->w -= other.w;\n    return *this;\n}\n\ntemplate <typename T>\ninline Vector4<T>& Vector4<T>::operator*=(T t)\n{\n    this->x *= t;\n    this->y *= t;\n    this->z *= t;\n    this->w *= t;\n    return *this;\n}\n\ntemplate <typename T>\ninline Vector4<T>& Vector4<T>::operator/=(T t)\n{\n    this->x /= t;\n    this->y /= t;\n    this->z /= t;\n    this->w /= t;\n    return *this;\n}\n\ntemplate <typename T>\ninline Vector4<T>& Vector4<T>::operator=(const Vector4<T>& other)\n{\n    Vector4CalcCommon<T>::set(*this, other);\n    return *this;\n}\n\ntemplate <typename T>\ninline void Vector4<T>::set(const Vector4<T>& other)\n{\n    Vector4CalcCommon<T>::set(*this, other);\n}\n\ntemplate <typename T>\ninline void Vector4<T>::set(T x_, T y_, T z_, T w_)\n{\n    Vector4CalcCommon<T>::set(*this, x_, y_, z_, w_);\n}\n\n} // namespace sead\n\nnamespace al {\n\nclass ByamlIter {\n    union {\n        const u8* mData;\n        const class ByamlHeader* mHeader;\n    };\n    union {\n        const u8* mRootNode;\n        const class ByamlContainerHeader* mContainerHeader;\n    };\n\npublic:\n    ByamlIter();\n    ByamlIter(const u8* data);\n    ByamlIter(const u8* data, const u8* rootNode);\n\n    bool isEqualData(const ByamlIter& other) const;\n\n    bool isValid() const;\n    bool isTypeArray() const;\n    bool isTypeHash() const;\n    bool isTypeContainer() const;\n\n    int getSize() const;\n\n    bool isExistKey(const char* key) const;\n    int getKeyIndex(const char* key) const;\n    bool getKeyName(const char** out, int index) const;\n\n    bool tryGetStringByIndex(const char** out, int index) const;\n    bool tryGetStringByKey(const char** out, const char* key) const;\n    bool tryGetBinaryByIndex(const u8** out, int* size, int index) const;\n    bool tryGetBinaryByKey(const u8** out, int* size, const char* key) const;\n    ByamlIter getIterByIndex(int index) const;\n    bool tryGetIterByIndex(ByamlIter* out, int index) const;\n    ByamlIter getIterByKey(const char* key) const;\n    bool tryGetIterByKey(ByamlIter* out, const char* key) const;\n    bool tryGetIterAndKeyNameByIndex(ByamlIter* out, const char** key, int index) const;\n    bool tryGetBoolByIndex(bool* out, int index) const;\n    bool tryGetBoolByKey(bool* out, const char* key) const;\n    bool tryGetIntByIndex(int* out, int index) const;\n    bool tryGetIntByKey(int* out, const char* key) const;\n    bool tryGetFloatByIndex(float* out, int index) const;\n    bool tryGetFloatByKey(float* out, const char* key) const;\n\n    const ByamlHeader* getHeader() const { return mHeader; }\n};\n// turn into a class if it actually is one\ntypedef ByamlIter PlacementInfo;\n\n} // namespace al\n\nnamespace al {\n\nclass Rail {\n    int _0;\n    int _4;\n    int _8;\n    int _C;\n    bool mIsClosed;\n\npublic:\n    Rail();\n\n    void init(const PlacementInfo& info);\n\n    float normalizeLength(float) const;\n    void calcPosDir(sead::Vector3f*, sead::Vector3f*, float);\n};\n\n} // namespace al\n\nnamespace al {\n\nclass RailRider {\n    Rail* mRail;\n    sead::Vector3f mCurrentPos;\n    sead::Vector3f mCurrentDir;\n    float _1C;\n    float _20;\n    bool _24;\n\npublic:\n    RailRider(Rail* rail);\n\n    void moveToRailStart();\n\n    const sead::Vector3f& getCurrentPos() { return mCurrentPos; }\n    const sead::Vector3f& getCurrentDir() { return mCurrentDir; }\n};\n\n} // namespace al\n\nnamespace al {\n\nclass RailKeeper {\n    Rail* mRail;\n    RailRider* mRailRider;\n\npublic:\n    RailKeeper(const PlacementInfo& info);\n    Rail* getRail() { return mRail; }\n    RailRider* getRailRider() { return mRailRider; }\n};\n\nRailKeeper::RailKeeper(const PlacementInfo& info)\n    : mRail(nullptr)\n    , mRailRider(nullptr)\n{\n    mRail = new Rail;\n    mRail->init(info);\n    mRailRider = new RailRider(mRail);\n}\n\nRailKeeper* tryCreateRailKeeper(const PlacementInfo& info);\n\n// from PlacementFunction\nbool tryGetRailIter(PlacementInfo* out, const PlacementInfo& info);\n\n} // namespace al", "diff_flags": [], "diff_label": "_ZN2al19tryCreateRailKeeperERKNS_9ByamlIterE", "libraries": []}