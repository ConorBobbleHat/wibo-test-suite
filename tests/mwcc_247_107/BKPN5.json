{"compiler": "mwcc_247_107", "compiler_flags": "-lang=c++ -nodefaults -Cpp_exceptions off -RTTI off -fp hard -fp_contract on -rostr -O4,p -use_lmw_stmw on -enum int -inline auto -sdata 8 -sdata2 8 -common on", "source_code": "/*\nDecompilation failure:\n\nunsupported non-nop instruction outside of function (blr)\n*/\n\nvoid func(void) {\n    // ...\n}\n", "context": "/* \"src\\Dolphin\\gx\\GXTev.c\" line 0 \"Dolphin/gx.h\" */\n#ifndef _DOLPHIN_GX_H\n#define _DOLPHIN_GX_H\n\n/* \"include\\Dolphin\\gx.h\" line 3 \"types.h\" */\n#ifndef _TYPES_H\n#define _TYPES_H\n\n/* \"include\\types.h\" line 3 \"BuildSettings.h\" */\n#ifndef _BUILDSETTINGS_H\n#define _BUILDSETTINGS_H\n\n// TODO: These should probably go into a precompiled header or build flags or\n// something.\n#define LOCALIZED true\n#define MATCHING  true\n\n#define USADEMO1 1\n#define USAFINAL 2\n\n#if VERNUM == USAFINAL\n#define BUILDTARGET USAFINAL\n#elif VERNUM == USADEMO1\n#define BUILDTARGET USADEMO1\n#endif\n\n// The following are constants that mods might be interested in tweaking.\n#define GENERATOR_CACHE_HEAP_SIZE 0xA000\n#define CHALLENGE_COURSE_COUNT    30\n\n#endif\n/* end \"BuildSettings.h\" */\n\n// r2 is  8051E360\n// r13 is 8051C680\n\ntypedef int BOOL;\n\ntypedef signed char s8;\ntypedef signed short s16;\ntypedef signed long s32;\ntypedef signed long long s64;\ntypedef unsigned char u8;\ntypedef unsigned short u16;\ntypedef unsigned int uint;\ntypedef unsigned long u32;\ntypedef unsigned long size_t;\ntypedef unsigned long long u64;\n\ntypedef volatile u8 vu8;\ntypedef volatile u16 vu16;\ntypedef volatile u32 vu32;\ntypedef volatile u64 vu64;\ntypedef volatile s8 vs8;\ntypedef volatile s16 vs16;\ntypedef volatile s32 vs32;\ntypedef volatile s64 vs64;\n\ntypedef float f32;\ntypedef double f64;\ntypedef volatile f32 vf32;\ntypedef volatile f64 vf64;\n\ntypedef u32 unknown;\n\n#ifndef __cplusplus\ntypedef unsigned short wchar_t;\n#endif\n\n// Basic defines to allow newer-like C++ code to be written\n#define TRUE  1\n#define FALSE 0\n#define NULL  ((void*)0)\n#define nullptr 0\n\n// Sets specific flag to 1\n#define SET_FLAG(x, val) (x |= (val))\n\n// Resets specific flag from (val) back to 0\n#define RESET_FLAG(x, val) (x &= ~(val))\n\n// Return 1 if flag is set, 0 if flag is not set\n#define IS_FLAG(x, val) (x & val)\n\n// Array size define\n#define ARRAY_SIZE(o) (sizeof((o)) / sizeof(*(o)))\n\n// Align X to the previous N bytes (N must be power of two)\n#define ALIGN_PREV(X, N) ((X) & ~((N)-1))\n\n// Align X to the next N bytes (N must be power of two)\n#define ALIGN_NEXT(X, N) ALIGN_PREV(((X) + (N)-1), N)\n\n// True if X is aligned to N bytes, else false\n#define IS_ALIGNED(X, N) ((X & ((N)-1)) == 0)\n\n// True if X is not aligned to N bytes, else false\n#define IS_NOT_ALIGNED(X, N) (((X) & ((N)-1)) != 0)\n\n// Align object to num bytes (num should be power of two)\n#define ATTRIBUTE_ALIGN(num) __attribute__((aligned(num)))\n\n#define IS_FLAG_SET(flags, bitsFromLSB) (((flags) >> (bitsFromLSB)&1))\n\n// For functions that return 0 on a success and -1 on failure\n#define EXIT_SUCCESS 0\n#define EXIT_FAILURE -1\n\n#define ASSERT_HANG(cond) \\\n\tif (!(cond)) {        \\\n\t\twhile (true) { }  \\\n\t}\n\n// Get the maximum of two values\n#define MAX(a, b) (((a) > (b)) ? (a) : (b))\n\n// Get the minimum of two values\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n\n// number of bytes in a kilobyte\n#define KILOBYTE_BYTECOUNT 1024\n\n#ifdef __MWERKS__\n#define WEAKFUNC __declspec(weak)\n#else\n#define WEAKFUNC ;\n#endif\n\n#endif\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\gx.h\" line 9 \"Dolphin/vi.h\" */\n#ifndef _DOLPHIN_VI_H\n#define _DOLPHIN_VI_H\n\n/* \"include\\Dolphin\\vi.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n////// VIDEO INTERFACE DEFINES /////\n// Display pixel size.\n#define VI_DISPLAY_PIX_SZ (2)\n\n// Interlacing types\n#define VI_INTERLACE     (0)\n#define VI_NON_INTERLACE (1)\n#define VI_PROGRESSIVE   (2)\n#define VI_3D            (3)\n\n// Video output formats\n#define VI_NTSC      (0)\n#define VI_PAL       (1)\n#define VI_MPAL      (2)\n#define VI_DEBUG     (3)\n#define VI_DEBUG_PAL (4)\n#define VI_EURGB60   (5)\n#define VI_GCA       (6)\n\n// Conversion to TVMode used in enums\n#define VI_TVMODE(FMT, INT) (((FMT) << 2) + (INT))\n\n// Fields\n#define VI_FIELD_ABOVE (1)\n#define VI_FIELD_BELOW (0)\n\n// Max screen dimensions\n// NTSC\n#define VI_MAX_WIDTH_NTSC  (720)\n#define VI_MAX_HEIGHT_NTSC (480)\n\n// PAL\n#define VI_MAX_WIDTH_PAL  (720)\n#define VI_MAX_HEIGHT_PAL (574)\n\n// MPAL\n#define VI_MAX_WIDTH_MPAL  (720)\n#define VI_MAX_HEIGHT_MPAL (480)\n\n// EU RGB60 (same as NTSC)\n#define VI_MAX_WIDTH_EURGB60  VI_MAX_WIDTH_NTSC\n#define VI_MAX_HEIGHT_EURGB60 VI_MAX_HEIGHT_NTSC\n\n// Conversion to padded FB width from screen width\n#define VIPadFrameBufferWidth(width) ((u16)(((u16)(width) + 15) & ~15))\n\n////////////////////////////////////\n\n/////// VIDEO INTERFACE TYPES //////\n// Retrace callback function type.\ntypedef void (*VIRetraceCallback)(u32 retraceCount);\n\n// Position callback function type.\ntypedef void (*VIPositionCallback)(s16 x, s16 y);\n\n// TV Modes\ntypedef enum {\n\t// NTSC\n\tVI_TVMODE_NTSC_INT  = VI_TVMODE(VI_NTSC, VI_INTERLACE),     // 0\n\tVI_TVMODE_NTSC_DS   = VI_TVMODE(VI_NTSC, VI_NON_INTERLACE), // 1\n\tVI_TVMODE_NTSC_PROG = VI_TVMODE(VI_NTSC, VI_PROGRESSIVE),   // 2\n\tVI_TVMODE_NTSC_3D   = VI_TVMODE(VI_NTSC, VI_3D),            // 3\n\n\t// PAL\n\tVI_TVMODE_PAL_INT = VI_TVMODE(VI_PAL, VI_INTERLACE),     // 4\n\tVI_TVMODE_PAL_DS  = VI_TVMODE(VI_PAL, VI_NON_INTERLACE), // 5\n\n\t// MPAL\n\tVI_TVMODE_MPAL_INT = VI_TVMODE(VI_MPAL, VI_INTERLACE),     // 8\n\tVI_TVMODE_MPAL_DS  = VI_TVMODE(VI_MPAL, VI_NON_INTERLACE), // 9\n\n\t// Debug\n\tVI_TVMODE_DEBUG_INT = VI_TVMODE(VI_DEBUG, VI_INTERLACE), // 12\n\n\t// Debug PAL\n\tVI_TVMODE_DEBUG_PAL_INT = VI_TVMODE(VI_DEBUG_PAL, VI_INTERLACE),     // 16\n\tVI_TVMODE_DEBUG_PAL_DS  = VI_TVMODE(VI_DEBUG_PAL, VI_NON_INTERLACE), // 17\n\n\t// EU RGB60\n\tVI_TVMODE_EURGB60_INT = VI_TVMODE(VI_EURGB60, VI_INTERLACE),     // 20\n\tVI_TVMODE_EURGB60_DS  = VI_TVMODE(VI_EURGB60, VI_NON_INTERLACE), // 21\n\n\t// GCA\n\tVI_TVMODE_GCA_INT  = VI_TVMODE(VI_GCA, VI_INTERLACE),     // 24\n\tVI_TVMODE_GCA_DS   = VI_TVMODE(VI_GCA, VI_NON_INTERLACE), // 25\n\tVI_TVMODE_GCA_PROG = VI_TVMODE(VI_GCA, VI_PROGRESSIVE),   // 26\n} VITVMode;\n\n// External frame buffer modes (single and double?)\ntypedef enum {\n\tVI_XFBMODE_SF = 0,\n\tVI_XFBMODE_DF = 1,\n} VIXFBMode;\n\n// Structure to use with timing in vi.c (size 0x28).\ntypedef struct VITimingInfo {\n\tu8 equ;           // _00\n\tu16 acv;          // _02\n\tu16 prbOdd;       // _04\n\tu16 prbEven;      // _06\n\tu16 psbOdd;       // _08\n\tu16 psbEven;      // _0A\n\tu8 bs1;           // _0C\n\tu8 bs2;           // _0D\n\tu8 bs3;           // _0E\n\tu8 bs4;           // _0F\n\tu16 be1;          // _10\n\tu16 be2;          // _12\n\tu16 be3;          // _14\n\tu16 be4;          // _16\n\tu16 numHalfLines; // _18\n\tu16 hlw;          // _1A\n\tu8 hsy;           // _1C\n\tu8 hcs;           // _1D\n\tu8 hce;           // _1E\n\tu8 hbe640;        // _1F\n\tu16 hbs640;       // _20\n\tu8 hbeCCIR656;    // _24\n\tu16 hbsCCIR656;   // _26\n} VITimingInfo;\n\n// Structure to use with HorVer in vi.c (size 0x58).\ntypedef struct VIPositionInfo {\n\tu16 dispPosX;         // _00\n\tu16 dispPosY;         // _02\n\tu16 dispSizeX;        // _04\n\tu16 dispSizeY;        // _06\n\tu16 adjDispPosX;      // _08\n\tu16 adjDispPosY;      // _0A\n\tu16 adjDispSizeY;     // _0C\n\tu16 adjPanPosY;       // _0E\n\tu16 adjPanSizeY;      // _10\n\tu16 fbSizeX;          // _12\n\tu16 fbSizeY;          // _14\n\tu16 panPosX;          // _16\n\tu16 panPosY;          // _18\n\tu16 panSizeX;         // _1A\n\tu16 panSizeY;         // _1C\n\tVIXFBMode xfbMode;    // _20\n\tu32 nonInter;         // _24\n\tu32 tv;               // _28\n\tu8 wordPerLine;       // _2C\n\tu8 std;               // _2D\n\tu8 wpl;               // _2E\n\tu32 bufAddr;          // _30\n\tu32 tfbb;             // _34\n\tu32 bfbb;             // _38\n\tu8 xof;               // _3C\n\tBOOL isBlack;         // _40\n\tBOOL is3D;            // _44\n\tu32 rbufAddr;         // _48\n\tu32 rtfbb;            // _4C\n\tu32 rbfbb;            // _50\n\tVITimingInfo* timing; // _54\n} VIPositionInfo;\n\n////////////////////////////////////\n\n///// VIDEO INTERFACE FUNCTIONS ////\n// Basic VI functions.\nvoid VIInit(void);\nvoid VIFlush(void);\nvoid VIWaitForRetrace(void);\n\n// Configure functions.\nvoid VIConfigure(const struct _GXRenderModeObj* obj);\n\n// Retrace callbacks.\nVIRetraceCallback VISetPreRetraceCallback(VIRetraceCallback callback);\nVIRetraceCallback VISetPostRetraceCallback(VIRetraceCallback callback);\n\n// Getters and setters\nvoid VISetNextFrameBuffer(void* fb);\nvoid* VIGetCurrentFrameBuffer();\n\nvoid __VIGetCurrentPosition(s16* x, s16* y);\n\nvoid VISetBlack(BOOL isBlack);\n\nu32 VIGetRetraceCount(void);\nu32 VIGetNextField(void);\nu32 VIGetCurrentLine(void);\nu32 VIGetTvFormat(void);\n\nu32 VIGetDTVStatus(void);\n\n// Unused/stripped in P2.\nvoid VIConfigurePan(u16 panPosX, u16 panPosY, u16 panSizeX, u16 panSizeY);\nvoid* VIGetNextFrameBuffer();\nvoid VISetNextRightFrameBuffer(void* fb);\nvoid VISet3D(); // unsure on arguments\n\n////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/vi.h\" */\n/* \"include\\Dolphin\\gx.h\" line 10 \"Dolphin/mtx.h\" */\n#ifndef _DOLPHIN_MTX_H\n#define _DOLPHIN_MTX_H\n\n/* \"include\\Dolphin\\mtx.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\mtx.h\" line 9 \"Dolphin/vec.h\" */\n#ifndef _DOLPHIN_VEC_H\n#define _DOLPHIN_VEC_H\n\n/* \"include\\Dolphin\\vec.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\ntypedef struct Vec {\n\tf32 x;\n\tf32 y;\n\tf32 z;\n} Vec;\n\nvoid PSVECAdd(const Vec*, const Vec*, Vec*);\nvoid PSVECSubtract(const Vec*, const Vec*, Vec*);\nvoid PSVECNormalize(const Vec*, Vec*);\nf32 PSVECMag(const Vec*);\nvoid PSVECCrossProduct(const Vec*, const Vec*, Vec*);\n\n#ifdef __cplusplus\n}\n#endif\n\n//  lfs     f1,0(r3)\n//  lfs     f0,4(r3)\n//  fmuls   f1,f1,f1\n//  lfs     f2,8(r3)\n//  fmuls   f0,f0,f0\n//  fmuls   f2,f2,f2\n//  fadds   f0,f1,f0\n//  fadds   f1,f2,f0\n//  blr\n\n#endif\n/* end \"Dolphin/vec.h\" */\n\n/////////////// TYPE DEFINES ///////////////\n#define MTXDegToRad(a) ((a)*0.01745329252f)\n\ntypedef f32 Mtx[3][4];\ntypedef f32 Mtx23[2][3];\ntypedef f32 Mtx33[3][3];\ntypedef f32 Mtx44[4][4];\ntypedef f32 (*MtxP)[4];\ntypedef f32 PSQuaternion[4];\n\ntypedef struct Quaternion {\n\tf32 x, y, z, w;\n} Quaternion;\n\n////////////////////////////////////////////\n\n////// PAIRED SINGLE MATRIX FUNCTIONS //////\nvoid PSMTXIdentity(Mtx mtx);\nvoid PSMTXCopy(const Mtx src, Mtx dest);\nvoid PSMTXConcat(const Mtx A, const Mtx B, Mtx concat);\n\nvoid PSMTXTranspose(const Mtx src, Mtx xPose);\nu32 PSMTXInverse(const Mtx src, Mtx inv);\n\nvoid __PSMTXRotAxisRadInternal(Mtx mtx, const Vec* axis, f32 sinA, f32 cosA);\nvoid PSMTXRotRad(Mtx mtx, char axis, f32 angle);\nvoid PSMTXRotTrig(Mtx mtx, char axis, f32 sinA, f32 cosA);\nvoid PSMTXRotAxisRad(Mtx mtx, const Vec* axis, f32 angle);\n\nvoid PSMTXTrans(Mtx mtx, f32 xT, f32 yT, f32 zT);\nvoid PSMTXTransApply(const Mtx src, Mtx dest, f32 xT, f32 yT, f32 zT);\n\nvoid PSMTXScale(Mtx mtx, f32 xS, f32 yS, f32 zS);\nvoid PSMTXScaleApply(const Mtx src, Mtx dest, f32 xS, f32 yS, f32 zS);\nvoid PSMTXQuat(Mtx mtx, const PSQuaternion* quat);\n\n////////////////////////////////////////////\n\n//// PAIRED SINGLE MATRIX VEC FUNCTIONS ////\nvoid PSMTXMultVec(const Mtx, const Vec*, Vec*);\nvoid PSMTXMultVecSR(const Mtx, const Vec*, Vec*);\nvoid PSMTXMultVecArraySR(const Mtx, f32*, f32*, f32*);\n\n////////////////////////////////////////////\n\n///////////  MATRIX44 FUNCTIONS ////////////\nvoid PSMTX44Copy(Mtx44 src, Mtx44 dest);\nvoid C_MTXPerspective(Mtx44 mtx, f32 fovY, f32 aspect, f32 n, f32 f);\nvoid C_MTXOrtho(Mtx44 mtx, f32 t, f32 b, f32 l, f32 r, f32 n, f32 f);\n////////////////////////////////////////////\n\n///////// CODED C MATRIX FUNCTIONS /////////\nvoid C_MTXLookAt(Mtx, const Vec*, const Vec*, const Vec*);\nvoid C_MTXLightPerspective(Mtx mtx, f32 fovY, f32 aspect, f32 scaleS, f32 scaleT, f32 transS, f32 transT);\nvoid C_MTXLightOrtho(Mtx mtx, f32 t, f32 b, f32 l, f32 r, f32 scaleS, f32 scaleT, f32 transS, f32 transT);\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n/* end \"Dolphin/mtx.h\" */\n/* \"include\\Dolphin\\gx.h\" line 11 \"Dolphin/GX/GXEnum.h\" */\n#ifndef _DOLPHIN_GXENUM_H\n#define _DOLPHIN_GXENUM_H\n\n/* \"include\\Dolphin\\GX\\GXEnum.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n////////////////// BASICS //////////////////\n// Set up custom GX bool\ntypedef u8 GXBool;\n\n#define GX_TRUE    ((GXBool)1)\n#define GX_FALSE   ((GXBool)0)\n#define GX_ENABLE  ((GXBool)1)\n#define GX_DISABLE ((GXBool)0)\n\n#define GX_LARGE_NUMBER 1.0e+18f;\n\n// Logical comparison operators.\ntypedef enum _GXCompare {\n\tGX_NEVER   = 0, // never true\n\tGX_LESS    = 1, // <\n\tGX_EQUAL   = 2, // ==\n\tGX_LEQUAL  = 3, // <=\n\tGX_GREATER = 4, // >\n\tGX_NEQUAL  = 5, // !=\n\tGX_GEQUAL  = 6, // >=\n\tGX_ALWAYS  = 7, // always true\n} GXCompare;\ntypedef GXCompare _SDK_GXCompare;\n\n// Logical operation types.\n// Source is the input coefficient and Destination is the output coefficient.\ntypedef enum _GXLogicOp {\n\tGX_LO_CLEAR   = 0,  // 0x00\n\tGX_LO_AND     = 1,  // Source & Destination\n\tGX_LO_REVAND  = 2,  // Source & ~Destination\n\tGX_LO_COPY    = 3,  // Source\n\tGX_LO_INVAND  = 4,  //~Source & Destination\n\tGX_LO_NOOP    = 5,  // Destination\n\tGX_LO_XOR     = 6,  // Source ^ Destination\n\tGX_LO_OR      = 7,  // Source | Destination\n\tGX_LO_NOR     = 8,  //~(Source | Destination)\n\tGX_LO_EQUIV   = 9,  //~(Source ^ Destination)\n\tGX_LO_INV     = 10, //~Destination\n\tGX_LO_REVOR   = 11, // Source | ~Destination\n\tGX_LO_INVCOPY = 12, //~Source\n\tGX_LO_INVOR   = 13, //~Source | Destination\n\tGX_LO_NAND    = 14, //~(Source & Destination)\n\tGX_LO_SET     = 15, // 0xff\n} GXLogicOp;\n\ntypedef GXLogicOp _SDK_GXLogicOp;\n\n// Primitive types.\ntypedef enum _GXPrimitive {\n\tGX_POINTS        = 0xB8,\n\tGX_LINES         = 0xA8,\n\tGX_LINESTRIP     = 0xB0,\n\tGX_TRIANGLES     = 0x90,\n\tGX_TRIANGLESTRIP = 0x98,\n\tGX_TRIANGLEFAN   = 0xa0,\n\tGX_QUADS         = 0x80,\n} GXPrimitive;\n\n// Position-normal matrix sizes/types.\ntypedef enum _GXPosNrmMtx {\n\tGX_PNMTX0 = 3 * 0, // 0\n\tGX_PNMTX1 = 3 * 1, // 3\n\tGX_PNMTX2 = 3 * 2, // 6\n\tGX_PNMTX3 = 3 * 3, // 9\n\tGX_PNMTX4 = 3 * 4, // 12\n\tGX_PNMTX5 = 3 * 5, // 15\n\tGX_PNMTX6 = 3 * 6, // 18\n\tGX_PNMTX7 = 3 * 7, // 21\n\tGX_PNMTX8 = 3 * 8, // 24\n\tGX_PNMTX9 = 3 * 9, // 27\n} GXPosNrmMtx;\n\n// Command display list opcodes.\ntypedef enum _GXCommand {\n\tGX_CMD_LOAD_INDX_A = 0x20,\n\tGX_CMD_LOAD_INDX_B = 0x28,\n\tGX_CMD_LOAD_INDX_C = 0x30,\n\tGX_CMD_LOAD_INDX_D = 0x38,\n\n\tGX_CMD_LOAD_BP_REG = 0x61,\n\tGX_CMD_LOAD_CP_REG = 0x08,\n\tGX_CMD_LOAD_XF_REG = 0x10,\n\n\tGX_CMD_CALL_DL = 0x40,\n\tGX_CMD_INVL_VC = 0x48,\n\n\tGX_CMD_NOP                 = 0x00,\n\tGX_CMD_DRAW_QUADS          = 0x80,\n\tGX_CMD_DRAW_TRIANGLES      = 0x90,\n\tGX_CMD_DRAW_TRIANGLE_STRIP = 0x98,\n\tGX_CMD_DRAW_TRIANGLE_FAN   = 0xA0,\n\tGX_CMD_DRAW_LINES          = 0xA8,\n\tGX_CMD_DRAW_LINE_STRIP     = 0xB0,\n\tGX_CMD_DRAW_POINTS         = 0xB8,\n} GXCommand;\n\n#define GX_OPCODE_MASK 0xF8\n#define GX_VAT_MASK    0x07\n\n////////////////////////////////////////////\n\n//////////////// ATTRIBUTES ////////////////\n// Name of the vertex attribute or array. Attributes are listed in the ascending\n// order vertex data is required to be sent to the GP.\n// NB: havent confirmed the GX docs match pikmin 2 here\ntypedef enum _GXAttr {\n\tGX_VA_PNMTXIDX   = 0, // Position coordinate/normal matrix index.\n\tGX_VA_TEX0MTXIDX = 1, // GX_TXCOORD0 matrix index.\n\tGX_VA_TEX1MTXIDX = 2, // GX_TXCOORD1 matrix index.\n\tGX_VA_TEX2MTXIDX = 3, // GX_TXCOORD2 matrix index.\n\tGX_VA_TEX3MTXIDX = 4, // GX_TXCOORD3 matrix index.\n\tGX_VA_TEX4MTXIDX = 5, // GX_TXCOORD4 matrix index.\n\tGX_VA_TEX5MTXIDX = 6, // GX_TXCOORD5 matrix index.\n\tGX_VA_TEX6MTXIDX = 7, // GX_TXCOORD6 matrix index.\n\tGX_VA_TEX7MTXIDX = 8, // GX_TXCOORD7 matrix index.\n\n\tGX_VA_POS  = 9,  // Position coordinates.\n\tGX_VA_NRM  = 10, // Normal.\n\tGX_VA_CLR0 = 11, // Color 0.\n\tGX_VA_CLR1 = 12, // Color 1.\n\tGX_VA_TEX0 = 13, // Texture coordinate 0.\n\tGX_VA_TEX1 = 14, // Texture coordinate 1.\n\tGX_VA_TEX2 = 15, // Texture coordinate 2.\n\tGX_VA_TEX3 = 16, // Texture coordinate 3.\n\tGX_VA_TEX4 = 17, // Texture coordinate 4.\n\tGX_VA_TEX5 = 18, // Texture coordinate 5.\n\tGX_VA_TEX6 = 19, // Texture coordinate 6.\n\tGX_VA_TEX7 = 20, // Texture coordinate 7.\n\n\tGX_POS_MTX_ARRAY = 21, // Position coordinates matrix array.\n\tGX_NRM_MTX_ARRAY = 22, // Normal matrix array.\n\tGX_TEX_MTX_ARRAY = 23, // Texture matrix array.\n\tGX_LIGHT_ARRAY   = 24, // Light structure array.\n\tGX_VA_NBT        = 25, // Normal/bi-normal/tangent.\n\n\tGX_VA_MAX_ATTR, // Max number of attributes (26).\n\n\tGX_VA_NULL = 0xFF, // Indicates that it is none of these data types.\n} GXAttr;\n\n#define GX_MAX_VTXARRAY 16\n\n// Type of vertex attribute reference.\n// NB: havent confirmed the GX docs match pikmin 2 here\ntypedef enum _GXAttrType {\n\tGX_NONE    = 0, // No data to be sent.\n\tGX_DIRECT  = 1, // Value sent is value of data.\n\tGX_INDEX8  = 2, // Value sent is INDEX value of data array (8-bit).\n\tGX_INDEX16 = 3, // Value sent is INDEX value of data array (16-bit).\n} GXAttrType;\n\n// Vertex format IDs.\n// NB: havent confirmed the GX docs match pikmin 2 here\ntypedef enum _GXVtxFmt {\n\tGX_VTXFMT0 = 0, // Vertex attribute format ID 0.\n\tGX_VTXFMT1 = 1, // Vertex attribute format ID 1.\n\tGX_VTXFMT2 = 2, // Vertex attribute format ID 2.\n\tGX_VTXFMT3 = 3, // Vertex attribute format ID 3.\n\tGX_VTXFMT4 = 4, // Vertex attribute format ID 4.\n\tGX_VTXFMT5 = 5, // Vertex attribute format ID 5.\n\tGX_VTXFMT6 = 6, // Vertex attribute format ID 6.\n\tGX_VTXFMT7 = 7, // Vertex attribute format ID 7.\n\n\tGX_MAX_VTXFMT, // Max vertex formats (8)\n} GXVtxFmt;\n\n// Number of components in an attribute.\n// NB: havent confirmed the GX docs match pikmin 2 here\ntypedef enum _GXCompCnt {\n\tGX_POS_XY  = 0, // Position X, Y (two components).\n\tGX_POS_XYZ = 1, // Position X, Y, Z (three components).\n\n\tGX_NRM_XYZ  = 0, // Normal X, Y, Z (three components).\n\tGX_NRM_NBT  = 1, // Normal, binormal, tangent (three components).\n\tGX_NRM_NBT3 = 2, // Normal, binormal, tangent (three components). Use when NBT\n\t                 // normal is indexed independently.\n\n\tGX_CLR_RGB  = 0, // RGB (three components).\n\tGX_CLR_RGBA = 1, // RGBA (four components).\n\n\tGX_TEX_S  = 0, // Texture coordinate S (one component).\n\tGX_TEX_ST = 1, // Texture coordinates S, T (two components).\n\n\tGX_COMPCNT_NULL = 0, // Null count.\n} GXCompCnt;\n\n// Type of components in an attribute.\n// NB: havent confirmed the GX docs match pikmin 2 here\ntypedef enum _GXCompType {\n\tGX_U8  = 0, // Unsigned 8-bit.\n\tGX_S8  = 1, // Signed 8-bit.\n\tGX_U16 = 2, // Unsigned 16-bit.\n\tGX_S16 = 3, // Signed 16-bit.\n\tGX_F32 = 4, // Floating-point 32-bit.\n\n\tGX_RGB565 = 0, // RGB565 16-bit.\n\tGX_RGB8   = 1, // RGB888 24-bit.\n\tGX_RGBX8  = 2, // RGB888x 32-bit.\n\tGX_RGBA4  = 3, // RGBA4444 16-bit.\n\tGX_RGBA6  = 4, // RGBA6666 24-bit.\n\tGX_RGBA8  = 5, // RGBA8888 32-bit.\n\n\tGX_COMP_NULL = 0, // Null type.\n} GXCompType;\n\n// Anisotropy (direction-dependent) types.\n// NB: unsure what each type means.\ntypedef enum _GXAnisotropy {\n\tGX_ANISO_1 = 0,\n\tGX_ANISO_2 = 1,\n\tGX_ANISO_4 = 2,\n\n\tGX_MAX_ANISOTROPY, // Max types (3).\n} GXAnisotropy;\n\n////////////////////////////////////////////\n\n///////////// LIGHT/FOG/BLEND //////////////\n// Light levels.\ntypedef enum _GXLightID {\n\tGX_LIGHT_NULL = 0x0,\n\tGX_LIGHT0     = 0x1,\n\tGX_LIGHT1     = 0x2,\n\tGX_LIGHT2     = 0x4,\n\tGX_LIGHT3     = 0x8,\n\tGX_LIGHT4     = 0x10,\n\tGX_LIGHT5     = 0x20,\n\tGX_LIGHT6     = 0x40,\n\tGX_LIGHT7     = 0x80,\n\tGX_MAX_LIGHT  = 0x100,\n} GXLightID;\n\n// Diffuse light functions.\ntypedef enum _GXDiffuseFn {\n\tGX_DF_NONE  = 0,\n\tGX_DF_SIGN  = 1,\n\tGX_DF_CLAMP = 2,\n} GXDiffuseFn;\n\n// Light attenuation functions.\ntypedef enum _GXAttnFn {\n\tGX_AF_SPEC = 0, // Specular attenuation.\n\tGX_AF_SPOT = 1, // Spotlight/distance attenuation.\n\tGX_AF_NONE = 2, // Attenuation off.\n} GXAttnFn;\n\n// Spotlight attenuation functions.\ntypedef enum _GXSpotFn {\n\tGX_SP_OFF   = 0,\n\tGX_SP_FLAT  = 1,\n\tGX_SP_COS   = 2,\n\tGX_SP_COS2  = 3,\n\tGX_SP_SHARP = 4,\n\tGX_SP_RING1 = 5,\n\tGX_SP_RING2 = 6,\n} GXSpotFn;\n\n// Distance attentuation functions.\ntypedef enum _GXDistAttnFn {\n\tGX_DA_OFF    = 0,\n\tGX_DA_GENTLE = 1,\n\tGX_DA_MEDIUM = 2,\n\tGX_DA_STEEP  = 3,\n} GXDistAttnFn;\n\n// Fog density functions for perspective projection mode.\ntypedef enum _GXFogType {\n\tGX_FOG_NONE       = 0, // No fog.\n\tGX_FOG_LINEAR     = 2, // Linear density.\n\tGX_FOG_EXPONENT   = 4, // Exponential density.\n\tGX_FOG_EXPONENT2  = 5, // Exponential-squared density.\n\tGX_FOG_REVERSEEXP = 6, // Inverse exponential density.\n\tGX_FOG_REVERSEXP2 = 7  // Inverse exponential-squared density.\n} GXFogType;\n\ntypedef GXFogType _SDK_GXFogType;\n\n// Blending type.\ntypedef enum _GXBlendMode {\n\tGX_BM_NONE     = 0, // No blending.\n\tGX_BM_BLEND    = 1, // Blending.\n\tGX_BM_LOGIC    = 2, // Logic operations.\n\tGX_BM_SUBTRACT = 3, // Subtractive blending.\n\tGX_MAX_BLENDMODE,   // Max blend modes (4).\n} GXBlendMode;\n\ntypedef GXBlendMode _SDK_GXBlendMode;\n\n// Blending controls. Dest = frame buffer, src = current/source.\ntypedef enum _GXBlendFactor {\n\tGX_BL_ZERO        = 0, // 0.0\n\tGX_BL_ONE         = 1, // 1.0\n\tGX_BL_SRCCOL      = 2,\n\tGX_BL_DSTCOL      = GX_BL_SRCCOL, // Frame buffer color, Source color\n\tGX_BL_INVSRCCOL   = 3,\n\tGX_BL_INVDSTCOL   = GX_BL_INVSRCCOL, // 1.0 - (Frame buffer color), 1.0 - (Source color)\n\tGX_BL_SRCALPHA    = 4,               // Source alpha\n\tGX_BL_INVSRCALPHA = 5,               // 1.0 - (Source alpha)\n\tGX_BL_DSTALPHA    = 6,               // Frame buffer alpha\n\tGX_BL_INVDSTALPHA = 7,               // 1.0 - (Frame buffer alpha)\n} GXBlendFactor;\n\ntypedef GXBlendFactor _SDK_GXBlendFactor;\n\n////////////////////////////////////////////\n\n/////////////// MANIP MODES ////////////////\n// Culling modes.\ntypedef enum _GXCullMode {\n\tGX_CULL_NONE  = 0,\n\tGX_CULL_FRONT = 1,\n\tGX_CULL_BACK  = 2,\n\tGX_CULL_ALL   = 3,\n} GXCullMode;\n\n// Clipping modes.\n// NB: These are deliberately reversed from normal on/off.\ntypedef enum _GXClipMode {\n\tGX_CLIP_ENABLE  = 0,\n\tGX_CLIP_DISABLE = 1,\n} GXClipMode;\n\n// Copy modes.\ntypedef enum _GXCopyMode {\n\tGX_COPY_PROGRESSIVE = 0,\n\tGX_COPY_INTLC_EVEN  = 2,\n\tGX_COPY_INTLC_ODD   = 3,\n} GXCopyMode;\n\n////////////////////////////////////////////\n\n/////////////// COLOR MANIP ////////////////\n// Color Channel IDs.\ntypedef enum _GXChannelID {\n\tGX_COLOR0      = 0, // Color 0.\n\tGX_COLOR1      = 1, // Color 1.\n\tGX_ALPHA0      = 2, // Alpha 0.\n\tGX_ALPHA1      = 3, // Alpha 1.\n\tGX_COLOR0A0    = 4, // Color 0 + Alpha 0.\n\tGX_COLOR1A1    = 5, // Color 1 + Alpha 1.\n\tGX_COLOR_ZERO  = 6, // RGBA = 0.\n\tGX_ALPHA_BUMP  = 7, // Bump alpha 0-248, RGB = 0.\n\tGX_ALPHA_BUMPN = 8, // Norm bump alpha 0-255, RGB = 0.\n\n\tGX_COLOR_NULL = 0xFF, // Null channel.\n} GXChannelID;\n\n// Color sources.\ntypedef enum _GXColorSrc {\n\tGX_SRC_REG = 0, // Source from register (?).\n\tGX_SRC_VTX = 1, // Source from vertex.\n} GXColorSrc;\n\n// Alpha operators.\ntypedef enum _GXAlphaOp {\n\tGX_AOP_AND  = 0,\n\tGX_AOP_OR   = 1,\n\tGX_AOP_XOR  = 2,\n\tGX_AOP_XNOR = 3,\n\n\tGX_MAX_ALPHAOP, // Max num alpha operators (4).\n} GXAlphaOp;\n\n// Alpha read mode.\ntypedef enum _GXAlphaReadMode {\n\tGX_READ_00   = 0,\n\tGX_READ_FF   = 1,\n\tGX_READ_NONE = 2,\n} GXAlphaReadMode;\n\n// Gamma modes.\n// NB: not sure what these modes are.\ntypedef enum _GXGamma {\n\tGX_GM_1_0 = 0,\n\tGX_GM_1_7 = 1,\n\tGX_GM_2_2 = 2,\n} GXGamma;\n\n////////////////////////////////////////////\n\n///////////////// TEXTURES /////////////////\n// Texture Coordinate IDs\ntypedef enum _GXTexCoordID {\n\tGX_TEXCOORD0 = 0, // Generated tex coord 0.\n\tGX_TEXCOORD1 = 1, // Generated tex coord 1.\n\tGX_TEXCOORD2 = 2, // Generated tex coord 2.\n\tGX_TEXCOORD3 = 3, // Generated tex coord 3.\n\tGX_TEXCOORD4 = 4, // Generated tex coord 4.\n\tGX_TEXCOORD5 = 5, // Generated tex coord 5.\n\tGX_TEXCOORD6 = 6, // Generated tex coord 6.\n\tGX_TEXCOORD7 = 7, // Generated tex coord 7.\n\n\tGX_MAX_TEXCOORD, // Max num texture coords (8).\n\n\tGX_TEXCOORD_NULL = 0xFF, // Null coordinate.\n} GXTexCoordID;\n\n// Texture generation types.\ntypedef enum _GXTexGenType {\n\tGX_TG_MTX2X4 = 0,\n\tGX_TG_MTX3X4 = 1,\n\n\tGX_TG_BUMP0 = 2,\n\tGX_TG_BUMP1 = 3,\n\tGX_TG_BUMP2 = 4,\n\tGX_TG_BUMP3 = 5,\n\tGX_TG_BUMP4 = 6,\n\tGX_TG_BUMP5 = 7,\n\tGX_TG_BUMP6 = 8,\n\tGX_TG_BUMP7 = 9,\n\n\tGX_TG_SRTG = 10,\n} GXTexGenType;\n\n// Texture generation sources.\ntypedef enum _GXTexGenSrc {\n\tGX_TG_POS     = 0, // Position.\n\tGX_TG_NRM     = 1, // Normal.\n\tGX_TG_BINRM   = 2, // Bi-normal.\n\tGX_TG_TANGENT = 3, // Tangent.\n\n\tGX_TG_TEX0 = 4,  // Texture 0.\n\tGX_TG_TEX1 = 5,  // Texture 1.\n\tGX_TG_TEX2 = 6,  // Texture 2.\n\tGX_TG_TEX3 = 7,  // Texture 3.\n\tGX_TG_TEX4 = 8,  // Texture 4.\n\tGX_TG_TEX5 = 9,  // Texture 5.\n\tGX_TG_TEX6 = 10, // Texture 6.\n\tGX_TG_TEX7 = 11, // Texture 7.\n\n\tGX_TG_TEXCOORD0 = 12, // Tex coord 0.\n\tGX_TG_TEXCOORD1 = 13, // Tex coord 1.\n\tGX_TG_TEXCOORD2 = 14, // Tex coord 2.\n\tGX_TG_TEXCOORD3 = 15, // Tex coord 3.\n\tGX_TG_TEXCOORD4 = 16, // Tex coord 4.\n\tGX_TG_TEXCOORD5 = 17, // Tex coord 5.\n\tGX_TG_TEXCOORD6 = 18, // Tex coord 6. No 7?\n\n\tGX_TG_COLOR0 = 19, // Color 0.\n\tGX_TG_COLOR1 = 20, // Color 1.\n} GXTexGenSrc;\n\n// Texture map names.\n// NB: havent confirmed the GX docs match pikmin 2 here\ntypedef enum _GXTexMapID {\n\tGX_TEXMAP0 = 0, // Texture map ID 0.\n\tGX_TEXMAP1 = 1, // Texture map ID 1.\n\tGX_TEXMAP2 = 2, // Texture map ID 2.\n\tGX_TEXMAP3 = 3, // Texture map ID 3.\n\tGX_TEXMAP4 = 4, // Texture map ID 4.\n\tGX_TEXMAP5 = 5, // Texture map ID 5.\n\tGX_TEXMAP6 = 6, // Texture map ID 6.\n\tGX_TEXMAP7 = 7, // Texture map ID 7.\n\n\tGX_MAX_TEXMAP, // Max num texture map IDs (8).\n\n\tGX_TEXMAP_NULL = 0xFF,  // No textures used.\n\tGX_TEX_DISABLE = 0x100, // No texture map look-up.\n} GXTexMapID;\n\n// Texture format types.\n/*\n * RGB, RGBA, Intensity, Intensity/Alpha, Compressed, and Z texture format\n * types. See GXCITexFmt for information on color index formats. The CTF format\n * is used only by the GXSetTexCopyDst function to specify how data is copied\n * out of the EFB into a texture in main memory. In order to actually use that\n * texture, you must specify a non-copy format of matching size. For example, if\n * copying using GX_CTF_RG8, you would apply the resulting texture using\n * GX_TF_IA8.\n */\n// clang-format off\ntypedef enum _GXTexFmt {\n    // Intensities (I) and RGB/RGBA.\n\tGX_TF_I4     = 0x0, // 4-bit I\n\tGX_TF_I8     = 0x1, // 8-bit I\n\tGX_TF_IA4    = 0x2, // 8-bit I + alpha (4+4).\n\tGX_TF_IA8    = 0x3, // 16-bit I + alpha (8+8).\n\tGX_TF_RGB565 = 0x4, // 16-bit RGB.\n\tGX_TF_RGB5A3 = 0x5, // MSB=1, RGB555 (opaque). MSB=0, RGBA4443 (transparent).\n\tGX_TF_RGBA8  = 0x6, // 32-bit RGB.\n\tGX_TF_CMPR   = 0xE, // Compressed 4-bit texel.\n\n    // Z-texture format.\n\tGX_TF_Z8    = 0x11, // Unsigned 8-bit Z. For texture copies, specify the upper 8 bits of Z.\n\tGX_TF_Z16   = 0x13, // Unsigned 16-bit Z. For texture copies, specify the upper 16 bits of Z.\n\tGX_TF_Z24X8 = 0x16, // Unsigned 24-bit (32-bit texture) Z. For texture copies, copy the 24-bit Z and 0xff.\n\n    // Copy-texture format.\n\tGX_CTF_R4    = 0x20, // 4-bit red. For copying 4 bits from red.\n\tGX_CTF_RA4   = 0x22, // 4-bit red + 4-bit alpha. For copying 4 bits from red, 4 bits from alpha.\n\tGX_CTF_RA8   = 0x23, // 8-bit red + 8-bit alpha. For copying 8 bits from red, 8 bits from alpha.\n    GX_CTF_YUVA8 = 0x26, // 8-bit YUV + alpha. For copying 8 bits from YUV, 8 bits from alpha.\n\tGX_CTF_A8    = 0x26, // 8-bit alpha. For copying 8 bits from alpha.\n\tGX_CTF_R8    = 0x27, // 8-bit red. For copying 8 bits from red.\n\tGX_CTF_G8    = 0x28, // 8-bit green. For copying 8 bits from green.\n\tGX_CTF_B8    = 0x29, // 8-bit blue. For copying 8 bits from blue.\n\tGX_CTF_RG8   = 0x2A, // 8-bit red +8-bit green. For copying 8 bits from red, 8 bits from green.\n\tGX_CTF_GB8   = 0x2B, // 8-bit green +8-bit blue. For copying 8 bits from green, 8 bits from blue.\n\n    // Copy-Z-texture format.\n\tGX_CTF_Z4   = 0x30, // 4-bit Z. For copying the 4 upper bits from Z.\n\tGX_CTF_Z8M  = 0x39, // 8-bit Z (median byte). For copying the middle 8 bits of Z.\n\tGX_CTF_Z8L  = 0x3A, // 8-bit Z (lower byte). For copying the lower 8 bits of Z.\n\tGX_CTF_Z16L = 0x3C, // 16-bit Z (lower portion). For copying the lower 16 bits of Z.\n} GXTexFmt;\n// clang-format on\n\n// Color index formats.\ntypedef enum _GXCITexFmt {\n\tGX_TF_C4    = 0x8,\n\tGX_TF_C8    = 0x9,\n\tGX_TF_C14X2 = 0xA,\n} GXCITexFmt;\n\n// Texture matrix ID.\ntypedef enum _GXTexMtx {\n\tGX_TEXMTX0 = 30 + 0 * 3, // 30, Mtx0\n\tGX_TEXMTX1 = 30 + 1 * 3, // 33, Mtx1\n\tGX_TEXMTX2 = 30 + 2 * 3, // 36, Mtx2\n\tGX_TEXMTX3 = 30 + 3 * 3, // 39, Mtx3\n\tGX_TEXMTX4 = 30 + 4 * 3, // 42, Mtx4\n\tGX_TEXMTX5 = 30 + 5 * 3, // 45, Mtx5\n\tGX_TEXMTX6 = 30 + 6 * 3, // 48, Mtx6\n\tGX_TEXMTX7 = 30 + 7 * 3, // 51, Mtx7\n\tGX_TEXMTX8 = 30 + 8 * 3, // 54, Mtx8\n\tGX_TEXMTX9 = 30 + 9 * 3, // 57, Mtx9\n\n\tGX_IDENTITY = 60, // 60, Identity mtx\n} GXTexMtx;\n\n// Texture matrix type.\ntypedef enum _GXTexMtxType {\n\tGX_MTX3x4 = 0,\n\tGX_MTX2x4 = 1,\n} GXTexMtxType;\n\n// PT Texture matrix ID (?).\ntypedef enum _GXPTTexMtx {\n\tGX_PTTEXMTX0  = 64 + 0 * 3,  // 64, Mtx0\n\tGX_PTTEXMTX1  = 64 + 1 * 3,  // 67, Mtx1\n\tGX_PTTEXMTX2  = 64 + 2 * 3,  // 70, Mtx2\n\tGX_PTTEXMTX3  = 64 + 3 * 3,  // 73, Mtx3\n\tGX_PTTEXMTX4  = 64 + 4 * 3,  // 76, Mtx4\n\tGX_PTTEXMTX5  = 64 + 5 * 3,  // 79, Mtx5\n\tGX_PTTEXMTX6  = 64 + 6 * 3,  // 82, Mtx6\n\tGX_PTTEXMTX7  = 64 + 7 * 3,  // 85, Mtx7\n\tGX_PTTEXMTX8  = 64 + 8 * 3,  // 88, Mtx8\n\tGX_PTTEXMTX9  = 64 + 9 * 3,  // 91, Mtx9\n\tGX_PTTEXMTX10 = 64 + 10 * 3, // 94, Mtx10\n\tGX_PTTEXMTX11 = 64 + 11 * 3, // 97, Mtx11\n\tGX_PTTEXMTX12 = 64 + 12 * 3, // 100, Mtx12\n\tGX_PTTEXMTX13 = 64 + 13 * 3, // 103, Mtx13\n\tGX_PTTEXMTX14 = 64 + 14 * 3, // 106, Mtx14\n\tGX_PTTEXMTX15 = 64 + 15 * 3, // 109, Mtx15\n\tGX_PTTEXMTX16 = 64 + 16 * 3, // 112, Mtx16\n\tGX_PTTEXMTX17 = 64 + 17 * 3, // 115, Mtx17\n\tGX_PTTEXMTX18 = 64 + 18 * 3, // 118, Mtx18\n\tGX_PTTEXMTX19 = 64 + 19 * 3, // 121, Mtx19\n\n\tGX_PTIDENTITY = 125, // 125, Identity mtx\n} GXPTTexMtx;\n\n// Texture offset types.\ntypedef enum _GXTexOffset {\n\tGX_TO_ZERO      = 0,\n\tGX_TO_SIXTEENTH = 1,\n\tGX_TO_EIGHTH    = 2,\n\tGX_TO_FOURTH    = 3,\n\tGX_TO_HALF      = 4,\n\tGX_TO_ONE       = 5,\n\n\tGX_MAX_TEXOFFSET, // Max num texture offset types (6).\n} GXTexOffset;\n\n// Texture wrap modes.\ntypedef enum _GXTexWrapMode {\n\tGX_CLAMP  = 0, // Clamp/cut off at wrap.\n\tGX_REPEAT = 1, // Repeat past wrap.\n\tGX_MIRROR = 2, // Mirror past wrap.\n} GXTexWrapMode;\n\n// Texture filtering types.\ntypedef enum _GXTexFilter {\n\tGX_NEAR          = 0, // Filter near.\n\tGX_LINEAR        = 1, // Filter linear.\n\tGX_NEAR_MIP_NEAR = 2, // Near + MIPmap near.\n\tGX_LIN_MIP_NEAR  = 3, // Linear + MIPmap near.\n\tGX_NEAR_MIP_LIN  = 4, // Near + MIPmap linear.\n\tGX_LIN_MIP_LIN   = 5, // Linear + MIPmap linear.\n} GXTexFilter;\n\n// Texture cache sizes.\ntypedef enum _GXTexCacheSize {\n\tGX_TEXCACHE_32K  = 0, // Small.\n\tGX_TEXCACHE_128K = 1, // Medium.\n\tGX_TEXCACHE_512K = 2, // Large.\n\tGX_TEXCACHE_NONE = 3, // No cache.\n} GXTexCacheSize;\n\n////////////////////////////////////////////\n\n////////// TEXTURE LOOK-UP TABLES //////////\n// Texture look-up table (Tlut) names.\n/*\n * Names of texture lookup tables (TLUTs) in texture memory.\n * Each table GX_TLUT0 through GX_TLUT15 contains 256 entries, at 16 bits per\n * entry. Each table GX_BIGTLUT0 through BIGTLUT3 contains 1024 entries, at 16\n * bits per entry. Used for setting texture memory in the GXInit function.\n */\ntypedef enum _GXTlut {\n\tGX_TLUT0  = 0, // TLUT (256 16-bit entries) ID 0.\n\tGX_TLUT1  = 1,\n\tGX_TLUT2  = 2,\n\tGX_TLUT3  = 3,\n\tGX_TLUT4  = 4,\n\tGX_TLUT5  = 5,\n\tGX_TLUT6  = 6,\n\tGX_TLUT7  = 7,\n\tGX_TLUT8  = 8,\n\tGX_TLUT9  = 9,\n\tGX_TLUT10 = 10,\n\tGX_TLUT11 = 11,\n\tGX_TLUT12 = 12,\n\tGX_TLUT13 = 13,\n\tGX_TLUT14 = 14,\n\tGX_TLUT15 = 15,\n\n\tGX_MAX_TLUT = 16,\n\n\tGX_BIGTLUT0 = 16, // BIGTLUT (1024 16-bit entries) ID 0.\n\tGX_BIGTLUT1 = 17,\n\tGX_BIGTLUT2 = 18,\n\tGX_BIGTLUT3 = 19,\n\n\tGX_MAX_BIGTLUT = 4,\n\n\tGX_MAX_TLUT_ALL = GX_MAX_TLUT + GX_MAX_BIGTLUT, // 20\n} GXTlut;\n\n// Texture look-up (Tlut) formats.\ntypedef enum _GXTlutFmt {\n\tGX_TL_IA8    = 0, // 16-bit intensity + alpha (8I+8A).\n\tGX_TL_RGB565 = 1, // 16-bit RGB (R5+G6+B5).\n\tGX_TL_RGB5A3 = 2, // MSB=1, RGB555 (opaque); MSB=0, RGBA4443 (transparent).\n\n\tGX_MAX_TLUTFMT, // Max number of formats (3).\n} GXTlutFmt;\n\n// Texture look-up (Tlut) sizes.\ntypedef enum _GXTlutSize {\n\tGX_TLUT_16  = 1, // Number of 16 entry blocks.\n\tGX_TLUT_32  = 2,\n\tGX_TLUT_64  = 4,\n\tGX_TLUT_128 = 8,\n\tGX_TLUT_256 = 16,\n\tGX_TLUT_512 = 32,\n\tGX_TLUT_1K  = 64,\n\tGX_TLUT_2K  = 128,\n\tGX_TLUT_4K  = 256,\n\tGX_TLUT_8K  = 512,\n\tGX_TLUT_16K = 1024,\n} GXTlutSize;\n\n////////////////////////////////////////////\n\n//////////// INDIRECT TEXTURES /////////////\n// Indirect texture formats.\ntypedef enum _GXIndTexFormat {\n\tGX_ITF_8 = 0, // 8-bit texture offsets.\n\tGX_ITF_5 = 1, // 5-bit texture offsets.\n\tGX_ITF_4 = 2, // 4-bit texture offsets.\n\tGX_ITF_3 = 3, // 3-bit texture offsets.\n\n\tGX_MAX_ITFORMAT, // Max num formats (4).\n} GXIndTexFormat;\n\n// Indirect texture stage names.\ntypedef enum _GXIndTexStageID {\n\tGX_IND_TEX_STAGE_0 = 0,\n\tGX_IND_TEX_STAGE_1 = 1,\n\tGX_IND_TEX_STAGE_2 = 2,\n\tGX_IND_TEX_STAGE_3 = 3,\n\n\tGX_IND_MAX_TEX_STAGE_ID, // Max num stages (4).\n} GXIndTexStageID;\n\n// Indirect texture matrix IDs.\ntypedef enum _GXIndTexMtxID {\n\tGX_ITM_OFF = 0,\n\tGX_ITM_0   = 1,\n\tGX_ITM_1   = 2,\n\tGX_ITM_2   = 3,\n\n\tGX_ITM_S0 = 5,\n\tGX_ITM_S1 = 6,\n\tGX_ITM_S2 = 7,\n\n\tGX_ITM_T0 = 9,\n\tGX_ITM_T1 = 10,\n\tGX_ITM_T2 = 11,\n} GXIndTexMtxID;\n\n// Indirect texture scaling amounts.\ntypedef enum _GXIndTexScale {\n\tGX_ITS_1   = 0, // Scale by 1.\n\tGX_ITS_2   = 1, // Scale by 1/2.\n\tGX_ITS_4   = 2, // Scale by 1/4.\n\tGX_ITS_8   = 3, // Scale by 1/8.\n\tGX_ITS_16  = 4, // Scale by 1/16.\n\tGX_ITS_32  = 5, // Scale by 1/32.\n\tGX_ITS_64  = 6, // Scale by 1/64.\n\tGX_ITS_128 = 7, // Scale by 1/128.\n\tGX_ITS_256 = 8, // Scale by 1/256.\n\n\tGX_MAX_ITSCALE, // Max scaling types (9)\n} GXIndTexScale;\n\n// Indirect texture wrapping amounts.\ntypedef enum _GXIndTexWrap {\n\tGX_ITW_OFF = 0, // No wrapping.\n\tGX_ITW_256 = 1, // Wrap 256.\n\tGX_ITW_128 = 2, // Wrap 128.\n\tGX_ITW_64  = 3, // Wrap 64.\n\tGX_ITW_32  = 4, // Wrap 32.\n\tGX_ITW_16  = 5, // Wrap 16.\n\tGX_ITW_0   = 6, // Wrap 0.\n\n\tGX_MAX_ITWRAP, // Max wrapping types (7)\n} GXIndTexWrap;\n\n// Indirect texture bias selections.\n// STU = surface coordinate system (s,t,u) with u normal to surface.\ntypedef enum _GXIndTexBiasSel {\n\tGX_ITB_NONE = 0,\n\tGX_ITB_S    = 1,\n\tGX_ITB_T    = 2,\n\tGX_ITB_ST   = 3,\n\tGX_ITB_U    = 4,\n\tGX_ITB_SU   = 5,\n\tGX_ITB_TU   = 6,\n\tGX_ITB_STU  = 7,\n\n\tGX_MAX_ITBIAS, // Max num bias types (8).\n} GXIndTexBiasSel;\n\n// Indirect texture alpha selections.\n// STU = surface coordinate system (s,t,u) with u normal to surface.\ntypedef enum _GXIndTexAlphaSel {\n\tGX_ITBA_OFF = 0,\n\tGX_ITBA_S   = 1,\n\tGX_ITBA_T   = 2,\n\tGX_ITBA_U   = 3,\n\n\tGX_MAX_ITBALPHA, // Max num alpha types (4).\n} GXIndTexAlphaSel;\n\n////////////////////////////////////////////\n\n/////// TEXTURE ENVIRONMENTS (TEV) /////////\n// TEV stage names.\ntypedef enum _GXTevStageID {\n\tGX_TEVSTAGE0  = 0,  // TEV Stage 0.\n\tGX_TEVSTAGE1  = 1,  // TEV Stage 1.\n\tGX_TEVSTAGE2  = 2,  // TEV Stage 2.\n\tGX_TEVSTAGE3  = 3,  // TEV Stage 3.\n\tGX_TEVSTAGE4  = 4,  // TEV Stage 4.\n\tGX_TEVSTAGE5  = 5,  // TEV Stage 5.\n\tGX_TEVSTAGE6  = 6,  // TEV Stage 6.\n\tGX_TEVSTAGE7  = 7,  // TEV Stage 7.\n\tGX_TEVSTAGE8  = 8,  // TEV Stage 8.\n\tGX_TEVSTAGE9  = 9,  // TEV Stage 9.\n\tGX_TEVSTAGE10 = 10, // TEV Stage 10.\n\tGX_TEVSTAGE11 = 11, // TEV Stage 11.\n\tGX_TEVSTAGE12 = 12, // TEV Stage 12.\n\tGX_TEVSTAGE13 = 13, // TEV Stage 13.\n\tGX_TEVSTAGE14 = 14, // TEV Stage 14.\n\tGX_TEVSTAGE15 = 15, // TEV Stage 15.\n\n\tGX_MAXTEVSTAGE, // Max num TEV stages (16).\n} GXTevStageID;\n\n// TEV register names.\ntypedef enum _GXTevRegID {\n\tGX_TEVPREV = 0,\n\tGX_TEVREG0 = 1,\n\tGX_TEVREG1 = 2,\n\tGX_TEVREG2 = 3,\n\n\tGX_MAX_TEVREG, // Max num TEV registers (4).\n} GXTevRegID;\n\n// TEV operations.\ntypedef enum _GXTevOp {\n\tGX_TEV_ADD = 0,\n\tGX_TEV_SUB = 1,\n\n\tGX_TEV_COMP_R8_GT    = 8,\n\tGX_TEV_COMP_R8_EQ    = 9,\n\tGX_TEV_COMP_GR16_GT  = 10,\n\tGX_TEV_COMP_GR16_EQ  = 11,\n\tGX_TEV_COMP_BGR24_GT = 12,\n\tGX_TEV_COMP_BGR24_EQ = 13,\n\n\tGX_TEV_COMP_RGB8_GT = 14,\n\tGX_TEV_COMP_RGB8_EQ = 15,\n\n\tGX_TEV_COMP_A8_GT = GX_TEV_COMP_RGB8_GT, // Alpha channel (14)\n\tGX_TEV_COMP_A8_EQ = GX_TEV_COMP_RGB8_EQ  // Alpha channel (15)\n} GXTevOp;\n\n// TEV mode.\ntypedef enum _GXTevMode {\n\tGX_MODULATE = 0,\n\tGX_DECAL    = 1,\n\tGX_BLEND    = 2,\n\tGX_REPLACE  = 3,\n\tGX_PASSCLR  = 4,\n} GXTevMode;\n\n// TEV color channels.\n// NB: we used to have this called GXTevColor (like TP).\ntypedef enum _GXTevColorChan {\n\tGX_CH_RED   = 0,\n\tGX_CH_GREEN = 1,\n\tGX_CH_BLUE  = 2,\n\tGX_CH_ALPHA = 3,\n} GXTevColorChan;\n\n// TEV color arguments.\ntypedef enum _GXTevColorArg {\n\tGX_CC_CPREV = 0,\n\tGX_CC_APREV = 1,\n\tGX_CC_C0    = 2,\n\tGX_CC_C1    = 3,\n\tGX_CC_C2    = 4,\n\tGX_CC_A0    = 5,\n\tGX_CC_A1    = 6,\n\tGX_CC_A2    = 7,\n\tGX_CC_TEXC  = 8,\n\tGX_CC_TEXA  = 9,\n\tGX_CC_RASC  = 10,\n\tGX_CC_RASA  = 11,\n\tGX_CC_ONE   = 12,\n\tGX_CC_HALF  = 13,\n\tGX_CC_KONST = 14,\n\tGX_CC_ZERO  = 15,\n} GXTevColorArg;\n\n// TEV alpha-specific arguments.\ntypedef enum _GXTevAlphaArg {\n\tGX_CA_APREV = 0,\n\tGX_CA_A0    = 1,\n\tGX_CA_A1    = 2,\n\tGX_CA_A2    = 3,\n\tGX_CA_TEXA  = 4,\n\tGX_CA_RASA  = 5,\n\tGX_KONST    = 6,\n\tGX_ZERO     = 7,\n} GXTevAlphaArg;\n\n// TEV bias.\ntypedef enum _GXTevBias {\n\tGX_TB_ZERO    = 0,\n\tGX_TB_ADDHALF = 1,\n\tGX_TB_SUBHALF = 2,\n\n\tGX_MAX_TEVBIAS, // Max num bias types (3).\n} GXTevBias;\n\n// TEV clamp modes.\ntypedef enum _GXTevClampMode {\n\tGX_TC_LINEAR = 0,\n\tGX_TC_GE     = 1,\n\tGX_TC_EQ     = 2,\n\tGX_TC_LE     = 3,\n\n\tGX_MAX_TEVCLAMPMODE, // Max num clamp modes (4).\n} GXTevClampMode;\n\n// TEV scale types.\ntypedef enum _GXTevScale {\n\tGX_CS_SCALE_1  = 0,\n\tGX_CS_SCALE_2  = 1,\n\tGX_CS_SCALE_4  = 2,\n\tGX_CS_DIVIDE_2 = 3,\n\tGX_MAX_TEVSCALE, // Max num scale types (4).\n} GXTevScale;\n\n// TEV swap selections.\ntypedef enum _GXTevSwapSel {\n\tGX_TEV_SWAP0 = 0,\n\tGX_TEV_SWAP1 = 1,\n\tGX_TEV_SWAP2 = 2,\n\tGX_TEV_SWAP3 = 3,\n\tGX_MAX_TEVSWAP, // Max num swap selections (4).\n} GXTevSwapSel;\n\n// TEV const (konst) color IDs.\ntypedef enum _GXTevKColorID {\n\tGX_KCOLOR0 = 0, // kColor 0.\n\tGX_KCOLOR1 = 1, // kColor 1.\n\tGX_KCOLOR2 = 2, // kColor 2.\n\tGX_KCOLOR3 = 3, // kColor 3.\n\tGX_MAX_KCOLOR,  // Max num kColors (4).\n} GXTevKColorID;\n\n// TEV const (konst) color selections.\ntypedef enum _GXTevKColorSel {\n\tGX_TEV_KCSEL_1   = 0,\n\tGX_TEV_KCSEL_7_8 = 1,\n\tGX_TEV_KCSEL_3_4 = 2,\n\tGX_TEV_KCSEL_5_8 = 3,\n\tGX_TEV_KCSEL_1_2 = 4,\n\tGX_TEV_KCSEL_3_8 = 5,\n\tGX_TEV_KCSEL_1_4 = 6,\n\tGX_TEV_KCSEL_1_8 = 7,\n\n\tGX_TEV_KCSEL_K0 = 12,\n\tGX_TEV_KCSEL_K1 = 13,\n\tGX_TEV_KCSEL_K2 = 14,\n\tGX_TEV_KCSEL_K3 = 15,\n\n\tGX_TEV_KCSEL_K0_R = 16,\n\tGX_TEV_KCSEL_K1_R = 17,\n\tGX_TEV_KCSEL_K2_R = 18,\n\tGX_TEV_KCSEL_K3_R = 19,\n\n\tGX_TEV_KCSEL_K0_G = 20,\n\tGX_TEV_KCSEL_K1_G = 21,\n\tGX_TEV_KCSEL_K2_G = 22,\n\tGX_TEV_KCSEL_K3_G = 23,\n\n\tGX_TEV_KCSEL_K0_B = 24,\n\tGX_TEV_KCSEL_K1_B = 25,\n\tGX_TEV_KCSEL_K2_B = 26,\n\tGX_TEV_KCSEL_K3_B = 27,\n\n\tGX_TEV_KCSEL_K0_A = 28,\n\tGX_TEV_KCSEL_K1_A = 29,\n\tGX_TEV_KCSEL_K2_A = 30,\n\tGX_TEV_KCSEL_K3_A = 31,\n} GXTevKColorSel;\n\n// TEV const (konst) alpha selectors.\ntypedef enum _GXTevKAlphaSel {\n\tGX_TEV_KASEL_1   = 0,\n\tGX_TEV_KASEL_7_8 = 1,\n\tGX_TEV_KASEL_3_4 = 2,\n\tGX_TEV_KASEL_5_8 = 3,\n\tGX_TEV_KASEL_1_2 = 4,\n\tGX_TEV_KASEL_3_8 = 5,\n\tGX_TEV_KASEL_1_4 = 6,\n\tGX_TEV_KASEL_1_8 = 7,\n\n\tGX_TEV_KASEL_K0_R = 16,\n\tGX_TEV_KASEL_K1_R = 17,\n\tGX_TEV_KASEL_K2_R = 18,\n\tGX_TEV_KASEL_K3_R = 19,\n\n\tGX_TEV_KASEL_K0_G = 20,\n\tGX_TEV_KASEL_K1_G = 21,\n\tGX_TEV_KASEL_K2_G = 22,\n\tGX_TEV_KASEL_K3_G = 23,\n\n\tGX_TEV_KASEL_K0_B = 24,\n\tGX_TEV_KASEL_K1_B = 25,\n\tGX_TEV_KASEL_K2_B = 26,\n\tGX_TEV_KASEL_K3_B = 27,\n\n\tGX_TEV_KASEL_K0_A = 28,\n\tGX_TEV_KASEL_K1_A = 29,\n\tGX_TEV_KASEL_K2_A = 30,\n\tGX_TEV_KASEL_K3_A = 31,\n} GXTevKAlphaSel;\n\n////////////////////////////////////////////\n\n/////////// OTHER FORMATS/MODES ////////////\n// Frame buffer pixel formats.\ntypedef enum _GXPixelFmt {\n\tGX_PF_RGB8_Z24   = 0, // Non-antialiased (RGB 888).\n\tGX_PF_RGBA6_Z24  = 1, // Non-antialiased (RGBA 6666).\n\tGX_PF_RGB565_Z16 = 2, // Anti-aliasing.\n\tGX_PF_Z24        = 3,\n\tGX_PF_Y8         = 4,\n\tGX_PF_U8         = 5,\n\tGX_PF_V8         = 6,\n\tGX_PF_YUV420     = 7,\n} GXPixelFmt;\n\ntypedef GXPixelFmt _SDK_GXPixelFmt;\n\n// Compressed Z format.\ntypedef enum _GXZFmt16 {\n\tGX_ZC_LINEAR = 0, // 16-bit linear.\n\tGX_ZC_NEAR   = 1, // Compressed format (14e2) for smaller far/near ratio.\n\tGX_ZC_MID    = 2, // Compressed format (13e3) for medium far/near ratio.\n\tGX_ZC_FAR    = 3, // Compressed format (12e4) for large far/near ratio.\n} GXZFmt16;\n\ntypedef GXZFmt16 _SDK_GXZFmt16;\n\n// Projection types.\ntypedef enum _GXProjectionType {\n\tGX_PERSPECTIVE  = 0,\n\tGX_ORTHOGRAPHIC = 1,\n} GXProjectionType;\n\n// FB clamp types.\ntypedef enum _GXFBClamp {\n\tGX_CLAMP_NONE   = 0,\n\tGX_CLAMP_TOP    = 1,\n\tGX_CLAMP_BOTTOM = 2,\n\tGX_CLAMP_BOTH   = GX_CLAMP_TOP | GX_CLAMP_BOTTOM,\n} GXFBClamp;\n\n// Z-Texture operations.\ntypedef enum _GXZTexOp {\n\tGX_ZT_DISABLE = 0,\n\tGX_ZT_ADD     = 1,\n\tGX_ZT_REPLACE = 2,\n\n\tGX_MAX_ZTEXOP, // Max num operations (3).\n} GXZTexOp;\n\n// Perf-0 types.\ntypedef enum _GXPerf0 {\n\tGX_PERF0_VERTICES      = 0,\n\tGX_PERF0_CLIP_VTX      = 1,\n\tGX_PERF0_CLIP_CLKS     = 2,\n\tGX_PERF0_XF_WAIT_IN    = 3,\n\tGX_PERF0_XF_WAIT_OUT   = 4,\n\tGX_PERF0_XF_XFRM_CLKS  = 5,\n\tGX_PERF0_XF_LIT_CLKS   = 6,\n\tGX_PERF0_XF_BOT_CLKS   = 7,\n\tGX_PERF0_XF_REGLD_CLKS = 8,\n\tGX_PERF0_XF_REGRD_CLKS = 9,\n\tGX_PERF0_CLIP_RATIO    = 10,\n\n\tGX_PERF0_TRIANGLES           = 11,\n\tGX_PERF0_TRIANGLES_CULLED    = 12,\n\tGX_PERF0_TRIANGLES_PASSED    = 13,\n\tGX_PERF0_TRIANGLES_SCISSORED = 14,\n\tGX_PERF0_TRIANGLES_0TEX      = 15,\n\tGX_PERF0_TRIANGLES_1TEX      = 16,\n\tGX_PERF0_TRIANGLES_2TEX      = 17,\n\tGX_PERF0_TRIANGLES_3TEX      = 18,\n\tGX_PERF0_TRIANGLES_4TEX      = 19,\n\tGX_PERF0_TRIANGLES_5TEX      = 20,\n\tGX_PERF0_TRIANGLES_6TEX      = 21,\n\tGX_PERF0_TRIANGLES_7TEX      = 22,\n\tGX_PERF0_TRIANGLES_8TEX      = 23,\n\tGX_PERF0_TRIANGLES_0CLR      = 24,\n\tGX_PERF0_TRIANGLES_1CLR      = 25,\n\tGX_PERF0_TRIANGLES_2CLR      = 26,\n\n\tGX_PERF0_QUAD_0CVG    = 27,\n\tGX_PERF0_QUAD_NON0CVG = 28,\n\tGX_PERF0_QUAD_1CVG    = 29,\n\tGX_PERF0_QUAD_2CVG    = 30,\n\tGX_PERF0_QUAD_3CVG    = 31,\n\tGX_PERF0_QUAD_4CVG    = 32,\n\tGX_PERF0_AVG_QUAD_CNT = 33,\n\n\tGX_PERF0_CLOCKS = 34,\n\tGX_PERF0_NONE   = 35,\n} GXPerf0;\n\n// Perf-1 types.\ntypedef enum _GXPerf1 {\n\tGX_PERF1_TEXELS      = 0,\n\tGX_PERF1_TX_IDLE     = 1,\n\tGX_PERF1_TX_REGS     = 2,\n\tGX_PERF1_TX_MEMSTALL = 3,\n\tGX_PERF1_TC_CHECK1_2 = 4,\n\tGX_PERF1_TC_CHECK3_4 = 5,\n\tGX_PERF1_TC_CHECK5_6 = 6,\n\tGX_PERF1_TC_CHECK7_8 = 7,\n\tGX_PERF1_TC_MISS     = 8,\n\n\tGX_PERF1_VC_ELEMQ_FULL    = 9,\n\tGX_PERF1_VC_MISSQ_FULL    = 10,\n\tGX_PERF1_VC_MEMREQ_FULL   = 11,\n\tGX_PERF1_VC_STATUS7       = 12,\n\tGX_PERF1_VC_MISSREP_FULL  = 13,\n\tGX_PERF1_VC_STREAMBUF_LOW = 14,\n\tGX_PERF1_VC_ALL_STALLS    = 15,\n\tGX_PERF1_VERTICES         = 16,\n\n\tGX_PERF1_FIFO_REQ    = 17,\n\tGX_PERF1_CALL_REQ    = 18,\n\tGX_PERF1_VC_MISS_REQ = 19,\n\tGX_PERF1_CP_ALL_REQ  = 20,\n\n\tGX_PERF1_CLOCKS = 21,\n\tGX_PERF1_NONE   = 22,\n} GXPerf1;\n\n// Vertex cache perf types.\ntypedef enum _GXVCachePerf {\n\tGX_VC_POS  = 0,\n\tGX_VC_NRM  = 1,\n\tGX_VC_CLR0 = 2,\n\tGX_VC_CLR1 = 3,\n\tGX_VC_TEX0 = 4,\n\tGX_VC_TEX1 = 5,\n\tGX_VC_TEX2 = 6,\n\tGX_VC_TEX3 = 7,\n\tGX_VC_TEX4 = 8,\n\tGX_VC_TEX5 = 9,\n\tGX_VC_TEX6 = 10,\n\tGX_VC_TEX7 = 11,\n\n\tGX_VC_ALL = 15\n} GXVCachePerf;\n\n// Miscellaneous token types.\ntypedef enum _GXMiscToken {\n\tGX_MT_NULL               = 0,\n\tGX_MT_XF_FLUSH           = 1,\n\tGX_MT_DL_SAVE_CONTEXT    = 2,\n\tGX_MT_ABORT_WAIT_COPYOUT = 3,\n} GXMiscToken;\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\gx.h\" line 12 \"Dolphin/GX/GXTypes.h\" */\n#ifndef _DOLPHIN_GXTYPES_H\n#define _DOLPHIN_GXTYPES_H\n\n/* \"include\\Dolphin\\GX\\GXTypes.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXTypes.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXTypes.h\" line 10 \"Dolphin/vi.h\" */\n/* end \"Dolphin/vi.h\" */\n\n///////////// USEFUL HELPERS ///////////////\n// Set bitfields manually.\n#define GX_BITFIELD_SET(field, pos, size, value) ((field) = __rlwimi((field), (value), 31 - (pos) - (size) + 1, (pos), (pos) + (size)-1))\n#define LOAD_GX_FIELD(offset, type)              (*(type*)(((u8*)__GXData) + offset))\n#define GX_BITGET(field, pos, size)              ((field) >> (31 - (pos) - (size) + 1) & ((1 << (size)) - 1))\n////////////////////////////////////////////\n\n////////////////// COLORS //////////////////\n// Generic 8-bit-component colors.\ntypedef struct _GXColor {\n\tu8 r, g, b, a; // _00, _01, _02, _03\n} GXColor;\n\n// Signed 10-bit-component colors for TEV const (konst) colors.\ntypedef struct _GXColorS10 {\n\ts16 r, g, b, a; // _00, _02, _04, _06\n} GXColorS10;\n\n////////////////////////////////////////////\n\n///////////////// TEXTURES /////////////////\n// NB: these are all generic structs. Members aren't\n// referenced directly, they only exist for size.\n\n// Generic struct for texture objects.\ntypedef struct _GXTexObj {\n\tu8 pad[0x20]; // _00\n} GXTexObj;       // size 0x20\n\n// Internal struct for texture objects.\ntypedef struct _GXTexObjPriv {\n\tu32 mode0;       // _00\n\tu32 mode1;       // _04\n\tu32 image0;      // _08\n\tu32 image3;      // _0C\n\tvoid* userData;  // _10\n\tGXTexFmt format; // _14\n\tu32 tlutName;    // _18\n\tu16 loadCount;   // _1C\n\tu8 loadFormat;   // _1E\n\tu8 flags;        // _1F\n} GXTexObjPriv;\n\n// Generic struct for texture memory storage.\ntypedef struct _GXTexRegion {\n\tu8 padding[0x10]; // _00\n} GXTexRegion;\n\n// Generic struct for texture look-up table objects.\ntypedef struct _GXTlutObj {\n\tu8 padding[0xC]; // _00\n} GXTlutObj;\n\n// Generic struct for texture look-up table memory storage.\ntypedef struct _GXTlutRegion {\n\tu8 padding[0x10]; // _00\n} GXTlutRegion;\n\n// Generic struct for light information.\ntypedef struct _GXLightObj {\n\tu8 padding[0x40]; // _00\n} GXLightObj;         // size 0x40\n\ntypedef struct __GXLightObjPriv {\n\tu32 reserved[3]; // _00\n\tGXColor color;   // _0C, light color\n\tf32 a[3];        // _10, angle-attenuation coefficients\n\tf32 k[3];        // _1C, distance-attenuation coefficients\n\tf32 lpos[3];     // _28, diffuse: position;  specular: direction\n\tf32 ldir[3];     // _34, diffuse: direction; specular: half-angle\n} GXLightObjPriv;\n\n// TODO: work out what these are. Used in GXTev.c\ntypedef struct _GXTevColorOpTable {\n\tu32 _00; // _00\n\tu32 _04; // _04\n\tu32 _08; // _08\n\tu32 _0C; // _0C\n\tu32 _10; // _10\n} GXTevColorOpTable;\n\n////////////////////////////////////////////\n\n/////////////// VERTEX INFO ////////////////\n// Struct for vertex descriptive info.\ntypedef struct _GXVtxDescList {\n\tGXAttr mAttr;     // _00\n\tGXAttrType mType; // _04\n} GXVtxDescList;\n\n// Struct for vertex attribute formats.\ntypedef struct _GXVtxAttrFmtList {\n\tGXAttr mAttr;     // _00\n\tGXCompCnt mCount; // _04\n\tGXCompType mType; // _08\n\tu8 mFrac;         // _0C\n} GXVtxAttrFmtList;\n\n////////////////////////////////////////////\n\n///////////// OTHER RENDERING //////////////\n// Struct for rendering modes.\ntypedef struct _GXRenderModeObj {\n\tVITVMode viTVmode;        // _00\n\tu16 fbWidth;              // _04, frame buffer width (same for emb. and ext.)\n\tu16 efbHeight;            // _06, embedded frame buffer height\n\tu16 xfbHeight;            // _08, external frame buffer height (may scale emb.)\n\tu16 viXOrigin;            // _0A\n\tu16 viYOrigin;            // _0C\n\tu16 viWidth;              // _0E\n\tu16 viHeight;             // _10\n\tVIXFBMode xFBmode;        // _14, single or double field for external frame buffer\n\tu8 field_rendering;       // _18, rendering fields/frames\n\tu8 aa;                    // _19, is anti-aliasing on\n\tu8 sample_pattern[12][2]; // _1C, anti-aliasing sample pattern\n\tu8 vfilter[7];            // _34, vertical filter coeffs\n} GXRenderModeObj;\n\n// Struct for storing fog adjustment values.\ntypedef struct _GXFogAdjTable {\n\tu16 fogVals[10]; // _00\n} GXFogAdjTable;\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXTypes.h\" */\n/* \"include\\Dolphin\\gx.h\" line 13 \"Dolphin/GX/GXBump.h\" */\n#ifndef _DOLPHIN_GXBUMP_H\n#define _DOLPHIN_GXBUMP_H\n\n/* \"include\\Dolphin\\GX\\GXBump.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXBump.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXBump.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n/* \"include\\Dolphin\\GX\\GXBump.h\" line 11 \"Dolphin/mtx.h\" */\n/* end \"Dolphin/mtx.h\" */\n\n////////////// BUMP FUNCTIONS //////////////\n// Flush functions.\nextern void __GXFlushTextureState();\n\n// Indirect texture functions.\nextern void GXSetTevIndirect(GXTevStageID tevStage, GXIndTexStageID indStage, GXIndTexFormat format, GXIndTexBiasSel bias,\n                             GXIndTexMtxID mtx, GXIndTexWrap sWrap, GXIndTexWrap tWrap, GXBool doAddPrev, GXBool isIndLOD,\n                             GXIndTexAlphaSel alpha);\nextern void GXSetIndTexMtx(GXIndTexMtxID mtx, const Mtx23 offsets, s8 scale);\nextern void GXSetIndTexCoordScale(GXIndTexStageID stage, GXIndTexScale sScale, GXIndTexScale tScale);\nextern void GXSetIndTexOrder(GXIndTexStageID stage, GXTexCoordID texCoord, GXTexMapID texMap);\nextern void GXSetNumIndStages(u8 stageCount);\nextern void __GXSetIndirectMask(u32 mask);\n\n// Convenience functions.\nextern void GXSetTevDirect(GXTevStageID stage);\nextern void GXSetTevIndWarp(GXTevStageID tevStage, GXIndTexStageID indStage, GXBool isSignedOffset, GXBool isReplaceMode,\n                            GXIndTexMtxID mtx);\n\n// Unused/inlined in P2.\nextern void GXSetTevIndTile(GXTevStageID tevStage, GXIndTexStageID indStage, u16 sTileSize, u16 tTileSize, u16 sTileSpacing,\n                            u16 tTileSpacing, GXIndTexFormat format, GXIndTexMtxID mtx, GXIndTexBiasSel bias, GXIndTexAlphaSel alpha);\nextern void GXSetTevIndBumpST(GXTevStageID tevStage, GXIndTexStageID indStage, GXIndTexMtxID mtx);\nextern void GXSetTevIndBumpXYZ(GXTevStageID tevStage, GXIndTexStageID indStage, GXIndTexMtxID mtx);\nextern void GXSetTevIndRepeat(GXTevStageID stage);\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXBump.h\" */\n/* \"include\\Dolphin\\gx.h\" line 14 \"Dolphin/GX/GXLight.h\" */\n#ifndef _DOLPHIN_GXLIGHT_H\n#define _DOLPHIN_GXLIGHT_H\n\n/* \"include\\Dolphin\\GX\\GXLight.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXLight.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXLight.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n\n///////////// LIGHT FUNCTIONS //////////////\n// Init functions.\nextern void GXInitLightAttn(GXLightObj* obj, f32 a0, f32 a1, f32 a2, f32 k0, f32 k1, f32 k2);\n\nextern void GXInitLightSpot(GXLightObj* obj, f32 cutoff, GXSpotFn spotFunc);\nextern void GXInitLightDistAttn(GXLightObj* obj, f32 refDist, f32 refBrightness, GXDistAttnFn distFunc);\n\nextern void GXInitLightPos(GXLightObj* obj, f32 x, f32 y, f32 z);\nextern void GXInitLightDir(GXLightObj* obj, f32 nX, f32 nY, f32 nZ);\nextern void GXInitSpecularDir(GXLightObj* obj, f32 nX, f32 nY, f32 nZ);\nextern void GXInitLightColor(GXLightObj* obj, GXColor color);\n\n// Load functions.\nextern void GXLoadLightObjImm(GXLightObj* obj, GXLightID light);\n\n// Set functions.\nextern void GXSetChanAmbColor(GXChannelID channel, GXColor color);\nextern void GXSetChanMatColor(GXChannelID channel, GXColor color);\nextern void GXSetNumChans(u8 count);\nextern void GXSetChanCtrl(GXChannelID channel, GXBool doEnable, GXColorSrc ambSrc, GXColorSrc matSrc, u32 mask, GXDiffuseFn diffFunc,\n                          GXAttnFn attnFunc);\n\n// Unused/inlined in P2.\nextern void GXInitLightAttnA(GXLightObj* obj, f32 a0, f32 a1, f32 a2);\nextern void GXGetLightAttnA(GXLightObj* obj, f32* a0, f32* a1, f32* a2);\nextern void GXInitLightAttnK(GXLightObj* obj, f32 k0, f32 k1, f32 k2);\nextern void GXGetLightAttnK(GXLightObj* obj, f32* k0, f32* k1, f32* k2);\n\nextern void GXGetLightPos(GXLightObj* obj, f32* x, f32* y, f32* z);\nextern void GXGetLightDir(GXLightObj* obj, f32* nX, f32* nY, f32* nZ);\n\nextern void GXInitSpecularDirHA(GXLightObj* obj, f32 nX, f32 nY, f32 nZ, f32 hX, f32 hY, f32 hZ);\n\nextern void GXGetLightColor(GXLightObj* obj, GXColor* color);\n\nextern void GXLoadLightObjIndx(u32 objIndex, GXLightID light);\n\n////////////////////////////////////////////\n\n/////////////// LIGHT MACROS ///////////////\n#define GXInitLightPosVec(obj, vec) (GXInitLightPos((obj), *(f32*)(vec), *((f32*)(vec) + 1), *((f32*)(vec) + 2)))\n\n#define GXInitLightDirVec(obj, vec) (GXInitLightDir((obj), *(f32*)(vec), *((f32*)(vec) + 1), *((f32*)(vec) + 2)))\n\n#define GXInitSpecularDirVec(obj, vec) (GXInitSpecularDir((obj), *(f32*)(vec), *((f32*)(vec) + 1), *((f32*)(vec) + 2)))\n\n#define GXInitLightShininess(obj, shine) (GXInitLightAttn((obj), 0.0f, 0.0f, 1.0f, (shine) / 2.0f, 0.0f, 1.0f - (shine) / 2.0f))\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXLight.h\" */\n/* \"include\\Dolphin\\gx.h\" line 15 \"Dolphin/GX/GXFrameBuffer.h\" */\n#ifndef _DOLPHIN_GXFRAMEBUFFER_H\n#define _DOLPHIN_GXFRAMEBUFFER_H\n\n/* \"include\\Dolphin\\GX\\GXFrameBuffer.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXFrameBuffer.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXFrameBuffer.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n\n///////////// RENDER MODE OBJS /////////////\n// NB: commented out objects are unused in P2.\n// extern GXRenderModeObj GXNtsc240Ds;\n// extern GXRenderModeObj GXNtsc240DsAa;\n// extern GXRenderModeObj GXNtsc240Int;\n// extern GXRenderModeObj GXNtsc240IntAa;\nextern GXRenderModeObj GXNtsc480IntDf;\nextern GXRenderModeObj GXNtsc480Int;\n// extern GXRenderModeObj GXNtsc480IntAa;\n// extern GXRenderModeObj GXNtsc480Prog;\n// extern GXRenderModeObj GXNtsc480ProgAa;\n// extern GXRenderModeObj GXMpal240Ds;\n// extern GXRenderModeObj GXMpal240DsAa;\n// extern GXRenderModeObj GXMpal240Int;\n// extern GXRenderModeObj GXMpal240IntAa;\nextern GXRenderModeObj GXMpal480IntDf;\nextern GXRenderModeObj GXMpal480Int;\n// extern GXRenderModeObj GXMpal480IntAa;\n// extern GXRenderModeObj GXPal264Ds;\n// extern GXRenderModeObj GXPal264DsAa;\n// extern GXRenderModeObj GXPal264Int;\n// extern GXRenderModeObj GXPal264IntAa;\nextern GXRenderModeObj GXPal528IntDf;\n// extern GXRenderModeObj GXPal528Int;\n// extern GXRenderModeObj GXPal524IntAa;\n// extern GXRenderModeObj GXEurgb60Hz240Ds;\n// extern GXRenderModeObj GXEurgb60Hz240DsAa;\n// extern GXRenderModeObj GXEurgb60Hz240Int;\n// extern GXRenderModeObj GXEurgb60Hz240IntAa;\nextern GXRenderModeObj GXEurgb60Hz480IntDf;\n// extern GXRenderModeObj GXEurgb60Hz480Int;\n// extern GXRenderModeObj GXEurgb60Hz480IntAa;\n// extern GXRenderModeObj GXRmHW;\n\n////////////////////////////////////////////\n\n///////////// BUFFER FUNCTIONS /////////////\n// Source/dest copy-set functions.\nextern void GXSetDispCopySrc(u16 left, u16 top, u16 width, u16 height);\nextern void GXSetTexCopySrc(u16 left, u16 top, u16 width, u16 height);\nextern void GXSetDispCopyDst(u16 width, u16 height);\nextern void GXSetTexCopyDst(u16 width, u16 height, GXTexFmt format, GXBool useMIPmap);\n\n// Other copy-set functions.\nextern void GXSetDispCopyFrame2Field(GXCopyMode mode);\nextern void GXSetCopyClamp(GXFBClamp clamp);\nextern u32 GXSetDispCopyYScale(f32 vertScale);\nextern void GXSetCopyClear(GXColor clearColor, u32 clearZ);\nextern void GXSetCopyFilter(GXBool useAA, u8 samplePattern[12][2], GXBool doVertFilt, u8 vFilt[7]);\nextern void GXSetDispCopyGamma(GXGamma gamma);\n\n// Copy data functions.\nextern void GXCopyDisp(void* dest, GXBool doClear);\nextern void GXCopyTex(void* dest, GXBool doClear);\n\n// Get functions.\nextern u16 GXGetNumXfbLines(u16 efbHeight, f32 yScale);\nextern f32 GXGetYScaleFactor(u16 efbHeight, u16 xfbHeight);\n\n// Clear functions.\nextern void GXClearBoundingBox();\n\n// Unused/inlined in P2.\nextern void GXAdjustForOverscan(GXRenderModeObj* rIn, GXRenderModeObj* rOut, u16 horiz, u16 vert);\nextern void GXReadBoundingBox(u16* left, u16* top, u16* right, u16* bottom);\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXFrameBuffer.h\" */\n/* \"include\\Dolphin\\gx.h\" line 16 \"Dolphin/GX/GXPerf.h\" */\n#ifndef _DOLPHIN_GXPERF_H\n#define _DOLPHIN_GXPERF_H\n\n/* \"include\\Dolphin\\GX\\GXPerf.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXPerf.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXPerf.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n\n///////////// METRIC FUNCTIONS /////////////\nextern void GXSetGPMetric(GXPerf0 perf0, GXPerf1 perf1);\nextern void GXClearGPMetric();\nextern void GXReadXfRasMetric(u32* xfWaitIn, u32* xfWaitOut, u32* rasBusy, u32* clocks);\n\n// Unused/inlined in P2.\nextern void GXReadGPMetric(u32* count0, u32* count1);\nextern u32 GXReadGP0Metric();\nextern u32 GXReadGP1Metric();\nextern void GXReadMemMetric(u32* cpReq, u32* tcReq, u32* cpuReadReq, u32* cpuWriteReq, u32* dspReq, u32* ioReq, u32* viReq, u32* peReq,\n                            u32* rfReq, u32* fiReq);\nextern void GXClearMemMetric();\nextern void GXReadPixMetric(u32* topIn, u32* topOut, u32* bottomIn, u32* bottomOut, u32* clearIn, u32* copyClocks);\nextern void GXClearPixMetric();\nextern void GXSetVCacheMetric(GXVCachePerf attr);\nextern void GXReadVCacheMetric(u32* check, u32* miss, u32* stall);\nextern void GXClearVCacheMetric();\nextern void GXInitXfRasMetric();\nextern u32 GXReadClksPerVtx();\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXPerf.h\" */\n/* \"include\\Dolphin\\gx.h\" line 17 \"Dolphin/GX/GXPixel.h\" */\n#ifndef _DOLPHIN_GXPIXEL_H\n#define _DOLPHIN_GXPIXEL_H\n\n/* \"include\\Dolphin\\GX\\GXPixel.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXPixel.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXPixel.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n/* \"include\\Dolphin\\GX\\GXPixel.h\" line 11 \"Dolphin/mtx.h\" */\n/* end \"Dolphin/mtx.h\" */\n\n///////////// PIXEL FUNCTIONS //////////////\n// Fog functions.\nextern void GXSetFog(GXFogType type, f32 startZ, f32 endZ, f32 nearZ, f32 farZ, GXColor color);\nextern void GXInitFogAdjTable(GXFogAdjTable* table, u16 width, Mtx44 projMtx);\nextern void GXSetFogRangeAdj(GXBool doEnable, u16 center, GXFogAdjTable* table);\n\n// Blend functions.\nextern void GXSetBlendMode(GXBlendMode type, GXBlendFactor srcFactor, GXBlendFactor destFactor, GXLogicOp op);\n\n// Color update functions.\nextern void GXSetColorUpdate(GXBool enableUpdate);\nextern void GXSetAlphaUpdate(GXBool enableUpdate);\n\n// Other setter functions.\nextern void GXSetZMode(GXBool enableCompare, GXCompare func, GXBool enableUpdate);\nextern void GXSetZCompLoc(GXBool isBeforeTex);\nextern void GXSetPixelFmt(GXPixelFmt pixelFormat, GXZFmt16 zFormat);\nextern void GXSetDither(GXBool doDither);\nextern void GXSetDstAlpha(GXBool doEnable, u8 alpha);\nextern void GXSetFieldMask(GXBool doOddMask, GXBool doEvenMask);\nextern void GXSetFieldMode(GXBool doFieldMode, GXBool doHalfAspectRatio);\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXPixel.h\" */\n/* \"include\\Dolphin\\gx.h\" line 18 \"Dolphin/GX/GXTev.h\" */\n#ifndef _DOLPHIN_GXTEV_H\n#define _DOLPHIN_GXTEV_H\n\n/* \"include\\Dolphin\\GX\\GXTev.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXTev.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXTev.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n\n////// TEXTURE ENVIRONMENT FUNCTIONS ///////\nextern void GXSetTevOp(GXTevStageID stage, GXTevMode mode);\nextern void GXSetTevColorIn(GXTevStageID stage, GXTevColorArg a, GXTevColorArg b, GXTevColorArg c, GXTevColorArg d);\nextern void GXSetTevAlphaIn(GXTevStageID stage, GXTevAlphaArg a, GXTevAlphaArg b, GXTevAlphaArg c, GXTevAlphaArg d);\nextern void GXSetTevColorOp(GXTevStageID stage, GXTevOp op, GXTevBias bias, GXTevScale scale, GXBool doClamp, GXTevRegID outReg);\nextern void GXSetTevAlphaOp(GXTevStageID stage, GXTevOp op, GXTevBias bias, GXTevScale scale, GXBool doClamp, GXTevRegID outReg);\n\nextern void GXSetTevColor(GXTevRegID reg, GXColor color);\nextern void GXSetTevColorS10(GXTevRegID reg, GXColorS10 color);\n\nextern void GXSetTevKColor(GXTevKColorID id, GXColor color);\nextern void GXSetTevKColorSel(GXTevStageID stage, GXTevKColorSel sel);\nextern void GXSetTevKAlphaSel(GXTevStageID stage, GXTevKAlphaSel sel);\n\nextern void GXSetTevSwapMode(GXTevStageID stage, GXTevSwapSel rasSel, GXTevSwapSel texSel);\nextern void GXSetTevSwapModeTable(GXTevSwapSel table, GXTevColorChan red, GXTevColorChan green, GXTevColorChan blue, GXTevColorChan alpha);\n\nextern void GXSetAlphaCompare(GXCompare comp0, u8 ref0, GXAlphaOp op, GXCompare comp1, u8 ref1);\nextern void GXSetTevOrder(GXTevStageID stage, GXTexCoordID coord, GXTexMapID map, GXChannelID color);\nextern void GXSetZTexture(GXZTexOp op, GXTexFmt format, u32 bias);\nextern void GXSetNumTevStages(u8 count);\n\n// Unused/inlined in P2.\nextern void GXSetTevClampMode(GXTevStageID stage, GXTevClampMode mode);\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXTev.h\" */\n/* \"include\\Dolphin\\gx.h\" line 19 \"Dolphin/GX/GXTexture.h\" */\n#ifndef _DOLPHIN_GXTEXTURE_H\n#define _DOLPHIN_GXTEXTURE_H\n\n/* \"include\\Dolphin\\GX\\GXTexture.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXTexture.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXTexture.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n\n//////////// TEXTURE CALLBACKS /////////////\n\ntypedef GXTexRegion* (*GXTexRegionCallback)(const GXTexObj* t_obj, GXTexMapID id);\ntypedef GXTlutRegion* (*GXTlutRegionCallback)(u32 idx);\n\n////////////////////////////////////////////\n\n////////////// TEXTURE MODES ///////////////\n// Texture mode IDs.\nextern u8 GXTexMode0Ids[8];\nextern u8 GXTexMode1Ids[8];\nextern u8 GXTexImage0Ids[8];\nextern u8 GXTexImage1Ids[8];\nextern u8 GXTexImage2Ids[8];\nextern u8 GXTexImage3Ids[8];\nextern u8 GXTexTlutIds[8];\n\n// Filter conversion arrays (HW2GX unused in P2).\nextern u8 GX2HWFiltConv[6];\n// extern u8 HW2GXFiltConv[8];\n\n////////////////////////////////////////////\n\n//////////// TEXTURE FUNCTIONS /////////////\n// Init functions.\nextern void GXInitTexObj(GXTexObj* obj, void* imagePtr, u16 width, u16 height, GXTexFmt format, GXTexWrapMode sWrap, GXTexWrapMode tWrap,\n                         GXBool useMIPmap);\nextern void GXInitTexObjCI(GXTexObj* obj, void* imagePtr, u16 width, u16 height, GXCITexFmt format, GXTexWrapMode sWrap,\n                           GXTexWrapMode tWrap, GXBool useMIPmap, u32 tlutName);\nextern void GXInitTexObjLOD(GXTexObj* obj, GXTexFilter minFilter, GXTexFilter maxFilter, f32 minLOD, f32 maxLOD, f32 lodBias,\n                            GXBool doBiasClamp, GXBool doEdgeLOD, GXAnisotropy maxAniso);\n\n// Get functions.\nextern GXTexFmt GXGetTexObjFmt(GXTexObj* obj);\nextern GXBool GXGetTexObjMipMap(GXTexObj* obj);\nextern u32 GXGetTexBufferSize(u16 width, u16 height, u32 format, GXBool mipmap, u8 max_lod);\n\n// Load functions.\nextern void GXLoadTexObjPreLoaded(GXTexObj* obj, GXTexRegion* region, GXTexMapID map);\nextern void GXLoadTexObj(GXTexObj* obj, GXTexMapID map);\n\n// Tlut functions.\nextern void GXInitTlutObj(GXTlutObj* obj, void* table, GXTlutFmt format, u16 numEntries);\nextern void GXLoadTlut(GXTlutObj* obj, u32 tlutName);\n\n// Region functions.\nextern void GXInitTexCacheRegion(GXTexRegion* region, GXBool is32bMIPmap, u32 memEven, GXTexCacheSize sizeEven, u32 memOdd,\n                                 GXTexCacheSize sizeOdd);\nextern void GXInitTlutRegion(GXTlutRegion* region, u32 memAddr, GXTlutSize tlutSize);\n\n// Other functions.\nextern void GXInvalidateTexAll();\nextern GXTexRegionCallback GXSetTexRegionCallback(GXTexRegionCallback func);\nextern GXTlutRegionCallback GXSetTlutRegionCallback(GXTlutRegionCallback func);\n\n// Unknown arg functions.\n// TODO: work these out.\nextern void __SetSURegs();\nextern void __GXSetSUTexRegs();\nextern void __GXSetTmemConfig(u32 config);\n\n// Unused/inlined in P2.\nextern void GXInitTexObjData(GXTexObj* obj, void* imagePtr);\nextern void GXInitTexObjWrapMode(GXTexObj* obj, GXTexWrapMode sWrap, GXTexWrapMode tWrap);\nextern void GXInitTexObjTlut(GXTexObj* obj, u32 tlutName);\n// TODO: finish filling these out for reference purposes.\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXTexture.h\" */\n/* \"include\\Dolphin\\gx.h\" line 20 \"Dolphin/GX/GXGeometry.h\" */\n#ifndef _DOLPHIN_GXGEOMETRY_H\n#define _DOLPHIN_GXGEOMETRY_H\n\n/* \"include\\Dolphin\\GX\\GXGeometry.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXGeometry.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXGeometry.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n\n//////////// GEOMETRY FUNCTIONS ////////////\n// Basic GX functions.\nextern void __GXSetDirtyState();\nextern void GXBegin(GXPrimitive type, GXVtxFmt format, u16 numVertices);\nextern void __GXSendFlushPrim();\n\n// Attr functions.\nextern void GXSetVtxDesc(GXAttr attr, GXAttrType type);\nextern void GXClearVtxDesc();\n\nextern void GXSetVtxAttrFmt(GXVtxFmt format, GXAttr attr, GXCompCnt count, GXCompType type, u8 frac);\nextern void GXSetVtxAttrFmtv(GXVtxFmt format, GXVtxAttrFmtList* list);\n\nextern void GXSetArray(GXAttr attr, void* basePtr, u8 stride);\nextern void GXInvalidateVtxCache();\nextern void GXSetTexCoordGen2(GXTexCoordID coord, GXTexGenType genType, GXTexGenSrc srcParam, u32 mtx, GXBool doNormalise, u32 postMtx);\nextern void GXSetNumTexGens(u8 count);\n\n// Geometry functions.\nextern void GXSetLineWidth(u8 width, GXTexOffset offset);\nextern void GXSetPointSize(u8 pointSize, GXTexOffset offset);\nextern void GXEnableTexOffsets(GXTexCoordID coord, GXBool enableLine, GXBool enablePoint);\nextern void __GXSetGenMode();\n\n// Cull and manip functions.\nextern void GXSetCullMode(GXCullMode mode);\nextern void GXSetCoPlanar(GXBool doEnable);\n\n// Unused/inlined in P2.\nextern void GXSetVtxDescv(GXVtxDescList* attrList);\nextern void GXGetVtxDesc(GXAttr attr, GXAttrType* type);\nextern void GXGetVtxDescv(GXVtxDescList* list);\nextern void GXGetVtxAttrFmtv(GXVtxFmt format, GXVtxAttrFmtList* list);\nextern void GXGetLineWidth(u8* width, GXTexOffset* offset);\nextern void GXGetPointSize(u8* pointSize, GXTexOffset* offset);\nextern void GXGetCullMode(GXCullMode* mode);\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXGeometry.h\" */\n/* \"include\\Dolphin\\gx.h\" line 21 \"Dolphin/GX/GXTransform.h\" */\n#ifndef _DOLPHIN_GXTRANSFORM_H\n#define _DOLPHIN_GXTRANSFORM_H\n\n/* \"include\\Dolphin\\GX\\GXTransform.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXTransform.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXTransform.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n/* \"include\\Dolphin\\GX\\GXTransform.h\" line 11 \"Dolphin/mtx.h\" */\n/* end \"Dolphin/mtx.h\" */\n\n/////////// TRANSFORM FUNCTIONS ////////////\n// Matrix and projection functions.\nextern void GXSetProjection(Mtx44 mtx, GXProjectionType type);\nextern void GXSetProjectionv(f32* ptr);\nextern void GXLoadPosMtxImm(Mtx mtx, u32 id);\nextern void GXLoadNrmMtxImm(Mtx mtx, u32 id);\nextern void GXSetCurrentMtx(u32 id);\nextern void GXLoadTexMtxImm(f32 mtx[][4], u32 id, GXTexMtxType type);\n\n// Viewport functions.\nextern void __GXSetViewport(); // confirm types\nextern void GXSetViewport(f32 left, f32 top, f32 width, f32 height, f32 nearZ, f32 farZ);\n\n// Scissor/clip functions.\nextern void GXSetScissor(u32 left, u32 top, u32 width, u32 height);\nextern void GXSetScissorBoxOffset(s32 x, s32 y);\nextern void GXGetScissor(u32* left, u32* top, u32* width, u32* height);\nextern void GXGetScissorBoxOffset(int xOffset, int yOffset);\nextern void GXSetClipMode(GXClipMode mode);\n\n// Unused/inlined in P2.\nextern void GXProject(f32 x, f32 y, f32 z, Mtx viewMtx, f32* projMtx, f32* viewport, f32* screenX, f32* screenY, f32* screenZ);\nextern void GXGetProjectionv(f32* ptr);\nextern void GXLoadPosMtxIndx(u16 index, u32 id);\nextern void GXLoadNrmMtxImm3x3(Mtx33, u32 id);\nextern void GXLoadNrmMtxIndx3x3(u16 index, u32 id);\nextern void GXLoadTexMtxIndx(u16 index, u32 id, GXTexMtxType type);\nextern void GXSetViewportJitter(f32 left, f32 top, f32 width, f32 height, f32 nearZ, f32 farZ, u32 field);\nextern void GXGetViewportv(f32* viewport);\n\n////////////////////////////////////////////\n\n////////////// USEFUL EXTRAS ///////////////\n#define GX_PROJECTION_SZ 7\n#define GX_VIEWPORT_SZ   6\n\nstatic inline void GXSetViewportv(f32* port) { GXSetViewport(port[0], port[1], port[2], port[3], port[4], port[5]); }\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXTransform.h\" */\n/* \"include\\Dolphin\\gx.h\" line 22 \"Dolphin/GX/GXMisc.h\" */\n#ifndef _DOLPHIN_GXMISC_H\n#define _DOLPHIN_GXMISC_H\n\n/* \"include\\Dolphin\\GX\\GXMisc.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXMisc.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXMisc.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n/* \"include\\Dolphin\\GX\\GXMisc.h\" line 11 \"Dolphin/GX/GXFifo.h\" */\n#ifndef _DOLPHIN_GXFIFO_H\n#define _DOLPHIN_GXFIFO_H\n\n/* \"include\\Dolphin\\GX\\GXFifo.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXFifo.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXFifo.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n\n/////////////// FIFO STRUCTS ///////////////\n#define GX_FIFO_MINSIZE  (64 * 1024)\n#define GX_FIFO_OBJ_SIZE (128)\n\n#define GXFIFO_ADDR 0xCC008000\n\n// Generic struct for FIFO access (size 0x80).\ntypedef struct _GXFifoObj {\n\tu8 padding[GX_FIFO_OBJ_SIZE]; // _00\n} GXFifoObj;\n\n// Internal struct for FIFO access.\ntypedef struct _GXFifoObjPriv {\n\tvoid* base;        // _00\n\tvoid* end;         // _04\n\tu32 size;          // _08\n\tu32 highWatermark; // _0C\n\tu32 lowWatermark;  // _10\n\tvoid* readPtr;     // _14\n\tvoid* writePtr;    // _18\n\ts32 rwDistance;    // _1C\n\tu8 _20[0x60];      // _20\n} GXFifoObjPriv;\n\ntypedef void (*GXBreakPtCallback)(void);\n\n// PPC Write Gather Pipe\ntypedef union {\n\tu8 u8;\n\tu16 u16;\n\tu32 u32;\n\tu64 u64;\n\ts8 s8;\n\ts16 s16;\n\ts32 s32;\n\ts64 s64;\n\tf32 f32;\n\tf64 f64;\n} PPCWGPipe;\n\n#ifdef __MWERKS__\nvolatile PPCWGPipe GXWGFifo : GXFIFO_ADDR;\n#else\n#define GXWGFifo (*(volatile PPCWGPipe*)GXFIFO_ADDR)\n#endif\n\n////////////////////////////////////////////\n\n//////////// FIFO MACROS/INLINES ///////////\n#define GX_WRITE_U8(val)  (GXWGFifo.u8 = val)\n#define GX_WRITE_U16(val) (GXWGFifo.u16 = val)\n#define GX_WRITE_U32(val) (GXWGFifo.u32 = (u32)val)\n\nstatic inline void GXPosition2f32(const f32 x, const f32 y)\n{\n\tGXWGFifo.f32 = x;\n\tGXWGFifo.f32 = y;\n}\n\nstatic inline void GXPosition3s16(const s16 x, const s16 y, const s16 z)\n{\n\tGXWGFifo.s16 = x;\n\tGXWGFifo.s16 = y;\n\tGXWGFifo.s16 = z;\n}\n\nstatic inline void GXPosition3u16(const u16 x, const u16 y, const u16 z)\n{\n\tGXWGFifo.u16 = x;\n\tGXWGFifo.u16 = y;\n\tGXWGFifo.u16 = z;\n}\n\nstatic inline void GXPosition3f32(f32 x, f32 y, f32 z)\n{\n\tGXWGFifo.f32 = x;\n\tGXWGFifo.f32 = y;\n\tGXWGFifo.f32 = z;\n}\n\nstatic inline void GXNormal3f32(const f32 x, const f32 y, const f32 z)\n{\n\tGXWGFifo.f32 = x;\n\tGXWGFifo.f32 = y;\n\tGXWGFifo.f32 = z;\n}\n\nstatic inline void GXColor1u32(u32 c) { GXWGFifo.u32 = c; }\n\nstatic inline void GXColor4u8(const u8 r, const u8 g, const u8 b, const u8 a)\n{\n\tGXWGFifo.u8 = r;\n\tGXWGFifo.u8 = g;\n\tGXWGFifo.u8 = b;\n\tGXWGFifo.u8 = a;\n}\n\nstatic inline void GXTexCoord2s8(const s8 u, const s8 v)\n{\n\tGXWGFifo.s8 = u;\n\tGXWGFifo.s8 = v;\n}\n\nstatic inline void GXTexCoord2u8(u8 s, u8 t)\n{\n\tGXWGFifo.u8 = s;\n\tGXWGFifo.u8 = t;\n}\n\nstatic inline void GXPosition2u16(u16 x, u16 y)\n{\n\tGXWGFifo.u16 = x;\n\tGXWGFifo.u16 = y;\n}\n\nstatic inline void GXTexCoord2s16(const s16 u, const s16 v)\n{\n\tGXWGFifo.s16 = u;\n\tGXWGFifo.s16 = v;\n}\n\nstatic inline void GXTexCoord2u16(const u16 u, const u16 v)\n{\n\tGXWGFifo.u16 = u;\n\tGXWGFifo.u16 = v;\n}\n\nstatic inline void GXTexCoord2f32(const f32 u, const f32 v)\n{\n\tGXWGFifo.f32 = u;\n\tGXWGFifo.f32 = v;\n}\n\nstatic inline void GXEnd(void) { }\n\n////////////////////////////////////////////\n\n//////////// FIFO INIT/SET/SAVE ////////////\n// Init.\nextern void __GXFifoInit();\nextern void GXInitFifoBase(GXFifoObj* obj, void* base, u32 size);\nextern void GXInitFifoPtrs(GXFifoObj* obj, void* readPtr, void* writePtr);\nextern void GXInitFifoLimits(GXFifoObj* obj, u32 hiWaterMark, u32 loWaterMark);\n\n// Set.\nextern void GXSetCPUFifo(GXFifoObj* obj);\nextern void GXSetGPFifo(GXFifoObj* obj);\nextern void GXSaveCPUFifo(GXFifoObj* obj);\n\n////////////////////////////////////////////\n\n/////////////// FIFO GETTERS ///////////////\nextern void GXGetGPStatus(GXBool* isOverHi, GXBool* isUnderLo, GXBool* isReadIdle, GXBool* isCmdIdle, GXBool* isHitBrkPt);\nextern GXFifoObj* GXGetCPUFifo();\nextern GXFifoObj* GXGetGPFifo();\n\n////////////////////////////////////////////\n\n//////////// DISPLAY LIST FUNCS ////////////\nextern void GXBeginDisplayList(void* list, u32 size);\nextern u32 GXEndDisplayList();\nextern void GXCallDisplayList(void* list, u32 numBytes);\n\n////////////////////////////////////////////\n\n///////////// BREAKPOINT FUNCS /////////////\nextern GXBreakPtCallback GXSetBreakPtCallback(GXBreakPtCallback callback);\n\n////////////////////////////////////////////\n\n/////////////// OTHER FUNCS ////////////////\nvoid __GXSaveCPUFifoAux(GXFifoObj* obj);\nvoid __GXFifoReadEnable();\nvoid __GXFifoReadDisable();\nvoid __GXFifoLink(u8);\nvoid __GXWriteFifoIntEnable(u32, u32);\nvoid __GXWriteFifoIntReset(u32, u32);\n\n// Unused/inlined in P2.\nextern void GXSaveGPFifo(GXFifoObj* obj);\n\nextern void GXGetFifoStatus(GXFifoObj* obj, GXBool* isOverHi, GXBool* isUnderLo, u32* fifoCount, GXBool* isCpuWrite, GXBool* isGPRead,\n                            GXBool* isFifoWrap);\nextern void GXGetFifoPtrs(GXFifoObj* obj, void** readPtr, void** writePtr);\nextern void* GXGetFifoBase(GXFifoObj* obj);\nextern u32 GXGetFifoSize(GXFifoObj* obj);\nextern void GXGetFifoLimits(GXFifoObj* obj, u32* hi, u32* lo);\n\nextern void GXEnableBreakPt(void* breakPtr);\nextern void GXDisableBreakPt();\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXFifo.h\" */\n\n//////////////// CALLBACKS /////////////////\ntypedef void (*GXDrawSyncCallback)(u16 token);\ntypedef void (*GXDrawDoneCallback)(void);\n\n////////////////////////////////////////////\n\n///////////// BASIC FUNCTIONS //////////////\nstatic GXTexRegion* __GXDefaultTexRegionCallback(const GXTexObj* obj, GXTexMapID id);\nstatic GXTlutRegion* __GXDefaultTlutRegionCallback(u32 tlut);\nstatic BOOL __GXShutdown(BOOL final); // need to check types\n\n////////////////////////////////////////////\n\n////////////// INIT FUNCTIONS //////////////\nextern GXFifoObj* GXInit(void* base, u32 size);\nextern void __GXInitGX(); // need to check types\nextern void __GXPEInit();\n\n////////////////////////////////////////////\n\n////////////// MISC FUNCTIONS //////////////\n// Basic functions.\nextern void GXSetMisc(GXMiscToken token, u32 val);\nextern void GXFlush();\nextern void __GXAbort(); // need to check types\nextern void GXAbortFrame();\n\n// Draw functions.\nextern void GXSetDrawSync(u16 token);\nextern void GXSetDrawDone();\nextern void GXWaitDrawDone();\nextern void GXDrawDone();\n\n// Other syncs/interrupts.\nextern void GXPixModeSync();\nextern GXDrawSyncCallback GXSetDrawSyncCallback(GXDrawSyncCallback callback);\nextern void GXTokenInterruptHandler(); // need to check types\nextern GXDrawDoneCallback GXSetDrawDoneCallback(GXDrawDoneCallback callback);\nextern void GXFinishInterruptHandler(); // need to check types\n\n// Poke functions.\nextern void GXPokeAlphaMode(GXCompare func, u8 threshold);\nextern void GXPokeAlphaRead(GXAlphaReadMode mode);\nextern void GXPokeAlphaUpdate(GXBool doUpdate);\nextern void GXPokeBlendMode(GXBlendMode mode, GXBlendFactor srcFactor, GXBlendFactor destFactor, GXLogicOp op);\nextern void GXPokeColorUpdate(GXBool doUpdate);\nextern void GXPokeDstAlpha(GXBool doEnable, u8 alpha);\nextern void GXPokeDither(GXBool doDither);\nextern void GXPokeZMode(GXBool doCompare, GXCompare func, GXBool doUpdate);\n\n// Unused/inlined in P2.\nextern BOOL IsWriteGatherBufferEmpty();\nextern void EnableWriteGatherPipe();\nextern void DisableWriteGatherPipe();\nextern void GXResetWriteGatherPipe();\n\nextern void GXReadDrawSync();\nextern void GXTexModeSync();\n\nextern void GXPeekARGB(u16 x, u16 y, u32* color);\nextern void GXPokeARGB(u16 x, u16 y, u32 color);\nextern void GXPeekZ(u16 x, u16 y, u32* z);\nextern void GXPokeZ(u16 x, u16 y, u32 z);\n\nextern u32 GXCompressZ16(u32 z24, GXZFmt16 zFormat);\nextern u32 GXDecompressZ16(u32 z16, GXZFmt16 zFormat);\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXMisc.h\" */\n/* \"include\\Dolphin\\gx.h\" line 23 \"Dolphin/GX/GXData.h\" */\n#ifndef _DOLPHIN_GXDATA_H\n#define _DOLPHIN_GXDATA_H\n\n/* \"include\\Dolphin\\GX\\GXData.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXData.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXData.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n/* \"include\\Dolphin\\GX\\GXData.h\" line 11 \"Dolphin/GX/GXTexture.h\" */\n/* end \"Dolphin/GX/GXTexture.h\" */\n\n/////////////// CONTROL ENUMS //////////////\ntypedef enum _CPStatus {\n\tGX_FIFO_OVERFLOW        = 0x1,\n\tGX_FIFO_UNDERFLOW       = 0x2,\n\tGP_IS_IDLE_FOR_READING  = 0x4,\n\tGP_IS_IDLE_FOR_COMMANDS = 0x8,\n\tBP_INTERRUPT            = 0x10,\n} CPStatus;\n\ntypedef enum _CPControl {\n\tGP_FIFO_READ_ENABLE             = 0x1,\n\tCP_IRQ_ENABLE_MAYBE             = 0x2,\n\tFIFO_OVERFLOW_IRQ_ENABLE_MAYBE  = 0x4,\n\tFIFO_UNDERFLOW_IRQ_ENABLE_MAYBE = 0x8,\n\tGP_LINK_ENABLE                  = 0x10,\n\tBP_ENABLE                       = 0x20,\n} CPControl;\n\ntypedef enum _CPClear {\n\tCLEAR_FIFO_OVERFLOW  = 0x1,\n\tCLEAR_FIFO_UNDERFLOW = 0x2,\n} CPClear;\n\n////////////////////////////////////////////\n\n////////////// GXDATA STRUCTS //////////////\n// size: 0x5B0\ntypedef struct _GXData {\n\t// Bypass and vertex info\n\tu16 vNumNot;   // _000, !(# flush verts to send)\n\tu16 bpSentNot; // _002, !(bypass reg sent last?)\n\tu16 vNum;      // _004, # flush verts to send\n\tu16 vLim;      // _006, max vert size\n\n\t// Command process (CP) regs\n\tu32 cpEnable; // _008\n\tu32 cpStatus; // _00C\n\tu32 cpClr;    // _010\n\tu32 vcdLo;    // _014\n\tu32 vcdHi;    // _018\n\tu32 vatA[8];  // _01C\n\tu32 vatB[8];  // _03C\n\tu32 vatC[8];  // _05C\n\tu32 lpSize;   // _07C\n\tu32 matIdxA;  // _080\n\tu32 matIdxB;  // _084\n\n\t// Index loading base/stride regs (pos, nrm, tex, light)\n\tu32 indexBase[4];   // _088\n\tu32 indexStride[4]; // _098\n\n\t// Transform and lighting regs\n\tu32 ambColor[2]; // _0A8\n\tu32 matColor[2]; // _0B0\n\n\t// Setup regs\n\tu32 suTs0[8]; // _0B8\n\tu32 suTs1[8]; // _0D8\n\tu32 suScis0;  // _0F8\n\tu32 suScis1;  // _0FC\n\n\t// Raster regs\n\tu32 tref[8]; // _100\n\tu32 iref;    // _120\n\n\t// Bump/Indirect texture regs\n\tu32 bpMask;       // _124\n\tu32 IndTexScale0; // _128\n\tu32 IndTexScale1; // _12C\n\n\t// Tev regs\n\tu32 tevc[16];   // _130\n\tu32 teva[16];   // _170\n\tu32 tevKsel[8]; // _1B0\n\n\t// Performance regs\n\tu32 cmode0; // _1D0\n\tu32 cmode1; // _1D4\n\tu32 zmode;  // _1D8\n\tu32 peCtrl; // _1DC\n\n\t// Display copy regs\n\tu32 cpDispSrc;    // _1E0\n\tu32 cpDispSize;   // _1E4\n\tu32 cpDispStride; // _1E8\n\tu32 cpDisp;       // _1EC\n\n\t// Texture copy regs\n\tu32 cpTexSrc;    // _1F0\n\tu32 cpTexSize;   // _1F4\n\tu32 cpTexStride; // _1F8\n\tu32 cpTex;       // _1FC\n\tGXBool cpTexZ;   // _200\n\n\t// General raster mode\n\tu32 genMode; // _204\n\n\t// Texture regions\n\tGXTexRegion TexRegions0[GX_MAX_TEXMAP]; // _208\n\tGXTexRegion TexRegions1[GX_MAX_TEXMAP]; // _288\n\tGXTexRegion TexRegions2[GX_MAX_TEXMAP]; // _308\n\n\t// Texture lookup table regions\n\tGXTlutRegion TlutRegions[GX_MAX_TLUT_ALL]; // _388\n\tGXTexRegionCallback texRegionCallback;     // _4C8\n\tGXTlutRegionCallback tlutRegionCallback;   // _4CC\n\n\t// Command processor vars\n\tGXAttrType nrmType; // _4D0\n\tGXBool hasNrms;     // _4D4\n\tGXBool hasBiNrms;   // _4D5\n\tu32 projType;       // _4D8\n\tf32 projMtx[6];     // _4DC\n\n\t// Viewport parms\n\tf32 vpLeft;  // _4F4\n\tf32 vpTop;   // _4F8\n\tf32 vpWd;    // _4FC\n\tf32 vpHt;    // _500\n\tf32 vpNearz; // _504\n\tf32 vpFarz;  // _508\n\tf32 zOffset; // _50C\n\tf32 zScale;  // _510\n\n\t// Texture regs\n\tu32 tImage0[8];   // _514\n\tu32 tMode0[8];    // _534\n\tu32 texmapId[16]; // _554\n\tu32 tcsManEnab;   // _594\n\tu32 tevTcEnab;    // _598\n\n\t// Performance metrics\n\tGXPerf0 perf0; // _59C\n\tGXPerf1 perf1; // _5A0\n\tu32 perfSel;   // _5A4\n\n\t// Flags\n\tGXBool inDispList;    // _5A8\n\tGXBool dlSaveContext; // _5A9\n\tGXBool abtWaitPECopy; // _5AA\n\tu8 dirtyVAT;          // _5AB\n\tu32 dirtyState;       // _5AC\n} GXData;\nextern GXData* const __GXData; // NB: this is const in SMG1 decomp.\n\n#define gx __GXData\n\n////////////////////////////////////////////\n\n///////////// REGISTER DEFINES /////////////\n// Declare registers.\nextern void* __cpReg;\nextern void* __piReg;\nextern void* __memReg;\nextern void* __peReg;\n\n// Define register addresses.\n#define GX_CP_ADDR  (0x0C000000)\n#define GX_PE_ADDR  (0x0C001000)\n#define GX_PI_ADDR  (0x0C003000)\n#define GX_MEM_ADDR (0x0C004000)\n\n// i hate writing out the damn volatile shit so many times\n#define GX_GET_MEM_REG(offset) (*(vu16*)((vu16*)(__memReg) + (offset)))\n#define GX_GET_CP_REG(offset)  (*(vu16*)((vu16*)(__cpReg) + (offset)))\n#define GX_GET_PE_REG(offset)  (*(vu16*)((vu16*)(__peReg) + (offset)))\n#define GX_GET_PI_REG(offset)  (*(vu32*)((vu32*)(__piReg) + (offset)))\n\n#define GX_SET_MEM_REG(offset, val) (*(vu16*)((vu16*)(__memReg) + (offset)) = val)\n#define GX_SET_CP_REG(offset, val)  (*(vu16*)((vu16*)(__cpReg) + (offset)) = val)\n#define GX_SET_PE_REG(offset, val)  (*(vu16*)((vu16*)(__peReg) + (offset)) = val)\n#define GX_SET_PI_REG(offset, val)  (*(vu32*)((vu32*)(__piReg) + (offset)) = val)\n\n// Useful reading register inlines\nstatic inline u32 GXReadMEMReg(u32 addrLo, u32 addrHi)\n{\n\tu32 hiStart, hiNew, lo;\n\thiStart = GX_GET_MEM_REG(addrHi);\n\tdo {\n\t\thiNew   = hiStart;\n\t\tlo      = GX_GET_MEM_REG(addrLo);\n\t\thiStart = GX_GET_MEM_REG(addrHi);\n\t} while (hiStart != hiNew);\n\n\treturn ((hiStart << 16) | lo);\n}\n\nstatic inline u32 GXReadCPReg(u32 addrLo, u32 addrHi)\n{\n\tu32 hiStart, hiNew, lo;\n\thiStart = GX_GET_CP_REG(addrHi);\n\tdo {\n\t\thiNew   = hiStart;\n\t\tlo      = GX_GET_CP_REG(addrLo);\n\t\thiStart = GX_GET_CP_REG(addrHi);\n\t} while (hiStart != hiNew);\n\n\treturn ((hiStart << 16) | lo);\n}\n\nstatic inline u32 GXReadPEReg(u32 addrLo, u32 addrHi)\n{\n\tu32 hiStart, hiNew, lo;\n\thiStart = GX_GET_PE_REG(addrHi);\n\tdo {\n\t\thiNew   = hiStart;\n\t\tlo      = GX_GET_PE_REG(addrLo);\n\t\thiStart = GX_GET_PE_REG(addrHi);\n\t} while (hiStart != hiNew);\n\n\treturn ((hiStart << 16) | lo);\n}\n\nstatic inline u32 GXReadPIReg(u32 addrLo, u32 addrHi)\n{\n\tu32 hiStart, hiNew, lo;\n\thiStart = GX_GET_PI_REG(addrHi);\n\tdo {\n\t\thiNew   = hiStart;\n\t\tlo      = GX_GET_PI_REG(addrLo);\n\t\thiStart = GX_GET_PI_REG(addrHi);\n\t} while (hiStart != hiNew);\n\n\treturn ((hiStart << 16) | lo);\n}\n\n////////////////////////////////////////////\n\n/////////// OTHER USEFUL DEFINES ///////////\n// useful define to check first two GXData members together\n// used in GXDisplayList, saves having a union in the struct\n#define GX_CHECK_FLUSH() (!(*(u32*)(&gx->vNumNot)))\n\n// set waste flags\nstatic inline void GXSetWasteFlags()\n{\n\tGXData* data = __GXData;\n\tdata->dirtyState |= 0x3;\n\tdata->bpSentNot = GX_FALSE;\n}\n\n// do the damn rlwimi thing\n#define FAST_FLAG_SET(regOrg, newFlag, shift, size)                                                                \\\n\tdo {                                                                                                           \\\n\t\t(regOrg) = (u32)__rlwimi((int)(regOrg), (int)(newFlag), (shift), (32 - (shift) - (size)), (31 - (shift))); \\\n\t} while (0);\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXData.h\" */\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/gx.h\" */\n\n// Blitting processor registers.\ntypedef enum _GXBPRegs {\n\t// gen mode\n\tGX_BP_REG_GENMODE = 0x0, // gen mode\n\n\t// display copy filters\n\tGX_BP_REG_DISPCOPYFILTER0 = 0x1, // display copy filter 0\n\tGX_BP_REG_DISPCOPYFILTER1 = 0x2, // display copy filter 1\n\tGX_BP_REG_DISPCOPYFILTER2 = 0x3, // display copy filter 2\n\tGX_BP_REG_DISPCOPYFILTER3 = 0x4, // display copy filter 3\n\n\t// indirect matrices\n\tGX_BP_REG_INDMTX0A = 0x6, // indirect matrix 0A\n\tGX_BP_REG_INDMTX0B = 0x7, // indirect matrix 0B\n\tGX_BP_REG_INDMTX0C = 0x8, // indirect matrix 0C\n\tGX_BP_REG_INDMTX1A = 0x9, // indirect matrix 1A\n\tGX_BP_REG_INDMTX1B = 0xA, // indirect matrix 1B\n\tGX_BP_REG_INDMTX1C = 0xB, // indirect matrix 1C\n\tGX_BP_REG_INDMTX2A = 0xC, // indirect matrix 2A\n\tGX_BP_REG_INDMTX2B = 0xD, // indirect matrix 2B\n\tGX_BP_REG_INDMTX2C = 0xE, // indirect matrix 2C\n\tGX_BP_REG_INDIMASK = 0xF, // indirect mask\n\n\t// indirect TEV stages\n\tGX_BP_REG_INDTEVSTAGE0  = 0x10, // indirect TEV stage 0\n\tGX_BP_REG_INDTEVSTAGE1  = 0x11, // indirect TEV stage 1\n\tGX_BP_REG_INDTEVSTAGE2  = 0x12, // indirect TEV stage 2\n\tGX_BP_REG_INDTEVSTAGE3  = 0x13, // indirect TEV stage 3\n\tGX_BP_REG_INDTEVSTAGE4  = 0x14, // indirect TEV stage 4\n\tGX_BP_REG_INDTEVSTAGE5  = 0x15, // indirect TEV stage 5\n\tGX_BP_REG_INDTEVSTAGE6  = 0x16, // indirect TEV stage 6\n\tGX_BP_REG_INDTEVSTAGE7  = 0x17, // indirect TEV stage 7\n\tGX_BP_REG_INDTEVSTAGE8  = 0x18, // indirect TEV stage 8\n\tGX_BP_REG_INDTEVSTAGE9  = 0x19, // indirect TEV stage 9\n\tGX_BP_REG_INDTEVSTAGE10 = 0x1A, // indirect TEV stage 10\n\tGX_BP_REG_INDTEVSTAGE11 = 0x1B, // indirect TEV stage 11\n\tGX_BP_REG_INDTEVSTAGE12 = 0x1C, // indirect TEV stage 12\n\tGX_BP_REG_INDTEVSTAGE13 = 0x1D, // indirect TEV stage 13\n\tGX_BP_REG_INDTEVSTAGE14 = 0x1E, // indirect TEV stage 14\n\tGX_BP_REG_INDTEVSTAGE15 = 0x1F, // indirect TEV stage 15\n\n\t// performance manips\n\tGX_BP_REG_SCISSORTL   = 0x20, // scissor top left\n\tGX_BP_REG_SCISSORBR   = 0x21, // scissor bottom right\n\tGX_BP_REG_LINEPTWIDTH = 0x22, // line point width\n\tGX_BP_REG_PERF0TRI    = 0x23, // performance 0 (triangle)\n\tGX_BP_REG_PERF0QUAD   = 0x24, // performance 0 (quad)\n\n\t// rasters\n\tGX_BP_REG_RAS1_SS0   = 0x25,\n\tGX_BP_REG_RAS1_SS1   = 0x26,\n\tGX_BP_REG_RAS1_IREF  = 0x27,\n\tGX_BP_REG_RAS1_TREF0 = 0x28,\n\tGX_BP_REG_RAS1_TREF1 = 0x29,\n\tGX_BP_REG_RAS1_TREF2 = 0x2A,\n\tGX_BP_REG_RAS1_TREF3 = 0x2B,\n\tGX_BP_REG_RAS1_TREF4 = 0x2C,\n\tGX_BP_REG_RAS1_TREF5 = 0x2D,\n\tGX_BP_REG_RAS1_TREF6 = 0x2E,\n\tGX_BP_REG_RAS1_TREF7 = 0x2F,\n\n\t// setup sizes\n\tGX_BP_REG_SU_SSIZE0 = 0x30,\n\tGX_BP_REG_SU_TSIZE0 = 0x31,\n\tGX_BP_REG_SU_SSIZE1 = 0x32,\n\tGX_BP_REG_SU_TSIZE1 = 0x33,\n\tGX_BP_REG_SU_SSIZE2 = 0x34,\n\tGX_BP_REG_SU_TSIZE2 = 0x35,\n\tGX_BP_REG_SU_SSIZE3 = 0x36,\n\tGX_BP_REG_SU_TSIZE3 = 0x37,\n\tGX_BP_REG_SU_SSIZE4 = 0x38,\n\tGX_BP_REG_SU_TSIZE4 = 0x39,\n\tGX_BP_REG_SU_SSIZE5 = 0x3A,\n\tGX_BP_REG_SU_TSIZE5 = 0x3B,\n\tGX_BP_REG_SU_SSIZE6 = 0x3C,\n\tGX_BP_REG_SU_TSIZE6 = 0x3D,\n\tGX_BP_REG_SU_SSIZE7 = 0x3E,\n\tGX_BP_REG_SU_TSIZE7 = 0x3F,\n\n\t// Z and blend controls\n\tGX_BP_REG_ZMODE      = 0x40,\n\tGX_BP_REG_BLENDMODE  = 0x41,\n\tGX_BP_REG_DSTALPHA   = 0x42,\n\tGX_BP_REG_ZCONTROL   = 0x43,\n\tGX_BP_REG_FIELDMASK  = 0x44,\n\tGX_BP_REG_DRAWDONE   = 0x45,\n\tGX_BP_REG_PETOKEN    = 0x47,\n\tGX_BP_REG_PETOKENINT = 0x48,\n\n\t// copying\n\tGX_BP_REG_TEXCOPYSRCXY   = 0x49,\n\tGX_BP_REG_TEXCOPYSRCWH   = 0x4A,\n\tGX_BP_REG_TEXCOPYDST     = 0x4B,\n\tGX_BP_REG_DISPCOPYSTRIDE = 0x4D,\n\tGX_BP_REG_DISPCOPYSCALEY = 0x4E,\n\tGX_BP_REG_COPYCLEARAR    = 0x4F,\n\tGX_BP_REG_COPYCLEARGB    = 0x50,\n\tGX_BP_REG_COPYCLEARZ     = 0x51,\n\tGX_BP_REG_COPYFILTER0    = 0x53,\n\tGX_BP_REG_COPYFILTER1    = 0x54,\n\n\t//\n\tGX_BP_REG_BOUNDINGBOX0 = 0x55,\n\tGX_BP_REG_BOUNDINGBOX1 = 0x56,\n\n\tGX_BP_REG_SCISSOROFFSET = 0x59,\n\n\t// texture memory\n\tGX_BP_REG_TMEMPRELOADADDR   = 0x60,\n\tGX_BP_REG_TMEMPRELOADEVEN   = 0x61,\n\tGX_BP_REG_TMEMPRELOADODD    = 0x62,\n\tGX_BP_REG_TMEMPRELOADMODE   = 0x63,\n\tGX_BP_REG_TMEMTLUTSRC       = 0x64,\n\tGX_BP_REG_TMEMTLUTDST       = 0x65,\n\tGX_BP_REG_TMEMTEXINVALIDATE = 0x66,\n\n\t// performance 1\n\tGX_BP_REG_PERF1     = 0x67,\n\tGX_BP_REG_FIELDMODE = 0x68,\n\n\t// set modes\n\tGX_BP_REG_SETMODE0_TEX0 = 0x80,\n\tGX_BP_REG_SETMODE0_TEX1 = 0x81,\n\tGX_BP_REG_SETMODE0_TEX2 = 0x82,\n\tGX_BP_REG_SETMODE0_TEX3 = 0x83,\n\tGX_BP_REG_SETMODE1_TEX0 = 0x84,\n\tGX_BP_REG_SETMODE1_TEX1 = 0x85,\n\tGX_BP_REG_SETMODE1_TEX2 = 0x86,\n\tGX_BP_REG_SETMODE1_TEX3 = 0x87,\n\n\t// set images\n\tGX_BP_REG_SETIMAGE0_TEX0 = 0x88,\n\tGX_BP_REG_SETIMAGE0_TEX1 = 0x89,\n\tGX_BP_REG_SETIMAGE0_TEX2 = 0x8A,\n\tGX_BP_REG_SETIMAGE0_TEX3 = 0x8B,\n\tGX_BP_REG_SETIMAGE1_TEX0 = 0x8C,\n\tGX_BP_REG_SETIMAGE1_TEX1 = 0x8D,\n\tGX_BP_REG_SETIMAGE1_TEX2 = 0x8E,\n\tGX_BP_REG_SETIMAGE1_TEX3 = 0x8F,\n\tGX_BP_REG_SETIMAGE2_TEX0 = 0x90,\n\tGX_BP_REG_SETIMAGE2_TEX1 = 0x91,\n\tGX_BP_REG_SETIMAGE2_TEX2 = 0x92,\n\tGX_BP_REG_SETIMAGE2_TEX3 = 0x93,\n\tGX_BP_REG_SETIMAGE3_TEX0 = 0x94,\n\tGX_BP_REG_SETIMAGE3_TEX1 = 0x95,\n\tGX_BP_REG_SETIMAGE3_TEX2 = 0x96,\n\tGX_BP_REG_SETIMAGE3_TEX3 = 0x97,\n\n\t// set texture lookups\n\tGX_BP_REG_SETTLUT_TEX0 = 0x98,\n\tGX_BP_REG_SETTLUT_TEX1 = 0x99,\n\tGX_BP_REG_SETTLUT_TEX2 = 0x9A,\n\tGX_BP_REG_SETTLUT_TEX3 = 0x9B,\n\n\t// set modes continued\n\tGX_BP_REG_SETMODE0_TEX4 = 0xA0,\n\tGX_BP_REG_SETMODE0_TEX5 = 0xA1,\n\tGX_BP_REG_SETMODE0_TEX6 = 0xA2,\n\tGX_BP_REG_SETMODE0_TEX7 = 0xA3,\n\tGX_BP_REG_SETMODE1_TEX4 = 0xA4,\n\tGX_BP_REG_SETMODE1_TEX5 = 0xA5,\n\tGX_BP_REG_SETMODE1_TEX6 = 0xA6,\n\tGX_BP_REG_SETMODE1_TEX7 = 0xA7,\n\n\t// set images continued\n\tGX_BP_REG_SETIMAGE0_TEX4 = 0xA8,\n\tGX_BP_REG_SETIMAGE0_TEX5 = 0xA9,\n\tGX_BP_REG_SETIMAGE0_TEX6 = 0xAA,\n\tGX_BP_REG_SETIMAGE0_TEX7 = 0xAB,\n\tGX_BP_REG_SETIMAGE1_TEX4 = 0xAC,\n\tGX_BP_REG_SETIMAGE1_TEX5 = 0xAD,\n\tGX_BP_REG_SETIMAGE1_TEX6 = 0xAE,\n\tGX_BP_REG_SETIMAGE1_TEX7 = 0xAF,\n\tGX_BP_REG_SETIMAGE2_TEX4 = 0xB0,\n\tGX_BP_REG_SETIMAGE2_TEX5 = 0xB1,\n\tGX_BP_REG_SETIMAGE2_TEX6 = 0xB2,\n\tGX_BP_REG_SETIMAGE2_TEX7 = 0xB3,\n\tGX_BP_REG_SETIMAGE3_TEX4 = 0xB4,\n\tGX_BP_REG_SETIMAGE3_TEX5 = 0xB5,\n\tGX_BP_REG_SETIMAGE3_TEX6 = 0xB6,\n\tGX_BP_REG_SETIMAGE3_TEX7 = 0xB7,\n\n\t// set texture lookups continued\n\tGX_BP_REG_SETTLUT_TEX4 = 0xB8,\n\tGX_BP_REG_SETTLUT_TEX5 = 0xB9,\n\tGX_BP_REG_SETTLUT_TEX6 = 0xBA,\n\tGX_BP_REG_SETTLUT_TEX7 = 0xBB,\n\n\t// TEV color manips\n\tGX_BP_REG_TEVCOLORCOMBINER0  = 0xC0,\n\tGX_BP_REG_TEVALPHACOMBINER0  = 0xC1,\n\tGX_BP_REG_TEVCOLORCOMBINER1  = 0xC2,\n\tGX_BP_REG_TEVALPHACOMBINER1  = 0xC3,\n\tGX_BP_REG_TEVCOLORCOMBINER2  = 0xC4,\n\tGX_BP_REG_TEVALPHACOMBINER2  = 0xC5,\n\tGX_BP_REG_TEVCOLORCOMBINER3  = 0xC6,\n\tGX_BP_REG_TEVALPHACOMBINER3  = 0xC7,\n\tGX_BP_REG_TEVCOLORCOMBINER4  = 0xC8,\n\tGX_BP_REG_TEVALPHACOMBINER4  = 0xC9,\n\tGX_BP_REG_TEVCOLORCOMBINER5  = 0xCA,\n\tGX_BP_REG_TEVALPHACOMBINER5  = 0xCB,\n\tGX_BP_REG_TEVCOLORCOMBINER6  = 0xCC,\n\tGX_BP_REG_TEVALPHACOMBINER6  = 0xCD,\n\tGX_BP_REG_TEVCOLORCOMBINER7  = 0xCE,\n\tGX_BP_REG_TEVALPHACOMBINER7  = 0xCF,\n\tGX_BP_REG_TEVCOLORCOMBINER8  = 0xD0,\n\tGX_BP_REG_TEVALPHACOMBINER8  = 0xD1,\n\tGX_BP_REG_TEVCOLORCOMBINER9  = 0xD2,\n\tGX_BP_REG_TEVALPHACOMBINER9  = 0xD3,\n\tGX_BP_REG_TEVCOLORCOMBINER10 = 0xD4,\n\tGX_BP_REG_TEVALPHACOMBINER10 = 0xD5,\n\tGX_BP_REG_TEVCOLORCOMBINER11 = 0xD6,\n\tGX_BP_REG_TEVALPHACOMBINER11 = 0xD7,\n\tGX_BP_REG_TEVCOLORCOMBINER12 = 0xD8,\n\tGX_BP_REG_TEVALPHACOMBINER12 = 0xD9,\n\tGX_BP_REG_TEVCOLORCOMBINER13 = 0xDA,\n\tGX_BP_REG_TEVALPHACOMBINER13 = 0xDB,\n\tGX_BP_REG_TEVCOLORCOMBINER14 = 0xDC,\n\tGX_BP_REG_TEVALPHACOMBINER14 = 0xDD,\n\tGX_BP_REG_TEVCOLORCOMBINER15 = 0xDE,\n\tGX_BP_REG_TEVALPHACOMBINER15 = 0xDF,\n\n\t// TEV registers\n\tGX_BP_REG_TEVREG0LO = 0xE0,\n\tGX_BP_REG_TEVREG0HI = 0xE1,\n\tGX_BP_REG_TEVREG1LO = 0xE2,\n\tGX_BP_REG_TEVREG1HI = 0xE3,\n\tGX_BP_REG_TEVREG2LO = 0xE4,\n\tGX_BP_REG_TEVREG2HI = 0xE5,\n\tGX_BP_REG_TEVREG3LO = 0xE6,\n\tGX_BP_REG_TEVREG3HI = 0xE7,\n\n\t// fog registers\n\tGX_BP_REG_FOGRANGE   = 0xE8,\n\tGX_BP_REG_FOGRANGEK0 = 0xE9,\n\tGX_BP_REG_FOGRANGEK1 = 0xEA,\n\tGX_BP_REG_FOGRANGEK2 = 0xEB,\n\tGX_BP_REG_FOGRANGEK3 = 0xEC,\n\tGX_BP_REG_FOGRANGEK4 = 0xED,\n\tGX_BP_REG_FOGPARAM0  = 0xEE,\n\tGX_BP_REG_FOGPARAM1  = 0xEF,\n\tGX_BP_REG_FOGPARAM2  = 0xF0,\n\tGX_BP_REG_FOGPARAM3  = 0xF1,\n\tGX_BP_REG_FOGCOLOR   = 0xF2,\n\n\t// performance manip registers\n\tGX_BP_REG_ALPHACOMPARE = 0xF3,\n\tGX_BP_REG_ZTEXTURE0    = 0xF4,\n\tGX_BP_REG_ZTEXTURE1    = 0xF5,\n\n\t// TEV K selectors\n\tGX_BP_REG_TEVKSEL0 = 0xF6,\n\tGX_BP_REG_TEVKSEL1 = 0xF7,\n\tGX_BP_REG_TEVKSEL2 = 0xF8,\n\tGX_BP_REG_TEVKSEL3 = 0xF9,\n\tGX_BP_REG_TEVKSEL4 = 0xFA,\n\tGX_BP_REG_TEVKSEL5 = 0xFB,\n\tGX_BP_REG_TEVKSEL6 = 0xFC,\n\tGX_BP_REG_TEVKSEL7 = 0xFD,\n\n\t// SS mask\n\tGX_BP_REG_SSMASK = 0xFE,\n} GXBPRegs;\n\ntypedef enum _GXFifoCmd {\n\tGX_FIFO_CMD_NOOP = 0x00, // no operation\n\n\tGX_FIFO_CMD_LOAD_BP_REG = 0x61, // load blitting processor reg\n\tGX_FIFO_CMD_LOAD_CP_REG = 0x08, // load command processor reg\n\tGX_FIFO_CMD_LOAD_XF_REG = 0x10, // load transform unit reg\n\n\tGX_FIFO_CMD_LOAD_INDX_A = 0x20, // load index A\n\tGX_FIFO_CMD_LOAD_INDX_B = 0x28, // load index B\n\tGX_FIFO_CMD_LOAD_INDX_C = 0x30, // load index C\n\tGX_FIFO_CMD_LOAD_INDX_D = 0x38, // load index D\n\n\tGX_FIFO_CMD_CALL_DL   = 0x40, // call displaylist\n\tGX_FIFO_CMD_INVAL_VTX = 0x48, // invalid vertex\n\n} GXFifoCmd;", "diff_flags": [], "diff_label": "", "libraries": []}