{"compiler": "armcc_40_821", "compiler_flags": "--cpp --arm --split_sections --debug --no_debug_macros --gnu --debug_info=line_inlining_extensions --data_reorder --signed_chars --multibyte_chars --remove_unneeded_entities --force_new_nothrow --remarks --no_rtti -O3", "source_code": "/* No decompiler yet implemented for arm32 */\n#define GET_THREAD_LOCAL_STORAGE(r) __asm { mrc p15, 0, r, c13, c0, 3 }\n\nnamespace nn {\nnamespace err {\nnamespace CTR {\n\nstruct StaticBufferTranslationDescriptor {\n};\n\nstruct IPCStaticBuffer {\n    StaticBufferTranslationDescriptor translationDescriptor;\n    void* ptr;\n};\n\nstruct ThreadLocalInfo {\n    char data[0x80];\n    char ipcCommand[0x100];\n    IPCStaticBuffer ipcStaticBuffers[0x10];\n};\n\nstruct Request {\n    u32 headerCode;\n    u32 data[31];\n};\n\nstruct Response {\n    u32 headerCode;\n    Result result;\n};\n\nstruct Lock {\n    u32 unk0;\n    ThreadLocalInfo* threadLocalInfo;\n    u32 unk8;\n};\n\nnamespace {\n\nLock sLock;\n    \n// inline asm void BusyWait(s32 arg0, void* target, s32 arg2, s32 value) {\n// startLoop\n//     ldrex r0, [r1]\n//     strex r2, r3, [r1]\n//     cmp r2, #0\n//     bne startLoop\n//     bx lr\n// }\n\n// __attribute__((noinline)) void Throw(nn::err::CTR::FatalErrInfo& fatalErrInfo) {\n//     Result result;\n\n//     sLock.Enter();\n\n//     if (!sFatalErrSession.IsValid()) {\n//         result = svc::ConnectToPort(&sFatalErrSession, FATAL_ERR_PORT_NAME);\n//         if (result.Succeeded()) {\n//             result = Result();\n//         }\n//     }\n//     if (result.Succeeded()) {\n//         svc::GetProcessId(&fatalErrInfo.processID, Handle(PSEUDO_HANDLE_CURRENT_PROCESS));\n//         FatalErr(sFatalErrSession).Throw(fatalErrInfo);\n//         if (sFatalErrSession.IsValid()) {\n//             svc::CloseHandle(sFatalErrSession);\n//             sFatalErrSession = Handle();\n//         }\n//     }\n\n//     if (fatalErrInfo.errorType != CARD_REMOVED) {\n//         os::LightEvent lightEvent;\n\n//         BusyWait(0, &lightEvent, 0, -1);\n//         lightEvent.Wait();\n//     }\n//     sLock.Leave();\n// }\n    \n}\n\n}\n}\n}\n", "context": "#pragma once\n\n#define UNK_RETURN int\n#define UNK_TYPE int\n\n#define NULL 0\n\ntypedef signed char s8;\ntypedef unsigned char u8;\ntypedef signed short s16;\ntypedef unsigned short u16;\ntypedef signed int s32;\ntypedef unsigned int u32;\ntypedef signed long long s64;\ntypedef unsigned long long u64;\n\ntypedef float f32;\ntypedef double f64;\n\n#ifdef __cplusplus\n\n#define nullptr NULL\n\ntypedef u32 uintptr_t;\ntypedef s32 intptr_t;\n\n#endif\n\nnamespace nn {\n\nclass Result {\npublic:\n    Result();\n\n    bool Failed() const {\n        return mResult & 0x80000000;\n    }\n\n    bool Succeeded() const {\n        return !Failed();\n    }\n\nprivate:\n    u32 mResult;\n};\n\n} // nn\n\nnamespace nn {\n\nclass Handle {\npublic:\n    Handle();\nprivate:\n    u32 mHandle;\n};\n\n} // nn\n\nnamespace nn {\n\nnamespace err {\n\nnamespace CTR {\n\nenum FatalErrorType {\n    GENERIC,\n    CORRUPTED,\n    CARD_REMOVED,\n    EXCEPTION,\n    RESULT_FAILURE,\n    LOGGED\n};\n\nenum ExceptionType {\n    PREFETCH_ABORT,\n    DATA_ABORT,\n    UNDEFINED_EXCEPTION,\n    VFP_EXCEPTION\n};\n\nstruct ExceptionInfo {\n    ExceptionType exceptionType;\n    u32 statusRegister;\n    u32 abortRegister;\n    u32 fpexc;\n    u32 fpinst;\n    u32 fpinst2;\n};\n\nstruct CPURegisters {\n    u32 r[13];\n    u32 sp;\n    u32 lr;\n    u32 pc;\n    u32 cpsr;\n};\n\nstruct Exception {\n    ExceptionInfo exceptionInfo;\n    CPURegisters cpuRegisters;\n};\n\nstruct Failure {\n    char message[0x60];\n};\n\nunion ExceptionData {\n    Exception exception;\n    Failure failure;\n};\n\nstruct FatalErrInfo {\n    FatalErrorType errorType;\n    u8 revisionHigh;\n    u16 revisionLow;\n    Result fatalResult;\n    u32 linkRegister;\n    u32 processID;\n    u64 titleID;\n    u64 appletTitleID;\n    ExceptionData data;\n};\n\nclass FatalErr {\npublic:\n    Result Throw(const FatalErrInfo& fatalErrorInfo);\nprivate:\n    Handle handle;\n};\n\nnamespace {\n\nvoid Throw(nn::err::CTR::FatalErrInfo&);\n\n} // (anonymous namespace)\n\nvoid ThrowFatalErr(nn::Result);\n\n} // CTR\n\n} // err\n\n} // nn\n", "diff_flags": [], "diff_label": "Throw", "libraries": []}