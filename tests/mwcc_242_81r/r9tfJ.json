{"compiler": "mwcc_242_81r", "compiler_flags": "-O4 -fp hard -sdata 0 -sdata2 0 -Cpp_exceptions off -enum int -sym on", "source_code": "#define mEv_MonthDay(m, d) (((u8)(m) << 8) | ((u8)(d)))\n\nstatic void init_weekly_event() {\n  u16 sched_date;\n  lbRTC_time_c* rtc_time = &Common_Get(time.rtc_time);\n  mEv_kabu_peddler_c* kabu_peddler_data = &Save_Get(event_save_data).weekly.kabu_peddler;\n  mEv_MonthDay_u today_date;\n  u8 flag = 0;\n  u16 ghost_date;\n  u16 ghost_date2;\n  u16 monday_date;\n  u16 friday_date;\n  u16* event_dates = Save_Get(event_save_common).dates;\n\n  today_date.month = rtc_time->month;\n  today_date.day = rtc_time->day;\n  sched_date = event_dates[mEv_SAVE_DATE_WEEKLY];\n  \n  switch (rtc_time->weekday) {\n    case lbRTC_SUNDAY:\n    {\n      if (today_date.raw != sched_date) {\n        mEv_ClearEventKabuPeddler(kabu_peddler_data);\n        sched_date = today_date.raw;\n        event_dates[mEv_SAVE_DATE_WEEKLY] = sched_date;\n        Save_Get(event_save_common).weekly_event.type = mEv_EVENT_KABU_PEDDLER;\n        flag = 1;\n      }\n      break;\n    }\n\n    case lbRTC_SATURDAY:\n    {\n      if (today_date.raw != sched_date) {\n        sched_date = today_date.raw;\n        event_dates[mEv_SAVE_DATE_WEEKLY] = sched_date;\n        Save_Get(event_save_common).weekly_event.type = mEv_EVENT_KK_SLIDER;\n        flag = 1;\n      }\n      break;\n    }\n\n    default:\n    {\n      monday_date = after_n_day(today_date.raw, lbRTC_MONDAY - rtc_time->weekday);\n      friday_date = after_n_day(today_date.raw, lbRTC_FRIDAY - rtc_time->weekday);\n\n      if (sched_date == 0 || check_date_range(sched_date, monday_date, friday_date) == FALSE) {\n        u8 ofs = 1 + (today_date.raw + rtc_time->hour) % 5;\n        /* Schedule a new date for the event between Monday & Friday */\n        sched_date = after_n_day(today_date.raw, ofs - rtc_time->weekday);\n        event_dates[mEv_SAVE_DATE_WEEKLY] = sched_date;\n        Save_Get(event_save_common).weekly_event.type = mEv_EVENT_DOZAEMON; // Gulliver\n        Save_Get(event_save_common).current_event_state = 0;\n      }\n\n      if (sched_date == today_date.raw) {\n        flag = mEv_EVENT_DOZAEMON;\n      }\n\n      break;\n    }\n  }\n\n  if (rtc_time->weekday == lbRTC_SATURDAY || (rtc_time->weekday != lbRTC_SUNDAY && sched_date != today_date.raw)) {\n    if (\n      Common_Get(player_no) != mPr_FOREIGNER &&\n      Save_Get(now_npc_max) >= ANIMAL_NUM_MAX &&\n      Save_Get(bridge).exists != TRUE &&\n      mSC_LightHouse_travel_check() == FALSE\n    ) {\n      flag = mEv_EVENT_SONCHO_BRIDGE_MAKE;\n    }\n\n    /* TODO: fix bridge date comparison hack */\n    if (flag == mEv_EVENT_SONCHO_BRIDGE_MAKE && Save_Get(event_save_common).bridge_day != today_date.raw) {\n      Save_Get(event_save_common).bridge_day = today_date.raw;\n      Save_Get(event_save_common).bridge_flags.raw++;\n    }\n  }\n\n  if (\n    flag != mEv_EVENT_DOZAEMON &&\n    flag != mEv_EVENT_SONCHO_BRIDGE_MAKE &&\n    (mGH_check_birth2() || mMC_check_birth())\n  ) {\n    flag = mEv_EVENT_MASK_CAT;\n  }\n\n  Save_Get(event_save_common).weekly_event.flags = flag;\n  Save_Get(event_save_common).ghost_event_type = mEv_EVENT_NUM; // unset?\n  ghost_date = Save_Get(event_save_common).ghost_day;\n  monday_date = after_n_day(today_date.raw, -lbRTC_WEEK);\n  friday_date = after_n_day(today_date.raw, 4);\n\n  if (ghost_date == 0 || check_date_range(ghost_date, monday_date, friday_date) == FALSE) {\n    ghost_date = after_n_day(today_date.raw, 2 + RANDOM(3));\n    Save_Get(event_save_common).ghost_day = ghost_date;\n  }\n\n  /* Spawn Wisp if his scheduled appearance date is within [today-7, today] */\n  if (check_date_range(ghost_date, monday_date, today_date.raw)) {\n    Save_Get(event_save_common).ghost_event_type = mEv_EVENT_GHOST;\n  }\n}", "context": "typedef signed char s8;\ntypedef signed short s16;\ntypedef signed long s32;\ntypedef signed long long s64;\ntypedef unsigned char u8;\ntypedef unsigned short u16;\ntypedef unsigned long u32;\ntypedef unsigned long size_t;\ntypedef unsigned long long u64;\ntypedef unsigned int uint;\n\ntypedef volatile u8 vu8;\ntypedef volatile u16 vu16;\ntypedef volatile u32 vu32;\ntypedef volatile u64 vu64;\ntypedef volatile s8 vs8;\ntypedef volatile s16 vs16;\ntypedef volatile s32 vs32;\ntypedef volatile s64 vs64;\n\ntypedef float f32;\ntypedef double f64;\ntypedef volatile f32 vf32;\ntypedef volatile f64 vf64;\n\ntypedef int BOOL;\ntypedef unsigned int uintptr_t; // Manually added\n\n// Pointer to unknown, to be determined at a later date.\ntypedef void* unkptr;\ntypedef u32 unknown;\n\n#define TRUE 1\n#define FALSE 0\n#define NULL ((void*)0)\n#define nullptr 0\n\ntypedef struct __va_list_struct {\n    char gpr;\n    char fpr;\n    char reserved[2];\n    char* input_arg_area;\n    char* reg_save_area;\n} _va_list_struct;\n\ntypedef _va_list_struct __va_list[1];\n\n#define __va_start(list, fmt) __builtin_va_info(&list)\n#define __va_arg(list, type) (*((type*)__va_arg(ap, _var_arg_typeof(type))))\n#define va_start __va_start\n#define va_arg __va_arg\n#define va_end __va_end\n#define va_list __va_list\n#define __va_end(list) ((void)0)\n    \ntypedef u16 mActor_name_t;\ntypedef struct actor_s ACTOR;\n\ntypedef struct game_play_s GAME_PLAY;\n\ntypedef struct rgba_t { //can be put in other place\n    u8 r, g, b, a;\n} rgba_t;\n\n#define mEv_SUBTYPE_BITS 29\n#define mEv_TYPE_BITMASK (0b111 << mEv_SUBTYPE_BITS)\n#define mEv_SUBTYPE_BITMASK ((1 << mEv_SUBTYPE_BITS) - 1)\n\n#define mEv_GET_TYPE(event) (((event) & mEv_TYPE_BITMASK) >> mEv_SUBTYPE_BITS)\n#define mEv_SET_TYPE(t) (((t) << mEv_SUBTYPE_BITS) & mEv_TYPE_BITMASK)\n\n#define mEv_GET_SUBTYPE(event) ((event) & mEv_SUBTYPE_BITMASK)\n#define mEv_SET_SUBTYPE(s) ((s) & mEv_SUBTYPE_BITMASK)\n\n#define mEv_SET(type, subtype) (mEv_SET_TYPE(type) | mEv_SET_TYPE(subtype))\n\nenum event_type {\n  mEv_SPNPC_EVENT, /* special NPC events */\n  mEv_SAVED_EVENT, /* events saved to data */\n  mEv_TYPE2_EVENT, /* unused? */\n  mEv_TYPE3_EVENT, /* unused? */\n  mEv_TYPE4_EVENT, /* unused? */\n  mEv_DAILY_EVENT, /* checked daily always? aSL_ReportShopOpen2Event has event 3 */\n  mEv_SPECL_EVENT, /* ??? secondary special npc event data? */\n\n  mEv_EVENT_TYPE_NUM\n};\n\n#define ATTRIBUTE_ALIGN(num) __attribute__((aligned(num)))\n\n#define _SHIFTL(v, s, w)\t\\\n    ((unsigned int) (((unsigned int)(v) & ((0x01 << (w)) - 1)) << (s)))\n#define _SHIFTR(v, s, w)\t\\\n    ((unsigned int)(((unsigned int)(v) >> (s)) & ((0x01 << (w)) - 1)))\n\n#define G_OFF 0\n#define G_ON 1\n\n#define F3DEX_GBI_2\n#define _LANGUAGE_C\n\n#ifdef    F3DEX_GBI_2\n# ifndef  F3DEX_GBI\n#  define F3DEX_GBI\n# endif\n#define\tG_NOOP\t\t\t0x00\n#define\tG_RDPHALF_2\t\t0xf1\n#define\tG_SETOTHERMODE_H\t0xe3\n#define\tG_SETOTHERMODE_L\t0xe2\n#define\tG_RDPHALF_1\t\t0xe1\n#define\tG_SPNOOP\t\t0xe0\n#define\tG_ENDDL\t\t\t0xdf\n#define\tG_DL\t\t\t0xde\n#define\tG_LOAD_UCODE\t\t0xdd\n#define\tG_MOVEMEM\t\t0xdc\n#define\tG_MOVEWORD\t\t0xdb\n#define\tG_MTX\t\t\t0xda\n#define G_GEOMETRYMODE\t\t0xd9\n#define\tG_POPMTX\t\t0xd8\n#define\tG_TEXTURE\t\t0xd7\n#define\tG_DMA_IO\t\t0xd6\n#define\tG_SPECIAL_1\t\t0xd5\n#define\tG_SPECIAL_2\t\t0xd4\n#define\tG_SPECIAL_3\t\t0xd3\n\n#define\tG_VTX\t\t\t0x01\n#define\tG_MODIFYVTX\t\t0x02\n#define\tG_CULLDL\t\t0x03\n#define\tG_BRANCH_Z\t\t0x04\n#define\tG_TRI1\t\t\t0x05\n#define G_TRI2\t\t\t0x06\n#define G_QUAD\t\t\t0x07\n#define G_LINE3D\t\t0x08\n#else\t/* F3DEX_GBI_2 */\n\n/* DMA commands: */\n#define\tG_SPNOOP\t\t0\t/* handle 0 gracefully */\n#define\tG_MTX\t\t\t1\n#define G_RESERVED0\t\t2\t/* not implemeted */\n#define G_MOVEMEM\t\t3\t/* move a block of memory (up to 4 words) to dmem */\n#define\tG_VTX\t\t\t4\n#define G_RESERVED1\t\t5\t/* not implemeted */\n#define\tG_DL\t\t\t6\n#define G_RESERVED2\t\t7\t/* not implemeted */\n#define G_RESERVED3\t\t8\t/* not implemeted */\n#define G_SPRITE2D_BASE\t\t9\t/* sprite command */\n\n/* IMMEDIATE commands: */\n#define\tG_IMMFIRST\t\t-65\n#define\tG_TRI1\t\t\t(G_IMMFIRST-0)\n#define G_CULLDL\t\t(G_IMMFIRST-1)\n#define\tG_POPMTX\t\t(G_IMMFIRST-2)\n#define\tG_MOVEWORD\t\t(G_IMMFIRST-3)\n#define\tG_TEXTURE\t\t(G_IMMFIRST-4)\n#define\tG_SETOTHERMODE_H\t(G_IMMFIRST-5)\n#define\tG_SETOTHERMODE_L\t(G_IMMFIRST-6)\n#define G_ENDDL\t\t\t(G_IMMFIRST-7)\n#define G_SETGEOMETRYMODE\t(G_IMMFIRST-8)\n#define G_CLEARGEOMETRYMODE\t(G_IMMFIRST-9)\n#define G_LINE3D\t\t(G_IMMFIRST-10)\n#define G_RDPHALF_1\t\t(G_IMMFIRST-11)\n#define G_RDPHALF_2\t\t(G_IMMFIRST-12)\n#if (defined(F3DEX_GBI)||defined(F3DLP_GBI))\n#  define G_MODIFYVTX\t\t(G_IMMFIRST-13)\n#  define G_TRI2\t\t(G_IMMFIRST-14)\n#  define G_BRANCH_Z\t\t(G_IMMFIRST-15)\n#  define G_LOAD_UCODE\t\t(G_IMMFIRST-16)\n#else\n#  define G_RDPHALF_CONT\t(G_IMMFIRST-13)\n#endif\n\n/* We are overloading 2 of the immediate commands\n   to keep the byte alignment of dmem the same */\n\n#define G_SPRITE2D_SCALEFLIP    (G_IMMFIRST-1)\n#define G_SPRITE2D_DRAW         (G_IMMFIRST-2)\n\n/* RDP commands: */\n#define\tG_NOOP\t\t\t0xc0\t/*   0 */\n\n#endif\t/* F3DEX_GBI_2 */\n\n/* RDP commands: */\n#define\tG_SETCIMG\t\t0xff\t/*  -1 */\n#define\tG_SETZIMG\t\t0xfe\t/*  -2 */\n#define\tG_SETTIMG\t\t0xfd\t/*  -3 */\n#define\tG_SETCOMBINE\t\t0xfc\t/*  -4 */\n#define\tG_SETENVCOLOR\t\t0xfb\t/*  -5 */\n#define\tG_SETPRIMCOLOR\t\t0xfa\t/*  -6 */\n#define\tG_SETBLENDCOLOR\t\t0xf9\t/*  -7 */\n#define\tG_SETFOGCOLOR\t\t0xf8\t/*  -8 */\n#define\tG_SETFILLCOLOR\t\t0xf7\t/*  -9 */\n#define\tG_FILLRECT\t\t0xf6\t/* -10 */\n#define\tG_SETTILE\t\t0xf5\t/* -11 */\n#define\tG_LOADTILE\t\t0xf4\t/* -12 */\n#define\tG_LOADBLOCK\t\t0xf3\t/* -13 */\n#define\tG_SETTILESIZE\t\t0xf2\t/* -14 */\n#define\tG_LOADTLUT\t\t0xf0\t/* -16 */\n#define\tG_RDPSETOTHERMODE\t0xef\t/* -17 */\n#define\tG_SETPRIMDEPTH\t\t0xee\t/* -18 */\n#define\tG_SETSCISSOR\t\t0xed\t/* -19 */\n#define\tG_SETCONVERT\t\t0xec\t/* -20 */\n#define\tG_SETKEYR\t\t0xeb\t/* -21 */\n#define\tG_SETKEYGB\t\t0xea\t/* -22 */\n#define\tG_RDPFULLSYNC\t\t0xe9\t/* -23 */\n#define\tG_RDPTILESYNC\t\t0xe8\t/* -24 */\n#define\tG_RDPPIPESYNC\t\t0xe7\t/* -25 */\n#define\tG_RDPLOADSYNC\t\t0xe6\t/* -26 */\n#define G_TEXRECTFLIP\t\t0xe5\t/* -27 */\n#define G_TEXRECT\t\t0xe4\t/* -28 */\n\n\n/* \n * The following commands are the \"generated\" RDP commands; the user\n * never sees them, the RSP microcode generates them.\n *\n * The layout of the bits is magical, to save work in the ucode.\n * These id's are -56, -52, -54, -50, -55, -51, -53, -49, ...\n *                                 edge, shade, texture, zbuff bits:  estz\n */\n#define G_TRI_FILL\t\t0xc8 /* fill triangle:            11001000 */\n#define G_TRI_SHADE\t\t0xcc /* shade triangle:           11001100 */\n#define G_TRI_TXTR\t\t0xca /* texture triangle:         11001010 */\n#define G_TRI_SHADE_TXTR\t0xce /* shade, texture triangle:  11001110 */\n#define G_TRI_FILL_ZBUFF\t0xc9 /* fill, zbuff triangle:     11001001 */\n#define G_TRI_SHADE_ZBUFF\t0xcd /* shade, zbuff triangle:    11001101 */\n#define G_TRI_TXTR_ZBUFF\t0xcb /* texture, zbuff triangle:  11001011 */\n#define G_TRI_SHADE_TXTR_ZBUFF\t0xcf /* shade, txtr, zbuff trngl: 11001111 */\n\n/*\n * A TRI_FILL triangle is just the edges. You need to set the DP\n * to use primcolor, in order to see anything. (it is NOT a triangle\n * that gets rendered in 'fill mode'. Triangles can't be rendered\n * in 'fill mode')\n *\n * A TRI_SHADE is a gouraud triangle that has colors interpolated.\n * Flat-shaded triangles (from the software) are still gouraud shaded,\n * it's just the colors are all the same and the deltas are 0.\n *\n * Other triangle types, and combinations are more obvious.\n */\n\n/* masks to build RDP triangle commands: */\n#define G_RDP_TRI_FILL_MASK\t0x08\n#define G_RDP_TRI_SHADE_MASK\t0x04\n#define G_RDP_TRI_TXTR_MASK\t0x02\t\t\n#define G_RDP_TRI_ZBUFF_MASK\t0x01\t\t\n\n/*\n * HACK:\n * This is a dreadful hack. For version 1.0 hardware, there are still\n * some 'bowtie' hangs. This parameter can be increased to avoid\n * the hangs. Every increase of 4 chops one scanline off of every\n * triangle. Values of 4,8,12 should be sufficient to avoid any\n * bowtie hang.\n *\n * Change this value, then recompile ALL of your program (including static\n * display lists!)\n *\n * THIS WILL BE REMOVED FOR HARDWARE VERSION 2.0!\n */\n#define BOWTIE_VAL\t0\n\n\n/* gets added to RDP command, in order to test for addres fixup: */\n#define G_RDP_ADDR_FIXUP\t3\t/* |RDP cmds| <= this, do addr fixup */\n#ifdef _LANGUAGE_ASSEMBLY\n#define G_RDP_TEXRECT_CHECK\t((-1*G_TEXRECTFLIP)& 0xff)\n#endif\n\n/* macros for command parsing: */\n#define\tGDMACMD(x)\t\t(x)\n#define\tGIMMCMD(x)\t\t(G_IMMFIRST-(x))\n#define\tGRDPCMD(x)\t\t(0xff-(x))\n\n#define\tG_DMACMDSIZ\t\t128\n#define\tG_IMMCMDSIZ\t\t64\n#define\tG_RDPCMDSIZ\t\t64\n\n/*\n * Coordinate shift values, number of bits of fraction\n */\n#define\tG_TEXTURE_IMAGE_FRAC\t2\n#define\tG_TEXTURE_SCALE_FRAC\t16\n#define\tG_SCALE_FRAC\t\t8\n#define\tG_ROTATE_FRAC\t\t16\n\n/*\n * Parameters to graphics commands\n */\n\n/*\n * Data packing macros\n */\n\n/*\n * Maximum z-buffer value, used to initialize the z-buffer.\n * Note : this number is NOT the viewport z-scale constant.\n * See the comment next to G_MAXZ for more info.\n */\n#define\tG_MAXFBZ\t\t0x3fff\t/* 3b exp, 11b mantissa */\n\n#define\tGPACK_RGBA5551(r, g, b, a)\t((((r)<<8) & 0xf800) | \t\t\\\n\t\t\t\t\t (((g)<<3) & 0x7c0) |\t\t\\\n\t\t\t\t\t (((b)>>2) & 0x3e) | ((a) & 0x1))\n#define\tGPACK_ZDZ(z, dz)\t\t((z) << 2 | (dz))\n\n/*\n * G_MTX: parameter flags\n */\n#ifdef\tF3DEX_GBI_2\n# define G_MTX_MODELVIEW\t0x00\t/* matrix types */\n# define G_MTX_PROJECTION\t0x04\n# define G_MTX_MUL\t\t0x00\t/* concat or load */\n# define G_MTX_LOAD\t\t0x02\n# define G_MTX_NOPUSH\t\t0x00\t/* push or not */\n# define G_MTX_PUSH\t\t0x01\n#else\t/* F3DEX_GBI_2 */\n# define G_MTX_MODELVIEW\t0x00\t/* matrix types */\n# define G_MTX_PROJECTION\t0x01\n# define G_MTX_MUL\t\t0x00\t/* concat or load */\n# define G_MTX_LOAD\t\t0x02\n# define G_MTX_NOPUSH\t\t0x00\t/* push or not */\n# define G_MTX_PUSH\t\t0x04\n#endif\t/* F3DEX_GBI_2 */\n\n/*\n * flags for G_SETGEOMETRYMODE\n * (this rendering state is maintained in RSP)\n *\n * DO NOT USE THE LOW 8 BITS OF GEOMETRYMODE:\n * The weird bit-ordering is for the micro-code: the lower byte\n * can be OR'd in with G_TRI_SHADE (11001100) to construct \n * the triangle command directly. Don't break it...\n *\n * DO NOT USE THE HIGH 8 BITS OF GEOMETRYMODE:\n * The high byte is OR'd with 0x703 to form the clip code mask.\n * If it is set to 0x04, this will cause near clipping to occur.\n * If it is zero, near clipping will not occur.\n *\n * Further explanation:\n * G_SHADE is necessary in order to see the color that you passed\n * down with the vertex. If G_SHADE isn't set, you need to set the DP\n * appropriately and use primcolor to see anything.\n *\n * G_SHADING_SMOOTH enabled means use all 3 colors of the triangle.\n * If it is not set, then do 'flat shading', where only one vertex color \n * is used (and all 3 vertices are set to that same color by the ucode)\n * See the man page for gSP1Triangle().\n *\n */\n#define G_ZBUFFER\t\t0x00000001\n#define G_SHADE\t\t\t0x00000004\t/* enable Gouraud interp */\n/* rest of low byte reserved for setup ucode */\n#ifdef\tF3DEX_GBI_2\n# define G_TEXTURE_ENABLE\t0x00000000\t/* Ignored               */\n# define G_SHADING_SMOOTH\t0x00200000\t/* flat or smooth shaded */\n# define G_CULL_FRONT\t\t0x00000200\n# define G_CULL_BACK\t\t0x00000400\n# define G_CULL_BOTH\t\t0x00000600\t/* To make code cleaner */\n#else\n# define G_TEXTURE_ENABLE\t0x00000002\t/* Microcode use only */\n# define G_SHADING_SMOOTH\t0x00000200\t/* flat or smooth shaded */\n# define G_CULL_FRONT\t\t0x00001000\n# define G_CULL_BACK\t\t0x00002000\n# define G_CULL_BOTH\t\t0x00003000\t/* To make code cleaner */\n#endif\n#define G_FOG\t\t\t0x00010000\n#define G_LIGHTING\t\t0x00020000\n#define G_TEXTURE_GEN\t\t0x00040000\n#define G_TEXTURE_GEN_LINEAR\t0x00080000\n#define G_LOD\t\t\t0x00100000\t/* NOT IMPLEMENTED */\n#if\t(defined(F3DEX_GBI)||defined(F3DLP_GBI))\n# define G_CLIPPING\t\t0x00800000\n#else\n# define G_CLIPPING\t\t0x00000000\n#endif\n\n#ifdef _LANGUAGE_ASSEMBLY\n#define G_FOG_H\t\t\t(G_FOG/0x10000)\n#define G_LIGHTING_H\t\t(G_LIGHTING/0x10000)\n#define G_TEXTURE_GEN_H\t\t(G_TEXTURE_GEN/0x10000)\n#define G_TEXTURE_GEN_LINEAR_H\t(G_TEXTURE_GEN_LINEAR/0x10000)\n#define G_LOD_H\t\t\t(G_LOD/0x10000)\t/* NOT IMPLEMENTED */\n#if\t(defined(F3DEX_GBI)||defined(F3DLP_GBI))\n#  define G_CLIPPING_H\t\t(G_CLIPPING/0x10000)\n#endif\n#endif\n\n/* Need these defined for Sprite Microcode */\n#ifdef _LANGUAGE_ASSEMBLY\n#define\tG_TX_LOADTILE\t7\n#define\tG_TX_RENDERTILE\t0\n\n#define\tG_TX_NOMIRROR\t0\n#define\tG_TX_WRAP\t0\n#define\tG_TX_MIRROR\t0x1\n#define\tG_TX_CLAMP\t0x2\n#define\tG_TX_NOMASK\t0\n#define\tG_TX_NOLOD\t0\n#endif\n\n/*\n * G_SETIMG fmt: set image formats\n */\n#define G_IM_FMT_RGBA\t0\n#define G_IM_FMT_YUV\t1\n#define G_IM_FMT_CI\t2\n#define G_IM_FMT_IA\t3\n#define G_IM_FMT_I\t4\n\n/*\n * G_SETIMG siz: set image pixel size\n */\n#define G_IM_SIZ_4b\t0\n#define G_IM_SIZ_8b\t1\n#define G_IM_SIZ_16b\t2\n#define G_IM_SIZ_32b\t3\n#define G_IM_SIZ_DD\t5\n\n#define G_IM_SIZ_4b_BYTES\t\t0\n#define G_IM_SIZ_4b_TILE_BYTES\tG_IM_SIZ_4b_BYTES\n#define G_IM_SIZ_4b_LINE_BYTES\tG_IM_SIZ_4b_BYTES\n\n#define G_IM_SIZ_8b_BYTES\t\t1\n#define G_IM_SIZ_8b_TILE_BYTES\tG_IM_SIZ_8b_BYTES\n#define G_IM_SIZ_8b_LINE_BYTES\tG_IM_SIZ_8b_BYTES\n\n#define G_IM_SIZ_16b_BYTES\t\t2\n#define G_IM_SIZ_16b_TILE_BYTES\tG_IM_SIZ_16b_BYTES\n#define G_IM_SIZ_16b_LINE_BYTES\tG_IM_SIZ_16b_BYTES\n\n#define G_IM_SIZ_32b_BYTES\t\t4\n#define G_IM_SIZ_32b_TILE_BYTES\t2\n#define G_IM_SIZ_32b_LINE_BYTES\t2\n\n#define G_IM_SIZ_4b_LOAD_BLOCK\tG_IM_SIZ_16b\n#define G_IM_SIZ_8b_LOAD_BLOCK\tG_IM_SIZ_16b\n#define G_IM_SIZ_16b_LOAD_BLOCK\tG_IM_SIZ_16b\n#define G_IM_SIZ_32b_LOAD_BLOCK\tG_IM_SIZ_32b\n\n#define G_IM_SIZ_4b_SHIFT  2\n#define G_IM_SIZ_8b_SHIFT  1\n#define G_IM_SIZ_16b_SHIFT 0\n#define G_IM_SIZ_32b_SHIFT 0\n\n#define G_IM_SIZ_4b_INCR  3\n#define G_IM_SIZ_8b_INCR  1\n#define G_IM_SIZ_16b_INCR 0\n#define G_IM_SIZ_32b_INCR 0\n\n/*\n * G_SETCOMBINE: color combine modes\n */\n/* Color combiner constants: */\n#define G_CCMUX_COMBINED\t0\n#define G_CCMUX_TEXEL0\t\t1\n#define G_CCMUX_TEXEL1\t\t2\n#define G_CCMUX_PRIMITIVE\t3\n#define G_CCMUX_SHADE\t\t4\n#define G_CCMUX_ENVIRONMENT\t5\n#define G_CCMUX_CENTER\t\t6\n#define G_CCMUX_SCALE\t\t6\n#define G_CCMUX_COMBINED_ALPHA\t7\n#define G_CCMUX_TEXEL0_ALPHA\t8\n#define G_CCMUX_TEXEL1_ALPHA\t9\n#define G_CCMUX_PRIMITIVE_ALPHA\t10\n#define G_CCMUX_SHADE_ALPHA\t11\n#define G_CCMUX_ENV_ALPHA\t12\n#define G_CCMUX_LOD_FRACTION\t13\n#define G_CCMUX_PRIM_LOD_FRAC\t14\n#define G_CCMUX_NOISE\t\t7\n#define G_CCMUX_K4\t\t7\n#define G_CCMUX_K5\t\t15\n#define G_CCMUX_1\t\t6\n#define G_CCMUX_0\t\t31\n\n/* Alpha combiner constants: */\n#define G_ACMUX_COMBINED\t0\n#define G_ACMUX_TEXEL0\t\t1\n#define G_ACMUX_TEXEL1\t\t2\n#define G_ACMUX_PRIMITIVE\t3\n#define G_ACMUX_SHADE\t\t4\n#define G_ACMUX_ENVIRONMENT\t5\n#define G_ACMUX_LOD_FRACTION\t0\n#define G_ACMUX_PRIM_LOD_FRAC\t6\n#define G_ACMUX_1\t\t6\n#define G_ACMUX_0\t\t7\n\n/* typical CC cycle 1 modes */\n#define\tG_CC_PRIMITIVE\t\t0, 0, 0, PRIMITIVE, 0, 0, 0, PRIMITIVE\n#define\tG_CC_SHADE\t\t0, 0, 0, SHADE, 0, 0, 0, SHADE\n#define\tG_CC_MODULATEI\t\tTEXEL0, 0, SHADE, 0, 0, 0, 0, SHADE\n#define\tG_CC_MODULATEIA\t\tTEXEL0, 0, SHADE, 0, TEXEL0, 0, SHADE, 0\n#define\tG_CC_MODULATEIDECALA\tTEXEL0, 0, SHADE, 0, 0, 0, 0, TEXEL0\n#define\tG_CC_MODULATERGB\tG_CC_MODULATEI\n#define\tG_CC_MODULATERGBA\tG_CC_MODULATEIA\n#define\tG_CC_MODULATERGBDECALA\tG_CC_MODULATEIDECALA\n#define\tG_CC_MODULATEI_PRIM\tTEXEL0, 0, PRIMITIVE, 0, 0, 0, 0, PRIMITIVE\n#define\tG_CC_MODULATEIA_PRIM\tTEXEL0, 0, PRIMITIVE, 0, TEXEL0, 0, PRIMITIVE, 0\n#define\tG_CC_MODULATEIDECALA_PRIM\tTEXEL0, 0, PRIMITIVE, 0, 0, 0, 0, TEXEL0\n#define\tG_CC_MODULATERGB_PRIM\tG_CC_MODULATEI_PRIM\n#define\tG_CC_MODULATERGBA_PRIM\tG_CC_MODULATEIA_PRIM\n#define\tG_CC_MODULATERGBDECALA_PRIM\tG_CC_MODULATEIDECALA_PRIM\n#define\tG_CC_DECALRGB\t\t0, 0, 0, TEXEL0, 0, 0, 0, SHADE\n#define\tG_CC_DECALRGBA\t\t0, 0, 0, TEXEL0, 0, 0, 0, TEXEL0\n#define\tG_CC_BLENDI\t\tENVIRONMENT, SHADE, TEXEL0, SHADE, 0, 0, 0, SHADE\n#define\tG_CC_BLENDIA\t\tENVIRONMENT, SHADE, TEXEL0, SHADE, TEXEL0, 0, SHADE, 0\n#define\tG_CC_BLENDIDECALA\tENVIRONMENT, SHADE, TEXEL0, SHADE, 0, 0, 0, TEXEL0\n#define\tG_CC_BLENDRGBA\t\tTEXEL0, SHADE, TEXEL0_ALPHA, SHADE, 0, 0, 0, SHADE\n#define\tG_CC_BLENDRGBDECALA\tTEXEL0, SHADE, TEXEL0_ALPHA, SHADE, 0, 0, 0, TEXEL0\n#define G_CC_ADDRGB\t\t1, 0, TEXEL0, SHADE, 0, 0, 0, SHADE\n#define G_CC_ADDRGBDECALA\t1, 0, TEXEL0, SHADE, 0, 0, 0, TEXEL0\n#define G_CC_REFLECTRGB\t\tENVIRONMENT, 0, TEXEL0, SHADE, 0, 0, 0, SHADE\n#define G_CC_REFLECTRGBDECALA\tENVIRONMENT, 0, TEXEL0, SHADE, 0, 0, 0, TEXEL0\n#define G_CC_HILITERGB\t\tPRIMITIVE, SHADE, TEXEL0, SHADE, 0, 0, 0, SHADE\n#define G_CC_HILITERGBA\t\tPRIMITIVE, SHADE, TEXEL0, SHADE, PRIMITIVE, SHADE, TEXEL0, SHADE\n#define G_CC_HILITERGBDECALA\tPRIMITIVE, SHADE, TEXEL0, SHADE, 0, 0, 0, TEXEL0\n#define G_CC_SHADEDECALA\t0, 0, 0, SHADE, 0, 0, 0, TEXEL0\n#define\tG_CC_BLENDPE\t\tPRIMITIVE, ENVIRONMENT, TEXEL0, ENVIRONMENT, TEXEL0, 0, SHADE, 0\n#define\tG_CC_BLENDPEDECALA\tPRIMITIVE, ENVIRONMENT, TEXEL0, ENVIRONMENT, 0, 0, 0, TEXEL0\n\n/* oddball modes */\n#define\t_G_CC_BLENDPE\t\tENVIRONMENT, PRIMITIVE, TEXEL0, PRIMITIVE, TEXEL0, 0, SHADE, 0\n#define\t_G_CC_BLENDPEDECALA\tENVIRONMENT, PRIMITIVE, TEXEL0, PRIMITIVE, 0, 0, 0, TEXEL0\n#define\t_G_CC_TWOCOLORTEX\tPRIMITIVE, SHADE, TEXEL0, SHADE, 0, 0, 0, SHADE\n/* used for 1-cycle sparse mip-maps, primitive color has color of lowest LOD */\n#define\t_G_CC_SPARSEST\t\tPRIMITIVE, TEXEL0, LOD_FRACTION, TEXEL0, PRIMITIVE, TEXEL0, LOD_FRACTION, TEXEL0\n#define G_CC_TEMPLERP   TEXEL1, TEXEL0, PRIM_LOD_FRAC, TEXEL0, TEXEL1, TEXEL0, PRIM_LOD_FRAC, TEXEL0\n\n/* typical CC cycle 1 modes, usually followed by other cycle 2 modes */\n#define\tG_CC_TRILERP\t\tTEXEL1, TEXEL0, LOD_FRACTION, TEXEL0, TEXEL1, TEXEL0, LOD_FRACTION, TEXEL0\n#define\tG_CC_INTERFERENCE\tTEXEL0, 0, TEXEL1, 0, TEXEL0, 0, TEXEL1, 0\n\n/*\n *  One-cycle color convert operation\n */\n#define\tG_CC_1CYUV2RGB\t\tTEXEL0, K4, K5, TEXEL0, 0, 0, 0, SHADE\n\n/*\n *  NOTE: YUV2RGB expects TF step1 color conversion to occur in 2nd clock.\n * Therefore, CC looks for step1 results in TEXEL1\n */\n#define\tG_CC_YUV2RGB\t\tTEXEL1, K4, K5, TEXEL1, 0, 0, 0, 0\n\n/* typical CC cycle 2 modes */\n#define\tG_CC_PASS2\t\t0, 0, 0, COMBINED, 0, 0, 0, COMBINED\n#define\tG_CC_MODULATEI2\t\tCOMBINED, 0, SHADE, 0, 0, 0, 0, SHADE\n#define\tG_CC_MODULATEIA2\tCOMBINED, 0, SHADE, 0, COMBINED, 0, SHADE, 0\n#define\tG_CC_MODULATERGB2\tG_CC_MODULATEI2\n#define\tG_CC_MODULATERGBA2\tG_CC_MODULATEIA2\n#define\tG_CC_MODULATEI_PRIM2\tCOMBINED, 0, PRIMITIVE, 0, 0, 0, 0, PRIMITIVE\n#define\tG_CC_MODULATEIA_PRIM2\tCOMBINED, 0, PRIMITIVE, 0, COMBINED, 0, PRIMITIVE, 0\n#define\tG_CC_MODULATERGB_PRIM2\tG_CC_MODULATEI_PRIM2\n#define\tG_CC_MODULATERGBA_PRIM2\tG_CC_MODULATEIA_PRIM2\n#define\tG_CC_DECALRGB2\t\t0, 0, 0, COMBINED, 0, 0, 0, SHADE\n/*\n * ?\n#define\tG_CC_DECALRGBA2\t\tCOMBINED, SHADE, COMBINED_ALPHA, SHADE, 0, 0, 0, SHADE\n*/\n#define\tG_CC_BLENDI2\t\tENVIRONMENT, SHADE, COMBINED, SHADE, 0, 0, 0, SHADE\n#define\tG_CC_BLENDIA2\t\tENVIRONMENT, SHADE, COMBINED, SHADE, COMBINED, 0, SHADE, 0\n#define\tG_CC_CHROMA_KEY2\tTEXEL0, CENTER, SCALE, 0, 0, 0, 0, 0\n#define G_CC_HILITERGB2\t\tENVIRONMENT, COMBINED, TEXEL0, COMBINED, 0, 0, 0, SHADE\n#define G_CC_HILITERGBA2\tENVIRONMENT, COMBINED, TEXEL0, COMBINED, ENVIRONMENT, COMBINED, TEXEL0, COMBINED\n#define G_CC_HILITERGBDECALA2\tENVIRONMENT, COMBINED, TEXEL0, COMBINED, 0, 0, 0, TEXEL0\n#define G_CC_HILITERGBPASSA2\tENVIRONMENT, COMBINED, TEXEL0, COMBINED, 0, 0, 0, COMBINED\n\n/*\n * G_SETOTHERMODE_L sft: shift count\n */\n#define\tG_MDSFT_ALPHACOMPARE\t\t0\n#define\tG_MDSFT_ZSRCSEL\t\t\t2\n#define\tG_MDSFT_RENDERMODE\t\t3\n#define\tG_MDSFT_BLENDER\t\t\t16\n\n/*\n * G_SETOTHERMODE_H sft: shift count\n */\n#define\tG_MDSFT_BLENDMASK\t\t0\t/* unsupported */\n#define\tG_MDSFT_ALPHADITHER\t\t4\n#define\tG_MDSFT_RGBDITHER\t\t6\n\n#define\tG_MDSFT_COMBKEY\t\t\t8\n#define\tG_MDSFT_TEXTCONV\t\t9\n#define\tG_MDSFT_TEXTFILT\t\t12\n#define\tG_MDSFT_TEXTLUT\t\t\t14\n#define\tG_MDSFT_TEXTLOD\t\t\t16\n#define\tG_MDSFT_TEXTDETAIL\t\t17\n#define\tG_MDSFT_TEXTPERSP\t\t19\n#define\tG_MDSFT_CYCLETYPE\t\t20\n#define\tG_MDSFT_COLORDITHER\t\t22\t/* unsupported in HW 2.0 */\n#define\tG_MDSFT_PIPELINE\t\t23\n\n/* G_SETOTHERMODE_H gPipelineMode */\n#define\tG_PM_1PRIMITIVE\t\t(1 << G_MDSFT_PIPELINE)\n#define\tG_PM_NPRIMITIVE\t\t(0 << G_MDSFT_PIPELINE)\n\n/* G_SETOTHERMODE_H gSetCycleType */\n#define\tG_CYC_1CYCLE\t\t(0 << G_MDSFT_CYCLETYPE)\n#define\tG_CYC_2CYCLE\t\t(1 << G_MDSFT_CYCLETYPE)\n#define\tG_CYC_COPY\t\t(2 << G_MDSFT_CYCLETYPE)\n#define\tG_CYC_FILL\t\t(3 << G_MDSFT_CYCLETYPE)\n\n/* G_SETOTHERMODE_H gSetTexturePersp */\n#define G_TP_NONE\t(0 << G_MDSFT_TEXTPERSP)\n#define G_TP_PERSP\t(1 << G_MDSFT_TEXTPERSP)\n\n/* G_SETOTHERMODE_H gSetTextureDetail */\n#define G_TD_CLAMP\t(0 << G_MDSFT_TEXTDETAIL)\n#define G_TD_SHARPEN\t(1 << G_MDSFT_TEXTDETAIL)\n#define G_TD_DETAIL\t(2 << G_MDSFT_TEXTDETAIL)\n\n/* G_SETOTHERMODE_H gSetTextureLOD */\n#define G_TL_TILE\t(0 << G_MDSFT_TEXTLOD)\n#define G_TL_LOD\t(1 << G_MDSFT_TEXTLOD)\n\n/* G_SETOTHERMODE_H gSetTextureLUT */\n#define G_TT_NONE\t(0 << G_MDSFT_TEXTLUT)\n#define G_TT_RGBA16\t(2 << G_MDSFT_TEXTLUT)\n#define G_TT_IA16\t(3 << G_MDSFT_TEXTLUT)\n\n/* G_SETOTHERMODE_H gSetTextureFilter */\n#define G_TF_POINT\t(0 << G_MDSFT_TEXTFILT)\n#define G_TF_AVERAGE\t(3 << G_MDSFT_TEXTFILT)\n#define G_TF_BILERP\t(2 << G_MDSFT_TEXTFILT)\n\n/* G_SETOTHERMODE_H gSetTextureConvert */\n#define G_TC_CONV\t(0 << G_MDSFT_TEXTCONV)\n#define G_TC_FILTCONV\t(5 << G_MDSFT_TEXTCONV)\n#define G_TC_FILT\t(6 << G_MDSFT_TEXTCONV)\n\n/* G_SETOTHERMODE_H gSetCombineKey */\n#define G_CK_NONE\t(0 << G_MDSFT_COMBKEY)\n#define G_CK_KEY\t(1 << G_MDSFT_COMBKEY)\n\n/* G_SETOTHERMODE_H gSetColorDither */\n#define\tG_CD_MAGICSQ\t\t(0 << G_MDSFT_RGBDITHER)\n#define\tG_CD_BAYER\t\t(1 << G_MDSFT_RGBDITHER)\n#define\tG_CD_NOISE\t\t(2 << G_MDSFT_RGBDITHER)\n\n#ifndef _HW_VERSION_1\n#define\tG_CD_DISABLE\t\t(3 << G_MDSFT_RGBDITHER)\n#define\tG_CD_ENABLE\t\tG_CD_NOISE\t/* HW 1.0 compatibility mode */\n#else\n#define G_CD_ENABLE\t\t(1 << G_MDSFT_COLORDITHER)\n#define G_CD_DISABLE\t\t(0 << G_MDSFT_COLORDITHER)\n#endif\n\n/* G_SETOTHERMODE_H gSetAlphaDither */\n#define\tG_AD_PATTERN\t\t(0 << G_MDSFT_ALPHADITHER)\n#define\tG_AD_NOTPATTERN\t\t(1 << G_MDSFT_ALPHADITHER)\n#define\tG_AD_NOISE\t\t(2 << G_MDSFT_ALPHADITHER)\n#define\tG_AD_DISABLE\t\t(3 << G_MDSFT_ALPHADITHER)\n\n/* G_SETOTHERMODE_L gSetAlphaCompare */\n#define\tG_AC_NONE\t\t(0 << G_MDSFT_ALPHACOMPARE)\n#define\tG_AC_THRESHOLD\t\t(1 << G_MDSFT_ALPHACOMPARE)\n#define\tG_AC_DITHER\t\t(3 << G_MDSFT_ALPHACOMPARE)\n\n/* G_SETOTHERMODE_L gSetDepthSource */\n#define\tG_ZS_PIXEL\t\t(0 << G_MDSFT_ZSRCSEL)\n#define\tG_ZS_PRIM\t\t(1 << G_MDSFT_ZSRCSEL)\n\n/* G_SETOTHERMODE_L gSetRenderMode */\n#define\tAA_EN\t\t0x8\n#define\tZ_CMP\t\t0x10\n#define\tZ_UPD\t\t0x20\n#define\tIM_RD\t\t0x40\n#define\tCLR_ON_CVG\t0x80\n#define\tCVG_DST_CLAMP\t0\n#define\tCVG_DST_WRAP\t0x100\n#define\tCVG_DST_FULL\t0x200\n#define\tCVG_DST_SAVE\t0x300\n#define\tZMODE_OPA\t0\n#define\tZMODE_INTER\t0x400\n#define\tZMODE_XLU\t0x800\n#define\tZMODE_DEC\t0xc00\n#define\tCVG_X_ALPHA\t0x1000\n#define\tALPHA_CVG_SEL\t0x2000\n#define\tFORCE_BL\t0x4000\n#define\tTEX_EDGE\t0x0000 /* used to be 0x8000 */\n\n#define\tG_BL_CLR_IN\t0\n#define\tG_BL_CLR_MEM\t1\n#define\tG_BL_CLR_BL\t2\n#define\tG_BL_CLR_FOG\t3\n#define\tG_BL_1MA\t0\n#define\tG_BL_A_MEM\t1\n#define\tG_BL_A_IN\t0\n#define\tG_BL_A_FOG\t1\n#define\tG_BL_A_SHADE\t2\n#define\tG_BL_1\t\t2\n#define\tG_BL_0\t\t3\n\n#define\tGBL_c1(m1a, m1b, m2a, m2b)\t\\\n\t(m1a) << 30 | (m1b) << 26 | (m2a) << 22 | (m2b) << 18\n#define\tGBL_c2(m1a, m1b, m2a, m2b)\t\\\n\t(m1a) << 28 | (m1b) << 24 | (m2a) << 20 | (m2b) << 16\n\n#define\tRM_AA_ZB_OPA_SURF(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | Z_UPD | IM_RD | CVG_DST_CLAMP |\t\t\\\n\tZMODE_OPA | ALPHA_CVG_SEL |\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_A_MEM)\n\n#define\tRM_RA_ZB_OPA_SURF(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | Z_UPD | CVG_DST_CLAMP |\t\t\t\\\n\tZMODE_OPA | ALPHA_CVG_SEL |\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_A_MEM)\n\n#define\tRM_AA_ZB_XLU_SURF(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | IM_RD | CVG_DST_WRAP | CLR_ON_CVG |\t\\\n\tFORCE_BL | ZMODE_XLU |\t\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n#define\tRM_AA_ZB_OPA_DECAL(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | IM_RD | CVG_DST_WRAP | ALPHA_CVG_SEL |\t\\\n\tZMODE_DEC |\t\t\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_A_MEM)\n\n#define\tRM_RA_ZB_OPA_DECAL(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | CVG_DST_WRAP | ALPHA_CVG_SEL |\t\t\\\n\tZMODE_DEC |\t\t\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_A_MEM)\n\n#define\tRM_AA_ZB_XLU_DECAL(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | IM_RD | CVG_DST_WRAP | CLR_ON_CVG |\t\\\n\tFORCE_BL | ZMODE_DEC |\t\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n#define\tRM_AA_ZB_OPA_INTER(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | Z_UPD | IM_RD | CVG_DST_CLAMP |\t\t\\\n\tALPHA_CVG_SEL |\tZMODE_INTER |\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_A_MEM)\n\n#define\tRM_RA_ZB_OPA_INTER(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | Z_UPD | CVG_DST_CLAMP |\t\t\t\\\n\tALPHA_CVG_SEL |\tZMODE_INTER |\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_A_MEM)\n\n#define\tRM_AA_ZB_XLU_INTER(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | IM_RD | CVG_DST_WRAP | CLR_ON_CVG |\t\\\n\tFORCE_BL | ZMODE_INTER |\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n#define\tRM_AA_ZB_XLU_LINE(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | IM_RD | CVG_DST_CLAMP | CVG_X_ALPHA |\t\\\n\tALPHA_CVG_SEL | FORCE_BL | ZMODE_XLU |\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n#define\tRM_AA_ZB_DEC_LINE(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | IM_RD | CVG_DST_SAVE | CVG_X_ALPHA |\t\\\n\tALPHA_CVG_SEL | FORCE_BL | ZMODE_DEC |\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n#define\tRM_AA_ZB_TEX_EDGE(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | Z_UPD | IM_RD | CVG_DST_CLAMP |\t\t\\\n\tCVG_X_ALPHA | ALPHA_CVG_SEL | ZMODE_OPA | TEX_EDGE |\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_A_MEM)\n\n#define\tRM_AA_ZB_TEX_INTER(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | Z_UPD | IM_RD | CVG_DST_CLAMP |\t\t\\\n\tCVG_X_ALPHA | ALPHA_CVG_SEL | ZMODE_INTER | TEX_EDGE |\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_A_MEM)\n\n#define\tRM_AA_ZB_SUB_SURF(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | Z_UPD | IM_RD | CVG_DST_FULL |\t\t\\\n\tZMODE_OPA | ALPHA_CVG_SEL |\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_A_MEM)\n\n#define\tRM_AA_ZB_PCL_SURF(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | Z_UPD | IM_RD | CVG_DST_CLAMP |\t\t\\\n\tZMODE_OPA | G_AC_DITHER | \t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n#define\tRM_AA_ZB_OPA_TERR(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | Z_UPD | IM_RD | CVG_DST_CLAMP |\t\t\\\n\tZMODE_OPA | ALPHA_CVG_SEL |\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n#define\tRM_AA_ZB_TEX_TERR(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | Z_UPD | IM_RD | CVG_DST_CLAMP |\t\t\\\n\tCVG_X_ALPHA | ALPHA_CVG_SEL | ZMODE_OPA | TEX_EDGE |\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n#define\tRM_AA_ZB_SUB_TERR(clk)\t\t\t\t\t\\\n\tAA_EN | Z_CMP | Z_UPD | IM_RD | CVG_DST_FULL |\t\t\\\n\tZMODE_OPA | ALPHA_CVG_SEL |\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n\n#define\tRM_AA_OPA_SURF(clk)\t\t\t\t\t\\\n\tAA_EN | IM_RD | CVG_DST_CLAMP |\t\t\t\t\\\n\tZMODE_OPA | ALPHA_CVG_SEL |\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_A_MEM)\n\n#define\tRM_RA_OPA_SURF(clk)\t\t\t\t\t\\\n\tAA_EN | CVG_DST_CLAMP |\t\t\t\t\\\n\tZMODE_OPA | ALPHA_CVG_SEL |\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_A_MEM)\n\n#define\tRM_AA_XLU_SURF(clk)\t\t\t\t\t\\\n\tAA_EN | IM_RD | CVG_DST_WRAP | CLR_ON_CVG | FORCE_BL |\t\\\n\tZMODE_OPA |\t\t\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n#define\tRM_AA_XLU_LINE(clk)\t\t\t\t\t\\\n\tAA_EN | IM_RD | CVG_DST_CLAMP | CVG_X_ALPHA |\t\t\\\n\tALPHA_CVG_SEL | FORCE_BL | ZMODE_OPA |\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n#define\tRM_AA_DEC_LINE(clk)\t\t\t\t\t\\\n\tAA_EN | IM_RD | CVG_DST_FULL | CVG_X_ALPHA |\t\t\\\n\tALPHA_CVG_SEL | FORCE_BL | ZMODE_OPA |\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n#define\tRM_AA_TEX_EDGE(clk)\t\t\t\t\t\\\n\tAA_EN | IM_RD | CVG_DST_CLAMP |\t\t\t\t\\\n\tCVG_X_ALPHA | ALPHA_CVG_SEL | ZMODE_OPA | TEX_EDGE |\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_A_MEM)\n\n#define\tRM_AA_SUB_SURF(clk)\t\t\t\t\t\\\n\tAA_EN | IM_RD | CVG_DST_FULL |\t\t\t\t\\\n\tZMODE_OPA | ALPHA_CVG_SEL |\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_A_MEM)\n\n#define\tRM_AA_PCL_SURF(clk)\t\t\t\t\t\\\n\tAA_EN | IM_RD | CVG_DST_CLAMP |\t\t\t\t\\\n\tZMODE_OPA | G_AC_DITHER | \t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n#define\tRM_AA_OPA_TERR(clk)\t\t\t\t\t\\\n\tAA_EN | IM_RD | CVG_DST_CLAMP |\t\t\t\t\\\n\tZMODE_OPA | ALPHA_CVG_SEL |\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n#define\tRM_AA_TEX_TERR(clk)\t\t\t\t\t\\\n\tAA_EN | IM_RD | CVG_DST_CLAMP |\t\t\t\t\\\n\tCVG_X_ALPHA | ALPHA_CVG_SEL | ZMODE_OPA | TEX_EDGE |\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n#define\tRM_AA_SUB_TERR(clk)\t\t\t\t\t\\\n\tAA_EN | IM_RD | CVG_DST_FULL |\t\t\t\t\\\n\tZMODE_OPA | ALPHA_CVG_SEL |\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n\n#define\tRM_ZB_OPA_SURF(clk)\t\t\t\t\t\\\n\tZ_CMP | Z_UPD | CVG_DST_FULL | ALPHA_CVG_SEL |\t\t\\\n\tZMODE_OPA |\t\t\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_A_MEM)\n\t\n#define\tRM_ZB_XLU_SURF(clk)\t\t\t\t\t\\\n\tZ_CMP | IM_RD | CVG_DST_FULL | FORCE_BL | ZMODE_XLU |\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\t\n#define\tRM_ZB_OPA_DECAL(clk)\t\t\t\t\t\\\n\tZ_CMP | CVG_DST_FULL | ALPHA_CVG_SEL | ZMODE_DEC |\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_A_MEM)\n\t\n#define\tRM_ZB_XLU_DECAL(clk)\t\t\t\t\t\\\n\tZ_CMP | IM_RD | CVG_DST_FULL | FORCE_BL | ZMODE_DEC |\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\t\n#define\tRM_ZB_CLD_SURF(clk)\t\t\t\t\t\\\n\tZ_CMP | IM_RD | CVG_DST_SAVE | FORCE_BL | ZMODE_XLU |\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\t\n#define\tRM_ZB_OVL_SURF(clk)\t\t\t\t\t\\\n\tZ_CMP | IM_RD | CVG_DST_SAVE | FORCE_BL | ZMODE_DEC |\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\t\n#define\tRM_ZB_PCL_SURF(clk)\t\t\t\t\t\\\n\tZ_CMP | Z_UPD | CVG_DST_FULL | ZMODE_OPA |\t\t\\\n\tG_AC_DITHER | \t\t\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_0, G_BL_CLR_IN, G_BL_1)\n\n\n#define\tRM_OPA_SURF(clk)\t\t\t\t\t\\\n\tCVG_DST_CLAMP | FORCE_BL | ZMODE_OPA |\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_0, G_BL_CLR_IN, G_BL_1)\n\n#define\tRM_XLU_SURF(clk)\t\t\t\t\t\\\n\tIM_RD | CVG_DST_FULL | FORCE_BL | ZMODE_OPA |\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n#define\tRM_TEX_EDGE(clk)\t\t\t\t\t\\\n\tCVG_DST_CLAMP | CVG_X_ALPHA | ALPHA_CVG_SEL | FORCE_BL |\\\n\tZMODE_OPA | TEX_EDGE | AA_EN |\t\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_0, G_BL_CLR_IN, G_BL_1)\n\n#define\tRM_CLD_SURF(clk)\t\t\t\t\t\\\n\tIM_RD | CVG_DST_SAVE | FORCE_BL | ZMODE_OPA |\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_IN, G_BL_CLR_MEM, G_BL_1MA)\n\n#define\tRM_PCL_SURF(clk)\t\t\t\t\t\\\n\tCVG_DST_FULL | FORCE_BL | ZMODE_OPA | \t\t\t\\\n\tG_AC_DITHER | \t\t\t\t\t\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_0, G_BL_CLR_IN, G_BL_1)\n\n#define\tRM_ADD(clk)\t\t\t\t\t\\\n\tIM_RD | CVG_DST_SAVE | FORCE_BL | ZMODE_OPA |\t\\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_A_FOG, G_BL_CLR_MEM, G_BL_1)\n\n#define\tRM_NOOP(clk)\t\\\n\tGBL_c##clk(0, 0, 0, 0)\n\n#define RM_VISCVG(clk) \\\n\tIM_RD | FORCE_BL |     \\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_0, G_BL_CLR_BL, G_BL_A_MEM)\n\n/* for rendering to an 8-bit framebuffer */\n#define RM_OPA_CI(clk)                    \\\n\tCVG_DST_CLAMP | ZMODE_OPA |          \\\n\tGBL_c##clk(G_BL_CLR_IN, G_BL_0, G_BL_CLR_IN, G_BL_1)\n\n\n\n#define\tG_RM_AA_ZB_OPA_SURF\tRM_AA_ZB_OPA_SURF(1)\n#define\tG_RM_AA_ZB_OPA_SURF2\tRM_AA_ZB_OPA_SURF(2)\n#define\tG_RM_AA_ZB_XLU_SURF\tRM_AA_ZB_XLU_SURF(1)\n#define\tG_RM_AA_ZB_XLU_SURF2\tRM_AA_ZB_XLU_SURF(2)\n#define\tG_RM_AA_ZB_OPA_DECAL\tRM_AA_ZB_OPA_DECAL(1)\n#define\tG_RM_AA_ZB_OPA_DECAL2\tRM_AA_ZB_OPA_DECAL(2)\n#define\tG_RM_AA_ZB_XLU_DECAL\tRM_AA_ZB_XLU_DECAL(1)\n#define\tG_RM_AA_ZB_XLU_DECAL2\tRM_AA_ZB_XLU_DECAL(2)\n#define\tG_RM_AA_ZB_OPA_INTER\tRM_AA_ZB_OPA_INTER(1)\n#define\tG_RM_AA_ZB_OPA_INTER2\tRM_AA_ZB_OPA_INTER(2)\n#define\tG_RM_AA_ZB_XLU_INTER\tRM_AA_ZB_XLU_INTER(1)\n#define\tG_RM_AA_ZB_XLU_INTER2\tRM_AA_ZB_XLU_INTER(2)\n#define\tG_RM_AA_ZB_XLU_LINE\tRM_AA_ZB_XLU_LINE(1)\n#define\tG_RM_AA_ZB_XLU_LINE2\tRM_AA_ZB_XLU_LINE(2)\n#define\tG_RM_AA_ZB_DEC_LINE\tRM_AA_ZB_DEC_LINE(1)\n#define\tG_RM_AA_ZB_DEC_LINE2\tRM_AA_ZB_DEC_LINE(2)\n#define\tG_RM_AA_ZB_TEX_EDGE\tRM_AA_ZB_TEX_EDGE(1)\n#define\tG_RM_AA_ZB_TEX_EDGE2\tRM_AA_ZB_TEX_EDGE(2)\n#define\tG_RM_AA_ZB_TEX_INTER\tRM_AA_ZB_TEX_INTER(1)\n#define\tG_RM_AA_ZB_TEX_INTER2\tRM_AA_ZB_TEX_INTER(2)\n#define\tG_RM_AA_ZB_SUB_SURF\tRM_AA_ZB_SUB_SURF(1)\n#define\tG_RM_AA_ZB_SUB_SURF2\tRM_AA_ZB_SUB_SURF(2)\n#define\tG_RM_AA_ZB_PCL_SURF\tRM_AA_ZB_PCL_SURF(1)\n#define\tG_RM_AA_ZB_PCL_SURF2\tRM_AA_ZB_PCL_SURF(2)\n#define\tG_RM_AA_ZB_OPA_TERR\tRM_AA_ZB_OPA_TERR(1)\n#define\tG_RM_AA_ZB_OPA_TERR2\tRM_AA_ZB_OPA_TERR(2)\n#define\tG_RM_AA_ZB_TEX_TERR\tRM_AA_ZB_TEX_TERR(1)\n#define\tG_RM_AA_ZB_TEX_TERR2\tRM_AA_ZB_TEX_TERR(2)\n#define\tG_RM_AA_ZB_SUB_TERR\tRM_AA_ZB_SUB_TERR(1)\n#define\tG_RM_AA_ZB_SUB_TERR2\tRM_AA_ZB_SUB_TERR(2)\n\n#define\tG_RM_RA_ZB_OPA_SURF\tRM_RA_ZB_OPA_SURF(1)\n#define\tG_RM_RA_ZB_OPA_SURF2\tRM_RA_ZB_OPA_SURF(2)\n#define\tG_RM_RA_ZB_OPA_DECAL\tRM_RA_ZB_OPA_DECAL(1)\n#define\tG_RM_RA_ZB_OPA_DECAL2\tRM_RA_ZB_OPA_DECAL(2)\n#define\tG_RM_RA_ZB_OPA_INTER\tRM_RA_ZB_OPA_INTER(1)\n#define\tG_RM_RA_ZB_OPA_INTER2\tRM_RA_ZB_OPA_INTER(2)\n\n#define\tG_RM_AA_OPA_SURF\tRM_AA_OPA_SURF(1)\n#define\tG_RM_AA_OPA_SURF2\tRM_AA_OPA_SURF(2)\n#define\tG_RM_AA_XLU_SURF\tRM_AA_XLU_SURF(1)\n#define\tG_RM_AA_XLU_SURF2\tRM_AA_XLU_SURF(2)\n#define\tG_RM_AA_XLU_LINE\tRM_AA_XLU_LINE(1)\n#define\tG_RM_AA_XLU_LINE2\tRM_AA_XLU_LINE(2)\n#define\tG_RM_AA_DEC_LINE\tRM_AA_DEC_LINE(1)\n#define\tG_RM_AA_DEC_LINE2\tRM_AA_DEC_LINE(2)\n#define\tG_RM_AA_TEX_EDGE\tRM_AA_TEX_EDGE(1)\n#define\tG_RM_AA_TEX_EDGE2\tRM_AA_TEX_EDGE(2)\n#define\tG_RM_AA_SUB_SURF\tRM_AA_SUB_SURF(1)\n#define\tG_RM_AA_SUB_SURF2\tRM_AA_SUB_SURF(2)\n#define\tG_RM_AA_PCL_SURF\tRM_AA_PCL_SURF(1)\n#define\tG_RM_AA_PCL_SURF2\tRM_AA_PCL_SURF(2)\n#define\tG_RM_AA_OPA_TERR\tRM_AA_OPA_TERR(1)\n#define\tG_RM_AA_OPA_TERR2\tRM_AA_OPA_TERR(2)\n#define\tG_RM_AA_TEX_TERR\tRM_AA_TEX_TERR(1)\n#define\tG_RM_AA_TEX_TERR2\tRM_AA_TEX_TERR(2)\n#define\tG_RM_AA_SUB_TERR\tRM_AA_SUB_TERR(1)\n#define\tG_RM_AA_SUB_TERR2\tRM_AA_SUB_TERR(2)\n\n#define\tG_RM_RA_OPA_SURF\tRM_RA_OPA_SURF(1)\n#define\tG_RM_RA_OPA_SURF2\tRM_RA_OPA_SURF(2)\n\n#define\tG_RM_ZB_OPA_SURF\tRM_ZB_OPA_SURF(1)\n#define\tG_RM_ZB_OPA_SURF2\tRM_ZB_OPA_SURF(2)\n#define\tG_RM_ZB_XLU_SURF\tRM_ZB_XLU_SURF(1)\n#define\tG_RM_ZB_XLU_SURF2\tRM_ZB_XLU_SURF(2)\n#define\tG_RM_ZB_OPA_DECAL\tRM_ZB_OPA_DECAL(1)\n#define\tG_RM_ZB_OPA_DECAL2\tRM_ZB_OPA_DECAL(2)\n#define\tG_RM_ZB_XLU_DECAL\tRM_ZB_XLU_DECAL(1)\n#define\tG_RM_ZB_XLU_DECAL2\tRM_ZB_XLU_DECAL(2)\n#define\tG_RM_ZB_CLD_SURF\tRM_ZB_CLD_SURF(1)\n#define\tG_RM_ZB_CLD_SURF2\tRM_ZB_CLD_SURF(2)\n#define\tG_RM_ZB_OVL_SURF\tRM_ZB_OVL_SURF(1)\n#define\tG_RM_ZB_OVL_SURF2\tRM_ZB_OVL_SURF(2)\n#define\tG_RM_ZB_PCL_SURF\tRM_ZB_PCL_SURF(1)\n#define\tG_RM_ZB_PCL_SURF2\tRM_ZB_PCL_SURF(2)\n\n#define\tG_RM_OPA_SURF\t\tRM_OPA_SURF(1)\n#define\tG_RM_OPA_SURF2\t\tRM_OPA_SURF(2)\n#define\tG_RM_XLU_SURF\t\tRM_XLU_SURF(1)\n#define\tG_RM_XLU_SURF2\t\tRM_XLU_SURF(2)\n#define\tG_RM_CLD_SURF\t\tRM_CLD_SURF(1)\n#define\tG_RM_CLD_SURF2\t\tRM_CLD_SURF(2)\n#define\tG_RM_TEX_EDGE\t\tRM_TEX_EDGE(1)\n#define\tG_RM_TEX_EDGE2\t\tRM_TEX_EDGE(2)\n#define\tG_RM_PCL_SURF\t\tRM_PCL_SURF(1)\n#define\tG_RM_PCL_SURF2\t\tRM_PCL_SURF(2)\n#define G_RM_ADD       \t\tRM_ADD(1)\n#define G_RM_ADD2      \t\tRM_ADD(2)\n#define G_RM_NOOP       \tRM_NOOP(1)\n#define G_RM_NOOP2      \tRM_NOOP(2)\n#define G_RM_VISCVG    \t\tRM_VISCVG(1)\n#define G_RM_VISCVG2    \tRM_VISCVG(2)\n#define G_RM_OPA_CI         RM_OPA_CI(1)\n#define G_RM_OPA_CI2        RM_OPA_CI(2)\n\n\n#define\tG_RM_FOG_SHADE_A\tGBL_c1(G_BL_CLR_FOG, G_BL_A_SHADE, G_BL_CLR_IN, G_BL_1MA)\n#define\tG_RM_FOG_PRIM_A\t\tGBL_c1(G_BL_CLR_FOG, G_BL_A_FOG, G_BL_CLR_IN, G_BL_1MA)\n#define\tG_RM_PASS\t\tGBL_c1(G_BL_CLR_IN, G_BL_0, G_BL_CLR_IN, G_BL_1)\n\n/*\n * G_SETCONVERT: K0-5\n */\n#define\tG_CV_K0\t\t175\n#define\tG_CV_K1\t\t-43\n#define\tG_CV_K2\t\t-89\n#define\tG_CV_K3\t\t222\n#define\tG_CV_K4\t\t114\n#define\tG_CV_K5\t\t42\n\n/*\n * G_SETSCISSOR: interlace mode\n */\n#define\tG_SC_NON_INTERLACE\t0\n#define\tG_SC_ODD_INTERLACE\t3\n#define\tG_SC_EVEN_INTERLACE\t2\n\n/* flags to inhibit pushing of the display list (on branch) */\n#define G_DL_PUSH\t\t0x00\n#define G_DL_NOPUSH\t\t0x01\n\n/*\n * BEGIN C-specific section: (typedef's)\n */\n#if defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS)\n\n/*\n * Data Structures\n *\n * NOTE:\n * The DMA transfer hardware requires 64-bit aligned, 64-bit multiple-\n * sized transfers. This important hardware optimization is unfortunately\n * reflected in the programming interface, with some structures\n * padded and alignment enforced.\n *\n * Since structures are aligned to the boundary of the \"worst-case\"\n * element, we can't depend on the C compiler to align things\n * properly.\n *\n * 64-bit structure alignment is enforced by wrapping structures with \n * unions that contain a dummy \"long long int\".  Why this works is\n * explained in the ANSI C Spec, or on page 186 of the second edition\n * of K&R, \"The C Programming Language\".\n *\n * The price we pay for this is a little awkwardness referencing the\n * structures through the union. There is no memory penalty, since\n * all the structures are at least 64-bits the dummy alignment field\n * does not increase the size of the union.\n *\n * Static initialization of these union structures works because\n * the ANSI C spec states that static initialization for unions\n * works by using the first union element. We put the dummy alignment\n * field last for this reason.\n *\n * (it's possible a newer 64-bit compiler from MIPS might make this\n * easier with a flag, but we can't wait for it...)\n *\n */\n\n/*\n * Vertex (set up for use with colors)\n */\ntypedef struct {\n\tshort\t\tob[3];\t/* x, y, z */\n\tunsigned short\tflag;\n\tshort\t\ttc[2];\t/* texture coord */\n\tunsigned char\tcn[4];\t/* color & alpha */\n} Vtx_t;\n\n/*\n * Vertex (set up for use with normals)\n */\ntypedef struct {\n\tshort\t\tob[3];\t/* x, y, z */\n\tunsigned short\tflag;\n\tshort\t\ttc[2];\t/* texture coord */\n\tsigned char\tn[3];\t/* normal */\n\tunsigned char   a;      /* alpha  */\n} Vtx_tn;\n\ntypedef union {\n    Vtx_t\t\tv;  /* Use this one for colors  */\n    Vtx_tn              n;  /* Use this one for normals */\n    long long int\tforce_structure_alignment;\n} Vtx;\n\n/*\n * Sprite structure\n */\n\ntypedef struct {\n  void *SourceImagePointer;\n  void *TlutPointer;\n  short Stride;\n  short SubImageWidth;\n  short SubImageHeight;\n  char  SourceImageType;\n  char  SourceImageBitSize;\n  short SourceImageOffsetS;\n  short SourceImageOffsetT;\n  /* 20 bytes for above */\n\n  /* padding to bring structure size to 64 bit allignment */\n  char dummy[4]; \n\n} uSprite_t;\n\ntypedef union {\t\n  uSprite_t  s;\n\n  /* Need to make sure this is 64 bit aligned */   \n  long long int         force_structure_allignment[3];\n} uSprite;\n\n/*\n * Triangle face\n */\ntypedef struct {\n\tunsigned char\tflag;\n\tunsigned char\tv[3];\n} Tri;\n\n/*\n * 4x4 matrix, fixed point s15.16 format.\n * First 8 words are integer portion of the 4x4 matrix\n * Last 8 words are the fraction portion of the 4x4 matrix\n */\ntypedef long\tMtx_t[4][4];\n\ntypedef union {\n    Mtx_t\t\tm;\n    long long int\tforce_structure_alignment;\n} Mtx;\n\n/*\n * Viewport\n */\n\n/*\n *\n * This magic value is the maximum INTEGER z-range of the hardware\n * (there are also 16-bits of fraction, which are introduced during\n * any transformations). This is not just a good idea, it's the law.\n * Feeding the hardware eventual z-coordinates (after any transforms\n * or scaling) bigger than this, will not work.\n *\n * This number is DIFFERENT than G_MAXFBZ, which is the maximum value\n * you want to use to initialize the z-buffer.\n *\n * The reason these are different is mildly interesting, but too long\n * to explain here. It is basically the result of optimizations in the\n * hardware. A more generic API might hide this detail from the users,\n * but we don't have the ucode to do that...\n *\n */\n#define G_MAXZ\t\t0x03ff\t/* 10 bits of integer screen-Z precision */\n\n/*\n * The viewport structure elements have 2 bits of fraction, necessary\n * to accomodate the sub-pixel positioning scaling for the hardware.\n * This can also be exploited to handle odd-sized viewports.\n *\n * Accounting for these fractional bits, using the default projection\n * and viewing matrices, the viewport structure is initialized thusly:\n *\n *\t\t(SCREEN_WD/2)*4, (SCREEN_HT/2)*4, G_MAXZ, 0,\n *\t\t(SCREEN_WD/2)*4, (SCREEN_HT/2)*4, 0, 0,\n */\ntypedef struct {\n\tshort\tvscale[4];  /* scale, 2 bits fraction */\n\tshort\tvtrans[4];  /* translate, 2 bits fraction */\n\t/* both the above arrays are padded to 64-bit boundary */\n} Vp_t;\n\ntypedef union {\n    Vp_t\t\tvp;\n    long long int\tforce_structure_alignment;\n} Vp;\n\n/*\n * MOVEMEM indices\n *\n * Each of these indexes an entry in a dmem table\n * which points to a 1-4 word block of dmem in\n * which to store a 1-4 word DMA.\n *\n */\n#ifdef\tF3DEX_GBI_2\n/* 0,4 are reserved by G_MTX */\n# define G_MV_MMTX\t2\t\n# define G_MV_PMTX\t6\n# define G_MV_VIEWPORT\t8\n# define G_MV_LIGHT\t10\n# define G_MV_POINT\t12\n# define G_MV_MATRIX\t14\t\t/* NOTE: this is in moveword table */\n# define G_MVO_LOOKATX\t(0*24)\n# define G_MVO_LOOKATY\t(1*24)\n# define G_MVO_L0\t(2*24)\n# define G_MVO_L1\t(3*24)\n# define G_MVO_L2\t(4*24)\n# define G_MVO_L3\t(5*24)\n# define G_MVO_L4\t(6*24)\n# define G_MVO_L5\t(7*24)\n# define G_MVO_L6\t(8*24)\n# define G_MVO_L7\t(9*24)\n#else\t/* F3DEX_GBI_2 */\n# define G_MV_VIEWPORT\t0x80\n# define G_MV_LOOKATY\t0x82\n# define G_MV_LOOKATX\t0x84\n# define G_MV_L0\t0x86\n# define G_MV_L1\t0x88\n# define G_MV_L2\t0x8a\n# define G_MV_L3\t0x8c\n# define G_MV_L4\t0x8e\n# define G_MV_L5\t0x90\n# define G_MV_L6\t0x92\n# define G_MV_L7\t0x94\n# define G_MV_TXTATT\t0x96\n# define G_MV_MATRIX_1\t0x9e\t/* NOTE: this is in moveword table */\n# define G_MV_MATRIX_2\t0x98\n# define G_MV_MATRIX_3\t0x9a\n# define G_MV_MATRIX_4\t0x9c\n#endif\t/* F3DEX_GBI_2 */\n\n/*\n * MOVEWORD indices\n *\n * Each of these indexes an entry in a dmem table\n * which points to a word in dmem in dmem where\n * an immediate word will be stored.\n *\n */\n#define G_MW_MATRIX\t\t0x00\t/* NOTE: also used by movemem */\n#define G_MW_NUMLIGHT\t\t0x02\n#define G_MW_CLIP\t\t0x04\n#define G_MW_SEGMENT\t\t0x06\n#define G_MW_FOG\t\t0x08\n#define G_MW_LIGHTCOL\t\t0x0a\n#ifdef\tF3DEX_GBI_2\n# define G_MW_FORCEMTX\t\t0x0c\n#else\t/* F3DEX_GBI_2 */\n# define G_MW_POINTS\t\t0x0c\n#endif\t/* F3DEX_GBI_2 */\n#define\tG_MW_PERSPNORM\t\t0x0e\n\n/*\n * These are offsets from the address in the dmem table\n */ \n#define G_MWO_NUMLIGHT\t\t0x00\n#define G_MWO_CLIP_RNX\t\t0x04\n#define G_MWO_CLIP_RNY\t\t0x0c\n#define G_MWO_CLIP_RPX\t\t0x14\n#define G_MWO_CLIP_RPY\t\t0x1c\n#define G_MWO_SEGMENT_0\t\t0x00\n#define G_MWO_SEGMENT_1\t\t0x01\n#define G_MWO_SEGMENT_2\t\t0x02\n#define G_MWO_SEGMENT_3\t\t0x03\n#define G_MWO_SEGMENT_4\t\t0x04\n#define G_MWO_SEGMENT_5\t\t0x05\n#define G_MWO_SEGMENT_6\t\t0x06\n#define G_MWO_SEGMENT_7\t\t0x07\n#define G_MWO_SEGMENT_8\t\t0x08\n#define G_MWO_SEGMENT_9\t\t0x09\n#define G_MWO_SEGMENT_A\t\t0x0a\n#define G_MWO_SEGMENT_B\t\t0x0b\n#define G_MWO_SEGMENT_C\t\t0x0c\n#define G_MWO_SEGMENT_D\t\t0x0d\n#define G_MWO_SEGMENT_E\t\t0x0e\n#define G_MWO_SEGMENT_F\t\t0x0f\n#define G_MWO_FOG\t\t0x00\n#define G_MWO_aLIGHT_1\t\t0x00\n#define G_MWO_bLIGHT_1\t\t0x04\n#ifdef\tF3DEX_GBI_2\n#define G_MWO_aLIGHT_2\t\t0x18\n#define G_MWO_bLIGHT_2\t\t0x1c\n#define G_MWO_aLIGHT_3\t\t0x30\n#define G_MWO_bLIGHT_3\t\t0x34\n#define G_MWO_aLIGHT_4\t\t0x48\n#define G_MWO_bLIGHT_4\t\t0x4c\n#define G_MWO_aLIGHT_5\t\t0x60\n#define G_MWO_bLIGHT_5\t\t0x64\n#define G_MWO_aLIGHT_6\t\t0x78\n#define G_MWO_bLIGHT_6\t\t0x7c\n#define G_MWO_aLIGHT_7\t\t0x90\n#define G_MWO_bLIGHT_7\t\t0x94\n#define G_MWO_aLIGHT_8\t\t0xa8\n#define G_MWO_bLIGHT_8\t\t0xac\n#else\n#define G_MWO_aLIGHT_2\t\t0x20\n#define G_MWO_bLIGHT_2\t\t0x24\n#define G_MWO_aLIGHT_3\t\t0x40\n#define G_MWO_bLIGHT_3\t\t0x44\n#define G_MWO_aLIGHT_4\t\t0x60\n#define G_MWO_bLIGHT_4\t\t0x64\n#define G_MWO_aLIGHT_5\t\t0x80\n#define G_MWO_bLIGHT_5\t\t0x84\n#define G_MWO_aLIGHT_6\t\t0xa0\n#define G_MWO_bLIGHT_6\t\t0xa4\n#define G_MWO_aLIGHT_7\t\t0xc0\n#define G_MWO_bLIGHT_7\t\t0xc4\n#define G_MWO_aLIGHT_8\t\t0xe0\n#define G_MWO_bLIGHT_8\t\t0xe4\n#endif\n#define G_MWO_MATRIX_XX_XY_I\t0x00\n#define G_MWO_MATRIX_XZ_XW_I\t0x04\n#define G_MWO_MATRIX_YX_YY_I\t0x08\n#define G_MWO_MATRIX_YZ_YW_I\t0x0c\n#define G_MWO_MATRIX_ZX_ZY_I\t0x10\n#define G_MWO_MATRIX_ZZ_ZW_I\t0x14\n#define G_MWO_MATRIX_WX_WY_I\t0x18\n#define G_MWO_MATRIX_WZ_WW_I\t0x1c\n#define G_MWO_MATRIX_XX_XY_F\t0x20\n#define G_MWO_MATRIX_XZ_XW_F\t0x24\n#define G_MWO_MATRIX_YX_YY_F\t0x28\n#define G_MWO_MATRIX_YZ_YW_F\t0x2c\n#define G_MWO_MATRIX_ZX_ZY_F\t0x30\n#define G_MWO_MATRIX_ZZ_ZW_F\t0x34\n#define G_MWO_MATRIX_WX_WY_F\t0x38\n#define G_MWO_MATRIX_WZ_WW_F\t0x3c\n#define G_MWO_POINT_RGBA\t0x10\n#define G_MWO_POINT_ST\t\t0x14\n#define G_MWO_POINT_XYSCREEN\t0x18\n#define G_MWO_POINT_ZSCREEN\t0x1c\n\n/*\n * Light structure.\n *\n * Note: only directional (infinite) lights are currently supported.\n *\n * Note: the weird order is for the DMEM alignment benefit of \n * the microcode.\n *\n */\n\ntypedef struct {\n  unsigned char\tcol[3];\t\t/* diffuse light value (rgba) */\n  char \t\tpad1;\n  unsigned char\tcolc[3];\t/* copy of diffuse light value (rgba) */\n  char \t\tpad2;\n  signed char\tdir[3];\t\t/* direction of light (normalized) */\n  char \t\tpad3;\n} Light_t;\n\ntypedef struct {\n  unsigned char\tcol[3];\t\t/* ambient light value (rgba) */\n  char \t\tpad1;\n  unsigned char\tcolc[3];\t/* copy of ambient light value (rgba) */\n  char \t\tpad2;\n} Ambient_t;\n\ntypedef struct {\n  int\t\tx1,y1,x2,y2;\t/* texture offsets for highlight 1/2 */\n} Hilite_t;\n\ntypedef union {\n    Light_t\tl;\n    long long int\tforce_structure_alignment[2];\n} Light;\n\ntypedef union {\n    Ambient_t\tl;\n    long long int\tforce_structure_alignment[1];\n} Ambient;\n\ntypedef struct {\n    Ambient\ta;\n    Light\tl[7];\n} Lightsn;\n\ntypedef struct {\n    Ambient\ta;\n    Light\tl[1];\n} Lights0;\n\ntypedef struct {\n    Ambient\ta;\n    Light\tl[1];\n} Lights1;\n\ntypedef struct {\n    Ambient\ta;\n    Light\tl[2];\n} Lights2;\n\ntypedef struct {\n    Ambient\ta;\n    Light\tl[3];\n} Lights3;\n\ntypedef struct {\n    Ambient\ta;\n    Light\tl[4];\n} Lights4;\n\ntypedef struct {\n    Ambient\ta;\n    Light\tl[5];\n} Lights5;\n\ntypedef struct {\n    Ambient\ta;\n    Light\tl[6];\n} Lights6;\n\ntypedef struct {\n    Ambient\ta;\n    Light\tl[7];\n} Lights7;\n\ntypedef struct {\n    Light\tl[2];\n} LookAt;\n\ntypedef union {\n    Hilite_t\th;\n    long int\tforce_structure_alignment[4];\n} Hilite;\n\n#define gdSPDefLights0(ar,ag,ab)\t\t\t\t\t\\\n\t\t{ \t{{ {ar,ag,ab},0,{ar,ag,ab},0}},\t\t\t\\\n\t\t       {{{ { 0, 0, 0},0,{ 0, 0, 0},0,{ 0, 0, 0},0}}} }\n#define gdSPDefLights1(ar,ag,ab,r1,g1,b1,x1,y1,z1)\t\t\t\\\n\t\t{ \t{{ {ar,ag,ab},0,{ar,ag,ab},0}},\t\t\t\\\n\t\t       {{{ {r1,g1,b1},0,{r1,g1,b1},0,{x1,y1,z1},0}}} }\n#define gdSPDefLights2(ar,ag,ab,r1,g1,b1,x1,y1,z1,r2,g2,b2,x2,y2,z2)\t\\\n\t\t{ \t{{ {ar,ag,ab},0,{ar,ag,ab},0}},\t\t\t\\\n\t\t       {{{ {r1,g1,b1},0,{r1,g1,b1},0,{x1,y1,z1},0}},\t\\\n\t\t\t{{ {r2,g2,b2},0,{r2,g2,b2},0,{x2,y2,z2},0}}} }\n#define gdSPDefLights3(ar,ag,ab,r1,g1,b1,x1,y1,z1,r2,g2,b2,x2,y2,z2,r3,g3,b3,x3,y3,z3)\t\t\t\t\t\t\t\t\t\\\n\t\t{ \t{{ {ar,ag,ab},0,{ar,ag,ab},0}},\t\t\t\\\n\t\t       {{{ {r1,g1,b1},0,{r1,g1,b1},0,{x1,y1,z1},0}},\t\\\n\t\t\t{{ {r2,g2,b2},0,{r2,g2,b2},0,{x2,y2,z2},0}},\t\\\n\t\t\t{{ {r3,g3,b3},0,{r3,g3,b3},0,{x3,y3,z3},0}}} }\n#define gdSPDefLights4(ar,ag,ab,r1,g1,b1,x1,y1,z1,r2,g2,b2,x2,y2,z2,r3,g3,b3,x3,y3,z3,r4,g4,b4,x4,y4,z4)\t\t\t\t\t\t\\\n\t\t{ \t{{ {ar,ag,ab},0,{ar,ag,ab},0}},\t\t\t\\\n\t\t       {{{ {r1,g1,b1},0,{r1,g1,b1},0,{x1,y1,z1},0}},\t\\\n\t\t\t{{ {r2,g2,b2},0,{r2,g2,b2},0,{x2,y2,z2},0}},\t\\\n\t\t\t{{ {r3,g3,b3},0,{r3,g3,b3},0,{x3,y3,z3},0}},\t\\\n\t\t\t{{ {r4,g4,b4},0,{r4,g4,b4},0,{x4,y4,z4},0}}} }\n#define gdSPDefLights5(ar,ag,ab,r1,g1,b1,x1,y1,z1,r2,g2,b2,x2,y2,z2,r3,g3,b3,x3,y3,z3,r4,g4,b4,x4,y4,z4,r5,g5,b5,x5,y5,z5)\t\t\t\t\\\n\t\t{ \t{{ {ar,ag,ab},0,{ar,ag,ab},0}},\t\t\t\\\n\t\t       {{{ {r1,g1,b1},0,{r1,g1,b1},0,{x1,y1,z1},0}},\t\\\n\t\t\t{{ {r2,g2,b2},0,{r2,g2,b2},0,{x2,y2,z2},0}},\t\\\n\t\t\t{{ {r3,g3,b3},0,{r3,g3,b3},0,{x3,y3,z3},0}},\t\\\n\t\t\t{{ {r4,g4,b4},0,{r4,g4,b4},0,{x4,y4,z4},0}},\t\\\n\t\t\t{{ {r5,g5,b5},0,{r5,g5,b5},0,{x5,y5,z5},0}}} }\n\n\n#define gdSPDefLights6(ar,ag,ab,r1,g1,b1,x1,y1,z1,r2,g2,b2,x2,y2,z2,r3,g3,b3,x3,y3,z3,r4,g4,b4,x4,y4,z4,r5,g5,b5,x5,y5,z5,r6,g6,b6,x6,y6,z6)\t\t\\\n\t\t{ \t{{ {ar,ag,ab},0,{ar,ag,ab},0}},\t\t\t\\\n\t\t       {{{ {r1,g1,b1},0,{r1,g1,b1},0,{x1,y1,z1},0}},\t\\\n\t\t\t{{ {r2,g2,b2},0,{r2,g2,b2},0,{x2,y2,z2},0}},\t\\\n\t\t\t{{ {r3,g3,b3},0,{r3,g3,b3},0,{x3,y3,z3},0}},\t\\\n\t\t\t{{ {r4,g4,b4},0,{r4,g4,b4},0,{x4,y4,z4},0}},\t\\\n\t\t\t{{ {r5,g5,b5},0,{r5,g5,b5},0,{x5,y5,z5},0}},\t\\\n\t\t\t{{ {r6,g6,b6},0,{r6,g6,b6},0,{x6,y6,z6},0}}} }\n\n\n#define gdSPDefLights7(ar,ag,ab,r1,g1,b1,x1,y1,z1,r2,g2,b2,x2,y2,z2,r3,g3,b3,x3,y3,z3,r4,g4,b4,x4,y4,z4,r5,g5,b5,x5,y5,z5,r6,g6,b6,x6,y6,z6,r7,g7,b7,x7,y7,z7)\t\\\n\t\t{ \t{{ {ar,ag,ab},0,{ar,ag,ab},0}},\t\t\t\\\n\t\t       {{{ {r1,g1,b1},0,{r1,g1,b1},0,{x1,y1,z1},0}},\t\\\n\t\t\t{{ {r2,g2,b2},0,{r2,g2,b2},0,{x2,y2,z2},0}},\t\\\n\t\t\t{{ {r3,g3,b3},0,{r3,g3,b3},0,{x3,y3,z3},0}},\t\\\n\t\t\t{{ {r4,g4,b4},0,{r4,g4,b4},0,{x4,y4,z4},0}},\t\\\n\t\t\t{{ {r5,g5,b5},0,{r5,g5,b5},0,{x5,y5,z5},0}},\t\\\n\t\t\t{{ {r6,g6,b6},0,{r6,g6,b6},0,{x6,y6,z6},0}},\t\\\n\t\t\t{{ {r7,g7,b7},0,{r7,g7,b7},0,{x7,y7,z7},0}}} }\n\n\n#define gdSPDefLookAt(rightx,righty,rightz,upx,upy,upz)\t\t\t    \\\n\t\t{\t{{ {{0,0,0},0,{0,0,0},0,{rightx,righty,rightz},0}}, \\\n\t\t\t{ {{0,0x80,0},0,{0,0x80,0},0,{upx,upy,upz},0}}}   }\n\n/*\n *  Graphics DMA Packet\n */\ntypedef struct {\n\tint\t\tcmd:8;\n\tunsigned int\tpar:8;\n\tunsigned int\tlen:16;\n\tunsigned int\taddr;\n} Gdma;\n\n/*\n * Graphics Immediate Mode Packet types\n */\ntypedef struct {\n\t\tint\t\tcmd:8;\n\t\tint\t\tpad:24;\n\t\tTri\t\ttri;\n} Gtri;\n\ntypedef struct {\n\t\tint\t\tcmd:8;\n\t\tint\t\tpad1:24;\n\t\tint             pad2:24;\n\t\tunsigned int\tparam:8;\n} Gpopmtx;\n\n/*\n * typedef struct {\n * \t\tint\t\tcmd:8;\n * \t\tint\t\tpad0:24;\n * \t\tint\t\tpad1:4;\n * \t\tint\t\tnumber:4;\n * \t\tint\t\tbase:24;\n * } Gsegment;\n */\ntypedef struct {\n\t\tint\t\tcmd:8;\n\t\tint\t\tpad0:8;\n\t\tint\t\tmw_index:8;\n\t\tint\t\tnumber:8;\n\t\tint\t\tpad1:8;\n\t\tint\t\tbase:24;\n} Gsegment;\n\ntypedef struct {\n\t\tint\t\tcmd:8;\n\t\tint\t\tpad0:8;\n\t\tint\t\tsft:8;\n\t\tint\t\tlen:8;\n\t\tunsigned int\tdata:32;\n} GsetothermodeL;\n\ntypedef struct {\n\t\tint\t\tcmd:8;\n\t\tint\t\tpad0:8;\n\t\tint\t\tsft:8;\n\t\tint\t\tlen:8;\n\t\tunsigned int\tdata:32;\n} GsetothermodeH;\n\ntypedef struct {\n\t\tunsigned char\tcmd;\n\t\tunsigned char\tlodscale;\n\t\tunsigned char\ttile;\n\t\tunsigned char\ton;\n\t\tunsigned short\ts;\n\t\tunsigned short\tt;\n} Gtexture;\n\ntypedef struct {\n\t\tint\t\tcmd:8;\n\t\tint\t\tpad:24;\n\t\tTri\t\tline;\n} Gline3D;\n\ntypedef struct {\n\t\tint\t\tcmd:8;\n\t\tint\t\tpad1:24;\n\t\tshort int\tpad2;\n\t\tshort int       scale;\n} Gperspnorm;\n\n\n/*\n * RDP Packet types\n */\ntypedef struct {\n                int             cmd:8;\n                unsigned int    fmt:3;\n                unsigned int    siz:2;\n                unsigned int    pad:7;\n                unsigned int    wd:12;\t/* really only 10 bits, extra\t*/\n                unsigned int    dram;\t/* to account for 1024\t\t*/\n} Gsetimg;\n\ntypedef struct {\n\t\tint\t\tcmd:8;\n\t\tunsigned int\tmuxs0:24;\n\t\tunsigned int\tmuxs1:32;\n} Gsetcombine;\n\ntypedef struct {\n\t\tint\t\tcmd:8;\n\t\tunsigned char\tpad;\n\t\tunsigned char\tprim_min_level;\n\t\tunsigned char\tprim_level;\n\t\tunsigned long\tcolor;\n} Gsetcolor;\n\ntypedef struct {\n\t\tint\t\tcmd:8;\n\t\tint\t\tx0:10;\n\t\tint\t\tx0frac:2;\n\t\tint\t\ty0:10;\n\t\tint\t\ty0frac:2;\n\t\tunsigned int\tpad:8;\n\t\tint\t\tx1:10;\n\t\tint\t\tx1frac:2;\n\t\tint\t\ty1:10;\n\t\tint\t\ty1frac:2;\n} Gfillrect;\n\ntypedef struct {\n\t\tint\t\tcmd:8;\n\t\tunsigned int\tfmt:3;\n\t\tunsigned int\tsiz:2;\n\t\tunsigned int\tpad0:1;\n\t\tunsigned int\tline:9;\n\t\tunsigned int\ttmem:9;\n\t\tunsigned int\tpad1:5;\n\t\tunsigned int\ttile:3;\n\t\tunsigned int\tpalette:4;\n\t\tunsigned int\tct:1;\n\t\tunsigned int\tmt:1;\n\t\tunsigned int\tmaskt:4;\n\t\tunsigned int\tshiftt:4;\n\t\tunsigned int\tcs:1;\n\t\tunsigned int\tms:1;\n\t\tunsigned int\tmasks:4;\n\t\tunsigned int\tshifts:4;\n} Gsettile;\n\ntypedef struct {\n\t\tint\t\tcmd:8;\n\t\tunsigned int\tsl:12;\n\t\tunsigned int\ttl:12;\n\t\tint\t\tpad:5;\n\t\tunsigned int\ttile:3;\n\t\tunsigned int\tsh:12;\n\t\tunsigned int\tth:12;\n} Gloadtile;\n\ntypedef Gloadtile Gloadblock;\n\ntypedef Gloadtile Gsettilesize;\n\ntypedef Gloadtile Gloadtlut;\n\ntypedef struct {\n\t\tunsigned int\tcmd:8;\t/* command\t\t\t*/\n\t\tunsigned int\txl:12;\t/* X coordinate of upper left\t*/\n\t\tunsigned int\tyl:12;\t/* Y coordinate of upper left\t*/\n\t\tunsigned int\tpad1:5;\t/* Padding\t\t\t*/\n\t\tunsigned int\ttile:3;\t/* Tile descriptor index\t*/\n\t\tunsigned int\txh:12;\t/* X coordinate of lower right\t*/\n\t\tunsigned int\tyh:12;\t/* Y coordinate of lower right\t*/\n\t\tunsigned int\ts:16;\t/* S texture coord at top left\t*/\n\t\tunsigned int\tt:16;\t/* T texture coord at top left\t*/\n\t\tunsigned int\tdsdx:16;/* Change in S per change in X\t*/\n\t\tunsigned int\tdtdy:16;/* Change in T per change in Y\t*/\n} Gtexrect;\n\n#define\tMakeTexRect(xh,yh,flip,tile,xl,yl,s,t,dsdx,dtdy)\t\t\\\n\tG_TEXRECT, xh, yh, 0, flip, 0, tile, xl, yl, s, t, dsdx, dtdy\n\n/*\n * Textured rectangles are 128 bits not 64 bits\n */\t\ntypedef struct {\n    unsigned long w0;\n    unsigned long w1;\n    unsigned long w2;\n    unsigned long w3;\n} TexRect;\n\n/*\n * Generic Gfx Packet\n */\ntypedef struct {\n\tunsigned int w0;\n\tunsigned int w1;\n} Gwords;\n\n/*\n * This union is the fundamental type of the display list.\n * It is, by law, exactly 64 bits in size.\n */\ntypedef union {\n\tGwords\t\twords;\n\tGdma\t\tdma;\n\tGtri\t\ttri;\n\tGline3D\t\tline;\n\tGpopmtx\t\tpopmtx;\n\tGsegment\tsegment;\n\tGsetothermodeH\tsetothermodeH;\n\tGsetothermodeL\tsetothermodeL;\n\tGtexture\ttexture;\n\tGperspnorm\tperspnorm;\n\tGsetimg\t\tsetimg;\n\tGsetcombine\tsetcombine;\n\tGsetcolor\tsetcolor;\n\tGfillrect\tfillrect;\t/* use for setscissor also */\n\tGsettile\tsettile;\n\tGloadtile\tloadtile;\t/* use for loadblock also, th is dxt */\n\tGsettilesize\tsettilesize;\n\tGloadtlut\tloadtlut;\n        long long int\tforce_structure_alignment;\n} Gfx;\n\n/*\n * Macros to assemble the graphics display list\n */\n\n/*\n * DMA macros\n */\n#define\tgDma0p(pkt, c, s, l)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL((c), 24, 8) | _SHIFTL((l), 0, 24);\t\\\n\t_g->words.w1 = (unsigned int)(s);\t\t\t\t\\\n} while (0)\n\n#define\tgsDma0p(c, s, l)\t\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL((c), 24, 8) | _SHIFTL((l), 0, 24), (unsigned int)(s)\t\\\n}}\n\n#define\tgDma1p(pkt, c, s, l, p)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL((c), 24, 8) | _SHIFTL((p), 16, 8) |\t\\\n\t\t\t_SHIFTL((l), 0, 16));\t\t\t\t\\\n\t_g->words.w1 = (unsigned int)(s);\t\t\t\t\\\n} while (0)\n\n#define\tgsDma1p(c, s, l, p)\t\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t(_SHIFTL((c), 24, 8) | _SHIFTL((p), 16, 8) | \t\t\t\\\n\t _SHIFTL((l), 0, 16)), \t\t\t\t\t\t\\\n        (unsigned int)(s)\t\t\t\t\t\t\\\n}}\n\n#define\tgDma2p(pkt, c, adrs, len, idx, ofs)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL((c),24,8)|_SHIFTL(((len)-1)/8,19,5)|\t\\\n\t\t\t_SHIFTL((ofs)/8,8,8)|_SHIFTL((idx),0,8));\t\\\n\t_g->words.w1 = (unsigned int)(adrs);\t\t\t\t\\\n} while (0)\n#define\tgsDma2p(c, adrs, len, idx, ofs)\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t(_SHIFTL((c),24,8)|_SHIFTL(((len)-1)/8,19,5)|\t\t\t\\\n\t _SHIFTL((ofs)/8,8,8)|_SHIFTL((idx),0,8)),\t\t\t\\\n        (unsigned int)(adrs)\t\t\t\t\t\t\\\n}}\n\n#define\tgSPNoOp(pkt)\t\tgDma0p(pkt, G_SPNOOP, 0, 0)\n#define\tgsSPNoOp()\t\tgsDma0p(G_SPNOOP, 0, 0)\n\n#ifdef\tF3DEX_GBI_2\n# define\tgSPMatrix(pkt, m, p)\t\\\n\t\tgDma2p((pkt),G_MTX,(m),sizeof(Mtx),(p)^G_MTX_PUSH,0)\n# define\tgsSPMatrix(m, p)\t\\\n\t\tgsDma2p(     G_MTX,(m),sizeof(Mtx),(p)^G_MTX_PUSH,0)\n#else\t/* F3DEX_GBI_2 */\n# define\tgSPMatrix(pkt, m, p)\tgDma1p(pkt, G_MTX, m, sizeof(Mtx), p)\n# define\tgsSPMatrix(m, p)\tgsDma1p(G_MTX, m, sizeof(Mtx), p)\n#endif\t/* F3DEX_GBI_2 */\n\n#if\tdefined(F3DEX_GBI_2)\n/*\n * F3DEX_GBI_2: G_VTX GBI format was changed.\n *\n *        +--------+----+---+---+----+------+-+\n *  G_VTX |  cmd:8 |0000|  n:8  |0000|v0+n:7|0|\n *        +-+---+--+----+---+---+----+------+-+\n *        | |seg|         address             |\n *        +-+---+-----------------------------+\n */\n# define\tgSPVertex(pkt, v, n, v0)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t_g->words.w0 =\t\t\t\t\t\t\t\\\n\t  _SHIFTL(G_VTX,24,8)|_SHIFTL((n),12,8)|_SHIFTL((v0)+(n),1,7);\t\\\n\t_g->words.w1 = (unsigned int)(v);\t\t\t\t\\\n} while (0)\n# define\tgsSPVertex(v, n, v0)\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t(_SHIFTL(G_VTX,24,8)|_SHIFTL((n),12,8)|_SHIFTL((v0)+(n),1,7)),\t\\\n        (unsigned int)(v)\t\t\t\t\t\t\\\n}}\n#elif\t(defined(F3DEX_GBI)||defined(F3DLP_GBI))\n/*\n * F3DEX_GBI: G_VTX GBI format was changed to support 64 vertice.\n *\n *        +--------+--------+------+----------+\n *  G_VTX |  cmd:8 |  v0:8  |  n:6 |length:10 |\n *        +-+---+--+--------+------+----------+\n *        | |seg|          address            |\n *        +-+---+-----------------------------+\n */\n# define\tgSPVertex(pkt, v, n, v0) \\\n                gDma1p((pkt),G_VTX,(v),((n)<<10)|(sizeof(Vtx)*(n)-1),(v0)*2)\n# define\tgsSPVertex(v, n, v0) \\\n                gsDma1p(G_VTX,(v),((n)<<10)|(sizeof(Vtx)*(n)-1),(v0)*2)\n#else\n# define\tgSPVertex(pkt, v, n, v0) \\\n                gDma1p(pkt, G_VTX, v, sizeof(Vtx)*(n),((n)-1)<<4|(v0))\n# define\tgsSPVertex(v, n, v0) \\\n                gsDma1p(G_VTX, v, sizeof(Vtx)*(n), ((n)-1)<<4|(v0))\n#endif\n\n\t\n#ifdef\tF3DEX_GBI_2\n# define gSPViewport(pkt, v)\t\\\n\t\tgDma2p((pkt), G_MOVEMEM, (v), sizeof(Vp), G_MV_VIEWPORT, 0)\n# define gsSPViewport(v)\t\\\n\t\tgsDma2p(      G_MOVEMEM, (v), sizeof(Vp), G_MV_VIEWPORT, 0)\n#else\t/* F3DEX_GBI_2 */\n# define gSPViewport(pkt,v)\t\\\n\t\tgDma1p((pkt), G_MOVEMEM, (v), sizeof(Vp), G_MV_VIEWPORT)\n# define gsSPViewport(v)\t\\\n\t\tgsDma1p(      G_MOVEMEM, (v), sizeof(Vp), G_MV_VIEWPORT)\n#endif\t/* F3DEX_GBI_2 */\n\n#define\tgSPDisplayList(pkt,dl)\tgDma1p(pkt,G_DL,dl,0,G_DL_PUSH)\n#define\tgsSPDisplayList(   dl)\tgsDma1p(   G_DL,dl,0,G_DL_PUSH)\n\n#define\tgSPBranchList(pkt,dl)\tgDma1p(pkt,G_DL,dl,0,G_DL_NOPUSH)\n#define\tgsSPBranchList(   dl)\tgsDma1p(   G_DL,dl,0,G_DL_NOPUSH)\n\n#define\tgSPSprite2DBase(pkt, s)\tgDma1p(pkt, G_SPRITE2D_BASE, s, sizeof(uSprite), 0)\n#define\tgsSPSprite2DBase(s)\tgsDma1p(G_SPRITE2D_BASE, s, sizeof(uSprite), 0)\n\n/*\n * RSP short command (no DMA required) macros\n */\n#define\tgImmp0(pkt, c)\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL((c), 24, 8);\t\t\t\t\\\n} while (0)\n\n#define\tgsImmp0(c)\t\t\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL((c), 24, 8)\t\t\t\t\t\t\\\n}}\n\n#define\tgImmp1(pkt, c, p0)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL((c), 24, 8);\t\t\t\t\\\n\t_g->words.w1 = (unsigned int)(p0);\t\t\t\t\\\n} while (0)\n\n#define\tgsImmp1(c, p0)\t\t\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL((c), 24, 8), (unsigned int)(p0)\t\t\t\t\\\n}}\n\n#define\tgImmp2(pkt, c, p0, p1)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL((c), 24, 8);\t\t\t\t\\\n\t_g->words.w1 = _SHIFTL((p0), 16, 16) | _SHIFTL((p1), 8, 8);\t\\\n} while (0)\n\n#define\tgsImmp2(c, p0, p1)\t\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL((c), 24, 8),  _SHIFTL((p0), 16, 16) | _SHIFTL((p1), 8, 8)\\\n}}\n\n#define\tgImmp3(pkt, c, p0, p1, p2)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL((c), 24, 8);\t\t\t\t\\\n\t_g->words.w1 = (_SHIFTL((p0), 16, 16) | _SHIFTL((p1), 8, 8) |\t\\\n\t\t\t_SHIFTL((p2), 0, 8));\t\t\t\t\\\n} while (0)\n\n#define\tgsImmp3(c, p0, p1, p2)\t\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL((c), 24, 8), (_SHIFTL((p0), 16, 16) | \t\t\t\\\n\t\t\t      _SHIFTL((p1), 8, 8) | _SHIFTL((p2), 0, 8))\\\n}}\n\n#define\tgImmp21(pkt, c, p0, p1, dat)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL((c), 24, 8)  | _SHIFTL((p0), 8, 16) |\t\\\n\t\t\t_SHIFTL((p1), 0, 8));\t\t\t\t\\\n\t_g->words.w1 = (unsigned int) (dat);\t\t\t\t\\\n} while (0)\n\n#define\tgsImmp21(c, p0, p1, dat)\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL((c), 24, 8) | _SHIFTL((p0), 8, 16) | _SHIFTL((p1), 0, 8),\\\n        (unsigned int) (dat)\t\t\t\t\t\t\\\n}}\n\n#ifdef\tF3DEX_GBI_2\n#define gMoveWd(pkt, index, offset, data)\t\t\t\t\\\n\tgDma1p((pkt), G_MOVEWORD, data, offset, index)\n#define gsMoveWd(    index, offset, data)\t\t\t\t\\\n\tgsDma1p(      G_MOVEWORD, data, offset, index)\n#else\t/* F3DEX_GBI_2 */\n#define gMoveWd(pkt, index, offset, data)\t\t\t\t\\\n\tgImmp21((pkt), G_MOVEWORD, offset, index, data)\n#define gsMoveWd(    index, offset, data)\t\t\t\t\\\n\tgsImmp21(      G_MOVEWORD, offset, index, data)\n#endif\t/* F3DEX_GBI_2 */\n\n/* Sprite immediate macros, there is also a sprite dma macro above */\n\n#define gSPSprite2DScaleFlip(pkt, sx, sy, fx, fy)                       \\\ndo {                                                                       \\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(G_SPRITE2D_SCALEFLIP, 24, 8) |          \\\n\t\t\t_SHIFTL((fx), 8, 8) |                           \\\n\t\t\t_SHIFTL((fy), 0, 8));\t                        \\\n\t_g->words.w1 = (_SHIFTL((sx), 16, 16) |                         \\\n\t\t\t_SHIFTL((sy),  0, 16));                         \\\n} while (0)\n\n#define gsSPSprite2DScaleFlip(sx, sy, fx, fy)                           \\\n{{                                                                       \\\n          (_SHIFTL(G_SPRITE2D_SCALEFLIP, 24, 8) |                       \\\n\t   _SHIFTL((fx), 8, 8) |                                        \\\n\t   _SHIFTL((fy), 0, 8)),\t                                \\\n\t  (_SHIFTL((sx), 16, 16) |                                      \\\n\t   _SHIFTL((sy),  0, 16))                                       \\\n}}\n\n#define gSPSprite2DDraw(pkt, px, py)                                    \\\ndo {                                                                       \\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(G_SPRITE2D_DRAW, 24, 8));               \\\n\t_g->words.w1 = (_SHIFTL((px), 16, 16) |                         \\\n\t\t\t_SHIFTL((py),  0, 16));                         \\\n} while (0)\n\n#define gsSPSprite2DDraw(px, py)                                        \\\n{{                                                                       \\\n          (_SHIFTL(G_SPRITE2D_DRAW, 24, 8)),                            \\\n\t  (_SHIFTL((px), 16, 16) |                                      \\\n\t   _SHIFTL((py),  0, 16))                                       \\\n}}\n\n\n/*\n * Note: the SP1Triangle() and line macros multiply the vertex indices\n * by 10, this is an optimization for the microcode.\n */\n#if\t(defined(F3DLP_GBI)||defined(F3DEX_GBI))\n#  define __gsSP1Triangle_w1(v0, v1, v2)\t\t\t\\\n     (_SHIFTL((v0)*2,16,8)|_SHIFTL((v1)*2,8,8)|_SHIFTL((v2)*2,0,8))\n#  define __gsSP1Triangle_w1f(v0, v1, v2, flag)\t\t\t\\\n     (((flag) == 0) ? __gsSP1Triangle_w1(v0, v1, v2):\t\t\\\n      ((flag) == 1) ? __gsSP1Triangle_w1(v1, v2, v0):\t\t\\\n\t              __gsSP1Triangle_w1(v2, v0, v1))\n#  define __gsSPLine3D_w1(v0, v1, wd)\t\t\t\t\\\n     (_SHIFTL((v0)*2,16,8)|_SHIFT((v1)*2,8,8)|_SHIFT((wd),0,8))\n#  define __gsSPLine3D_w1f(v0, v1, wd, flag)\t\t\t\\\n     (((flag) == 0) ? __gsSPLine3D_w1(v0, v1, wd):\t\t\\\n\t              __gsSPLine3D_w1(v1, v0, wd))\n#  define __gsSP1Quadrangle_w1f(v0, v1, v2, v3, flag)\t\\\n  (((flag) == 0) ? __gsSP1Triangle_w1(v0, v1, v2):      \\\n   ((flag) == 1) ? __gsSP1Triangle_w1(v1, v2, v3):      \\\n   ((flag) == 2) ? __gsSP1Triangle_w1(v2, v3, v0):      \\\n                   __gsSP1Triangle_w1(v3, v0, v1))\n#  define __gsSP1Quadrangle_w2f(v0, v1, v2, v3, flag)\t\\\n  (((flag) == 0) ? __gsSP1Triangle_w1(v0, v2, v3):      \\\n   ((flag) == 1) ? __gsSP1Triangle_w1(v1, v3, v0):      \\\n   ((flag) == 2) ? __gsSP1Triangle_w1(v2, v0, v1):      \\\n                   __gsSP1Triangle_w1(v3, v1, v2))\n#else\n#  define __gsSP1Triangle_w1f(v0, v1, v2, flag)\t\t\t\\\n     (_SHIFTL((flag), 24,8)|_SHIFTL((v0)*10,16,8)|\t\t\\\n      _SHIFTL((v1)*10, 8,8)|_SHIFTL((v2)*10, 0,8))\n#  define __gsSPLine3D_w1f(v0, v1, wd, flag)\t\t\t\\\n     (_SHIFTL((flag), 24,8)|_SHIFTL((v0)*10,16,8)| \t\t\\\n      _SHIFTL((v1)*10, 8,8)|_SHIFTL((wd),    0,8))\n#endif\n\n#ifdef\tF3DEX_GBI_2\n/***\n ***  1 Triangle\n ***/\n#define gSP1Triangle(pkt, v0, v1, v2, flag)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_TRI1, 24, 8)|\t\t\t\t\\\n\t\t\t__gsSP1Triangle_w1f(v0, v1, v2, flag);\t\t\\\n\t_g->words.w1 = 0;\t\t\t\t\t\t\\\n} while (0)\n#define gsSP1Triangle(v0, v1, v2, flag)\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_TRI1, 24, 8)|__gsSP1Triangle_w1f(v0, v1, v2, flag),\t\\\n\t0\t\t\t\t\t\t\t\t\\\n}}\n\n/***\n ***  Line\n ***/\n#define gSPLine3D(pkt, v0, v1, flag)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_LINE3D, 24, 8)|\t\t\t\\\n\t\t\t__gsSPLine3D_w1f(v0, v1, 0, flag);\t\t\\\n\t_g->words.w1 = 0;\t\t\t\t\t\t\\\n} while (0)\n#define gsSPLine3D(v0, v1, flag)\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_LINE3D, 24, 8)|__gsSPLine3D_w1f(v0, v1, 0, flag),\t\\\n\t0\t\t\t\t\t\t\t\t\\\n}}\n\n/***\n ***  LineW\n ***/\n/* these macros are the same as SPLine3D, except they have an\n * additional parameter for width. The width is added to the \"minimum\"\n * thickness, which is 1.5 pixels. The units for width are in\n * half-pixel units, so a width of 1 translates to (.5 + 1.5) or\n * a 2.0 pixels wide line.\n */\n#define gSPLineW3D(pkt, v0, v1, wd, flag)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_LINE3D, 24, 8)|\t\t\t\\\n\t\t\t__gsSPLine3D_w1f(v0, v1, wd, flag);\t\t\\\n\t_g->words.w1 = 0;\t\t\t\t\t\t\\\n} while (0)\n#define gsSPLineW3D(v0, v1, wd, flag)\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_LINE3D, 24, 8)|__gsSPLine3D_w1f(v0, v1, wd, flag),\t\\\n\t0\t\t\t\t\t\t\t\t\\\n}}\n\n/***\n ***  1 Quadrangle\n ***/\n#define gSP1Quadrangle(pkt, v0, v1, v2, v3, flag)                       \\\ndo {                                                                       \\\n        Gfx *_g = (Gfx *)(pkt);                                         \\\n                                                                        \\\n        _g->words.w0 = (_SHIFTL(G_QUAD, 24, 8)|\t                        \\\n                        __gsSP1Quadrangle_w1f(v0, v1, v2, v3, flag));   \\\n        _g->words.w1 =  __gsSP1Quadrangle_w2f(v0, v1, v2, v3, flag);    \\\n} while (0)\n\n#define gsSP1Quadrangle(v0, v1, v2, v3, flag)                           \\\n{{                                                                       \\\n        (_SHIFTL(G_QUAD, 24, 8)|                                        \\\n         __gsSP1Quadrangle_w1f(v0, v1, v2, v3, flag)),                  \\\n         __gsSP1Quadrangle_w2f(v0, v1, v2, v3, flag)                    \\\n}}\n#else\t/* F3DEX_GBI_2 */\n\n/***\n ***  1 Triangle\n ***/\t\n#define gSP1Triangle(pkt, v0, v1, v2, flag)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_TRI1, 24, 8);\t\t\t\t\\\n\t_g->words.w1 = __gsSP1Triangle_w1f(v0, v1, v2, flag);\t\t\\\n} while (0)\n#define gsSP1Triangle(v0, v1, v2, flag)\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_TRI1, 24, 8),\t\t\t\t\t\t\\\n\t__gsSP1Triangle_w1f(v0, v1, v2, flag)\t\t\t\t\\\n}}\n\n/***\n ***  Line\n ***/\n#define gSPLine3D(pkt, v0, v1, flag)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_LINE3D, 24, 8);\t\t\t\\\n\t_g->words.w1 = __gsSPLine3D_w1f(v0, v1, 0, flag);\t\t\\\n} while (0)\n#define gsSPLine3D(v0, v1, flag)\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_LINE3D, 24, 8),\t\t\t\t\t\\\n\t__gsSPLine3D_w1f(v0, v1, 0, flag)\t\t\t\t\\\n}}\n\n/***\n ***  LineW\n ***/\n/* these macros are the same as SPLine3D, except they have an\n * additional parameter for width. The width is added to the \"minimum\"\n * thickness, which is 1.5 pixels. The units for width are in\n * half-pixel units, so a width of 1 translates to (.5 + 1.5) or\n * a 2.0 pixels wide line.\n */\n#define gSPLineW3D(pkt, v0, v1, wd, flag)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_LINE3D, 24, 8);\t\t\t\\\n\t_g->words.w1 = __gsSPLine3D_w1f(v0, v1, wd, flag);\t\t\\\n} while (0)\n#define gsSPLineW3D(v0, v1, wd, flag)\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_LINE3D, 24, 8),\t\t\t\t\t\\\n\t__gsSPLine3D_w1f(v0, v1, wd, flag)\t\t\t\t\\\n}}\n\n/***\n ***  1 Quadrangle\n ***/\n#define gSP1Quadrangle(pkt, v0, v1, v2, v3, flag)                       \\\ndo {                                                                       \\\n        Gfx *_g = (Gfx *)(pkt);                                         \\\n                                                                        \\\n        _g->words.w0 = (_SHIFTL(G_TRI2, 24, 8)|\t                        \\\n                        __gsSP1Quadrangle_w1f(v0, v1, v2, v3, flag));   \\\n        _g->words.w1 =  __gsSP1Quadrangle_w2f(v0, v1, v2, v3, flag);    \\\n} while (0)\n\n#define gsSP1Quadrangle(v0, v1, v2, v3, flag)                           \\\n{{                                                                       \\\n        (_SHIFTL(G_TRI2, 24, 8)|                                        \\\n         __gsSP1Quadrangle_w1f(v0, v1, v2, v3, flag)),                  \\\n         __gsSP1Quadrangle_w2f(v0, v1, v2, v3, flag)                    \\\n}}\n#endif\t/* F3DEX_GBI_2 */\n\n#if\t(defined(F3DLP_GBI)||defined(F3DEX_GBI))\n/***\n ***  2 Triangles\n ***/\n#define gSP2Triangles(pkt, v00, v01, v02, flag0, v10, v11, v12, flag1)\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(G_TRI2, 24, 8)|\t\t\t\t\\\n\t\t\t__gsSP1Triangle_w1f(v00, v01, v02, flag0));\t\\\n        _g->words.w1 =  __gsSP1Triangle_w1f(v10, v11, v12, flag1); \t\\\n} while (0)\n\n#define gsSP2Triangles(v00, v01, v02, flag0, v10, v11, v12, flag1)\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t(_SHIFTL(G_TRI2, 24, 8)|\t\t\t\t\t\\\n\t __gsSP1Triangle_w1f(v00, v01, v02, flag0)),\t\t\t\\\n\t __gsSP1Triangle_w1f(v10, v11, v12, flag1)\t\t\t\\\n}}\n\n#endif\t/* F3DEX_GBI/F3DLP_GBI */\n\n#if\t(defined(F3DEX_GBI)||defined(F3DLP_GBI))\n#define gSPCullDisplayList(pkt,vstart,vend)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_CULLDL, 24, 8) | \t\t\t\\\n\t\t\t_SHIFTL((vstart)*2, 0, 16);\t\t\t\\\n\t_g->words.w1 = _SHIFTL((vend)*2, 0, 16);\t\t\t\\\n} while (0)\n\n#define gsSPCullDisplayList(vstart,vend)\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_CULLDL, 24, 8) | _SHIFTL((vstart)*2, 0, 16),\t\t\\\n\t_SHIFTL((vend)*2, 0, 16)\t\t\t\t\t\\\n}}\n\n#else\n#define gSPCullDisplayList(pkt,vstart,vend)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_CULLDL, 24, 8) |\t\t\t\\\n                       ((0x0f & (vstart))*40);\t\t\t\t\\\n\t_g->words.w1 = (unsigned int)((0x0f & ((vend)+1))*40);\t\t\\\n} while (0)\n\n#define gsSPCullDisplayList(vstart,vend)\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_CULLDL, 24, 8) | ((0x0f & (vstart))*40), \t\t\\\n\t((0x0f & ((vend)+1))*40)\t\t\t\t\t\\\n}}\n#endif\n\n#define gSPSegment(pkt, segment, base)\t\t\t\t\t\\\n\tgMoveWd(pkt, G_MW_SEGMENT, (segment)*4, base)\n#define gsSPSegment(segment, base)\t\t\t\t\t\\\n\tgsMoveWd(    G_MW_SEGMENT, (segment)*4, base)\n\n/*\n * Clipping Macros\n */\n#define FR_NEG_FRUSTRATIO_1\t0x00000001\n#define FR_POS_FRUSTRATIO_1\t0x0000ffff\n#define FR_NEG_FRUSTRATIO_2\t0x00000002\n#define FR_POS_FRUSTRATIO_2\t0x0000fffe\n#define FR_NEG_FRUSTRATIO_3\t0x00000003\n#define FR_POS_FRUSTRATIO_3\t0x0000fffd\n#define FR_NEG_FRUSTRATIO_4\t0x00000004\n#define FR_POS_FRUSTRATIO_4\t0x0000fffc\n#define FR_NEG_FRUSTRATIO_5\t0x00000005\n#define FR_POS_FRUSTRATIO_5\t0x0000fffb\n#define FR_NEG_FRUSTRATIO_6\t0x00000006\n#define FR_POS_FRUSTRATIO_6\t0x0000fffa\n/*\n * r should be one of: FRUSTRATIO_1, FRUSTRATIO_2, FRUSTRATIO_3, ... FRUSTRATIO_6\n */\n#define gSPClipRatio(pkt, r)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgMoveWd(pkt, G_MW_CLIP, G_MWO_CLIP_RNX, FR_NEG_##r);\t\t\\\n\tgMoveWd(pkt, G_MW_CLIP, G_MWO_CLIP_RNY, FR_NEG_##r);\t\t\\\n\tgMoveWd(pkt, G_MW_CLIP, G_MWO_CLIP_RPX, FR_POS_##r);\t\t\\\n\tgMoveWd(pkt, G_MW_CLIP, G_MWO_CLIP_RPY, FR_POS_##r);\t\t\\\n} while (0)\n\n#define gsSPClipRatio(r)\t\t\t\t\t\t\\\n\tgsMoveWd(G_MW_CLIP, G_MWO_CLIP_RNX, FR_NEG_##r),\t\t\\\n\tgsMoveWd(G_MW_CLIP, G_MWO_CLIP_RNY, FR_NEG_##r),\t\t\\\n\tgsMoveWd(G_MW_CLIP, G_MWO_CLIP_RPX, FR_POS_##r),\t\t\\\n\tgsMoveWd(G_MW_CLIP, G_MWO_CLIP_RPY, FR_POS_##r)\n\n/*\n * Insert values into Matrix\n *\n * where = element of matrix (byte offset)\n * num   = new element (32 bit value replacing 2 int or 2 frac matrix \n *                                 componants\n */\n#ifdef\tF3DEX_GBI_2\n#define gSPInsertMatrix(pkt, where, num)\t\t\t\t\\\n\tERROR!! gSPInsertMatrix is no longer supported.\n#define gsSPInsertMatrix(where, num)\t\t\t\t\t\\\n\tERROR!! gsSPInsertMatrix is no longer supported.\n#else\n#define gSPInsertMatrix(pkt, where, num)\t\t\t\t\\\n\tgMoveWd(pkt, G_MW_MATRIX, where, num)\n#define gsSPInsertMatrix(where, num)\t\t\t\t\t\\\n\tgsMoveWd(G_MW_MATRIX, where, num)\n#endif\n\n/*\n * Load new matrix directly\n *\n * mptr = pointer to matrix\n */\n#ifdef\tF3DEX_GBI_2\n#define\tgSPForceMatrix(pkt, mptr)\t\t\t\t\t\\\ndo {\tgDma2p((pkt),G_MOVEMEM,(mptr),sizeof(Mtx),G_MV_MATRIX,0);\t\\\n\tgMoveWd((pkt), G_MW_FORCEMTX,0,0x00010000);\t\t\t\\\n} while (0)\n#define\tgsSPForceMatrix(mptr)\t\t\t\t\t\t\\\n\tgsDma2p(G_MOVEMEM,(mptr),sizeof(Mtx),G_MV_MATRIX,0),\t\t\\\n\tgsMoveWd(G_MW_FORCEMTX,0,0x00010000)\n\t\n#else\t/* F3DEX_GBI_2 */\n#define\tgSPForceMatrix(pkt, mptr)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDma1p(pkt, G_MOVEMEM, mptr,              16, G_MV_MATRIX_1);\t\\\n\tgDma1p(pkt, G_MOVEMEM, (char *)(mptr)+16, 16, G_MV_MATRIX_2);\t\\\n\tgDma1p(pkt, G_MOVEMEM, (char *)(mptr)+32, 16, G_MV_MATRIX_3);\t\\\n\tgDma1p(pkt, G_MOVEMEM, (char *)(mptr)+48, 16, G_MV_MATRIX_4);\t\\\n} while (0)\n#define\tgsSPForceMatrix(mptr)\t\t\t\t\t\t\\\n\tgsDma1p(    G_MOVEMEM, mptr,              16, G_MV_MATRIX_1),\t\\\n\tgsDma1p(    G_MOVEMEM, (char *)(mptr)+16, 16, G_MV_MATRIX_2),\t\\\n\tgsDma1p(    G_MOVEMEM, (char *)(mptr)+32, 16, G_MV_MATRIX_3),\t\\\n\tgsDma1p(    G_MOVEMEM, (char *)(mptr)+48, 16, G_MV_MATRIX_4)\n#endif\t/* F3DEX_GBI_2 */\n\n/*\n * Insert values into Points\n *\n * point = point number 0-15\n * where = which element of point to modify (byte offset into point)\n * num   = new value (32 bit)\n */\n#if\t(defined(F3DEX_GBI)||defined(F3DLP_GBI))\n# define gSPModifyVertex(pkt, vtx, where, val)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(G_MODIFYVTX,24,8)|\t\t\t\\\n\t\t        _SHIFTL((where),16,8)|_SHIFTL((vtx)*2,0,16));\t\\\n\t_g->words.w1 = (unsigned int)(val);\t\t\t\t\\\n} while (0)\n# define gsSPModifyVertex(vtx, where, val)\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_MODIFYVTX,24,8)|\t\t\t\t\t\\\n\t_SHIFTL((where),16,8)|_SHIFTL((vtx)*2,0,16),\t\t\t\\\n\t(unsigned int)(val)\t\t\t\t\t\t\\\n}}\n#else\n# define gSPModifyVertex(pkt, vtx, where, val)\t\t\t\t\\\n\t gMoveWd(pkt, G_MW_POINTS, (vtx)*40+(where), val)\n# define gsSPModifyVertex(vtx, where, val)\t\t\t\t\\\n\t gsMoveWd(G_MW_POINTS, (vtx)*40+(where), val)\n#endif\n\n#if\t(defined(F3DEX_GBI)||defined(F3DLP_GBI))\n/*\n *  gSPBranchLessZ   Branch DL if (vtx.z) less than or equal (zval).\n *\n *  dl\t = DL branch to \n *  vtx  = Vertex\n *  zval = Screen depth\n *  near = Near plane\n *  far  = Far  plane\n *  flag = G_BZ_PERSP or G_BZ_ORTHO\n */\n\n#define\tG_BZ_PERSP\t0\n#define\tG_BZ_ORTHO\t1\n\n#define\tG_DEPTOZSrg(zval, near, far, flag, zmin, zmax)\t\t\t\\\n(((unsigned int)FTOFIX32(((flag) == G_BZ_PERSP ? \t\t\t\\\n\t\t\t  (1.0f-(float)(near)/(float)(zval)) / \t\t\\\n\t\t\t  (1.0f-(float)(near)/(float)(far )) :\t\t\\\n\t\t\t  ((float)(zval) - (float)(near)) /\t\t\\\n\t\t\t  ((float)(far ) - (float)(near))))) *\t\t\\\n (((int)((zmax) - (zmin)))&~1) + (int)FTOFIX32(zmin))\n\n#define\tG_DEPTOZS(zval, near, far, flag) \\\n\tG_DEPTOZSrg(zval, near, far, flag, 0, G_MAXZ)\n\n#define\tgSPBranchLessZrg(pkt, dl, vtx, zval, near, far, flag, zmin, zmax) \\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_RDPHALF_1,24,8);\t\t\t\\\n\t_g->words.w1 = (unsigned int)(dl);\t\t\t\t\\\n\t_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(G_BRANCH_Z,24,8)|\t\t\t\\\n\t\t        _SHIFTL((vtx)*5,12,12)|_SHIFTL((vtx)*2,0,12));\t\\\n\t_g->words.w1 = G_DEPTOZSrg(zval, near, far, flag, zmin, zmax);\t\\\n} while (0)\n\n#define\tgsSPBranchLessZrg(dl, vtx, zval, near, far, flag, zmin, zmax)\t      \\\n{{\t_SHIFTL(G_RDPHALF_1,24,8),\t\t\t\t\t      \\\n\t(unsigned int)(dl),\t\t\t\t\t\t}},    \\\n{{\t_SHIFTL(G_BRANCH_Z,24,8)|_SHIFTL((vtx)*5,12,12)|_SHIFTL((vtx)*2,0,12),\\\n\tG_DEPTOZSrg(zval, near, far, flag, zmin, zmax),\t\t\t}}\n\n#define\tgSPBranchLessZ(pkt, dl, vtx, zval, near, far, flag)\t\t\\\n\tgSPBranchLessZrg(pkt, dl, vtx, zval, near, far, flag, 0, G_MAXZ)\n#define\tgsSPBranchLessZ(dl, vtx, zval, near, far, flag)\t\t\t\\\n\tgsSPBranchLessZrg(dl, vtx, zval, near, far, flag, 0, G_MAXZ)\n\n/*\n *  gSPBranchLessZraw   Branch DL if (vtx.z) less than or equal (raw zval).\n *\n *  dl\t = DL branch to \n *  vtx  = Vertex\n *  zval = Raw value of screen depth\n */\n#define\tgSPBranchLessZraw(pkt, dl, vtx, zval)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_RDPHALF_1,24,8);\t\t\t\\\n\t_g->words.w1 = (unsigned int)(dl);\t\t\t\t\\\n\t_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(G_BRANCH_Z,24,8)|\t\t\t\\\n\t\t        _SHIFTL((vtx)*5,12,12)|_SHIFTL((vtx)*2,0,12));\t\\\n\t_g->words.w1 = (unsigned int)(zval);\t\t\t\t\\\n} while (0)\n\n#define\tgsSPBranchLessZraw(dl, vtx, zval)\t\t\t\t\\\n{{\t_SHIFTL(G_RDPHALF_1,24,8),\t\t\t\t\t      \\\n\t(unsigned int)(dl),\t\t\t\t\t\t}},    \\\n{{\t_SHIFTL(G_BRANCH_Z,24,8)|_SHIFTL((vtx)*5,12,12)|_SHIFTL((vtx)*2,0,12),\\\n\t(unsigned int)(zval),\t\t\t\t\t\t}}\n\n/*\n * gSPLoadUcode   RSP loads specified ucode.\n *\n * uc_start  = ucode text section start\n * uc_dstart = ucode data section start\n */\n#define\tgSPLoadUcodeEx(pkt, uc_start, uc_dstart, uc_dsize)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_RDPHALF_1,24,8);\t\t\t\\\n\t_g->words.w1 = (unsigned int)(uc_dstart);\t\t\t\\\n\t_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(G_LOAD_UCODE,24,8)|\t\t\t\\\n\t\t\t_SHIFTL((int)(uc_dsize)-1,0,16));\t\t\\\n\t_g->words.w1 = (unsigned int)(uc_start);\t\t\t\\\n} while (0)\n\n#define\tgsSPLoadUcodeEx(uc_start, uc_dstart, uc_dsize)\t\t\t\\\n{{\t_SHIFTL(G_RDPHALF_1,24,8),\t\t\t\t\t\\\n\t(unsigned int)(uc_dstart),\t\t\t\t}},\t\\\n{{\t_SHIFTL(G_LOAD_UCODE,24,8)|\t\t\t\t\t\\\n\t  _SHIFTL((int)(uc_dsize)-1,0,16),\t\t\t\t\\\n\t(unsigned int)(uc_start),\t\t\t\t}}\n\n#define\tgSPLoadUcode(pkt, uc_start, uc_dstart)\t\t\t\t\\\n        gSPLoadUcodeEx((pkt), (uc_start), (uc_dstart), SP_UCODE_DATA_SIZE)\n#define\tgsSPLoadUcode(uc_start, uc_dstart)\t\t\t\t\\\n        gsSPLoadUcodeEx((uc_start), (uc_dstart), SP_UCODE_DATA_SIZE)\n\n#define\tgSPLoadUcodeL(pkt, ucode)\t\t\t\t\t\\\n        gSPLoadUcode((pkt), OS_K0_TO_PHYSICAL(&##ucode##TextStart),\t\\\n\t\t            OS_K0_TO_PHYSICAL(&##ucode##DataStart))\n#define\tgsSPLoadUcodeL(ucode)\t\t\t\t\t\t\\\n        gsSPLoadUcode(OS_K0_TO_PHYSICAL(&##ucode##TextStart),\t\t\\\n\t\t      OS_K0_TO_PHYSICAL(&##ucode##DataStart))\n#endif\n\n#ifdef\tF3DEX_GBI_2\n/*\n * gSPDma_io  DMA to/from DMEM/IMEM for DEBUG.\n */\n#define\tgSPDma_io(pkt, flag, dmem, dram, size)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_DMA_IO,24,8)|_SHIFTL((flag),23,1)|\t\\\n\t  _SHIFTL((dmem)/8,13,10)|_SHIFTL((size)-1,0,12);\t\t\\\n\t_g->words.w1 = (unsigned int)(dram);\t\t\t\t\\\n} while (0)\n\n#define\tgsSPDma_io(flag, dmem, dram, size)\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_DMA_IO,24,8)|_SHIFTL((flag),23,1)|\t\t\t\\\n\t_SHIFTL((dmem)/8,13,10)|_SHIFTL((size)-1,0,12),\t\t\t\\\n\t(unsigned int)(dram)\t\t\t\t\t\t\\\n}}\n\n#define\tgSPDmaRead(pkt,dmem,dram,size)\tgSPDma_io((pkt),0,(dmem),(dram),(size))\n#define\tgsSPDmaRead(dmem,dram,size)\tgsSPDma_io(0,(dmem),(dram),(size))\n#define\tgSPDmaWrite(pkt,dmem,dram,size)\tgSPDma_io((pkt),1,(dmem),(dram),(size))\n#define\tgsSPDmaWrite(dmem,dram,size)\tgsSPDma_io(1,(dmem),(dram),(size))\n#endif\n\n/*\n * Lighting Macros\n */\n#ifdef\tF3DEX_GBI_2\n# define NUML(n)\t((n)*24)\n#else\n# define NUML(n)\t(((n)+1)*32 + 0x80000000)\n#endif\n#define NUMLIGHTS_0\t1\n#define NUMLIGHTS_1\t1\n#define NUMLIGHTS_2\t2\n#define NUMLIGHTS_3\t3\n#define NUMLIGHTS_4\t4\n#define NUMLIGHTS_5\t5\n#define NUMLIGHTS_6\t6\n#define NUMLIGHTS_7\t7\n/*\n * n should be one of: NUMLIGHTS_0, NUMLIGHTS_1, ..., NUMLIGHTS_7\n * NOTE: in addition to the number of directional lights specified, \n *       there is always 1 ambient light\n */\n#define gSPNumLights(pkt, n)\t\t\t\t\t\t\\\n\tgMoveWd(pkt, G_MW_NUMLIGHT, G_MWO_NUMLIGHT, NUML(n))\n#define gsSPNumLights(n)\t\t\t\t\t\t\\\n\tgsMoveWd(    G_MW_NUMLIGHT, G_MWO_NUMLIGHT, NUML(n))\n\n#define LIGHT_1\t\t1\n#define LIGHT_2\t\t2\n#define LIGHT_3\t\t3\n#define LIGHT_4\t\t4\n#define LIGHT_5\t\t5\t\n#define LIGHT_6\t\t6\n#define LIGHT_7\t\t7\n#define LIGHT_8\t\t8\n/*\n * l should point to a Light struct\n * n should be one of: LIGHT_1, LIGHT_2, ..., LIGHT_8\n * NOTE: the highest numbered light is always the ambient light (eg if there are\n *       3 directional lights defined: gsSPNumLights(NUMLIGHTS_3), then lights\n *       LIGHT_1 through LIGHT_3 will be the directional lights and light\n *       LIGHT_4 will be the ambient light.\n */\n#ifdef\tF3DEX_GBI_2\n# define gSPLight(pkt, l, n)\t\\\n\t  gDma2p((pkt),G_MOVEMEM,(l),sizeof(Light),G_MV_LIGHT,(n)*24+24)\n# define gsSPLight(l, n)\t\\\n\t gsDma2p(      G_MOVEMEM,(l),sizeof(Light),G_MV_LIGHT,(n)*24+24)\n#else\t/* F3DEX_GBI_2 */\n# define gSPLight(pkt, l, n)\t\\\n\t gDma1p(pkt, G_MOVEMEM, l, sizeof(Light),((n)-1)*2+G_MV_L0)\n# define gsSPLight(l, n)\t\\\n\t gsDma1p(    G_MOVEMEM, l, sizeof(Light),((n)-1)*2+G_MV_L0)\n#endif\t/* F3DEX_GBI_2 */\n\n/*\n * gSPLightColor changes color of light without recalculating light direction\n * col is a 32 bit word with r,g,b,a (alpha is ignored)\n * n should be one of LIGHT_1, LIGHT_2, ..., LIGHT_8\n */\n#define gSPLightColor(pkt, n, col)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgMoveWd(pkt, G_MW_LIGHTCOL, G_MWO_a##n, col);\t\t\t\\\n\tgMoveWd(pkt, G_MW_LIGHTCOL, G_MWO_b##n, col);\t\t\t\\\n} while (0)\n#define gsSPLightColor(n, col)\t\t\t\t\t\t\\\n\tgsMoveWd(G_MW_LIGHTCOL, G_MWO_a##n, col),\t\t\t\\\n\tgsMoveWd(G_MW_LIGHTCOL, G_MWO_b##n, col)\n\n/* These macros use a structure \"name\" which is init'd with the gdSPDefLights macros*/\n\n#define gSPSetLights0(pkt,name)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgSPNumLights(pkt,NUMLIGHTS_0);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[0],1);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.a,2);\t\t\t\t\t\\\n} while (0)\n#define gsSPSetLights0(name)\t\t\t\t\t\t\\\n\tgsSPNumLights(NUMLIGHTS_0),\t\t\t\t\t\\\n\tgsSPLight(&name.l[0],1),\t\t\t\t\t\\\n\tgsSPLight(&name.a,2)\n\n#define gSPSetLights1(pkt,name)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgSPNumLights(pkt,NUMLIGHTS_1);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[0],1);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.a,2);\t\t\t\t\t\\\n} while (0)\n#define gsSPSetLights1(name)\t\t\t\t\t\t\\\n\tgsSPNumLights(NUMLIGHTS_1),\t\t\t\t\t\\\n\tgsSPLight(&name.l[0],1),\t\t\t\t\t\\\n\tgsSPLight(&name.a,2)\n\n#define gSPSetLights2(pkt,name)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgSPNumLights(pkt,NUMLIGHTS_2);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[0],1);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[1],2);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.a,3);\t\t\t\t\t\\\n} while (0)\n#define gsSPSetLights2(name)\t\t\t\t\t\t\\\n\tgsSPNumLights(NUMLIGHTS_2),\t\t\t\t\t\\\n\tgsSPLight(&name.l[0],1),\t\t\t\t\t\\\n\tgsSPLight(&name.l[1],2),\t\t\t\t\t\\\n\tgsSPLight(&name.a,3)\n\n#define gSPSetLights3(pkt,name)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgSPNumLights(pkt,NUMLIGHTS_3);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[0],1);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[1],2);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[2],3);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.a,4);\t\t\t\t\t\\\n} while (0)\n#define gsSPSetLights3(name)\t\t\t\t\t\t\\\n\tgsSPNumLights(NUMLIGHTS_3),\t\t\t\t\t\\\n\tgsSPLight(&name.l[0],1),\t\t\t\t\t\\\n\tgsSPLight(&name.l[1],2),\t\t\t\t\t\\\n\tgsSPLight(&name.l[2],3),\t\t\t\t\t\\\n\tgsSPLight(&name.a,4)\n\n#define gSPSetLights4(pkt,name)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgSPNumLights(pkt,NUMLIGHTS_4);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[0],1);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[1],2);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[2],3);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[3],4);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.a,5);\t\t\t\t\t\\\n} while (0)\n#define gsSPSetLights4(name)\t\t\t\t\t\t\\\n\tgsSPNumLights(NUMLIGHTS_4),\t\t\t\t\t\\\n\tgsSPLight(&name.l[0],1),\t\t\t\t\t\\\n\tgsSPLight(&name.l[1],2),\t\t\t\t\t\\\n\tgsSPLight(&name.l[2],3),\t\t\t\t\t\\\n\tgsSPLight(&name.l[3],4),\t\t\t\t\t\\\n\tgsSPLight(&name.a,5)\n\n#define gSPSetLights5(pkt,name)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgSPNumLights(pkt,NUMLIGHTS_5);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[0],1);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[1],2);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[2],3);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[3],4);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[4],5);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.a,6);\t\t\t\t\t\\\n} while (0)\n\n#define gsSPSetLights5(name)\t\t\t\t\t\t\\\n\tgsSPNumLights(NUMLIGHTS_5),\t\t\t\t\t\\\n\tgsSPLight(&name.l[0],1),\t\t\t\t\t\\\n\tgsSPLight(&name.l[1],2),\t\t\t\t\t\\\n\tgsSPLight(&name.l[2],3),\t\t\t\t\t\\\n\tgsSPLight(&name.l[3],4),\t\t\t\t\t\\\n\tgsSPLight(&name.l[4],5),\t\t\t\t\t\\\n\tgsSPLight(&name.a,6)\n\n#define gSPSetLights6(pkt,name)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgSPNumLights(pkt,NUMLIGHTS_6);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[0],1);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[1],2);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[2],3);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[3],4);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[4],5);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[5],6);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.a,7);\t\t\t\t\t\\\n} while (0)\n\n#define gsSPSetLights6(name)\t\t\t\t\t\t\\\n\tgsSPNumLights(NUMLIGHTS_6),\t\t\t\t\t\\\n\tgsSPLight(&name.l[0],1),\t\t\t\t\t\\\n\tgsSPLight(&name.l[1],2),\t\t\t\t\t\\\n\tgsSPLight(&name.l[2],3),\t\t\t\t\t\\\n\tgsSPLight(&name.l[3],4),\t\t\t\t\t\\\n\tgsSPLight(&name.l[4],5),\t\t\t\t\t\\\n\tgsSPLight(&name.l[5],6),\t\t\t\t\t\\\n\tgsSPLight(&name.a,7)\n\n#define gSPSetLights7(pkt,name)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgSPNumLights(pkt,NUMLIGHTS_7);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[0],1);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[1],2);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[2],3);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[3],4);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[4],5);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[5],6);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.l[6],7);\t\t\t\t\t\\\n\tgSPLight(pkt,&name.a,8);\t\t\t\t\t\\\n} while (0)\n\n#define gsSPSetLights7(name)\t\t\t\t\t\t\\\n\tgsSPNumLights(NUMLIGHTS_7),\t\t\t\t\t\\\n\tgsSPLight(&name.l[0],1),\t\t\t\t\t\\\n\tgsSPLight(&name.l[1],2),\t\t\t\t\t\\\n\tgsSPLight(&name.l[2],3),\t\t\t\t\t\\\n\tgsSPLight(&name.l[3],4),\t\t\t\t\t\\\n\tgsSPLight(&name.l[4],5),\t\t\t\t\t\\\n\tgsSPLight(&name.l[5],6),\t\t\t\t\t\\\n\tgsSPLight(&name.l[6],7),\t\t\t\t\t\\\n\tgsSPLight(&name.a,8)\n\n/*\n * Reflection/Hiliting Macros\n */\n#ifdef\tF3DEX_GBI_2\n# define gSPLookAtX(pkt, l)\t\\\n\t gDma2p((pkt),G_MOVEMEM,(l),sizeof(Light),G_MV_LIGHT,G_MVO_LOOKATX)\n# define gsSPLookAtX(l)\t\t\\\n\t gsDma2p(     G_MOVEMEM,(l),sizeof(Light),G_MV_LIGHT,G_MVO_LOOKATX)\n# define gSPLookAtY(pkt, l)\t\\\n\t gDma2p((pkt),G_MOVEMEM,(l),sizeof(Light),G_MV_LIGHT,G_MVO_LOOKATY)\n# define gsSPLookAtY(l)\t\t\\\n\t gsDma2p(     G_MOVEMEM,(l),sizeof(Light),G_MV_LIGHT,G_MVO_LOOKATY)\n#else\t/* F3DEX_GBI_2 */\n# define gSPLookAtX(pkt, l)\t\\\n\t gDma1p(pkt, G_MOVEMEM, l, sizeof(Light),G_MV_LOOKATX)\n# define gsSPLookAtX(l)\t\t\\\n\t gsDma1p(    G_MOVEMEM, l, sizeof(Light),G_MV_LOOKATX)\n# define gSPLookAtY(pkt, l)\t\\\n\t gDma1p(pkt, G_MOVEMEM, l, sizeof(Light),G_MV_LOOKATY)\n# define gsSPLookAtY(l)\t\t\\\n\t gsDma1p(    G_MOVEMEM, l, sizeof(Light),G_MV_LOOKATY)\n#endif\t/* F3DEX_GBI_2 */\n\n#define gSPLookAt(pkt, la)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgSPLookAtX(pkt,la);\t\t\t\t\t\t\\\n\tgSPLookAtY(pkt,(char *)(la)+16);\t\t\t\t\\\n} while (0)\n#define gsSPLookAt(la)\t\t\t\t\t\t\t\\\n\tgsSPLookAtX(la),\t\t\t\t\t\t\\\n\tgsSPLookAtY((char *)(la)+16)\n\n#define gDPSetHilite1Tile(pkt, tile, hilite, width, height)\t\t\\\n\tgDPSetTileSize(pkt, tile, (hilite)->h.x1 & 0xfff, (hilite)->h.y1 & 0xfff, \t\\\n\t\t((((width)-1)*4)+(hilite)->h.x1) & 0xfff, ((((height)-1)*4)+(hilite)->h.y1) & 0xfff)\n\n#define gDPSetHilite2Tile(pkt, tile, hilite, width, height)\t\t\\\n\tgDPSetTileSize(pkt, tile, (hilite)->h.x2 & 0xfff, (hilite)->h.y2 & 0xfff, \t\\\n\t\t((((width)-1)*4)+(hilite)->h.x2) & 0xfff, ((((height)-1)*4)+(hilite)->h.y2) & 0xfff)\n\n/*\n * FOG macros\n * fm = z multiplier\n * fo = z offset\n * FOG FORMULA:    alpha(fog) = (eyespace z) * fm  + fo  CLAMPED 0 to 255\n *   note: (eyespace z) ranges -1 to 1\n *\n * Alternate method of setting fog:\n * min, max: range 0 to 1000: 0=nearplane, 1000=farplane\n * min is where fog begins (usually less than max and often 0)\n * max is where fog is thickest (usually 1000)\n * \n */\n#define gSPFogFactor(pkt, fm, fo)\t\t\t\t\\\n        gMoveWd(pkt, G_MW_FOG, G_MWO_FOG, \t\t\t\\\n\t\t(_SHIFTL(fm,16,16) | _SHIFTL(fo,0,16)))\n\n#define gsSPFogFactor(fm, fo)\t\t\t\t\t\\\n        gsMoveWd(G_MW_FOG, G_MWO_FOG, \t\t\t\t\\\n\t\t(_SHIFTL(fm,16,16) | _SHIFTL(fo,0,16)))\n\n#define gSPFogPosition(pkt, min, max)\t\t\t\t\\\n\tgMoveWd(pkt, G_MW_FOG, G_MWO_FOG, \t\t\t\\\n\t\t(_SHIFTL((128000/((max)-(min))),16,16) |\t\t\\\n\t\t_SHIFTL(((500-(min))*256/((max)-(min))),0,16)))\n\n#define gsSPFogPosition(min, max)\t\t\t\t\\\n\tgsMoveWd(G_MW_FOG, G_MWO_FOG, \t\t\t\t\\\n\t\t(_SHIFTL((128000/((max)-(min))),16,16) |\t\t\\\n\t\t_SHIFTL(((500-(min))*256/((max)-(min))),0,16)))\n\n#ifdef\tF3DEX_GBI_2\n/*\n * Macros to turn texture on/off\n */\n# define gSPTexture(pkt, s, t, level, tile, on)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(G_TEXTURE,24,8) | \t\t\t\\\n\t\t\t_SHIFTL(BOWTIE_VAL,16,8) |\t\t\t\\\n\t\t\t_SHIFTL((level),11,3) | _SHIFTL((tile),8,3) |\t\\\n\t\t\t_SHIFTL((on),1,7));\t\t\t\t\\\n\t_g->words.w1 = (_SHIFTL((s),16,16) | _SHIFTL((t),0,16));\t\\\n} while (0)\n# define gsSPTexture(s, t, level, tile, on)\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t(_SHIFTL(G_TEXTURE,24,8) | _SHIFTL(BOWTIE_VAL,16,8) |\t\t\\\n\t _SHIFTL((level),11,3) | _SHIFTL((tile),8,3) | _SHIFTL((on),1,7)),\\\n        (_SHIFTL((s),16,16) | _SHIFTL((t),0,16))\t\t\t\\\n}}\n/* \n * Different version of SPTexture macro, has an additional parameter\n * which is currently reserved in the microcode.\n */\n# define gSPTextureL(pkt, s, t, level, xparam, tile, on)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(G_TEXTURE,24,8) | \t\t\t\\\n\t\t\t_SHIFTL((xparam),16,8) | \t\t\t\\\n\t\t\t_SHIFTL((level),11,3) | _SHIFTL((tile),8,3) |\t\\\n\t\t\t_SHIFTL((on),1,7));\t\t\t\t\\\n\t_g->words.w1 = (_SHIFTL((s),16,16) | _SHIFTL((t),0,16));\t\\\n} while (0)\n# define gsSPTextureL(s, t, level, xparam, tile, on)\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t(_SHIFTL(G_TEXTURE,24,8) | _SHIFTL((xparam),16,8) |\t\t\\\n\t _SHIFTL((level),11,3) | _SHIFTL((tile),8,3) | _SHIFTL((on),1,7)),\\\n        (_SHIFTL((s),16,16) | _SHIFTL((t),0,16))\t\t\t\\\n}}\n#else\n/*\n * Macros to turn texture on/off\n */\n# define gSPTexture(pkt, s, t, level, tile, on)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(G_TEXTURE,24,8)|_SHIFTL(BOWTIE_VAL,16,8)|\\\n\t\t\t_SHIFTL((level),11,3)|_SHIFTL((tile),8,3)|\t\\\n\t\t\t_SHIFTL((on),0,8));\t\t\t\t\\\n\t_g->words.w1 = (_SHIFTL((s),16,16)|_SHIFTL((t),0,16));\t\t\\\n} while (0)\n# define gsSPTexture(s, t, level, tile, on)\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t(_SHIFTL(G_TEXTURE,24,8)|_SHIFTL(BOWTIE_VAL,16,8)|\t\t\\\n\t _SHIFTL((level),11,3)|_SHIFTL((tile),8,3)|_SHIFTL((on),0,8)),\t\\\n        (_SHIFTL((s),16,16)|_SHIFTL((t),0,16))\t\t\t\t\\\n}}\n/* \n * Different version of SPTexture macro, has an additional parameter\n * which is currently reserved in the microcode.\n */\n# define gSPTextureL(pkt, s, t, level, xparam, tile, on)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(G_TEXTURE,24,8)|_SHIFTL((xparam),16,8)|\t\\\n\t\t\t_SHIFTL((level),11,3)|_SHIFTL((tile),8,3)|\t\\\n\t\t\t_SHIFTL((on),0,8));\t\t\t\t\\\n\t_g->words.w1 = (_SHIFTL((s),16,16)|_SHIFTL((t),0,16));\t\t\\\n} while (0)\n# define gsSPTextureL(s, t, level, xparam, tile, on)\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t(_SHIFTL(G_TEXTURE,24,8)|_SHIFTL((xparam),16,8)|\t\t\\\n\t _SHIFTL((level),11,3)|_SHIFTL((tile),8,3)|_SHIFTL((on),0,8)),\t\\\n        (_SHIFTL((s),16,16)|_SHIFTL((t),0,16))\t\t\t\t\\\n}}\n#endif\n\n#define gSPPerspNormalize(pkt, s)\tgMoveWd(pkt, G_MW_PERSPNORM, 0, (s))\n#define gsSPPerspNormalize(s)\t\tgsMoveWd(    G_MW_PERSPNORM, 0, (s))\n\n#ifdef\tF3DEX_GBI_2\n# define gSPPopMatrixN(pkt, n, num)\tgDma2p((pkt),G_POPMTX,(num)*64,64,2,0)\n# define gsSPPopMatrixN(n, num)\t\tgsDma2p(     G_POPMTX,(num)*64,64,2,0)\n# define gSPPopMatrix(pkt, n)\t\tgSPPopMatrixN((pkt), (n), 1)\n# define gsSPPopMatrix(n)\t\tgsSPPopMatrixN(      (n), 1)\n#else\t/* F3DEX_GBI_2 */\n# define gSPPopMatrix(pkt, n)\t\tgImmp1(pkt, G_POPMTX, n)\n# define gsSPPopMatrix(n)\t\tgsImmp1(    G_POPMTX, n)\n#endif\t/* F3DEX_GBI_2 */\n\n#define gSPEndDisplayList(pkt)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_ENDDL, 24, 8);\t\t\t\t\\\n\t_g->words.w1 = 0;\t\t\t\t\t\t\\\n} while (0)\n\n#define gsSPEndDisplayList()\t\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_ENDDL, 24, 8), 0\t\t\t\t\t\\\n}}\n\n#ifdef\tF3DEX_GBI_2\n/*\n *\tOne gSPGeometryMode(pkt,c,s) GBI is equal to these two GBIs.\n *\n *\t\tgSPClearGeometryMode(pkt,c)\n *\t\tgSPSetGeometryMode(pkt,s)\n *\n *\tgSPLoadGeometryMode(pkt, word) sets GeometryMode directly.\n */\n#define\tgSPGeometryMode(pkt, c, s)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_GEOMETRYMODE,24,8)|_SHIFTL(~(u32)(c),0,24);\\\n\t_g->words.w1 = (u32)(s);\t\t\t\t\t\\\n} while (0)\n\n#define\tgsSPGeometryMode(c, s)\t\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t(_SHIFTL(G_GEOMETRYMODE,24,8)|_SHIFTL(~(u32)(c),0,24)),(u32)(s)\t\\\n}}\n#define\tgSPSetGeometryMode(pkt, word)\tgSPGeometryMode((pkt),0,(word))\n#define\tgsSPSetGeometryMode(word)\tgsSPGeometryMode(0,(word))\n#define\tgSPClearGeometryMode(pkt, word)\tgSPGeometryMode((pkt),(word),0)\n#define\tgsSPClearGeometryMode(word)\tgsSPGeometryMode((word),0)\n#define\tgSPLoadGeometryMode(pkt, word)\tgSPGeometryMode((pkt),-1,(word))\n#define\tgsSPLoadGeometryMode(word)\tgsSPGeometryMode(-1,(word))\n\n#else\t/* F3DEX_GBI_2 */\n#define\tgSPSetGeometryMode(pkt, word)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_SETGEOMETRYMODE, 24, 8);\t\t\\\n\t_g->words.w1 = (unsigned int)(word);\t\t\t\t\\\n} while (0)\n\n#define\tgsSPSetGeometryMode(word)\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_SETGEOMETRYMODE, 24, 8), (unsigned int)(word)\t\t\\\n}}\n\n#define\tgSPClearGeometryMode(pkt, word)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_CLEARGEOMETRYMODE, 24, 8);\t\t\\\n\t_g->words.w1 = (unsigned int)(word);\t\t\t\t\\\n} while (0)\n\n#define\tgsSPClearGeometryMode(word)\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_CLEARGEOMETRYMODE, 24, 8), (unsigned int)(word)\t\\\n}}\n#endif\t/* F3DEX_GBI_2 */\n\n#ifdef\tF3DEX_GBI_2\n#define\tgSPSetOtherMode(pkt, cmd, sft, len, data)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(cmd,24,8)|_SHIFTL(32-(sft)-(len),8,8)|\t\\\n\t\t\t_SHIFTL((len)-1,0,8));\t\t\t\t\\\n\t_g->words.w1 = (unsigned int)(data);\t\t\t\t\\\n} while (0)\n\n#define\tgsSPSetOtherMode(cmd, sft, len, data)\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(cmd,24,8)|_SHIFTL(32-(sft)-(len),8,8)|_SHIFTL((len)-1,0,8), \\\n\t(unsigned int)(data)\t\t\t\t\t\t\\\n}}\n#else\n#define\tgSPSetOtherMode(pkt, cmd, sft, len, data)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(cmd, 24, 8) | _SHIFTL(sft, 8, 8) |\t\\\n\t\t\t_SHIFTL(len, 0, 8));\t\t\t\t\\\n\t_g->words.w1 = (unsigned int)(data);\t\t\t\t\\\n} while (0)\n\n#define\tgsSPSetOtherMode(cmd, sft, len, data)\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(cmd, 24, 8) | _SHIFTL(sft, 8, 8) | _SHIFTL(len, 0, 8),\t\\\n\t(unsigned int)(data)\t\t\t\t\t\t\\\n}}\n#endif\n\n/*\n * RDP setothermode register commands - register shadowed in RSP\n */\n#define\tgDPPipelineMode(pkt, mode)\t\\\n\tgSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_PIPELINE, 1, mode)\n#define\tgsDPPipelineMode(mode)\t\t\\\n\tgsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_PIPELINE, 1, mode)\n\n#define\tgDPSetCycleType(pkt, type)\t\\\n\tgSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_CYCLETYPE, 2, type)\n#define\tgsDPSetCycleType(type)\t\t\\\n\tgsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_CYCLETYPE, 2, type)\n\n#define\tgDPSetTexturePersp(pkt, type)\t\\\n\tgSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_TEXTPERSP, 1, type)\n#define\tgsDPSetTexturePersp(type)\t\t\\\n\tgsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_TEXTPERSP, 1, type)\n\n#define\tgDPSetTextureDetail(pkt, type)\t\\\n\tgSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_TEXTDETAIL, 2, type)\n#define\tgsDPSetTextureDetail(type)\t\t\\\n\tgsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_TEXTDETAIL, 2, type)\n\n#define\tgDPSetTextureLOD(pkt, type)\t\\\n\tgSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_TEXTLOD, 1, type)\n#define\tgsDPSetTextureLOD(type)\t\t\\\n\tgsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_TEXTLOD, 1, type)\n\n#define\tgDPSetTextureLUT(pkt, type)\t\\\n\tgSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_TEXTLUT, 2, type)\n#define\tgsDPSetTextureLUT(type)\t\t\\\n\tgsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_TEXTLUT, 2, type)\n\n#define\tgDPSetTextureFilter(pkt, type)\t\\\n\tgSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_TEXTFILT, 2, type)\n#define\tgsDPSetTextureFilter(type)\t\t\\\n\tgsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_TEXTFILT, 2, type)\n\n#define\tgDPSetTextureConvert(pkt, type)\t\\\n\tgSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_TEXTCONV, 3, type)\n#define\tgsDPSetTextureConvert(type)\t\t\\\n\tgsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_TEXTCONV, 3, type)\n\n#define\tgDPSetCombineKey(pkt, type)\t\\\n\tgSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_COMBKEY, 1, type)\n#define\tgsDPSetCombineKey(type)\t\t\\\n\tgsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_COMBKEY, 1, type)\n\n#ifndef _HW_VERSION_1\n#define\tgDPSetColorDither(pkt, mode)\t\\\n\tgSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_RGBDITHER, 2, mode)\n#define\tgsDPSetColorDither(mode)\t\t\\\n\tgsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_RGBDITHER, 2, mode)\n#else\n#define gDPSetColorDither(pkt, mode)    \\\n\tgSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_COLORDITHER, 1, mode)\n#define gsDPSetColorDither(mode)                \\\n\tgsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_COLORDITHER, 1, mode)\n#endif\n\n#ifndef _HW_VERSION_1\n#define\tgDPSetAlphaDither(pkt, mode)\t\\\n\tgSPSetOtherMode(pkt, G_SETOTHERMODE_H, G_MDSFT_ALPHADITHER, 2, mode)\n#define\tgsDPSetAlphaDither(mode)\t\t\\\n\tgsSPSetOtherMode(G_SETOTHERMODE_H, G_MDSFT_ALPHADITHER, 2, mode)\n#endif\n\n/* 'blendmask' is not supported anymore. \n * The bits are reserved for future use.\n * Fri May 26 13:45:55 PDT 1995\n */\n#define\tgDPSetBlendMask(pkt, mask)      gDPNoOp(pkt)\n#define\tgsDPSetBlendMask(mask)\t\tgsDPNoOp()\n\n#define\tgDPSetAlphaCompare(pkt, type)\t\\\n\tgSPSetOtherMode(pkt, G_SETOTHERMODE_L, G_MDSFT_ALPHACOMPARE, 2, type)\n#define\tgsDPSetAlphaCompare(type)\t\t\\\n\tgsSPSetOtherMode(G_SETOTHERMODE_L, G_MDSFT_ALPHACOMPARE, 2, type)\n\n#define\tgDPSetDepthSource(pkt, src)\t\\\n\tgSPSetOtherMode(pkt, G_SETOTHERMODE_L, G_MDSFT_ZSRCSEL, 1, src)\n#define\tgsDPSetDepthSource(src)\t\\\n\tgsSPSetOtherMode(G_SETOTHERMODE_L, G_MDSFT_ZSRCSEL, 1, src)\n\n#define\tgDPSetRenderMode(pkt, c0, c1)\t\\\n\tgSPSetOtherMode(pkt, G_SETOTHERMODE_L, G_MDSFT_RENDERMODE, 29, \t\\\n\t\t\t(c0) | (c1))\n#define\tgsDPSetRenderMode(c0, c1)\t\\\n\tgsSPSetOtherMode(G_SETOTHERMODE_L, G_MDSFT_RENDERMODE, 29, \t\\\n\t\t\t (c0) | (c1))\n\n#define\tgSetImage(pkt, cmd, fmt, siz, width, i)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(cmd, 24, 8) | _SHIFTL(fmt, 21, 3) |\t\\\n\t\t       _SHIFTL(siz, 19, 2) | _SHIFTL((width)-1, 0, 12);\t\\\n\t_g->words.w1 = (unsigned int)(i);\t\t\t\t\\\n} while (0)\n\n#define\tgsSetImage(cmd, fmt, siz, width, i)\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(cmd, 24, 8) | _SHIFTL(fmt, 21, 3) |\t\t\t\\\n\t_SHIFTL(siz, 19, 2) | _SHIFTL((width)-1, 0, 12),\t\t\\\n\t(unsigned int)(i)\t\t\t\t\t\t\\\n}}\n\n#define\tgDPSetColorImage(pkt, f, s, w, i)\tgSetImage(pkt, G_SETCIMG, f, s, w, i)\n#define\tgsDPSetColorImage(f, s, w, i)\t\tgsSetImage(G_SETCIMG, f, s, w, i)\n\n\n/* use these for new code */\n#define\tgDPSetDepthImage(pkt, i)\tgSetImage(pkt, G_SETZIMG, 0, 0, 1, i)\n#define\tgsDPSetDepthImage(i)\t\tgsSetImage(G_SETZIMG, 0, 0, 1, i)\n/* kept for compatibility */\n#define\tgDPSetMaskImage(pkt, i)\t\tgDPSetDepthImage(pkt, i)\n#define\tgsDPSetMaskImage(i)\t\t\tgsDPSetDepthImage(i)\n\n#define\tgDPSetTextureImage(pkt, f, s, w, i)\tgSetImage(pkt, G_SETTIMG, f, s, w, i)\n#define\tgsDPSetTextureImage(f, s, w, i)\tgsSetImage(G_SETTIMG, f, s, w, i)\n\n/*\n * RDP macros\n */\n\n#define\tgDPSetCombine(pkt, muxs0, muxs1)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_SETCOMBINE, 24, 8) | _SHIFTL(muxs0, 0, 24);\\\n\t_g->words.w1 = (unsigned int)(muxs1);\t\t\t\t\\\n} while (0)\n\n#define\tgsDPSetCombine(muxs0, muxs1)\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_SETCOMBINE, 24, 8) | _SHIFTL(muxs0, 0, 24),\t\t\\\n\t(unsigned int)(muxs1)\t\t\t\t\t\t\\\n}}\n\n#define\tGCCc0w0(saRGB0, mRGB0, saA0, mA0)\t\t\t\t\\\n\t\t(_SHIFTL((saRGB0), 20, 4) | _SHIFTL((mRGB0), 15, 5) | \t\\\n\t\t _SHIFTL((saA0), 12, 3) | _SHIFTL((mA0), 9, 3))\n\n#define\tGCCc1w0(saRGB1, mRGB1)\t\t\t\t\t\t\\\n\t\t(_SHIFTL((saRGB1), 5, 4) | _SHIFTL((mRGB1), 0, 5))\n\n#define GCCc0w1(sbRGB0, aRGB0, sbA0, aA0)\t\t\t\t\\\n                (_SHIFTL((sbRGB0), 28, 4) | _SHIFTL((aRGB0), 15, 3) |\t\\\n\t\t _SHIFTL((sbA0), 12, 3) | _SHIFTL((aA0), 9, 3))\n\n#define\tGCCc1w1(sbRGB1, saA1, mA1, aRGB1, sbA1, aA1)\t\t\t\\\n\t\t(_SHIFTL((sbRGB1), 24, 4) | _SHIFTL((saA1), 21, 3) |\t\\\n\t\t _SHIFTL((mA1), 18, 3) | _SHIFTL((aRGB1), 6, 3) |\t\\\n\t\t _SHIFTL((sbA1), 3, 3) | _SHIFTL((aA1), 0, 3))\n\n#define\tgDPSetCombineLERP(pkt, a0, b0, c0, d0, Aa0, Ab0, Ac0, Ad0,\t\\\n\t\ta1, b1, c1, d1,\tAa1, Ab1, Ac1, Ad1)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 =\t_SHIFTL(G_SETCOMBINE, 24, 8) |\t\t\t\\\n\t\t\t_SHIFTL(GCCc0w0(G_CCMUX_##a0, G_CCMUX_##c0,\t\\\n\t\t\t\t       G_ACMUX_##Aa0, G_ACMUX_##Ac0) |\t\\\n\t\t\t       GCCc1w0(G_CCMUX_##a1, G_CCMUX_##c1), \t\\\n\t\t\t       0, 24);\t\t\t\t\t\\\n\t_g->words.w1 =\t(unsigned int)(GCCc0w1(G_CCMUX_##b0, \t\t\\\n\t\t\t\t\t       G_CCMUX_##d0,\t\t\\\n\t\t\t\t\t       G_ACMUX_##Ab0, \t\t\\\n\t\t\t\t\t       G_ACMUX_##Ad0) |\t\t\\\n\t\t\t\t       GCCc1w1(G_CCMUX_##b1, \t\t\\\n\t\t\t\t\t       G_ACMUX_##Aa1,\t\t\\\n\t\t\t\t\t       G_ACMUX_##Ac1, \t\t\\\n\t\t\t\t\t       G_CCMUX_##d1,\t\t\\\n\t\t\t\t\t       G_ACMUX_##Ab1, \t\t\\\n\t\t\t\t\t       G_ACMUX_##Ad1));\t\t\\\n} while (0)\n\n#define\tgsDPSetCombineLERP(a0, b0, c0, d0, Aa0, Ab0, Ac0, Ad0,\t\t\\\n\t\ta1, b1, c1, d1,\tAa1, Ab1, Ac1, Ad1)\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_SETCOMBINE, 24, 8) |\t\t\t\t\t\\\n\t_SHIFTL(GCCc0w0(G_CCMUX_##a0, G_CCMUX_##c0,\t\t\t\\\n\t\t       G_ACMUX_##Aa0, G_ACMUX_##Ac0) |\t\t\t\\\n\t       GCCc1w0(G_CCMUX_##a1, G_CCMUX_##c1), 0, 24),\t\t\\\n\t(unsigned int)(GCCc0w1(G_CCMUX_##b0, G_CCMUX_##d0,\t\t\\\n\t\t\t       G_ACMUX_##Ab0, G_ACMUX_##Ad0) |\t\t\\\n\t\t       GCCc1w1(G_CCMUX_##b1, G_ACMUX_##Aa1,\t\t\\\n\t\t\t       G_ACMUX_##Ac1, G_CCMUX_##d1,\t\t\\\n\t\t\t       G_ACMUX_##Ab1, G_ACMUX_##Ad1))\t\t\\\n}}\n\n/*\n * SetCombineMode macros are NOT redunant. It allow the C preprocessor\n * to substitute single parameter which includes commas in the token and\n * rescan for higher parameter count macro substitution.\n *\n * eg.\tgsDPSetCombineMode(G_CC_MODULATE, G_CC_MODULATE) turns into\n *\tgsDPSetCombineLERP(TEXEL0, 0, SHADE, 0, TEXEL0, 0, SHADE, 0,\n *\t\tTEXEL0, 0, SHADE, 0, TEXEL0, 0, SHADE, 0)\n */\n\n#define gDPSetCombineMode(pkt, a, b)\tgDPSetCombineLERP(pkt, a, b)\n#define\tgsDPSetCombineMode(a, b)\tgsDPSetCombineLERP(a, b)\n\n#define\tgDPSetColor(pkt, c, d)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(c, 24, 8);\t\t\t\t\\\n\t_g->words.w1 = (unsigned int)(d);\t\t\t\t\\\n} while (0)\n\n#define\tgsDPSetColor(c, d)\t\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(c, 24, 8), (unsigned int)(d)\t\t\t\t\\\n}}\n\n#define\tDPRGBColor(pkt, cmd, r, g, b, a)\t\t\t\t\\\n            gDPSetColor(pkt, cmd,\t\t\t\t\t\\\n\t\t\t(_SHIFTL(r, 24, 8) | _SHIFTL(g, 16, 8) | \t\\\n\t\t\t _SHIFTL(b, 8, 8) | _SHIFTL(a, 0, 8)))\n#define\tsDPRGBColor(cmd, r, g, b, a)\t\t\t\t\t\\\n\t    gsDPSetColor(cmd,\t\t\t\t\t\t\\\n\t\t\t (_SHIFTL(r, 24, 8) | _SHIFTL(g, 16, 8) | \t\\\n\t\t\t  _SHIFTL(b, 8, 8) | _SHIFTL(a, 0, 8)))\n\n#define\tgDPSetEnvColor(pkt, r, g, b, a)\t\t\t\t\t\\\n            DPRGBColor(pkt, G_SETENVCOLOR, r,g,b,a)\n#define\tgsDPSetEnvColor(r, g, b, a)\t\t\t\t\t\\\n            sDPRGBColor(G_SETENVCOLOR, r,g,b,a)\n#define\tgDPSetBlendColor(pkt, r, g, b, a)\t\t\t\t\\\n            DPRGBColor(pkt, G_SETBLENDCOLOR, r,g,b,a)\n#define\tgsDPSetBlendColor(r, g, b, a)\t\t\t\t\t\\\n            sDPRGBColor(G_SETBLENDCOLOR, r,g,b,a)\n#define\tgDPSetFogColor(pkt, r, g, b, a)\t\t\t\t\t\\\n            DPRGBColor(pkt, G_SETFOGCOLOR, r,g,b,a)\n#define\tgsDPSetFogColor(r, g, b, a)\t\t\t\t\t\\\n            sDPRGBColor(G_SETFOGCOLOR, r,g,b,a)\n#define\tgDPSetFillColor(pkt, d)\t\t\t\t\t\t\\\n            gDPSetColor(pkt, G_SETFILLCOLOR, (d))\n#define\tgsDPSetFillColor(d)\t\t\t\t\t\t\\\n            gsDPSetColor(G_SETFILLCOLOR, (d))\n\n#define\tgDPSetPrimDepth(pkt, z, dz)\t\t\t\t\t\\\n\t\tgDPSetColor(pkt, G_SETPRIMDEPTH, \t\t\t\\\n\t\t\t    _SHIFTL(z, 16, 16) | _SHIFTL(dz, 0, 16))\n#define\tgsDPSetPrimDepth(z, dz)\t\t\t\t\t\t\\\n\t\tgsDPSetColor(G_SETPRIMDEPTH, _SHIFTL(z, 16, 16) | \t\\\n\t\t\t     _SHIFTL(dz, 0, 16))\n\n#define\tgDPSetPrimColor(pkt, m, l, r, g, b, a)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 =\t(_SHIFTL(G_SETPRIMCOLOR, 24, 8) | \t\t\\\n\t\t\t _SHIFTL(m, 8, 8) | _SHIFTL(l, 0, 8));\t\t\\\n\t_g->words.w1 =  (_SHIFTL(r, 24, 8) | _SHIFTL(g, 16, 8) | \t\\\n\t\t\t _SHIFTL(b, 8, 8) | _SHIFTL(a, 0, 8));\t\t\\\n} while (0)\n\n#define\tgsDPSetPrimColor(m, l, r, g, b, a)\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t(_SHIFTL(G_SETPRIMCOLOR, 24, 8) | _SHIFTL(m, 8, 8) |\t\t\\\n\t _SHIFTL(l, 0, 8)),\t\t\t\t\t\t\\\n\t(_SHIFTL(r, 24, 8) | _SHIFTL(g, 16, 8) | _SHIFTL(b, 8, 8) |\t\\\n\t _SHIFTL(a, 0, 8))\t\t\t\t\t\t\\\n}}\n\n/*\n * gDPSetOtherMode (This is for expert user.)\n *\n * This command makes all othermode parameters set.\n * Do not use this command in the same DL with another g*SPSetOtherMode DLs.\n * \n * [Usage]\n *\tgDPSetOtherMode(pkt, modeA, modeB)\n *\n *      'modeA' is described all parameters of GroupA GBI command.\n *      'modeB' is also described all parameters of GroupB GBI command.\n *\n *\tGroupA:\n *\t  gDPPipelineMode, gDPSetCycleType, gSPSetTexturePersp,\n *\t  gDPSetTextureDetail, gDPSetTextureLOD, gDPSetTextureLUT,\n *\t  gDPSetTextureFilter, gDPSetTextureConvert, gDPSetCombineKey,\n *\t  gDPSetColorDither, gDPSetAlphaDither\n *\n *\tGroupB:\n *\t  gDPSetAlphaCompare, gDPSetDepthSource, gDPSetRenderMode\n *\n *\tUse 'OR' operation to get modeA and modeB.\n *\n *\tmodeA = G_PM_* | G_CYC_* | G_TP_* | G_TD_* | G_TL_* | G_TT_* | G_TF_*\n *\t\tG_TC_* | G_CK_*  | G_CD_* | G_AD_*;\n *\n *\tmodeB = G_AC_* | G_ZS_*  | G_RM_* | G_RM_*2;\n */\n#define\tgDPSetOtherMode(pkt, mode0, mode1)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_RDPSETOTHERMODE,24,8)|_SHIFTL(mode0,0,24);\\\n\t_g->words.w1 = (unsigned int)(mode1);\t\t\t\t\\\n} while (0)\n\n#define\tgsDPSetOtherMode(mode0, mode1)\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_RDPSETOTHERMODE,24,8)|_SHIFTL(mode0,0,24),\t\t\\\n\t(unsigned int)(mode1)\t\t\t\t\t\t\\\n}}\n\n/*\n * Texturing macros\n */\n\n/* These are also defined defined above for Sprite Microcode */\n\n#define\tG_TX_LOADTILE\t7\n#define\tG_TX_RENDERTILE\t0\n\n#define\tG_TX_NOMIRROR\t0\n#define\tG_TX_WRAP\t0\n#define\tG_TX_MIRROR\t0x1\n#define\tG_TX_CLAMP\t0x2\n#define\tG_TX_NOMASK\t0\n#define\tG_TX_NOLOD\t0\n\n\n#ifndef MAX\n#define MAX(a, b)\t\t\t\t((a) > (b) ? (a) : (b))\n#endif\n\n#ifndef MIN\n#define MIN(a, b)\t\t\t\t((a) < (b) ? (a) : (b))\n#endif\n/*\n *  Dxt is the inverse of the number of 64-bit words in a line of\n *  the texture being loaded using the load_block command.  If\n *  there are any 1's to the right of the 11th fractional bit,\n *  dxt should be rounded up.  The following macros accomplish\n *  this.  The 4b macros are a special case since 4-bit textures\n *  are loaded as 8-bit textures.  Dxt is fixed point 1.11. RJM\n */\n#define\tG_TX_DXT_FRAC\t11\n\n/*\n *  For RCP 2.0, the maximum number of texels that can be loaded\n *  using a load_block command is 2048.  In order to load the total\n *  4kB of Tmem, change the texel size when loading to be G_IM_SIZ_16b,\n *  then change the tile to the proper texel size after the load.\n *  The g*DPLoadTextureBlock macros already do this, so this change\n *  will be transparent if you use these macros.  If you use\n *  the g*DPLoadBlock macros directly, you will need to handle this\n *  tile manipulation yourself.  RJM.\n */\n#ifdef _HW_VERSION_1\n#define G_TX_LDBLK_MAX_TXL\t4095\n#else\n#define G_TX_LDBLK_MAX_TXL\t2047\n#endif /* _HW_VERSION_1 */\n\n#define TXL2WORDS(txls, b_txl)\tMAX(1, ((txls)*(b_txl)/8))\n#define CALC_DXT(width, b_txl)\t\\\n\t\t(((1 << G_TX_DXT_FRAC) + TXL2WORDS(width, b_txl) - 1) / \\\n\t\t\t\t\tTXL2WORDS(width, b_txl))\n\n#define TXL2WORDS_4b(txls)\tMAX(1, ((txls)/16))\n#define CALC_DXT_4b(width)\t\\\n\t\t(((1 << G_TX_DXT_FRAC) + TXL2WORDS_4b(width) - 1) / \\\n\t\t\t\t\tTXL2WORDS_4b(width))\n\n#define gDPLoadTileGeneric(pkt, c, tile, uls, ult, lrs, lrt)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(c, 24, 8) | _SHIFTL(uls, 12, 12) |\t\\\n\t\t      _SHIFTL(ult, 0, 12);\t\t\t\t\\\n\t_g->words.w1 = _SHIFTL(tile, 24, 3) | _SHIFTL(lrs, 12, 12) |\t\\\n\t\t      _SHIFTL(lrt, 0, 12);\t\t\t\t\\\n} while (0)\n\n#define gsDPLoadTileGeneric(c, tile, uls, ult, lrs, lrt)\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(c, 24, 8) | _SHIFTL(uls, 12, 12) | _SHIFTL(ult, 0, 12),\t\\\n\t_SHIFTL(tile, 24, 3) | _SHIFTL(lrs, 12, 12) | _SHIFTL(lrt, 0, 12)\\\n}}\n\n#define\tgDPSetTileSize(pkt, t, uls, ult, lrs, lrt)\t\t\t\\\n\t\tgDPLoadTileGeneric(pkt, G_SETTILESIZE, t, uls, ult, lrs, lrt)\n#define\tgsDPSetTileSize(t, uls, ult, lrs, lrt)\t\t\t\t\\\n\t\tgsDPLoadTileGeneric(G_SETTILESIZE, t, uls, ult, lrs, lrt)\n#define\tgDPLoadTile(pkt, t, uls, ult, lrs, lrt)\t\t\t\t\\\n\t\tgDPLoadTileGeneric(pkt, G_LOADTILE, t, uls, ult, lrs, lrt)\n#define\tgsDPLoadTile(t, uls, ult, lrs, lrt)\t\t\t\t\\\n\t\tgsDPLoadTileGeneric(G_LOADTILE, t, uls, ult, lrs, lrt)\n\n#define\tgDPSetTile(pkt, fmt, siz, line, tmem, tile, palette, cmt,\t\\\n\t\tmaskt, shiftt, cms, masks, shifts)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_SETTILE, 24, 8) | _SHIFTL(fmt, 21, 3) |\\\n\t\t       _SHIFTL(siz, 19, 2) | _SHIFTL(line, 9, 9) |\t\\\n\t\t       _SHIFTL(tmem, 0, 9);\t\t\t\t\\\n\t_g->words.w1 = _SHIFTL(tile, 24, 3) | _SHIFTL(palette, 20, 4) |\t\\\n\t\t       _SHIFTL(cmt, 18, 2) | _SHIFTL(maskt, 14, 4) |\t\\\n\t\t       _SHIFTL(shiftt, 10, 4) |_SHIFTL(cms, 8, 2) |\t\\\n\t\t       _SHIFTL(masks, 4, 4) | _SHIFTL(shifts, 0, 4);\t\\\n} while (0)\n\n#define\tgsDPSetTile(fmt, siz, line, tmem, tile, palette, cmt,\t\t\\\n\t\tmaskt, shiftt, cms, masks, shifts)\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t(_SHIFTL(G_SETTILE, 24, 8) | _SHIFTL(fmt, 21, 3) | \t\t\\\n\t _SHIFTL(siz, 19, 2) | _SHIFTL(line, 9, 9) | _SHIFTL(tmem, 0, 9)),\\\n        (_SHIFTL(tile, 24, 3) | _SHIFTL(palette, 20, 4) | \t\t\\\n\t _SHIFTL(cmt, 18, 2) | _SHIFTL(maskt, 14, 4) | \t\t\t\\\n\t _SHIFTL(shiftt, 10, 4) | _SHIFTL(cms, 8, 2) | \t\t\t\\\n\t _SHIFTL(masks, 4, 4) | _SHIFTL(shifts, 0, 4))\t\t\t\\\n}}\n\n/*\n *  For RCP 2.0, the maximum number of texels that can be loaded\n *  using a load_block command is 2048.  In order to load the total\n *  4kB of Tmem, change the texel size when loading to be G_IM_SIZ_16b,\n *  then change the tile to the proper texel size after the load.\n *  The g*DPLoadTextureBlock macros already do this, so this change\n *  will be transparent if you use these macros.  If you use\n *  the g*DPLoadBlock macros directly, you will need to handle this\n *  tile manipulation yourself.  RJM.\n */\n#define gDPLoadBlock(pkt, tile, uls, ult, lrs, dxt)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(G_LOADBLOCK, 24, 8) | \t\t\t\\\n\t\t\t_SHIFTL(uls, 12, 12) | _SHIFTL(ult, 0, 12));\t\\\n\t_g->words.w1 = (_SHIFTL(tile, 24, 3) |\t\t\t\t\\\n\t\t\t_SHIFTL((MIN(lrs,G_TX_LDBLK_MAX_TXL)), 12, 12) |\\\n\t\t\t_SHIFTL(dxt, 0, 12));\t\t\t\t\\\n} while (0)\n\n#define gsDPLoadBlock(tile, uls, ult, lrs, dxt)\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t(_SHIFTL(G_LOADBLOCK, 24, 8) | _SHIFTL(uls, 12, 12) | \t\t\\\n\t _SHIFTL(ult, 0, 12)),\t\t\t\t\t\t\\\n\t(_SHIFTL(tile, 24, 3) | \t\t\t\t\t\\\n\t _SHIFTL((MIN(lrs,G_TX_LDBLK_MAX_TXL)), 12, 12) |\t\t\\\n\t _SHIFTL(dxt, 0, 12))\t\t\t\t\t\t\\\n}}\n\n#define\tgDPLoadTLUTCmd(pkt, tile, count)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)pkt;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_LOADTLUT, 24, 8);\t\t\t\\\n\t_g->words.w1 = _SHIFTL((tile), 24, 3) | _SHIFTL((count), 14, 10);\\\n} while (0)\n\n#define\tgsDPLoadTLUTCmd(tile, count)\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_LOADTLUT, 24, 8),\t\t\t\t\t\\\n\t_SHIFTL((tile), 24, 3) | _SHIFTL((count), 14, 10)\t\t\\\n}}\n\n#define\tgDPLoadTextureBlock(pkt, timg, fmt, siz, width, height,\t\t\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, fmt, siz##_LOAD_BLOCK, 1, timg);\t\\\n\tgDPSetTile(pkt, fmt, siz##_LOAD_BLOCK, 0, 0, G_TX_LOADTILE, \t\\\n\t\t0 , cmt, maskt, shiftt, cms, masks, shifts);\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadBlock(pkt, G_TX_LOADTILE, 0, 0, \t\t\t\t\\\n\t\t(((width)*(height) + siz##_INCR) >> siz##_SHIFT) -1,\t\\\n\t\tCALC_DXT(width, siz##_BYTES)); \t\t\t\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, fmt, siz,\t\t\t\t\t\\\n\t\t(((width) * siz##_LINE_BYTES)+7)>>3, 0,\t\t\t\\\n\t\tG_TX_RENDERTILE, pal, cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts);\t\t\t\t\t\t\\\n\tgDPSetTileSize(pkt, G_TX_RENDERTILE, 0, 0,\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n} while (0)\n\n#define\tgDPLoadTextureBlockYuv(pkt, timg, fmt, siz, width, height,\t\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, fmt, siz##_LOAD_BLOCK, 1, timg);\t\\\n\tgDPSetTile(pkt, fmt, siz##_LOAD_BLOCK, 0, 0, G_TX_LOADTILE, \t\\\n\t\t0 , cmt, maskt, shiftt, cms, masks, shifts);\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadBlock(pkt, G_TX_LOADTILE, 0, 0, \t\t\t\t\\\n\t\t(((width)*(height) + siz##_INCR) >> siz##_SHIFT) -1,\t\\\n\t\tCALC_DXT(width, siz##_BYTES)); \t\t\t\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, fmt, siz,\t\t\t\t\t\\\n\t\t(((width) * 1)+7)>>3, 0,\t\t\t\t\\\n\t\tG_TX_RENDERTILE, pal, cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts);\t\t\t\t\t\t\\\n\tgDPSetTileSize(pkt, G_TX_RENDERTILE, 0, 0,\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n} while (0)\n\n/* Load fix rww 27jun95 */\n/* The S at the end means odd lines are already word Swapped */\n\n#define\tgDPLoadTextureBlockS(pkt, timg, fmt, siz, width, height,\t\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, fmt, siz##_LOAD_BLOCK, 1, timg);\t\\\n\tgDPSetTile(pkt, fmt, siz##_LOAD_BLOCK, 0, 0, G_TX_LOADTILE, \t\\\n\t\t0 , cmt, maskt,\tshiftt, cms, masks, shifts);\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadBlock(pkt, G_TX_LOADTILE, 0, 0, \t\t\t\t\\\n\t\t(((width)*(height) + siz##_INCR) >> siz##_SHIFT)-1,0);\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, fmt, siz,\t\t\t\t\t\\\n\t\t(((width) * siz##_LINE_BYTES)+7)>>3, 0,\t\t\t\\\n\t\tG_TX_RENDERTILE, pal, cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts);\t\t\t\t\t\t\\\n\tgDPSetTileSize(pkt, G_TX_RENDERTILE, 0, 0,\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n} while (0)\n\n/* \n *  Allow tmem address and render tile to be specified.\n *  The S at the end means odd lines are already word Swapped \n */\n#define\tgDPLoadMultiBlockS(pkt, timg, tmem, rtile, fmt, siz, width, \t\\\n\t\t   height, pal, cms, cmt, masks, maskt, shifts, shiftt)\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, fmt, siz##_LOAD_BLOCK, 1, timg);\t\\\n\tgDPSetTile(pkt, fmt, siz##_LOAD_BLOCK, 0, tmem, G_TX_LOADTILE, \t\\\n\t\t0 , cmt, maskt,\tshiftt, cms, masks, shifts);\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadBlock(pkt, G_TX_LOADTILE, 0, 0, \t\t\t\t\\\n\t\t(((width)*(height) + siz##_INCR) >> siz##_SHIFT)-1,0);\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, fmt, siz,\t\t\t\t\t\\\n\t\t(((width) * siz##_LINE_BYTES)+7)>>3, tmem,\t\t\\\n\t\trtile, pal, cmt, maskt, shiftt, cms, masks,\t\t\\\n\t\tshifts);\t\t\t\t\t\t\\\n\tgDPSetTileSize(pkt, rtile, 0, 0,\t\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n} while (0)\n\n\n#define\tgDPLoadTextureBlockYuvS(pkt, timg, fmt, siz, width, height,\t\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, fmt, siz##_LOAD_BLOCK, 1, timg);\t\\\n\tgDPSetTile(pkt, fmt, siz##_LOAD_BLOCK, 0, 0, G_TX_LOADTILE, \t\\\n\t\t0 , cmt, maskt,\tshiftt, cms, masks, shifts);\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadBlock(pkt, G_TX_LOADTILE, 0, 0, \t\t\t\t\\\n\t\t(((width)*(height) + siz##_INCR) >> siz##_SHIFT)-1,0);\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, fmt, siz,\t\t\t\t\t\\\n\t\t(((width) * 1)+7)>>3, 0,\t\t\t\t\\\n\t\tG_TX_RENDERTILE, pal, cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts);\t\t\t\t\t\t\\\n\tgDPSetTileSize(pkt, G_TX_RENDERTILE, 0, 0,\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n} while (0)\n\n/*\n *  allows tmem address to be specified\n */\n#define\t_gDPLoadTextureBlock(pkt, timg, tmem, fmt, siz, width, height,\t\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, fmt, siz##_LOAD_BLOCK, 1, timg);\t\\\n\tgDPSetTile(pkt, fmt, siz##_LOAD_BLOCK, 0, tmem, G_TX_LOADTILE,  \\\n\t\t0, cmt, maskt, shiftt, cms, masks, shifts);\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadBlock(pkt, G_TX_LOADTILE, 0, 0, \t\t\t\t\\\n\t\t(((width)*(height) + siz##_INCR) >> siz##_SHIFT)-1,\t\\\n\t\tCALC_DXT(width, siz##_BYTES)); \t\t\t\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, fmt, siz, (((width) * siz##_LINE_BYTES)+7)>>3,\t\\\n\t\ttmem, G_TX_RENDERTILE, pal, cmt,\t\t\t\\\n\t\tmaskt, shiftt, cms, masks, shifts);\t\t\t\\\n\tgDPSetTileSize(pkt, G_TX_RENDERTILE, 0, 0,\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n} while (0)\n\n/*\n *  allows tmem address and render tile to be specified\n */\n#define\t_gDPLoadTextureBlockTile(pkt, timg, tmem, rtile, fmt, siz, width,  \\\n\t\theight, pal, cms, cmt, masks, maskt, shifts, shiftt)\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, fmt, siz##_LOAD_BLOCK, 1, timg);\t\\\n\tgDPSetTile(pkt, fmt, siz##_LOAD_BLOCK, 0, tmem, G_TX_LOADTILE, 0,\\\n\t\tcmt, maskt, shiftt, cms, masks, shifts);\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadBlock(pkt, G_TX_LOADTILE, 0, 0, \t\t\t\t\\\n\t\t(((width)*(height) + siz##_INCR) >> siz##_SHIFT)-1,\t\\\n\t\tCALC_DXT(width, siz##_BYTES)); \t\t\t\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, fmt, siz, (((width) * siz##_LINE_BYTES)+7)>>3,\t\\\n\t\ttmem, rtile, pal, cmt,\t\t\t\t\t\\\n\t\tmaskt, shiftt, cms, masks, shifts);\t\t\t\\\n\tgDPSetTileSize(pkt, rtile, 0, 0,\t\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n} while (0)\n\n/*\n *  allows tmem address and render tile to be specified\n */\n#define\tgDPLoadMultiBlock(pkt, timg, tmem, rtile, fmt, siz, width,  \t\\\n\t\theight, pal, cms, cmt, masks, maskt, shifts, shiftt)\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, fmt, siz##_LOAD_BLOCK, 1, timg);\t\\\n\tgDPSetTile(pkt, fmt, siz##_LOAD_BLOCK, 0, tmem, G_TX_LOADTILE, 0,\\\n\t\tcmt, maskt, shiftt, cms, masks, shifts);\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadBlock(pkt, G_TX_LOADTILE, 0, 0, \t\t\t\t\\\n\t\t(((width)*(height) + siz##_INCR) >> siz##_SHIFT)-1,\t\\\n\t\tCALC_DXT(width, siz##_BYTES)); \t\t\t\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, fmt, siz, (((width) * siz##_LINE_BYTES)+7)>>3,\t\\\n\t\ttmem, rtile, pal, cmt,\t\t\t\t\t\\\n\t\tmaskt, shiftt, cms, masks, shifts);\t\t\t\\\n\tgDPSetTileSize(pkt, rtile, 0, 0,\t\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n} while (0)\n\n#define\tgsDPLoadTextureBlock(timg, fmt, siz, width, height,\t\t\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(fmt, siz##_LOAD_BLOCK, 1, timg),\t\t\\\n\tgsDPSetTile(fmt, siz##_LOAD_BLOCK, 0, 0, \t\t\t\\\n\t\tG_TX_LOADTILE, \t0 , cmt, maskt,\tshiftt, cms, \t\t\\\n\t\tmasks, shifts),\t\t\t\t\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadBlock(G_TX_LOADTILE, 0, 0, \t\t\t\t\\\n\t\t(((width)*(height) + siz##_INCR) >> siz##_SHIFT)-1,\t\\\n\t\tCALC_DXT(width, siz##_BYTES)), \t\t\t\t\\\n\tgsDPPipeSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(fmt, siz, ((((width) * siz##_LINE_BYTES)+7)>>3), 0,\t\\\n\t\tG_TX_RENDERTILE, pal, cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts),\t\t\t\t\t\t\\\n\tgsDPSetTileSize(G_TX_RENDERTILE, 0, 0,\t\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC)\n\n/* Here is the static form of the pre-swapped texture block loading */\n/* See gDPLoadTextureBlockS() for reference.  Basically, just don't\n   calculate DxT, use 0 */\n\n#define\tgsDPLoadTextureBlockS(timg, fmt, siz, width, height,\t\t\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(fmt, siz##_LOAD_BLOCK, 1, timg),\t\t\\\n\tgsDPSetTile(fmt, siz##_LOAD_BLOCK, 0, 0, G_TX_LOADTILE, 0 , \t\\\n\t\tcmt, maskt,shiftt, cms, masks, shifts),\t\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadBlock(G_TX_LOADTILE, 0, 0, \t\t\t\t\\\n\t\t(((width)*(height) + siz##_INCR) >> siz##_SHIFT)-1, 0 ),\\\n\tgsDPPipeSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(fmt, siz, ((((width) * siz##_LINE_BYTES)+7)>>3), 0,\t\\\n\t\tG_TX_RENDERTILE, pal, cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts),\t\t\t\t\t\t\\\n\tgsDPSetTileSize(G_TX_RENDERTILE, 0, 0,\t\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC)\n\n/*\n *  Allow tmem address to be specified\n */\n#define\t_gsDPLoadTextureBlock(timg, tmem, fmt, siz, width, height,\t\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(fmt, siz##_LOAD_BLOCK, 1, timg),\t\t\\\n\tgsDPSetTile(fmt, siz##_LOAD_BLOCK, 0, tmem, G_TX_LOADTILE, \t\\\n\t\t0 , cmt, maskt,\tshiftt, cms, masks, shifts),\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadBlock(G_TX_LOADTILE, 0, 0, \t\t\t\t\\\n\t\t(((width)*(height) + siz##_INCR) >> siz##_SHIFT)-1,\t\\\n\t\tCALC_DXT(width, siz##_BYTES)), \t\t\t\t\\\n\tgsDPPipeSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(fmt, siz,\t\t\t\t\t\t\\\n\t\t((((width) * siz##_LINE_BYTES)+7)>>3), tmem,\t\t\\\n\t\tG_TX_RENDERTILE, pal, cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts),\t\t\t\t\t\t\\\n\tgsDPSetTileSize(G_TX_RENDERTILE, 0, 0,\t\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC)\n\n\n/*\n *  Allow tmem address and render_tile to be specified\n */\n#define\t_gsDPLoadTextureBlockTile(timg, tmem, rtile, fmt, siz, width,\t\\\n\t\theight, pal, cms, cmt, masks, maskt, shifts, shiftt)\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(fmt, siz##_LOAD_BLOCK, 1, timg),\t\t\\\n\tgsDPSetTile(fmt, siz##_LOAD_BLOCK, 0, tmem, G_TX_LOADTILE, \t\\\n\t\t0 , cmt, maskt,\tshiftt, cms, masks, shifts),\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadBlock(G_TX_LOADTILE, 0, 0, \t\t\t\t\\\n\t\t(((width)*(height) + siz##_INCR) >> siz##_SHIFT)-1,\t\\\n\t\tCALC_DXT(width, siz##_BYTES)), \t\t\t\t\\\n\tgsDPPipeSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(fmt, siz,\t\t\t\t\t\t\\\n\t\t((((width) * siz##_LINE_BYTES)+7)>>3), tmem,\t\t\\\n\t\trtile, pal, cmt, maskt, shiftt, cms, masks,\t\t\\\n\t\tshifts),\t\t\t\t\t\t\\\n\tgsDPSetTileSize(rtile, 0, 0,\t\t\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC)\n\n\n/*\n *  Allow tmem address and render_tile to be specified, useful when loading\n *  mutilple tiles at a time.\n */\n#define\tgsDPLoadMultiBlock(timg, tmem, rtile, fmt, siz, width,\t\t\\\n\t\theight, pal, cms, cmt, masks, maskt, shifts, shiftt)\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(fmt, siz##_LOAD_BLOCK, 1, timg),\t\t\\\n\tgsDPSetTile(fmt, siz##_LOAD_BLOCK, 0, tmem, G_TX_LOADTILE, \t\\\n\t\t0 , cmt, maskt,\tshiftt, cms, masks, shifts),\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadBlock(G_TX_LOADTILE, 0, 0, \t\t\t\t\\\n\t\t(((width)*(height) + siz##_INCR) >> siz##_SHIFT)-1,\t\\\n\t\tCALC_DXT(width, siz##_BYTES)), \t\t\t\t\\\n\tgsDPPipeSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(fmt, siz,\t\t\t\t\t\t\\\n\t\t((((width) * siz##_LINE_BYTES)+7)>>3), tmem,\t\t\\\n\t\trtile, pal, cmt, maskt, shiftt, cms, masks,\t\t\\\n\t\tshifts),\t\t\t\t\t\t\\\n\tgsDPSetTileSize(rtile, 0, 0,\t\t\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC)\n\n/* \n *  Allows tmem and render tile to be specified.  Useful when loading\n *  several tiles at a time.\n *\n *  Here is the static form of the pre-swapped texture block loading\n *  See gDPLoadTextureBlockS() for reference.  Basically, just don't\n *  calculate DxT, use 0 \n */\n\n#define\tgsDPLoadMultiBlockS(timg, tmem, rtile, fmt, siz, width, height,\t\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(fmt, siz##_LOAD_BLOCK, 1, timg),\t\t\\\n\tgsDPSetTile(fmt, siz##_LOAD_BLOCK, 0, tmem, G_TX_LOADTILE, 0 , \t\\\n\t\tcmt, maskt,shiftt, cms, masks, shifts),\t\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadBlock(G_TX_LOADTILE, 0, 0, \t\t\t\t\\\n\t\t(((width)*(height) + siz##_INCR) >> siz##_SHIFT)-1, 0 ),\\\n\tgsDPPipeSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(fmt, siz, ((((width) * siz##_LINE_BYTES)+7)>>3), tmem,\\\n\t\trtile, pal, cmt, maskt, shiftt, cms, masks,\t\t\\\n\t\tshifts),\t\t\t\t\t\t\\\n\tgsDPSetTileSize(rtile, 0, 0,\t\t\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC)\n\n\n#define\tgDPLoadTextureBlock_4b(pkt, timg, fmt, width, height,\t\t\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, fmt, G_IM_SIZ_16b, 1, timg);\t\t\\\n\tgDPSetTile(pkt, fmt, G_IM_SIZ_16b, 0, 0, G_TX_LOADTILE, 0,\t\\\n\t\tcmt, maskt, shiftt, cms, masks, shifts);\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadBlock(pkt, G_TX_LOADTILE, 0, 0,\t\t\t\t\\\n\t\t(((width)*(height)+3)>>2)-1,\t\t\t\t\\\n\t\tCALC_DXT_4b(width)); \t\t\t\t\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, fmt, G_IM_SIZ_4b, ((((width)>>1)+7)>>3), 0,\t\\\n\t\tG_TX_RENDERTILE, pal, cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts);\t\t\t\t\t\t\\\n\tgDPSetTileSize(pkt, G_TX_RENDERTILE, 0, 0,\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n} while (0)\n\n/* Load fix rww 27jun95 */\n/* The S at the end means odd lines are already word Swapped */\n\n#define\tgDPLoadTextureBlock_4bS(pkt, timg, fmt, width, height,\t\t\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, fmt, G_IM_SIZ_16b, 1, timg);\t\t\\\n\tgDPSetTile(pkt, fmt, G_IM_SIZ_16b, 0, 0, G_TX_LOADTILE, 0,\t\\\n\t\tcmt, maskt, shiftt, cms, masks, shifts);\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadBlock(pkt, G_TX_LOADTILE, 0, 0,\t\t\t\t\\\n\t\t(((width)*(height)+3)>>2)-1, 0 );\t\t\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, fmt, G_IM_SIZ_4b, ((((width)>>1)+7)>>3), 0,\t\\\n\t\tG_TX_RENDERTILE, pal, cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts);\t\t\t\t\t\t\\\n\tgDPSetTileSize(pkt, G_TX_RENDERTILE, 0, 0,\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n} while (0)\n\n/*\n *  4-bit load block.  Useful when loading multiple tiles\n */\n#define\tgDPLoadMultiBlock_4b(pkt, timg, tmem, rtile, fmt, width, height,\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, fmt, G_IM_SIZ_16b, 1, timg);\t\t\\\n\tgDPSetTile(pkt, fmt, G_IM_SIZ_16b, 0, tmem, G_TX_LOADTILE, 0,\t\\\n\t\tcmt, maskt, shiftt, cms, masks, shifts);\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadBlock(pkt, G_TX_LOADTILE, 0, 0,\t\t\t\t\\\n\t\t(((width)*(height)+3)>>2)-1,\t\t\t\t\\\n\t\tCALC_DXT_4b(width));\t\t\t\t\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, fmt, G_IM_SIZ_4b, ((((width)>>1)+7)>>3), tmem,\t\\\n\t\trtile, pal, cmt, maskt, shiftt, cms, masks,\t\t\\\n\t\tshifts);\t\t\t\t\t\t\\\n\tgDPSetTileSize(pkt, rtile, 0, 0,\t\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n} while (0)\n\n/*\n *  4-bit load block.  Allows tmem and render tile to be specified.  Useful when  \n *  loading multiple tiles.  The S means odd lines are already word swapped.\n */\n#define\tgDPLoadMultiBlock_4bS(pkt, timg, tmem, rtile, fmt, width, height,\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, fmt, G_IM_SIZ_16b, 1, timg);\t\t\\\n\tgDPSetTile(pkt, fmt, G_IM_SIZ_16b, 0, tmem, G_TX_LOADTILE, 0,\t\\\n\t\tcmt, maskt, shiftt, cms, masks, shifts);\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadBlock(pkt, G_TX_LOADTILE, 0, 0,\t\t\t\t\\\n\t\t(((width)*(height)+3)>>2)-1, 0 );\t\t\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, fmt, G_IM_SIZ_4b, ((((width)>>1)+7)>>3), tmem,\t\\\n\t\trtile, pal, cmt, maskt, shiftt, cms, masks,\t\t\\\n\t\tshifts);\t\t\t\t\t\t\\\n\tgDPSetTileSize(pkt, rtile, 0, 0,\t\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n} while (0)\n\n\n#define\t_gDPLoadTextureBlock_4b(pkt, timg, tmem, fmt, width, height,\t\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, fmt, G_IM_SIZ_16b, 1, timg);\t\t\\\n\tgDPSetTile(pkt, fmt, G_IM_SIZ_16b, 0, tmem, G_TX_LOADTILE, 0,\t\\\n\t\tcmt, maskt, shiftt, cms, masks, shifts);\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadBlock(pkt, G_TX_LOADTILE, 0, 0,\t\t\t\t\\\n\t\t(((width)*(height)+3)>>2)-1,\t\t\t\t\\\n\t\tCALC_DXT_4b(width));\t\t\t\t\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, fmt, G_IM_SIZ_4b, ((((width)>>1)+7)>>3), tmem,\t\\\n\t\tG_TX_RENDERTILE, pal, cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts);\t\t\t\t\t\t\\\n\tgDPSetTileSize(pkt, G_TX_RENDERTILE, 0, 0,\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n} while (0)\n\n#define\tgsDPLoadTextureBlock_4b(timg, fmt, width, height,\t\t\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(fmt, G_IM_SIZ_16b, 1, timg),\t\t\\\n\tgsDPSetTile(fmt, G_IM_SIZ_16b, 0, 0, G_TX_LOADTILE, 0 , cmt,\t\\\n\t\tmaskt, shiftt, cms, masks, shifts),\t\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadBlock(G_TX_LOADTILE, 0, 0, (((width)*(height)+3)>>2)-1,\t\\\n\t\tCALC_DXT_4b(width)),\t\t\t\t\t\\\n\tgsDPPipeSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(fmt, G_IM_SIZ_4b, ((((width)>>1)+7)>>3), 0,\t\t\\\n\t\tG_TX_RENDERTILE, pal, cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts),\t\t\t\t\t\t\\\n\tgsDPSetTileSize(G_TX_RENDERTILE, 0, 0,\t\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC)\n\n#define\tgsDPLoadTextureBlock_4bS(timg, fmt, width, height,\t\t\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(fmt, G_IM_SIZ_16b, 1, timg),\t\t\\\n\tgsDPSetTile(fmt, G_IM_SIZ_16b, 0, 0, G_TX_LOADTILE, 0 , cmt,\t\\\n\t\tmaskt, shiftt, cms, masks, shifts),\t\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadBlock(G_TX_LOADTILE, 0, 0, (((width)*(height)+3)>>2)-1,0),\\\n\tgsDPPipeSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(fmt, G_IM_SIZ_4b, ((((width)>>1)+7)>>3), 0,\t\t\\\n\t\tG_TX_RENDERTILE, pal, cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts),\t\t\t\t\t\t\\\n\tgsDPSetTileSize(G_TX_RENDERTILE, 0, 0,\t\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC)\n\n/*\n *  4-bit load block.  Allows tmem address and render tile to be specified.\n *  Useful when loading multiple tiles.\n */\n#define\tgsDPLoadMultiBlock_4b(timg, tmem, rtile, fmt, width, height,\t\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(fmt, G_IM_SIZ_16b, 1, timg),\t\t\\\n\tgsDPSetTile(fmt, G_IM_SIZ_16b, 0, tmem, G_TX_LOADTILE, 0 , cmt,\t\\\n\t\tmaskt, shiftt, cms, masks, shifts),\t\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadBlock(G_TX_LOADTILE, 0, 0, (((width)*(height)+3)>>2)-1,\t\\\n\t\tCALC_DXT_4b(width)), \t\t\t\t\t\\\n\tgsDPPipeSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(fmt, G_IM_SIZ_4b, ((((width)>>1)+7)>>3), tmem,\t\\\n\t\trtile, pal, cmt, maskt, shiftt, cms, masks,\t\t\\\n\t\tshifts),\t\t\t\t\t\t\\\n\tgsDPSetTileSize(rtile, 0, 0,\t\t\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC)\n\n\n/*\n *  4-bit load block.  Allows tmem address and render tile to be specified.\n *  Useful when loading multiple tiles.  S means odd lines are already swapped.\n */\n#define\tgsDPLoadMultiBlock_4bS(timg, tmem, rtile, fmt, width, height,\t\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(fmt, G_IM_SIZ_16b, 1, timg),\t\t\\\n\tgsDPSetTile(fmt, G_IM_SIZ_16b, 0, tmem, G_TX_LOADTILE, 0 , cmt,\t\\\n\t\tmaskt, shiftt, cms, masks, shifts),\t\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadBlock(G_TX_LOADTILE, 0, 0, (((width)*(height)+3)>>2)-1,0),\\\n\tgsDPPipeSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(fmt, G_IM_SIZ_4b, ((((width)>>1)+7)>>3), tmem,\t\\\n\t\trtile, pal, cmt, maskt, shiftt, cms, masks,\t\t\\\n\t\tshifts),\t\t\t\t\t\t\\\n\tgsDPSetTileSize(rtile, 0, 0,\t\t\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC)\n\n\n/*\n *  Allows tmem address to be specified\n */\n#define\t_gsDPLoadTextureBlock_4b(timg, tmem, fmt, width, height,\t\\\n\t\tpal, cms, cmt, masks, maskt, shifts, shiftt)\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(fmt, G_IM_SIZ_16b, 1, timg),\t\t\\\n\tgsDPSetTile(fmt, G_IM_SIZ_16b, 0, tmem, G_TX_LOADTILE, 0 , cmt,\t\\\n\t\tmaskt, shiftt, cms, masks, shifts),\t\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadBlock(G_TX_LOADTILE, 0, 0, (((width)*(height)+3)>>2)-1,\t\\\n\t\tCALC_DXT_4b(width)), \t\t\t\t\t\\\n\tgsDPPipeSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(fmt, G_IM_SIZ_4b, ((((width)>>1)+7)>>3), tmem,\t\\\n\t\tG_TX_RENDERTILE, pal, cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts),\t\t\t\t\t\t\\\n\tgsDPSetTileSize(G_TX_RENDERTILE, 0, 0,\t\t\t\t\\\n\t\t((width)-1) << G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t((height)-1) << G_TEXTURE_IMAGE_FRAC)\n\n#ifndef _HW_VERSION_1\n\n#define\tgDPLoadTextureTile(pkt, timg, fmt, siz, width, height,\t\t\\\n\t\tuls, ult, lrs, lrt, pal,\t\t\t\t\\\n\t\tcms, cmt, masks, maskt, shifts, shiftt)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, fmt, siz, width, timg);\t\t\t\\\n\tgDPSetTile(pkt, fmt, siz,\t\t\t\t\t\\\n\t\t(((((lrs)-(uls)+1) * siz##_TILE_BYTES)+7)>>3), 0,\t\\\n\t\tG_TX_LOADTILE, 0 , cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts);\t\t\t\t\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadTile(\tpkt, G_TX_LOADTILE,\t\t\t\t\\\n\t\t\t(uls)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(ult)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrs)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrt)<<G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, fmt, siz,\t\t\t\t\t\\\n\t\t(((((lrs)-(uls)+1) * siz##_LINE_BYTES)+7)>>3), 0,\t\\\n\t\tG_TX_RENDERTILE, pal, cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts);\t\t\t\t\t\t\\\n\tgDPSetTileSize(pkt, G_TX_RENDERTILE,\t\t\t\t\\\n\t\t\t(uls)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(ult)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrs)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrt)<<G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n} while (0)\n\n#else /******** WORKAROUND hw 1 load tile bug ********/\n\n#define\tgDPLoadTextureTile(pkt, timg, fmt, siz, width, height,\t\t\\\n\t\tuls, ult, lrs, lrt, pal,\t\t\t\t\\\n\t\tcms, cmt, masks, maskt, shifts, shiftt)\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tint _loadtile_i, _loadtile_nw; Gfx *_loadtile_temp = pkt; \t\\\n\tguDPLoadTextureTile(_loadtile_temp, timg, fmt, siz, \t\t\\\n\t\twidth, height,        \t\t\t\t\t\\\n                uls, ult, lrs, lrt, pal,                                \\\n                cms, cmt, masks, maskt, shifts, shiftt);\t\t\\\n\t_loadtile_nw = guGetDPLoadTextureTileSz(ult, lrt) - 1;\t\t\\\n\tfor(_loadtile_i = 0; _loadtile_i < _loadtile_nw; _loadtile_i++)\t\\\n\t  pkt;\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#endif /* HW_VERSION_1 */\n\n/*\n *  Load texture tile.  Allows tmem address and render tile to be specified.\n *  Useful for loading multiple tiles.\n */\n#define\tgDPLoadMultiTile(pkt, timg, tmem, rtile, fmt, siz, width, height,\\\n\t\tuls, ult, lrs, lrt, pal,\t\t\t\t\\\n\t\tcms, cmt, masks, maskt, shifts, shiftt)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, fmt, siz, width, timg);\t\t\t\\\n\tgDPSetTile(pkt, fmt, siz,\t\t\t\t\t\\\n\t\t(((((lrs)-(uls)+1) * siz##_TILE_BYTES)+7)>>3), tmem,\t\\\n\t\tG_TX_LOADTILE, 0 , cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts);\t\t\t\t\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadTile(\tpkt, G_TX_LOADTILE,\t\t\t\t\\\n\t\t\t(uls)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(ult)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrs)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrt)<<G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, fmt, siz,\t\t\t\t\t\\\n\t\t(((((lrs)-(uls)+1) * siz##_LINE_BYTES)+7)>>3), tmem,\t\\\n\t\trtile, pal, cmt, maskt, shiftt, cms, masks,\t\t\\\n\t\tshifts);\t\t\t\t\t\t\\\n\tgDPSetTileSize(pkt, rtile,\t\t\t\t\t\\\n\t\t\t(uls)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(ult)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrs)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrt)<<G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n} while (0)\n\n\n#define\tgsDPLoadTextureTile(timg, fmt, siz, width, height,\t\t\\\n\t\tuls, ult, lrs, lrt, pal,\t\t\t\t\\\n\t\tcms, cmt, masks, maskt, shifts, shiftt)\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(fmt, siz, width, timg),\t\t\t\\\n\tgsDPSetTile(fmt, siz, \t\t\t\t\t\t\\\n\t\t    (((((lrs)-(uls)+1) * siz##_TILE_BYTES)+7)>>3), 0,\t\\\n\t\t    G_TX_LOADTILE, 0 , cmt, maskt, shiftt, cms, masks,\t\\\n\t\t    shifts),\t\t\t\t\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadTile(\tG_TX_LOADTILE,\t\t\t\t\t\\\n\t\t\t(uls)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(ult)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrs)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrt)<<G_TEXTURE_IMAGE_FRAC),\t\t\t\\\n\tgsDPPipeSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(fmt, siz, \t\t\t\t\t\t\\\n\t\t    (((((lrs)-(uls)+1) * siz##_LINE_BYTES)+7)>>3), 0,\t\\\n\t\t    G_TX_RENDERTILE, pal, cmt, maskt, shiftt, cms, masks,\\\n\t\t    shifts),\t\t\t\t\t\t\\\n\tgsDPSetTileSize(G_TX_RENDERTILE,\t\t\t\t\\\n\t\t\t(uls)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(ult)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrs)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrt)<<G_TEXTURE_IMAGE_FRAC)\n\n/*\n *  Load texture tile.  Allows tmem address and render tile to be specified.\n *  Useful for loading multiple tiles.\n */\n#define\tgsDPLoadMultiTile(timg, tmem, rtile, fmt, siz, width, height,\t\\\n\t\tuls, ult, lrs, lrt, pal,\t\t\t\t\\\n\t\tcms, cmt, masks, maskt, shifts, shiftt)\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(fmt, siz, width, timg),\t\t\t\\\n\tgsDPSetTile(fmt, siz, \t\t\t\t\t\t\\\n\t\t    (((((lrs)-(uls)+1) * siz##_TILE_BYTES)+7)>>3), \t\\\n\t\t    tmem, G_TX_LOADTILE, 0 , cmt, maskt, shiftt, cms, \t\\\n\t\t    masks, shifts),\t\t\t\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadTile(\tG_TX_LOADTILE,\t\t\t\t\t\\\n\t\t\t(uls)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(ult)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrs)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrt)<<G_TEXTURE_IMAGE_FRAC),\t\t\t\\\n\tgsDPPipeSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(fmt, siz, \t\t\t\t\t\t\\\n\t\t    (((((lrs)-(uls)+1) * siz##_LINE_BYTES)+7)>>3), \t\\\n\t\t    tmem, rtile, pal, cmt, maskt, shiftt, cms, masks,\t\\\n\t\t    shifts),\t\t\t\t\t\t\\\n\tgsDPSetTileSize(rtile,\t\t\t\t\t\t\\\n\t\t\t(uls)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(ult)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrs)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrt)<<G_TEXTURE_IMAGE_FRAC)\n\n#define\tgDPLoadTextureTile_4b(pkt, timg, fmt, width, height,\t\t\\\n\t\tuls, ult, lrs, lrt, pal,\t\t\t\t\\\n\t\tcms, cmt, masks, maskt, shifts, shiftt)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, fmt, G_IM_SIZ_8b, ((width)>>1), timg);\t\\\n\tgDPSetTile(pkt, fmt, G_IM_SIZ_8b, \t\t\t\t\\\n\t\t   (((((lrs)-(uls)+1)>>1)+7)>>3), 0,\t\t\t\\\n\t\t   G_TX_LOADTILE, 0 , cmt, maskt, shiftt, cms, masks,\t\\\n\t\t   shifts);\t\t\t\t\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadTile(\tpkt, G_TX_LOADTILE,\t\t\t\t\\\n\t\t\t(uls)<<(G_TEXTURE_IMAGE_FRAC-1),\t\t\\\n\t\t\t(ult)<<(G_TEXTURE_IMAGE_FRAC),\t\t\t\\\n\t\t\t(lrs)<<(G_TEXTURE_IMAGE_FRAC-1),\t\t\\\n\t\t\t(lrt)<<(G_TEXTURE_IMAGE_FRAC));\t\t\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, fmt, G_IM_SIZ_4b, \t\t\t\t\\\n\t\t   (((((lrs)-(uls)+1)>>1)+7)>>3), 0,\t\t\t\\\n\t\t   G_TX_RENDERTILE, pal, cmt, maskt, shiftt, cms, \t\\\n\t\t   masks, shifts);\t\t\t\t\t\\\n\tgDPSetTileSize(pkt, G_TX_RENDERTILE,\t\t\t\t\\\n\t\t\t(uls)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(ult)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrs)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrt)<<G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n} while (0)\n\n/*\n *  Load texture tile.  Allows tmem address and render tile to be specified.\n *  Useful for loading multiple tiles.\n */\n#define\tgDPLoadMultiTile_4b(pkt, timg, tmem, rtile, fmt, width, height,\t\\\n\t\tuls, ult, lrs, lrt, pal,\t\t\t\t\\\n\t\tcms, cmt, masks, maskt, shifts, shiftt)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, fmt, G_IM_SIZ_8b, ((width)>>1), timg);\t\\\n\tgDPSetTile(pkt, fmt, G_IM_SIZ_8b, \t\t\t        \\\n\t\t   (((((lrs)-(uls)+1)>>1)+7)>>3), tmem,\t\t\t\\\n\t\t   G_TX_LOADTILE, 0 , cmt, maskt, shiftt, cms, masks,\t\\\n\t\t   shifts);\t\t\t\t\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadTile(\tpkt, G_TX_LOADTILE,\t\t\t\t\\\n\t\t\t(uls)<<(G_TEXTURE_IMAGE_FRAC-1),\t\t\\\n\t\t\t(ult)<<(G_TEXTURE_IMAGE_FRAC),\t\t\t\\\n\t\t\t(lrs)<<(G_TEXTURE_IMAGE_FRAC-1),\t\t\\\n\t\t\t(lrt)<<(G_TEXTURE_IMAGE_FRAC));\t\t\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, fmt, G_IM_SIZ_4b, \t\t\t\t\\\n\t\t   (((((lrs)-(uls)+1)>>1)+7)>>3), tmem,\t\t\t\\\n\t\t   rtile, pal, cmt, maskt, shiftt, cms, masks,\t\t\\\n\t\t   shifts);\t\t\t\t\t\t\\\n\tgDPSetTileSize(pkt, rtile,\t\t\t\t\t\\\n\t\t\t(uls)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(ult)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrs)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrt)<<G_TEXTURE_IMAGE_FRAC);\t\t\t\\\n} while (0)\n\n#define\tgsDPLoadTextureTile_4b(timg, fmt, width, height,\t\t\\\n\t\tuls, ult, lrs, lrt, pal,\t\t\t\t\\\n\t\tcms, cmt, masks, maskt, shifts, shiftt)\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(fmt, G_IM_SIZ_8b, ((width)>>1), timg),\t\\\n\tgsDPSetTile(fmt, G_IM_SIZ_8b, (((((lrs)-(uls)+1)>>1)+7)>>3), 0,\t\\\n\t\tG_TX_LOADTILE, 0 , cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts),\t\t\t\t\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadTile(\tG_TX_LOADTILE,\t\t\t\t\t\\\n\t\t\t(uls)<<(G_TEXTURE_IMAGE_FRAC-1),\t\t\\\n\t\t\t(ult)<<(G_TEXTURE_IMAGE_FRAC),\t\t\t\\\n\t\t\t(lrs)<<(G_TEXTURE_IMAGE_FRAC-1),\t\t\\\n\t\t\t(lrt)<<(G_TEXTURE_IMAGE_FRAC)),\t\t\t\\\n\tgsDPPipeSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(fmt, G_IM_SIZ_4b, (((((lrs)-(uls)+1)>>1)+7)>>3), 0,\t\\\n\t\tG_TX_RENDERTILE, pal, cmt, maskt, shiftt, cms, masks,\t\\\n\t\tshifts),\t\t\t\t\t\t\\\n\tgsDPSetTileSize(G_TX_RENDERTILE,\t\t\t\t\\\n\t\t\t(uls)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(ult)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrs)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrt)<<G_TEXTURE_IMAGE_FRAC)\n\n/*\n *  Load texture tile.  Allows tmem address and render tile to be specified.\n *  Useful for loading multiple tiles.\n */\n#define\tgsDPLoadMultiTile_4b(timg, tmem, rtile, fmt, width, height,\t\\\n\t\tuls, ult, lrs, lrt, pal,\t\t\t\t\\\n\t\tcms, cmt, masks, maskt, shifts, shiftt)\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(fmt, G_IM_SIZ_8b, ((width)>>1), timg),\t\\\n\tgsDPSetTile(fmt, G_IM_SIZ_8b, (((((lrs)-(uls)+1)>>1)+7)>>3), \t\\\n\t\t    tmem, G_TX_LOADTILE, 0 , cmt, maskt, shiftt, cms, \t\\\n\t\t    masks, shifts),\t\t\t\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadTile(\tG_TX_LOADTILE,\t\t\t\t\t\\\n\t\t\t(uls)<<(G_TEXTURE_IMAGE_FRAC-1),\t\t\\\n\t\t\t(ult)<<(G_TEXTURE_IMAGE_FRAC),\t\t\t\\\n\t\t\t(lrs)<<(G_TEXTURE_IMAGE_FRAC-1),\t\t\\\n\t\t\t(lrt)<<(G_TEXTURE_IMAGE_FRAC)),\t\t\t\\\n\tgsDPPipeSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(fmt, G_IM_SIZ_4b, (((((lrs)-(uls)+1)>>1)+7)>>3), \t\\\n\t\t    tmem, rtile, pal, cmt, maskt, shiftt, cms, masks,\t\\\n\t\t    shifts),\t\t\t\t\t\t\\\n\tgsDPSetTileSize(rtile,\t\t\t\t\t\t\\\n\t\t\t(uls)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(ult)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrs)<<G_TEXTURE_IMAGE_FRAC,\t\t\t\\\n\t\t\t(lrt)<<G_TEXTURE_IMAGE_FRAC)\n\n/*\n *  Load a 16-entry palette (for 4-bit CI textures)\n *  Assumes a 16 entry tlut is being loaded, palette # is 0-15\n */\n#ifndef _HW_VERSION_1\n\n#define gDPLoadTLUT_pal16(pkt, pal, dram)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, G_IM_FMT_RGBA, G_IM_SIZ_16b, 1, dram);\t\\\n\tgDPTileSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, 0, 0, 0, (256+(((pal)&0xf)*16)),\t\t\\\n\t\tG_TX_LOADTILE, 0 , 0, 0, 0, 0, 0, 0);\t\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadTLUTCmd(pkt, G_TX_LOADTILE, 15);\t\t\t\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n} while (0)\n\n#else /* **** WORKAROUND hardware 1 load_tlut bug ****** */\n\n#define gDPLoadTLUT_pal16(pkt, pal, dram)\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n        _gDPLoadTextureBlock(pkt, dram, (256+(((pal)&0xf)*16)),\t\t\\\n\t\tG_IM_FMT_RGBA, G_IM_SIZ_16b, 4*16, 1,\t\t\t\\\n\t\tpal, 0, 0, 0, 0, 0, 0)\n\n#endif /* _HW_VERSION_1 */\n\n\n/*\n *  Load a 16-entry palette (for 4-bit CI textures)\n *  Assumes a 16 entry tlut is being loaded, palette # is 0-15\n */\n#ifndef _HW_VERSION_1\n\n#define gsDPLoadTLUT_pal16(pal, dram)\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(G_IM_FMT_RGBA, G_IM_SIZ_16b, 1, dram),\t\\\n\tgsDPTileSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(0, 0, 0, (256+(((pal)&0xf)*16)),\t\t\t\\\n\t\tG_TX_LOADTILE, 0 , 0, 0, 0, 0, 0, 0),\t\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadTLUTCmd(G_TX_LOADTILE, 15),\t\t\t\t\\\n\tgsDPPipeSync()\n\n#else /* **** WORKAROUND hardware 1 load_tlut bug ****** */\n\n#define gsDPLoadTLUT_pal16(pal, dram)                                   \\\n\t\t\t\t\t\t\t\t\t\\\n\t_gsDPLoadTextureBlock(dram, (256+(((pal)&0xf)*16)),           \t\\\n                G_IM_FMT_RGBA, G_IM_SIZ_16b, 4*16, 1,                   \\\n                pal, 0, 0, 0, 0, 0, 0)\n\n#endif /* _HW_VERSION_1 */ \n\n/*\n *  Load a 256-entry palette (for 8-bit CI textures)\n *  Assumes a 256 entry tlut is being loaded, palette # is not used\n */\n#ifndef _HW_VERSION_1\n\n#define gDPLoadTLUT_pal256(pkt, dram)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, G_IM_FMT_RGBA, G_IM_SIZ_16b, 1, dram);\t\\\n\tgDPTileSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, 0, 0, 0, 256,\t\t\t\t\t\\\n\t\tG_TX_LOADTILE, 0 , 0, 0, 0, 0, 0, 0);\t\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadTLUTCmd(pkt, G_TX_LOADTILE, 255);\t\t\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n} while (0)\n\n#else /* **** WORKAROUND hardware 1 load_tlut bug ****** */\n\n#define gDPLoadTLUT_pal256(pkt, dram)                                   \\\n\t                                                                \\\n\t_gDPLoadTextureBlock(pkt, dram, 256,           \t\t\t\\\n                G_IM_FMT_RGBA, G_IM_SIZ_16b, 4*256, 1,\t\t\t\\\n                0, 0, 0, 0, 0, 0, 0)\n\n\n#endif /* _HW_VERSION_1 */\n\n\n#ifndef _HW_VERSION_1\n\n#define gsDPLoadTLUT_pal256(dram)\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(G_IM_FMT_RGBA, G_IM_SIZ_16b, 1, dram),\t\\\n\tgsDPTileSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(0, 0, 0, 256,\t\t\t\t\t\\\n\t\tG_TX_LOADTILE, 0 , 0, 0, 0, 0, 0, 0),\t\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadTLUTCmd(G_TX_LOADTILE, 255),\t\t\t\t\\\n\tgsDPPipeSync()\n \n#else /* **** WORKAROUND hardware 1 load_tlut bug ****** */\n\n#define gsDPLoadTLUT_pal256(dram)                                       \\\n                                                                        \\\n\t_gsDPLoadTextureBlock(dram, 256,                            \t\\\n                G_IM_FMT_RGBA, G_IM_SIZ_16b, 4*256, 1,                  \\\n                0, 0, 0, 0, 0, 0, 0)\n\n#endif /* _HW_VERSION_1 */\n\n\n#ifndef _HW_VERSION_1\n\n#define gDPLoadTLUT(pkt, count, tmemaddr, dram)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tgDPSetTextureImage(pkt, G_IM_FMT_RGBA, G_IM_SIZ_16b, 1, dram);\t\\\n\tgDPTileSync(pkt);\t\t\t\t\t\t\\\n\tgDPSetTile(pkt, 0, 0, 0, tmemaddr,\t\t\t\t\\\n\t\tG_TX_LOADTILE, 0 , 0, 0, 0, 0, 0, 0);\t\t\t\\\n\tgDPLoadSync(pkt);\t\t\t\t\t\t\\\n\tgDPLoadTLUTCmd(pkt, G_TX_LOADTILE, ((count)-1));\t\t\\\n\tgDPPipeSync(pkt);\t\t\t\t\t\t\\\n} while (0)\n\n#else /* **** WORKAROUND hardware 1 load_tlut bug ****** */\n\n#define gDPLoadTLUT(pkt, count, tmemaddr, dram)                         \\\n\t\t\t\t\t\t\t\t\t\\\n        _gDPLoadTextureBlock(pkt, dram, tmemaddr,                       \\\n                G_IM_FMT_RGBA, G_IM_SIZ_16b, 4, count,                  \\\n                0, 0, 0, 0, 0, 0, 0)\n\n#endif /* _HW_VERSION_1 */\n\n\n#ifndef _HW_VERSION_1\n\n#define gsDPLoadTLUT(count, tmemaddr, dram)\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n\tgsDPSetTextureImage(G_IM_FMT_RGBA, G_IM_SIZ_16b, 1, dram),\t\\\n\tgsDPTileSync(),\t\t\t\t\t\t\t\\\n\tgsDPSetTile(0, 0, 0, tmemaddr,\t\t\t\t\t\\\n\t\tG_TX_LOADTILE, 0 , 0, 0, 0, 0, 0, 0),\t\t\t\\\n\tgsDPLoadSync(),\t\t\t\t\t\t\t\\\n\tgsDPLoadTLUTCmd(G_TX_LOADTILE, ((count)-1)),\t\t\t\\\n\tgsDPPipeSync()\n\n#else /* **** WORKAROUND hardware 1 load_tlut bug ****** */\n#define gsDPLoadTLUT(count, tmemaddr, dram)                             \\\n                                                                        \\\n        _gsDPLoadTextureBlock(dram, tmemaddr,                       \t\\\n                G_IM_FMT_RGBA, G_IM_SIZ_16b, 4, count,                  \\\n                0, 0, 0, 0, 0, 0, 0)\n\n#endif /* _HW_VERSION_1 */ \n\n#define gDPSetScissor(pkt, mode, ulx, uly, lrx, lry)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)pkt;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_SETSCISSOR, 24, 8) |\t\t\t\\\n\t\t       _SHIFTL((int)((float)(ulx)*4.0F), 12, 12) |\t\\\n                       _SHIFTL((int)((float)(uly)*4.0F), 0, 12);\t\\\n\t_g->words.w1 = _SHIFTL(mode, 24, 2) |\t\t\t\t\\\n\t\t       _SHIFTL((int)((float)(lrx)*4.0F), 12, 12) |\t\\\n                       _SHIFTL((int)((float)(lry)*4.0F), 0, 12);\t\\\n} while (0)\n\n\n#define gDPSetScissorFrac(pkt, mode, ulx, uly, lrx, lry)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)pkt;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_SETSCISSOR, 24, 8) |\t\t\t\\\n\t\t       _SHIFTL((int)((ulx)), 12, 12) |\t\t\t\\\n                       _SHIFTL((int)((uly)), 0, 12);\t\t\t\\\n\t_g->words.w1 = _SHIFTL(mode, 24, 2) |\t\t\t\t\\\n\t\t       _SHIFTL((int)((lrx)), 12, 12) | \t\t\t\\\n                       _SHIFTL((int)((lry)), 0, 12);\t\t\t\\\n} while (0)\n\n#define gsDPSetScissor(mode, ulx, uly, lrx, lry)\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_SETSCISSOR, 24, 8) |\t\t\t\t\t\\\n\t_SHIFTL((int)((float)(ulx)*4.0F), 12, 12) |\t\t\t\\\n\t_SHIFTL((int)((float)(uly)*4.0F), 0, 12),\t\t\t\\\n\t_SHIFTL(mode, 24, 2) |\t\t\t\t\t\t\\\n\t_SHIFTL((int)((float)(lrx)*4.0F), 12, 12) |\t\t\t\\\n\t_SHIFTL((int)((float)(lry)*4.0F), 0, 12)\t\t\t\\\n}}\n\n#define gsDPSetScissorFrac(mode, ulx, uly, lrx, lry)\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_SETSCISSOR, 24, 8) |\t\t\t\t\t\\\n\t_SHIFTL((int)((ulx)), 12, 12) |\t\t\t\t\t\\\n\t_SHIFTL((int)((uly)), 0, 12),\t\t\t\t\t\\\n\t_SHIFTL(mode, 24, 2) |\t\t\t\t\t\t\\\n\t_SHIFTL((int)(lrx), 12, 12) |\t\t\t\t\t\\\n\t_SHIFTL((int)(lry), 0, 12)\t\t\t\t\t\\\n}}\n\n/* Fraction never used in fill */\n#define\tgDPFillRectangle(pkt, ulx, uly, lrx, lry)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(G_FILLRECT, 24, 8) | \t\t\t\\\n\t\t\t_SHIFTL((lrx), 14, 10) | _SHIFTL((lry), 2, 10));\\\n\t_g->words.w1 = (_SHIFTL((ulx), 14, 10) | _SHIFTL((uly), 2, 10));\\\n} while (0)\n\n#define\tgsDPFillRectangle(ulx, uly, lrx, lry)\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t(_SHIFTL(G_FILLRECT, 24, 8) | _SHIFTL((lrx), 14, 10) | \t\t\\\n\t _SHIFTL((lry), 2, 10)),\t\t\t\t\t\\\n\t(_SHIFTL((ulx), 14, 10) | _SHIFTL((uly), 2, 10))\t\t\\\n}}\n\n/* like gDPFillRectangle but accepts negative arguments */\n#define\tgDPScisFillRectangle(pkt, ulx, uly, lrx, lry)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(G_FILLRECT, 24, 8) | \t\t\t\\\n\t\t\t_SHIFTL(MAX((lrx),0), 14, 10) | \t\t\\\n\t\t\t_SHIFTL(MAX((lry),0), 2, 10));\t\t\t\\\n\t_g->words.w1 = (_SHIFTL(MAX((ulx),0), 14, 10) | \t\t\\\n\t\t\t_SHIFTL(MAX((uly),0), 2, 10));\t\t\t\\\n} while (0)\n\n#define\tgDPSetConvert(pkt, k0, k1, k2, k3, k4, k5)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(G_SETCONVERT, 24, 8) |\t\t\t\\\n\t\t\t_SHIFTL(k0, 13, 9) | _SHIFTL(k1, 4, 9) | \t\\\n\t\t\t_SHIFTR(k2, 5, 4));\t\t\t\t\\\n\t_g->words.w1 = (_SHIFTL(k2, 27, 5) | _SHIFTL(k3, 18, 9) |\t\\\n\t\t\t_SHIFTL(k4, 9, 9) | _SHIFTL(k5, 0, 9));\t\t\\\n} while (0)\n\n#define gsDPSetConvert(k0, k1, k2, k3, k4, k5)\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t(_SHIFTL(G_SETCONVERT, 24, 8) |\t\t\t\t\t\\\n\t _SHIFTL(k0, 13, 9) | _SHIFTL(k1, 4, 9) | _SHIFTR(k2, 5, 4)),\t\\\n\t(_SHIFTL(k2, 27, 5) | _SHIFTL(k3, 18, 9) | _SHIFTL(k4, 9, 9) | \t\\\n\t _SHIFTL(k5, 0, 9))\t\t\t\t\t\t\\\n}}\n\n#define\tgDPSetKeyR(pkt, cR, sR, wR)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(G_SETKEYR, 24, 8);\t\t\t\\\n\t_g->words.w1 = (_SHIFTL(wR, 16, 12) | _SHIFTL(cR, 8, 8) | \t\\\n\t\t\t_SHIFTL(sR, 0, 8));\t\t\t\t\\\n} while (0)\n\n#define\tgsDPSetKeyR(cR, sR, wR)\t\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(G_SETKEYR, 24, 8),\t\t\t\t\t\\\n\t_SHIFTL(wR, 16, 12) | _SHIFTL(cR, 8, 8) | _SHIFTL(sR, 0, 8)\t\\\n}}\n\n#define\tgDPSetKeyGB(pkt, cG, sG, wG, cB, sB, wB)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = (_SHIFTL(G_SETKEYGB, 24, 8) |\t\t\t\\\n\t\t\t_SHIFTL(wG, 12, 12) | _SHIFTL(wB, 0, 12));\t\\\n\t_g->words.w1 = (_SHIFTL(cG, 24, 8) | _SHIFTL(sG, 16, 8) |\t\\\n\t\t\t _SHIFTL(cB, 8, 8) | _SHIFTL(sB, 0, 8));\t\\\n} while (0)\n\n#define\tgsDPSetKeyGB(cG, sG, wG, cB, sB, wB)\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t(_SHIFTL(G_SETKEYGB, 24, 8) | _SHIFTL(wG, 12, 12) |\t\t\\\n\t _SHIFTL(wB, 0, 12)),\t\t\t\t\t\t\\\n\t(_SHIFTL(cG, 24, 8) | _SHIFTL(sG, 16, 8) | _SHIFTL(cB, 8, 8) |\t\\\n\t _SHIFTL(sB, 0, 8))\t\t\t\t\t\t\\\n}}\n\n#define gDPNoParam(pkt, cmd)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(cmd, 24, 8);\t\t\t\t\\\n\t_g->words.w1 = 0;\t\t\t\t\t\t\\\n} while (0)\n\n#define gsDPNoParam(cmd)\t\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(cmd, 24, 8), 0\t\t\t\t\t\t\\\n}}\n\n#define gDPParam(pkt, cmd, param)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tGfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_g->words.w0 = _SHIFTL(cmd, 24, 8);\t\t\t\t\\\n\t_g->words.w1 = (param);\t\t\t\t\t\t\\\n} while (0)\n\n#define gsDPParam(cmd, param)\t\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n\t_SHIFTL(cmd, 24, 8), (param)\t\t\t\t\t\\\n}}\n\n/* Notice that textured rectangles are 128-bit commands, therefore\n * gsDPTextureRectangle() should not be used in display lists \n * under normal circumstances (use gsSPTextureRectangle()).\n * That is also why there is no gDPTextureRectangle() macros.\n */\n#define gsDPTextureRectangle(xl, yl, xh, yh, tile, s, t, dsdx, dtdy)\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n    (_SHIFTL(G_TEXRECT, 24, 8) | _SHIFTL(xh, 12, 12) | \t\t\t\\\n     _SHIFTL(yh, 0, 12)),\t\t\t\t\t\t\\\n    (_SHIFTL(tile, 24, 3) | _SHIFTL(xl, 12, 12) | _SHIFTL(yl, 0, 12)),\t\\\n}},\t\t\t\t\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n    _SHIFTL(s, 16, 16) | _SHIFTL(t, 0, 16),\t\t\t\t\\\n    _SHIFTL(dsdx, 16, 16) | _SHIFTL(dtdy, 0, 16)\t\t\t\\\n}}\n\n#define gDPTextureRectangle(pkt, xl, yl, xh, yh, tile, s, t, dsdx, dtdy)\\\ndo {\t\t\t\t\t\t\t\t\t\\\n    Gfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n    if (pkt);\t\t\t\t\t\t\t\t\\\n    _g->words.w0 = (_SHIFTL(G_TEXRECT, 24, 8) | _SHIFTL(xh, 12, 12) |\t\\\n\t\t    _SHIFTL(yh, 0, 12));    \t\t\t\t\\\n    _g->words.w1 = (_SHIFTL(tile, 24, 3) | _SHIFTL(xl, 12, 12) |\t\\\n\t\t    _SHIFTL(yl, 0, 12));\t\t\t\t\\\n    _g ++;\t\t\t\t\t\t\t\t\\\n    _g->words.w0 = (_SHIFTL(s, 16, 16) | _SHIFTL(t, 0, 16));\t\t\\\n    _g->words.w1 = (_SHIFTL(dsdx, 16, 16) | _SHIFTL(dtdy, 0, 16));\t\\\n} while (0)\n\n#define gsDPTextureRectangleFlip(xl, yl, xh, yh, tile, s, t, dsdx, dtdy) \\\n{{\t\t\t\t\t\t\t\t\t\\\n    (_SHIFTL(G_TEXRECTFLIP, 24, 8) | _SHIFTL(xh, 12, 12) |\t\t\\\n     _SHIFTL(yh, 0, 12)),\t\t\t\t\t\t\\\n    (_SHIFTL(tile, 24, 3) | _SHIFTL(xl, 12, 12) | _SHIFTL(yl, 0, 12)),\t\\\n}},\t\t\t\t\t\t\t\t\t\\\n{{\t\t\t\t\t\t\t\t\t\\\n    _SHIFTL(s, 16, 16) | _SHIFTL(t, 0, 16),\t\t\t\t\\\n    _SHIFTL(dsdx, 16, 16) | _SHIFTL(dtdy, 0, 16)\t\t\t\\\n}}\n\n#define gDPTextureRectangleFlip(pkt, xl, yl, xh, yh, tile, s, t, dsdx, dtdy)\\\ndo {\t\t\t\t\t\t\t\t\t\\\n    Gfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n    if (pkt);\t\t\t\t\t\t\t\t\\\n    _g->words.w0 = (_SHIFTL(G_TEXRECTFLIP, 24, 8) | _SHIFTL(xh, 12, 12) | \\\n\t\t    _SHIFTL(yh, 0, 12));    \t\t\t\t\\\n    _g->words.w1 = (_SHIFTL(tile, 24, 3) | _SHIFTL(xl, 12, 12) |\t\\\n\t\t    _SHIFTL(yl, 0, 12));\t\t\t\t\\\n    _g ++;\t\t\t\t\t\t\t\t\\\n    _g->words.w0 = (_SHIFTL(s, 16, 16) | _SHIFTL(t, 0, 16));\t\t\\\n    _g->words.w1 = (_SHIFTL(dsdx, 16, 16) | _SHIFTL(dtdy, 0, 16));\t\\\n} while (0)\n\n#define gsSPTextureRectangle(xl, yl, xh, yh, tile, s, t, dsdx, dtdy)\t\\\n    {{(_SHIFTL(G_TEXRECT, 24, 8) | _SHIFTL(xh, 12, 12) | _SHIFTL(yh, 0, 12)),\\\n    (_SHIFTL(tile, 24, 3) | _SHIFTL(xl, 12, 12) | _SHIFTL(yl, 0, 12))}},\t\\\n    gsImmp1(G_RDPHALF_1, (_SHIFTL(s, 16, 16) | _SHIFTL(t, 0, 16))),\t\\\n    gsImmp1(G_RDPHALF_2, (_SHIFTL(dsdx, 16, 16) | _SHIFTL(dtdy, 0, 16)))\n\n#define gSPTextureRectangle(pkt, xl, yl, xh, yh, tile, s, t, dsdx, dtdy)\\\ndo {\t\t\t\t\t\t\t\t\t\\\n    Gfx *_g = (Gfx *)(pkt);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    _g->words.w0 = (_SHIFTL(G_TEXRECT, 24, 8) | _SHIFTL(xh, 12, 12) |\t\\\n\t\t    _SHIFTL(yh, 0, 12));    \t\t\t\t\\\n    _g->words.w1 = (_SHIFTL(tile, 24, 3) | _SHIFTL(xl, 12, 12) |\t\\\n\t\t    _SHIFTL(yl, 0, 12));\t\t\t\t\\\n    gImmp1(pkt, G_RDPHALF_1, (_SHIFTL(s, 16, 16) | _SHIFTL(t, 0, 16)));\t\\\n    gImmp1(pkt, G_RDPHALF_2, (_SHIFTL(dsdx, 16, 16) | _SHIFTL(dtdy, 0, 16)));\\\n} while (0)\n\n/* like gSPTextureRectangle but accepts negative position arguments */\n#define gSPScisTextureRectangle(pkt, xl, yl, xh, yh, tile, s, t, dsdx, dtdy) \\\ndo {                                                                            \\\n    Gfx *_g = (Gfx *)(pkt);                                                  \\\n                                                                             \\\n    _g->words.w0 = (_SHIFTL(G_TEXRECT, 24, 8) |                              \\\n                    _SHIFTL(MAX((s16)(xh),0), 12, 12) |                      \\\n                    _SHIFTL(MAX((s16)(yh),0), 0, 12));                       \\\n    _g->words.w1 = (_SHIFTL((tile), 24, 3) |                                 \\\n                    _SHIFTL(MAX((s16)(xl),0), 12, 12) |                      \\\n                    _SHIFTL(MAX((s16)(yl),0), 0, 12));                       \\\n    gImmp1(pkt, G_RDPHALF_1,                                                 \\\n                (_SHIFTL(((s) -                                              \\\n                          (((s16)(xl) < 0) ?                                 \\\n                           (((s16)(dsdx) < 0) ?                              \\\n                            ((s32)MAX((((s16)(xl)*(s16)(dsdx))>>7),0)) :          \\\n\t\t\t    ((s32)MIN((((s16)(xl)*(s16)(dsdx))>>7),0))) : 0)),    \\\n\t\t\t 16, 16) |                                           \\\n                 _SHIFTL(((t) -                                              \\\n                          (((yl) < 0) ?                                      \\\n                           (((s16)(dtdy) < 0) ?                              \\\n                            ((s32)MAX((((s16)(yl)*(s16)(dtdy))>>7),0)) :          \\\n                            ((s32)MIN((((s16)(yl)*(s16)(dtdy))>>7),0))) : 0)),    \\\n\t\t\t 0, 16)));                                           \\\n    gImmp1(pkt, G_RDPHALF_2, (_SHIFTL((dsdx), 16, 16) |                      \\\n                              _SHIFTL((dtdy), 0, 16)));                      \\\n} while (0)\n\n#define gsSPTextureRectangleFlip(xl, yl, xh, yh, tile, s, t, dsdx, dtdy) \\\n    {{(_SHIFTL(G_TEXRECTFLIP, 24, 8) | _SHIFTL(xh, 12, 12) |\t\t\\\n     _SHIFTL(yh, 0, 12)),\t\t\t\t\t\t\\\n    (_SHIFTL(tile, 24, 3) | _SHIFTL(xl, 12, 12) | _SHIFTL(yl, 0, 12))}},\t\\\n    gsImmp1(G_RDPHALF_1, (_SHIFTL(s, 16, 16) | _SHIFTL(t, 0, 16))),\t\\\n    gsImmp1(G_RDPHALF_2, (_SHIFTL(dsdx, 16, 16) | _SHIFTL(dtdy, 0, 16)))\n\n#define gSPTextureRectangleFlip(pkt, xl, yl, xh, yh, tile, s, t, dsdx, dtdy) \\\ndo {\t\t\t\t\t\t\t\t       \t\\\n    Gfx *_g = (Gfx *)(pkt);\t\t\t\t\t       \t\\\n\t\t\t\t\t\t\t\t\t \\\n    _g->words.w0 = (_SHIFTL(G_TEXRECTFLIP, 24, 8) | _SHIFTL(xh, 12, 12) |\\\n\t\t    _SHIFTL(yh, 0, 12)); \t\t\t\t\\\n    _g->words.w1 = (_SHIFTL(tile, 24, 3) | _SHIFTL(xl, 12, 12) |\t\\\n\t\t    _SHIFTL(yl, 0, 12));\t\t\t\t\\\n    gImmp1(pkt, G_RDPHALF_1, (_SHIFTL(s, 16, 16) | _SHIFTL(t, 0, 16)));\t\\\n    gImmp1(pkt, G_RDPHALF_2, (_SHIFTL(dsdx, 16, 16) | _SHIFTL(dtdy, 0, 16))); \\\n} while (0)\n\n#define gsDPWord(wordhi, wordlo)\t\t\t\\\n    gsImmp1(G_RDPHALF_1, (unsigned int)(wordhi)),\t\\\n    gsImmp1(G_RDPHALF_2, (unsigned int)(wordlo))\n\n#define gDPWord(pkt, wordhi, wordlo)      \t\t\\\ndo {\t\t\t\t\t\t\t\\\n    Gfx *_g = (Gfx *)(pkt);\t\t\t\t\\\n\t\t\t\t\t\t\t\\\n    gImmp1(pkt, G_RDPHALF_1, (unsigned int)(wordhi));\t\\\n    gImmp1(pkt, G_RDPHALF_2, (unsigned int)(wordlo));\t\\\n} while (0)\n\n#define\tgDPFullSync(pkt)\tgDPNoParam(pkt, G_RDPFULLSYNC)\n#define\tgsDPFullSync()\t\tgsDPNoParam(G_RDPFULLSYNC)\n#define\tgDPTileSync(pkt)\tgDPNoParam(pkt, G_RDPTILESYNC)\n#define\tgsDPTileSync()\t\tgsDPNoParam(G_RDPTILESYNC)\n#define\tgDPPipeSync(pkt)\tgDPNoParam(pkt, G_RDPPIPESYNC)\n#define\tgsDPPipeSync()\t\tgsDPNoParam(G_RDPPIPESYNC)\n#define\tgDPLoadSync(pkt)\tgDPNoParam(pkt, G_RDPLOADSYNC)\n#define\tgsDPLoadSync()\t\tgsDPNoParam(G_RDPLOADSYNC)\n#define\tgDPNoOp(pkt)\t\tgDPNoParam(pkt, G_NOOP)\n#define\tgsDPNoOp()\t\tgsDPNoParam(G_NOOP)\n#define\tgDPNoOpTag(pkt, tag)\tgDPParam(pkt, G_NOOP, tag)\n#define\tgsDPNoOpTag(tag)\tgsDPParam(G_NOOP, tag)\n\n#endif /* _LANGUAGE_C */\n\ntypedef struct {\n  u32 r:8;\n  u32 g:8;\n  u32 b:8;\n  u32 a:8;\n} rgba8888_t;\n\ntypedef union {\n  u32 rgba8888;\n  rgba8888_t c;\n} rgba8888;\n\ntypedef struct {\n  size_t size;\n  char *buf_p;\n  char *head_p;\n  char *tail_p;\n} TwoHeadArena_t;\ntypedef TwoHeadArena_t TwoHeadArena;\ntypedef TwoHeadArena_t THA;\n\ntypedef struct {\n  size_t size;\n  Gfx* buf_p;\n  Gfx* head_p;\n  Gfx* tail_p;\n} TwoHeadArenaGfx_t;\n\ntypedef TwoHeadArenaGfx_t TwoHeadArenaGfx;\n\ntypedef union {\n  TwoHeadArena tha;\n  TwoHeadArenaGfx thaGfx;\n} THA_GA_t;\n\ntypedef THA_GA_t THA_GA;\n\n#define MAXCONTROLLERS 4\n\ntypedef struct {\n  u16 type;\n  u8 status;\n  u8 errno;\n} OSContStatus;\n\n/* sizeof(OSContPad) == 6 */\ntypedef struct {\n  /* 0x00 */ u16 button;\n  /* 0x02 */ s8 stick_x;\n  /* 0x03 */ s8 stick_y;\n  /* 0x04 */ u8 errno;\n} OSContPad;\n\n/* sizeof(pad_t) == 0x18 */\ntypedef struct {\n  /* 0x00 */ OSContPad now;\n  /* 0x06 */ OSContPad last;\n  /* 0x0C */ OSContPad on;\n  /* 0x12 */ OSContPad off;\n} pad_t;\n\n/* sizeof(struct gameAllocList_s) == 0x10 */\ntypedef struct gameAllocList_s {\n  /* 0x00 */ struct gameAllocList_s* next;\n  /* 0x04 */ struct gameAllocList_s* prev;\n  /* 0x08 */ size_t alloc_size;\n  /* 0x0C */ u32 pad;\n} GameAllocList;\n\n/* sizeof(struct gameAlloc_s) == 0x14 */\ntypedef struct gameAlloc_s {\n  /* 0x00 */ GameAllocList head;\n  /* 0x10 */ GameAllocList* tail;\n} GameAlloc;\n\n/* sizeof(struct controller_s) == 0x38 */\ntypedef struct controller_s {\n  /* 0x00 */ f32 move_pX;\n  /* 0x04 */ f32 move_pY;\n  /* 0x08 */ f32 move_pR;\n  /* 0x0C */ s16 move_angle;\n\n  /* 0x10 */ f32 last_move_pX;\n  /* 0x14 */ f32 last_move_pY;\n  /* 0x18 */ f32 last_move_pR;\n  /* 0x1C */ s16 last_move_angle;\n\n  /* 0x20 */ f32 adjusted_pX;\n  /* 0x24 */ f32 adjusted_pY;\n  /* 0x28 */ f32 adjusted_pR;\n  \n  /* 0x2C */ f32 last_adjusted_pX;\n  /* 0x30 */ f32 last_adjusted_pY;\n  /* 0x34 */ f32 last_adjusted_pR;\n} MCON;\n\nenum {\n  NAME_TYPE_ITEM0,  /* Scenery items */\n  NAME_TYPE_FTR0,   /* Furniture 0 */\n  NAME_TYPE_ITEM1,  /* Obtainable items */\n  NAME_TYPE_FTR1,   /* Furniture 1 */\n  NAME_TYPE_WARP,   /* Loading zones */\n  NAME_TYPE_STRUCT, /* Structures */\n  NAME_TYPE_PAD6,   /* Unused? */\n  NAME_TYPE_PAD7,   /* Unused? */\n  NAME_TYPE_ITEM2,  /* Misc items */\n  NAME_TYPE_ACTOR,  /* Actors */\n  NAME_TYPE_PROPS,  /* Props */\n  NAME_TYPE_PADB,   /* Unused? */\n  NAME_TYPE_PADC,   /* Unused? */\n  NAME_TYPE_SPNPC,  /* Special NPCs */\n  NAME_TYPE_NPC,    /* Villager NPCs */\n  NAME_TYPE_PAD15,  /* Unused? */\n\n  NAME_TYPE_NUM\n};\n\nenum {\n  ITEM1_CAT_PAPER,\n  ITEM1_CAT_MONEY,\n  ITEM1_CAT_TOOL,\n  ITEM1_CAT_FISH,\n  ITEM1_CAT_CLOTH,\n  ITEM1_CAT_ETC,\n  ITEM1_CAT_CARPET,\n  ITEM1_CAT_WALL,\n  ITEM1_CAT_FRUIT,\n  ITEM1_CAT_PLANT,\n  ITEM1_CAT_MINIDISK,\n  ITEM1_CAT_DUMMY, /* diaries */\n  ITEM1_CAT_TICKET,\n  ITEM1_CAT_INSECT,\n  ITEM1_CAT_HUKUBUKURO,\n  ITEM1_CAT_KABU,\n\n  ITEM1_CAT_NUM\n};\n\nenum {\n  mNT_TREE_TYPE_NORMAL,\n  mNT_TREE_TYPE_PALM,\n  mNT_TREE_TYPE_CEDAR,\n  mNT_TREE_TYPE_GOLD,\n\n  mNT_TREE_TYPE_NUM\n};\n\n/* TODO: these should be calculated via definitions later */\n\n#define FTR_NUM 1266\n#define PAPER_NUM 256\n#define MONEY_NUM 4\n#define TOOL_NUM 92\n#define FISH_NUM 40\n#define CLOTH_NUM 255\n#define ETC_NUM 49\n#define CARPET_NUM 67\n#define WALL_NUM 67\n#define FRUIT_NUM 8\n#define PLANT_NUM 11\n#define MINIDISK_NUM 55\n#define DIARY_NUM 16\n#define TICKET_NUM 96\n#define INSECT_NUM 40 + 5 // 5 spirits\n#define HUKUBUKURO_NUM 2\n#define KABU_NUM 4\n\n#define PAPER_UNIQUE_NUM 64\n#define PAINT_NUM 12\n#define FLOWER_NUM 9\n#define HANIWA_NUM 127\n#define NOT_SECRET_MD_NUM 52\n#define UMBRELLA_NUM 32\n\nextern u8 npc_looks_table[];\n\nextern int mNT_check_unknown(mActor_name_t item_no);\nextern int FGTreeType_check(mActor_name_t tree);\nextern mActor_name_t bg_item_fg_sub_tree_grow(mActor_name_t tree, int past_days, int check_plant);\nextern mActor_name_t bg_item_fg_sub_dig2take_conv(mActor_name_t item);\n\n/* Retrieve the item actor's category */\n#define ITEM_NAME_GET_TYPE(n) (((n) & 0xF000) >> 12)\n#define ITEM_NAME_GET_CAT(n) (((n) & 0x0F00) >> 8)\n#define ITEM_NAME_GET_INDEX(n) ((mActor_name_t)(n) & 0xFF)\n\n#define NPC_HOUSE_ID_TO_NPC_ID(house) (house + 0x9000)\n#define NPC_ID_TO_NPC_HOUSE_ID(npc) (npc - 0x9000)\n\n#define ITEM_IS_FTR(n) \\\n  (ITEM_NAME_GET_TYPE(n) == NAME_TYPE_FTR0 || ITEM_NAME_GET_TYPE(n) == NAME_TYPE_FTR1)\n\n#define ITEM_IS_ITEM1(n) (ITEM_NAME_GET_TYPE(n) == NAME_TYPE_ITEM1)\n\n#define GET_NAME_ITEM0_CATEGORY(f) (((f) & 0x0800) >> 11) /* enviornmental or static background objects */\n#define GET_NAME_ITEM1_CATEGORY(f) (((f) & 0x0F00) >> 8)\n\n#define IS_ITEM_FLOWER(item) ((item) >= FLOWER_LEAVES_PANSIES0 && (item) <= FLOWER_TULIP2)\n#define IS_ITEM_ALIVE_TREE(item) \\\n  (((item) >= TREE_SAPLING && (item) <= TREE_30000BELLS) || \\\n   ((item) >= TREE_100BELLS_SAPLING && (item) <= TREE_PALM_FRUIT) || \\\n   ((item) >= CEDAR_TREE_SAPLING && (item) <= CEDAR_TREE) || \\\n   ((item) >= GOLD_TREE_SAPLING && (item) <= GOLD_TREE) \\\n  )\n\n#define IS_ITEM_DEAD_SAPLING(item) \\\n  (((item) == DEAD_SAPLING) || \\\n   ((item) == DEAD_PALM_SAPLING) || \\\n   ((item) == DEAD_CEDAR_SAPLING) || \\\n   ((item) == DEAD_GOLD_SAPLING) \\\n  )\n\n/*\n#define IS_ITEM_TREE(item) \\\n  (((item) >= TREE_SAPLING && (item) <= TREE_30000BELLS) || \\\n   ((item) >= TREE_100BELLS_SAPLING && (item) <= TREE_PALM_FRUIT) || \\\n   ((item) >= CEDAR_TREE_SAPLING && (item) <= CEDAR_TREE) || \\\n   ((item) >= GOLD_TREE_SAPLING && (item) <= GOLD_TREE) || \\\n   ((item) == DEAD_SAPLING) || \\\n   ((item) == DEAD_PALM_SAPLING) || \\\n   ((item) == DEAD_CEDAR_SAPLING) || \\\n   ((item) == DEAD_GOLD_SAPLING) \\\n  )\n*/\n\n#define IS_ITEM_TREE(item) (IS_ITEM_ALIVE_TREE(item) || IS_ITEM_DEAD_SAPLING(item))\n\n#define IS_ITEM_GROWN_TREE(item) \\\n  (((item) == TREE) || \\\n   ((item) == TREE_1000BELLS) || \\\n   ((item) == TREE_10000BELLS) || \\\n   ((item) == TREE_30000BELLS) || \\\n   ((item) == TREE_100BELLS) || \\\n   ((item) == CEDAR_TREE) || \\\n   ((item) == GOLD_TREE_SHOVEL || (item) == GOLD_TREE) || \\\n   ((item) == TREE_APPLE_NOFRUIT_0 || (item) == TREE_APPLE_NOFRUIT_1 || (item) == TREE_APPLE_NOFRUIT_2 || (item) == TREE_APPLE_FRUIT) || \\\n   ((item) == TREE_ORANGE_NOFRUIT_0 || (item) == TREE_ORANGE_NOFRUIT_1 || (item) == TREE_ORANGE_NOFRUIT_2 || (item) == TREE_ORANGE_FRUIT) || \\\n   ((item) == TREE_PEACH_NOFRUIT_0 || (item) == TREE_PEACH_NOFRUIT_1 || (item) == TREE_PEACH_NOFRUIT_2 || (item) == TREE_PEACH_FRUIT) || \\\n   ((item) == TREE_PEAR_NOFRUIT_0 || (item) == TREE_PEAR_NOFRUIT_1 || (item) == TREE_PEAR_NOFRUIT_2 || (item) == TREE_PEAR_FRUIT) || \\\n   ((item) == TREE_CHERRY_NOFRUIT_0 || (item) == TREE_CHERRY_NOFRUIT_1 || (item) == TREE_CHERRY_NOFRUIT_2 || (item) == TREE_CHERRY_FRUIT) || \\\n   ((item) == TREE_PALM_NOFRUIT_0 || (item) == TREE_PALM_NOFRUIT_1 || (item) == TREE_PALM_NOFRUIT_2 || (item) == TREE_PALM_FRUIT) || \\\n   ((item) == TREE_BEES) || \\\n   ((item) == TREE_FTR) || \\\n   ((item) == TREE_LIGHTS) || \\\n   ((item) == TREE_PRESENT) || \\\n   ((item) == TREE_BELLS) || \\\n   ((item) == CEDAR_TREE_BELLS) || \\\n   ((item) == CEDAR_TREE_FTR) || \\\n   ((item) == CEDAR_TREE_BEES) || \\\n   ((item) == CEDAR_TREE_LIGHTS) || \\\n   ((item) == GOLD_TREE_BELLS) || \\\n   ((item) == GOLD_TREE_FTR) || \\\n   ((item) == GOLD_TREE_BEES) \\\n  )\n\n#define IS_ITEM_GRASS(item) ((item) >= GRASS_A && (item) <= GRASS_C) /* aka IS_ITEM_WEED */\n\n#define IS_ITEM_HANIWA(item) ((item) >= HANIWA_START && (item) <= HANIWA_END)\n\n#define IS_ITEM_DIARY(item) ((item) >= ITM_DIARY_START && (item) <= (ITM_DIARY_END-1))\n\n#define BG_CATEGORY 0\n#define ENV_CATEGORY 8\n\n#define EMPTY_NO 0x0000\n#define TREE_STUMP001 (EMPTY_NO + 1)\n#define TREE_STUMP002 (EMPTY_NO + 2)\n#define TREE_STUMP003 (EMPTY_NO + 3)\n#define TREE_STUMP004 (EMPTY_NO + 4)\n#define FENCE0 (EMPTY_NO + 5)\n#define FENCE1 (EMPTY_NO + 6)\n#define MESSAGE_BOARD0 0x0007\n#define GRASS_A 0x0008\n#define GRASS_B (GRASS_A + 1)\n#define GRASS_C (GRASS_B + 1)\n#define MESSAGE_BOARD1 0x000B\n#define MAP_BOARD0 0x000C\n#define MAP_BOARD1 0x000D\n#define MUSIC_BOARD0 0x000E\n#define MUSIC_BOARD1 0x000F\n#define WOOD_FENCE 0x0010\n#define HOLE_START 0x0011\n#define HOLE00 (HOLE_START + 0)\n#define HOLE01 (HOLE_START + 1)\n#define HOLE02 (HOLE_START + 2)\n#define HOLE03 (HOLE_START + 3)\n#define HOLE04 (HOLE_START + 4)\n#define HOLE05 (HOLE_START + 5)\n#define HOLE06 (HOLE_START + 6)\n#define HOLE07 (HOLE_START + 7)\n#define HOLE08 (HOLE_START + 8)\n#define HOLE09 (HOLE_START + 9)\n#define HOLE10 (HOLE_START + 10)\n#define HOLE11 (HOLE_START + 11)\n#define HOLE12 (HOLE_START + 12)\n#define HOLE13 (HOLE_START + 13)\n#define HOLE14 (HOLE_START + 14)\n#define HOLE15 (HOLE_START + 15)\n#define HOLE16 (HOLE_START + 16)\n#define HOLE17 (HOLE_START + 17)\n#define HOLE18 (HOLE_START + 18)\n#define HOLE19 (HOLE_START + 19)\n#define HOLE20 (HOLE_START + 20)\n#define HOLE21 (HOLE_START + 21)\n#define HOLE22 (HOLE_START + 22)\n#define HOLE23 (HOLE_START + 23)\n#define HOLE24 (HOLE_START + 24)\n#define HOLE_END HOLE24\n#define BURIED_PITFALL_START 0x002A\n#define BURIED_PITFALL00 (BURIED_PITFALL_START + 0)\n#define BURIED_PITFALL01 (BURIED_PITFALL_START + 1)\n#define BURIED_PITFALL02 (BURIED_PITFALL_START + 2)\n#define BURIED_PITFALL03 (BURIED_PITFALL_START + 3)\n#define BURIED_PITFALL04 (BURIED_PITFALL_START + 4)\n#define BURIED_PITFALL05 (BURIED_PITFALL_START + 5)\n#define BURIED_PITFALL06 (BURIED_PITFALL_START + 6)\n#define BURIED_PITFALL07 (BURIED_PITFALL_START + 7)\n#define BURIED_PITFALL08 (BURIED_PITFALL_START + 8)\n#define BURIED_PITFALL09 (BURIED_PITFALL_START + 9)\n#define BURIED_PITFALL10 (BURIED_PITFALL_START + 10)\n#define BURIED_PITFALL11 (BURIED_PITFALL_START + 11)\n#define BURIED_PITFALL12 (BURIED_PITFALL_START + 12)\n#define BURIED_PITFALL13 (BURIED_PITFALL_START + 13)\n#define BURIED_PITFALL14 (BURIED_PITFALL_START + 14)\n#define BURIED_PITFALL15 (BURIED_PITFALL_START + 15)\n#define BURIED_PITFALL16 (BURIED_PITFALL_START + 16)\n#define BURIED_PITFALL17 (BURIED_PITFALL_START + 17)\n#define BURIED_PITFALL18 (BURIED_PITFALL_START + 18)\n#define BURIED_PITFALL19 (BURIED_PITFALL_START + 19)\n#define BURIED_PITFALL20 (BURIED_PITFALL_START + 20)\n#define BURIED_PITFALL21 (BURIED_PITFALL_START + 21)\n#define BURIED_PITFALL22 (BURIED_PITFALL_START + 22)\n#define BURIED_PITFALL23 (BURIED_PITFALL_START + 23)\n#define BURIED_PITFALL24 (BURIED_PITFALL_START + 24)\n#define BURIED_PITFALL_END BURIED_PITFALL24\n#define SHINE_SPOT 0x005C\n#define HOLE_SHINE 0x005D\n#define TREE_BEES 0x005E\n#define TREE_FTR (TREE_BEES + 1)\n#define TREE_LIGHTS (TREE_FTR + 1)\n#define TREE_PRESENT (TREE_LIGHTS + 1)\n\n#define HONEYCOMB 0x0062\n#define ROCK_A 0x0063\n#define ROCK_B (ROCK_A + 1)\n#define ROCK_C (ROCK_B + 1)\n#define ROCK_D (ROCK_C + 1)\n#define ROCK_E (ROCK_D + 1)\n\n#define FLOWER_SEED 0x0068\n#define TREE_BELLS 0x0069\n\n#define MONEY_ROCK_A 0x006A\n#define MONEY_ROCK_B (MONEY_ROCK_A + 1)\n#define MONEY_ROCK_C (MONEY_ROCK_B + 1)\n#define MONEY_ROCK_D (MONEY_ROCK_C + 1)\n#define MONEY_ROCK_E (MONEY_ROCK_D + 1)\n\n#define MONEY_FLOWER_SEED 0x006F\n\n#define TREE_PALM_STUMP001 (EMPTY_NO + 112)\n#define TREE_PALM_STUMP002 (EMPTY_NO + 113)\n#define TREE_PALM_STUMP003 (EMPTY_NO + 114)\n#define TREE_PALM_STUMP004 (EMPTY_NO + 115)\n#define CEDAR_TREE_STUMP001 (EMPTY_NO + 116)\n#define CEDAR_TREE_STUMP002 (EMPTY_NO + 117)\n#define CEDAR_TREE_STUMP003 (EMPTY_NO + 118)\n#define CEDAR_TREE_STUMP004 (EMPTY_NO + 119)\n\n#define CEDAR_TREE_BELLS 0x0078\n#define CEDAR_TREE_FTR (CEDAR_TREE_BELLS + 1)\n#define CEDAR_TREE_BEES (CEDAR_TREE_FTR + 1)\n\n#define GOLD_TREE_STUMP001 (EMPTY_NO + 123)\n#define GOLD_TREE_STUMP002 (EMPTY_NO + 124)\n#define GOLD_TREE_STUMP003 (EMPTY_NO + 125)\n#define GOLD_TREE_STUMP004 (EMPTY_NO + 126)\n\n#define GOLD_TREE_BELLS 0x007F\n#define GOLD_TREE_FTR (GOLD_TREE_BELLS + 1)\n#define GOLD_TREE_BEES (GOLD_TREE_FTR + 1)\n#define CEDAR_TREE_LIGHTS (GOLD_TREE_BEES + 1)\n\n/* begin environmental/nature objects */\n#define ENV_START 0x0800\n/* tree */\n#define TREE_SAPLING (ENV_START + 0)\n#define TREE_S0 (ENV_START + 1)\n#define TREE_S1 (ENV_START + 2)\n#define TREE_S2 (ENV_START + 3)\n#define TREE (ENV_START + 4) /* fully grown */\n/* apple tree */\n#define TREE_APPLE_SAPLING (ENV_START + 5)\n#define TREE_APPLE_S0 (ENV_START + 6)\n#define TREE_APPLE_S1 (ENV_START + 7)\n#define TREE_APPLE_S2 (ENV_START + 8)\n#define TREE_APPLE_NOFRUIT_0 (ENV_START + 9) /* fully grown, no fruit */\n#define TREE_APPLE_NOFRUIT_1 (ENV_START + 10)\n#define TREE_APPLE_NOFRUIT_2 (ENV_START + 11)\n#define TREE_APPLE_FRUIT (ENV_START + 12)\n/* orange tree */\n#define TREE_ORANGE_SAPLING (ENV_START + 13)\n#define TREE_ORANGE_S0 (ENV_START + 14)\n#define TREE_ORANGE_S1 (ENV_START + 15)\n#define TREE_ORANGE_S2 (ENV_START + 16) /* fully grown, no fruit */\n#define TREE_ORANGE_NOFRUIT_0 (ENV_START + 17)\n#define TREE_ORANGE_NOFRUIT_1 (ENV_START + 18)\n#define TREE_ORANGE_NOFRUIT_2 (ENV_START + 19)\n#define TREE_ORANGE_FRUIT (ENV_START + 20)\n/* peach tree */\n#define TREE_PEACH_SAPLING (ENV_START + 21)\n#define TREE_PEACH_S0 (ENV_START + 22)\n#define TREE_PEACH_S1 (ENV_START + 23)\n#define TREE_PEACH_S2 (ENV_START + 24)\n#define TREE_PEACH_NOFRUIT_0 (ENV_START + 25) /* fully grown, no fruit */\n#define TREE_PEACH_NOFRUIT_1 (ENV_START + 26)\n#define TREE_PEACH_NOFRUIT_2 (ENV_START + 27)\n#define TREE_PEACH_FRUIT (ENV_START + 28)\n/* pear tree */\n#define TREE_PEAR_SAPLING (ENV_START + 29)\n#define TREE_PEAR_S0 (ENV_START + 30)\n#define TREE_PEAR_S1 (ENV_START + 31)\n#define TREE_PEAR_S2 (ENV_START + 32)\n#define TREE_PEAR_NOFRUIT_0 (ENV_START + 33) /* fully grown, no fruit */\n#define TREE_PEAR_NOFRUIT_1 (ENV_START + 34)\n#define TREE_PEAR_NOFRUIT_2 (ENV_START + 35)\n#define TREE_PEAR_FRUIT (ENV_START + 36)\n/* cherry tree */\n#define TREE_CHERRY_SAPLING (ENV_START + 37)\n#define TREE_CHERRY_S0 (ENV_START + 38)\n#define TREE_CHERRY_S1 (ENV_START + 39)\n#define TREE_CHERRY_S2 (ENV_START + 40)\n#define TREE_CHERRY_NOFRUIT_0 (ENV_START + 41) /* fully grown, no fruit */\n#define TREE_CHERRY_NOFRUIT_1 (ENV_START + 42)\n#define TREE_CHERRY_NOFRUIT_2 (ENV_START + 43)\n#define TREE_CHERRY_FRUIT (ENV_START + 44)\n/* money tree (1,000 Bells) */\n#define TREE_1000BELLS_SAPLING (ENV_START + 45)\n#define TREE_1000BELLS_S0 (ENV_START + 46)\n#define TREE_1000BELLS_S1 (ENV_START + 47)\n#define TREE_1000BELLS_S2 (ENV_START + 48)\n#define TREE_1000BELLS (ENV_START + 49) /* fully grown w/ bells */\n/* money tree (10,000 Bells) */\n#define TREE_10000BELLS_SAPLING (ENV_START + 50)\n#define TREE_10000BELLS_S0 (ENV_START + 51)\n#define TREE_10000BELLS_S1 (ENV_START + 52)\n#define TREE_10000BELLS_S2 (ENV_START + 53)\n#define TREE_10000BELLS (ENV_START + 54) /* fully grown w/ bells */\n/* money tree (30,000 Bells) */\n#define TREE_30000BELLS_SAPLING (ENV_START + 55)\n#define TREE_30000BELLS_S0 (ENV_START + 56)\n#define TREE_30000BELLS_S1 (ENV_START + 57)\n#define TREE_30000BELLS_S2 (ENV_START + 58)\n#define TREE_30000BELLS (ENV_START + 59) /* fully grown w/ bells */\n/* flower leaves (unused growth stage) */\n#define FLOWER_LEAVES_PANSIES0 (ENV_START + 60) /* white */\n#define FLOWER_LEAVES_PANSIES1 (ENV_START + 61) /* purple */\n#define FLOWER_LEAVES_PANSIES2 (ENV_START + 62) /* yellow */\n#define FLOWER_LEAVES_COSMOS0 (ENV_START + 63) /* yellow */\n#define FLOWER_LEAVES_COSMOS1 (ENV_START + 64) /* purple */\n#define FLOWER_LEAVES_COSMOS2 (ENV_START + 65) /* blue */\n#define FLOWER_LEAVES_TULIP0 (ENV_START + 66) /* red */\n#define FLOWER_LEAVES_TULIP1 (ENV_START + 67) /* white */\n#define FLOWER_LEAVES_TULIP2 (ENV_START + 68) /* yellow */\n/* flowers */\n#define FLOWER_PANSIES0 (ENV_START + 69) /* white */\n#define FLOWER_PANSIES1 (ENV_START + 70) /* purple */\n#define FLOWER_PANSIES2 (ENV_START + 71) /* yellow */\n#define FLOWER_COSMOS0 (ENV_START + 72) /* yellow */\n#define FLOWER_COSMOS1 (ENV_START + 73) /* purple */\n#define FLOWER_COSMOS2 (ENV_START + 74) /* blue */\n#define FLOWER_TULIP0 (ENV_START + 75) /* red */\n#define FLOWER_TULIP1 (ENV_START + 76) /* white */\n#define FLOWER_TULIP2 (ENV_START + 77) /* yellow */\n/* dead sapling */\n#define DEAD_SAPLING (ENV_START + 78)\n/* money tree (100 Bells) */\n#define TREE_100BELLS_SAPLING (ENV_START + 79)\n#define TREE_100BELLS_S0 (ENV_START + 80)\n#define TREE_100BELLS_S1 (ENV_START + 81)\n#define TREE_100BELLS_S2 (ENV_START + 82)\n#define TREE_100BELLS (ENV_START + 83) /* fully grown w/ bells */\n/* palm tree */\n#define TREE_PALM_SAPLING (ENV_START + 84)\n#define TREE_PALM_S0 (ENV_START + 85)\n#define TREE_PALM_S1 (ENV_START + 86)\n#define TREE_PALM_S2 (ENV_START + 87)\n#define TREE_PALM_NOFRUIT_0 (ENV_START + 88) /* fully grown, no fruit */\n#define TREE_PALM_NOFRUIT_1 (ENV_START + 89)\n#define TREE_PALM_NOFRUIT_2 (ENV_START + 90)\n#define TREE_PALM_FRUIT (ENV_START + 91)\n#define DEAD_PALM_SAPLING (ENV_START + 92)\n/* cedar tree */\n#define CEDAR_TREE_SAPLING (ENV_START + 93)\n#define CEDAR_TREE_S0 (ENV_START + 94)\n#define CEDAR_TREE_S1 (ENV_START + 95)\n#define CEDAR_TREE_S2 (ENV_START + 96)\n#define CEDAR_TREE (ENV_START + 97) /* fully grown */\n#define DEAD_CEDAR_SAPLING (ENV_START + 98)\n/* gold tree */\n#define GOLD_TREE_SAPLING (ENV_START + 99)\n#define GOLD_TREE_S0 (ENV_START + 100)\n#define GOLD_TREE_S1 (ENV_START + 101)\n#define GOLD_TREE_S2 (ENV_START + 102)\n#define GOLD_TREE_SHOVEL (ENV_START + 103) /* fully grown w/ golden shovel */\n#define GOLD_TREE (ENV_START + 104) /* fully grown */\n#define DEAD_GOLD_SAPLING (ENV_START + 105)\n/* end of environmental objects */\n\n#define SIGNBOARD_START 0x0900\n#define SIGNBOARD (SIGNBOARD_START)\n#define SIGNBOARD0_PLR0 (SIGNBOARD_START + 1)\n#define SIGNBOARD1_PLR0 (SIGNBOARD0_PLR0 + 1)\n#define SIGNBOARD2_PLR0 (SIGNBOARD1_PLR0 + 1)\n#define SIGNBOARD3_PLR0 (SIGNBOARD2_PLR0 + 1)\n#define SIGNBOARD4_PLR0 (SIGNBOARD3_PLR0 + 1)\n#define SIGNBOARD5_PLR0 (SIGNBOARD4_PLR0 + 1)\n#define SIGNBOARD6_PLR0 (SIGNBOARD5_PLR0 + 1)\n#define SIGNBOARD7_PLR0 (SIGNBOARD6_PLR0 + 1)\n#define SIGNBOARD0_PLR1 (SIGNBOARD7_PLR0 + 1)\n#define SIGNBOARD1_PLR1 (SIGNBOARD0_PLR1 + 1)\n#define SIGNBOARD2_PLR1 (SIGNBOARD1_PLR1 + 1)\n#define SIGNBOARD3_PLR1 (SIGNBOARD2_PLR1 + 1)\n#define SIGNBOARD4_PLR1 (SIGNBOARD3_PLR1 + 1)\n#define SIGNBOARD5_PLR1 (SIGNBOARD4_PLR1 + 1)\n#define SIGNBOARD6_PLR1 (SIGNBOARD5_PLR1 + 1)\n#define SIGNBOARD7_PLR1 (SIGNBOARD6_PLR1 + 1)\n#define SIGNBOARD0_PLR2 (SIGNBOARD7_PLR1 + 1)\n#define SIGNBOARD1_PLR2 (SIGNBOARD0_PLR2 + 1)\n#define SIGNBOARD2_PLR2 (SIGNBOARD1_PLR2 + 1)\n#define SIGNBOARD3_PLR2 (SIGNBOARD2_PLR2 + 1)\n#define SIGNBOARD4_PLR2 (SIGNBOARD3_PLR2 + 1)\n#define SIGNBOARD5_PLR2 (SIGNBOARD4_PLR2 + 1)\n#define SIGNBOARD6_PLR2 (SIGNBOARD5_PLR2 + 1)\n#define SIGNBOARD7_PLR2 (SIGNBOARD6_PLR2 + 1)\n#define SIGNBOARD0_PLR3 (SIGNBOARD7_PLR2 + 1)\n#define SIGNBOARD1_PLR3 (SIGNBOARD0_PLR3 + 1)\n#define SIGNBOARD2_PLR3 (SIGNBOARD1_PLR3 + 1)\n#define SIGNBOARD3_PLR3 (SIGNBOARD2_PLR3 + 1)\n#define SIGNBOARD4_PLR3 (SIGNBOARD3_PLR3 + 1)\n#define SIGNBOARD5_PLR3 (SIGNBOARD4_PLR3 + 1)\n#define SIGNBOARD6_PLR3 (SIGNBOARD5_PLR3 + 1)\n#define SIGNBOARD7_PLR3 (SIGNBOARD6_PLR3 + 1)\n\n#define FTR0_START 0x1000\n#define FTR_CLASSIC_WARDROBE 0x1004\n#define FTR_PAPA_BEAR 0x10E8\n#define FTR_PAPA_BEAR_EAST 0x10E9\n#define FTR_PAPA_BEAR_NORTH 0x10EA\n#define FTR_PAPA_BEAR_WEST 0x10EB\n\n#define FTR_BIRTHDAY_CAKE 0x11FC\n#define FTR_BIRTHDAY_CAKE_EAST 0x11FD\n#define FTR_BIRTHDAY_CAKE_NORTH 0x11FE\n#define FTR_BIRTHDAY_CAKE_WEST 0x11FF\n\n#define FTR_PAINTING0 0x12AC // famous painting\n\n#define FTR_PAINTING14 0x12E4 // worthy painting\n#define FTR_PAINTING14_EAST 0x12E5\n#define FTR_PAINTING14_NORTH 0x12E6\n#define FTR_PAINTING14_WEST 0x12E7\n\n#define FTR_DRACAENA 0x13B0\n#define FTR_DRACAENA_EAST 0x13B1\n#define FTR_DRACAENA_NORTH 0x13B2\n#define FTR_DRACAENA_WEST 0x13B3\n\n#define HANIWA_START 0x15B0\n//\n#define HANIWA_END 0x17AB\n\n#define FTR_CLOTH_START 0x17AC\n#define FTR_CLOTH_MANNIQUIN000_SOUTH FTR_CLOTH_START\n\n#define FTR_REDALOHASHIRT 0x1814\n\n#define FTR_BLUEALOHASHIRT 0x1818\n\n#define FTR_CLOTH_MANNIQUIN254_SOUTH 0x1BA4\n#define FTR_CLOTH_MANNIQUIN254_WEST 0x1BA7\n#define FTR_CLOTH_END FTR_CLOTH_MANNIQUIN254_WEST\n#define FTR_CLOTH_MANNIQUIN_MY_ORIGINAL0 0x1BA8\n\n#define FTR_INSECT_START 0x1BC8\n#define FTR_INSECT00 FTR_INSECT_START\n\n#define FTR_INSECT39 0x1C64\n#define FTR_INSECT39_EAST 0x1C65\n#define FTR_INSECT39_NORTH 0x1C66\n#define FTR_INSECT39_WEST 0x1C67\n#define FTR_INSECT_END FTR_INSECT39_WEST\n#define FTR_FISH_START 0x1C68\n#define FTR_FISH00 FTR_FISH_START\n\n#define FTR_FISH39 0x1D04\n#define FTR_FISH39_EAST 0x1D05\n#define FTR_FISH39_NORTH 0x1D06\n#define FTR_FISH39_WEST 0x1D07\n#define FTR_FISH_END FTR_FISH39_WEST\n#define FTR_UMBRELLA_START 0x1D08\n#define FTR_UMBRELLA00_SOUTH FTR_UMBRELLA_START\n\n#define FTR_UMBRELLA31_WEST 0x1D87\n#define FTR_UMBRELLA_END FTR_UMBRELLA31_WEST\n\n#define FTR_FAMICOM_START 0x1DA8\n#define FTR_FAMICOM_CLU_CLU_LAND FTR_FAMICOM_START\n#define FTR_FAMICOM_BALLOON_FIGHT 0x1DAC\n#define FTR_FAMICOM_DONKEY_KONG 0x1DB0\n#define FTR_FAMICOM_DK_JR_MATCH 0x1DB4\n#define FTR_FAMICOM_PINBALL 0x1DB8\n#define FTR_FAMICOM_TENNIS 0x1DBC\n#define FTR_FAMICOM_GOLF 0x1DC0\n#define FTR_FAMICOM_PUNCHOUT 0x1DC4\n#define FTR_FAMICOM_BASEBALL 0x1DC8\n#define FTR_FAMICOM_CLU_CLU_LAND_DISK 0x1DCC\n#define FTR_FAMICOM_DONKEY_KONG_3 0x1DD0\n#define FTR_FAMICOM_DONKEY_KONG_JR 0x1DD4\n#define FTR_FAMICOM_SOCCER 0x1DD8\n#define FTR_FAMICOM_EXCITEBIKE 0x1DDC\n#define FTR_FAMICOM_WARIOS_WOODS 0x1DE0\n#define FTR_FAMICOM_ICE_CLIMBERS 0x1DE4\n#define FTR_FAMICOM_MARIO_BROS 0x1DE8\n#define FTR_FAMICOM_SUPER_MARIO_BROS 0x1DEC\n#define FTR_FAMICOM_LEGEND_OF_ZELDA 0x1DF0\n#define FTR_FAMICOM_END 0x1DF3\n#define FTR_FAMICOM 0x1DF4\n\n#define FTR_TAPEDECK 0x1E58\n\n#define FTR_BIG_FESTIVE_TREE 0x1E88\n\n#define FTR_FESTIVE_TREE 0x1EBC\n\n#define FTR_DINO_START 0x1EEC\n#define FTR_DINO_TRICERA_SKULL FTR_DINO_START\n#define FTR_DINO_TRICERA_TAIL 0x1EF0\n#define FTR_DINO_TRICERA_BODY 0x1EF4\n#define FTR_DINO_TREX_SKULL 0x1EF8\n#define FTR_DINO_TREX_TAIL 0x1EFC\n#define FTR_DINO_TREX_BODY 0x1F00\n#define FTR_DINO_APATO_SKULL 0x1F04\n#define FTR_DINO_APATO_TAIL 0x1F08\n#define FTR_DINO_APATO_BODY 0x1F0C\n#define FTR_DINO_STEGO_SKULL 0x1F10\n#define FTR_DINO_STEGO_TAIL 0x1F14\n#define FTR_DINO_STEGO_BODY 0x1F18\n#define FTR_DINO_PTERA_SKULL 0x1F1C\n#define FTR_DINO_PTERA_RIGHT_WING 0x1F20\n#define FTR_DINO_PTERA_LEFT_WING 0x1F24\n#define FTR_DINO_PLESIO_SKULL 0x1F28\n#define FTR_DINO_PLESIO_NECK 0x1F2C\n#define FTR_DINO_PLESIO_TORSO 0x1F30\n#define FTR_DINO_MAMMOTH_SKULL 0x1F34\n#define FTR_DINO_MAMMOTH_TORSO 0x1F38\n#define FTR_FOSSIL_AMBER 0x1F3C\n#define FTR_FOSSIL_TRACK 0x1F40\n#define FTR_FOSSIL_AMMONITE 0x1F44\n#define FTR_FOSSIL_EGG 0x1F48\n#define FTR_FOSSIL_TRILOBITE 0x1F4C\n//\n#define FTR_DINO_TRILOBITE_WEST 0x1F4F\n#define FTR_DINO_END FTR_DINO_TRILOBITE_WEST\n\n#define FTR_DINO_DISP_TRICERA 0x1F7C\n#define FTR_DINO_DISP_TREX 0x1F80\n#define FTR_DINO_DISP_BRONTO 0x1F84\n#define FTR_DINO_DISP_PTERA 0x1F88\n#define FTR_DINO_DISP_PLESIO 0x1F8C\n#define FTR_DINO_DISP_MAMMOTH 0x1F90\n#define FTR_DINO_DISP_STEGO 0x1F94\n#define FTR_DINO_DISP_STEGO2 0x1F98\n#define FTR_FOSSIL 0x1F9C\n#define FTR_SHOGI_PIECE 0x1FA0\n#define FTR_CHOCOLATES 0x1FA4\n#define FTR_POST_BOX 0x1FA8\n#define FTR_PIGGY_BANK 0x1FAC\n#define FTR_TISSUE 0x1FB0\n#define FTR_TRIBAL_MASK 0x1FB4\n#define FTR_MATRYOSHKA 0x1FB8\n#define FTR_FAMICOM_LEGEND_OF_ZELDA_DISK 0x1FBC\n#define FTR_BOTTLED_SHIP 0x1FC0\n#define FTR_TIGER_BOBBLEHEAD 0x1FC4\n#define FTR_MOAI_STATUE 0x1FC8\n#define FTR_AEROBICS_RADIO 0x1FCC\n#define FTR_PAGODA 0x1FD0\n#define FTR_FISHING_BEAR 0x1FD4\n#define FTR_MOUTH_OF_TRUTH 0x1FD8\n#define FTR_CHINESE_LIONESS 0x1FDC\n#define FTR_TOWER_OF_PISA 0x1FE0\n#define FTR_MERLION 0x1FE4\n#define FTR_MANEKIN_PIS 0x1FE8\n#define FTR_TOKYO_TOWER 0x1FEC\n#define FTR_RED_BALLOON 0x1FF0\n#define FTR_YELLOW_BALLOON 0x1FF4\n#define FTR_BLUE_BALLOON 0x1FF8\n#define FTR_GREE_BALLOON 0x1FFC\n#define FTR0_END 0x1FFF\n\n#define ITM_PAPER_START 0x2000\n#define ITM_PAPER00 (ITM_PAPER_START +   0)\n#define ITM_PAPER01 (ITM_PAPER_START +   1)\n#define ITM_PAPER02 (ITM_PAPER_START +   2)\n#define ITM_PAPER03 (ITM_PAPER_START +   3)\n#define ITM_PAPER04 (ITM_PAPER_START +   4)\n#define ITM_PAPER05 (ITM_PAPER_START +   5)\n#define ITM_PAPER06 (ITM_PAPER_START +   6)\n#define ITM_PAPER07 (ITM_PAPER_START +   7)\n#define ITM_PAPER08 (ITM_PAPER_START +   8)\n#define ITM_PAPER09 (ITM_PAPER_START +   9)\n#define ITM_PAPER10 (ITM_PAPER_START +  10)\n#define ITM_PAPER11 (ITM_PAPER_START +  11)\n#define ITM_PAPER12 (ITM_PAPER_START +  12)\n#define ITM_PAPER13 (ITM_PAPER_START +  13)\n#define ITM_PAPER14 (ITM_PAPER_START +  14)\n#define ITM_PAPER15 (ITM_PAPER_START +  15)\n#define ITM_PAPER16 (ITM_PAPER_START +  16)\n#define ITM_PAPER17 (ITM_PAPER_START +  17)\n#define ITM_PAPER18 (ITM_PAPER_START +  18)\n#define ITM_PAPER19 (ITM_PAPER_START +  19)\n#define ITM_PAPER20 (ITM_PAPER_START +  20)\n#define ITM_PAPER21 (ITM_PAPER_START +  21)\n#define ITM_PAPER22 (ITM_PAPER_START +  22)\n#define ITM_PAPER23 (ITM_PAPER_START +  23)\n#define ITM_PAPER24 (ITM_PAPER_START +  24)\n#define ITM_PAPER25 (ITM_PAPER_START +  25)\n#define ITM_PAPER26 (ITM_PAPER_START +  26)\n#define ITM_PAPER27 (ITM_PAPER_START +  27)\n#define ITM_PAPER28 (ITM_PAPER_START +  28)\n#define ITM_PAPER29 (ITM_PAPER_START +  29)\n#define ITM_PAPER30 (ITM_PAPER_START +  30)\n#define ITM_PAPER31 (ITM_PAPER_START +  31)\n#define ITM_PAPER32 (ITM_PAPER_START +  32)\n#define ITM_PAPER33 (ITM_PAPER_START +  33)\n#define ITM_PAPER34 (ITM_PAPER_START +  34)\n#define ITM_PAPER35 (ITM_PAPER_START +  35)\n#define ITM_PAPER36 (ITM_PAPER_START +  36)\n#define ITM_PAPER37 (ITM_PAPER_START +  37)\n#define ITM_PAPER38 (ITM_PAPER_START +  38)\n#define ITM_PAPER39 (ITM_PAPER_START +  39)\n#define ITM_PAPER40 (ITM_PAPER_START +  40)\n#define ITM_PAPER41 (ITM_PAPER_START +  41)\n#define ITM_PAPER42 (ITM_PAPER_START +  42)\n#define ITM_PAPER43 (ITM_PAPER_START +  43)\n#define ITM_PAPER44 (ITM_PAPER_START +  44)\n#define ITM_PAPER45 (ITM_PAPER_START +  45)\n#define ITM_PAPER46 (ITM_PAPER_START +  46)\n#define ITM_PAPER47 (ITM_PAPER_START +  47)\n#define ITM_PAPER48 (ITM_PAPER_START +  48)\n#define ITM_PAPER49 (ITM_PAPER_START +  49)\n#define ITM_PAPER50 (ITM_PAPER_START +  50)\n#define ITM_PAPER51 (ITM_PAPER_START +  51)\n#define ITM_PAPER52 (ITM_PAPER_START +  52)\n#define ITM_PAPER53 (ITM_PAPER_START +  53)\n#define ITM_PAPER54 (ITM_PAPER_START +  54)\n#define ITM_PAPER55 (ITM_PAPER_START +  55)\n#define ITM_PAPER56 (ITM_PAPER_START +  56)\n#define ITM_PAPER57 (ITM_PAPER_START +  57)\n#define ITM_PAPER58 (ITM_PAPER_START +  58)\n#define ITM_PAPER59 (ITM_PAPER_START +  59)\n#define ITM_PAPER60 (ITM_PAPER_START +  60)\n#define ITM_PAPER61 (ITM_PAPER_START +  61)\n#define ITM_PAPER62 (ITM_PAPER_START +  62)\n#define ITM_PAPER63 (ITM_PAPER_START +  63)\n#define ITM_PAPER_STACK_TWO_START 0x2040\n#define ITM_PAPER_STACK_THREE_START 0x2080\n#define ITM_PAPER_STACK_FOUR_START 0x20C0\n#define ITM_PAPER_END (ITM_PAPER_START + 256)\n\n#define ITM_MONEY_START 0x2100\n#define ITM_MONEY_1000 ITM_MONEY_START // 0x2100\n#define ITM_MONEY_10000 (ITM_MONEY_1000 + 1) // 0x2101\n#define ITM_MONEY_30000 (ITM_MONEY_10000 + 1) // 0x2102\n#define ITM_MONEY_100 (ITM_MONEY_30000 + 1) // 0x2103\n#define ITM_MONEY_END ITM_MONEY_100 // 0x2103\n\n#define ITM_TOOL_START 0x2200\n#define ITM_NET ITM_TOOL_START\n#define ITM_AXE 0x2201\n#define ITM_SHOVEL 0x2202\n#define ITM_ROD 0x2203\n#define ITM_UMBRELLA_START (ITM_TOOL_START + 4)\n#define ITM_GELATO_UMBRELLA 0x2204\n#define ITM_DAFFODIL_PARASOL 0x2205\n// TODO: other umbrellas\n#define ITM_FLAME_UMBRELLA 0x2223\n#define ITM_MY_ORG_UMBRELLA0 0x2224\n#define ITM_MY_ORG_UMBRELLA1 0x2225\n#define ITM_MY_ORG_UMBRELLA2 0x2226\n#define ITM_MY_ORG_UMBRELLA3 0x2227\n#define ITM_MY_ORG_UMBRELLA4 0x2228\n#define ITM_MY_ORG_UMBRELLA5 0x2229\n#define ITM_MY_ORG_UMBRELLA6 0x222A\n#define ITM_MY_ORG_UMBRELLA7 0x222B\n#define ITM_UMBRELLA_END (ITM_TOOL_START + 44)\n#define ITM_SICKLE 0x222C\n#define ITM_RED_PAINT 0x222D\n#define ITM_ORANGE_PAINT 0x222E\n#define ITM_YELLOW_PAINT 0x222F\n#define ITM_PALE_GREEN_PAINT 0x2230\n#define ITM_GREEN_PAINT 0x2231\n#define ITM_SKY_BLUE_PAINT 0x2232\n#define ITM_BLUE_PAINT 0x2233\n#define ITM_PURPLE_PAINT 0x2234\n#define ITM_PINK_PAINT 0x2235\n#define ITM_BLACK_PAINT 0x2236\n#define ITM_WHITE_PAINT 0x2237\n#define ITM_BROWN_PAINT 0x2238\n#define ITM_GOLDEN_NET 0x2239\n#define ITM_GOLDEN_AXE 0x223A\n#define ITM_GOLDEN_SHOVEL 0x223B\n#define ITM_GOLDEN_ROD 0x223C\n#define ITM_AXE_USE_1 0x223D\n#define ITM_AXE_USE_2 0x223E\n#define ITM_AXE_USE_3 0x223F\n#define ITM_AXE_USE_4 0x2240\n#define ITM_AXE_USE_5 0x2241\n#define ITM_AXE_USE_6 0x2242\n#define ITM_AXE_USE_7 0x2243\n#define ITM_BALLOON_START (ITM_TOOL_START + 68)\n#define ITM_RED_BALLOON 0x2244\n#define ITM_YELLOW_BALLOON 0x2245\n#define ITM_BLUE_BALLOON 0x2246\n#define ITM_GREEN_BALLOON 0x2247\n#define ITM_PURPLE_BALLOON 0x2248\n#define ITM_BUNNY_P_BALLOON 0x2249\n#define ITM_BUNNY_B_BALLOON 0x224A\n#define ITM_BUNNY_O_BALLOON 0x224B\n#define ITM_YELLOW_PINWHEEL 0x224C\n#define ITM_RED_PINWHEEL 0x224D\n#define ITM_TIGER_PINWHEEL 0x224E\n#define ITM_GREEN_PINWHEEL 0x224F\n#define ITM_PINK_PINWHEEL 0x2250\n#define ITM_STRIPED_PINWHEEL 0x2251\n#define ITM_FLOWER_PINWHEEL 0x2252\n#define ITM_FANCY_PINWHEEL 0x2253\n#define ITM_BLUEBELL_FAN 0x2254\n#define ITM_PLUM_FAN 0x2255\n#define ITM_BAMBOO_FAN 0x2256\n#define ITM_CLOUD_FAN 0x2257\n#define ITM_MAPLE_FAN 0x2258\n#define ITM_FAN_FAN 0x2259\n#define ITM_FLOWER_FAN 0x225A\n#define ITM_LEAF_FAN 0x225B\n#define ITM_TOOL_END (ITM_LEAF_FAN + 1)\n\n#define ITM_FISH_START 0x2300\n#define ITM_FISH00 (ITM_FISH_START + 0)\n#define ITM_FISH01 (ITM_FISH_START + 1)\n#define ITM_FISH02 (ITM_FISH_START + 2)\n#define ITM_FISH03 (ITM_FISH_START + 3)\n#define ITM_FISH04 (ITM_FISH_START + 4)\n#define ITM_FISH05 (ITM_FISH_START + 5)\n#define ITM_FISH06 (ITM_FISH_START + 6)\n#define ITM_FISH07 (ITM_FISH_START + 7)\n#define ITM_FISH08 (ITM_FISH_START + 8)\n#define ITM_FISH09 (ITM_FISH_START + 9)\n#define ITM_FISH10 (ITM_FISH_START + 10)\n#define ITM_FISH11 (ITM_FISH_START + 11)\n#define ITM_FISH12 (ITM_FISH_START + 12)\n#define ITM_FISH13 (ITM_FISH_START + 13)\n#define ITM_FISH14 (ITM_FISH_START + 14)\n#define ITM_FISH15 (ITM_FISH_START + 15)\n#define ITM_FISH16 (ITM_FISH_START + 16)\n#define ITM_FISH17 (ITM_FISH_START + 17)\n#define ITM_FISH18 (ITM_FISH_START + 18)\n#define ITM_FISH19 (ITM_FISH_START + 19)\n#define ITM_FISH20 (ITM_FISH_START + 20)\n#define ITM_FISH21 (ITM_FISH_START + 21)\n#define ITM_FISH22 (ITM_FISH_START + 22)\n#define ITM_FISH23 (ITM_FISH_START + 23)\n#define ITM_FISH24 (ITM_FISH_START + 24)\n#define ITM_FISH25 (ITM_FISH_START + 25)\n#define ITM_FISH26 (ITM_FISH_START + 26)\n#define ITM_FISH27 (ITM_FISH_START + 27)\n#define ITM_FISH28 (ITM_FISH_START + 28)\n#define ITM_FISH29 (ITM_FISH_START + 29)\n#define ITM_FISH30 (ITM_FISH_START + 30)\n#define ITM_FISH31 (ITM_FISH_START + 31)\n#define ITM_FISH32 (ITM_FISH_START + 32)\n#define ITM_FISH33 (ITM_FISH_START + 33)\n#define ITM_FISH34 (ITM_FISH_START + 34)\n#define ITM_FISH35 (ITM_FISH_START + 35)\n#define ITM_FISH36 (ITM_FISH_START + 36)\n#define ITM_FISH37 (ITM_FISH_START + 37)\n#define ITM_FISH38 (ITM_FISH_START + 38)\n#define ITM_FISH39 (ITM_FISH_START + 39)\n#define ITM_FISH_END (ITM_FISH_START + 40)\n\n#define ITM_CLOTH_START 0x2400\n#define ITM_CLOTH000 (ITM_CLOTH_START +   0)\n#define ITM_CLOTH001 (ITM_CLOTH_START +   1)\n#define ITM_CLOTH002 (ITM_CLOTH_START +   2)\n#define ITM_CLOTH003 (ITM_CLOTH_START +   3)\n#define ITM_CLOTH004 (ITM_CLOTH_START +   4)\n#define ITM_CLOTH005 (ITM_CLOTH_START +   5)\n#define ITM_CLOTH006 (ITM_CLOTH_START +   6)\n#define ITM_CLOTH007 (ITM_CLOTH_START +   7)\n#define ITM_CLOTH008 (ITM_CLOTH_START +   8)\n#define ITM_CLOTH009 (ITM_CLOTH_START +   9)\n#define ITM_CLOTH010 (ITM_CLOTH_START +  10)\n#define ITM_CLOTH011 (ITM_CLOTH_START +  11)\n#define ITM_CLOTH012 (ITM_CLOTH_START +  12)\n#define ITM_CLOTH013 (ITM_CLOTH_START +  13)\n#define ITM_CLOTH014 (ITM_CLOTH_START +  14)\n#define ITM_CLOTH015 (ITM_CLOTH_START +  15)\n#define ITM_CLOTH016 (ITM_CLOTH_START +  16)\n#define ITM_CLOTH017 (ITM_CLOTH_START +  17)\n#define ITM_CLOTH018 (ITM_CLOTH_START +  18)\n#define ITM_CLOTH019 (ITM_CLOTH_START +  19)\n#define ITM_CLOTH020 (ITM_CLOTH_START +  20)\n#define ITM_CLOTH021 (ITM_CLOTH_START +  21)\n#define ITM_CLOTH022 (ITM_CLOTH_START +  22)\n#define ITM_CLOTH023 (ITM_CLOTH_START +  23)\n#define ITM_CLOTH024 (ITM_CLOTH_START +  24)\n#define ITM_CLOTH025 (ITM_CLOTH_START +  25)\n#define ITM_CLOTH026 (ITM_CLOTH_START +  26)\n#define ITM_CLOTH027 (ITM_CLOTH_START +  27)\n#define ITM_CLOTH028 (ITM_CLOTH_START +  28)\n#define ITM_CLOTH029 (ITM_CLOTH_START +  29)\n#define ITM_CLOTH030 (ITM_CLOTH_START +  30)\n#define ITM_CLOTH031 (ITM_CLOTH_START +  31)\n#define ITM_CLOTH032 (ITM_CLOTH_START +  32)\n#define ITM_CLOTH033 (ITM_CLOTH_START +  33)\n#define ITM_CLOTH034 (ITM_CLOTH_START +  34)\n#define ITM_CLOTH035 (ITM_CLOTH_START +  35)\n#define ITM_CLOTH036 (ITM_CLOTH_START +  36)\n#define ITM_CLOTH037 (ITM_CLOTH_START +  37)\n#define ITM_CLOTH038 (ITM_CLOTH_START +  38)\n#define ITM_CLOTH039 (ITM_CLOTH_START +  39)\n#define ITM_CLOTH040 (ITM_CLOTH_START +  40)\n#define ITM_CLOTH041 (ITM_CLOTH_START +  41)\n#define ITM_CLOTH042 (ITM_CLOTH_START +  42)\n#define ITM_CLOTH043 (ITM_CLOTH_START +  43)\n#define ITM_CLOTH044 (ITM_CLOTH_START +  44)\n#define ITM_CLOTH045 (ITM_CLOTH_START +  45)\n#define ITM_CLOTH046 (ITM_CLOTH_START +  46)\n#define ITM_CLOTH047 (ITM_CLOTH_START +  47)\n#define ITM_CLOTH048 (ITM_CLOTH_START +  48)\n#define ITM_CLOTH049 (ITM_CLOTH_START +  49)\n#define ITM_CLOTH050 (ITM_CLOTH_START +  50)\n#define ITM_CLOTH051 (ITM_CLOTH_START +  51)\n#define ITM_CLOTH052 (ITM_CLOTH_START +  52)\n#define ITM_CLOTH053 (ITM_CLOTH_START +  53)\n#define ITM_CLOTH054 (ITM_CLOTH_START +  54)\n#define ITM_CLOTH055 (ITM_CLOTH_START +  55)\n#define ITM_CLOTH056 (ITM_CLOTH_START +  56)\n#define ITM_CLOTH057 (ITM_CLOTH_START +  57)\n#define ITM_CLOTH058 (ITM_CLOTH_START +  58)\n#define ITM_CLOTH059 (ITM_CLOTH_START +  59)\n#define ITM_CLOTH060 (ITM_CLOTH_START +  60)\n#define ITM_CLOTH061 (ITM_CLOTH_START +  61)\n#define ITM_CLOTH062 (ITM_CLOTH_START +  62)\n#define ITM_CLOTH063 (ITM_CLOTH_START +  63)\n#define ITM_CLOTH064 (ITM_CLOTH_START +  64)\n#define ITM_CLOTH065 (ITM_CLOTH_START +  65)\n#define ITM_CLOTH066 (ITM_CLOTH_START +  66)\n#define ITM_CLOTH067 (ITM_CLOTH_START +  67)\n#define ITM_CLOTH068 (ITM_CLOTH_START +  68)\n#define ITM_CLOTH069 (ITM_CLOTH_START +  69)\n#define ITM_CLOTH070 (ITM_CLOTH_START +  70)\n#define ITM_CLOTH071 (ITM_CLOTH_START +  71)\n#define ITM_CLOTH072 (ITM_CLOTH_START +  72)\n#define ITM_CLOTH073 (ITM_CLOTH_START +  73)\n#define ITM_CLOTH074 (ITM_CLOTH_START +  74)\n#define ITM_CLOTH075 (ITM_CLOTH_START +  75)\n#define ITM_CLOTH076 (ITM_CLOTH_START +  76)\n#define ITM_CLOTH077 (ITM_CLOTH_START +  77)\n#define ITM_CLOTH078 (ITM_CLOTH_START +  78)\n#define ITM_CLOTH079 (ITM_CLOTH_START +  79)\n#define ITM_CLOTH080 (ITM_CLOTH_START +  80)\n#define ITM_CLOTH081 (ITM_CLOTH_START +  81)\n#define ITM_CLOTH082 (ITM_CLOTH_START +  82)\n#define ITM_CLOTH083 (ITM_CLOTH_START +  83)\n#define ITM_CLOTH084 (ITM_CLOTH_START +  84)\n#define ITM_CLOTH085 (ITM_CLOTH_START +  85)\n#define ITM_CLOTH086 (ITM_CLOTH_START +  86)\n#define ITM_CLOTH087 (ITM_CLOTH_START +  87)\n#define ITM_CLOTH088 (ITM_CLOTH_START +  88)\n#define ITM_CLOTH089 (ITM_CLOTH_START +  89)\n#define ITM_CLOTH090 (ITM_CLOTH_START +  90)\n#define ITM_CLOTH091 (ITM_CLOTH_START +  91)\n#define ITM_CLOTH092 (ITM_CLOTH_START +  92)\n#define ITM_CLOTH093 (ITM_CLOTH_START +  93)\n#define ITM_CLOTH094 (ITM_CLOTH_START +  94)\n#define ITM_CLOTH095 (ITM_CLOTH_START +  95)\n#define ITM_CLOTH096 (ITM_CLOTH_START +  96)\n#define ITM_CLOTH097 (ITM_CLOTH_START +  97)\n#define ITM_CLOTH098 (ITM_CLOTH_START +  98)\n#define ITM_CLOTH099 (ITM_CLOTH_START +  99)\n#define ITM_CLOTH100 (ITM_CLOTH_START + 100)\n#define ITM_CLOTH101 (ITM_CLOTH_START + 101)\n#define ITM_CLOTH102 (ITM_CLOTH_START + 102)\n#define ITM_CLOTH103 (ITM_CLOTH_START + 103)\n#define ITM_CLOTH104 (ITM_CLOTH_START + 104)\n#define ITM_CLOTH105 (ITM_CLOTH_START + 105)\n#define ITM_CLOTH106 (ITM_CLOTH_START + 106)\n#define ITM_CLOTH107 (ITM_CLOTH_START + 107)\n#define ITM_CLOTH108 (ITM_CLOTH_START + 108)\n#define ITM_CLOTH109 (ITM_CLOTH_START + 109)\n#define ITM_CLOTH110 (ITM_CLOTH_START + 110)\n#define ITM_CLOTH111 (ITM_CLOTH_START + 111)\n#define ITM_CLOTH112 (ITM_CLOTH_START + 112)\n#define ITM_CLOTH113 (ITM_CLOTH_START + 113)\n#define ITM_CLOTH114 (ITM_CLOTH_START + 114)\n#define ITM_CLOTH115 (ITM_CLOTH_START + 115)\n#define ITM_CLOTH116 (ITM_CLOTH_START + 116)\n#define ITM_CLOTH117 (ITM_CLOTH_START + 117)\n#define ITM_CLOTH118 (ITM_CLOTH_START + 118)\n#define ITM_CLOTH119 (ITM_CLOTH_START + 119)\n#define ITM_CLOTH120 (ITM_CLOTH_START + 120)\n#define ITM_CLOTH121 (ITM_CLOTH_START + 121)\n#define ITM_CLOTH122 (ITM_CLOTH_START + 122)\n#define ITM_CLOTH123 (ITM_CLOTH_START + 123)\n#define ITM_CLOTH124 (ITM_CLOTH_START + 124)\n#define ITM_CLOTH125 (ITM_CLOTH_START + 125)\n#define ITM_CLOTH126 (ITM_CLOTH_START + 126)\n#define ITM_CLOTH127 (ITM_CLOTH_START + 127)\n#define ITM_CLOTH128 (ITM_CLOTH_START + 128)\n#define ITM_CLOTH129 (ITM_CLOTH_START + 129)\n#define ITM_CLOTH130 (ITM_CLOTH_START + 130)\n#define ITM_CLOTH131 (ITM_CLOTH_START + 131)\n#define ITM_CLOTH132 (ITM_CLOTH_START + 132)\n#define ITM_CLOTH133 (ITM_CLOTH_START + 133)\n#define ITM_CLOTH134 (ITM_CLOTH_START + 134)\n#define ITM_CLOTH135 (ITM_CLOTH_START + 135)\n#define ITM_CLOTH136 (ITM_CLOTH_START + 136)\n#define ITM_CLOTH137 (ITM_CLOTH_START + 137)\n#define ITM_CLOTH138 (ITM_CLOTH_START + 138)\n#define ITM_CLOTH139 (ITM_CLOTH_START + 139)\n#define ITM_CLOTH140 (ITM_CLOTH_START + 140)\n#define ITM_CLOTH141 (ITM_CLOTH_START + 141)\n#define ITM_CLOTH142 (ITM_CLOTH_START + 142)\n#define ITM_CLOTH143 (ITM_CLOTH_START + 143)\n#define ITM_CLOTH144 (ITM_CLOTH_START + 144)\n#define ITM_CLOTH145 (ITM_CLOTH_START + 145)\n#define ITM_CLOTH146 (ITM_CLOTH_START + 146)\n#define ITM_CLOTH147 (ITM_CLOTH_START + 147)\n#define ITM_CLOTH148 (ITM_CLOTH_START + 148)\n#define ITM_CLOTH149 (ITM_CLOTH_START + 149)\n#define ITM_CLOTH150 (ITM_CLOTH_START + 150)\n#define ITM_CLOTH151 (ITM_CLOTH_START + 151)\n#define ITM_CLOTH152 (ITM_CLOTH_START + 152)\n#define ITM_CLOTH153 (ITM_CLOTH_START + 153)\n#define ITM_CLOTH154 (ITM_CLOTH_START + 154)\n#define ITM_CLOTH155 (ITM_CLOTH_START + 155)\n#define ITM_CLOTH156 (ITM_CLOTH_START + 156)\n#define ITM_CLOTH157 (ITM_CLOTH_START + 157)\n#define ITM_CLOTH158 (ITM_CLOTH_START + 158)\n#define ITM_CLOTH159 (ITM_CLOTH_START + 159)\n#define ITM_CLOTH160 (ITM_CLOTH_START + 160)\n#define ITM_CLOTH161 (ITM_CLOTH_START + 161)\n#define ITM_CLOTH162 (ITM_CLOTH_START + 162)\n#define ITM_CLOTH163 (ITM_CLOTH_START + 163)\n#define ITM_CLOTH164 (ITM_CLOTH_START + 164)\n#define ITM_CLOTH165 (ITM_CLOTH_START + 165)\n#define ITM_CLOTH166 (ITM_CLOTH_START + 166)\n#define ITM_CLOTH167 (ITM_CLOTH_START + 167)\n#define ITM_CLOTH168 (ITM_CLOTH_START + 168)\n#define ITM_CLOTH169 (ITM_CLOTH_START + 169)\n#define ITM_CLOTH170 (ITM_CLOTH_START + 170)\n#define ITM_CLOTH171 (ITM_CLOTH_START + 171)\n#define ITM_CLOTH172 (ITM_CLOTH_START + 172)\n#define ITM_CLOTH173 (ITM_CLOTH_START + 173)\n#define ITM_CLOTH174 (ITM_CLOTH_START + 174)\n#define ITM_CLOTH175 (ITM_CLOTH_START + 175)\n#define ITM_CLOTH176 (ITM_CLOTH_START + 176)\n#define ITM_CLOTH177 (ITM_CLOTH_START + 177)\n#define ITM_CLOTH178 (ITM_CLOTH_START + 178)\n#define ITM_CLOTH179 (ITM_CLOTH_START + 179)\n#define ITM_CLOTH180 (ITM_CLOTH_START + 180)\n#define ITM_CLOTH181 (ITM_CLOTH_START + 181)\n#define ITM_CLOTH182 (ITM_CLOTH_START + 182)\n#define ITM_CLOTH183 (ITM_CLOTH_START + 183)\n#define ITM_CLOTH184 (ITM_CLOTH_START + 184)\n#define ITM_CLOTH185 (ITM_CLOTH_START + 185)\n#define ITM_CLOTH186 (ITM_CLOTH_START + 186)\n#define ITM_CLOTH187 (ITM_CLOTH_START + 187)\n#define ITM_CLOTH188 (ITM_CLOTH_START + 188)\n#define ITM_CLOTH189 (ITM_CLOTH_START + 189)\n#define ITM_CLOTH190 (ITM_CLOTH_START + 190)\n#define ITM_CLOTH191 (ITM_CLOTH_START + 191)\n#define ITM_CLOTH192 (ITM_CLOTH_START + 192)\n#define ITM_CLOTH193 (ITM_CLOTH_START + 193)\n#define ITM_CLOTH194 (ITM_CLOTH_START + 194)\n#define ITM_CLOTH195 (ITM_CLOTH_START + 195)\n#define ITM_CLOTH196 (ITM_CLOTH_START + 196)\n#define ITM_CLOTH197 (ITM_CLOTH_START + 197)\n#define ITM_CLOTH198 (ITM_CLOTH_START + 198)\n#define ITM_CLOTH199 (ITM_CLOTH_START + 199)\n#define ITM_CLOTH200 (ITM_CLOTH_START + 200)\n#define ITM_CLOTH201 (ITM_CLOTH_START + 201)\n#define ITM_CLOTH202 (ITM_CLOTH_START + 202)\n#define ITM_CLOTH203 (ITM_CLOTH_START + 203)\n#define ITM_CLOTH204 (ITM_CLOTH_START + 204)\n#define ITM_CLOTH205 (ITM_CLOTH_START + 205)\n#define ITM_CLOTH206 (ITM_CLOTH_START + 206)\n#define ITM_CLOTH207 (ITM_CLOTH_START + 207)\n#define ITM_CLOTH208 (ITM_CLOTH_START + 208)\n#define ITM_CLOTH209 (ITM_CLOTH_START + 209)\n#define ITM_CLOTH210 (ITM_CLOTH_START + 210)\n#define ITM_CLOTH211 (ITM_CLOTH_START + 211)\n#define ITM_CLOTH212 (ITM_CLOTH_START + 212)\n#define ITM_CLOTH213 (ITM_CLOTH_START + 213)\n#define ITM_CLOTH214 (ITM_CLOTH_START + 214)\n#define ITM_CLOTH215 (ITM_CLOTH_START + 215)\n#define ITM_CLOTH216 (ITM_CLOTH_START + 216)\n#define ITM_CLOTH217 (ITM_CLOTH_START + 217)\n#define ITM_CLOTH218 (ITM_CLOTH_START + 218)\n#define ITM_CLOTH219 (ITM_CLOTH_START + 219)\n#define ITM_CLOTH220 (ITM_CLOTH_START + 220)\n#define ITM_CLOTH221 (ITM_CLOTH_START + 221)\n#define ITM_CLOTH222 (ITM_CLOTH_START + 222)\n#define ITM_CLOTH223 (ITM_CLOTH_START + 223)\n#define ITM_CLOTH224 (ITM_CLOTH_START + 224)\n#define ITM_CLOTH225 (ITM_CLOTH_START + 225)\n#define ITM_CLOTH226 (ITM_CLOTH_START + 226)\n#define ITM_CLOTH227 (ITM_CLOTH_START + 227)\n#define ITM_CLOTH228 (ITM_CLOTH_START + 228)\n#define ITM_CLOTH229 (ITM_CLOTH_START + 229)\n#define ITM_CLOTH230 (ITM_CLOTH_START + 230)\n#define ITM_CLOTH231 (ITM_CLOTH_START + 231)\n#define ITM_CLOTH232 (ITM_CLOTH_START + 232)\n#define ITM_CLOTH233 (ITM_CLOTH_START + 233)\n#define ITM_CLOTH234 (ITM_CLOTH_START + 234)\n#define ITM_CLOTH235 (ITM_CLOTH_START + 235)\n#define ITM_CLOTH236 (ITM_CLOTH_START + 236)\n#define ITM_CLOTH237 (ITM_CLOTH_START + 237)\n#define ITM_CLOTH238 (ITM_CLOTH_START + 238)\n#define ITM_CLOTH239 (ITM_CLOTH_START + 239)\n#define ITM_CLOTH240 (ITM_CLOTH_START + 240)\n#define ITM_CLOTH241 (ITM_CLOTH_START + 241)\n#define ITM_CLOTH242 (ITM_CLOTH_START + 242)\n#define ITM_CLOTH243 (ITM_CLOTH_START + 243)\n#define ITM_CLOTH244 (ITM_CLOTH_START + 244)\n#define ITM_CLOTH245 (ITM_CLOTH_START + 245)\n#define ITM_CLOTH246 (ITM_CLOTH_START + 246)\n#define ITM_CLOTH247 (ITM_CLOTH_START + 247)\n#define ITM_CLOTH248 (ITM_CLOTH_START + 248)\n#define ITM_CLOTH249 (ITM_CLOTH_START + 249)\n#define ITM_CLOTH250 (ITM_CLOTH_START + 250)\n#define ITM_CLOTH251 (ITM_CLOTH_START + 251)\n#define ITM_CLOTH252 (ITM_CLOTH_START + 252)\n#define ITM_CLOTH253 (ITM_CLOTH_START + 253)\n#define ITM_CLOTH254 (ITM_CLOTH_START + 254)\n#define ITM_CLOTH_END (ITM_CLOTH_START + 255)\n\n#define ITM_ETC_START 0x2500\n#define ITM_QST_LETTER ITM_ETC_START\n#define ITM_QST_CLOTH (ITM_QST_LETTER + 1)\n#define ITM_QST_MONEY (ITM_QST_CLOTH + 1)\n#define ITM_QST_VIDEOTAPE (ITM_QST_MONEY + 1)\n#define ITM_QST_ORGANIZER (ITM_QST_VIDEOTAPE + 1)\n#define ITM_QST_POKEMON_PIKACHU (ITM_QST_ORGANIZER + 1)\n#define ITM_QST_COMIC_BOOK (ITM_QST_POKEMON_PIKACHU + 1)\n#define ITM_QST_PICTURE_BOOK (ITM_QST_COMIC_BOOK + 1)\n#define ITM_QST_GAME_BOY (ITM_QST_PICTURE_BOOK + 1)\n#define ITM_QST_CAMREA (ITM_QST_GAME_BOY + 1)\n#define ITM_QST_WATCH (ITM_QST_CAMREA + 1)\n#define ITM_QST_HANDKERCHIEF (ITM_QST_WATCH + 1)\n#define ITM_QST_GLASSES_CASE (ITM_QST_HANDKERCHIEF + 1)\n#define ITM_MONEY1000BELL (ITM_QST_GLASSES_CASE + 1)\n#define ITM_DUST0_EMPTY_CAN (ITM_MONEY1000BELL + 1)\n#define ITM_DUST1_BOOT (ITM_DUST0_EMPTY_CAN + 1)\n#define ITM_DUST2_OLD_TIRE (ITM_DUST1_BOOT + 1)\n#define ITM_FOSSIL (ITM_DUST2_OLD_TIRE + 1)\n#define ITM_PITFALL (ITM_FOSSIL + 1)\n#define ITM_FORTUNE_SLIP (ITM_PITFALL + 1)\n#define ITM_SHELL_START (ITM_ETC_START + 20)\n#define ITM_SHELL0 (ITM_SHELL_START + 0)\n#define ITM_SHELL1 (ITM_SHELL_START + 1)\n#define ITM_SHELL2 (ITM_SHELL_START + 2)\n#define ITM_SHELL3 (ITM_SHELL_START + 3)\n#define ITM_SHELL4 (ITM_SHELL_START + 4)\n#define ITM_SHELL5 (ITM_SHELL_START + 5)\n#define ITM_SHELL6 (ITM_SHELL_START + 6)\n#define ITM_SHELL7 (ITM_SHELL_START + 7)\n#define ITM_SHELL_END (ITM_SHELL_START + 8)\n#define ITM_PRESENT (ITM_ETC_START + 28)\n#define ITM_TOWN_MAP (ITM_PRESENT + 1)\n#define ITM_SIGNBOARD (ITM_TOWN_MAP + 1)\n#define ITM_GOLDEN_NET_PRESENT (ITM_SIGNBOARD + 1)\n#define ITM_GOLDEN_AXE_PRESENT (ITM_GOLDEN_NET_PRESENT + 1)\n#define ITM_GOLDEN_SHOVEL_PRESENT (ITM_GOLDEN_AXE_PRESENT + 1)\n#define ITM_GOLDEN_ROD_PRESENT (ITM_GOLDEN_SHOVEL_PRESENT + 1)\n#define ITM_EXCERCISE_CARD00 (ITM_GOLDEN_ROD_PRESENT + 1)\n#define ITM_EXCERCISE_CARD01 (ITM_EXCERCISE_CARD00 + 1)\n#define ITM_EXCERCISE_CARD02 (ITM_EXCERCISE_CARD01 + 1)\n#define ITM_EXCERCISE_CARD03 (ITM_EXCERCISE_CARD02 + 1)\n#define ITM_EXCERCISE_CARD04 (ITM_EXCERCISE_CARD03 + 1)\n#define ITM_EXCERCISE_CARD05 (ITM_EXCERCISE_CARD04 + 1)\n#define ITM_EXCERCISE_CARD06 (ITM_EXCERCISE_CARD05 + 1)\n#define ITM_EXCERCISE_CARD07 (ITM_EXCERCISE_CARD06 + 1)\n#define ITM_EXCERCISE_CARD08 (ITM_EXCERCISE_CARD07 + 1)\n#define ITM_EXCERCISE_CARD09 (ITM_EXCERCISE_CARD08 + 1)\n#define ITM_EXCERCISE_CARD10 (ITM_EXCERCISE_CARD09 + 1)\n#define ITM_EXCERCISE_CARD11 (ITM_EXCERCISE_CARD10 + 1)\n#define ITM_EXCERCISE_CARD12 (ITM_EXCERCISE_CARD11 + 1)\n#define ITM_KNIFE_AND_FORK (ITM_EXCERCISE_CARD12 + 1)\n#define ITM_ETC_END 0x2531\n\n#define ITM_CARPET_START 0x2600\n#define ITM_CARPET00 (ITM_CARPET_START +  0)\n#define ITM_CARPET01 (ITM_CARPET_START +  1)\n#define ITM_CARPET02 (ITM_CARPET_START +  2)\n#define ITM_CARPET03 (ITM_CARPET_START +  3)\n#define ITM_CARPET04 (ITM_CARPET_START +  4)\n#define ITM_CARPET05 (ITM_CARPET_START +  5)\n#define ITM_CARPET06 (ITM_CARPET_START +  6)\n#define ITM_CARPET07 (ITM_CARPET_START +  7)\n#define ITM_CARPET08 (ITM_CARPET_START +  8)\n#define ITM_CARPET09 (ITM_CARPET_START +  9)\n#define ITM_CARPET10 (ITM_CARPET_START + 10)\n#define ITM_CARPET11 (ITM_CARPET_START + 11)\n#define ITM_CARPET12 (ITM_CARPET_START + 12)\n#define ITM_CARPET13 (ITM_CARPET_START + 13)\n#define ITM_CARPET14 (ITM_CARPET_START + 14)\n#define ITM_CARPET15 (ITM_CARPET_START + 15)\n#define ITM_CARPET16 (ITM_CARPET_START + 16)\n#define ITM_CARPET17 (ITM_CARPET_START + 17)\n#define ITM_CARPET18 (ITM_CARPET_START + 18)\n#define ITM_CARPET19 (ITM_CARPET_START + 19)\n#define ITM_CARPET20 (ITM_CARPET_START + 20)\n#define ITM_CARPET21 (ITM_CARPET_START + 21)\n#define ITM_CARPET22 (ITM_CARPET_START + 22)\n#define ITM_CARPET23 (ITM_CARPET_START + 23)\n#define ITM_CARPET24 (ITM_CARPET_START + 24)\n#define ITM_CARPET25 (ITM_CARPET_START + 25)\n#define ITM_CARPET26 (ITM_CARPET_START + 26)\n#define ITM_CARPET27 (ITM_CARPET_START + 27)\n#define ITM_CARPET28 (ITM_CARPET_START + 28)\n#define ITM_CARPET29 (ITM_CARPET_START + 29)\n#define ITM_CARPET30 (ITM_CARPET_START + 30)\n#define ITM_CARPET31 (ITM_CARPET_START + 31)\n#define ITM_CARPET32 (ITM_CARPET_START + 32)\n#define ITM_CARPET33 (ITM_CARPET_START + 33)\n#define ITM_CARPET34 (ITM_CARPET_START + 34)\n#define ITM_CARPET35 (ITM_CARPET_START + 35)\n#define ITM_CARPET36 (ITM_CARPET_START + 36)\n#define ITM_CARPET37 (ITM_CARPET_START + 37)\n#define ITM_CARPET38 (ITM_CARPET_START + 38)\n#define ITM_CARPET39 (ITM_CARPET_START + 39)\n#define ITM_CARPET40 (ITM_CARPET_START + 40)\n#define ITM_CARPET41 (ITM_CARPET_START + 41)\n#define ITM_CARPET42 (ITM_CARPET_START + 42)\n#define ITM_CARPET43 (ITM_CARPET_START + 43)\n#define ITM_CARPET44 (ITM_CARPET_START + 44)\n#define ITM_CARPET45 (ITM_CARPET_START + 45)\n#define ITM_CARPET46 (ITM_CARPET_START + 46)\n#define ITM_CARPET47 (ITM_CARPET_START + 47)\n#define ITM_CARPET48 (ITM_CARPET_START + 48)\n#define ITM_CARPET49 (ITM_CARPET_START + 49)\n#define ITM_CARPET50 (ITM_CARPET_START + 50)\n#define ITM_CARPET51 (ITM_CARPET_START + 51)\n#define ITM_CARPET52 (ITM_CARPET_START + 52)\n#define ITM_CARPET53 (ITM_CARPET_START + 53)\n#define ITM_CARPET54 (ITM_CARPET_START + 54)\n#define ITM_CARPET55 (ITM_CARPET_START + 55)\n#define ITM_CARPET56 (ITM_CARPET_START + 56)\n#define ITM_CARPET57 (ITM_CARPET_START + 57)\n#define ITM_CARPET58 (ITM_CARPET_START + 58)\n#define ITM_CARPET59 (ITM_CARPET_START + 59)\n#define ITM_CARPET60 (ITM_CARPET_START + 60)\n#define ITM_CARPET61 (ITM_CARPET_START + 61)\n#define ITM_CARPET62 (ITM_CARPET_START + 62)\n#define ITM_CARPET63 (ITM_CARPET_START + 63)\n#define ITM_CARPET64 (ITM_CARPET_START + 64)\n#define ITM_CARPET65 (ITM_CARPET_START + 65)\n#define ITM_CARPET66 (ITM_CARPET_START + 66)\n#define ITM_CARPET67 (ITM_CARPET_START + 67)\n#define ITM_CARPET68 (ITM_CARPET_START + 68)\n#define ITM_CARPET69 (ITM_CARPET_START + 69)\n#define ITM_CARPET70 (ITM_CARPET_START + 70)\n#define ITM_CARPET_END (ITM_CARPET_START + 71)\n\n#define ITM_WALL_START 0x2700\n#define ITM_WALL00 (ITM_WALL_START +  0)\n#define ITM_WALL01 (ITM_WALL_START +  1)\n#define ITM_WALL02 (ITM_WALL_START +  2)\n#define ITM_WALL03 (ITM_WALL_START +  3)\n#define ITM_WALL04 (ITM_WALL_START +  4)\n#define ITM_WALL05 (ITM_WALL_START +  5)\n#define ITM_WALL06 (ITM_WALL_START +  6)\n#define ITM_WALL07 (ITM_WALL_START +  7)\n#define ITM_WALL08 (ITM_WALL_START +  8)\n#define ITM_WALL09 (ITM_WALL_START +  9)\n#define ITM_WALL10 (ITM_WALL_START + 10)\n#define ITM_WALL11 (ITM_WALL_START + 11)\n#define ITM_WALL12 (ITM_WALL_START + 12)\n#define ITM_WALL13 (ITM_WALL_START + 13)\n#define ITM_WALL14 (ITM_WALL_START + 14)\n#define ITM_WALL15 (ITM_WALL_START + 15)\n#define ITM_WALL16 (ITM_WALL_START + 16)\n#define ITM_WALL17 (ITM_WALL_START + 17)\n#define ITM_WALL18 (ITM_WALL_START + 18)\n#define ITM_WALL19 (ITM_WALL_START + 19)\n#define ITM_WALL20 (ITM_WALL_START + 20)\n#define ITM_WALL21 (ITM_WALL_START + 21)\n#define ITM_WALL22 (ITM_WALL_START + 22)\n#define ITM_WALL23 (ITM_WALL_START + 23)\n#define ITM_WALL24 (ITM_WALL_START + 24)\n#define ITM_WALL25 (ITM_WALL_START + 25)\n#define ITM_WALL26 (ITM_WALL_START + 26)\n#define ITM_WALL27 (ITM_WALL_START + 27)\n#define ITM_WALL28 (ITM_WALL_START + 28)\n#define ITM_WALL29 (ITM_WALL_START + 29)\n#define ITM_WALL30 (ITM_WALL_START + 30)\n#define ITM_WALL31 (ITM_WALL_START + 31)\n#define ITM_WALL32 (ITM_WALL_START + 32)\n#define ITM_WALL33 (ITM_WALL_START + 33)\n#define ITM_WALL34 (ITM_WALL_START + 34)\n#define ITM_WALL35 (ITM_WALL_START + 35)\n#define ITM_WALL36 (ITM_WALL_START + 36)\n#define ITM_WALL37 (ITM_WALL_START + 37)\n#define ITM_WALL38 (ITM_WALL_START + 38)\n#define ITM_WALL39 (ITM_WALL_START + 39)\n#define ITM_WALL40 (ITM_WALL_START + 40)\n#define ITM_WALL41 (ITM_WALL_START + 41)\n#define ITM_WALL42 (ITM_WALL_START + 42)\n#define ITM_WALL43 (ITM_WALL_START + 43)\n#define ITM_WALL44 (ITM_WALL_START + 44)\n#define ITM_WALL45 (ITM_WALL_START + 45)\n#define ITM_WALL46 (ITM_WALL_START + 46)\n#define ITM_WALL47 (ITM_WALL_START + 47)\n#define ITM_WALL48 (ITM_WALL_START + 48)\n#define ITM_WALL49 (ITM_WALL_START + 49)\n#define ITM_WALL50 (ITM_WALL_START + 50)\n#define ITM_WALL51 (ITM_WALL_START + 51)\n#define ITM_WALL52 (ITM_WALL_START + 52)\n#define ITM_WALL53 (ITM_WALL_START + 53)\n#define ITM_WALL54 (ITM_WALL_START + 54)\n#define ITM_WALL55 (ITM_WALL_START + 55)\n#define ITM_WALL56 (ITM_WALL_START + 56)\n#define ITM_WALL57 (ITM_WALL_START + 57)\n#define ITM_WALL58 (ITM_WALL_START + 58)\n#define ITM_WALL59 (ITM_WALL_START + 59)\n#define ITM_WALL60 (ITM_WALL_START + 60)\n#define ITM_WALL61 (ITM_WALL_START + 61)\n#define ITM_WALL62 (ITM_WALL_START + 62)\n#define ITM_WALL63 (ITM_WALL_START + 63)\n#define ITM_WALL64 (ITM_WALL_START + 64)\n#define ITM_WALL65 (ITM_WALL_START + 65)\n#define ITM_WALL66 (ITM_WALL_START + 66)\n#define ITM_WALL67 (ITM_WALL_START + 67)\n#define ITM_WALL68 (ITM_WALL_START + 68)\n#define ITM_WALL69 (ITM_WALL_START + 69)\n#define ITM_WALL70 (ITM_WALL_START + 70)\n#define ITM_WALL_END (ITM_WALL_START + 71)\n\n#define ITM_FOOD_START 0x2800\n#define ITM_FOOD_APPLE (ITM_FOOD_START + 0)\n#define ITM_FOOD_CHERRY (ITM_FOOD_START + 1)\n#define ITM_FOOD_PEAR (ITM_FOOD_START + 2)\n#define ITM_FOOD_PEACH (ITM_FOOD_START + 3)\n#define ITM_FOOD_ORANGE (ITM_FOOD_START + 4)\n#define ITM_FOOD_MUSHROOM (ITM_FOOD_START + 5)\n#define ITM_FOOD_CANDY (ITM_FOOD_START + 6)\n#define ITM_FOOD_COCONUT (ITM_FOOD_START + 7)\n#define ITM_FOOD_END (ITM_FOOD_START + 8)\n\n#define ITM_ENV_START 0x2900\n#define ITM_SAPLING ITM_ENV_START\n#define ITM_CEDAR_SAPLING 0x2901\n#define ITM_WHITE_PANSY_BAG 0x2902\n#define ITM_PURPLE_PANSY_BAG 0x2903\n#define ITM_YELLOW_PANSY_BAG 0x2904\n#define ITM_WHITE_COSMOS_BAG 0x2905\n#define ITM_PINK_COSMOS_BAG 0x2906\n#define ITM_BLUE_COSMOS_BAG 0x2907\n#define ITM_RED_TULIP_BAG 0x2908\n#define ITM_WHITE_TULIP_BAG 0x2909\n#define ITM_YELLOW_TULIP_BAG 0x290A\n\n#define ITM_MINIDISK_START 0x2A00\n#define ITM_MINIDISK00 (ITM_MINIDISK_START + 0)\n#define ITM_MINIDISK01 (ITM_MINIDISK_START + 1)\n#define ITM_MINIDISK02 (ITM_MINIDISK_START + 2)\n#define ITM_MINIDISK03 (ITM_MINIDISK_START + 3)\n#define ITM_MINIDISK04 (ITM_MINIDISK_START + 4)\n#define ITM_MINIDISK05 (ITM_MINIDISK_START + 5)\n#define ITM_MINIDISK06 (ITM_MINIDISK_START + 6)\n#define ITM_MINIDISK07 (ITM_MINIDISK_START + 7)\n#define ITM_MINIDISK08 (ITM_MINIDISK_START + 8)\n#define ITM_MINIDISK09 (ITM_MINIDISK_START + 9)\n#define ITM_MINIDISK10 (ITM_MINIDISK_START + 10)\n#define ITM_MINIDISK11 (ITM_MINIDISK_START + 11)\n#define ITM_MINIDISK12 (ITM_MINIDISK_START + 12)\n#define ITM_MINIDISK13 (ITM_MINIDISK_START + 13)\n#define ITM_MINIDISK14 (ITM_MINIDISK_START + 14)\n#define ITM_MINIDISK15 (ITM_MINIDISK_START + 15)\n#define ITM_MINIDISK16 (ITM_MINIDISK_START + 16)\n#define ITM_MINIDISK17 (ITM_MINIDISK_START + 17)\n#define ITM_MINIDISK18 (ITM_MINIDISK_START + 18)\n#define ITM_MINIDISK19 (ITM_MINIDISK_START + 19)\n#define ITM_MINIDISK20 (ITM_MINIDISK_START + 20)\n#define ITM_MINIDISK21 (ITM_MINIDISK_START + 21)\n#define ITM_MINIDISK22 (ITM_MINIDISK_START + 22)\n#define ITM_MINIDISK23 (ITM_MINIDISK_START + 23)\n#define ITM_MINIDISK24 (ITM_MINIDISK_START + 24)\n#define ITM_MINIDISK25 (ITM_MINIDISK_START + 25)\n#define ITM_MINIDISK26 (ITM_MINIDISK_START + 26)\n#define ITM_MINIDISK27 (ITM_MINIDISK_START + 27)\n#define ITM_MINIDISK28 (ITM_MINIDISK_START + 28)\n#define ITM_MINIDISK29 (ITM_MINIDISK_START + 29)\n#define ITM_MINIDISK30 (ITM_MINIDISK_START + 30)\n#define ITM_MINIDISK31 (ITM_MINIDISK_START + 31)\n#define ITM_MINIDISK32 (ITM_MINIDISK_START + 32)\n#define ITM_MINIDISK33 (ITM_MINIDISK_START + 33)\n#define ITM_MINIDISK34 (ITM_MINIDISK_START + 34)\n#define ITM_MINIDISK35 (ITM_MINIDISK_START + 35)\n#define ITM_MINIDISK36 (ITM_MINIDISK_START + 36)\n#define ITM_MINIDISK37 (ITM_MINIDISK_START + 37)\n#define ITM_MINIDISK38 (ITM_MINIDISK_START + 38)\n#define ITM_MINIDISK39 (ITM_MINIDISK_START + 39)\n#define ITM_MINIDISK40 (ITM_MINIDISK_START + 40)\n#define ITM_MINIDISK41 (ITM_MINIDISK_START + 41)\n#define ITM_MINIDISK42 (ITM_MINIDISK_START + 42)\n#define ITM_MINIDISK43 (ITM_MINIDISK_START + 43)\n#define ITM_MINIDISK44 (ITM_MINIDISK_START + 44)\n#define ITM_MINIDISK45 (ITM_MINIDISK_START + 45)\n#define ITM_MINIDISK46 (ITM_MINIDISK_START + 46)\n#define ITM_MINIDISK47 (ITM_MINIDISK_START + 47)\n#define ITM_MINIDISK48 (ITM_MINIDISK_START + 48)\n#define ITM_MINIDISK49 (ITM_MINIDISK_START + 49)\n#define ITM_MINIDISK50 (ITM_MINIDISK_START + 50)\n#define ITM_MINIDISK51 (ITM_MINIDISK_START + 51)\n#define ITM_MINIDISK52 (ITM_MINIDISK_START + 52)\n#define ITM_MINIDISK53 (ITM_MINIDISK_START + 53)\n#define ITM_MINIDISK54 (ITM_MINIDISK_START + 54)\n#define ITM_MINIDISK_END (ITM_MINIDISK_START + 55)\n\n#define ITM_DIARY_START 0x2B00\n#define ITM_DIARY00 (ITM_DIARY_START +  0)\n#define ITM_DIARY01 (ITM_DIARY_START +  1)\n#define ITM_DIARY02 (ITM_DIARY_START +  2)\n#define ITM_DIARY03 (ITM_DIARY_START +  3)\n#define ITM_DIARY04 (ITM_DIARY_START +  4)\n#define ITM_DIARY05 (ITM_DIARY_START +  5)\n#define ITM_DIARY06 (ITM_DIARY_START +  6)\n#define ITM_DIARY07 (ITM_DIARY_START +  7)\n#define ITM_DIARY08 (ITM_DIARY_START +  8)\n#define ITM_DIARY09 (ITM_DIARY_START +  9)\n#define ITM_DIARY10 (ITM_DIARY_START + 10)\n#define ITM_DIARY11 (ITM_DIARY_START + 11)\n#define ITM_DIARY12 (ITM_DIARY_START + 12)\n#define ITM_DIARY13 (ITM_DIARY_START + 13)\n#define ITM_DIARY14 (ITM_DIARY_START + 14)\n#define ITM_DIARY15 (ITM_DIARY_START + 15)\n#define ITM_DIARY_END (ITM_DIARY_START + 16)\n\n#define ITM_TICKET_START 0x2C00\n\n#define ITM_INSECT_START 0x2D00\n#define ITM_INSECT00 (ITM_INSECT_START + 0)\n#define ITM_INSECT01 (ITM_INSECT_START + 1)\n#define ITM_INSECT02 (ITM_INSECT_START + 2)\n#define ITM_INSECT03 (ITM_INSECT_START + 3)\n#define ITM_INSECT04 (ITM_INSECT_START + 4)\n#define ITM_INSECT05 (ITM_INSECT_START + 5)\n#define ITM_INSECT06 (ITM_INSECT_START + 6)\n#define ITM_INSECT07 (ITM_INSECT_START + 7)\n#define ITM_INSECT08 (ITM_INSECT_START + 8)\n#define ITM_INSECT09 (ITM_INSECT_START + 9)\n#define ITM_INSECT10 (ITM_INSECT_START + 10)\n#define ITM_INSECT11 (ITM_INSECT_START + 11)\n#define ITM_INSECT12 (ITM_INSECT_START + 12)\n#define ITM_INSECT13 (ITM_INSECT_START + 13)\n#define ITM_INSECT14 (ITM_INSECT_START + 14)\n#define ITM_INSECT15 (ITM_INSECT_START + 15)\n#define ITM_INSECT16 (ITM_INSECT_START + 16)\n#define ITM_INSECT17 (ITM_INSECT_START + 17)\n#define ITM_INSECT18 (ITM_INSECT_START + 18)\n#define ITM_INSECT19 (ITM_INSECT_START + 19)\n#define ITM_INSECT20 (ITM_INSECT_START + 20)\n#define ITM_INSECT21 (ITM_INSECT_START + 21)\n#define ITM_INSECT22 (ITM_INSECT_START + 22)\n#define ITM_INSECT23 (ITM_INSECT_START + 23)\n#define ITM_INSECT24 (ITM_INSECT_START + 24)\n#define ITM_INSECT25 (ITM_INSECT_START + 25)\n#define ITM_INSECT26 (ITM_INSECT_START + 26)\n#define ITM_INSECT27 (ITM_INSECT_START + 27)\n#define ITM_INSECT28 (ITM_INSECT_START + 28)\n#define ITM_INSECT29 (ITM_INSECT_START + 29)\n#define ITM_INSECT30 (ITM_INSECT_START + 30)\n#define ITM_INSECT31 (ITM_INSECT_START + 31)\n#define ITM_INSECT32 (ITM_INSECT_START + 32)\n#define ITM_INSECT33 (ITM_INSECT_START + 33)\n#define ITM_INSECT34 (ITM_INSECT_START + 34)\n#define ITM_INSECT35 (ITM_INSECT_START + 35)\n#define ITM_INSECT36 (ITM_INSECT_START + 36)\n#define ITM_INSECT37 (ITM_INSECT_START + 37)\n#define ITM_INSECT38 (ITM_INSECT_START + 38)\n#define ITM_INSECT39 (ITM_INSECT_START + 39)\n#define ITM_INSECT_END (ITM_INSECT_START + 40)\n#define ITM_SPIRIT0 (ITM_INSECT_START + 40)\n#define ITM_SPIRIT1 (ITM_INSECT_START + 41)\n#define ITM_SPIRIT2 (ITM_INSECT_START + 42)\n#define ITM_SPIRIT3 (ITM_INSECT_START + 43)\n#define ITM_SPIRIT4 (ITM_INSECT_START + 44)\n#define ITM_INSECT_ALL_END (ITM_INSECT_START + 45)\n\n#define ITM_HUKUBUKURO_START 0x2E00\n#define ITM_HUKUBUKURO_BAG (ITM_HUKUBUKURO_START + 0)\n#define ITM_HUKUBUKURO_PRESENT (ITM_HUKUBUKURO_START + 1)\n#define ITM_HUKUBUKURO_END (ITM_HUKUBUKURO_START + 2)\n\n#define ITM_KABU_START 0x2F00\n#define ITM_KABU_10 (ITM_KABU_START + 0)\n#define ITM_KABU_50 (ITM_KABU_START + 1)\n#define ITM_KABU_100 (ITM_KABU_START + 2)\n#define ITM_KABU_SPOILED (ITM_KABU_START + 3)\n#define ITM_KABU_END (ITM_KABU_START + 4)\n\n#define FTR1_START 0x3000\n\n#define FTR_POST_MODEL 0x3020\n#define FTR_HOUSE_MODEL 0x3024\n#define FTR_MANOR_MODEL 0x3028\n#define FTR_POLICE_MODEL 0x302C\n#define FTR_MUSEUM_MODEL 0x3030\n#define FTR_PLATE_ARMOR 0x3034\n#define FTR_TSUKIMI_DANGO 0x3038\n#define FTR_BEAN_THROWING_SET 0x303C\n#define FTR_OSECHI 0x3040\n#define FTR_LOVELY_PHONE 0x3044\n#define FTR_MARKET_MODEL 0x3048\n#define FTR_FORTUNE_TENT_MODEL 0x304C\n#define FTR_CHINESE_LION 0x3050\n#define FTR_TANABATA_PALM 0x3054\n#define FTR_SPRING_PENNANT 0x3058\n#define FTR_AUTUMN_PENNANT 0x305C\n#define FTR_SHOP_MDOEL 0x3060\n#define FTR_COMPASS 0x3064\n#define FTR_LONG_LIFE_NOODLES 0x3068\n#define FTR_BASS_BOAT 0x306C\n#define FTR_LIGHTHOUSE_MODEL 0x3070\n#define FTR_LIFE_RING 0x3074\n#define FTR_TREE_MODEL 0x3078\n#define FTR_PINK_TREE_MODEL 0x307C\n#define FTR_WEED_MODEL 0x3080\n#define FTR_NEEDLEWORK_MODEL 0x3084\n#define FTR_DUMP_MODEL 0x3088\n#define FTR_MORTAR_BALL 0x308C\n#define FTR_SNOWMAN 0x3090\n#define FTR_MINI_CAR 0x3094\n#define FTR_BIG_CATCH_FLAG 0x3098\n#define FTR_MOON 0x309C\n#define FTR_LOCOMOTIVE_MODEL 0x30A0\n#define FTR_DOLLY 0x30A4\n#define FTR_STATION_MODEL0  0x30A8\n#define FTR_STATION_MODEL1  0x30AC\n#define FTR_STATION_MODEL2  0x30B0\n#define FTR_STATION_MODEL3  0x30B4\n#define FTR_STATION_MODEL4  0x30B8\n#define FTR_STATION_MODEL5  0x30BC\n#define FTR_STATION_MODEL6  0x30C0\n#define FTR_STATION_MODEL7  0x30C4\n#define FTR_STATION_MODEL8  0x30C8\n#define FTR_STATION_MODEL9  0x30CC\n#define FTR_STATION_MODEL10 0x30D0\n#define FTR_STATION_MODEL11 0x30D4\n#define FTR_STATION_MODEL12 0x30D8\n#define FTR_STATION_MODEL13 0x30DC\n#define FTR_STATION_MODEL14 0x30E0\n#define FTR_WELL_MODEL 0x30E4\n#define FTR_GRASS_MODEL 0x30E8\n#define FTR_TRACK_MODEL 0x30EC\n#define FTR_DIRT_MODEL 0x30F0\n#define FTR_TRAIN_CAR_MODEL 0x30F4\n#define FTR_ORANGEBOX 0x30F8\n\n#define FTR_COLLEGERULE 0x30FC\n\n#define FTR_CALLIGRAPHY_PAD_WEST 0x313B\n\n#define FTR_AXE 0x3190\n\n#define FTR_PAINTING15_UNUSED 0x31D8\n#define FTR_PAINTING16_UNUSED 0x31DC\n\n#define FTR_BOTTLE_ROCKET 0x31F0\n\n#define FTR_FISHING_TROPHY 0x3210\n\n#define FTR_TELESCOPE 0x3238\n\n#define FTR_FESTIVE_FLAG 0x327C\n#define FTR_SUPER_TORTIMER 0x3280\n\n#define FTR_MAILBOX 0x3294\n#define FTR_FESTIVE_CANDLE 0x3298\n\n#define FTR_SPRING_MEDAL 0x32A8\n#define FTR_AUTUMN_MEDAL 0x32AC\n\n#define FTR_ANGLER_TROPHY 0x3374\n\n#define FTR_CORNUCOPIA 0x33B4\n#define FTR_JUDGES_BELL 0x33B8\n#define FTR_NOISEMAKER 0x33BC\n#define FTR_CHOWER 0x33C0\n#define FTR_DUMMY 0x33C4\n#define FTR1_END 0x33C8\n\n#define DOOR_START 0x4000\n#define DOOR0 DOOR_START  /* 0x4000 */\n#define DOOR1 (DOOR0 + 1) /* 0x4001 */\n\n#define EXIT_DOOR 0x4080\n\n#define NPC_HOUSE_START 0x5000\n#define NPC_HOUSE000 NPC_HOUSE_START\n//\n#define NPC_HOUSE_END 0x50EE\n\n#define STRUCTURE_START 0x5800\n#define HOUSE0 (STRUCTURE_START)\n#define HOUSE1 (HOUSE0 + 1)\n#define HOUSE2 (HOUSE1 + 1)\n#define HOUSE3 (HOUSE2 + 1)\n#define SHOP0 (HOUSE3 + 1)\n#define SHOP1 (SHOP0 + 1)\n#define SHOP2 (SHOP1 + 1)\n#define SHOP3 (SHOP2 + 1)\n#define POST_OFFICE (SHOP3 + 1)\n#define TRAIN_STATION (POST_OFFICE + 1)\n#define TRAIN0 (TRAIN_STATION + 1)\n#define TRAIN1 (TRAIN0 + 1)\n#define POLICE_STATION (TRAIN1 + 1)\n#define WATERFALL_SOUTH (POLICE_STATION + 1)\n#define WATERFALL_EAST (WATERFALL_SOUTH + 1)\n#define WATERFALL_WEST (WATERFALL_EAST + 1)\n#define SIGN00 (STRUCTURE_START + 16)\n#define SIGN01 (SIGN00 + 1)\n#define SIGN02 (SIGN01 + 1)\n#define SIGN03 (SIGN02 + 1)\n#define SIGN04 (SIGN03 + 1)\n#define SIGN05 (SIGN04 + 1)\n#define SIGN06 (SIGN05 + 1)\n#define SIGN07 (SIGN06 + 1)\n#define SIGN08 (SIGN07 + 1)\n#define SIGN09 (SIGN08 + 1)\n#define SIGN10 (SIGN09 + 1)\n#define SIGN11 (SIGN10 + 1)\n#define SIGN12 (SIGN11 + 1)\n#define SIGN13 (SIGN12 + 1)\n#define SIGN14 (SIGN13 + 1)\n#define SIGN15 (SIGN14 + 1)\n#define SIGN16 (SIGN15 + 1)\n#define SIGN17 (SIGN16 + 1)\n#define SIGN18 (SIGN17 + 1)\n#define SIGN19 (SIGN18 + 1)\n#define SIGN20 (SIGN19 + 1)\n#define WISHING_WELL (SIGN20 + 1)\n#define BROKER_TENT (WISHING_WELL + 1)\n#define FORTUNE_TENT (BROKER_TENT + 1)\n#define DESIGNER_CAR (FORTUNE_TENT + 1)\n#define KAMAKURA (DESIGNER_CAR + 1)\n#define SAKURA_TABLE0 (KAMAKURA + 1)\n#define SAKURA_TABLE1 (SAKURA_TABLE0 + 1)\n#define AEROBICS_RADIO (SAKURA_TABLE1 + 1)\n#define FIREWORKS_STALL0 (AEROBICS_RADIO + 1)\n#define FIREWORKS_STALL1 (FIREWORKS_STALL0 + 1)\n#define NEWYEAR_SHRINE0 (FIREWORKS_STALL1 + 1)\n#define NEWYEAR_SHRINE1 (NEWYEAR_SHRINE0 + 1)\n#define NEWYEAR_TABLE (NEWYEAR_SHRINE1 + 1)\n#define NEWYEAR_COUNTDOWN0 (NEWYEAR_TABLE + 1)\n#define NEWYEAR_COUNTDOWN1 (NEWYEAR_COUNTDOWN0 + 1)\n#define SPORTSFAIR_BALLS_RED (NEWYEAR_COUNTDOWN1 + 1)\n#define SPORTSFAIR_BALLS_WHITE (SPORTSFAIR_BALLS_RED + 1)\n#define SPORTSFAIR_BASKET_RED (SPORTSFAIR_BALLS_WHITE + 1)\n#define SPORTSFAIR_BASKET_WHITE (SPORTSFAIR_BASKET_RED + 1)\n#define FISHCHECK_STAND0 (SPORTSFAIR_BASKET_WHITE + 1)\n#define FISHCHECK_STAND1 (FISHCHECK_STAND0 + 1)\n#define KOINOBORI_WINDSOCK (FISHCHECK_STAND1 + 1)\n#define DUMP (KOINOBORI_WINDSOCK + 1)\n#define WINDMILL0 (DUMP + 1)\n#define WINDMILL1 (WINDMILL0 + 1)\n#define WINDMILL2 (WINDMILL1 + 1)\n#define WINDMILL3 (WINDMILL2 + 1)\n#define WINDMILL4 (WINDMILL3 + 1)\n#define LOTUS (WINDMILL4 + 1)\n#define MIKANBOX (LOTUS + 1)\n#define DOUZOU (MIKANBOX + 1) // train station statue\n#define TOUDAI (DOUZOU + 1) // lighthouse\n#define GHOG (TOUDAI + 1)\n#define HTABLE0 (GHOG + 1)\n#define HTABLE1 (HTABLE0 + 1)\n#define HTABLE2 (HTABLE1 + 1)\n#define TENT (HTABLE2 + 1)\n#define MUSEUM (TENT + 1)\n#define BRIDGE_A0 (MUSEUM + 1)\n#define BRIDGE_A1 (BRIDGE_A0 + 1)\n#define NEEDLEWORK_SHOP (BRIDGE_A1 + 1)\n#define FLAG (NEEDLEWORK_SHOP + 1)\n#define BOAT (FLAG + 1)\n#define COTTAGE_MY (BOAT + 1)\n#define COTTAGE_NPC (COTTAGE_MY + 1)\n#define PORT_SIGN (COTTAGE_NPC + 1)\n#define STRUCTURE_END (PORT_SIGN + 1)\n\n#define ETC_START 0x8000\n#define ETC_AIRPLANE ETC_START\n#define ETC_BOXTRICK (ETC_START + 4)\n#define ETC_BOXMANAGER (ETC_START + 5)\n#define ETC_SNOWMAN_BALL_A (ETC_START + 13)\n#define ETC_SNOWMAN_BALL_B (ETC_START + 14)\n#define ETC_TRAIN_WINDOW (ETC_START + 17)\n\n#define MISC_ACTOR_START 0x9000\n#define MISC_ACTOR_SAMPLE MISC_ACTOR_START\n\n#define ACTOR_PROP_START 0xA000\n#define ACTOR_PROP_MAILBOX0 (ACTOR_PROP_START)\n#define ACTOR_PROP_MAILBOX1 (ACTOR_PROP_MAILBOX0 + 1)\n#define ACTOR_PROP_MAILBOX2 (ACTOR_PROP_MAILBOX1 + 1)\n#define ACTOR_PROP_MAILBOX3 (ACTOR_PROP_MAILBOX2 + 1)\n#define ACTOR_PROP_HANIWA0 (ACTOR_PROP_MAILBOX3 + 1)\n#define ACTOR_PROP_HANIWA1 (ACTOR_PROP_HANIWA0 + 1)\n#define ACTOR_PROP_HANIWA2 (ACTOR_PROP_HANIWA1 + 1)\n#define ACTOR_PROP_HANIWA3 (ACTOR_PROP_HANIWA2 + 1)\n#define SNOWMAN0 (ACTOR_PROP_HANIWA3 + 1)\n#define SNOWMAN1 (SNOWMAN0 + 1)\n#define SNOWMAN2 (SNOWMAN1 + 1)\n#define SNOWMAN3 (SNOWMAN2 + 1)\n#define SNOWMAN4 (SNOWMAN3 + 1)\n#define SNOWMAN5 (SNOWMAN4 + 1)\n#define SNOWMAN6 (SNOWMAN5 + 1)\n#define SNOWMAN7 (SNOWMAN6 + 1)\n#define SNOWMAN8 (SNOWMAN7 + 1)\n#define TRAIN_DOOR 0xA011\n#define ACTOR_PROP_VILLAGER_SIGNBOARD 0xA012\n\n#define SP_NPC_START 0xD000\n#define SP_NPC_ARTIST (SP_NPC_START + 0) // D000\n#define SP_NPC_BROKER (SP_NPC_START + 1) // D001\n#define SP_NPC_DESIGNER (SP_NPC_START + 2) // D002\n#define SP_NPC_POST_GIRL (SP_NPC_START + 3) // D003\n#define SP_NPC_GUIDE (SP_NPC_START + 4) // D004\n#define SP_NPC_GUIDE2 (SP_NPC_START + 5) // D005\n#define SP_NPC_CARPETPEDDLER (SP_NPC_START + 6) // D006\n#define SP_NPC_KABUPEDDLER (SP_NPC_START + 7) // D007\n#define SP_NPC_SHOP_MASTER (SP_NPC_START + 8) // D008\n#define SP_NPC_CONV_MASTER (SP_NPC_START + 9) // D009\n#define SP_NPC_SUPER_MASTER (SP_NPC_START + 10) // D00A\n#define SP_NPC_DEPART_MASTER (SP_NPC_START + 11) // D00B\n#define SP_NPC_GYPSY (SP_NPC_START + 12) // D00C\n#define SP_NPC_POLICE (SP_NPC_START + 13) // D00D\n#define SP_NPC_STATION_MASTER (SP_NPC_START + 14) // D00E\n#define SP_NPC_SANTA (SP_NPC_START + 15) // D00F\n#define SP_NPC_POLICE2 (SP_NPC_START + 16) // D010\n#define SP_NPC_POST_MAN (SP_NPC_START + 17) // D011\n#define SP_NPC_POST_GIRL2 (SP_NPC_START + 18) // D012\n#define SP_NPC_EV_BROKER2 (SP_NPC_START + 19) // D013\n#define SP_NPC_RCN_GUIDE (SP_NPC_START + 20) // D014\n#define SP_NPC_RCN_GUIDE_1 (SP_NPC_START + 21) // D015\n#define SP_NPC_RCN_GUIDE_2 (SP_NPC_START + 22) // D016\n#define SP_NPC_RCN_GUIDE_3 (SP_NPC_START + 23) // D017\n#define SP_NPC_P_SEL (SP_NPC_START + 24) // D018\n#define SP_NPC_RCN_GUIDE2 (SP_NPC_START + 25) // D019\n#define SP_NPC_RCN_GUIDE2_1 (SP_NPC_START + 26) // D01A\n#define SP_NPC_RCN_GUIDE2_2 (SP_NPC_START + 27) // D01B\n#define SP_NPC_RCN_GUIDE2_3 (SP_NPC_START + 28) // D01C\n#define SP_NPC_ANGLER (SP_NPC_START + 29) // D01D\n#define SP_NPC_SHOP_MASTERSP (SP_NPC_START + 30) // D01E\n#define SP_NPC_P_SEL2 (SP_NPC_START + 31) // D01F\n#define SP_NPC_EV_HALLOWEEN_0 (SP_NPC_START + 32) // D020\n#define SP_NPC_EV_HALLOWEEN_1 (SP_NPC_START + 33) // D021\n#define SP_NPC_EV_HALLOWEEN_2 (SP_NPC_START + 34) // D022\n#define SP_NPC_EV_HALLOWEEN_3 (SP_NPC_START + 35) // D023\n#define SP_NPC_EV_HALLOWEEN_4 (SP_NPC_START + 36) // D024\n#define SP_NPC_HALLOWEEN (SP_NPC_START + 37) // D025\n#define SP_NPC_MAMEDANUKI0 (SP_NPC_START + 38) // D026\n#define SP_NPC_EV_HANABI_0 (SP_NPC_START + 39) // D027\n#define SP_NPC_EV_HANABI_1 (SP_NPC_START + 40) // D028\n#define SP_NPC_EV_HANABI_2 (SP_NPC_START + 41) // D029\n#define SP_NPC_EV_HANABI_3 (SP_NPC_START + 42) // D02A\n#define SP_NPC_EV_HANABI_4 (SP_NPC_START + 43) // D02B\n#define SP_NPC_EV_YOMISE (SP_NPC_START + 44) // D02C\n#define SP_NPC_EV_TOKYOSO_0 (SP_NPC_START + 45) // D02D\n#define SP_NPC_EV_TOKYOSO_1 (SP_NPC_START + 46) // D02E\n#define SP_NPC_EV_TOKYOSO_2 (SP_NPC_START + 47) // D02F\n#define SP_NPC_EV_TOKYOSO_3 (SP_NPC_START + 48) // D030\n#define SP_NPC_EV_TOKYOSO_4 (SP_NPC_START + 49) // D031\n#define SP_NPC_EV_HANAMI_0 (SP_NPC_START + 50) // D032\n#define SP_NPC_EV_HANAMI_1 (SP_NPC_START + 51) // D033\n#define SP_NPC_EV_HANAMI_2 (SP_NPC_START + 52) // D034\n#define SP_NPC_EV_HANAMI_3 (SP_NPC_START + 53) // D035\n#define SP_NPC_EV_HANAMI_4 (SP_NPC_START + 54) // D036\n#define SP_NPC_MAMEDANUKI1 (SP_NPC_START + 55) // D037\n#define SP_NPC_SLEEP_OBABA (SP_NPC_START + 56) // D038\n#define SP_NPC_EV_YOMISE2 (SP_NPC_START + 57) // D039\n#define SP_NPC_SHOP_MASTERSP_2 (SP_NPC_START + 58) // D03A\n#define SP_NPC_SHOP_MASTERSP_3 (SP_NPC_START + 59) // D03B\n#define SP_NPC_SHOP_MASTERSP_4 (SP_NPC_START + 60) // D03C\n#define SP_NPC_EV_MIKO (SP_NPC_START + 61) // D03D\n#define SP_NPC_MAJIN (SP_NPC_START + 62) // D03E\n#define SP_NPC_EV_TUKIMI_0 (SP_NPC_START + 63) // D03F\n#define SP_NPC_EV_TUKIMI_1 (SP_NPC_START + 64) // D040\n#define SP_NPC_EV_TUKIMI_2 (SP_NPC_START + 65) // D041\n#define SP_NPC_EV_TUKIMI_3 (SP_NPC_START + 66) // D042\n#define SP_NPC_EV_TUKIMI_4 (SP_NPC_START + 67) // D043\n#define SP_NPC_EV_COUNTDOWN_0 (SP_NPC_START + 68) // D044\n#define SP_NPC_EV_COUNTDOWN_1 (SP_NPC_START + 69) // D045\n#define SP_NPC_EV_COUNTDOWN_2 (SP_NPC_START + 70) // D046\n#define SP_NPC_EV_COUNTDOWN_3 (SP_NPC_START + 71) // D047\n#define SP_NPC_EV_COUNTDOWN_4 (SP_NPC_START + 72) // D048\n#define SP_NPC_EV_TURI_0 (SP_NPC_START + 73) // D049\n#define SP_NPC_EV_TURI_1 (SP_NPC_START + 74) // D04A\n#define SP_NPC_EV_TURI_2 (SP_NPC_START + 75) // D04B\n#define SP_NPC_EV_TURI_3 (SP_NPC_START + 76) // D04C\n#define SP_NPC_EV_TURI_4 (SP_NPC_START + 77) // D04D\n#define SP_NPC_EV_TAISOU_0 (SP_NPC_START + 78) // D04E\n#define SP_NPC_EV_TAISOU_1 (SP_NPC_START + 79) // D04F\n#define SP_NPC_EV_TAISOU_2 (SP_NPC_START + 80) // D050\n#define SP_NPC_EV_TAISOU_3 (SP_NPC_START + 81) // D051\n#define SP_NPC_EV_TAISOU_4 (SP_NPC_START + 82) // D052\n#define SP_NPC_EV_TAMAIRE_0 (SP_NPC_START + 83) // D053\n#define SP_NPC_EV_TAMAIRE_1 (SP_NPC_START + 84) // D054\n#define SP_NPC_EV_TAMAIRE_2 (SP_NPC_START + 85) // D055\n#define SP_NPC_EV_TAMAIRE_3 (SP_NPC_START + 86) // D056\n#define SP_NPC_EV_TAMAIRE_4 (SP_NPC_START + 87) // D057\n#define SP_NPC_EV_HATUMODE_0 (SP_NPC_START + 88) // D058\n#define SP_NPC_EV_HATUMODE_1 (SP_NPC_START + 89) // D059\n#define SP_NPC_EV_HATUMODE_2 (SP_NPC_START + 90) // D05A\n#define SP_NPC_EV_HATUMODE_3 (SP_NPC_START + 91) // D05B\n#define SP_NPC_EV_HATUMODE_4 (SP_NPC_START + 92) // D05C\n#define SP_NPC_TOTAKEKE (SP_NPC_START + 93) // D05D\n#define SP_NPC_EV_KAMAKURA_0 (SP_NPC_START + 94) // D05E\n#define SP_NPC_EV_TUNAHIKI_0 (SP_NPC_START + 95) // D05F\n#define SP_NPC_EV_TUNAHIKI_1 (SP_NPC_START + 96) // D060\n#define SP_NPC_EV_TUNAHIKI_2 (SP_NPC_START + 97) // D061\n#define SP_NPC_EV_TUNAHIKI_3 (SP_NPC_START + 98) // D062\n#define SP_NPC_EV_TUNAHIKI_4 (SP_NPC_START + 99) // D063\n#define SP_NPC_EV_DOZAEMON (SP_NPC_START + 100) // D064\n#define SP_NPC_MAJIN2 (SP_NPC_START + 101) // D065\n#define SP_NPC_RTC (SP_NPC_START + 102) // D066\n#define SP_NPC_ENGINEER (SP_NPC_START + 103) // D067\n#define SP_NPC_MAJIN3 (SP_NPC_START + 104) // D068\n#define SP_NPC_MAJIN4 (SP_NPC_START + 105) // D069\n#define SP_NPC_RESTART (SP_NPC_START + 106) // D06A\n#define SP_NPC_MAJIN5 (SP_NPC_START + 107) // D06B\n#define SP_NPC_EV_DOKUTU (SP_NPC_START + 108) // D06C\n#define SP_NPC_CURATOR (SP_NPC_START + 109) // D06D\n#define SP_NPC_EV_SONCHO (SP_NPC_START + 110) // D06E\n#define SP_NPC_EV_GHOST (SP_NPC_START + 111) // D06F\n#define SP_NPC_NEEDLEWORK0 (SP_NPC_START + 112) // D070\n#define SP_NPC_NEEDLEWORK1 (SP_NPC_START + 113) // D071\n#define SP_NPC_SENDO (SP_NPC_START + 114) // D072\n//\n#define SP_NPC_EV_SONCHO2 (SP_NPC_START + 116) // D074\n#define SP_NPC_MASK_CAT (SP_NPC_START + 117) // D075\n#define SP_NPC_MASK_CAT2 (SP_NPC_START + 118) // D076\n//\n#define SP_NPC_SONCHO_D078 (SP_NPC_START + 120) // D078\n#define SP_NPC_SONCHO_D079 (SP_NPC_START + 121) // D079\n#define SP_NPC_SASHO (SP_NPC_START + 122) // D07A\n//\n#define SP_NPC_MAJIN_D07C (SP_NPC_START + 124) // D07C\n#define SP_NPC_MAJIN_D07D (SP_NPC_START + 125) // D07D\n#define SP_NPC_MAJIN_BROTHER (SP_NPC_START + 126) // D07E\n#define SP_NPC_SONCHO (SP_NPC_START + 127) // D07F\n#define SP_NPC_MAJIN_D080 (SP_NPC_START + 128) // D080\n#define SP_NPC_EV_MAJIN (SP_NPC_START + 129) // D081\n#define SP_NPC_EV_HARVEST_0 (SP_NPC_START + 130) // D082\n#define SP_NPC_EV_HARVEST_1 (SP_NPC_START + 131) // D083\n#define SP_NPC_EV_HARVEST_2 (SP_NPC_START + 132) // D084\n#define SP_NPC_EV_HARVEST_3 (SP_NPC_START + 133) // D085\n#define SP_NPC_EV_HARVEST_4 (SP_NPC_START + 134) // D086\n#define SP_NPC_EV_SPEECH_SONCHO (SP_NPC_START + 135) // D087\n#define SP_NPC_EV_GROUNDHOG_0 (SP_NPC_START + 136) // D088\n#define SP_NPC_EV_GROUNDHOG_1 (SP_NPC_START + 137) // D089\n#define SP_NPC_EV_GROUNDHOG_2 (SP_NPC_START + 138) // D08A\n#define SP_NPC_EV_GROUNDHOG_3 (SP_NPC_START + 139) // D08B\n#define SP_NPC_EV_GROUNDHOG_4 (SP_NPC_START + 140) // D08C\n#define SP_NPC_TURKEY (SP_NPC_START + 141) // D08D\n#define SP_NPC_HEM (SP_NPC_START + 142) // D08E\n\n\n#define NPC_START    0xE000\n// cats\n#define NPC_BOB      NPC_START\n#define NPC_OLIVIA   (NPC_START + 1)\n#define NPC_MITZI    (NPC_START + 2)\n#define NPC_KIKI     (NPC_START + 3)\n#define NPC_TANGY    (NPC_START + 4)\n#define NPC_KABUKI   (NPC_START + 5)\n#define NPC_TABBY    (NPC_START + 6)\n#define NPC_MONIQUE  (NPC_START + 7)\n#define NPC_STINKY   (NPC_START + 8)\n#define NPC_PURRL    (NPC_START + 9)\n#define NPC_KITTY    (NPC_START + 10)\n#define NPC_TOM      (NPC_START + 11)\n#define NPC_ROSIE    (NPC_START + 12)\n// anteaters\n#define NPC_NOSEGAY  (NPC_START + 13)\n#define NPC_ZOE      (NPC_START + 14)\n#define NPC_PANGO    (NPC_START + 15)\n#define NPC_CYRANO   (NPC_START + 16)\n#define NPC_SNOOTY   (NPC_START + 17)\n// bears\n#define NPC_TEDDY    (NPC_START + 18)\n#define NPC_CHOW     (NPC_START + 19)\n#define NPC_DOZER    (NPC_START + 20)\n#define NPC_NATE     (NPC_START + 21)\n#define NPC_GROUCHO  (NPC_START + 22)\n#define NPC_TUTU     (NPC_START + 23)\n#define NPC_URSALA   (NPC_START + 24)\n#define NPC_GRIZZLY  (NPC_START + 25)\n#define NPC_PINKY    (NPC_START + 26)\n// birds\n#define NPC_JAY      (NPC_START + 27)\n#define NPC_TWIGGY   (NPC_START + 28)\n#define NPC_ANCHOVY  (NPC_START + 29)\n#define NPC_PIPER    (NPC_START + 30)\n#define NPC_ADMIRAL  (NPC_START + 31)\n#define NPC_OTIS     (NPC_START + 32)\n#define NPC_ROBIN    (NPC_START + 33)\n#define NPC_MIDGE    (NPC_START + 34)\n#define NPC_ACE      (NPC_START + 35)\n#define NPC_TWIRP    (NPC_START + 36)\n// bulls)\n#define NPC_CHUCK    (NPC_START + 37)\n#define NPC_STU      (NPC_START + 38)\n// chickens\n#define NPC_GOOSE    (NPC_START + 39)\n#define NPC_BETTY    (NPC_START + 40)\n#define NPC_HECTOR   (NPC_START + 41)\n#define NPC_EGBERT   (NPC_START + 42)\n#define NPC_AVA      (NPC_START + 43)\n#define NPC_HANK     (NPC_START + 44)\n#define NPC_LEIGH    (NPC_START + 45)\n#define NPC_RHODA    (NPC_START + 46)\n// cubs\n#define NPC_VLADIMIR (NPC_START + 47)\n#define NPC_MURPHY   (NPC_START + 48)\n#define NPC_CUPCAKE  (NPC_START + 49)\n#define NPC_KODY     (NPC_START + 50)\n#define NPC_MAPLE    (NPC_START + 51)\n#define NPC_PUDGE    (NPC_START + 52)\n#define NPC_OLIVE    (NPC_START + 53)\n#define NPC_PONCHO   (NPC_START + 54)\n#define NPC_BLUEBEAR (NPC_START + 55)\n// cows\n#define NPC_PATTY    (NPC_START + 56)\n#define NPC_PETUNIA  (NPC_START + 57)\n#define NPC_BESSIE   (NPC_START + 58)\n#define NPC_BELLE    (NPC_START + 59)\n// crocodiles / alligators\n#define NPC_ALFONSO  (NPC_START + 60)\n#define NPC_BOOTS    (NPC_START + 61)\n#define NPC_LIZ      (NPC_START + 62)\n#define NPC_BISKIT   (NPC_START + 63)\n// dogs\n#define NPC_GOLDIE   (NPC_START + 64)\n#define NPC_DAISY    (NPC_START + 65)\n#define NPC_LUCKY    (NPC_START + 66)\n#define NPC_PORTIA   (NPC_START + 67)\n#define NPC_MADDIE   (NPC_START + 68)\n#define NPC_BUTCH    (NPC_START + 69)\n// ducks\n#define NPC_BILL     (NPC_START + 70)\n#define NPC_POMPOM   (NPC_START + 71)\n#define NPC_JOEY     (NPC_START + 72)\n#define NPC_SCOOT    (NPC_START + 73)\n#define NPC_DERWIN   (NPC_START + 74)\n#define NPC_FRECKLES (NPC_START + 75)\n// elephants\n#define NPC_PAOLO    (NPC_START + 76)\n#define NPC_DIZZY    (NPC_START + 77)\n#define NPC_AXEL     (NPC_START + 78)\n// frogs\n#define NPC_EMERALD  (NPC_START + 79)\n#define NPC_TAD      (NPC_START + 80)\n#define NPC_WART_JR  (NPC_START + 81)\n#define NPC_COUSTEAU (NPC_START + 82)\n#define NPC_PUDDLES  (NPC_START + 83)\n#define NPC_LILY     (NPC_START + 84)\n#define NPC_JEREMIAH (NPC_START + 85)\n#define NPC_HUCK     (NPC_START + 86)\n#define NPC_CAMOFROG (NPC_START + 87)\n#define NPC_RIBBOT   (NPC_START + 88)\n#define NPC_PRINCE   (NPC_START + 89)\n#define NPC_JAMBETTE (NPC_START + 90)\n// goats\n#define NPC_BILLY    (NPC_START + 91)\n#define NPC_CHEVRE   (NPC_START + 92)\n#define NPC_IGGY     (NPC_START + 93)\n#define NPC_GRUFF    (NPC_START + 94)\n#define NPC_SVEN     (NPC_START + 95)\n#define NPC_VELMA    (NPC_START + 96)\n// gorillas\n#define NPC_JANE     (NPC_START + 97)\n#define NPC_CESAR    (NPC_START + 98)\n#define NPC_LOUIE    (NPC_START + 99)\n#define NPC_PEEWEE   (NPC_START + 100)\n// hippos\n#define NPC_ROLLO    (NPC_START + 101)\n#define NPC_BUBBLES  (NPC_START + 102)\n#define NPC_BERTHA   (NPC_START + 103)\n// horses\n#define NPC_ELMER    (NPC_START + 104)\n#define NPC_WINNIE   (NPC_START + 105)\n#define NPC_SAVANNAH (NPC_START + 106)\n#define NPC_ED       (NPC_START + 107)\n#define NPC_CLEO     (NPC_START + 108)\n#define NPC_PEACHES  (NPC_START + 109)\n#define NPC_BUCK     (NPC_START + 110)\n// kangaroos\n#define NPC_CARRIE   (NPC_START + 111)\n#define NPC_MATHILDA (NPC_START + 112)\n#define NPC_MARCY    (NPC_START + 113)\n#define NPC_KITT     (NPC_START + 114)\n#define NPC_VALISE   (NPC_START + 115)\n#define NPC_ASTRID   (NPC_START + 116)\n// koalas\n#define NPC_SYDNEY   (NPC_START + 117)\n#define NPC_GONZO    (NPC_START + 118)\n#define NPC_OZZIE    (NPC_START + 119)\n#define NPC_YUKA     (NPC_START + 120)\n#define NPC_HUGGY    (NPC_START + 121)\n// lions\n#define NPC_REX      (NPC_START + 122)\n#define NPC_AZIZ     (NPC_START + 123)\n#define NPC_LEOPOLD  (NPC_START + 124)\n// mice\n#define NPC_SAMSON   (NPC_START + 125)\n#define NPC_PENNY    (NPC_START + 126)\n#define NPC_DORA     (NPC_START + 127)\n#define NPC_CHICO    (NPC_START + 128)\n#define NPC_CANDI    (NPC_START + 129)\n#define NPC_RIZZO    (NPC_START + 130)\n#define NPC_ANICOTTI (NPC_START + 131)\n#define NPC_LIMBERG  (NPC_START + 132)\n#define NPC_CARMEN   (NPC_START + 133)\n// octopus\n#define NPC_OCTAVIAN (NPC_START + 134)\n// ostriches\n#define NPC_SANDY    (NPC_START + 135)\n#define NPC_SPROCKET (NPC_START + 136)\n#define NPC_RIO      (NPC_START + 137)\n#define NPC_QUEENIE  (NPC_START + 138)\n// eagles\n#define NPC_APOLLO   (NPC_START + 139)\n#define NPC_BUZZ     (NPC_START + 140)\n#define NPC_QUETZAL  (NPC_START + 141)\n#define NPC_AMELIA   (NPC_START + 142)\n#define NPC_PIERCE   (NPC_START + 143)\n// penguins\n#define NPC_ROALD    (NPC_START + 144)\n#define NPC_AURORA   (NPC_START + 145)\n#define NPC_HOPPER   (NPC_START + 146)\n#define NPC_CUBE     (NPC_START + 147)\n#define NPC_PUCK     (NPC_START + 148)\n#define NPC_GWEN     (NPC_START + 149)\n#define NPC_FRIGA    (NPC_START + 150)\n// pigs\n#define NPC_CURLY    (NPC_START + 151)\n#define NPC_TRUFFLES (NPC_START + 152)\n#define NPC_SPORK    (NPC_START + 153)\n#define NPC_HUGH     (NPC_START + 154)\n#define NPC_RASHER   (NPC_START + 155)\n#define NPC_SUE_E    (NPC_START + 156)\n#define NPC_HAMBO    (NPC_START + 157)\n#define NPC_LUCY     (NPC_START + 158)\n#define NPC_COBB     (NPC_START + 159)\n#define NPC_BORIS    (NPC_START + 160)\n// rabbits\n#define NPC_BUNNIE   (NPC_START + 161)\n#define NPC_DOC      (NPC_START + 162)\n#define NPC_GASTON   (NPC_START + 163)\n#define NPC_COCO     (NPC_START + 164)\n#define NPC_GABI     (NPC_START + 165)\n#define NPC_DOTTY    (NPC_START + 166)\n#define NPC_GENJI    (NPC_START + 167)\n#define NPC_SNAKE    (NPC_START + 168)\n#define NPC_CLAUDE   (NPC_START + 169)\n// rhinos \n#define NPC_TANK     (NPC_START + 170)\n#define NPC_SPIKE    (NPC_START + 171)\n#define NPC_TIARA    (NPC_START + 172)\n// sheep\n#define NPC_VESTA    (NPC_START + 173)\n// squirrels\n#define NPC_FILBERT  (NPC_START + 174)\n#define NPC_HAZEL    (NPC_START + 175)\n#define NPC_PEANUT   (NPC_START + 176)\n#define NPC_PECAN    (NPC_START + 177)\n#define NPC_RICKY    (NPC_START + 178)\n#define NPC_STATIC   (NPC_START + 179)\n#define NPC_MINT     (NPC_START + 180)\n#define NPC_NIBBLES  (NPC_START + 181)\n// tigers\n#define NPC_TYBALT   (NPC_START + 182)\n#define NPC_ROLF     (NPC_START + 183)\n#define NPC_BANGLE   (NPC_START + 184)\n// wolves\n#define NPC_LOBO     (NPC_START + 185)\n#define NPC_FREYA    (NPC_START + 186)\n#define NPC_CHIEF    (NPC_START + 187)\n// late additions\n#define NPC_WEBER    (NPC_START + 188)\n#define NPC_MALLARY  (NPC_START + 189)\n#define NPC_WOLFGANG (NPC_START + 190)\n#define NPC_HORNSBY  (NPC_START + 191)\n#define NPC_OXFORD   (NPC_START + 192)\n#define NPC_T_BONE   (NPC_START + 193)\n#define NPC_BIFF     (NPC_START + 194)\n#define NPC_OPAL     (NPC_START + 195)\n#define NPC_BONES    (NPC_START + 196)\n#define NPC_BEA      (NPC_START + 197)\n#define NPC_BITTY    (NPC_START + 198)\n#define NPC_ROCCO    (NPC_START + 199)\n#define NPC_LULU     (NPC_START + 200)\n#define NPC_BLAIRE   (NPC_START + 201)\n#define NPC_SALLY    (NPC_START + 202)\n#define NPC_ELLIE    (NPC_START + 203)\n#define NPC_ELOISE   (NPC_START + 204)\n#define NPC_ALLI     (NPC_START + 205)\n#define NPC_PIPPY    (NPC_START + 206)\n#define NPC_EUNICE   (NPC_START + 207)\n#define NPC_BAABARA  (NPC_START + 208)\n#define NPC_FANG     (NPC_START + 209)\n#define NPC_DEENA    (NPC_START + 210)\n#define NPC_PATE     (NPC_START + 211)\n#define NPC_STELLA   (NPC_START + 212)\n#define NPC_CASHMERE (NPC_START + 213)\n#define NPC_WOOLIO   (NPC_START + 214)\n#define NPC_COOKIE   (NPC_START + 215)\n// gamecube additions\n#define NPC_MAELLE   (NPC_START + 216)\n#define NPC_OHARE    (NPC_START + 217)\n#define NPC_BLISS    (NPC_START + 218)\n#define NPC_DRIFT    (NPC_START + 219)\n#define NPC_BUD      (NPC_START + 220)\n#define NPC_BOOMER   (NPC_START + 221)\n#define NPC_ELINA    (NPC_START + 222)\n#define NPC_FLASH    (NPC_START + 223)\n#define NPC_DOBIE    (NPC_START + 224)\n#define NPC_FLOSSIE  (NPC_START + 225)\n#define NPC_ANNALISE (NPC_START + 226)\n#define NPC_PLUCKY   (NPC_START + 227)\n#define NPC_FAITH    (NPC_START + 228)\n#define NPC_YODEL    (NPC_START + 229)\n#define NPC_ROWAN    (NPC_START + 230)\n#define NPC_JUNE     (NPC_START + 231)\n#define NPC_CHERI    (NPC_START + 232)\n#define NPC_PIGLEG   (NPC_START + 233)\n#define NPC_ANKHA    (NPC_START + 234)\n#define NPC_PUNCHY   (NPC_START + 235)\n#define NPC_END      (NPC_START + 236)\n\n#define DUMMY_START 0xF000\n#define DUMMY_HANIWA0 0xF0FB\n#define DUMMY_HANIWA1 (DUMMY_HANIWA0 + 1)\n#define DUMMY_HANIWA2 (DUMMY_HANIWA1 + 1)\n#define DUMMY_HANIWA3 (DUMMY_HANIWA2 + 1)\n#define DUMMY_RESERVE 0xF102\n#define DUMMY_SHRINE 0xF103\n#define DUMMY_RADIO 0xF109\n#define DUMMY_TAMA 0xF110\n#define DUMMY_DOUZOU 0xF11D\n#define DUMMY_NAMEPLATE 0xF11F\n\n#define RSV_DOOR 0xFE1B\n#define RSV_FE1C 0xFE1C\n#define RSV_FE1F 0xFE1F\n#define RSV_CLOTH 0xFE20\n#define RSV_ISLAND_FTR0 0xFEB3  /* mRmTp_FTRSIZE_1x1 S */\n#define RSV_ISLAND_FTR1 0xFEB4  /* mRmTp_FTRSIZE_1x1 E */\n#define RSV_ISLAND_FTR2 0xFEB5  /* mRmTp_FTRSIZE_1x1 N */\n#define RSV_ISLAND_FTR3 0xFEB6  /* mRmTp_FTRSIZE_1x1 W */\n#define RSV_ISLAND_FTR4 0xFEB7  /* mRmTp_FTRSIZE_1x1 S */\n#define RSV_ISLAND_FTR5 0xFEB8  /* mRmTp_FTRSIZE_1x1 E */\n#define RSV_ISLAND_FTR6 0xFEB9  /* mRmTp_FTRSIZE_1x1 N */\n#define RSV_ISLAND_FTR7 0xFEBA  /* mRmTp_FTRSIZE_1x1 W */\n#define RSV_ISLAND_FTR8 0xFEBB  /* mRmTp_FTRSIZE_1x2 S */\n#define RSV_ISLAND_FTR9 0xFEBC  /* mRmTp_FTRSIZE_1x2 E */\n#define RSV_ISLAND_FTR10 0xFEBD /* mRmTp_FTRSIZE_1x2 N */\n#define RSV_ISLAND_FTR11 0xFEBE /* mRmTp_FTRSIZE_1x2 W */\n#define RSV_ISLAND_FTR12 0xFEBF /* mRmTp_FTRSIZE_2x2 S */\n#define RSV_ISLAND_FTR13 0xFEC0 /* mRmTp_FTRSIZE_2x2 E */\n#define RSV_ISLAND_FTR14 0xFEC1 /* mRmTp_FTRSIZE_2x2 N */\n#define RSV_ISLAND_FTR15 0xFEC2 /* mRmTp_FTRSIZE_2x2 W */\n#define RSV_WALL_NO 0xFFFE /* interior wall item, no collision */\n#define RSV_NO 0xFFFF /* reserved space, can't interact but no collision */\n\n#define mNT_IS_RESERVE(n) ((n) >= SIGN00 && (n) <= SIGN20)\n\n/* sizeof(mFI_unit_c) == 0x14 */\ntypedef struct location_info_s {\n  /* 0x00 */ int block_x;\n  /* 0x04 */ int block_z;\n  /* 0x08 */ int unit_x;\n  /* 0x0C */ int unit_z;\n  /* 0x10 */ mActor_name_t* block_data;\n} mFI_unit_c;\n\n#define mRF_BLOCKKIND_NONE (0 << 0)\n#define mRF_BLOCKKIND_PLAYER (1 << 0)\n#define mRF_BLOCKKIND_SHOP (1 << 1)\n#define mRF_BLOCKKIND_SHRINE (1 << 2)\n#define mRF_BLOCKKIND_POLICE (1 << 3)\n#define mRF_BLOCKKIND_POSTOFFICE (1 << 4)\n#define mRF_BLOCKKIND_STATION (1 << 5)\n#define mRF_BLOCKKIND_CLIFF (1 << 6)\n#define mRF_BLOCKKIND_RIVER (1 << 7)\n#define mRF_BLOCKKIND_WATERFALL (1 << 8)\n#define mRF_BLOCKKIND_BRIDGE (1 << 9)\n#define mRF_BLOCKKIND_RAILROAD (1 << 10)\n#define mRF_BLOCKKIND_BEACH (1 << 11)\n#define mRF_BLOCKKIND_BORDER (1 << 12)\n#define mRF_BLOCKKIND_TUNNEL (1 << 13)\n#define mRF_BLOCKKIND_SLOPE (1 << 14)\n#define mRF_BLOCKKIND_POOL (1 << 15)\n#define mRF_BLOCKKIND_DUMP (1 << 16)\n#define mRF_BLOCKKIND_MUSEUM (1 << 17)\n#define mRF_BLOCKKIND_18 (1 << 18)\n#define mRF_BLOCKKIND_TAILORS (1 << 19)\n#define mRF_BLOCKKIND_OCEAN (1 << 20)\n#define mRF_BLOCKKIND_ISLAND_RIGHT (1 << 21)\n#define mRF_BLOCKKIND_OFFING (1 << 22)\n#define mRF_BLOCKKIND_23 (1 << 23)\n#define mRF_BLOCKKIND_24 (1 << 24)\n#define mRF_BLOCKKIND_25 (1 << 25)\n#define mRF_BLOCKKIND_26 (1 << 26)\n#define mRF_BLOCKKIND_27 (1 << 27)\n#define mRF_BLOCKKIND_28 (1 << 28)\n#define mRF_BLOCKKIND_29 (1 << 29)\n#define mRF_BLOCKKIND_DOCK (1 << 30)\n#define mRF_BLOCKKIND_ISLAND_LEFT (1 << 31)\n\ntypedef struct xyz_t {\n    f32 x, y, z;\n} xyz_t;\n\ntypedef struct s_xyz_s {\n    s16 x, y, z;\n} s_xyz;\n\n#define PLAYER_NUM 4\n#define FOREIGNER_NUM 1\n#define TOTAL_PLAYER_NUM (PLAYER_NUM + FOREIGNER_NUM)\n\n#define mPr_FLAG_MASK_CAT_SCHEDULED (1 << 0) // Blanca appears when travelling\n#define mPr_FLAG_POSTOFFICE_GIFT0 (1 << 2) // 1,000,000 Bells\n#define mPr_FLAG_POSTOFFICE_GIFT1 (1 << 3) // 10,000,000 Bells\n#define mPr_FLAG_POSTOFFICE_GIFT2 (1 << 4) // 100,000,000 Bells\n#define mPr_FLAG_POSTOFFICE_GIFT3 (1 << 5) // 999,999,999 Bells\n#define mPr_FLAG_MUSEUM_COMP_HANDBILL_SCHEDULED (1 << 6) // player is scheduled to receive completion letter & reward\n#define mPr_FLAG_MUSEUM_COMP_HANDBILL_RECEIVED (1 << 7) // player has received the completion letter & reward\n\n#define mPr_POCKETS_SLOT_COUNT 15\n#define mPr_INVENTORY_MAIL_COUNT 10\n#define mPr_DELIVERY_QUEST_NUM mPr_POCKETS_SLOT_COUNT\n#define mPr_ERRAND_QUEST_NUM 5\n#define mPr_CATALOG_ORDER_NUM 5\n#define mPr_FOREIGN_MAP_COUNT 8\n#define mPr_ORIGINAL_DESIGN_COUNT 8\n\n#define mPr_SUNBURN_MIN_RANK 0\n#define mPr_SUNBURN_MAX_RANK 8\n\n\n\n\n// Town name character count\n#define LAND_NAME_SIZE 8\n#define LAND_NAME_MURA_SIZE (LAND_NAME_SIZE + 2)\n\n/* sizeof(mLd_land_info_c) == 0x0C */\ntypedef struct land_info_s {\n  /* 0x00 */ u8 name[LAND_NAME_SIZE];\n  /* 0x08 */ s8 exists;\n  /* 0x0A */ u16 id;\n} mLd_land_info_c;\n\n\n#define mMsm_REMAIL_SLOTS 30\n\n/* sizeof(mMsm_remail_display_c) = 1 */\ntypedef struct museum_remail_display_s {\n  u8 display_type_upper:4;\n  u8 display_type_lower:4;\n} mMsm_remail_display_c;\n\n/* sizeof(mMsm_remail_info_c) == 0x4C */\ntypedef struct museum_remail_info_s {\n  /* 0x00 */ mMsm_remail_display_c types[mMsm_REMAIL_SLOTS / 2]; /* display types for items */\n  /* 0x10 */ mActor_name_t items[mMsm_REMAIL_SLOTS]; /* item storage */\n} mMsm_remail_info_c;\n\n/* sizeof(mMsm_mail_info_c) == 0x4E */\ntypedef struct museum_mail_info_s {\n  u8 contacted:1; /* set to TRUE when the museum has contacted the player */\n  u8 unused:1; /* unused where this is used, if at all */\n  u8 send_info_mail:1; /* if set to true, museum info mail will be sent */\n  u8 stored_item_num:5; /* number of stored items */\n\n  mMsm_remail_info_c remail_info; /* remail info */\n} mMsm_mail_info_c;\n\n#define PLAYER_NAME_LEN 8\n\n/* sizeof(PersonalID_c) == 0x14 */\ntypedef struct personal_id_s {\n  /* 0x00 */ u8 player_name[PLAYER_NAME_LEN];\n  /* 0x08 */ u8 land_name[LAND_NAME_SIZE];\n  /* 0x10 */ u16 player_id;\n  /* 0x12 */ u16 land_id;\n} PersonalID_c;\n\n\n#define MAIL_HEADER_LEN (32 - PLAYER_NAME_LEN)\n#define MAIL_FOOTER_LEN 32\n#define MAIL_BODY_LEN 192\n\nenum {\n  mMl_NAME_TYPE_PLAYER,\n  mMl_NAME_TYPE_NPC,\n  mMl_NAME_TYPE_MUSEUM,\n\n  mMl_NAME_TYPE_NUM,\n  mMl_NAME_TYPE_CLEAR = 0xFF\n};\n\nenum {\n  mMl_TYPE_MAIL = 0,\n  mMl_TYPE_XMAS = 1,\n  mMl_TYPE_SHOP_SALE_LEAFLET = 2,\n  mMl_TYPE_BROKER_SALE_LEAFLET = 3,\n  mMl_TYPE_4 = 4,\n  mMl_TYPE_5 = 5,\n\n  mMl_TYPE_HRA = 6,\n\n  mMl_TYPE_FISHING_CONTENST = 9,\n\n  mMl_TYPE_SPNPC_PASSWORD = 11,\n  mMl_TYPE_12 = 12\n};\n\n\n/* sizeof(Mail_nm_c) == 0x16 */\ntypedef struct mail_nm_s {\n  /* 0x00 */ PersonalID_c personalID;\n  /* 0x14 */ u8 type;\n} Mail_nm_c;\n\n/* sizeof(mail_header_save_s) == 0x3A */\ntypedef struct mail_header_save_s {\n  /* 0x00 */ s8 header_back_start;\n  /* 0x01 */ u8 unknown;\n  /* 0x02 */ u8 header[MAIL_HEADER_LEN];\n  /* 0x1A */ u8 footer[MAIL_FOOTER_LEN];\n} Mail_hs_c;\n\n/* sizeof(Mail_hdr_c) == 0x2C */\ntypedef struct mail_header_s {\n  /* 0x00 */ Mail_nm_c recipient;\n  /* 0x16 */ Mail_nm_c sender;\n} Mail_hdr_c;\n\n/* sizeof(Mail_ct_c) == 0xFC */\ntypedef struct mail_content_s {\n  /* 0x00 */ u8 font;\n  /* 0x01 */ u8 header_back_start;\n  /* 0x02 */ u8 mail_type;\n  /* 0x03 */ u8 paper_type;\n  /* 0x04 */ u8 header[MAIL_HEADER_LEN];\n  /* 0x1C */ u8 body[MAIL_BODY_LEN];\n  /* 0xDC */ u8 footer[MAIL_FOOTER_LEN];\n} Mail_ct_c;\n\n/* sizeof(Mail_c) == 0x12A */\ntypedef struct mail_s {\n  /* 0x000 */ Mail_hdr_c header;\n  /* 0x02C */ mActor_name_t present;\n  /* 0x02E */ Mail_ct_c content;\n} Mail_c;\n\n#define HOME_MAILBOX_SIZE 10\n#define HANIWA_ITEM_HOLD_NUM 4\n#define HANIWA_MESSAGE_LEN 128\n#define mHm_LAYER_NUM 4\n\nenum {\n  mHm_ROOM_MAIN,\n  mHm_ROOM_UPPER,\n  mHm_ROOM_BASEMENT,\n\n  mHm_ROOM_NUM\n};\n\nenum {\n  mHm_ROOMTYPE_SMALL,\n  mHm_ROOMTYPE_MEDIUM,\n  mHm_ROOMTYPE_LARGE,\n  mHm_ROOMTYPE_COTTAGE,\n\n  mHm_ROOMTYPE_NUM\n};\n\nenum {\n  mHm_HOMESIZE_SMALL,   /* initial size */\n  mHm_HOMESIZE_MEDIUM,  /* paid off first debt */\n  mHm_HOMESIZE_LARGE,   /* paid off second debt (excluding basement) */\n  mHm_HOMESIZE_UPPER,   /* paid off third debt & basement */\n  mHm_HOMESIZE_STATUE,  /* paid off final debt */\n\n  mHm_HOMESIZE_NUM\n};\n\n#define UT_X_NUM 16 /* Spaces per block (acre) in x direction */\n#define UT_Z_NUM 16 /* Spaces per block (acre) in z direction */\n\n/* sizeof(TempoBeat_c) == 2 */\ntypedef struct audio_tempo_beat_s {\n  /* 0x00 */ u8 tempo;\n  /* 0x01 */ s8 beat;\n} TempoBeat_c;\n\n\ntypedef u8 lbRTC_sec_t;\ntypedef u8 lbRTC_min_t;\ntypedef u8 lbRTC_hour_t;\ntypedef u8 lbRTC_day_t;\ntypedef u8 lbRTC_weekday_t;\ntypedef u8 lbRTC_month_t;\ntypedef u16 lbRTC_year_t;\n\ntypedef struct lbRTC_datetime_s {\n  lbRTC_sec_t sec;\n  lbRTC_min_t min;\n  lbRTC_hour_t hour;\n  lbRTC_day_t day;\n  lbRTC_weekday_t weekday;\n  lbRTC_month_t month;\n  lbRTC_year_t year;\n} lbRTC_time_c; /* Name leaked in lbRTC_time_c_save_data_check */\n\ntypedef struct lbRTC_ymd_s {\n  lbRTC_year_t year;\n  lbRTC_month_t month;\n  lbRTC_day_t day;\n} lbRTC_ymd_c; /* Name leaked in mTM_ymd_2_time */\n\n/* sizeof(AnmPersonalID_c) == 0xE */\ntypedef struct animal_personal_id_s {\n  /* 0x00 */ mActor_name_t npc_id; /* id */\n  /* 0x02 */ u16 land_id; /* town id */\n  /* 0x04 */ u8 land_name[LAND_NAME_SIZE]; /* town name */\n  /* 0x0C */ u8 name_id; /* lower byte of the id */\n  /* 0x0D */ u8 looks; /* internal name for personality */\n} AnmPersonalID_c;\n\n\n\n#define mQst_MAX_TIME_LIMIT_DAYS 28\n#define mQst_CHECK_NPC_RECEIPIENT 0\n#define mQst_CHECK_NPC_SENDER 1\n\n#define mQst_LETTER_RANK_MIN 0\n#define mQst_LETTER_RANK_0 mQst_LETTER_RANK_MIN\n#define mQst_LETTER_RANK_1 1\n#define mQst_LETTER_RANK_2 2\n#define mQst_LETTER_RANK_3 3\n#define mQst_LETTER_RANK_4 4\n#define mQst_LETTER_RANK_5 5\n#define mQst_LETTER_RANK_6 6\n#define mQst_LETTER_RANK_7 7\n#define mQst_LETTER_RANK_8 8\n#define mQst_LETTER_RANK_9 9\n#define mQst_LETTER_RANK_10 10\n#define mQst_LETTER_RANK_11 11\n#define mQst_LETTER_RANK_MAX mQst_LETTER_RANK_11 + 1\n\n#define mQst_LETTER_SCORE_BONUS 3 /* Given when the raw score of the letter has passed the threshold */\n#define mQst_LETTER_PRESENT_BONUS 6 /* Given when a present is attached */\n\n#define mQst_LETTER_OKAY_LENGTH 17\n#define mQst_LETTER_GOOD_LENGTH 49\n\nenum {\n  mQst_QUEST_TYPE_DELIVERY, /* Deliver item quest */\n  mQst_QUEST_TYPE_ERRAND,   /* Villager 'can I help' quests */\n  mQst_QUEST_TYPE_CONTEST,  /* Villager send letter, plant flowers, bring ball, etc */\n  mQst_QUEST_TYPE_NONE,\n  \n  mQst_QUEST_TYPE_NUM = mQst_QUEST_TYPE_NONE\n};\n\n/* sizeof(mQst_base_c) == 0xC */\ntypedef struct quest_base_s {\n  /* 0x00 */ u32 quest_type:2; /* type, 0 = delivery, 1 = errand, 2 = contest, 3 = none */\n  /* 0x00 */ u32 quest_kind:6; /* kind, differs by type */\n  /* 0x01 */ u32 time_limit_enabled:1; /* when set, the time limit will be utilized */\n  /* 0x01 */ u32 progress:4; /* progress towards quest goal */\n  /* 0x01 */ u32 give_reward:1; /* set to true when player cannot take the item, and will skip quest completion checks */\n  /* 0x01 */ u32 unused:2;\n\n  /* 0x02 */ lbRTC_time_c time_limit;\n} mQst_base_c;\n\n/* Contest Quest */\n\nenum {\n  mQst_CONTEST_KIND_FRUIT,   /* get fruit for villager */\n  mQst_CONTEST_KIND_SOCCER,  /* get ball for villager */\n  mQst_CONTEST_KIND_SNOWMAN, /* build snowman for villager */\n  mQst_CONTEST_KIND_FLOWER,  /* plant flowers for villager */\n  mQst_CONTEST_KIND_FISH,    /* get fish for villager */\n  mQst_CONTEST_KIND_INSECT,  /* get insect for villager */\n  mQst_CONTEST_KIND_LETTER,  /* send letter to villager */\n\n  mQst_CONTEST_KIND_NUM\n};\n\n/* sizeof(mQst_contest_info_u) == 4 */\ntypedef union quest_contest_info_s {\n  struct {\n    /* 0x00 */ u8 flowers_requested; /* number of flowers village requests be planted in acre */\n  } flower_data;\n\n  struct {\n    /* 0x00 */ u8 score; /* score rank of letter */\n    /* 0x02 */ mActor_name_t present; /* present sent with letter */\n  } letter_data;\n} mQst_contest_info_u;\n\n/* sizeof(mQst_contest_c) == 0x28 */\ntypedef struct quest_contest_s {\n  /* 0x00 */ mQst_base_c base; /* quest base struct */\n  /* 0x0C */ mActor_name_t requested_item; /* item (if any) requested by the villager */\n  /* 0x0E */ PersonalID_c player_id; /* personal id of the player */\n  /* 0x22 */ s8 type; /* type of quest, seems to be repeat of data in quest base */\n  /* 0x24 */ mQst_contest_info_u info; /* contest info for flower & letter quests */\n} mQst_contest_c;\n\n/* Delivery Quest */\n\n/* sizeof(mQst_delivery_c) == 0x28 */\ntypedef struct quest_delivery_s {\n  /* 0x00 */ mQst_base_c base; /* quest base info */\n  /* 0x0C */ AnmPersonalID_c recipient; /* villager who will receive it */\n  /* 0x1A */ AnmPersonalID_c sender; /* villager who sent it */\n} mQst_delivery_c;\n\n/* Errand Quest */\n#define mQst_ERRAND_FIRST_JOB_ANIMAL_NUM 2\n#define mQst_ERRAND_CHAIN_ANIMAL_NUM 3\n\nenum {\n  mQst_ERRAND_REQUEST,\n  mQst_ERRAND_REQUEST_CONTINUE,\n  mQst_ERRAND_REQUEST_FINAL,\n  \n  mQst_ERRAND_FIRSTJOB_CHANGE_CLOTH,\n  mQst_ERRAND_FIRSTJOB_PLANT_FLOWER,\n  mQst_ERRAND_FIRSTJOB_DELIVER_FTR,\n  mQst_ERRAND_FIRSTJOB_SEND_LETTER,\n  mQst_ERRAND_FIRSTJOB_DELIVER_CARPET,\n  mQst_ERRAND_FIRSTJOB_DELIVER_AXE,\n  mQst_ERRAND_FIRSTJOB_POST_NOTICE,\n  mQst_ERRAND_FIRSTJOB_SEND_LETTER2,\n  mQst_ERRAND_FIRSTJOB_DELIVER_AXE2,\n  mQst_ERRAND_FIRSTJOB_INTRODUCTIONS,\n  mQst_ERRAND_FIRSTJOB_OPEN,\n  mQst_ERRAND_FIRSTJOB_START,\n\n  mQst_ERRAND_NUM\n};\n\nenum {\n  mQst_ERRAND_TYPE_NONE,\n  mQst_ERRAND_TYPE_CHAIN,\n  mQst_ERRAND_TYPE_FIRST_JOB,\n\n  mQst_ERRAND_TYPE_NUM\n};\n\n/* sizeof(mQst_first_job_c) == 0x20 */\ntypedef struct quest_first_job_s {\n  /* 0x00 */ AnmPersonalID_c used_ids[mQst_ERRAND_FIRST_JOB_ANIMAL_NUM]; /* villagers already used for first job quest (furniture, then letter) */\n  /* 0x1C */ u8 used_num:7; /* used count for 'used_ids' */\n  /* 0x1C */ u8 wrong_cloth:1; /* set to TRUE if player changes out of work uniform during chores */\n} mQst_firstjob_c;\n\n/* sizeof(mQst_errand_chain_c) == 0x2C */\ntypedef struct quest_errand_chain_s {\n  /* 0x00 */ AnmPersonalID_c used_ids[mQst_ERRAND_CHAIN_ANIMAL_NUM];\n  /* 0x2A */ u8 used_num;\n} mQst_errand_chain_c;\n\n/* sizeof(mQst_errand_info_u) == 0x2C */\ntypedef union {\n  mQst_errand_chain_c chain;\n  mQst_firstjob_c first_job;\n} mQst_errand_info_u;\n\n/* sizeof(mQst_errand_c) == 0x58 */\ntypedef struct quest_errand_s {\n  /* 0x00 */ mQst_base_c base; /* quest base info */\n  /* 0x0C */ AnmPersonalID_c recipient; /* villager who will receive it */\n  /* 0x1A */ AnmPersonalID_c sender; /* villager who sent it */\n  /* 0x28 */ mActor_name_t item; /* errand item */\n  /* 0x2A */ s8 pockets_idx:5; /* index in player pockets where the errand item is */\n  /* 0x2A */ s8 errand_type:3; /* errand type */\n  /* 0x2C */ mQst_errand_info_u info; /* errand type-specific data */\n} mQst_errand_c;\n\n/* 'Not Saved' Quest */\ntypedef struct not_saved_quest_s {\n  int work;\n  u8 h;\n} mQst_not_saved_c;\n\nenum {\n  mPr_DESTINY_NORMAL,     /* standard fortune state */\n  mPr_DESTINY_POPULAR,    /* good luck with villagers */\n  mPr_DESTINY_UNPOPULAR,  /* bad luck with villagers */\n  mPr_DESTINY_BAD_LUCK,   /* bad luck in general */\n  mPr_DESTINY_MONEY_LUCK, /* good money luck */\n  mPr_DESTINY_GOODS_LUCK, /* good goods/item luck */\n\n  mPr_DESTINY_NUM\n};\n\n/* sizeof(mPr_destiny_c) == 0xA */\ntypedef struct player_destiny_s {\n  /* 0x00 */ lbRTC_time_c received_time; /* time fortune was received */\n  /* 0x08 */ u8 type; /* fortune type */ \n} mPr_destiny_c;\n\n/* sizeof(mPr_birthday_c) == 4 */\ntypedef struct player_birthday_s {\n  /* 0x00 */ u16 year; /* assumed, set in mPr_ClearPrivateBirthday but goes unused elsewhere */\n  /* 0x02 */ u8 month;\n  /* 0x03 */ u8 day;\n} mPr_birthday_c;\n\n/* sizeof(mPr_catalog_order_c) == 4 */\ntypedef struct player_catalog_order_s {\n  /* 0x00 */ mActor_name_t item; /* ordered item */\n  /* 0x02 */ u8 shop_level; /* shop 'level' at time of order */\n} mPr_catalog_order_c;\n\n/* sizeof(mPr_animal_memory_c) == 0xA */\ntypedef struct player_animal_memory_s {\n  /* 0x00 */ mActor_name_t npc_id;\n  /* 0x02 */ u8 land_name[LAND_NAME_SIZE];\n} mPr_animal_memory_c;\n\n/* sizeof(mPr_map_info_c) == 0xA */\ntypedef struct player_map_s {\n  /* 0x00 */ u8 land_name[LAND_NAME_SIZE];\n  /* 0x08 */ u16 land_id;\n} mPr_map_info_c;\n\n/* sizeof(mPr_day_day_c) == 6 */\ntypedef struct player_day_day_s {\n  /* 0x00 */ lbRTC_ymd_c last_date; /* last date modified */\n  /* 0x04 */ u8 days; /* number of unique days */\n} mPr_day_day_c;\n\n/* sizeof(mPr_sunburn_c) == 6 */\ntypedef struct player_sunburn_s {\n  /* 0x00 */ lbRTC_ymd_c last_changed_date; /* last date that the sunburn rank changed */\n  /* 0x04 */ s8 rank; /* level of sunburn, 0-8 */\n  /* 0x05 */ s8 rankdown_days; /* days until sunburn rank decreases */\n} mPr_sunburn_c;\n\n/* sizeof(mPr_carde_data_c) == 0x32 */\ntypedef struct player_ecard_data_s {\n  /* 0x00 */ lbRTC_ymd_c letter_send_date; /* date the latest eCard letter was sent */\n  /* 0x04 */ u8 card_letters_sent[46]; /* bitfield keeping track of which eCard letters have been sent to the player [0, 366] */\n} mPr_carde_data_c;\n\n#define mPr_MOTHER_MAIL_NORMAL_NUM 7\n#define mPr_MOTHER_MAIL_MONTHLY_NUM 2\n\ntypedef struct private_mother_mail_data_s {\n  u8 normal[mPr_MOTHER_MAIL_NORMAL_NUM];\n  u8 monthly[mPr_MOTHER_MAIL_MONTHLY_NUM];\n  u8 august; // unique byte for month of august\n} mPr_mother_mail_data_c;\n\ntypedef struct private_mother_mail_info_s {\n  lbRTC_ymd_c date;\n  mPr_mother_mail_data_c data;\n} mPr_mother_mail_info_c;\n\n#define ANIMAL_NUM_MIN  5\n#define ANIMAL_NUM_MAX 15 /* Maximum number of villagers possible in town */\n#define ANIMAL_MEMORY_NUM 7\n#define ANIMAL_CATCHPHRASE_LEN 10\n#define ANIMAL_HP_MAIL_NUM 4\n#define ANIMAL_NAME_LEN PLAYER_NAME_LEN\n#define mNpc_ISLAND_FTR_SAVE_NUM 4\n#define mNpc_EVENT_NPC_NUM 5\n#define mNpc_MASK_NPC_NUM 3\n\nenum {\n  mNpc_LETTER_RANK_BAD,\n  mNpc_LETTER_RANK_OK,\n\n  mNpc_LETTER_RANK_NUM\n};\n\n/* sizeof(Anmremail_c) == 0x16 */\ntypedef struct animal_remail_s {\n  lbRTC_ymd_c date; /* date sent */\n  u8 name[ANIMAL_NAME_LEN]; /* villager name */\n  u8 land_name[LAND_NAME_SIZE]; /* town name */\n  struct {\n    u8 cond:1; /* was letter good or not */\n    u8 looks:7; /* personality */\n  } flags;\n} Anmremail_c;\n\n/* sizeof(Anmplmail_c) == 0x104 */\ntypedef struct animal_player_maiL_s {\n  /* 0x000 */ u8 font; /* 'font' to use for letter info */\n  /* 0x001 */ u8 paper_type; \n  /* 0x002 */ mActor_name_t present;\n  /* 0x004 */ u8 header_back_start; /* position for name insertion in header */\n  /* 0x005 */ u8 header[MAIL_HEADER_LEN];\n  /* 0x01D */ u8 body[MAIL_BODY_LEN];\n  /* 0x0DD */ u8 footer[MAIL_FOOTER_LEN];\n  /* 0x0FD */ u8 pad0; /* likely pad */\n  /* 0x0FE */ lbRTC_ymd_c date; /* sent date */\n} Anmplmail_c;\n\n/* sizeof(Anmhome_c) == 5 */\ntypedef struct animal_home_s {\n  /* 0x00 */ u8 type_unused; /* Likely the house type, but seems to be unused outside of SChk_Anmhome_c_sub */\n  /* 0x01 */ u8 block_x; /* acre x position */\n  /* 0x02 */ u8 block_z; /* acre y position */\n  /* 0x03 */ u8 ut_x; /* unit x position */\n  /* 0x04 */ u8 ut_z; /* unit z position */\n} Anmhome_c;\n\n/* sizeof(Anmlet_c) == 1 */\ntypedef struct animal_letter_info_s {\n  u8 exists:1;   /* letter received by villager and exists */\n  u8 cond:1;   /* mNpc_LETTER_RANK_* */\n  u8 send_reply:1;   /* set when the villager should reply */\n  u8 has_present_cloth:1;   /* set when the villager's held present shirt is from this letter */\n  u8 wearing_present_cloth:1;   /* set when a villager is wearing the shirt sent with the saved letter */\n  u8 bit5_7:3; /* seemingly unused */\n} Anmlet_c;\n\n/* sizeof(Anmlnd_c) == 0xA */\ntypedef struct animal_land_mem_s {\n  /* 0x00 */ u8 name[LAND_NAME_SIZE];\n  /* 0x08 */ u16 id;\n} Anmlnd_c;\n\ntypedef struct island_animal_best_ftr_s {\n  u32 check;\n  u16 have_bitfield;\n} Anm_bestFtr_c;\n\n/* sizeof(memuni_u) == 0xC */\ntypedef union {\n  Anmlnd_c land; /* size = 0xA */\n  Anm_bestFtr_c island; /* size = 6 */\n} memuni_u;\n\n/* sizeof(Anmmem_c) == 0x138 */\ntypedef struct animal_memory_s {\n  /* 0x000 */ PersonalID_c memory_player_id; /* personal id of the player memory belongs to */\n  /* 0x014 */ lbRTC_time_c last_speak_time; /* time the player last spoke to this villager */\n  /* 0x01C */ memuni_u memuni; /* union between town NPC land memory & islander player action memory */\n  /* 0x028 */ u64 saved_town_tune; /* memory origin town tune */\n  /* 0x030 */ s8 friendship; /* friendship with the player */\n  /* 0x031 */ Anmlet_c letter_info; /* saved letter flags */\n  /* 0x032 */ Anmplmail_c letter; /* saved letter */\n} Anmmem_c;\n\n/* sizeof(anmuni) == 8 */\ntypedef union {\n  u8 previous_land_name[LAND_NAME_SIZE];\n  mActor_name_t island_ftr[mNpc_ISLAND_FTR_SAVE_NUM];\n} anmuni_u;\n\n/* sizeof(AnmHPMail_c) == 0x1C */\ntypedef struct animal_password_mail_s {\n  /* 0x00 */ lbRTC_time_c receive_time;\n  /* 0x08 */ u8 password[20]; /* TODO: this should not be a hardcoded length */\n} AnmHPMail_c;\n\n#define mNW_ORIGINAL_DESIGN_NAME_LEN 16 /* length of design name */\n#define mNW_ORIGINAL_DESIGN_WIDTH 32 /* width */\n#define mNW_ORIGINAL_DESIGN_HEIGHT 32 /* height */\n#define mNW_DEFAULT_ORIGINAL_TEX_NUM 4 /* number of 'default' player textures which are not blank */\n\n#define mNW_CLOTH_DESIGN_NUM 4 /* number of clothing designs in Able Sisters' */\n#define mNW_UMBRELLA_DESIGN_NUM 4 /* number of umbrella designs in Able Sisters' */\n#define mNW_TOTAL_DESIGN_NUM (mNW_CLOTH_DESIGN_NUM + mNW_UMBRELLA_DESIGN_NUM) /* total designs in Able Sisters' */\n\n#define mNW_DESIGN_TEX_SIZE (mNW_ORIGINAL_DESIGN_HEIGHT * (mNW_ORIGINAL_DESIGN_WIDTH / 2)) /* total texture data size */\n#define mNW_PALETTE_COUNT 16 /* number of design palettes */\n\n/* sizeof(mNW_original_design_c) == 0x220 */\ntypedef struct original_data_s {\n  /* 0x000 */ u8 name[mNW_ORIGINAL_DESIGN_NAME_LEN];\n  /* 0x010 */ u8 palette;\n\n  /* 0x020 */ u8 design[mNW_DESIGN_TEX_SIZE] ATTRIBUTE_ALIGN(32); /* this is aligned to 32 bytes for ARAM transfer */\n} mNW_original_design_c;\n\n/* sizeof(mNW_needlework_c) == 0x1100 */\ntypedef struct needlework_s {\n  /* 0x0000 */  mNW_original_design_c original_design[mNW_TOTAL_DESIGN_NUM];\n} mNW_needlework_c;\n\n/* TODO: do these have a better header? */\n#define GAME_YEAR_MIN 2000 /* Minimum year supported by the game */\n#define GAME_YEAR_MAX 2032 /* Maximum year supported by the game */\n\n#define lbRTC_YEAR_MIN 1901\n#define lbRTC_YEAR_MAX 2099\n\nenum MONTHS {\n  lbRTC_MONTHS_BEGIN = 0,\n  lbRTC_JANUARY = 1,\n  lbRTC_FEBRUARY,\n  lbRTC_MARCH,\n  lbRTC_APRIL,\n  lbRTC_MAY,\n  lbRTC_JUNE,\n  lbRTC_JULY,\n  lbRTC_AUGUST,\n  lbRTC_SEPTEMBER,\n  lbRTC_OCTOBER,\n  lbRTC_NOVEMBER,\n  lbRTC_DECEMBER,\n  lbRTC_MONTHS_MAX = lbRTC_DECEMBER\n};\n\n/* sizeof(mCD_player_calendar_c) == 0x68 */\ntypedef struct calendar_player_info_s {\n  /* 0x00 */ u32 played_days[lbRTC_MONTHS_MAX]; /* bitfield of days where 1 bit represents a day played */\n  /* 0x30 */ u32 event_days[lbRTC_MONTHS_MAX]; /* bitfield of events where 1 bit represents an event was on that day */\n  /* 0x60 */ u16 event_flags; /* flags for specific event days the player played on */\n  /* 0x62 */ u8 edit; /* unsure, might have something to do with saving an edit */\n  /* 0x63 */ u8 pad_63; /* only checked in save data validation? */\n  /* 0x64 */ lbRTC_year_t year; /* year calendar was last updated */\n  /* 0x66 */ lbRTC_month_t month; /* month calendar was last updated */\n} mCD_player_calendar_c;\n\n#define mPr_DEPOSIT_MAX 999999999\n\n/* sizeof(Animal_c) == 0x988 */\ntypedef struct animal_s {\n  /* 0x000 */ AnmPersonalID_c id; /* this villager's ID */\n  /* 0x010 */ Anmmem_c memories[ANIMAL_MEMORY_NUM]; /* memories of players who've spoken to this villager */\n  /* 0x898 */ Anmhome_c home_info; /* home position info */\n  /* 0x89D */ u8 catchphrase[ANIMAL_CATCHPHRASE_LEN]; /* may be called 'word_ending' */\n  /* 0x8A8 */ mQst_contest_c contest_quest; /* current contest quest information */\n  /* 0x8D0 */ u8 parent_name[PLAYER_NAME_LEN]; /* name of the player who 'spawned' the villager in, unsure why this is tracked */\n  /* 0x8D8 */ anmuni_u anmuni; /* name of the last town the villager lived in or saved island ftr */\n  /* 0x8E0 */ u16 previous_land_id; /* id of the previous town the villager lived in */\n  /* 0x8E2 */ u8 mood; /* probably called 'feel' based on code */\n  /* 0x8E3 */ u8 mood_time; /* probably called 'feel_tim' based on code */\n  /* 0x8E4 */ mActor_name_t cloth; /* shirt the villager is wearing */\n  /* 0x8E6 */ u16 remove_info; /* info about villager moving between towns? kinda stubbed */\n  /* 0x8E8 */ u8 is_home; /* TRUE when the villager is home, otherwise FALSE */\n  /* 0x8E9 */ u8 moved_in; /* TRUE when the villager moved in after town creation, FALSE if they started out in town */\n  /* 0x8EA */ u8 removing; /* TRUE when the villager is leaving town, FALSE otherwise */\n  /* 0x8EB */ u8 cloth_original_id; /* 0xFF when not wearing an Able Sister's pattern, otherwise 0-3 indicating which pattern */\n  /* 0x8EC */ s8 umbrella_id; /* 0xFF when no umbrella, 0-31 when a standard umbrella, 32-35 when using an Able Sister's pattern\n  /* 0x8ED */ u8 unk_8ED; /* Exists according to mISL_gc_to_agb_animal, but seems unused in practice */\n  /* 0x8EE */ mActor_name_t present_cloth; /* The most recently received shirt from a letter which the villager may change into */\n  /* 0x8F0 */ u8 animal_relations[ANIMAL_NUM_MAX]; /* relationships between all villagers in town, starts at 128 which is neutral */\n  /* 0x900 */ AnmHPMail_c hp_mail[ANIMAL_HP_MAIL_NUM]; /* mail password info storage */\n  /* 0x000 */ u8 unused[24]; /* unknown usage/unused */\n} Animal_c;\n\n#define mPr_RADIOCARD_MAX_DAYS 13\n\n/* sizeof(mMsm_record_c) == 0x4E */\ntypedef struct museum_record_s {\n  u8 contacted:1; /* set to TRUE when the museum has contacted the player */\n  u8 remail_pending:1; /* set to TRUE when the museum has non-fossil letters pending */\n  u8 send_info_mail:1; /* if set to true, museum info mail will be sent */\n  u8 stored_fossil_num:5; /* number of stored fossils */\n\n  mMsm_remail_info_c remail_info; /* remail info */\n} mMsm_record_c;\n\ntypedef struct private_cloth_s {\n  u16 idx;\n  mActor_name_t item;\n} mPr_cloth_c;\n\ntypedef struct private_s {\n  /* 0x0000 */ PersonalID_c player_ID; /* player's id info */\n  /* 0x0014 */ s8 gender; /* gender/sex of player */\n  /* 0x0015 */ s8 face; /* face type of player */\n  /* 0x0016 */ u8 reset_count; /* times player has reset */\n  /* 0x0017 */ mMsm_record_c museum_record; /* museum items & remail info */\n\n  /* must be a struct due to alignment of first member */\n  /* 0x0068 */ struct {\n    /* 0x0068 */ mActor_name_t pockets[mPr_POCKETS_SLOT_COUNT]; /* items in inventory */\n    /* 0x0086 */ u8 lotto_ticket_expiry_month;\n    /* 0x0087 */ u8 lotto_ticket_mail_storage;\n    /* 0x0088 */ u32 item_conditions; /* bitfield (15 values), 2 bits per pocket slot */\n    /* 0x008C */ u32 wallet;\n    /* 0x0090 */ u32 loan;\n  } inventory;\n\n  /* 0x0094 */ mQst_delivery_c deliveries[mPr_DELIVERY_QUEST_NUM]; /* delivery quests */\n  /* 0x02EC */ mQst_errand_c errands[mPr_ERRAND_QUEST_NUM]; /* errand quests */\n\n  /* 0x04A4 */ mActor_name_t equipment; /* equipped item */\n\n  /* 0x04A6 */ Mail_hs_c saved_mail_header; /* saved mail header/footer which is inserted when writing new letters */\n  /* 0x04E0 */ Mail_c mail[mPr_INVENTORY_MAIL_COUNT]; /* letters in inventory */\n  /* 0x1084 */ mActor_name_t backgound_texture; /* inventory background shirt item id */\n  /* 0x1086 */ u8 exists; /* 0/1 if player exists or not */\n  /* 0x1087 */ u8 hint_count; /* total hints heard from villagers (initial dialog) */\n\n  /* 0x1088 */ mPr_cloth_c cloth;\n  /* 0x1088 */ //u16 cloth_idx; /* index value for texture? */\n  /* 0x108A */ //mActor_name_t cloth; /* shirt item */\n\n  /* 0x108C */ AnmPersonalID_c stored_anm_id; /* foriegn animal personal ID leftover from N64? */\n\n  /* 0x109A */ mPr_destiny_c destiny; /* player fortune, seemingly called destiny */\n  /* 0x10A4 */ mPr_birthday_c birthday; /* player birthday */\n  /* 0x10A8 */ mPr_catalog_order_c catalog_orders[mPr_CATALOG_ORDER_NUM]; /* items ordered from catalog to be mailed */\n  /* 0x10BC */ u8 unk_10A8[24]; /* seemingly unused? */\n  /* 0x10D4 */ u32 aircheck_collect_bitfield[2]; /* TODO: this should be a define like #define mPr_AIRCHECK_BITFIELD_NUM ((MD_COUNT / 32) + 1) */\n  /* 0x10DC */ Anmremail_c remail; /* scheduled mail received from a foreign villager? */\n  /* 0x10F4 */ u32 reset_code; /* 0 when not reset, random value after reset */\n  /* 0x10F8 */ mPr_animal_memory_c animal_memory; /* id and town of last animal to move to another town */\n  /* 0x1102 */ u8 complete_fish_insect_flags; /* bit0 = completed fish, bit1 = villager acknowledged completed fish, bit2 = completed insect, bit3 = villager acknowledged complete insect */\n  /* 0x1104 */ lbRTC_year_t celebrated_birthday_year; /* last year a birthday was celebrated by card or visitor */\n\n                /* catalog */\n  /* 0x1108 */ u32 furniture_collected_bitfield[43];\n  /* 0x11B4 */ u32 wall_collected_bitfield[3];\n  /* 0x11C0 */ u32 carpet_collected_bitfield[3];\n  /* 0x11CC */ u32 paper_collected_bitfield[2];\n  /* 0x11D4 */ u32 music_collected_bitfield[2];\n\n  /* 0x11DC */ mPr_map_info_c maps[mPr_FOREIGN_MAP_COUNT]; /* maps 'collected' for foreign towns */\n\n  /* 0x122C */ u32 bank_account; /* probably 'deposit' interally */\n  /* 0x1240 */ mNW_original_design_c my_org[mPr_ORIGINAL_DESIGN_COUNT]; /* Able Sisters' designs */\n  /* 0x2340 */ u8 my_org_no_table[mPr_ORIGINAL_DESIGN_COUNT]; /* order of designs */\n  /* 0x2348 */ u32 state_flags; /* TODO: this might be a bitfield/struct, also document bits */\n  /* 0x234C */ mCD_player_calendar_c calendar; /* player calendar data */\n  /* 0x23B4 */ u32 soncho_trophy_field0; /* first 28 tortimer event flags */\n  /* 0x23B8 */ mPr_day_day_c nw_visitor; /* info for how many unique days the player has talked to Sable */\n  /* 0x23BE */ mPr_day_day_c radiocard; /* radio stamp days */\n  /* 0x23C4 */ mPr_sunburn_c sunburn; /* sunburn state */\n  /* 0x23CA */ u8 unused_23CA[14]; /* seemingly unused data */\n  /* 0x23D8 */ mActor_name_t birthday_present_npc; /* npc id of the 'best friend' villger who will gift the player a present on their birthday (at the door) */\n  /* 0x23DA */ u8 golden_items_collected; /* bitfield tracking which golden items the player has received */\n  /* 0x23DC */ u32 soncho_trophy_field1; /* remaining tortimer event flags */\n  /* 0x23E0 */ mPr_carde_data_c ecard_letter_data; /* info relating to scanned e-Card letters */\n  /* 0x2412 */ u8 unused_2412[46];\n} Private_c;\n\n\n#define mFR_RECORD_NUM 5\n\ntypedef struct fishrecord_s {\n  PersonalID_c pid;\n  lbRTC_time_c time;\n  int size;\n} mFR_record_c;\n\ntypedef struct mFRm_chk_s{\n   /*0x00*/ s32 version;\n   /*0x04*/ u32 code;\n   /*0x08*/ u16 land_id;\n   /*0x0A*/ lbRTC_time_c time;\n   /*0x12*/ u16 csum;\n}mFRm_chk_t;\n\ntypedef struct mLd_lnd_s{\n    u8 name[8];\n    s8 player_exist;\n    u8 unk9;\n    u16 id;\n}mLd_lnd_t;\n\ntypedef u64 OSTime;\n\ntypedef struct time_s {\n  u32 season;\n  u32 term_idx;\n  s16 bgitem_profile;\n  s16 bgitem_bank;\n  int now_sec;\n  lbRTC_time_c rtc_time;\n  s16 rad_min; /* clock hand radial position for mins */\n  s16 rad_hour; /* clock hand radial position for hours */\n  u8 time_signal;\n  u8 under_sec;\n  u8 disp;\n  u8 rtc_crashed;\n  int rtc_enabled;\n  int add_sec;\n  int add_idx;\n} Time_c;\n\ntypedef struct {\n    s16 x,y,z;\n}Vec3s;\n\ntypedef s32 OSPri;\ntypedef s32 OSId;\ntypedef u64 OSTime;\ntypedef void* OSMesg;\n\n#define ALIGN16(val) (((val) + 0xF) & ~0xF)\n#define ALIGN32(val) (((val) + 31) & ~31)\ns32 __osMalloc_FreeBlockTest_Enable;\n\nvoid OSReport(const char*, ...);\nvoid OSPanic(const char* file, int line, const char* msg, ...);\n\nOSTime osGetTime(void);\n\ntypedef struct OSContext {\n    u32 gprs[32]; // at 0x0\n    u32 cr;       // at 0x80\n    u32 lr;       // at 0x84\n    u32 ctr;      // at 0x88\n    u32 xer;      // at 0x8C\n    f64 fprs[32]; // at 0x90\n    // Bits 0-31 are undefined\n    u32 fpscr_tmp; // at 0x190\n    u32 fpscr;     // at 0x194\n    u32 srr0;      // at 0x198\n    u32 srr1;      // at 0x19C\n    u16 SHORT_0x1A0;\n    u16 SHORT_0x1A2;\n    u32 gqrs[8]; // at 0x1A4\n    char UNK_0x1C4[0x4];\n    f64 psfs[32]; // at 0x1C8\n} OSContext;\n\ntypedef struct OSThreadQueue {\n    struct OSThread* head; // at 0x0\n    struct OSThread* tail; // at 0x4\n} OSThreadQueue;\n\ntypedef struct OSMutexQueue {\n    struct OSMutex* head; // at 0x0\n    struct OSMutex* tail; // at 0x4\n} OSMutexQueue;\n\ntypedef struct OSThread {\n    OSContext context;\n    u16 state;    // at 0x2C8\n    u16 flags;    // at 0x2CA\n    s32 suspend;  // at 0x2CC\n    s32 priority; // at 0x2D0\n    s32 WORD_0x2D4;\n    u32 WORD_0x2D8;\n    OSThreadQueue* queue;      // at 0x2DC\n    struct OSThread* next;     // at 0x2E0\n    struct OSThread* prev;     // at 0x2E4\n    OSThreadQueue threadQueue; // at 0x2E8\n    struct OSMutex* mutex;     // at 0x2F0\n    OSMutexQueue mutexQueue;   // at 0x2F4\n    struct OSThread* next2;    // at 0x2FC\n    struct OSThread* prev2;    // at 0x300\n    u32* stackBegin;           // at 0x304\n    u32* stackEnd;             // at 0x308\n    u32 WORD_0x30C;\n    u32 ARR_0x310[2];\n} OSThread;\n    \ntypedef struct OSMesgQueue {\n    /* 0x00 */ OSThread* mtqueue;\n    /* 0x04 */ OSThread* fullqueue;\n    /* 0x08 */ s32 validCount;\n    /* 0x0C */ s32 first;\n    /* 0x10 */ s32 msgCount;\n    /* 0x14 */ OSMesg* msg;\n} OSMesgQueue; // size = 0x18\n\ntypedef struct OSMessageQueue OSMessageQueue;\n\n// Useful typedef for messages.\ntypedef void* OSMessage;\n\n// Struct for managing the message queue.\nstruct OSMessageQueue {\n\tOSThreadQueue queueSend;    // _00\n\tOSThreadQueue queueReceive; // _08\n\tOSMessage* msgArray;        // _10, array of messages.\n\tint msgCount;               // _14, array limit size.\n\tint firstIndex;             // _18, first message index in array.\n\tint usedCount;              // _1C, actual number of used messages.\n};\n\nstruct ArenaNode;\n\ntypedef struct Arena {\n    /* 0x00 */ struct ArenaNode* head;\n    /* 0x04 */ void* start;\n    /* 0x08 */ OSMessageQueue lockQueue;\n    /* 0x20 */ u8 unk_20;\n    /* 0x21 */ u8 isInit;\n    /* 0x22 */ u8 flag;\n    /* 0x24 */ u8 pad[0x2c-0x24];\n} Arena; // size = 0x24\n\ntypedef struct ArenaNode {\n    /* 0x00 */ s16 magic;\n    /* 0x02 */ s16 isFree;\n    /* 0x04 */ u32 size;\n    /* 0x08 */ struct ArenaNode* next;\n    /* 0x0C */ struct ArenaNode* prev;\n    /* 0x10 */ const char* filename;\n    /* 0x14 */ s32 line;\n    /* 0x18 */ OSId threadId;\n    /* 0x1C */ Arena* arena;\n    /* 0x20 */ OSTime time;\n    /* 0x28 */ u8 unk_28[0x30-0x28]; // probably padding\n} ArenaNode; // size = 0x30\n\n#define OS_MESSAGE_NOBLOCK 0\n\ntypedef struct actor_data_s {\n  s16 profile;\n  s_xyz position;\n  s_xyz rotation;\n  s16 arg;\n} Actor_data;\n\n#define mSc_ARENA_SIZE 0xA000\n\ntypedef struct door_data_s {\n  int next_scene_id;\n  u8 exit_orientation;\n  u8 exit_type; // 0 = normal, 1 = restart game?\n  u16 extra_data;\n  s_xyz exit_position;\n  mActor_name_t door_actor_name;\n  u8 wipe_type;\n  u8 pad[3]; // possibly necessary due to struct copy\n} Door_data_c;\n\n#define mSc_OBJECT_BANK_NUM 70\n\ntypedef struct object_bank_s {\n  s16 bank_id;\n  char* ram_start;\n  char* dma_start;\n  u32 rom_addr;\n  size_t size;\n  u32 _14;\n  int _18;\n  int _1C;\n  int _20;\n  int _24;\n  int _28;\n  OSMessageQueue* msg_queue_p;\n  OSMessage _30_msg;\n  OSMessageQueue dma_controller_msg_queue;\n  OSMessage dma_controller_msg;\n  s16 num_exist;\n  u8 part_id;\n  u8 state;\n} Object_Bank_c;\n\ntypedef struct object_exchange_s {\n  Object_Bank_c banks[mSc_OBJECT_BANK_NUM];\n  int bank_idx;\n  int keep_id;\n  int exchange_id;\n  char* next_bank_ram_address;\n  char* max_ram_address;\n  char* start_address_save[2];\n  char* end_address_save[2];\n  char* _194C;\n  int selected_partition;\n  int _1954;\n} Object_Exchange_c;\n\nenum {\n  mSc_SCENE_DATA_TYPE_PLAYER_PTR,\n  mSc_SCENE_DATA_TYPE_CTRL_ACTOR_PTR,\n  mSc_SCENE_DATA_TYPE_ACTOR_PTR,\n  mSc_SCENE_DATA_TYPE_OBJECT_EXCHANGE_BANK_PTR,\n  mSc_SCENE_DATA_TYPE_DOOR_DATA_PTR,\n  mSc_SCENE_DATA_TYPE_FIELD_CT,\n  mSc_SCENE_DATA_TYPE_MY_ROOM_CT,\n  mSc_SCENE_DATA_TYPE_ARRANGE_ROOM_CT,\n  mSc_SCENE_DATA_TYPE_ARRANGE_FURNITURE_CT,\n  mSc_SCENE_DATA_TYPE_SOUND,\n  mSc_SCENE_DATA_TYPE_END,\n\n  mSc_SCENE_DATA_TYPE_NUM\n};\n\ntypedef struct {\n  u8 type;\n  u8 num_actors;\n  Actor_data* data_p;\n} Scene_Word_Data_Actor_c;\n\ntypedef struct {\n  u8 type;\n  u8 num_ctrl_actors;\n  s16* ctrl_actor_profile_p;\n} Scene_Word_Data_Ctrl_Actor_c;\n\ntypedef struct {\n  u8 type;\n  u8 num_banks;\n  s16* banks_p;\n} Scene_Word_Data_Object_Bank_c;\n\ntypedef struct {\n  u8 type;\n  u8 num_doors;\n  Door_data_c* door_data_p;\n} Scene_Word_Data_Door_Data_c;\n\ntypedef struct {\n  u8 type;\n  u8 item_type;\n  u8 bg_num;\n  u16 bg_disp_size;\n  u8 room_type;\n  u8 draw_type;\n} Scene_Word_Data_FieldCt_c;\n\ntypedef struct {\n  u8 type;\n  u8 arrange_ftr_num;\n} Scene_Word_Data_ArrangeFurniture_ct_c;\n\ntypedef struct {\n  u8 type;\n} Scene_Word_Data_Misc_c;\n\ntypedef union scene_word_u {\n  Scene_Word_Data_Misc_c misc; /* MY_ROOM_CT, ARRANGE_ROOM_CT, ARRANGE_FURNITURE_CT, SOUND */\n  Scene_Word_Data_Actor_c actor; /* PLAYER_PTR, ACTOR_PTR */\n  Scene_Word_Data_Ctrl_Actor_c control_actor;\n  Scene_Word_Data_Object_Bank_c object_bank;\n  Scene_Word_Data_Door_Data_c door_data;\n  Scene_Word_Data_FieldCt_c field_ct;\n  Scene_Word_Data_ArrangeFurniture_ct_c arrange_ftr_ct;\n} Scene_Word_u;\n\ntypedef struct door_info_s {\n  u8 num_doors;\n  Door_data_c* door_data_p;\n} Door_info_c;\n\nextern Scene_Word_u test01_info[];\nextern Scene_Word_u test02_info[];\nextern Scene_Word_u test03_info[];\nextern Scene_Word_u water_test_info[];\nextern Scene_Word_u test_step01_info[];\nextern Scene_Word_u test04_info[];\nextern Scene_Word_u npc_room01_info[];\nextern Scene_Word_u test_fd_npc_land_info[];\nextern Scene_Word_u field_tool_field_info[];\nextern Scene_Word_u shop01_info[];\nextern Scene_Word_u BG_TEST01_info[];\nextern Scene_Word_u BG_TEST01_XLU_info[];\nextern Scene_Word_u broker_shop_info[];\nextern Scene_Word_u fg_tool_in_info[];\nextern Scene_Word_u post_office_info[];\nextern Scene_Word_u start_demo1_info[];\nextern Scene_Word_u start_demo2_info[];\nextern Scene_Word_u police_box_info[];\nextern Scene_Word_u buggy_info[];\nextern Scene_Word_u player_select_info[];\nextern Scene_Word_u player_room_s_info[];\nextern Scene_Word_u player_room_m_info[];\nextern Scene_Word_u player_room_l_info[];\nextern Scene_Word_u shop02_info[];\nextern Scene_Word_u shop03_info[];\nextern Scene_Word_u shop04_1f_info[];\nextern Scene_Word_u test05_info[];\nextern Scene_Word_u PLAYER_SELECT2_info[];\nextern Scene_Word_u PLAYER_SELECT3_info[];\nextern Scene_Word_u shop04_2f_info[];\nextern Scene_Word_u event_notification_info[];\nextern Scene_Word_u kamakura_info[];\nextern Scene_Word_u field_tool_field_info[];\nextern Scene_Word_u title_demo_info[];\nextern Scene_Word_u PLAYER_SELECT4_info[];\nextern Scene_Word_u museum_entrance_info[];\nextern Scene_Word_u museum_picture_info[];\nextern Scene_Word_u museum_fossil_info[];\nextern Scene_Word_u museum_insect_info[];\nextern Scene_Word_u museum_fish_info[];\nextern Scene_Word_u player_room_ll1_info[];\nextern Scene_Word_u player_room_ll2_info[];\nextern Scene_Word_u p_room_bm_s_info[];\nextern Scene_Word_u p_room_bm_m_info[];\nextern Scene_Word_u p_room_bm_l_info[];\nextern Scene_Word_u p_room_bm_ll1_info[];\nextern Scene_Word_u NEEDLEWORK_info[];\nextern Scene_Word_u player_room_island_info[];\nextern Scene_Word_u npc_room_island_info[];\nextern Scene_Word_u start_demo3_info[];\nextern Scene_Word_u lighthouse_info[];\nextern Scene_Word_u tent_info[];\n\n#define mNtc_BOARD_POST_COUNT 15\n\n/* sizeof(mNtc_board_post) == 0xC8 */\ntypedef struct notice_board_post_s {\n  /* 0x00 */ u8 message[MAIL_BODY_LEN]; /* post contents */\n  /* 0xC0 */ lbRTC_time_c post_time; /* date-time of post */\n} mNtc_board_post_c;\n\n\n/* sizeof(mHm_rmsz_c) == 6 */\ntypedef struct home_size_info_s {\n  /* 0x00 */ struct {\n    /* 0x00 */ u8 day;\n    /* 0x01 */ u8 month;\n    /* 0x02 */ u16 year;\n  } upgrade_order_date; /* date you ordered an upgrade, seems to be a struct */\n\n  /* 0x04 */ u8 size:3; /* current house size */\n  /* 0x04 */ u8 next_size:3; /* next house size when upgrade is ordered */\n  /* 0x04 */ u8 statue_rank:2; /* statue ranking, 0 = gold, 1 = silver, 2 = bronze, 3 = jade */\n  /* 0x05 */ u8 renew:1; /* refresh house size & 'outlook' palette */\n  /* 0x05 */ u8 statue_ordered:1; /* set when statue is ordered from Nook */\n  /* 0x05 */ u8 basement_ordered:1; /* set when basement has been ordered */\n  /* 0x05 */ u8 pad:5; /* unused? */\n} mHm_rmsz_c;\n\n/* sizeof(Haniwa_Item_c) == 8 */\ntypedef struct home_haniwa_item_s {\n  /* 0x00 */ mActor_name_t item; /* held item */\n  /* 0x02 */ s16 exchange_type; /* type of exchange (sale, free, trade) */\n  /* 0x04 */ u32 extra_data; /* trade related data */\n} Haniwa_Item_c;\n\n/* sizeof(Haniwa_c) == 0xA4 */\ntypedef struct home_haniwa_s {\n  /* 0x00 */ Haniwa_Item_c items[HANIWA_ITEM_HOLD_NUM]; /* held items */\n  /* 0x20 */ u8 message[HANIWA_MESSAGE_LEN]; /* message for visitors */\n  /* 0xA0 */ u32 bells; /* held bells from selling items */\n} Haniwa_c;\n\n\n#define BLOCK_X_NUM 7\n#define BLOCK_Z_NUM 10\n#define BLOCK_TOTAL_NUM (BLOCK_X_NUM * BLOCK_Z_NUM)\n\n#define FG_BLOCK_X_NUM (BLOCK_X_NUM - 2) /* 5 */\n#define FG_BLOCK_Z_NUM (BLOCK_Z_NUM - 4) /* 6 */\n#define FG_BLOCK_TOTAL_NUM (FG_BLOCK_X_NUM * FG_BLOCK_Z_NUM)\n\n#define UT_X_NUM 16 /* Spaces per block (acre) in x direction */\n#define UT_Z_NUM 16 /* Spaces per block (acre) in z direction */\n#define UT_TOTAL_NUM (UT_X_NUM * UT_Z_NUM)\n\n#define IDX_2_UT_X(idx) ((idx) & (UT_X_NUM - 1))\n#define IDX_2_UT_Z(idx) (((idx) / UT_X_NUM) & (UT_Z_NUM - 1))\n\n#define FGIDX_2_BLOCK_X(idx) ((idx) % FG_BLOCK_X_NUM + 1)\n#define FGIDX_2_BLOCK_Z(idx) ((idx) / FG_BLOCK_X_NUM + 1)\n#define FGBLOCKXZ_2_FGIDX(x, z) ((z) * FG_BLOCK_X_NUM + (x))\n\n#define BLOCKXZ_2_BLOCKIDX(x, z) ((z) * BLOCK_X_NUM + (x))\n\n#define mSP_PERSONAL_ID_COUNT 10\n#define mSP_GOODS_COUNT 39\n#define mSP_LOTTERY_ITEM_COUNT 3\n\nenum {\n  mSP_LIST_FURNITURE,\n  mSP_LIST_PAPER,\n  mSP_LIST_CLOTH,\n  mSP_LIST_CARPET,\n  mSP_LIST_WALLPAPER,\n\n  mSP_LIST_MAX\n};\n\n/* sizeof(mSP_goods_priority_list_c) == 1 */\ntypedef struct shop_goods_priority_list_s {\n  u8 a:2; /* list A rarity */\n  u8 b:2; /* list B rarity */\n  u8 c:2; /* list C rarity */\n  u8 pad:2;\n} mSP_goods_priority_list_c;\n\nenum {\n  mNPS_SCHED_FIELD, /* in same acre as their home */\n  mNPS_SCHED_IN_HOUSE, /* inside their house */\n  mNPS_SCHED_SLEEP, /* asleep in their house */\n  mNPS_SCHED_STAND, /* standing around town?? */\n  mNPS_SCHED_WANDER, /* wander around town */\n  mNPS_SCHED_SPECIAL, /* unique schedule method for each NPC actor type */\n\n  mNPS_SCHED_TYPE_NUM\n};\n\ntypedef struct schedule_data_s {\n  u32 type;\n  int end_time;\n} mNPS_schedule_data_c;\n\ntypedef struct schedule_data_table_s {\n  int count;\n  mNPS_schedule_data_c* sched_data;\n} mNPS_schedule_data_table_c;\n\ntypedef struct schedule_s {\n  AnmPersonalID_c* id;\n  mNPS_schedule_data_table_c* data_table;\n  u8 current_type;\n  u8 forced_type;\n  u8 saved_type;\n  int forced_timer;\n} mNPS_schedule_c;\n\nenum {\n  Kabu_TRADE_MARKET_TYPE_START,\n\n  Kabu_TRADE_MARKET_TYPE_A = Kabu_TRADE_MARKET_TYPE_START, /* spike trend */\n  Kabu_TRADE_MARKET_TYPE_B, /* random trend */\n  Kabu_TRADE_MARKET_TYPE_C, /* falling trend */\n\n  Kabu_TRADE_MARKET_TYPE_NUM\n};\n\nenum WEEKDAYS {\n  lbRTC_WEEKDAYS_BEGIN = 0,\n  lbRTC_SUNDAY = lbRTC_WEEKDAYS_BEGIN,\n  lbRTC_MONDAY,\n  lbRTC_TUESDAY,\n  lbRTC_WEDNESDAY,\n  lbRTC_THURSDAY,\n  lbRTC_FRIDAY,\n  lbRTC_SATURDAY,\n  lbRTC_WEEK,\n  lbRTC_WEEKDAYS_MAX = lbRTC_WEEK\n};\n\n/* sizeof(Kabu_price_c) == 0x18 */\ntypedef struct kabu_price_s {\n  /* 0x00 */ u16 daily_price[lbRTC_WEEKDAYS_MAX];\n  /* 0x0E */ u16 trade_market;\n  /* 0x10 */ lbRTC_time_c update_time;\n} Kabu_price_c;\n\n#define mPO_MAIL_STORAGE_SIZE 5\n\n/* sizeof(PostOffice_c) == 0x83C */\ntypedef struct post_office_s {\n  /* 0x000 */ s16 keep_mail_sum_players; /* sum of stored mail from players, see mPO_get_keep_mail_sum */\n  /* 0x002 */ s16 keep_mail_sum_npcs; /* sum of stored mail from NPCs, see mPO_get_keep_mail_sum */\n  /* 0x004 */ s16 mail_recipient_flags; /* flags to keep track of which players will receive mail */\n  /* 0x006 */ u16 unused_6; /* definitely here, as Mail_c has 2 byte alignment */\n  /* 0x008 */ Mail_c mail[mPO_MAIL_STORAGE_SIZE];\n  /* 0x5DA */ Mail_c leaflet;\n  /* 0x704 */ Mail_c event_leaflet;\n\n  /* certainly a union based on code usage */\n  /* 0x830 */ union {\n    /* 0x830 */ int raw; /* used in mPO_post_office_init */\n    struct {\n      /* 0x830 */ s16 leaflet_flags; /* bitfield of players who will receive the current 'leaflet' */\n      /* 0x832 */ s16 event_flags; /* bitfield of players who will receive the current 'event leaflet' */\n    };\n  } leaflet_recipient_flags; /* similar to mail_recipient_flags, just for 'leaflets' */\n\n  /* 0x834 */ lbRTC_time_c delivery_time; /* time when Pete should 'deliver' the mail */\n} PostOffice_c;\n\n#define mSN_SAVE_COUNT 3\n\n/* sizeof(mSN_snowman_data_c) == 4 */\ntypedef struct snowman_data_s {\n  /* 0x00 */ u8 exists; /* when non-zero, snowman 'exists' */\n  /* 0x01 */ u8 head_size; /* size of the snowman's head */\n  /* 0x02 */ u8 body_size; /* size of the snowman's body */\n  /* 0x03 */ u8 score; /* score based on snowman proportions */\n} mSN_snowman_data_c;\n\n/* sizeof(Config_c) == 4 */\ntypedef struct config_s {\n  /* 0x00 */ u8 sound_mode; /* mono, stereo, ... */\n  /* 0x01 */ u8 voice_mode; /* silent, babblese, animalese */\n  /* 0x02 */ u8 vibration_enabled; /* true/false */\n  /* 0x03 */ u8 unused; /* might not exist */\n} Config_c;\n\n/* sizeof(mSN_snowman_save_c) == 0xC */\ntypedef struct snowman_save_data_s {\n  /* 0x00 */ mSN_snowman_data_c snowmen_data[mSN_SAVE_COUNT];\n} mSN_snowman_save_c;\n\n#define mPB_POLICE_BOX_ITEM_STORAGE_COUNT 20\n\n/* sizeof(PoliceBox_c) == 0x28 */\ntypedef struct police_box_s {\n  /* 0x00 */ mActor_name_t keep_items[mPB_POLICE_BOX_ITEM_STORAGE_COUNT];\n} PoliceBox_c;\n\n/* sizeof(Shop_c) == 0x140 */\ntypedef struct shop_s {\n  /* 0x000 */ mSP_goods_priority_list_c priority_lists[mSP_LIST_MAX]; /* ABC list rarity (known internally as priority) */\n  /* 0x006 */ PersonalID_c unused_ids[mSP_PERSONAL_ID_COUNT]; /* unused personal ids */\n  /* 0x0CE */ mActor_name_t items[mSP_GOODS_COUNT]; /* standard shop items */\n  /* 0x11C */ mActor_name_t rare_item; /* spotlight rare item taken from rare furniture ABC list */\n  /* 0x11E */ mActor_name_t lottery_items[mSP_LOTTERY_ITEM_COUNT]; /* lottery items */\n  /* 0x124 */ s8 flowers_candy_grab_bag_count; /* count of items that are flowers, candy, or grab bags */\n  /* 0x126 */ struct {\n    /* 0x126 */ u16 shop_level:2; /* shop type, 0 = Cranny, 1 = Nook 'n Go, 2 = Nookway, 3 = Nookington's */\n    /* 0x126 */ u16 upgrading_today:1; /* enabled when the shop is 'undergoing renovations' */\n    /* 0x126 */ u16 send_upgrade_notice:1; /* triggers the upgrade letter to be sent out */\n    /* 0x126 */ u16 not_loaded_before:1; /* cleared when the shop actor has loaded for the first time in a play session */\n    /* 0x126/0x127 */ u16 paint_color:4; /* paint bucket color being sold */\n    /* 0x127 */ u16 unused:7; /* seems to be unused */\n  } shop_info;\n  /* 0x128 */ u32 sales_sum; /* current money towards upgrading shop */\n  /* 0x12C */ lbRTC_time_c exchange_time; /* last time the shop's items were updated */\n  /* 0x134 */ lbRTC_time_c renewal_time; /* last time the shop was 'renewed' which includes upgrading its 'level' */\n  /* 0x13C */ int visitor_flag; /* set when a foreign player enters Nook's shop, required for Nookington's */\n} Shop_c;\n\n/* sizeof(mFM_combination_c) == 2 */\ntypedef struct block_combination_s {\n  /* 0x00 */ u16 combination_type:14; /* acre type index */\n  /* 0x00 */ u16 height:2; /* 0, 1, 2, or 3 (unused) */\n} mFM_combination_c;\n\n/* sizeof(mFM_fg_c) == 0x200 */\ntypedef struct fg_items_s {\n  /* 0x000 */ mActor_name_t items[UT_Z_NUM][UT_X_NUM];\n} mFM_fg_c;\n\n/* sizeof (mFM_combo_info_c) == 6 */\ntypedef struct block_combo_s {\n  /* 0x00 */ mActor_name_t bg_id;\n  /* 0x02 */ mActor_name_t fg_id;\n  /* 0x05 */ u8 type;\n} mFM_combo_info_c;\n\nextern u8* g_block_type_p;\nextern int* g_block_kind_p;\n\n/* sizeof(mHm_wf_c) == 2 */\ntypedef struct home_wall_floor_s {\n  /* 0x00 */ u8 flooring_idx;\n  /* 0x01 */ u8 wallpaper_idx;\n} mHm_wf_c;\n\n/* sizeof(mHm_goki_c) == 0xA */\ntypedef struct home_goki_s {\n  /* 0x00 */ lbRTC_time_c time; /* last time updated */\n  /* 0x08 */ u8 num; /* number of cockroaches in the house */\n  /* 0x09 */ u8 pad;\n} mHm_goki_c;\n\n/* sizeof(mHm_lyr_c) == 0x228 */\ntypedef struct home_layer_s {\n  /* 0x000 */ mActor_name_t items[UT_Z_NUM][UT_X_NUM]; /* Furniture item actors */\n  /* 0x200 */ u64 ftr_switch; /* Bitfield for controlling which furniture items are active, max of 64 */\n  /* 0x208 */ u32 unk_208[8]; /* Only referenced in mISL_gc_to_agb_layer */\n} mHm_lyr_c;\n\ntypedef struct floor_bit_info_s {\n  u8 wall_original:1; /* is wallpaper a pattern (original)? */\n  u8 floor_original:1; /* is flooring a pattern (original)? */\n  u8 bit_2_7:6; /* unused? */\n} mHm_fllot_bit_c;\n\n/* sizeof(mHm_flr_c) == 0x8A8 */\ntypedef struct home_floor_s {\n  /* 0x000 */ mHm_lyr_c layer_main;\n  /* 0x228 */ mHm_lyr_c layer_secondary; /* Also storage layer 0 */\n  /* 0x450 */ mHm_lyr_c layer_storage1;\n  /* 0x678 */ mHm_lyr_c layer_storage2;\n  /* 0x8A0 */ mHm_wf_c wall_floor;\n  /* 0x8A2 */ TempoBeat_c tempo_beat;\n  /* 0x8A4 */ mHm_fllot_bit_c floor_bit_info;\n} mHm_flr_c;\n\n/* sizeof(mHm_cottage_c) == 0x8C8 */\ntypedef struct home_cottage_s {\n  /* 0x000 */ mHm_wf_c unused_wall_floor; /* Has wallpaper & flooring bounds checks in sChk_CheckSaveData_Cattage */\n  /* 0x002 */ u8 unk_2[2]; /* struct/array that is two bytes long, maybe another wall floor? */\n  /* 0x004 */ u8 unk_4; /* direct copy in agb_to_gc_cottage, GBA only? */\n  /* 0x005 */ u8 unk_5; /* direct copy in agb_to_gc_cottage, GBA only? */\n  /* 0x008 */ mHm_flr_c room; /* Cottage room */\n  /* 0x8B0 */ mHm_goki_c goki; /* Cottage cockroaches */\n  /* 0x8BC */ u32 music_box[2]; /* Cottage music storage... separate from main home? */\n} mHm_cottage_c;\n\n#define mISL_ISLAND_NAME_LEN 8\n\n#define mISL_FG_BLOCK_X_NUM 2\n#define mISL_FG_BLOCK_Z_NUM 1\n\n#define mISL_BLOCK_X0 4\n#define mISL_BLOCK_X1 5\n#define mISL_BLOCK_Z 8\n\nenum {\n  mISL_ISLAND_BLOCK_LEFT,\n  mISL_ISLAND_BLOCK_RIGHT,\n\n  mISL_ISLAND_BLOCK_NUM\n};\n\n/* sizeof(Island_c) == 0x1900 */\ntypedef struct island_s {\n  /* 0x0000 */ u8 name[mISL_ISLAND_NAME_LEN]; /* island name */\n  /* 0x0008 */ mLd_land_info_c landinfo; /* land info for town */\n  /* 0x0014 */ mFM_fg_c fgblock[mISL_FG_BLOCK_Z_NUM][mISL_FG_BLOCK_X_NUM]; /* island item actor data */\n  /* 0x0418 */ mHm_cottage_c cottage; /* player shared cottage data */\n  /* 0x0CE0 */ mNW_original_design_c flag_design; /* island flag design */\n  /* 0x0F00 */ Animal_c animal; /* islander info */\n  /* 0x1888 */ u16 deposit[mISL_FG_BLOCK_X_NUM * mISL_FG_BLOCK_Z_NUM][UT_Z_NUM]; /* buried item bitfield */\n  /* 0x18C8 */ u8 bg_data[mISL_ISLAND_BLOCK_NUM]; /* island acre ids */\n  /* 0x18CA */ lbRTC_time_c renew_time; /* last time island was visited? */\n  /* 0x18D2 */ u8 unused_18D2[14]; /* unused */\n  /* 0x18E0 */ u8 grass_tex_type; /* grass type */\n  /* 0x18E1 */ u8 last_song_male; /* last song kapp'n sang for a male character */\n  /* 0x18E2 */ u8 last_song_female; /* last song kapp'n sang for a female character */\n  /* 0x18E3 */ u8 unused_18E3[29]; /* unused */\n} Island_c;\n\n/* sizeof(mHm_flg_c) == 1 */\ntypedef struct home_flags_s {\n  u8 house_updated:1; /* signals HRA to re-score house */\n  u8 has_saved:1; /* whether or not the player has saved at this house before */\n  u8 hra_member:1; /* whether or not the house has been setup for HRA membership */\n  u8 has_basement:1; /* set when the basement is built */\n  u8 hra_reward0:1; /* earned 70k HRA points reward */\n  u8 hra_reward1:1; /* earned 100k HRA points reward */\n  u8 bit_6:1; /* unused */\n  u8 bit_7:1; /* unused */\n} mHm_flg_c;\n\n/* sizeof(mHm_hs_c) == 0x26B0 */\ntypedef struct home_s {\n  /* 0x0000 */ PersonalID_c ownerID; /* owner player's ID */\n  /* 0x0014 */ u8 unk_14[6];\n  /* 0x001A */ TempoBeat_c haniwa_tempo; /* unsure about this */\n  /* 0x001C */ lbRTC_ymd_c hra_mark_time; /* last HRA judge date */\n  /* 0x0020 */ u32 hra_mark_info; /* bitfield of HRA info pulled when HRA mails letter */\n  /* 0x0024 */ mHm_flg_c flags;\n  /* 0x0026 */ mHm_rmsz_c size_info; /* home size info */\n  /* 0x002C */ u8 outlook_pal; /* current house palette */\n  /* 0x002D */ u8 ordered_outlook_pal; /* house palette ordered at Nook's via upgrade */\n  /* 0x002E */ u8 next_outlook_pal; /* next house palette set via all other means (villager, Wisp, paint @ Nook's, ...) */\n  /* 0x002F */ u8 door_original; /* player design shown on door, apparently called 'original', maybe 'original design'? */\n  /* 0x0030 */ u8 unk_30[8]; /* unused? */\n  /* 0x0038 */ mHm_flr_c floors[mHm_ROOM_NUM]; /* house floors, might be a union idk */\n  /* 0x1A30 */ Mail_c mailbox[HOME_MAILBOX_SIZE]; /* mailbox */\n  /* 0x25D4 */ Haniwa_c haniwa; /* gyroid info */\n  /* 0x2678 */ mHm_goki_c goki; /* cockroach info */\n  /* 0x2684 */ u32 music_box[2]; /* bitfield of inserted music */\n  /* 0x268C */ u8 unk_286C[36]; /* unused? */\n} mHm_hs_c;\n\n/* sizeof(Anmret_c) == 0xC */\ntypedef struct animal_return_s {\n  /* 0x00 */ mActor_name_t npc_id; /* id of the villager who left */\n  /* 0x02 */ u8 talk_bit; /* which players have already interacted with this villager */\n  /* 0x03 */ u8 exist; /* if the villager exists */\n  /* 0x04 */ lbRTC_time_c renew_time; /* time that this struct was updated */\n} Anmret_c;\n\n#define mMmd_FOSSIL_BIT_NUM 13\n#define mMmd_ART_BIT_NUM 8\n#define mMmd_FISH_BIT_NUM 21\n#define mMmd_INSECT_BIT_NUM 21\n\n#define mMmd_FOSSIL_NUM 25\n#define mMmd_ART_NUM 15\n#define mMmd_INSECT_NUM 40\n#define mMmd_FISH_NUM 40\n\nenum {\n  mMmd_DISPLAY_CANNOT_DONATE, /* Item cannot be donated */\n  mMmd_DISPLAY_CAN_DONATE, /* Item can be donated */\n  mMmd_DISPLAY_ALREADY_DONATED, /* Item has already been donated */\n\n  mMmd_DISPLAY_NUM\n};\n\nenum {\n  mMmd_DONATOR_NONE,\n  mMmd_DONATOR_PLAYER1,\n  mMmd_DONATOR_PLAYER2,\n  mMmd_DONATOR_PLAYER3,\n  mMmd_DONATOR_PLAYER4,\n  mMmd_DONATOR_DELETED_PLAYER,\n\n  mMmd_DONATOR_NUM\n};\n\nenum {\n  mMmd_CATEGORY_FOSSIL,\n  mMmd_CATEGORY_ART,\n  mMmd_CATEGORY_INSECT,\n  mMmd_CATEGORY_FISH,\n\n  mMmd_CATEGORY_NUM\n};\n\n/* 4 bits per donatable item */\n#define mMmd_BIT_INFO(info, category, index) \\\n  (((info).category##_bit[(index) >> 1] >> (((index) & 1) << 2)) & 0x0F)\n#define mMmd_BIT_INFO2(bitfield, index) \\\n  (((bitfield)[(index) >> 1] >> (((index) & 1) << 2)) & 0x0F)\n\n#define mMmd_ART_BIT(info, index) mMmd_BIT_INFO(info, art, index)\n#define mMmd_INSECT_BIT(info, index) mMmd_BIT_INFO(info, insect, index)\n#define mMmd_FISH_BIT(info, index) mMmd_BIT_INFO(info, fish, index)\n#define mMmd_FOSSIL_BIT(info, index) mMmd_BIT_INFO(info, fossil, index)\n\n#define mMmd_BIT_CLR(info, category, index) \\\n  ((info).category##_bit[(index) >> 1] &= ~(0b1111 << (((index) & 1) * 4)))\n\n#define mMmd_FOSSIL_CLR(info, index) mMmd_BIT_CLR(info, fossil, index)\n#define mMmd_ART_CLR(info, index) mMmd_BIT_CLR(info, art, index)\n#define mMmd_INSECT_CLR(info, index) mMmd_BIT_CLR(info, insect, index)\n#define mMmd_FISH_CLR(info, index) mMmd_BIT_CLR(info, fish, index)\n\n#define mMmd_BIT_SET(info, category, index, value) \\\n  ((info).category##_bit[(index) >> 1] |= (((value) & 0b1111) << (((index) & 1)) * 4))\n\n#define mMmd_FOSSIL_SET(info, index, value) mMmd_BIT_SET(info, fossil, index, value)\n#define mMmd_ART_SET(info, index, value) mMmd_BIT_SET(info, art, index, value)\n#define mMmd_INSECT_SET(info, index, value) mMmd_BIT_SET(info, insect, index, value)\n#define mMmd_FISH_SET(info, index, value) mMmd_BIT_SET(info, fish, index, value)\n\n/* sizeof(mMmd_info_c) == 0x3F */\ntypedef struct museum_display_info_s {\n  /* 0x00 */ u8 fossil_bit[mMmd_FOSSIL_BIT_NUM];\n  /* 0x0D */ u8 art_bit[mMmd_ART_BIT_NUM];\n  /* 0x15 */ u8 fish_bit[mMmd_FISH_BIT_NUM];\n  /* 0x2A */ u8 insect_bit[mMmd_INSECT_BIT_NUM];\n} mMmd_info_c;\n\n#define mFAs_PERFECT_DAY_STREAK_MAX 15 /* max number of perfect days in a row for golden axe reward */\n\n#define mFAs_GRASS_OVER_NUM 5\n#define mFAs_DUST_OVER_NUM 5\n#define mFAs_FG_BLOCK_EXCLUDE_NUM 5 /* number of excluded block types */\n#define mFAs_TREE_RANK_COUNT 5\n\nenum {\n  mFAs_FIELDRANK_ZERO,\n  mFAs_FIELDRANK_ONE,\n  mFAs_FIELDRANK_TWO,\n  mFAs_FIELDRANK_THREE,\n  mFAs_FIELDRANK_FOUR,\n  mFAs_FIELDRANK_FIVE,\n  mFAs_FIELDRANK_SIX,\n\n  mFAs_FIELDRANK_NUM\n};\n\nenum {\n  mFAs_CONDITION_NONE = -1,\n  mFAs_CONDITION_DUST_OVER = 0,\n  mFAs_CONDITION_TREE_LESS,\n  mFAs_CONDITION_TREE_OVER,\n  mFAs_CONDITION_GRASS_OVER,\n  mFAs_CONDITION_NO_CASE,\n\n  mFAs_CONDITION_NUM\n};\n\n/* sizeof(mFAs_GoodField_c) == 0xC */\ntypedef struct good_field_s {\n  /* 0x00 */ lbRTC_time_c renew_time; /* time updated */\n  /* 0x08 */ int perfect_day_streak; /* number of days in a row the town is \"perfect\" */\n} mFAs_GoodField_c;\n\ntypedef enum {\n  GRAPH_DOING_ZERO = 0,\n  GRAPH_DOING_CT,\n  GRAPH_DOING_GAME_CT,\n  GRAPH_DOING_GAME_CT_FINISHED,\n  GRAPH_DOING_GAME_MAIN,\n  GRAPH_DOING_GAME_TIME,\n  GRAPH_DOING_GAME_TIME_FINISHED,\n  GRAPH_DOING_GAME_EXEC,\n  GRAPH_DOING_GAME_EXEC_FINISHED,\n  GRAPH_DOING_GAME_BGM,\n  GRAPH_DOING_GAME_BGM_FINISHED,\n  GRAPH_DOING_GAME_MAIN_FINISHED,\n  GRAPH_DOING_TASK_SET,\n  GRAPH_DOING_WAIT_TASK,\n  GRAPH_DOING_WAIT_TASK_FINISHED,\n  GRAPH_DOING_TASK_SET_FINISHED,\n  GRAPH_DOING_AUDIO,\n  GRAPH_DOING_AUDIO_FINISHED,\n  GRAPH_DOING_GAME_18, /* Not sure what this is, relevant code removed */\n  GRAPH_DOING_GAME_DT,\n  GRAPH_DOING_GAME_DT_FINISHED,\n  GRAPH_DOING_DT,\n  GRAPH_DOING_END\n} GRAPH_DOING_POINT;\n\n#define GRAPH_MSG_BUF_COUNT 8\n\ntypedef struct graph_s {\n  /* 0x0000 */ Gfx* Gfx_list00; /* polygon opaque */\n  /* 0x0004 */ Gfx* Gfx_list01; /* polygon translucent */\n  /* 0x0008 */ void* DepthBuffer;\n  /* 0x000C */ Gfx* Gfx_list03; /* unused */\n  /* 0x0010 */ Gfx* Gfx_list04; /* overlay */\n  /* 0x0014 */ Gfx* Gfx_list07; /* font */\n  /* 0x0018 */ Gfx* Gfx_list08; /* shadow */\n  /* 0x001C */ Gfx* Gfx_list09; /* light */\n  /* 0x0020 */ Gfx* gfxsave;\n  /* 0x0024 */ u8 _unk24[32];\n  /* 0x0044 */ OSMessage graphReplyMesgBuf[GRAPH_MSG_BUF_COUNT];\n  /* 0x0064 */ OSMessageQueue* schedMesgQueue;\n  /* 0x0068 */ OSMessageQueue graphReplyMesgQueue;\n  /* 0x0088 */ u8 _unused_ossctask00p[0x68]; /* real type = OSScTask */\n  /* 0x00F0 */ u8 _unused_ossctask01p[0x68]; /* real type = OSScTask */\n  /* 0x0158 */ u8 _unused_ossctask02p[0x68]; /* real type = OSScTask */\n  /* 0x01C0 */ Gfx* Gfx_list05; /* work */\n  /* 0x01C4 */ THA_GA work_thaga;\n  /* 0x01D4 */ u8 _unk1D4[0xBC]; /* Maybe related to more OSScTask stuff? */\n  /* 0x0290 */ void* scheduler; /* Actually points to OSSched struct, only used in DnM? */\n  /* 0x0294 */ void* vimode; /* Actually points to OSViMode struct, not used in AC. */\n  /* 0x0298 */ THA_GA line_opaque_thaga;\n  /* 0x02A8 */ THA_GA line_translucent_thaga;\n  /* 0x02B8 */ THA_GA overlay_thaga;\n  /* 0x02C8 */ THA_GA polygon_opaque_thaga;\n  /* 0x02D8 */ THA_GA polygon_translucent_thaga;\n  /* 0x02E8 */ THA_GA font_thaga;\n  /* 0x02F8 */ THA_GA shadow_thaga;\n  /* 0x0308 */ THA_GA light_thaga;\n  /* 0x0318 */ THA_GA bg_opaque_thaga;\n  /* 0x0328 */ THA_GA bg_translucent_thaga;\n  /* 0x0338 */ int frame_counter;\n  /* 0x033C */ u16* frameBuffer;\n  /* 0x0340 */ u16* renderBuffer;\n  /* 0x0344 */ u32 vispecial;\n  /* 0x0348 */ u8 doing_point;\n  /* 0x0349 */ u8 _unk349;\n  /* 0x034A */ u8 need_viupdate;\n  /* 0x034B */ u8 cfb_bank;\n  /* 0x034C */ void (*taskEndCallback)(struct graph_s*, void*);\n  /* 0x0350 */ void* taskEndData;\n  /* 0x0354 */ f32 vixscale;\n  /* 0x0358 */ f32 viyscale;\n  /* 0x035C */ Gfx* last_dl;\n  /* 0x0360 */ Gfx* Gfx_list10; /* new0 (highlight/reflections?) */\n  /* 0x0364 */ Gfx* Gfx_list11; /* new1 (highlight/reflections?) */\n} GRAPH ATTRIBUTE_ALIGN(8); // one of the missing structs is likely aligned to 8 bytes.\n\nextern void graph_proc(void* arg);\nextern void graph_ct(GRAPH* g);\nextern void graph_dt(GRAPH* g);\n\n#define GRAPH_SET_DOING_POINT(g, point) ((g)->doing_point = GRAPH_DOING_##point)\n\n/* Graph display list macros for style and correctness enforcement */\n\n#define OPEN_DISP(graph) \t\t\t        \\\n  {\t\t\t\t\t\t                        \\\n    GRAPH* __graph = (graph); \t\t    \\\n    int __gfx_opened = 0;             \\\n\twhile (0)\n\n#define CLOSE_DISP(graph) \t\t\t      \\\n\t  (void)__gfx_opened; \t\t          \\\n  }\t\t\t\t\t\t                        \\\n  while (0)\n\n#define NEXT_DISP(thaga) ((thaga)->thaGfx.head_p++)\n#define NOW_DISP(thaga) ((thaga)->thaGfx.head_p)\n#define SET_DISP(thaga, p) ((thaga)->tha.head_p = (char*)(p))\n\n#define NEXT_POLY_OPA_DISP NEXT_DISP(&__graph->polygon_opaque_thaga)\n#define NEXT_POLY_XLU_DISP NEXT_DISP(&__graph->polygon_translucent_thaga)\n#define NEXT_OVERLAY_DISP NEXT_DISP(&__graph->overlay_thaga)\n#define NEXT_WORK_DISP NEXT_DISP(&__graph->work_thaga)\n#define NEXT_FONT_DISP NEXT_DISP(&__graph->font_thaga)\n#define NEXT_SHADOW_DISP NEXT_DISP(&__graph->shadow_thaga)\n#define NEXT_LIGHT_DISP\tNEXT_DISP(&__graph->light_thaga)\n#define NEXT_BG_OPA_DISP NEXT_DISP(&__graph->bg_opaque_thaga)\n#define NEXT_BG_XLU_DISP NEXT_DISP(&__graph->bg_translucent_thaga)\n\n#define NOW_POLY_OPA_DISP (Gfx*)NOW_DISP(&__graph->polygon_opaque_thaga)\n#define NOW_POLY_XLU_DISP (Gfx*)NOW_DISP(&__graph->polygon_translucent_thaga)\n#define NOW_OVERLAY_DISP (Gfx*)NOW_DISP(&__graph->overlay_thaga)\n#define NOW_WORK_DISP (Gfx*)NOW_DISP(&__graph->work_thaga)\n#define NOW_FONT_DISP (Gfx*)NOW_DISP(&__graph->font_thaga)\n#define NOW_SHADOW_DISP (Gfx*)NOW_DISP(&__graph->shadow_thaga)\n#define NOW_LIGHT_DISP (Gfx*)NOW_DISP(&__graph->light_thaga)\n#define NOW_BG_OPA_DISP (Gfx*)NOW_DISP(&__graph->bg_opaque_thaga)\n#define NOW_BG_XLU_DISP (Gfx*)NOW_DISP(&__graph->bg_translucent_thaga)\n\n#define SET_POLY_OPA_DISP(p) SET_DISP(&__graph->polygon_opaque_thaga, p)\n#define SET_POLY_XLU_DISP(p) SET_DISP(&__graph->polygon_translucent_thaga, p)\n#define SET_OVERLAY_DISP(p) SET_DISP(&__graph->overlay_thaga, p)\n#define SET_WORK_DISP(p) SET_DISP(&__graph->work_thaga, p)\n#define SET_FONT_DISP(p) SET_DISP(&__graph->font_thaga, p)\n#define SET_SHADOW_DISP(p) SET_DISP(&__graph->shadow_thaga, p)\n#define SET_LIGHT_DISP(p) SET_DISP(&__graph->light_thaga, p)\n#define SET_BG_OPA_DISP(p) SET_DISP(&__graph->bg_opaque_thaga, p)\n#define SET_BG_XLU_DISP(p) SET_DISP(&__graph->bg_translucent_thaga, p)\n\n#define GRAPH_ALLOC(graph, size) ((void*)((graph)->polygon_opaque_thaga.tha.tail_p = (char*)((int)(graph)->polygon_opaque_thaga.tha.tail_p - (int)(size))))\n#define GRAPH_ALLOC_TYPE(graph, type, num) (GRAPH_ALLOC(graph, sizeof(type) * (num)))\n\nextern u8 SoftResetEnable;\nextern GRAPH graph_class;\n\n/* sizeof(struct game_s) == 0xE0 */\ntypedef struct game_s {\n  /* 0x0000 */ GRAPH* graph;\n  /* 0x0004 */ void (*exec)(struct game_s* );\n  /* 0x0008 */ void (*cleanup)(struct game_s*);\n  /* 0x000C */ void (*next_game_init)(struct game_s*);\n  /* 0x0010 */ size_t next_game_class_size;\n  /* 0x0014 */ pad_t pads[MAXCONTROLLERS];\n  /* 0x0074 */ int pad_initialized;\n  /* 0x0078 */ THA tha;\n  /* 0x0088 */ GameAlloc gamealloc;\n  /* 0x009C */ u8 doing_point;\n  /* 0x009D */ u8 doing_point_specific; /* game class specific? */\n  /* 0x009E */ u8 disable_display;\n  /* 0x009F */ u8 doing;\n  /* 0x00A0 */ u32 frame_counter;\n  /* 0x00A4 */ int disable_prenmi;\n  /* 0x00A8 */ MCON mcon;\n} GAME;\n\ntypedef float MtxF_t[4][4];\n\n\n\ntypedef union {\n    struct {\n\n\n        float xx, yx, zx, wx,\n              xy, yy, zy, wy,\n              xz, yz, zz, wz,\n              xw, yw, zw, ww;\n    };\n    MtxF_t mf;\n} MtxF;\n\ntypedef struct prerender_s {\n  u16 width;\n  u16 height;\n\n  u16 width_bak;\n  u16 height_bak;\n\n  u8 _08[8];\n\n  void* framebuffer;\n  void* framebuffer_bak;\n\n  void* _18;\n\n  int _1C;\n  int _20;\n\n  u8 _24[0x24];\n} PreRender;\n\ntypedef struct submenu_overlay_s Submenu_Overlay_c;\ntypedef struct submenu_s Submenu;\n\ntypedef struct map_overlay_s mMP_Overlay_c;\ntypedef struct board_ovl_s mBD_Ovl_c;\ntypedef struct passwordMake_ovl_s mPM_Ovl_c;\ntypedef struct passwordChk_ovl_s mPC_Ovl_c;\ntypedef struct editor_ovl_s mED_Ovl_c;\ntypedef struct address_ovl_s mAD_Ovl_c;\ntypedef struct music_ovl_s mMU_Overlay_c;\ntypedef struct bank_ovl_s mBN_Overlay_c;\ntypedef struct diary_ovl_s mDI_Ovl_c;\ntypedef struct haniwaPortrait_ovl_s mHP_Ovl_c;\ntypedef struct timeIn_ovl_s mTI_Ovl_c;\ntypedef struct repay_ovl_s mRP_Ovl_c;\ntypedef struct notice_ovl_s mNT_Ovl_c;\ntypedef struct birthday_ovl_s mBR_Ovl_c;\ntypedef struct tag_ovl_s mTG_Ovl_c;\n\nenum {\n  mPM_ENTRY_TOWN,\n  mPM_ENTRY_PLAYER,\n\n  mPM_ENTRY_NUM\n};\n\nstruct passwordMake_ovl_s {\n  int selected_idx;\n  u8 lengths[mPM_ENTRY_NUM];\n  u8 town_name[LAND_NAME_SIZE];\n  u8 player_name[PLAYER_NAME_LEN];\n};\n\n#define mPC_STR_SIZE 14\n#define mPC_LINE_COUNT 2\n\nstruct passwordChk_ovl_s {\n  int selected_line;\n  u8 _04;\n  u8 _05;\n  u8 line0[mPC_STR_SIZE];\n  u8 line1[mPC_STR_SIZE];\n};\n\n#define mBD_BODY_LINE_NUM 6\n\nenum {\n  mBD_FIELD_HEADER,\n  mBD_FIELD_BODY,\n  mBD_FIELD_FOOTER,\n\n  mBD_FIELD_NUM\n};\n\nstruct board_ovl_s {\n  u8 field;\n  u8 center_line;\n  u8 _02;\n  u8 _03;\n  u8 _04;\n  u8 lengths[mBD_FIELD_NUM];\n  Mail_c mail;\n  Mail_c* dst_p;\n  f32 ofs_x;\n  f32 ofs_y;\n  int _140;\n  int _144;\n};\n\n#define mAD_PAGE_NUM 3\n\nstruct address_ovl_s {\n  u8 _00;\n  u8 _01;\n  u8 command;\n  u8 _03;\n  u8 _04;\n  u8 selected_entry;\n  u8 show_museum_address;\n  u8 _07;\n  u8 page_entry_count[mAD_PAGE_NUM];\n  f32 _0C;\n  f32 _10;\n  f32 _14[mAD_PAGE_NUM];\n  f32 _20[mAD_PAGE_NUM];\n  Mail_nm_c player_mail_name[PLAYER_NUM + 1]; // last entry is the museum name\n  Mail_nm_c animal_mail_name[ANIMAL_NUM_MAX];\n  Gfx* display_list; // set to the beginning of the address display list data for drawing over editor etc\n};\n\nenum {\n  mSM_MOVE_OUT_RIGHT,\n  mSM_MOVE_IN_RIGHT,\n  \n  mSM_MOVE_OUT_LEFT,\n  mSM_MOVE_IN_LEFT,\n  \n  mSM_MOVE_OUT_TOP,\n  mSM_MOVE_IN_TOP,\n  \n  mSM_MOVE_OUT_BOTTOM,\n  mSM_MOVE_IN_BOTTOM,\n\n  mSM_MOVE_NUM\n};\n\nenum submenu_overlay {\n  mSM_OVL_NONE,\n  \n  mSM_OVL_INVENTORY,\n  mSM_OVL_HBOARD,\n  mSM_OVL_TIMEIN,\n  mSM_OVL_LEDIT,\n  mSM_OVL_MAP,\n  mSM_OVL_NOTICE,\n  mSM_OVL_REPAY,\n  mSM_OVL_MSCORE,\n  mSM_OVL_BIRTHDAY,\n  mSM_OVL_EDITOR,\n  mSM_OVL_MAILBOX,\n  mSM_OVL_BOARD,\n  mSM_OVL_ADDRESS,\n  mSM_OVL_HANIWA,\n  mSM_OVL_EDITENDCHK,\n  mSM_OVL_WARNING,\n  mSM_OVL_CPMAIL,\n  mSM_OVL_CPWARNING,\n  mSM_OVL_CPEDIT,\n  mSM_OVL_CATALOG,\n  mSM_OVL_MUSIC,\n  mSM_OVL_BANK,\n  mSM_OVL_NEEDLEWORK,\n  mSM_OVL_CPORIGINAL,\n  mSM_OVL_DESIGN,\n  mSM_OVL_GBA,\n  mSM_OVL_DIARY,\n  mSM_OVL_CALENDAR,\n  mSM_OVL_PASSWORDMAKE,\n  mSM_OVL_PASSWORDCHK,\n\n  mSM_OVL_NUM\n};\n\nenum {\n  mSM_IV_OPEN_NORMAL,\n  mSM_IV_OPEN_MAILBOX,\n  mSM_IV_OPEN_HANIWA_ENTRUST,\n  mSM_IV_OPEN_HANIWA_TAKE,\n  mSM_IV_OPEN_QUEST,\n  mSM_IV_OPEN_SELL,\n  mSM_IV_OPEN_GIVE,\n  mSM_IV_OPEN_SEND_MAIL,\n  mSM_IV_OPEN_TAKE,\n  mSM_IV_OPEN_PUTIN_FTR,\n  mSM_IV_OPEN_MINIDISK,\n  mSM_IV_OPEN_SHRINE,\n  mSM_IV_OPEN_12,\n  mSM_IV_OPEN_EXCHANGE,\n  mSM_IV_OPEN_14,\n  mSM_IV_OPEN_CURATOR,\n  mSM_IV_OPEN_16,\n\n  mSM_IV_OPEN_NUM\n};\n\ntypedef void (*SUBMENU_PROC)(Submenu*);\ntypedef void (*SUBMENU_GAME_PROC)(Submenu*, GAME*);\n\ntypedef struct submenu_segment_s {\n  u8 _00[0x54];\n} mSM_Segment_c;\n\ntypedef struct submenu_menu_info_s {\n  int menu_type;\n  int proc_status;\n  \n  int pre_menu_type;\n  SUBMENU_PROC pre_move_func;\n  SUBMENU_GAME_PROC pre_draw_func;\n\n  int next_menu_type;\n\n  f32 position[2];\n  f32 speed[2];\n\n  char* _28;\n  int _2C;\n\n  int next_proc_status;\n  s16 move_drt;\n  u16 _36;\n\n  int data0;\n  int data1;\n  void* data2;\n  int data3;\n} mSM_MenuInfo_c;\n\ntypedef struct submenu_control_s {\n  SUBMENU_PROC menu_move_func;\n  SUBMENU_GAME_PROC menu_draw_func;\n\n  void* hand_move_func;\n  void* hand_draw_func;\n\n  void* tag_move_func;\n  void* tag_draw_func;\n\n  int stick_release;\n  u32 trigger;\n  u32 last_trigger;\n  s16 repeat_timer;\n  s16 texture_movement_angle;\n  f32 texture_pos[2];\n  int animation_flag;\n} mSM_Control_c;\n\ntypedef void (*mSM_RETURN_FUNC_PROC)(Submenu*, mSM_MenuInfo_c*);\ntypedef void (*mSM_MOVE_MOVE_PROC)(Submenu*, mSM_MenuInfo_c*);\ntypedef void (*mSM_MOVE_END_PROC)(Submenu*, mSM_MenuInfo_c*);\ntypedef void (*mSM_MOVE_CHG_BASE_PROC)(mSM_MenuInfo_c*, int);\ntypedef void (*mSM_SET_CHAR_MATRIX_PROC)(GRAPH*);\ntypedef void (*mSM_CBUF_COPY_PROC)(GRAPH*, PreRender*, int, int, int);\ntypedef void (*mSM_SET_DRAWMODE_PROC)(GRAPH*, PreRender*, f32, f32, s16);\ntypedef void (*mSM_DRAW_ITEM_PROC)(GRAPH*, f32, f32, f32, mActor_name_t, int, int, int);\ntypedef void (*mSM_DRAW_MAIL_PROC)(GRAPH*, f32, f32, f32, Mail_c*, int, int);\ntypedef void (*mSM_SETUP_VIEW_PROC)(Submenu*, GRAPH*, int);\ntypedef void (*mSM_CHANGE_VIEW_PROC)(GRAPH*, f32, f32, f32, f32, s16, int, int);\n\ntypedef struct warning_ovl_s mWR_Ovl_c;\ntypedef struct end_edit_chk_s mEE_Ovl_c;\n\ntypedef void (*mSM_MOVE_PROC)(Submenu*, mSM_MenuInfo_c*);\n\n/* sizeof(struct submenu_overlay_s) == 0xA04 */\nstruct submenu_overlay_s {\n  /* TODO: finish */\n  /* 0x000 */ mSM_Segment_c segment;\n  /* 0x054 */ mSM_MenuInfo_c menu_info[mSM_OVL_NUM];\n  /* 0x90C */ mSM_Control_c menu_control;\n  /* 0x940 */ mSM_RETURN_FUNC_PROC return_func_proc;\n  /* 0x944 */ mSM_MOVE_MOVE_PROC move_Move_proc;\n  /* 0x948 */ mSM_MOVE_END_PROC move_End_proc;\n  /* 0x94C */ mSM_MOVE_CHG_BASE_PROC move_chg_base_proc;\n  /* 0x950 */ mSM_SET_CHAR_MATRIX_PROC set_char_matrix_proc;\n  /* 0x954 */ mSM_CBUF_COPY_PROC cbuf_copy_proc;\n  /* 0x958 */ mSM_SET_DRAWMODE_PROC set_drawMode_proc;\n  /* 0x95C */ mSM_DRAW_ITEM_PROC draw_item_proc;\n  /* 0x960 */ mSM_DRAW_MAIL_PROC draw_mail_proc;\n  /* 0x964 */ mSM_SETUP_VIEW_PROC setup_view_proc;\n  /* 0x968 */ void* unused_func_968;\n  /* 0x96C */ mSM_CHANGE_VIEW_PROC change_view_proc;\n  /* 0x970 */ void* _970;\n  /* 0x974 */ void* _974;\n  /* 0x978 */ void* _978;\n  /* 0x97C */ mTG_Ovl_c* tag_ovl;\n  /* 0x980 */ void* _980;\n  /* 0x984 */ mHP_Ovl_c* hanwiaPortrait_ovl;\n  /* 0x988 */ void* inventory_ovl;\n  /* 0x98C */ mED_Ovl_c* editor_ovl;\n  /* 0x990 */ mBD_Ovl_c* board_ovl;\n  /* 0x994 */ mAD_Ovl_c* address_ovl;\n  /* 0x998 */ void* _998;\n  /* 0x99C */ void* _99C;\n  /* 0x9A0 */ mTI_Ovl_c* timeIn_ovl;\n  /* 0x9A4 */ mEE_Ovl_c* editEndChk_ovl;\n  /* 0x9A8 */ mWR_Ovl_c* warning_ovl;\n  /* 0x9AC */ mRP_Ovl_c* repay_ovl;\n  /* 0x9B0 */ void* _9B0;\n  /* 0x9B4 */ mMP_Overlay_c* map_ovl;\n  /* 0x9B8 */ mNT_Ovl_c* notice_ovl;\n  /* 0x9BC */ mBR_Ovl_c* birthday_ovl;\n  /* 0x9C0 */ void* _9C0;\n  /* 0x9C4 */ void* _9C4;\n  /* 0x9C8 */ void* _9C8;\n  /* 0x9CC */ void* _9CC;\n  /* 0x9D0 */ mMU_Overlay_c* music_ovl;\n  /* 0x9D4 */ mBN_Overlay_c* bank_ovl;\n  /* 0x9D8 */ void* _9D8;\n  /* 0x9DC */ void* _9DC;\n  /* 0x9E0 */ void* _9E0;\n  /* 0x9E4 */ void* _9E4;\n  /* 0x9E8 */ mDI_Ovl_c* diary_ovl;\n  /* 0x9EC */ void* _9EC;\n  /* 0x9F0 */ mPM_Ovl_c* passwordMake_ovl;\n  /* 0x9F4 */ mPC_Ovl_c* passwordChk_ovl;\n  /* 0x9F8 */ u8 hboard_exists;\n  /* 0x9F9 */ u8 le_exists;\n  /* 0x9FA */ u8 _9FA;\n  /* 0x9FB */ u8 _9FB;\n  /* 0x9FC */ int _9FC;\n  /* 0xA00 */ Mtx* projection_matrix;\n};\n\nenum {\n  mSM_PROCESS_WAIT,\n  mSM_PROCESS_PREWAIT,\n  mSM_PROCESS_LINKWAIT,\n  mSM_PROCESS_PLAY,\n  mSM_PROCESS_END,\n\n  mSM_PROCESS_NUM\n};\n\ntypedef struct submenu_item_s {\n  mActor_name_t item;\n  u8 slot_no;\n} Submenu_Item_c;\n\n/* sizeof (struct submenu_s) == 0x1B8 */\nstruct submenu_s {\n  /* 0x000 */ int mode;\n  /* 0x004 */ int menu_type;\n  /* 0x008 */ int current_menu_type;\n\n  /* 0x00C */ int process_status;\n\n  /* 0x010 */ int param0;\n  /* 0x014 */ int param1;\n  /* 0x018 */ void* param2;\n  /* 0x01C */ int param3;\n\n  /* 0x020 */ int wait_timer;\n\n  /* 0x024 */ char* overlay_address;\n  /* 0x028 */ char* next_overlay_address;\n  /* 0x02C */ Submenu_Overlay_c* overlay;\n  /* 0x030 */ SUBMENU_PROC move_proc;\n  /* 0x034 */ SUBMENU_GAME_PROC draw_proc;\n\n  /* 0x038 */ Mail_c mail; /* selected mail */\n  /* 0x162 */ u8 flag; // only set to 0 or 1, checked at least once in aQMgr_actor_move_talk_sub_hand_item_wait\n  /* 0x163 */ u8 after_mode; /* relates to code which runs after the submenu process */\n  /* 0x164 */ u8 unk_164; // only set to 0 in mSM_move_LINKWait in AC\n  /* 0x165 */ u8 disable_start_btn_flag; /* when set to TRUE, the START button input will be ignored */\n  /* 0x166 */ u8 disable_start_btn_timer; /* timer for when to disable the start button ignore flag */\n  /* 0x168 */ xyz_t water_pos; /* calculated to the nearest water position to the player for releasing fish */ \n  /* 0x174 */ Submenu_Item_c* item_p; /* pointer to a 'Submenu_Item_c' array, seemingly only points to Submenu::items */\n  /* 0x178 */ s16 item_num; /* number of items in the item array */\n  /* 0x17A */ s16 selected_item_num; /* number of selected items in the item array */\n  /* 0x17C */ Submenu_Item_c items[mPr_POCKETS_SLOT_COUNT]; /* item buffer, entries are only set when an item is selected by the player */\n};\n\nenum {\n  CAMERA2_PROCESS_STOP,\n  CAMERA2_PROCESS_NORMAL,\n  CAMERA2_PROCESS_WADE,\n  CAMERA2_PROCESS_TALK,\n  CAMERA2_PROCESS_DEMO,\n  CAMERA2_PROCESS_ITEM,\n  CAMERA2_PROCESS_LOCK,\n  CAMERA2_PROCESS_DOOR,\n  CAMERA2_PROCESS_SIMPLE,\n  CAMERA2_PROCESS_CUST_TALK,\n  CAMERA2_PROCESS_INTER,\n  CAMERA2_PROCESS_STAFF_ROLL,\n  CAMERA2_PROCESS_INTER2,\n\n  CAMERA2_PROCESS_NUM\n};\n\ntypedef struct camera_main_cust_talk_s {\n  ACTOR* speaker_actor;\n  ACTOR* listener_actor;\n  f32 center_ratio;\n  f32 cull_timer;\n  s16 angle_x;\n  s16 angle_y;\n  f32 distance;\n} CameraCustTalk;\n\ntypedef struct camera_main_demo_s {\n  xyz_t starting_center_pos;\n  f32 starting_distance;\n  s_xyz starting_direction;\n\n  xyz_t goal_center_pos;\n  f32 goal_distance;\n  s_xyz goal_direction;\n\n  f32 goal_delta;\n  f32 acceleration_delta;\n  f32 braking_delta;\n  f32 now_delta;\n} CameraDemo;\n\ntypedef struct camera_main_door_s {\n  u32 flags;\n  int morph_counter;\n  xyz_t center_position;\n} CameraDoor;\n\ntypedef struct camera_main_inter_s {\n  xyz_t starting_center_pos;\n  xyz_t starting_eye_pos;\n  \n  xyz_t goal_center_pos;\n  xyz_t goal_eye_pos;\n\n  f32 slope0;\n  f32 slope1;\n\n  u32 flags;\n\n  int now_delta;\n  int max_delta;\n\n  int pad[2];\n} CameraInter;\n\ntypedef struct camera_main_item_s {\n  int type;\n  f32 cull_timer;\n} CameraItem;\n\ntypedef struct camera_main_lock_s {\n  xyz_t center_pos;\n  xyz_t eye_pos;\n\n  f32 fov_y;\n\n  int morph_counter;\n\n  f32 near;\n  f32 far;\n} CameraLock;\n\ntypedef struct camera_main_normal_s {\n  u32 flags;\n\n  int last_indoor_distance_addition_idx;\n  int last_indoor_direction_addition_idx;\n\n  int morph_counter;\n} CameraNormal;\n\ntypedef struct camera_main_simple_s {\n  xyz_t center_pos;\n  s_xyz angle;\n  f32 distance;\n\n  int morph_counter;\n  int mode;\n\n  f32 cull_timer;\n} CameraSimple;\n\ntypedef struct camera_main_staff_roll_s {\n  xyz_t last_center_pos;\n  xyz_t last_eye_pos;\n  f32 last_distance;\n\n  ACTOR* speaker_actor;\n  ACTOR* listener_actor;\n\n  s16 rotation_y_delta;\n  s16 r_delta;\n  s16 rotation_x_delta;\n\n  u16 flags;\n  u16 morph_counter;\n  u16 pad;\n  u16 dist_counter;\n  s_xyz last_direction;\n} CameraStaffRoll;\n\ntypedef struct camera_main_talk_s {\n  ACTOR* speaker_actor;\n  ACTOR* listener_actor;\n\n  xyz_t listener_pos;\n  \n  f32 cull_timer;\n  u32 flags;\n\n  xyz_t goal_center_pos;\n} CameraTalk;\n\ntypedef struct camera_main_wade_s {\n  f32 timer;\n\n  xyz_t start_pos;\n  xyz_t goal_pos;\n\n  f32 goal_time;\n} CameraWade;\n\ntypedef union camera_main_data_u {\n  CameraCustTalk cust_talk;\n  CameraDemo demo;\n  CameraDoor door;\n  CameraInter inter;\n  CameraItem item;\n  CameraLock lock;\n  CameraNormal normal;\n  CameraSimple simple;\n  CameraStaffRoll staff_roll;\n  CameraTalk talk;\n  CameraWade wade;\n  \n  u64 align;\n} CameraMainData;\n\n/* request index data */\n\ntypedef struct camera_request_cust_talk_s {\n  ACTOR* speaker_actor;\n  ACTOR* listener_actor;\n  f32 center_ratio;\n  s16 angle_x;\n  s16 angle_y;\n  f32 distance;\n} CameraRequestCustTalk;\n\ntypedef struct camera_request_demo_s {\n  xyz_t starting_center_pos;\n  f32 starting_distance;\n  s_xyz starting_direction;\n\n  xyz_t goal_center_pos;\n  f32 goal_distance;\n  s_xyz goal_direction;\n\n  f32 goal_delta;\n  f32 acceleration_delta;\n  f32 braking_delta;\n} CameraRequestDemo;\n\ntypedef struct camera_request_door_s {\n  ACTOR* door_actor;\n  u32 flags;\n} CameraRequestDoor;\n\ntypedef struct camera_request_inter_s {\n  xyz_t starting_center_pos;\n  xyz_t starting_eye_pos;\n  \n  xyz_t goal_center_pos;\n  xyz_t goal_eye_pos;\n\n  f32 slope0;\n  f32 slope1;\n\n  u32 flags;\n\n  int morph_counter;\n\n  int pad[2];\n} CameraRequestInter;\n\ntypedef struct camera_request_item_s {\n  int type;\n} CameraRequestItem;\n\ntypedef struct camera_request_lock_s {\n  xyz_t center_pos;\n  xyz_t eye_pos;\n\n  f32 fov_y;\n\n  int morph_counter;\n\n  f32 near;\n  f32 far;\n} CameraRequestLock;\n\ntypedef struct camera_request_normal_s {\n  xyz_t position;\n\n  int flags;\n} CameraRequestNormal;\n\ntypedef struct camera_request_simple_s {\n  xyz_t center_pos;\n  s_xyz angle;\n  f32 distance;\n\n  int morph_counter;\n  int mode;\n} CameraRequestSimple;\n\ntypedef struct camera_request_staff_roll_s {\n  ACTOR* speaker_actor;\n  ACTOR* listener_actor;\n} CameraRequestStaffRoll;\n\ntypedef struct camera_request_talk_s {\n  ACTOR* speaker_actor;\n  ACTOR* listener_actor;\n\n  xyz_t listener_pos;\n\n  u32 flags;\n} CameraRequestTalk;\n\ntypedef struct camera_request_wade_s {\n  xyz_t goal_pos;\n  f32 goal_time;\n} CameraRequestWade;\n\ntypedef union camera_request_data_u {\n  CameraRequestCustTalk cust_talk;\n  CameraRequestDemo demo;\n  CameraRequestDoor door;\n  CameraRequestInter inter;\n  CameraRequestItem item;\n  CameraRequestLock lock;\n  CameraRequestNormal normal;\n  CameraRequestSimple simple;\n  CameraRequestStaffRoll staff_roll;\n  CameraRequestTalk talk;\n  CameraRequestWade wade;\n  \n  u64 align;\n} CameraRequestData;\n\ntypedef struct camera_lookat_s {\n  xyz_t eye;\n  xyz_t center;\n  xyz_t up;\n} CameraLookat;\n\ntypedef struct camera_perspective_s {\n  f32 fov_y;\n  f32 aspect_ratio;\n  f32 near;\n  f32 far;\n  f32 scale;\n} CameraPerspective;\n\ntypedef struct camera_s {\n  CameraLookat lookat;\n  CameraPerspective perspective;\n\n  s_xyz direction; /* camera orientation */\n  s_xyz direction_velocity; /* camera orentation rate of change */\n\n  xyz_t movement_velocity; /* camera world position velocity */\n\n  f32 focus_distance; /* distance to the camera focal point/subject */\n  f32 focus_distance_velocity; /* rate of change of the camera focus */\n\n  int indoor_distance_addition_idx; /* index of indoor distance adjustment LUT value to apply */\n  int indoor_direction_addition_idx; /* index of indoor direction adjustment LUT value to apply */\n\n  int now_main_index; /* current main index type */\n  int last_main_index; /* previous main index type */\n  int requested_main_index; /* requested main index type */\n  int requested_main_index_priority; /* requested main index priority value */\n  int requested_main_index_flag; /* TRUE/FALSE requested main index has been set */\n\n  CameraMainData main_data; /* current main index data */\n  CameraRequestData request_data; /* requested index data */\n\n  xyz_t mic_pos; /* mic position */\n  u32 flags; /* camera flags */\n\n  xyz_t offset_eye;\n  xyz_t offset_center;\n} Camera2;\n\n\nextern xyz_t* Camera2_getMicPos_p(GAME_PLAY* play);\nextern int Camera2_request_main_normal(GAME_PLAY* play, int flags, int priority);\nextern void Camera2_main_Simple_AngleDistStd(GAME_PLAY* play, s_xyz* dir, f32* dist);\n\ntypedef struct rect_s {\n  int top, bottom;\n  int l, r;\n} rect;\n\n#define VIEW_UPDATE_NONE 0\n#define VIEW_UPDATE_LOOKAT (1 << 0) // 1\n#define VIEW_UPDATE_SCISSOR (1 << 1) // 2\n#define VIEW_UPDATE_PERSPECTIVE (1 << 2) // 4\n#define VIEW_UPDATE_ORTHOGRAPHIC (1 << 3) // 8\n#define VIEW_UPDATE_ALL (VIEW_UPDATE_LOOKAT | VIEW_UPDATE_SCISSOR | VIEW_UPDATE_PERSPECTIVE | VIEW_UPDATE_ORTHOGRAPHIC) // 15\n\n/* sizeof(struct view_s) == 0x120 */\ntypedef struct view_s {\n  GRAPH* graph;\n  \n  rect screen;\n  f32 fovY;\n  f32 near, far;\n  f32 scale;\n  xyz_t eye;\n  xyz_t center;\n  xyz_t up;\n\n  Vp viewport;\n\n  Mtx mtx_projection;\n  Mtx mtx_viewing;\n  Mtx* p_projection;\n  Mtx* p_viewing;\n\n  struct stretch_s {\n    xyz_t target_rotate;\n    xyz_t target_scale;\n    f32 step; /* step speed between rotate/scale -> target_rotation/target_scale */\n    xyz_t rotate;\n    xyz_t scale;\n  } stretch;\n\n  u16 normal;\n  int flag;\n  int _unused_pad0;\n} View;\n\ntypedef struct block_table_s {\n  s8 block_x;\n  s8 block_z;\n\n  f32 pos_x;\n  f32 pos_z;\n\n  mActor_name_t* items;\n} mFI_block_tbl_c;\n\ntypedef struct pause_t{\n   int enabled;\n   int timer;\n} pause_t; // size = 0x8\n\ntypedef void (*mActor_proc)(ACTOR*, GAME*);\n\n#define ACTOR_STATE_NO_MOVE_WHILE_CULLED (1 << 4)\n#define ACTOR_STATE_NO_DRAW_WHILE_CULLED (1 << 5)\n#define ACTOR_STATE_CAN_MOVE_IN_DEMO_SCENES (1 << 29)\n#define ACTOR_STATE_IN_DEMO (1 << 30)\n\n#define ACTOR_OBJ_BANK_NONE 0\n#define ACTOR_OBJ_BANK_3 3 /* TODO: rename, also likely an enum */\n\nenum actor_part {\n  ACTOR_PART_FG,\n  ACTOR_PART_ITEM,\n  ACTOR_PART_PLAYER,\n  ACTOR_PART_3, /* TODO: figure this one out */\n  ACTOR_PART_NPC,\n  ACTOR_PART_BG,\n  ACTOR_PART_EFFECT,\n  ACTOR_PART_CONTROL,\n\n  ACTOR_PART_NUM\n};\n\n/* sizeof(ACTOR_PROFILE) == 0x24 */\ntypedef struct actor_profile_s {\n  /* 0x00 */ s16 id; /* unique actor type ID */\n  /* 0x02 */ u8 part; /* actor type, seemingly called 'part' */\n  /* 0x04 */ u32 initial_flags_state; /* initial actor flag state */\n  /* 0x08 */ mActor_name_t npc_id; /* \"world\" npc id/name */\n  /* 0x0A */ s16 obj_bank_id; /* used with object exchange */\n  /* 0x0C */ size_t class_size; /* sizeof(ZZZ_ACTOR) */\n  /* 0x10 */ mActor_proc ct_proc; /* constructor */\n  /* 0x14 */ mActor_proc dt_proc; /* destructor */\n  /* 0x18 */ mActor_proc mv_proc; /* move */\n  /* 0x1C */ mActor_proc dw_proc; /* draw */\n  /* 0x20 */ mActor_proc sv_proc; /* save */\n} ACTOR_PROFILE;\n\ntypedef void (*mActor_shadow_proc)(ACTOR*, void*, GAME_PLAY*); /* TODO: void* is actually LightsN*, see m_lights */\n\n/* sizeof(Shape_Info) == 0x48 */\ntypedef struct actor_shape_info_s {\n  /* 0x00 */ s_xyz rotation;\n  /* 0x06 */ s16 unk_6;\n  /* 0x08 */ f32 ofs_y;\n  /* 0x0C */ mActor_shadow_proc shadow_proc;\n  /* 0x10 */ f32 shadow_size_x;\n  /* 0x14 */ f32 shadow_size_z;\n  /* 0x18 */ f32 shadow_size_change_rate;\n  /* 0x1C */ f32 shadow_alpha_change_rate;\n  /* 0x20 */ int unk_20;\n  /* 0x24 */ xyz_t* shadow_position;\n  /* 0x28 */ int unk_28;\n  /* 0x2C */ u8 draw_shadow; /* TRUE = shadow is drawn, FALSE = shadow is not drawn */\n  /* 0x2D */ u8 unk_2D;\n  /* 0x2E */ u8 force_shadow_position; /* TRUE = shadow's position is forcefully updated, FALSE = non-forcefully updated */\n  /* 0x2F */ u8 unused_2F[0x48-0x2F];\n} Shape_Info;\n\ntypedef struct {\n    xyz_t position;\n    s_xyz angle;\n} PositionAngle;\n\n/* sizeof(mCoBG_CollisionData_c) == 4*/\ntypedef struct collision_bg_data_s {\n  /* 1------- -------- -------- -------- */ u32 shape:1; /* collision shape */\n  /* -11111-- -------- -------- -------- */ u32 center:5;\n  /* ------11 111----- -------- -------- */ u32 top_left:5;\n  /* -------- ---11111 -------- -------- */ u32 bot_left:5;\n  /* -------- -------- 11111--- -------- */ u32 top_right:5;\n  /* -------- -------- -----111 11------ */ u32 bot_right:5;\n  /* -------- -------- -------- --111111 */ u32 unit_attribute:6; /* background_attribute type */\n} mCoBG_CollisionData_c;\n\ntypedef union collision_bg_u {\n  mCoBG_CollisionData_c data;\n  u32 raw;\n} mCoBG_Collision_u;\n\ntypedef struct collision_bg_check_result_s {\n  u32 on_ground:1;\n  u32 hit_attribute_wall:5;\n  u32 hit_wall:5;\n  u32 hit_wall_count:3;\n  u32 unk_flag0:1;\n  u32 unit_attribute:6;\n  u32 is_on_move_bg_obj:1;\n  u32 is_in_water:1;\n  u32 unk_flag1:1;\n  u32 unk_flag2:1;\n  u32 unk_flag3:1;\n  u32 unk_flag4:1;\n  u32 unk_flag5:1;\n  u32 unk_flag6:4;\n} mCoBG_CheckResult_c;\n\ntypedef struct wall_info_s {\n  s16 angleY;\n  s16 type;\n} mCoBG_WallInfo_c;\n\ntypedef struct collision_bg_check_s {\n  mCoBG_Collision_u collision_units[5];\n  mCoBG_CheckResult_c result;\n  f32 wall_top_y;\n  f32 wall_bottom_y;\n  f32 ground_y;\n  mCoBG_WallInfo_c wall_info[2];\n  s16 in_front_wall_angle_y;\n} mCoBG_Check_c;\n\n/* This appears to again be copy-paste from OoT? */\ntypedef struct status_s {\n  xyz_t collision_vec;\n  s16 radius;\n  s16 height;\n  s16 offset;\n\n  u8 weight;\n  u8 hp;\n  u8 damage;\n\n  u8 damage_effect;\n  u8 at_hit_effect;\n  u8 ac_hit_effect;\n} Status_c;\n\ntypedef struct status_data_s {\n  u8 health; // assuming this is inherited from OoT, seems largely unused\n  s16 radius;\n  s16 height;\n  s16 offset;\n  u8 weight;\n} StatusData_c;\n\ntypedef struct actor_dlftbl_s {\n  u32 rom_start; // unused in AC\n  u32 rom_end; // unused in AC\n  u8* ram_start; // used only with a check, but never set in AC\n  u8* ram_end; // unused in AC\n  u8* alloc_buf; // used in AC but only on free check and data is never allocated\n  ACTOR_PROFILE* profile; // profile for the actor\n  int unk; // unused in AC\n  u16 flags; // related to memory pinning but functionally useless in AC since alloc_buf is never allocated\n  s8 num_actors; // number of this type of actor that currently exist\n  s8 unk2; // unused in AC\n} ACTOR_DLFTBL;\n\n/* sizeof(struct actor_s) == 0x174 */\nstruct actor_s {\n  /* 0x000 */ s16 id; /* unique actor type ID */\n  /* 0x002 */ u8 part;\n  /* 0x003 */ u8 restore_fg; /* restores 'fgdata' according to restore_fgdata_all */\n  /* 0x004 */ s16 scene_id;\n  /* 0x006 */ mActor_name_t npc_id;\n  /* 0x008 */ s8 block_x;\n  /* 0x009 */ s8 block_z;\n  /* 0x00A */ s16 move_actor_list_idx; /* used in aBC_setupCommonMvActor */\n  /* 0x00C */ PositionAngle home; /* Home position & rotation */\n  /* 0x020 */ u32 state_bitfield; /* bitfield of current actor state */\n  /* 0x024 */ s16 actor_specific; /* actor specific temp data */\n  /* 0x026 */ s16 data_bank_id; /* data bank id actor is in */\n  /* 0x028 */ PositionAngle world; /* World position & rotation */\n  /* 0x03C */ xyz_t last_world_position; /* previous actor world position */\n  /* 0x048 */ PositionAngle eye; /* actor \"eyes\" (head/lookat) world position & rotation */\n  /* 0x05C */ xyz_t scale; /* actor size */\n  /* 0x068 */ xyz_t position_speed; /* actor movement velocity (see Actor_position_speed_set) */\n  /* 0x074 */ f32 speed; /* movement speed */\n  /* 0x078 */ f32 gravity; /* gravity acting on actor */\n  /* 0x07C */ f32 max_velocity_y; /* maximum y velocity possible due to gravity, usually -20.0f */\n  /* 0x080 */ f32 ground_y; /* vertical position of ground underneath actor */\n  /* 0x084 */ mCoBG_Check_c bg_collision_check; /* background object collision info with actor */\n  /* 0x0B4 */ u8 unknown_b4; /* some sort of flag */\n  /* 0x0B5 */ u8 drawn; /* was drawn flag, TRUE = actor was drawn, FALSE = actor was not drawn */\n  /* 0x0B6 */ s16 player_angle_y; /* Y angle (yaw) between actor and player actor */\n  /* 0x0B8 */ f32 player_distance; /* distance between actor and player actor (squared magnitude) */\n  /* 0x0BC */ f32 player_distance_xz; /* distance between actor and player actor on XZ plane (magnitude) */\n  /* 0x0C0 */ f32 player_distance_y; /* distance between actor and player actor on Y plane */\n  /* 0x0C4 */ Status_c status_data; /* collider info, lots of leftover stuff from OoT */\n  /* 0x0DC */ Shape_Info shape_info;\n  /* 0x124 */ xyz_t camera_position; /* camera position relative to actor position */\n  /* 0x130 */ f32 camera_w; /* camera projection W value */\n  /* 0x134 */ f32 cull_width;\n  /* 0x138 */ f32 cull_height;\n  /* 0x13C */ f32 cull_distance;\n  /* 0x140 */ f32 cull_radius;\n  /* 0x144 */ f32 talk_distance; /* maximum distance for talking to be triggered, default seems to be 55.0f */\n  /* 0x148 */ u8 cull_while_talking; /* flag to disable actor drawing while talking */\n  /* 0x149 */ u8 skip_drawing; /* manual \"do not draw\" override flag only used by player umbrella actor */\n  /* 0x14C */ ACTOR* parent_actor;\n  /* 0x150 */ ACTOR* child_actor;\n  /* 0x154 */ ACTOR* prev_actor;\n  /* 0x158 */ ACTOR* next_actor;\n  /* 0x15C */ mActor_proc ct_proc; /* constructor */\n  /* 0x160 */ mActor_proc dt_proc; /* destructor */\n  /* 0x164 */ mActor_proc mv_proc; /* move */\n  /* 0x168 */ mActor_proc dw_proc; /* draw */\n  /* 0x16C */ mActor_proc sv_proc; /* save */\n  /* 0x170 */ ACTOR_DLFTBL* dlftbl; /* display list function table */\n};\n\n#define mActor_NONE_PROC1 ((mActor_proc)none_proc1)\n\ntypedef struct actor_list_s {\n  int num_actors;\n  ACTOR* actor;\n} Actor_list;\n\ntypedef struct actor_info_s {\n  int total_num;\n  Actor_list list[ACTOR_PART_NUM];\n} Actor_info;\n\ntypedef struct xy_s {\n    f32 x, y;\n} xy_t;\n\ntypedef struct {\n    /* 0x00 */ int cols;\n    /* 0x04 */ int rows;\n    /* 0x08 */ int frame;\n    /* 0x0C */ xy_t* vtxData;\n    /* 0x10 */ Vtx* vtxFrame1;\n    /* 0x14 */ Vtx* vtxFrame2;\n    /* 0x18 */ Mtx projection;\n    /* 0x58 */ Mtx modelView1;\n    /* 0x98 */ Mtx modelView2;\n    /* 0xD8 */ Gfx* gfx; // \"gfxtbl\"\n    /* 0xDC */ u16* zBuffer;\n} fbdemo; // size = 0xE0\n\n\nextern void fbdemo_init_gfx(fbdemo*);\nextern void fbdemo_init_data(fbdemo*);\nextern void fbdemo_cleanup(fbdemo*);\nextern fbdemo* fbdemo_init(fbdemo*, int, int); \nextern void fbdemo_update(fbdemo*);\nextern void fbdemo_draw(fbdemo*, Gfx**);\nextern void fbdemo_move(fbdemo*);\n\ntypedef union {\n    struct {\n        u8 r, g, b, a;\n    };\n    u32 rgba;\n} Color_RGBA8_u32;\n\ntypedef struct {\n    /* 0x000 */ Color_RGBA8_u32 color;\n    /* 0x004 */ Color_RGBA8_u32 unkColor;\n    /* 0x008 */ u8 direction;\n    /* 0x009 */ u8 frame;\n    /* 0x00A */ u8 finished;\n    /* 0x00C */ u16 texX;\n    /* 0x00E */ u16 texY;\n    /* 0x010 */ u16 normal;\n    /* 0x018 */ Mtx projection;\n    /* 0x058 */ Mtx lookAt;\n    /* 0x098 */ Mtx modelView[2][3];\n} fbdemo_wipe1; // size = 0x218\n\n\nextern fbdemo_wipe1* fbdemo_wipe1_init(fbdemo_wipe1*);\nextern void fbdemo_wipe1_move(fbdemo_wipe1*, int);\nextern void fbdemo_wipe1_draw(fbdemo_wipe1*, Gfx**);\nextern void fbdemo_wipe1_startup(fbdemo_wipe1*);\nextern void fbdemo_wipe1_settype(fbdemo_wipe1*, int);\nextern void fbdemo_wipe1_setcolor_rgba8888(fbdemo_wipe1*, u32);\nextern u8 fbdemo_wipe1_is_finish(fbdemo_wipe1*);\n\ntypedef struct {\n    /* 0x00 */ int txt;\n    /* 0x04 */ int frame;\n    /* 0x08 */ u8 direction;\n    /* 0x09 */ u8 textureno;\n    /* 0x0A */ s8 finished;\n    /* 0x0B */ u8 tmp;\n    /* 0x0C */ u16 normal;\n    /* 0x0E*/  u8 temp2[2]; \n    /* 0x10 */ Mtx perspmtx;\n    /* 0x50 */ Mtx lookatmtx;\n} fbdemo_triforce; // size = 0x90;\n\nextern void fbdemo_triforce_startup(fbdemo_triforce*);\nextern fbdemo_triforce* fbdemo_triforce_init(fbdemo_triforce*);\nextern void fbdemo_triforce_move(fbdemo_triforce*, int);\nextern void fbdemo_triforce_draw(fbdemo_triforce*, Gfx**);\nextern s8 fbdemo_triforce_is_finish(fbdemo_triforce*);\nextern void fbdemo_triforce_settype(fbdemo_triforce*, int);\nextern void fbdemo_triforce_setcolor_rgba8888(void);\n\ntypedef struct {\n    /* 0x000 */ u8 type;\n    /* 0x001 */ u8 isDone;\n    /* 0x002 */ u8 direction;\n    /* 0x004 */ Color_RGBA8_u32 color;\n    /* 0x008 */ s16 frame;\n    /* 0x00A */ u16 unkA;\n    /* 0x00C */ u16 timer;\n} fbdemo_fade; // size = 0x10\n\n\nextern fbdemo_fade* fbdemo_fade_init(fbdemo_fade*);\nextern void fbdemo_fade_move(fbdemo_fade*, int);\nextern void fbdemo_fade_startup(fbdemo_fade*);\nextern void fbdemo_fade_settype(fbdemo_fade*, int);\nextern void fbdemo_fade_setcolor_rgba8888(fbdemo_fade* fade, u32 color);\nextern u8 fbdemo_fade_is_finish(fbdemo_fade*);\n\ntypedef union fbdemo_wipe_union {\n  fbdemo_wipe1 fbdemo_wipe1;\n  fbdemo_triforce fbdemo_triforce;\n  fbdemo_fade fbdemo_fade;\n} fbdemo_wipe_u;\n\ntypedef fbdemo_wipe_u* (*FBDEMO_INIT_PROC)(fbdemo_wipe_u*);\ntypedef void (*FBDEMO_CLEANUP_PROC)(fbdemo_wipe_u*);\ntypedef void (*FBDEMO_MOVE_PROC)(fbdemo_wipe_u*, int);\ntypedef void (*FBDEMO_DRAW_PROC)(fbdemo_wipe_u*, Gfx**);\ntypedef void (*FBDEMO_STARTUP_PROC)(fbdemo_wipe_u*);\ntypedef void (*FBDEMO_SETTYPE_PROC)(fbdemo_wipe_u*, int);\ntypedef void (*FBDEMO_SETCOLOR_PROC)(fbdemo_wipe_u*, u32);\ntypedef int (*FBDEMO_ISFINISHED_PROC)(fbdemo_wipe_u*);\n\ntypedef struct {\n  FBDEMO_INIT_PROC init_proc;\n  FBDEMO_CLEANUP_PROC cleanup_proc;\n  FBDEMO_MOVE_PROC move_proc;\n  FBDEMO_DRAW_PROC draw_proc;\n  FBDEMO_STARTUP_PROC startup_proc;\n  FBDEMO_SETTYPE_PROC settype_proc;\n  FBDEMO_SETCOLOR_PROC setcolor_proc;\n  void* unused_proc; // unknown\n  FBDEMO_ISFINISHED_PROC isfinished_proc;\n} fbdemo_wipe_proc_c;\n\ntypedef struct {\n  fbdemo_wipe_u wipe_data;\n  int wipe_type;\n  fbdemo_wipe_proc_c wipe_procs;\n} fbdemo_wipe;\n\ntypedef struct {\n    /* 0x0 */ s16 x;\n    /* 0x2 */ s16 y;\n    /* 0x4 */ s16 z;\n    /* 0x6 */ u8 color[3];\n    /* 0x9 */ u8 drawGlow;\n    /* 0xA */ s16 radius;\n} LightPoint; // size = 0xC\n\ntypedef struct {\n    /* 0x0 */ s8 x;\n    /* 0x1 */ s8 y;\n    /* 0x2 */ s8 z;\n    /* 0x3 */ u8 color[3];\n} LightDiffuse; // size = 0x6\n\ntypedef union {\n    LightPoint point;\n    LightDiffuse diffuse;\n} LightParams; // size = 0xC\n\ntypedef struct lights_s {\n    u8 type;\n    LightParams lights;\n} Lights;\n\n\ntypedef struct light_list {\n    /* 0x0 */ Lights* info;\n    /* 0x4 */ struct light_list* prev;\n    /* 0x8 */ struct light_list* next;\n} Light_list; // size = 0xC\n\ntypedef struct light_buf_s{\n    int current;\n    int idx;\n    Light_list lights[32];\n} Light_buffer;\n\ntypedef struct global_light_s {\n    /* 0x0 */ Light_list* list;\n    /* 0x4 */ u8 ambientColor[3];\n    /* 0x7 */ u8 fogColor[3];\n    /* 0xA */ s16 fogNear;\n    /* 0xC */ s16 fogFar; \n} Global_light; // size = 0x10\n\ntypedef struct base_light_s {\n  u8 ambient_color[3];\n  s8 sun_dir[3];\n  u8 sun_color[3];\n  s8 moon_dir[3];\n  u8 moon_color[3];\n  u8 fog_color[3];\n  s16 fog_near;\n  s16 fog_far;\n  u8 shadow_color[3];\n  u8 room_color[3];\n  u8 sun_color_window[3];\n  u8 moon_color_window[3];\n  u8 background_color[3];\n} BaseLight;\n\ntypedef struct add_light_info_s {\n  s16 ambient_color[3];\n  s16 diffuse_color[3];\n  s16 fog_color[3];\n  s16 fog_near;\n  s16 fog_far;\n} AddLightInfo;\n\ntypedef void (*NATURE_PROC)(ACTOR*);\n\ntypedef struct nature_s {\n  NATURE_PROC proc;\n  void* arg;\n} Nature;\n\ntypedef struct kankyo_s {\n  /* 0x00 */ Lights sun_light;\n  /* 0x0E */ Lights moon_light;\n  /* 0x1C */ Lights* lamp_light;\n  /* 0x20 */ Lights point_light;\n  /* 0x30 */ int _30;\n  /* 0x34 */ u8 _34[0x78 - 0x34];\n  /* 0x78 */ AddLightInfo add_light_info; /* extra values added to specific light parameters */\n  /* 0x90 */ int _90;\n  /* 0x94 */ BaseLight base_light;\n  /* 0xBA */ u8 _BA[0xC0 - 0xBA];\n  /* 0xC0 */ f32 shadow_pos;\n  /* 0xC4 */ u8 shadow_alpha;\n  /* 0xC5 */ u8 countdown_timer;\n  /* 0xC8 */ Nature nature;\n} Kankyo;\n\ntypedef struct event_s {\n  u8 day;\n  u8 hour;\n  u8 _02;\n  u8 state;\n  u8 month;\n  u8 year;\n  s16 changed_num;\n  int block_z;\n  int block_x;\n  int unused[5];\n} Event_c;\n\ntypedef struct math_3d_pipe_s {\n  s16 radius;\n  s16 height;\n  s16 offset;\n  s_xyz center;\n} Math3D_pipe_c;\n\ntypedef struct math_3d_sphere_s{\n  s_xyz center;\n  s16 radius;\n}Math3D_sphere_c;\n\ntypedef struct math_3d_plane_s {\n  xyz_t normal;\n  f32 originDist;\n} Math3D_plane_c; // size = 0x10\n\ntypedef struct math_3d_triangle_s {\n  xyz_t vtx[3];\n  Math3D_plane_c plane;\n} Math3D_triangle_c; // size = 0x34\n\ntypedef struct collision_obj_s {\n  ACTOR* owner_actor; // actor which owns this collision object\n  ACTOR* collided_actor; // actor which the owner collided with or NULL\n\n  u8 collision_flags0;\n  u8 collision_flags1;\n\n  u8 collision_type;\n} ClObj_c;\n\ntypedef struct collision_elem_s {\n  u8 flags;\n} ClObjElem_c;\n\ntypedef struct collision_pipe_attribute_s {\n  Math3D_pipe_c pipe;\n} ClObjPipeAttr_c;\n\ntypedef struct collision_pipe_s {\n  ClObj_c collision_obj;\n  ClObjElem_c element;\n  ClObjPipeAttr_c attribute;\n} ClObjPipe_c;\n\n/* static data */\n\ntypedef struct collision_obj_data_s {\n  u8 collision_flags0;\n  u8 collision_flags1;\n  u8 type;\n} ClObjData_c;\n\ntypedef struct collision_obj_elem_data_s {\n  u8 flags;\n} ClObjElemData_c;\n\ntypedef struct collision_obj_pipe_attr_data_s {\n  Math3D_pipe_c pipe;\n} ClObjPipeAttrData_c;\n\ntypedef struct collision_obj_pipe_data_s {\n  ClObjData_c collision_data;\n  ClObjElemData_c element_data;\n  ClObjPipeAttrData_c attribute_data;\n} ClObjPipeData_c;\n\ntypedef struct collision_check_tris_element_attr_data_s{\n  xyz_t vtx[3];\n}ClObjTrisElemAttrData_c;\n\ntypedef struct collision_check_tris_element_data_s{\n  ClObjElemData_c element;\n  ClObjTrisElemAttrData_c data;\n}ClObjTrisElemData_c;\n\ntypedef struct collision_check_tris_element_s{\n    Math3D_triangle_c tri;\n    xyz_t t;\n}ClObjTrisElemAttr_c;\n\ntypedef struct collision_tris_elem_s{\n  ClObjElem_c element;\n  ClObjTrisElemAttr_c attribute;\n}ClObjTrisElem_c;\n\ntypedef struct collision_tris_s {\n  ClObj_c collision_obj;\n  int count;\n  ClObjTrisElem_c* elements;\n} ClObjTris_c;\n\ntypedef struct ClObjTris_Init {\n  ClObjData_c data;\n  int count;\n  ClObjTrisElemData_c* elem_data;\n} ClObjTrisData_c;\n\ntypedef struct collision_obj_joint_sphere_elem_attribute_s{\n    Math3D_sphere_c s1;\n    Math3D_sphere_c s2;\n    f32 unk8;\n    u8 unk14;\n}ClObjJntSphElemAttr_c; \n\ntypedef struct collision_joint_sphere_elem_s{\n  ClObjElem_c element;\n  ClObjJntSphElemAttr_c attribute;\n}ClObjJntSphElem_c;\n\ntypedef struct collision_joint_sphere_s {\n   ClObj_c collision_obj;\n   int count;\n   ClObjJntSphElem_c* elements;\n}ClObjJntSph_c;\n\n#define Cl_COLLIDER_NUM 50\ntypedef struct collision_check_s {\n  u16 flags;\n  int collider_num;\n  ClObj_c* collider_table[Cl_COLLIDER_NUM];\n} CollisionCheck_c;\n\ntypedef struct scene_status_s {\n  u8 unk0[0x13];\n  u8 unk13;\n} Scene_data_status_c;\n\ntypedef int (*DRAW_CHK_PROC)(ACTOR*, GAME_PLAY*);\ntypedef void (*PLAY_WIPE_PROC)(GAME_PLAY*);\n\n/* sizeof(struct game_play_s) == 0x2600 */\nstruct game_play_s {\n  /* 0x0000 */ GAME game;\n  // TODO: finish\n  /* 0x00E0 */ s16 scene_id;\n  /* 0x00E4 */ mFI_block_tbl_c block_table;\n  /* 0x00F4 */ mFI_block_tbl_c last_block_table;\n  /* 0x0104 */ u8 _0104[0x010C - 0x0104];\n  /* 0x010C */ Scene_Word_u* current_scene_data;\n  /* 0x0110 */ Object_Exchange_c object_exchange;\n  /* 0x1A68 */ View view;\n  /* 0x1B88 */ Camera2 camera;\n  /* 0x1CC0 */ Kankyo kankyo; \n  /* 0x1D90 */ Global_light global_light;\n  /* 0x1DA0 */ pause_t pause;\n  /* 0x1DA8 */ Actor_info actor_info;\n  /* 0x1DEC */ Submenu submenu;\n  /* 0x1FA4 */ s8 submenu_ground_idx;\n  /* 0x1FA8 */ char* submenu_ground_tex[2];\n  /* 0x1FB0 */ char* submenu_ground_pallet[2];\n  /* 0x1FB8 */ PreRender prerender;\n  /* 0x2000 */ Door_info_c door_info;\n  /* 0x2008 */ int next_scene_no;\n  /* 0x200C */ MtxF projection_matrix;\n  /* 0x204C */ MtxF billboard_matrix;\n  /* 0x208C */ Mtx* _208C;\n  /* 0x2090 */ u32 game_frame; \n  /* 0x2094 */ u8 _2094;\n  /* 0x2095 */ u8 actor_data_num;\n  /* 0x2096 */ u8 ctrl_actor_data_num;\n  /* 0x2097 */ u8 obj_bank_data_num;\n  /* 0x2098 */ Actor_data* player_data;\n  /* 0x209C */ Actor_data* actor_data;\n  /* 0x20A0 */ s16* ctrl_actor_data;\n  /* 0x20A4 */ s16* obj_bank_data;\n  /* 0x20A8 */ int _20A8;\n  /* 0x20AC */ Event_c event;\n  /* 0x20D0 */ u8 fb_fade_type;\n  /* 0x20D1 */ u8 fb_wipe_type;\n  /* 0x20D2 */ u8 fb_mode;\n  /* 0x20D3 */ u8 fb_wipe_mode;\n  /* 0x20D8 */ fbdemo_wipe fbdemo_wipe;\n  /* 0x2318 */ fbdemo_fade color_fade;\n  /* 0x2328 */ CollisionCheck_c collision_check;\n  /* 0x23F8 */ DRAW_CHK_PROC draw_chk_proc; // only used by mikanbox actor\n  /* 0x23FC */ u32 fade_color_value;\n  /* 0x2400 */ Scene_data_status_c* scene_data_status;\n  /* 0x2404 */ u8 _2400[0x2600 - 0x2404];\n};\n\n#define mMsr_ACTIVE_HOUR 8\n#define mMsr_NUM_MUSHROOMS 5\n\n/* sizeof(mMsr_time_c) == 6 */\ntypedef struct mushroom_time_s {\n  /* 0x00 */ u16 year:12;\n  /* 0x01 */ u16 month:4;\n  /* 0x02 */ u8 day:5;\n  /* 0x02 */ u8 pad0:3;\n  /* 0x03 */ u8 hour:5;\n  /* 0x03 */ u8 pad1:3;\n  /* 0x04 */ u8 hour_quarter:4;\n  /* 0x04 */ u8 active:1; /* probably a better name for this */\n  /* 0x04 */ u8 pad2:3;\n} mMsr_time_c;\n\n/* sizeof(PlusBridge_c) == 8 */\ntypedef struct bridge_s {\n  /* 0x00 */ u8 block_x;\n  /* 0x01 */ u8 block_z;\n  /* 0x02 */ struct {\n    u8 exists:1;\n    u8 pending:1;\n    u8 pad:6;\n  };\n  /* 0x04 */ lbRTC_ymd_c build_date;\n} PlusBridge_c;\n\ntypedef struct lighthouse_s {\n  lbRTC_ymd_c renew_time;\n  u8 players_switch_on;\n  u8 players_quest_started;\n  u8 players_completed;\n} LightHouse_c;\n\n\nvoid* zelda_malloc_align(u32 size, u32 align);\nu32 JW_GetResSizeFileNo(u32);\nvoid zelda_free(void* ptr);\nvoid _JW_GetResourceAram(u32, void*, size_t);\nu32 JW_GetAramAddress(u32);\n\nint mHS_get_pl_no_detail(int);\nvoid mCkRh_InitGokiSaveData_1Room(int);\nvoid mCkRh_InitGokiSaveData_1Room_ByHomeData(mHm_hs_c*);\n\nint mHS_get_arrange_idx(int);\n\nlbRTC_weekday_t lbRTC_Week(lbRTC_year_t year, lbRTC_month_t month, lbRTC_day_t day);\nmActor_name_t mFI_GetFieldId(void);\nextern int lbRTC_GetInvervalDays(const lbRTC_time_c* t0, const lbRTC_time_c* t1);\n\n#define mCkRh_MAX_NUM 10 /* maximum 'stored' in the house */\n#define mCkRh_INTERVAL_DAYS 6 /* number of days before roaches will spawn */\n\n#define mCkRh_CAN_LOOK_GOKI_NUM 3 /* maximum that can spawn in the house at once */\n\nenum scene_table {\n  SCENE_TEST1,\n  SCENE_TEST2,\n  SCENE_TEST3,\n  SCENE_WATER_TEST,\n  SCENE_FOOTPRINT_TEST,\n  SCENE_NPC_TEST,\n  SCENE_NPC_HOUSE, /* npc house interior */\n  SCENE_FG, /* outdoors/FG */\n  SCENE_RANDOM_NPC_TEST,\n  SCENE_SHOP0, /* nook's cranny */\n  SCENE_BG_TEST_NO_RIVER,\n  SCENE_BG_TEST_RIVER,\n  SCENE_BROKER_SHOP, /* crazy redd's tent */\n  SCENE_FIELD_TOOL_INSIDE,\n  SCENE_POST_OFFICE, /* post office */\n  SCENE_START_DEMO, /* after player select */\n  SCENE_START_DEMO2, /*  */\n  SCENE_POLICE_BOX,\n  SCENE_BUGGY,\n  SCENE_PLAYERSELECT,\n  SCENE_MY_ROOM_S,\n  SCENE_MY_ROOM_M,\n  SCENE_MY_ROOM_L,\n  SCENE_CONVENI, /* nook 'n' go */\n  SCENE_SUPER, /* nookway */\n  SCENE_DEPART, /* nookington's 1st floor */\n  SCENE_TEST5,\n  SCENE_PLAYERSELECT_2,\n  SCENE_PLAYERSELECT_3,\n  SCENE_DEPART_2, /* nookington's 2nd floor */\n  SCENE_EVENT_ANNOUNCEMENT,\n  SCENE_KAMAKURA,\n  SCENE_FIELD_TOOL,\n  SCENE_TITLE_DEMO, /* title screen demo */\n  SCENE_PLAYERSELECT_SAVE,\n  SCENE_MUSEUM_ENTRANCE,\n  SCENE_MUSEUM_ROOM_PAINTING,\n  SCENE_MUSEUM_ROOM_FOSSIL,\n  SCENE_MUSEUM_ROOM_INSECT,\n  SCENE_MUSEUM_ROOM_FISH,\n  SCENE_MY_ROOM_LL1,\n  SCENE_MY_ROOM_LL2,\n  SCENE_MY_ROOM_BASEMENT_S,\n  SCENE_MY_ROOM_BASEMENT_M,\n  SCENE_MY_ROOM_BASEMENT_L,\n  SCENE_MY_ROOM_BASEMENT_LL1,\n  SCENE_NEEDLEWORK, /* able sister's */\n  SCENE_COTTAGE_MY,\n  SCENE_COTTAGE_NPC,\n  SCENE_START_DEMO3,\n  SCENE_LIGHTHOUSE,\n  SCENE_TENT,\n\n  SCENE_NUM\n};\n\nenum field_type {\n  mFI_FIELDTYPE_FG,\n  mFI_FIELDTYPE_1,\n  mFI_FIELDTYPE_2,\n  mFI_FIELDTYPE_ROOM,\n  mFI_FIELDTYPE_NPC_ROOM,\n  mFI_FIELDTYPE_DEMO,\n  mFI_FIELDTYPE_PLAYER_ROOM,\n\n  mFI_FIELDTYPE_NUM\n};\n\n#define mFI_TO_FIELD_ID(type, index) (((type) << 12) | (index))\n#define mFI_GET_TYPE(field_id) ((field_id) & 0xF000)\n#define mFI_TYPE(type) ((type) << 12)\n\nenum field_room {\n  /* TODO: others */\n  mFI_FIELD_FG = mFI_TO_FIELD_ID(mFI_FIELDTYPE_FG, 0),\n\n  mFI_FIELD_ROOM0 = mFI_TO_FIELD_ID(mFI_FIELDTYPE_ROOM, 0),\n  mFI_FIELD_ROOM_SHOP0,           /* 0x3001 */\n  mFI_FIELD_ROOM_BROKER_SHOP,     /* 0x3002 */\n  mFI_FIELD_ROOM_POST_OFFICE,     /* 0x3003 */\n  mFI_FIELD_ROOM_POLICE_BOX,      /* 0x3004 */\n  mFI_FIELD_ROOM_BUGGY,           /* 0x3005 */\n  mFI_FIELD_ROOM_SHOP1,           /* 0x3006 */\n  mFI_FIELD_ROOM_SHOP2,           /* 0x3007 */\n  mFI_FIELD_ROOM_SHOP3_1,         /* 0x3008 */\n  mFI_FIELD_ROOM_SHOP3_2,         /* 0x3009 */\n  mFI_FIELD_ROOM_KAMAKURA,        /* 0x300A */\n  mFI_FIELD_ROOM_MUSEUM_ENTRANCE, /* 0x300B */\n  mFI_FIELD_ROOM_MUSEUM_PAINTING, /* 0x300C */\n  mFI_FIELD_ROOM_MUSEUM_FOSSIL,   /* 0x300D */\n  mFI_FIELD_ROOM_MUSEUM_INSECT,   /* 0x300E */\n  mFI_FIELD_ROOM_MUSEUM_FISH,     /* 0x300F */\n  mFI_FIELD_ROOM_NEEDLEWORK,      /* 0x3010 */\n  mFI_FIELD_ROOM_LIGHTHOUSE,      /* 0x3011 */\n  mFI_FIELD_ROOM_TENT,            /* 0x3012 */\n\n  mFI_FIELD_NPCROOM0 = mFI_TO_FIELD_ID(mFI_FIELDTYPE_NPC_ROOM, 0),\n  mFI_FIELD_NPCROOM_FIELD_TOOL_INSIDE,\n\n  mFI_FIELD_DEMO_STARTDEMO = mFI_TO_FIELD_ID(mFI_FIELDTYPE_DEMO, 0),\n  mFI_FIELD_DEMO_STARTDEMO2,\n  mFI_FIELD_DEMO_PLAYERSELECT,\n  mFI_FIELD_DEMO_STARTDEMO3,\n\n  mFI_FIELD_PLAYER0_ROOM = mFI_TO_FIELD_ID(mFI_FIELDTYPE_PLAYER_ROOM, 0),\n  mFI_FIELD_PLAYER1_ROOM,\n  mFI_FIELD_PLAYER2_ROOM,\n  mFI_FIELD_PLAYER3_ROOM,\n\n  /* TODO: others */\n};\n\n#define mFI_GET_PLAYER_ROOM_NO(field_id) (((field_id)-mFI_FIELD_PLAYER0_ROOM) & 3)\n#define mFI_IS_PLAYER_ROOM(field_id) \\\n  ((field_id) == mFI_FIELD_PLAYER0_ROOM || (field_id) == mFI_FIELD_PLAYER1_ROOM || \\\n   (field_id) == mFI_FIELD_PLAYER2_ROOM || (field_id) == mFI_FIELD_PLAYER3_ROOM)\n\nextern int mEv_CheckFirstJob();\nextern int mEv_CheckArbeit();\nextern int mEv_CheckTitleDemo();\n\nextern int mEv_weekday2day(lbRTC_month_t month, int week_type, lbRTC_weekday_t weekday);\n\nextern const lbRTC_time_c mTM_rtcTime_clear_code;\nextern const lbRTC_ymd_c mTM_rtcTime_ymd_clear_code;\nextern const lbRTC_time_c mTM_rtcTime_default_code;\n\n#define mTM_IsTimeEqual(t0, t1) (lbRTC_IsEqualTime((t0), (t1), lbRTC_CHECK_ALL) == TRUE)\n#define mTM_IsTimeCleared(time) (lbRTC_IsEqualTime((time), &mTM_rtcTime_clear_code, lbRTC_CHECK_ALL) == TRUE)\n#define mTM_FIELD_RENEW_HOUR 6 /* hour which daily things 'reset' */\n\n#define CHAR_SPACE 32\nenum RTC_EQUALITY_FLAGS {\n  lbRTC_CHECK_NONE = 0,           /* 0x00 */\n\n  lbRTC_CHECK_SECONDS = 1 << 0,   /* 0x01 */\n  lbRTC_CHECK_MINUTES = 1 << 1,   /* 0x02 */\n  lbRTC_CHECK_HOURS = 1 << 2,     /* 0x04 */\n  lbRTC_CHECK_WEEKDAYS = 1 << 3,  /* 0x08 */\n  lbRTC_CHECK_DAYS = 1 << 4,      /* 0x10 */\n  lbRTC_CHECK_MONTHS = 1 << 5,    /* 0x20 */\n  lbRTC_CHECK_YEARS = 1 << 6,     /* 0x40 */\n\n  /* 0x7F */\n  lbRTC_CHECK_ALL = lbRTC_CHECK_SECONDS |\n                    lbRTC_CHECK_MINUTES |\n                    lbRTC_CHECK_HOURS |\n                    lbRTC_CHECK_WEEKDAYS |\n                    lbRTC_CHECK_DAYS |\n                    lbRTC_CHECK_MONTHS |\n                    lbRTC_CHECK_YEARS\n};\n\n#define mIN_ITEM_NAME_LEN 16\n\nextern void mIN_copy_name_str(u8* str, mActor_name_t item_no);\nextern int mIN_get_item_article(mActor_name_t item_no);\n\n#define mHandbill_HEADER_LEN MAIL_HEADER_LEN\n#define mHandbill_FOOTER_LEN MAIL_FOOTER_LEN\n#define mHandbill_BODY_LEN MAIL_BODY_LEN\n\nextern void mHandbill_Set_free_str(int free_str_no, u8* str, int str_len);\nextern void mHandbill_Set_free_str_art(int free_str_no, u8* str, int str_len, int article_no);\n\n/* item list groups */\nenum {\n  mSP_LIST_A,                 /* A priority list */\n  mSP_LIST_B,                 /* B priority list */\n  mSP_LIST_C,                 /* C priority list */\n  mSP_LIST_EVENT,             /* event list */\n  mSP_LIST_TRAIN,             /*  */\n  mSP_LIST_LOTTERY,           /* lottery list */\n  mSP_LIST_HALLOWEEN,         /* halloween theme list */\n  mSP_LIST_PRESENT,           /*  */\n  mSP_LIST_CHRISTMAS,\n  mSP_LIST_SNOW,\n  mSP_LIST_HALLOWEEN2,\n  mSP_LIST_JONASON,\n  mSP_LIST_POSTOFFICE,\n  mSP_LIST_NINTENDO64,\n  mSP_LIST_SPECIALPRESENT,\n  mSP_LIST_ISLAND,\n  mSP_LIST_HOMEPAGE,\n  mSP_LIST_EVENTPRESENTCHUMON,\n  mSP_LIST_KAMAKURA,\n  mSP_LIST_ISLANDFAMICOM,\n  mSP_LIST_HARVEST,\n  mSP_LIST_MARIO,\n  mSP_LIST_TENT,\n\n  mSP_LIST_NUM\n};\n\n/* item List types */\nenum {\n  mSP_LISTTYPE_COMMON,            /* common ABC priority list */\n  mSP_LISTTYPE_UNCOMMON,          /* uncommon ABC priority list */\n  mSP_LISTTYPE_RARE,              /* rare ABC priority list */\n  mSP_LISTTYPE_EVENT,             /* event list */\n  mSP_LISTTYPE_TRAIN,             /*  */\n  mSP_LISTTYPE_LOTTERY,           /* lottery list */\n  mSP_LISTTYPE_HALLOWEEN,         /* halloween theme list */\n  mSP_LISTTYPE_PRESENT,           /*  */\n  mSP_LISTTYPE_ABC,               /* ABC */\n  mSP_LISTTYPE_CHRISTMAS,\n  mSP_LISTTYPE_SNOW,\n  mSP_LISTTYPE_HALLOWEEN2,\n  mSP_LISTTYPE_JONASON,\n  mSP_LISTTYPE_POSTOFFICE,\n  mSP_LISTTYPE_NINTENDO64,\n  mSP_LISTTYPE_SPECIALPRESENT,\n  mSP_LISTTYPE_ISLAND,\n  mSP_LISTTYPE_HOMEPAGE,\n  mSP_LISTTYPE_EVENTPRESENTCHUMON,\n  mSP_LISTTYPE_KAMAKURA,\n  mSP_LISTTYPE_ISLANDFAMICOM,\n  mSP_LISTTYPE_HARVEST,\n  mSP_LISTTYPE_MARIO,\n  mSP_LISTTYPE_TENT,\n\n  mSP_LISTTYPE_NUM\n};\n\n/* item list kinds */\nenum {\n  mSP_KIND_FURNITURE,\n  mSP_KIND_PAPER,\n  mSP_KIND_CLOTH,\n  mSP_KIND_CARPET,\n  mSP_KIND_WALLPAPER,\n  mSP_KIND_DIARY,\n\n  mSP_KIND_MAX = mSP_KIND_DIARY,\n  mSP_KIND_EXTENDED_MAX /* includes diary */\n};\n\nextern int mString_Load_MonthStringFromRom(u8* buf, lbRTC_month_t month);\nextern int mString_Load_DayStringFromRom(u8* buf, lbRTC_day_t day);\n\nenum background_attribute {\n  /* TODO: finish */\n  mCoBG_ATTRIBUTE_GRASS0,\n  mCoBG_ATTRIBUTE_GRASS1,\n  mCoBG_ATTRIBUTE_GRASS2,\n  mCoBG_ATTRIBUTE_GRASS3,\n  mCoBG_ATTRIBUTE_SOIL0,\n  mCoBG_ATTRIBUTE_SOIL1,\n  mCoBG_ATTRIBUTE_SOIL2,\n  mCoBG_ATTRIBUTE_STONE,\n  mCoBG_ATTRIBUTE_FLOOR,\n  mCoBG_ATTRIBUTE_BUSH,\n  mCoBG_ATTRIBUTE_HOLE,\n  mCoBG_ATTRIBUTE_WAVE,\n  mCoBG_ATTRIBUTE_WATER,\n  mCoBG_ATTRIBUTE_WATERFALL,\n  mCoBG_ATTRIBUTE_RIVER_N,\n  mCoBG_ATTRIBUTE_RIVER_NW,\n  mCoBG_ATTRIBUTE_RIVER_W,\n  mCoBG_ATTRIBUTE_RIVER_SW,\n  mCoBG_ATTRIBUTE_RIVER_S,\n  mCoBG_ATTRIBUTE_RIVER_SE,\n  mCoBG_ATTRIBUTE_RIVER_E,\n  mCoBG_ATTRIBUTE_RIVER_NE,\n  mCoBG_ATTRIBUTE_SAND,\n  mCoBG_ATTRIBUTE_WOOD,\n  mCoBG_ATTRIBUTE_SEA,\n  // ...\n};\n\nenum {\n  mCoBG_PLANT0 = 0, /* Stay a sapling */\n  mCoBG_PLANT1 = 1, /* Grow until the first stage of growth */\n  mCoBG_PLANT2 = 2, /* Grow until the second stage of growth */\n  mCoBG_PLANT3 = 3, /* Grow until the third stage of growth */\n  mCoBG_PLANT4 = 4, /* Fully grow */\n\n  mCoBG_KILL_PLANT = 7 /* No growth, all plants die on this unit  */\n};\n\nenum field_layer {\n  mCoBG_LAYER0,\n  mCoBG_LAYER1,\n  mCoBG_LAYER2,\n  mCoBG_LAYER3,\n\n  mCoBG_LAYER_NUM\n};\n\nextern u32 mCoBG_Wpos2BgAttribute_Original(xyz_t wpos);\nextern u32 mCoBG_Wpos2Attribute(xyz_t wpos, s8* is_diggable);\nextern int mCoBG_CheckWaterAttribute(u32 attribute);\nextern f32 mCoBG_GetBgY_AngleS_FromWpos(s_xyz* angle_to_ground, xyz_t wpos, f32 offset);\nextern int mCoBG_CheckWaterAttribute_OutOfSea(u32 attribute);\n\nextern f32 mCoBG_GetWaterHeight_File(xyz_t wpos, char* file, int line);\n#define mCoBG_GetWaterHeight(wpos) mCoBG_GetWaterHeight_File(wpos, __FILE__, __LINE__)\n\nextern int mCoBG_CheckSandUt_ForFish(xyz_t* wpos);\n\n/* acre unit world size */\n#define mFI_UT_WORLDSIZE_X 40\n#define mFI_UT_WORLDSIZE_Z 40\n\n#define mFI_UT_WORLDSIZE_X_F ((f32)mFI_UT_WORLDSIZE_X)\n#define mFI_UT_WORLDSIZE_Z_F ((f32)mFI_UT_WORLDSIZE_Z)\n\n#define mFI_ROW_TO_CHARSTR(row) ((row) + 'A')\n#define mFI_COL_TO_CHARSTR(col) ((col) + '0')\n\nextern mCoBG_Collision_u* mFI_GetBkNum2ColTop(int block_x, int block_z);\nextern u32 mFI_BkNum2BlockKind(int block_x, int block_z);\nextern mActor_name_t* mFI_BkNumtoUtFGTop(int block_x, int block_z);\nextern u16* mFI_GetDepositP(int block_x, int block_z);\n\nf32 fqrand();\n\n#define mRF_BLOCKKIND_NONE (0 << 0)\n#define mRF_BLOCKKIND_PLAYER (1 << 0)\n#define mRF_BLOCKKIND_SHOP (1 << 1)\n#define mRF_BLOCKKIND_SHRINE (1 << 2)\n#define mRF_BLOCKKIND_POLICE (1 << 3)\n#define mRF_BLOCKKIND_POSTOFFICE (1 << 4)\n#define mRF_BLOCKKIND_STATION (1 << 5)\n#define mRF_BLOCKKIND_CLIFF (1 << 6)\n#define mRF_BLOCKKIND_RIVER (1 << 7)\n#define mRF_BLOCKKIND_WATERFALL (1 << 8)\n#define mRF_BLOCKKIND_BRIDGE (1 << 9)\n#define mRF_BLOCKKIND_RAILROAD (1 << 10)\n#define mRF_BLOCKKIND_MARINE (1 << 11)\n#define mRF_BLOCKKIND_BORDER (1 << 12)\n#define mRF_BLOCKKIND_TUNNEL (1 << 13)\n#define mRF_BLOCKKIND_SLOPE (1 << 14)\n#define mRF_BLOCKKIND_POOL (1 << 15)\n#define mRF_BLOCKKIND_DUMP (1 << 16)\n#define mRF_BLOCKKIND_MUSEUM (1 << 17)\n#define mRF_BLOCKKIND_18 (1 << 18)\n#define mRF_BLOCKKIND_TAILORS (1 << 19)\n#define mRF_BLOCKKIND_OCEAN (1 << 20)\n#define mRF_BLOCKKIND_ISLAND (1 << 21)\n#define mRF_BLOCKKIND_OFFING (1 << 22)\n#define mRF_BLOCKKIND_23 (1 << 23)\n#define mRF_BLOCKKIND_24 (1 << 24)\n#define mRF_BLOCKKIND_25 (1 << 25)\n#define mRF_BLOCKKIND_26 (1 << 26)\n#define mRF_BLOCKKIND_27 (1 << 27)\n#define mRF_BLOCKKIND_28 (1 << 28)\n#define mRF_BLOCKKIND_29 (1 << 29)\n#define mRF_BLOCKKIND_DOCK (1 << 30)\n#define mRF_BLOCKKIND_ISLAND_LEFT (1 << 31)\n\n#define lbRTC_TIME_TO_U32(t) ((u32)(((t)->year << 16) + ((t)->month << 8) + (t)->day))\n\n#define mNtc_TO_MONTHDAY(mo, day) ((u16)((((mo) & 0xFF) << 8) | ((day) & 0xFF)))\n#define mNtc_GET_MONTH(monthday) (((monthday) >> 8) & 0xFF)\n#define mNtc_GET_DAY(monthday) ((monthday) & 0xFF)\n\n#define mNtc_FISHING_DAY_YEAR 0xFFFF\n#define mNtc_FISHING_DAY_NUM 0xFF\n\n#define mNtc_MIN_DAYS_BETWEEN_TREASURE 3\n#define mNtc_TREASURE_CHANCE 0.4f /* 40% chance when possible */\n\n#define mNtc_NWRITE_NUM 5\n\n#define mNtc_DATA_LIST_NUM 43\n\n#define mNtc_UNUSED_MONTH 0xFF\n#define mNtc_UNUSED_DAY 0xFF\n\n/* sizeof(mNtc_date_c) == 2 */\ntypedef struct notice_date_s {\n  /* 0x00 */ lbRTC_month_t month;\n  /* 0x01 */ lbRTC_day_t day;\n} mNtc_date_c;\n\n/* sizeof() == 2 */\ntypedef union {\n  mNtc_date_c date;\n  u16 month_day;\n} mNtc_date_u;\n\n/* sizeof(mNtc_date_data_c) == 4 */\ntypedef struct notice_date_data_s {\n  /* 0x00 */ u16 id;\n  /* 0x02 */ mNtc_date_u date;\n} mNtc_date_data_c;\n\nstatic mNtc_date_data_c mNtc_auto_nwrite_data[48];\n\nenum RTC_EQUALITY {\n  lbRTC_LESS = -1,\n  lbRTC_EQUAL = 0,\n  lbRTC_OVER = 1\n};\n\nextern OSTime lbRTC_HardTime();\nextern int lbRTC_IsAbnormal();\nextern void lbRTC_Sampling();\nextern void lbRTC_SetTime(lbRTC_time_c* time);\nextern void lbRTC_GetTime(lbRTC_time_c* time);\nextern lbRTC_day_t lbRTC_GetDaysByMonth(lbRTC_year_t year, lbRTC_month_t month);\nextern int lbRTC_IsEqualDate(\n  lbRTC_year_t y0, lbRTC_month_t m0, lbRTC_day_t d0,\n  lbRTC_year_t y1, lbRTC_month_t m1, lbRTC_day_t d1\n);\nextern int lbRTC_IsEqualTime(const lbRTC_time_c* t0, const lbRTC_time_c* t1, int flags);\nextern int lbRTC_IsOverTime(const lbRTC_time_c* t0, const lbRTC_time_c* t1);\n// extern int lbRTC_IsJustAtRTC(const lbRTC_time_c* time, int check_flags);\nextern int lbRTC_IsOverRTC(const lbRTC_time_c* time);\nextern int lbRTC_IntervalTime(const lbRTC_time_c* time0, const lbRTC_time_c* time1);\nextern int lbRTC_GetIntervalDays(const lbRTC_time_c* t0, const lbRTC_time_c* t1);\nextern int lbRTC_GetIntervalDays2(const lbRTC_ymd_c* ymd0, const lbRTC_ymd_c* ymd1);\nextern void lbRTC_Add_YY(lbRTC_time_c* time, int year);\nextern void lbRTC_Add_MM(lbRTC_time_c* time, int month);\nextern void lbRTC_Add_DD(lbRTC_time_c* time, int day);\nextern void lbRTC_Add_hh(lbRTC_time_c* time, int hour);\nextern void lbRTC_Add_mm(lbRTC_time_c* time, int min);\nextern void lbRTC_Add_ss(lbRTC_time_c* time, int sec);\nextern void lbRTC_Add_Date(lbRTC_time_c* time, const lbRTC_time_c* add_time);\nextern void lbRTC_Sub_YY(lbRTC_time_c* time, int year);\nextern void lbRTC_Sub_MM(lbRTC_time_c* time, int month);\nextern void lbRTC_Sub_DD(lbRTC_time_c* time, int days);\nextern void lbRTC_Sub_hh(lbRTC_time_c* time, int hour);\nextern void lbRTC_Sub_mm(lbRTC_time_c* time, int min);\nextern void lbRTC_Sub_ss(lbRTC_time_c* time, int sec);\n// extern void lbRTC_Sub_Date(lbRTC_time_c* time, const lbRTC_time_c* sub_time)\nextern lbRTC_weekday_t lbRTC_Week(lbRTC_year_t year, lbRTC_month_t month, lbRTC_day_t day);\nextern void lbRTC_TimeCopy(lbRTC_time_c* dst, const lbRTC_time_c* src);\nextern int lbRTC_IsValidTime(const lbRTC_time_c* time);\nextern int lbRTC_time_c_save_data_check(const lbRTC_time_c* time);\nextern int lbRTC_Weekly_day(lbRTC_year_t year, lbRTC_month_t month, int weeks, int weekday);\n\n#define lbRTC_HOURS_PER_DAY 24\n#define lbRTC_MINUTES_PER_HOUR 60\n#define lbRTC_SECONDS_PER_MINUTE 60\n\n#define lbRTC_IS_LEAPYEAR(year) \\\n  (((year % 4) == 0 && ((year % 100) != 0)) || ((year % 400) == 0))\n\n\n#define GFXPRINT_NUM_SUBPIXELS 4\n#define GFXPRINT_PIXELS_PER_BLOCK 8\n#define GFXPRINT_PAD GFXPRINT_PIXELS_PER_BLOCK * GFXPRINT_NUM_SUBPIXELS\n\n#define GFXPRINT_FLAG_KANA_MODE (1 << 0) /* Japanese characters displayed as hiragana or katakana */\n#define GFXPRINT_FLAG_GRADIENT (1 << 1) /* Gradient state */\n#define GFXPRINT_FLAG_SHADOW (1 << 2) /* Shadow state */\n#define GFXPRINT_FLAG_CHANGED (1 << 3) /* Text changed */\n/* Unused...? */\n#define GFXPRINT_FLAG_HIGHRES (1 << 6) /* Highres text */\n#define GFXPRINT_FLAG_OPENED (1 << 7) /* Open state */\n\n#define GFXPRINT_KANA_MODE_KATAKANA 0\n#define GFXPRINT_KANA_MODE_HIRAGANA 1\n\n#define GFXPRINT_CLEAR_GRADIENT_CHAR \"\\x8A\"\n#define GFXPRINT_ENABLE_GRADIENT_CHAR \"\\x8B\"\n\n#define GFXPRINT_KATAKANA_MODE_CHAR \"\\x8C\"\n#define GFXPRINT_HIRAGANA_MODE_CHAR \"\\x8D\"\n\n/* NOTE: this should be a void return type but we're going to use a void* for readibility */\ntypedef void* (*PrintCallback)(void*, const char*, int);\ntypedef struct gfxprint_obj  {\n    PrintCallback prout_func; /* Current print out func */\n    Gfx* glistp; /* Current display list to write text to */\n    u16 position_x; /* Display coords (sub-pixel units) */\n    u16 position_y; /* Display coords (sub-pixel units) */\n    u16 offset_x; /* Display offset */\n    u8 offset_y; /* Display offset */\n    u8 flags; /* 1: Kana mode -> 0: Katakana/1: Hiragana\n                 2: Gradient displayed\n                 4: Shadow displayed\n                 8: Attribute changed\n                 64: Low-res -> high-res conversion\n                 128: Opened state */\n    rgba8888 color; /* Current font color */\n    u8 dummy[28]; /* For size compatibility */\n} gfxprint_t;\n\n/* Default gfxprint flag values set in game_ct func, default value is 0x40 (GFXPRINT_FLAG_HIGHRES on) */\nextern u8 __gfxprint_default_flags;\n\nextern u16 gfxprint_moji_tlut[];\nextern u8 gfxprint_font[];\n\n/* Macros for quickly checking state of gfxprint struct */\n#define gfxprint_isFlagOn(this, flag) ((this->flags & flag) != 0)\n#define gfxprint_setFlag(this, flag) (this->flags |= flag)\n#define gfxprint_clrFlag(this, flag) (this->flags &= ~flag)\n\n#define gfxprint_isOpened(this) (gfxprint_isFlagOn(this, GFXPRINT_FLAG_OPENED))\n#define gfxprint_setOpened(this) (gfxprint_setFlag(this, GFXPRINT_FLAG_OPENED))\n#define gfxprint_clrOpened(this) (gfxprint_clrFlag(this, GFXPRINT_FLAG_OPENED))\n\n#define gfxprint_isHighres(this) (gfxprint_isFlagOn(this, GFXPRINT_FLAG_HIGHRES))\n#define gfxprint_setHighres(this) (gfxprint_setFlag(this, GFXPRINT_FLAG_HIGHRES))\n#define gfxprint_clrHighres(this) (gfxprint_clrFlag(this, GFXPRINT_FLAG_HIGHRES))\n\n#define gfxprint_isHiragana(this) ((this->flags & GFXPRINT_FLAG_KANA_MODE) != GFXPRINT_KANA_MODE_KATAKANA)\n#define gfxprint_isKatakana(this) ((this->flags & GFXPRINT_FLAG_KANA_MODE) == GFXPRINT_KANA_MODE_KATAKANA)\n#define gfxprint_setHiragana(this) (this->flags |= GFXPRINT_FLAG_KANA_MODE)\n#define gfxprint_setKatakana(this) (this->flags &= ~GFXPRINT_FLAG_KANA_MODE)\n\n#define gfxprint_isGradient(this) (gfxprint_isFlagOn(this, GFXPRINT_FLAG_GRADIENT))\n#define gfxprint_setGradient(this) (gfxprint_setFlag(this, GFXPRINT_FLAG_GRADIENT))\n#define gfxprint_clrGradient(this) (gfxprint_clrFlag(this, GFXPRINT_FLAG_GRADIENT))\n\n#define gfxprint_isShadow(this) (gfxprint_isFlagOn(this, GFXPRINT_FLAG_SHADOW))\n#define gfxprint_setShadow(this) (gfxprint_setFlag(this, GFXPRINT_FLAG_SHADOW))\n#define gfxprint_clrShadow(this) (gfxprint_clrFlag(this, GFXPRINT_FLAG_SHADOW))\n\n#define gfxprint_isChanged(this) (gfxprint_isFlagOn(this, GFXPRINT_FLAG_CHANGED))\n#define gfxprint_setChanged(this) (gfxprint_setFlag(this, GFXPRINT_FLAG_CHANGED))\n#define gfxprint_clrChanged(this) (gfxprint_clrFlag(this, GFXPRINT_FLAG_CHANGED))\n\nstatic void gfxprint_setup(gfxprint_t* gfxprint);\nstatic void gfxprint_putc1(gfxprint_t* gfxprint, char c);\nstatic void* gfxprint_prout(void* gfxprint, const char* buffer, int n);\n\nextern void gfxprint_color(gfxprint_t* gfxprint, u32 r, u32 g, u32 b, u32 a);\n\nextern void gfxprint_locate(gfxprint_t* gfxprint, int x, int y); \nextern void gfxprint_locate8x8(gfxprint_t*gfxprint, int x, int y);\nextern void gfxprint_setoffset(gfxprint_t* gfxprint, int x, int y);\n\nextern void gfxprint_putc(gfxprint_t* gfxprint, char c);\nextern void gfxprint_write(gfxprint_t* gfxprint, const void* buffer, size_t size, size_t n);\nextern void gfxprint_puts(gfxprint_t* gfxprint, char* string);\n\nextern void gfxprint_init(gfxprint_t* gfxprint);\nextern void gfxprint_cleanup(gfxprint_t* gfxprint);\n\nextern void gfxprint_open(gfxprint_t* gfxprint, Gfx* glistp);\nextern Gfx* gfxprint_close(gfxprint_t* gfxprint);\n\nextern int gfxprint_printf(gfxprint_t* gfxprint, const char* fmt, ...);\n\n#define mEv_STATUS_ACTIVE     (1 << 0) /* event is active */\n#define mEv_STATUS_STOP       (1 << 1) /* event is stopped */\n#define mEv_STATUS_SHOW       (1 << 2) /* event is shown */\n#define mEv_STATUS_PLAYSOUND  (1 << 3) /* event should play sound */\n#define mEv_STATUS_RUN        (1 << 4) /* event should run */\n#define mEv_STATUS_ERROR      (1 << 5) /* event is in error state */\n#define mEv_STATUS_TALK       (1 << 6) /* event requires talking to player */\n\nextern int mEv_check_status(int event, s16 status);\n\nenum week_type {\n  mEv_WEEKTYPE_NONE,\n  mEv_WEEKTYPE_1ST,\n  mEv_WEEKTYPE_2ND,\n  mEv_WEEKTYPE_3RD,\n  mEv_WEEKTYPE_4TH,\n  mEv_WEEKTYPE_5TH,\n  mEv_WEEKTYPE_LAST,\n  mEv_WEEKTYPE_SPECIAL\n};\n\nenum event_table {\n  mEv_EVENT_RUMOR_NEW_YEARS_DAY,\n  mEv_EVENT_NEW_YEARS_DAY,\n  mEv_EVENT_RUMOR_KAMAKURA,\n  mEv_EVENT_KAMAKURA,\n  mEv_EVENT_SONCHO_VACATION_JANUARY,\n  mEv_EVENT_SONCHO_VACATION_FEBRUARY,\n  mEv_EVENT_RUMOR_GROUNDHOG_DAY,\n  mEv_EVENT_GROUNDHOG_DAY,\n  mEv_EVENT_RUMOR_VALENTINES_DAY,\n  mEv_EVENT_VALENTINES_DAY,\n  mEv_EVENT_RUMOR_SPRING_SPORTS_FAIR,\n  mEv_EVENT_SPRING_EQUINOX,\n  mEv_EVENT_SPORTS_FAIR_BALL_TOSS,\n  mEv_EVENT_SPORTS_FAIR_AEROBICS,\n  mEv_EVENT_SPORTS_FAIR_TUG_OF_WAR,\n  mEv_EVENT_SPORTS_FAIR_FOOT_RACE,\n  mEv_EVENT_SPORTS_FAIR,\n  mEv_EVENT_APRILFOOLS_DAY,\n  mEv_EVENT_RUMOR_APRILFOOLS_DAY,\n  mEv_EVENT_RUMOR_CHERRY_BLOSSOM_FESTIVAL,\n  mEv_EVENT_CHERRY_BLOSSOM_FESTIVAL,\n  mEv_EVENT_NATURE_DAY,\n  mEv_EVENT_SPRING_CLEANING,\n  mEv_EVENT_MOTHERS_DAY,\n  mEv_EVENT_SUMMER_CAMPER,\n  mEv_EVENT_GRADUATION_DAY,\n  mEv_EVENT_FATHERS_DAY,\n  mEv_EVENT_RUMOR_FISHING_TOURNEY_1,\n  mEv_EVENT_TALK_FISHING_TOURNEY_1, // for dialog?\n  mEv_EVENT_FISHING_TOURNEY_1,\n  mEv_EVENT_TOWN_DAY,\n  mEv_EVENT_RUMOR_FIREWORKS_SHOW,\n  mEv_EVENT_FIREWORKS_SHOW,\n  mEv_EVENT_RUMOR_MORNING_AEROBICS,\n  mEv_EVENT_TALK_MORNING_AEROBICS,\n  mEv_EVENT_MORNING_AEROBICS,\n  mEv_EVENT_RUMOR_METEOR_SHOWER,\n  mEv_EVENT_METEOR_SHOWER,\n  mEv_EVENT_FOUNDERS_DAY,\n  mEv_EVENT_LABOR_DAY,\n  mEv_EVENT_RUMOR_FALL_SPORTS_FAIR,\n  mEv_EVENT_AUTUMN_EQUINOX,\n  mEv_EVENT_HARVEST_MOON_DAY,\n  mEv_EVENT_HARVEST_MOON_FESTIVAL,\n  mEv_EVENT_EXPLORERS_DAY,\n  mEv_EVENT_RUMOR_MUSHROOM_SEASON,\n  mEv_EVENT_TALK_MUSHROOM_SEASON,\n  mEv_EVENT_MUSHROOM_SEASON,\n  mEv_EVENT_RUMOR_HALLOWEEN,\n  mEv_EVENT_HALLOWEEN,\n  mEv_EVENT_MAYORS_DAY,\n  mEv_EVENT_OFFICERS_DAY,\n  mEv_EVENT_RUMOR_FISHING_TOURNEY_2,\n  mEv_EVENT_TALK_FISHING_TOURNEY_2,\n  mEv_EVENT_FISHING_TOURNEY_2,\n  mEv_EVENT_RUMOR_HARVEST_FESTIVAL,\n  mEv_EVENT_HARVEST_FESTIVAL,\n  mEv_EVENT_SALE_DAY,\n  mEv_EVENT_SNOW_DAY,\n  mEv_EVENT_TOY_DAY_SONCHO,\n  mEv_EVENT_RUMOR_TOY_DAY,\n  mEv_EVENT_TOY_DAY_JINGLE,\n  mEv_EVENT_SNOWMAN_SEASON,\n  mEv_EVENT_RUMOR_NEW_YEARS_EVE_COUNTDOWN,\n  mEv_EVENT_NEW_YEARS_EVE_COUNTDOWN,\n  mEv_EVENT_CHERRY_BLOSSOM_PETALS,\n  mEv_EVENT_TALK_TOY_DAY,\n  \n  mEv_EVENT_PLAYER_BIRTHDAY,\n  \n  mEv_EVENT_DOZAEMON,\n  mEv_EVENT_KABU_PEDDLER,\n  mEv_EVENT_LOTTERY,\n  mEv_EVENT_KK_SLIDER,\n  \n  mEv_EVENT_HANDBILL_BROKER,\n  mEv_EVENT_HANDBILL_SHOP_SALE,\n  \n  mEv_EVENT_ARTIST,\n  mEv_EVENT_BROKER_SALE,\n  mEv_EVENT_DESIGNER,\n  mEv_EVENT_GYPSY,\n  mEv_EVENT_SHOP_SALE,\n  mEv_EVENT_CARPET_PEDDLER,\n\n  mEv_EVENT_SONCHO_NEW_YEARS_DAY,\n  mEv_EVENT_SONCHO_GROUNDHOG_DAY,\n  mEv_EVENT_SONCHO_SPRING_SPORTS_FAIR,\n  mEv_EVENT_SONCHO_APRILFOOLS_DAY,\n  mEv_EVENT_SONCHO_CHERRY_BLOSSOM_FESTIVAL,\n  mEv_EVENT_SONCHO_NATURE_DAY,\n  mEv_EVENT_SONCHO_SPRING_CLEANING,\n  mEv_EVENT_SONCHO_MOTHERS_DAY,\n  mEv_EVENT_SONCHO_GRADUATION_DAY,\n  mEv_EVENT_SONCHO_FATHERS_DAY,\n  mEv_EVENT_SONCHO_FISHING_TOURNEY_1,\n  mEv_EVENT_SONCHO_TOWN_DAY,\n  mEv_EVENT_SONCHO_FIREWORKS_SHOW,\n  mEv_EVENT_SONCHO_METEOR_SHOWER,\n  mEv_EVENT_SONCHO_FOUNDERS_DAY,\n  mEv_EVENT_SONCHO_LABOR_DAY,\n  mEv_EVENT_SONCHO_FALL_SPORTS_FAIR,\n  mEv_EVENT_SONCHO_HARVEST_MOON_FESTIVAL,\n  mEv_EVENT_SONCHO_EXPLORERS_DAY,\n  mEv_EVENT_SONCHO_HALLOWEEN,\n  mEv_EVENT_SONCHO_MAYORS_DAY,\n  mEv_EVENT_SONCHO_OFFICERS_DAY,\n  mEv_EVENT_SONCHO_FISHING_TOURNEY_2,\n  mEv_EVENT_SONCHO_HARVEST_FESTIVAL,\n  mEv_EVENT_SONCHO_SALE_DAY,\n  mEv_EVENT_SONCHO_SNOW_DAY,\n  mEv_EVENT_SONCHO_TOY_DAY,\n\n  mEv_EVENT_TALK_NEW_YEARS_COUNTDOWN,\n  mEv_EVENT_HARVEST_FESTIVAL_FRANKLIN,\n\n  mEv_EVENT_WEATHER_CLEAR,\n  mEv_EVENT_WEATHER_SNOW,\n  mEv_EVENT_WEATHER_SPORTS_FAIR,\n\n  mEv_EVENT_BRIDGE_MAKE,\n  mEv_EVENT_SONCHO_BRIDGE_MAKE,\n\n  mEv_EVENT_GHOST,\n  mEv_EVENT_MASK_CAT,\n\n  mEv_EVENT_74, // unused?\n\n  mEv_EVENT_KOINOBORI,\n\n  mEv_EVENT_76, // unused?\n\n  mEv_EVENT_NUM\n};\n\n#define mEv_STATUS_ACTIVE     (1 << 0) /* event is active */\n#define mEv_STATUS_STOP       (1 << 1) /* event is stopped */\n#define mEv_STATUS_SHOW       (1 << 2) /* event is shown */\n#define mEv_STATUS_PLAYSOUND  (1 << 3) /* event should play sound */\n#define mEv_STATUS_RUN        (1 << 4) /* event should run */\n#define mEv_STATUS_ERROR      (1 << 5) /* event is in error state */\n#define mEv_STATUS_TALK       (1 << 6) /* event requires talking to player */\n\n#define mEv_GHOST_HITODAMA_NUM 5\ntypedef struct ghost_spirit_block_data_s {\n  u8 block_x[mEv_GHOST_HITODAMA_NUM];\n  u8 block_z[mEv_GHOST_HITODAMA_NUM];\n} mEv_gst_hitodama_block_c;\n\n#define mEv_GHOST_FLAG_ACTIVE 0x4000 // TODO: do these live in the ghost actor itself?\ntypedef struct ghost_common_s {\n  mEv_gst_hitodama_block_c hitodama_block_data;\n  u16 flags;\n  u8 _0C[0x2C - 0x0C];\n} mEv_gst_common_c;\n\n#define mEv_DESGINER_NUM 3\n\ntypedef struct kabu_peddler_event_s {\n  PersonalID_c spoken_pids[TOTAL_PLAYER_NUM];\n} mEv_kabu_peddler_c;\n\ntypedef struct dozaemon_event_s {\n  u32 flags;\n} mEv_dozaemon_c;\n\ntypedef union {\n  mEv_kabu_peddler_c kabu_peddler;\n  mEv_dozaemon_c dozaemon;\n} mEv_weekly_u;\n\ntypedef struct bargin_event_s {\n  lbRTC_time_c start_time;\n  lbRTC_time_c end_time;\n  mActor_name_t items[5];\n  int kind;\n} mEv_bargin_c;\n\ntypedef struct designer_event_s {\n  PersonalID_c pids[mEv_DESGINER_NUM];\n  int used;\n  mActor_name_t gifted_cloths[mEv_DESGINER_NUM];\n} mEv_designer_c;\n\ntypedef struct broker_event_s {\n  PersonalID_c pid[2];\n  lbRTC_time_c end_time;\n  int used;\n  mActor_name_t sold_items[2];\n  mActor_name_t items[3];\n} mEv_broker_c;\n\ntypedef struct artist_event_s {\n  PersonalID_c pids[2];\n  int used;\n  mActor_name_t walls[2];\n} mEv_artist_c;\n\ntypedef struct arabian_event_s {\n  int used;\n  mActor_name_t carpet;\n} mEv_arabian_c;\n\ntypedef struct gypsy_event_s {\n  int _00;\n  int block_z;\n  int block_x;\n  int ut_z;\n  int ut_x;\n} mEv_gypsy_c;\n\ntypedef union {\n  mEv_bargin_c bargin;\n  mEv_designer_c designer;\n  mEv_broker_c broker;\n  mEv_artist_c artist;\n  mEv_arabian_c arabian;\n  mEv_gypsy_c gypsy;\n} mEv_special_u;\n\ntypedef struct special_event_s {\n  lbRTC_time_c scheduled;\n  u32 type;\n  mEv_special_u event;\n} mEv_special_c;\n\ntypedef struct save_event_data_s {\n  mEv_special_c special;\n  mEv_weekly_u weekly;\n  u32 flags;\n} mEv_event_save_c;\n\nextern s8* mEv_get_save_area(int type, s8 id);\n\n#define mTM_AreTimesEqual(t0, t1) (lbRTC_IsEqualTime(t0, t1, lbRTC_CHECK_ALL))\n\nenum weather {\n  mEnv_WEATHER_CLEAR,\n  mEnv_WEATHER_RAIN,\n  mEnv_WEATHER_SNOW,\n  mEnv_WEATHER_SAKURA,\n  mEnv_WEATHER_LEAVES,\n  \n  mEnv_WEATHER_NUM\n};\n\nextern int mEnv_NowWeather();\n\n\ntypedef struct actor_set_manager_s SET_MANAGER;\n\n#define aSetMgr_SET_OVERLAY_BUF_SIZE 0x4000\n#define aSetMgr_KEEP_SIZE 0x354\n\n#define aSetMgr_WAIT_TIME 5 // wait time between aSetMgr_move_check_wait -> aSetMgr_move_set\n\n#define aSetMgr_GYOEI_NUM 40\n\n/* sizeof(aSOG_gyoei_spawn_info_weight_f_c) == 8 */\ntypedef struct gyoei_spawn_info_weight_f_s {\n  /* 0x00 */ u16 type;\n  /* 0x02 */ u8 spawn_area;\n  /* 0x04 */ f32 spawn_weight;\n} aSOG_gyoei_spawn_info_weight_f_c;\n\ntypedef struct gyoei_keep_s {\n  /* 0x000 */ aSOG_gyoei_spawn_info_weight_f_c spawn_weights[aSetMgr_GYOEI_NUM];\n  /* 0x140 */ int possible_gyoei_num;\n} aSOG_gyoei_keep_c;\n\ntypedef int (*aSetMgr_ovl_proc)(SET_MANAGER*, GAME_PLAY*);\n\nenum set_overlay_type {\n  aSetMgr_OVERLAY_BEGIN = 0,\n\n  aSetMgr_OVERLAY_INSECT = aSetMgr_OVERLAY_BEGIN,\n  aSetMgr_OVERLAY_GYOEI,\n\n  aSetMgr_OVERLAY_NUM\n};\n\nenum set_manager_move_proc_type {\n  aSetMgr_MOVE_move_check_set,\n  aSetMgr_MOVE_move_check_wait,\n  aSetMgr_MOVE_move_set,\n\n  aSetMgr_MOVE_PROC_NUM\n};\n\n/* sizeof(aSetMgr_keep_c) == 0x354 */\ntypedef struct actor_set_manager_keep_s {\n  /* 0x000 */ u8 unk[aSetMgr_KEEP_SIZE - 0x210];\n  /* 0x210 */ aSOG_gyoei_keep_c gyoei_keep;\n} aSetMgr_keep_c;\n\n/* sizeof(aSetMgr_set_ovl_c) == 0x4004 */\ntypedef struct actor_set_manager_ovl_s {\n  /* 0x0000 */ u8 buf[aSetMgr_SET_OVERLAY_BUF_SIZE];\n  /* 0x4000 */ aSetMgr_ovl_proc ovl_proc;\n} aSetMgr_set_ovl_c;\n\n/* sizeof(aSetMgr_player_pos) == 0x18 */\ntypedef struct actor_set_manager_player_pos_s {\n  /* 0x00 */ int next_bx, next_bz; // TODO: there's a good chance these are structs\n  /* 0x08 */ int now_bx, now_bz;\n  /* 0x10 */ int last_bx, last_bz;\n} aSetMgr_player_pos_c;\n\n/* sizeof(SET_MANAGER) == 0x44F0 */\nstruct actor_set_manager_s {\n  /* 0x0000 */ ACTOR actor_class;\n  /* 0x0174 */ u8 move_proc;\n  /* 0x0175 */ u8 next_move_proc;\n  /* 0x0176 */ u8 set_ovl_type;\n  /* 0x0178 */ aSetMgr_set_ovl_c set_overlay;\n  /* 0x417C */ int unk_417C;\n  /* 0x4180 */ aSetMgr_player_pos_c player_pos;\n  /* 0x4198 */ aSetMgr_keep_c keep;\n  /* 0x44EC */ s16 wait_timer;\n};\n\nextern ACTOR_PROFILE Set_Manager_Profile;\n\n#define aSOG_TERM_TRANSITION_MAX_DAYS 5\n\nenum fish_spawn_area {\n  aSOG_SPAWN_AREA_POOL, /* river pool */\n  aSOG_SPAWN_AREA_WATERFALL,\n  aSOG_SPAWN_AREA_RIVER_MOUTH,\n  aSOG_SPAWN_AREA_OFFING, /* aka 'deep sea' */\n  aSOG_SPAWN_AREA_SEA,\n  aSOG_SPAWN_AREA_RIVER,\n  aSOG_SPAWN_AREA_POND,\n\n  aSOG_SPAWN_AREA_NUM\n};\n\n#define aSOG_FISH_TYPE_INVALID -1\n\n/* TODO: should we use the internal names for fish? */\nenum fish_type {\n  aSOG_FISH_TYPE_CRUCIAN_CARP,\n  aSOG_FISH_TYPE_BROOK_TROUT,\n  aSOG_FISH_TYPE_CARP,\n  aSOG_FISH_TYPE_KOI,\n  aSOG_FISH_TYPE_CATFISH,\n  aSOG_FISH_TYPE_SMALL_BASS,\n  aSOG_FISH_TYPE_BASS,\n  aSOG_FISH_TYPE_LARGE_BASS,\n  aSOG_FISH_TYPE_BLUEGILL,\n  aSOG_FISH_TYPE_GIANT_CATFISH,\n  aSOG_FISH_TYPE_GIANT_SNAKEHEAD,\n  aSOG_FISH_TYPE_BARBEL_STEED,\n  aSOG_FISH_TYPE_DACE,\n  aSOG_FISH_TYPE_PALE_CHUB,\n  aSOG_FISH_TYPE_BITTERLING,\n  aSOG_FISH_TYPE_LOACH,\n  aSOG_FISH_TYPE_POND_SMELT,\n  aSOG_FISH_TYPE_SWEETFISH,\n  aSOG_FISH_TYPE_CHERRY_SALMON,\n  aSOG_FISH_TYPE_LARGE_CHAR,\n  aSOG_FISH_TYPE_RAINBOW_TROUT,\n  aSOG_FISH_TYPE_STRINGFISH,\n  aSOG_FISH_TYPE_SALMON,\n  aSOG_FISH_TYPE_GOLDFISH,\n  aSOG_FISH_TYPE_PIRANHA,\n  aSOG_FISH_TYPE_AROWANA,\n  aSOG_FISH_TYPE_EEL,\n  aSOG_FISH_TYPE_FRESHWATER_GOBY,\n  aSOG_FISH_TYPE_ANGELFISH,\n  aSOG_FISH_TYPE_GUPPY,\n  aSOG_FISH_TYPE_POPEYED_GOLDFISH,\n  aSOG_FISH_TYPE_COELACANTH,\n  aSOG_FISH_TYPE_CRAWFISH,\n  aSOG_FISH_TYPE_FROG,\n  aSOG_FISH_TYPE_KILLIFISH,\n  aSOG_FISH_TYPE_JELLYFISH,\n  aSOG_FISH_TYPE_SEA_BASS,\n  aSOG_FISH_TYPE_RED_SNAPPER,\n  aSOG_FISH_TYPE_BARRED_KNIFEJAW,\n  aSOG_FISH_TYPE_ARAPAIMA,\n\n  aSOG_FISH_TYPE_NUM,\n  \n  /* non-fish fish */\n  aSOG_FISH_TYPE_WHALE = aSOG_FISH_TYPE_NUM,\n  aSOG_FISH_TYPE_EMPTY_CAN,\n  aSOG_FISH_TYPE_BOOT,\n  aSOG_FISH_TYPE_OLD_TIRE,\n  aSOG_FISH_TYPE_SALMON2,\n\n  aSOG_FISH_TYPE_EXTENDED_NUM\n};\n\n#define aSOG_TIME_NO_0_END 4      /* 9pm-3:59am */\n#define aSOG_TIME_NO_1_END 9      /* 4am-8:59am */\n#define aSOG_TIME_NO_2_END 12 + 4 /* 9am-3:59pm */\n#define aSOG_TIME_NO_3_END 12 + 9 /* 4pm-8:59pm */\n\n/* number of terms in a given month */\nenum fish_term {\n  aSOG_TERM_0,\n  aSOG_TERM1,\n\n  aSOG_TERM_NUM\n};\n\nenum time_no {\n  aSOG_TIME_0,\n  aSOG_TIME_1,\n  aSOG_TIME_2,\n  aSOG_TIME_3,\n\n  aSOG_TIME_NUM\n};\n\nenum range_proc {\n  aSOG_RANGE_PROC_RIVER,\n  aSOG_RANGE_PROC_SEA,\n  aSOG_RANGE_PROC_OFFING,\n  aSOG_RANGE_PROC_POOL,\n  aSOG_RANGE_PROC_FISHING_EVENT,\n  aSOG_RANGE_PROC_ISLAND,\n\n  aSOG_RANGE_PROC_NUM\n};\n\nextern int aSOG_gyoei_set(SET_MANAGER* set_manager, GAME_PLAY* play);\n\nextern int osShutdown;\n\n// DVD states.\n#define DVD_STATE_FATAL_ERROR   -1\n#define DVD_STATE_END           0\n#define DVD_STATE_BUSY          1\n#define DVD_STATE_WAITING       2\n#define DVD_STATE_COVER_CLOSED  3\n#define DVD_STATE_NO_DISK       4\n#define DVD_STATE_COVER_OPEN    5\n#define DVD_STATE_WRONG_DISK    6\n#define DVD_STATE_MOTOR_STOPPED 7\n#define DVD_STATE_PAUSING       8\n#define DVD_STATE_IGNORED       9\n#define DVD_STATE_CANCELED      10\n#define DVD_STATE_RETRY         11\n\n/* ARGB8 color format (32 bits) to RGB5A3 color format (16 bits) */\n#define ARGB8_to_RGB5A3(argb8) \\\n  ((u16)(((argb8) & 0xFF000000) >= 0xE0000000 ? \\\n   /* Fully opaque, 5 bits per color channel */ (0x8000 | ((((argb8) >> 16) & 0xF8) << 7) | ((((argb8) >> 8) & 0xF8) << 2) | (((argb8) & 0xFF) >> 3)) : \\\n   /* 3 bits of transparency, 4 bits per color channel */ (((((argb8) >> 24) & 0xE0) << 7) | ((((argb8) >> 16) & 0xF0) << 4) | (((argb8) >> 8) & 0xF0) | (((argb8) & 0xF0) >> 4))))\n\n#define GPACK_RGB5A3(r, g, b, a) ARGB8_to_RGB5A3((((a) & 0xFF) << 24) | (((r) & 0xFF) << 16) | (((g) & 0xFF) << 8) | ((b) & 0xFF))\n\n/* New Microcode Command Ids */\n#define G_TRIN 0x09\n#define G_TRIN_INDEPEND 0x0A\n\n#define G_SETTEXEDGEALPHA 0xCE\n#define G_SETCOMBINE_NOTEV 0xCF\n#define G_SETCOMBINE_TEV 0xD0\n#define G_SETTILE_DOLPHIN 0xD2\n\n#define G_FIRST_CMD G_SETTEXEDGEALPHA\n\n/* Triangle/Quad vertex bit size */\n#define POLY_5b 0 /* 5 bits per vertex index (0 - 31) */\n#define POLY_7b 1 /* 7 bits per vertex index (0 - 127) */\n#define POLY_BITMASK 1\n\n/* First face, 5 bits */\n#define POLY_GET_V0_5b(g)((g->words.w1 >> 4) & 0x1F)\n#define POLY_GET_V1_5b(g)((g->words.w1 >> 9) & 0x1F)\n#define POLY_GET_V2_5b(g)((g->words.w1 >> 14) & 0x1F)\n\n/* Second face, 5 bits */\n#define POLY_GET_V3_5b(g)((g->words.w1 >> 19) & 0x1F)\n#define POLY_GET_V4_5b(g)((g->words.w1 >> 24) & 0x1F)\n#define POLY_GET_V5_5b(g)((((g->words.w1 >> 29) & 7) | ((g->words.w0 & 3) << 3)) & 0x1F)\n\n/* Third face, 5 bits */\n#define POLY_GET_V6_5b(g)((g->words.w0 >> 2) & 0x1F)\n#define POLY_GET_V7_5b(g)((g->words.w0 >> 7) & 0x1F)\n#define POLY_GET_V8_5b(g)((g->words.w0 >> 12) & 0x1F)\n\n/* Fourth face, 5 bits */\n#define POLY_GET_V9_5b(g)((g->words.w0 >> 17) & 0x1F)\n#define POLY_GET_V10_5b(g)((g->words.w0 >> 22) & 0x1F)\n#define POLY_GET_V11_5b(g)((g->words.w0 >> 27) & 0x1F)\n\n/* First face, 7 bits */\n#define POLY_GET_V0_7b(g)((g->words.w1 >> 1) & 0x7F)\n#define POLY_GET_V1_7b(g)((g->words.w1 >> 8) & 0x7F)\n#define POLY_GET_V2_7b(g)((g->words.w1 >> 15) & 0x7F)\n\n/* Second face, 7 bits */\n#define POLY_GET_V3_7b(g)((g->words.w1 >> 22) & 0x7F)\n#define POLY_GET_V4_7b(g)((((g->words.w1 >> 29) & 7) | ((g->words.w0 & 0xF) << 3)) & 0x7F)\n#define POLY_GET_V5_7b(g)((g->words.w0 >> 4) & 0x7F)\n\n/* Third face, 7 bits */\n#define POLY_GET_V6_7b(g)((g->words.w0 >> 11) & 0x7F)\n#define POLY_GET_V7_7b(g)((g->words.w0 >> 18) & 0x7F)\n#define POLY_GET_V8_7b(g)((g->words.w0 >> 25) & 0x7F)\n\n/* Vertex matrix types */\n#define SHARED_MTX GX_PNMTX0\n#define NONSHARED_MTX GX_PNMTX1\n\n#define MTX_SHARED 0\n#define MTX_NONSHARED 1\n\n/* NOOP Debug Tags */\n#define G_TAG_NONE 0\n#define G_TAG_HERE 1\n#define G_TAG_STRING 2\n#define G_TAG_WORD 3\n#define G_TAG_FLOAT 4\n#define G_TAG_INFO 5\n#define G_TAG_CALLBACK 6\n#define G_TAG_OPENDISP 7\n#define G_TAG_CLOSEDISP 8\n#define G_TAG_FILL 9\n\n/* Vertex Culling Flags */\n#define G_CULL_X_LESSTHAN 0x100 /* x component left of culling plane */\n#define G_CULL_X_GREATERTHAN 0x200 /* x component right of culling plane */\n#define G_CULL_Y_LESSTHAN 0x400 /* y component below culling plane */\n#define G_CULL_Y_GREATERTHAN 0x800 /* y component above culling plane */\n#define G_CULL_Z_LESSTHAN 0x1000 /* z component behind culling plane */\n#define G_CULL_Z_GREATERTHAN 0x2000 /* z component farther than culling plane */\n\n/* Extra Geometry Mode Flags */\n#define G_LIGHTING_POSITIONAL 0x400000\n#define G_DECAL_LEQUAL 0x00\n#define G_DECAL_GEQUAL 0x10\n#define G_DECAL_EQUAL 0x20\n#define G_DECAL_ALWAYS 0x30\n#define G_DECAL_SPECIAL 0x40\n#define G_DECAL_ALL G_DECAL_ALWAYS | G_DECAL_SPECIAL\n\n/* Indicies for G_SPECIAL_1 */\n#define G_SPECIAL_NONE 0\n#define G_SPECIAL_UNKNOWN 1\n#define G_SPECIAL_TA_MODE 2\n\n/* Texture Adjust Modes (used in G_SPECIAL1) */\n#define G_TA_N64 0\n#define G_TA_DOLPHIN 1\n\n/* Combiner Param Ids */\n#define COMBINER_PARAM_A 1\n#define COMBINER_PARAM_B 2\n#define COMBINER_PARAM_C 3\n#define COMBINER_PARAM_D 4\n\n/* TEV Combiner Settings */\n\n#define TEV_COMBINED 0\n#define TEV_COMBINED_ALPHA 1\n#define TEV_FILL 2\n#define TEV_PRIM_LOD_FRAC 3\n#define TEV_PRIMITIVE 4\n#define TEV_PRIMITIVE_ALPHA 5\n#define TEV_ENVIRONMENT 6\n#define TEV_ENV_ALPHA 7\n#define TEV_TEXEL0 8\n#define TEV_TEXEL0_ALPHA 9\n#define TEV_SHADE 10\n#define TEV_SHADE_ALPHA 11\n#define TEV_ONE 12\n#define TEV_HALF 13\n#define TEV_KONST 14\n#define TEV_ZERO 15\n\n#define TEV_ALPHA_COMBINED 0\n#define TEV_ALPHA_PRIM_LOD_FRAC 1\n#define TEV_ALPHA_PRIMITIVE 2\n#define TEV_ALPHA_ENVIRONMENT 3\n#define TEV_ALPHA_TEXEL0 4\n#define TEV_ALPHA_SHADE 5\n#define TEV_ALPHA_ONE 6\n#define TEV_ALPHA_ZERO 7\n\n/* Macro to expand packed image/tile width and height */\n#define EXPAND_WIDTH(wd)(wd + 1)\n#define EXPAND_HEIGHT(ht)((ht + 1) * 4)\n\n/* Combiner Macros */\n\n#define COMBINER_GET_a0(words)((words.w0 >> 20) & 0xF)\n#define COMBINER_GET_b0(words)((words.w1 >> 28) & 0xF)\n#define COMBINER_GET_c0(words)((words.w0 >> 15) & 0x1F)\n#define COMBINER_GET_d0(words)((words.w1 >> 15) & 7)\n\n#define COMBINER_GET_Aa0(words)((words.w0 >> 12) & 7)\n#define COMBINER_GET_Ab0(words)((words.w1 >> 12) & 7)\n#define COMBINER_GET_Ac0(words)((words.w0 >> 9) & 7)\n#define COMBINER_GET_Ad0(words)((words.w1 >> 9) & 7)\n\n#define COMBINER_GET_a1(words)((words.w0 >> 5) & 0xF)\n#define COMBINER_GET_b1(words)((words.w1 >> 24) & 0xF)\n#define COMBINER_GET_c1(words)(words.w0 & 0x1F)\n#define COMBINER_GET_d1(words)((words.w1 >> 6) & 7)\n\n#define COMBINER_GET_Aa1(words)((words.w1 >> 21) & 7)\n#define COMBINER_GET_Ab1(words)((words.w1 >> 3) & 7)\n#define COMBINER_GET_Ac1(words)((words.w1 >> 18) & 7)\n#define COMBINER_GET_Ad1(words)(words.w1 & 7)\n\n/* TEV Combiner Macros */\n\n#define COMBINER_TEV_GET_a0(words)((words.w1 >> 28) & 0xF)\n#define COMBINER_TEV_GET_b0(words)((words.w1 >> 24) & 0xF)\n#define COMBINER_TEV_GET_c0(words)((words.w1 >> 20) & 0xF)\n#define COMBINER_TEV_GET_d0(words)((words.w1 >> 16) & 0xF)\n\n#define COMBINER_TEV_GET_Aa0(words)((words.w0 >> 21) & 7)\n#define COMBINER_TEV_GET_Ab0(words)((words.w0 >> 18) & 7)\n#define COMBINER_TEV_GET_Ac0(words)((words.w0 >> 15) & 7)\n#define COMBINER_TEV_GET_Ad0(words)((words.w0 >> 12) & 7)\n\n#define COMBINER_TEV_GET_a1(words)((words.w1 >> 12) & 0xF)\n#define COMBINER_TEV_GET_b1(words)((words.w1 >>  8) & 0xF)\n#define COMBINER_TEV_GET_c1(words)((words.w1 >>  4) & 0xF)\n#define COMBINER_TEV_GET_d1(words)((words.w1 >>  0) & 0xF)\n\n#define COMBINER_TEV_GET_Aa1(words)((words.w0 >>  9) & 7)\n#define COMBINER_TEV_GET_Ab1(words)((words.w0 >>  6) & 7)\n#define COMBINER_TEV_GET_Ac1(words)((words.w0 >>  3) & 7)\n#define COMBINER_TEV_GET_Ad1(words)((words.w0 >>  0) & 7)\n\ntypedef struct {\n    int cmd:8;\n    unsigned int a0:4;\n    unsigned int c0:5;\n    unsigned int Aa0:3;\n    unsigned int Ac0:3;\n    unsigned int a1:4;\n    unsigned int c1:5;\n\n    unsigned int b0:4;\n    unsigned int b1:4;\n    unsigned int Aa1:3;\n    unsigned int Ac1:3;\n    unsigned int d0:3;\n    unsigned int Ab0:3;\n    unsigned int Ad0:3;\n    unsigned int d1:3;\n    unsigned int Ab1:3;\n    unsigned int Ad1:3;\n} Gsetcombine_new;\n\ntypedef struct {\n    int cmd:8; /* 0xCF */\n    unsigned int Aa0:3;\n    unsigned int Ab0:3;\n    unsigned int Ac0:3;\n    unsigned int Ad0:3;\n\n    unsigned int Aa1:3;\n    unsigned int Ab1:3;\n    unsigned int Ac1:3;\n    unsigned int Ad1:3;\n\n    unsigned int a0:4;\n    unsigned int b0:4;\n    unsigned int c0:4;\n    unsigned int d0:4;\n\n    unsigned int a1:4;\n    unsigned int b1:4;\n    unsigned int c1:4;\n    unsigned int d1:4;\n} Gsetcombine_tev;\n\ntypedef struct {\n    unsigned int cmd:8;\n    unsigned int xl:12;\t/* Top-left x coord */\n    unsigned int yl:12;\t/* Top-left y coord */\n    unsigned int pad1:5;\n    unsigned int tile:3; /* Tile descriptor index */\n    unsigned int xh:12;\t/* Lower-right x coord */\n    unsigned int yh:12;\t/* Lower-right y coord */\n\n    unsigned int pad2:32;\n\n    unsigned int s:16;\t/* S (X) texture coord at top left */\n    unsigned int t:16;\t/* T (Y) texture coord at top left */\n\n    unsigned int pad3:32;\n\n    unsigned int dsdx:16; /* Change in S (X) per change in X */\n    unsigned int dtdy:16; /* Change in T (Y) per change in Y */\n} Gtexrect2;\n\ntypedef struct {\n    int cmd:8;\n    unsigned int dol_fmt:4;\n    unsigned int pad0:1;\n    unsigned int tile:3;\n    unsigned int tlut_name:4;\n    unsigned int wrap_s:2;\n    unsigned int wrap_t:2;\n    unsigned int shift_s:4;\n    unsigned int shift_t:4;\n    unsigned int pad1:32;\n} Gsettile_dolphin;\n\ntypedef struct {\n    int cmd:8;\n    unsigned int sl:14; /* Start of S coordinate */\n    unsigned int slen:10; /* Length of S coordinate */\n    \n    unsigned int isDolphin:1; /* If true, format is Gsettilesize_dolphin. If false, format is Gsettilesize2 */\n    unsigned int pad:4;\n    unsigned int tile:3; /* Tile descriptor */\n    unsigned int tl:14; /* Start of T coordinate */\n    unsigned int tlen:10; /* Length of T coordinate */\n} Gsettilesize_dolphin;\n\ntypedef struct {\n    int cmd:8; /* Command */\n    unsigned int fmt:3; /* Image format */\n    unsigned int siz:2; /* Image format texel size */\n    unsigned int isDolphin:1; /* Is this Gsetimg2 or Gsetimg */\n    unsigned int ht:8; /* Height, packed: (height / 4) - 1 */\n    unsigned int wd:10; /* Width, packed: width - 1 */\n\n    unsigned int imgaddr:32; /* Image RAM address */\n} Gsetimg2;\n\ntypedef union {\n    Gsetimg setimg;\n    Gsetimg2 setimg2;\n} Gsetimg_new;\n\ntypedef struct {\n    int cmd:8;\n    unsigned int type:2; /* Type - if 2, is Gloadtlut_dolphin. Otherwise is Gloadtlut. */\n    unsigned int pad0:2;\n    unsigned int tlut_name:4; /* GC Palette/TLUT name(index). */\n    unsigned int pad1:2;\n    unsigned int count:14; /* Number of entries in the TLUT. Max by GC spec is 0x4000. */\n    \n    unsigned int tlut_addr:32;\n} Gloadtlut_dolphin;\n\ntypedef struct {\n    unsigned char cmd:8;\n    unsigned char xparam:8;\n    unsigned int pad:2;\n    unsigned char level:3;\n    unsigned char tile:3;\n    unsigned char on:8; /* Should be 7 bits w/ 1 bit padding, but emulator doesn't do this */\n    unsigned short s:16;\n    unsigned short t:16;\n} Gtexture_internal;\n\ntypedef struct {\n    unsigned char cmd:8;\n    unsigned int index:8;\n    unsigned int offset:16;\n    unsigned int data;\n} Gmoveword;\n\ntypedef struct {\n    unsigned char cmd:8;\n    unsigned int length:8;\n    unsigned int offset:8;\n    unsigned int index:8;\n\n    unsigned int data;\n} Gmovemem;\n\ntypedef struct {\n    unsigned char col[3];\n    unsigned char kc;\n    unsigned char colc[3];\n    unsigned char k1;\n    signed short pos[3]; /* position of light */\n    unsigned char kq;\n} Light_pos_t;\n\ntypedef union {\n    Light_t l;\n    Light_pos_t p;\n    long long int force_align[2];\n} Light_new;\n\n/* Combiner Structs */\ntypedef struct {\n    unsigned int pad0:4;\n    unsigned int color0:4;\n    unsigned int pad1:4;\n    unsigned int color1:4;\n    unsigned int pad2:4;\n    unsigned int color2:4;\n    unsigned int pad3:4;\n    unsigned int color3:4;\n} combiner_tev_color;\n\ntypedef struct {\n    unsigned int pad0:5;\n    unsigned int alpha0:3;\n    unsigned int pad1:5;\n    unsigned int alpha1:3;\n} combiner_tev_alpha;\n\n/*\nstatic combiner_tev_alpha tbla[8] = {\n    { 0, TEV_ALPHA_COMBINED, 0, TEV_ALPHA_ONE },\n    { 0, TEV_ALPHA_TEXEL0, 0, TEV_ALPHA_TEXEL0 },\n    { 0, TEV_ALPHA_TEXEL0, 0, TEV_ALPHA_TEXEL0 },\n    { 0, TEV_ALPHA_PRIMITIVE, 0, TEV_ALPHA_PRIMITIVE },\n    { 0, TEV_ALPHA_SHADE, 0, TEV_ALPHA_SHADE },\n    { 0, TEV_ALPHA_ENVIRONMENT, 0, TEV_ALPHA_ENVIRONMENT },\n    { 0, TEV_ALPHA_ONE, 0, TEV_ALPHA_PRIM_LOD_FRAC },\n    { 0, TEV_ALPHA_ZERO, 0, TEV_ALPHA_ZERO }\n};\n\nstatic combiner_tev_color tblc[32] = {\n    { 0, TEV_COMBINED, 0, TEV_COMBINED, 0, TEV_COMBINED, 0, TEV_COMBINED },\n    { 0, TEV_TEXEL0, 0, TEV_TEXEL0, 0, TEV_TEXEL0, 0, TEV_TEXEL0 },\n    { 0, TEV_TEXEL0, 0, TEV_TEXEL0, 0, TEV_TEXEL0, 0, TEV_TEXEL0 },\n    { 0, TEV_PRIMITIVE, 0, TEV_PRIMITIVE, 0, TEV_PRIMITIVE, 0, TEV_PRIMITIVE },\n    { 0, TEV_SHADE, 0, TEV_SHADE, 0, TEV_SHADE, 0, TEV_SHADE },\n    { 0, TEV_ENVIRONMENT, 0, TEV_ENVIRONMENT, 0, TEV_ENVIRONMENT, 0, TEV_ENVIRONMENT },\n    { 0, TEV_ONE, 0, TEV_HALF, 0, TEV_HALF, 0, TEV_ONE },\n    { 0, TEV_HALF, 0, TEV_HALF, 0, TEV_COMBINED_ALPHA, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_TEXEL0_ALPHA, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_TEXEL0_ALPHA, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_PRIMITIVE_ALPHA, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_SHADE_ALPHA, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ENV_ALPHA, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_HALF, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_PRIM_LOD_FRAC, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_HALF, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO },\n    { 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO, 0, TEV_ZERO }\n};\n*/\n\n/* New Command Macros */\n#define gsDPParam2(cmd, tag, param, extra) \\\n{{ \\\n\t_SHIFTL(cmd, 24, 8) | _SHIFTL(tag, 16, 8) | _SHIFTL(param, 0, 16), extra \\\n}}\n\n#define gsDPNoOpTag2(tag, param, extra) gsDPParam2(G_NOOP, tag, param, extra) \n#define\tgsDPNoOpHere() gsDPNoOpTag2(G_TAG_HERE, __LINE__, __FILE__)\n#define gsDPNoOpString(str, param) gsDPNoOpTag2(G_TAG_STRING, param, str)\n#define gsDPNoOpWord(word, param) gsDPNoOpTag2(G_TAG_WORD, param, word)\n#define gsDPNoOpFloat(float, param) gsDPNoOpTag2(G_TAG_FLOAT, param, float)\n#define gsDPNoOpQuiet() gsDPNoOpTag2(G_TAG_INFO, 0, 0)\n#define gsDPNoOpVerbose() gsDPNoOpTag2(G_TAG_INFO, 0xF, 0)\n#define gsDPNoOpCallBack(callback, param) gsDPNoOpTag2(G_TAG_CALLBACK, param, callback)\n#define gsDPNoOpOpenDisp() gsDPNoOpTag2(G_TAG_OPENDISP, __LINE__, __FILE__)\n#define gsDPNoOpCloseDisp() gsDPNoOpTag2(G_TAG_CLOSEDISP, __LINE__, __FILE__)\n#define gsDPNoOpFill() gsDPNoOpTag2(G_TAG_FILL, 0, 0)\n#define gsDPNoOpTag3(tag, extra, param) gsDPNoOpTag2(tag, param, extra)\n\n#define G_TLUT_DOLPHIN 2\n#define gDPLoadTLUT_Dolphin(pkt, name, count, unk, addr) \\\ndo { \\\n    Gfx* _g = (Gfx*)(pkt); \\\n    _g->words.w0 = _SHIFTL(G_LOADTLUT, 24, 8) | _SHIFTL(G_TLUT_DOLPHIN, 22, 2) | _SHIFTL(name, 16, 4) | _SHIFTL(unk, 14, 2) | _SHIFTL(count, 0, 14); \\\n    _g->words.w1 = (unsigned int)addr; \\\n} while (0)\n\n#define gsDPLoadTLUT_Dolphin(name, count, unk, addr) \\\n{{ \\\n    _SHIFTL(G_LOADTLUT, 24, 8) | _SHIFTL(G_TLUT_DOLPHIN, 22, 2) | _SHIFTL(name, 16, 4) | _SHIFTL(unk, 14, 2) | _SHIFTL(count, 0, 14), (unsigned int)addr \\\n}}\n\n#define gsDPSetTextureImage_Dolphin(fmt, siz, h, w, img) \\\n{{ \\\n    _SHIFTL(G_SETTIMG, 24, 8) | _SHIFTL(fmt, 21, 3) | _SHIFTL(siz, 19, 2) | _SHIFTL(1, 18, 1) | \\\n        _SHIFTL((h/4)-1, 10, 8) | _SHIFTL((w-1), 0, 10), (unsigned long)img \\\n}}\n\n#define gsDPSetTile_Dolphin(d_fmt, tile, tlut_name, wrap_s, wrap_t, shift_s, shift_t) \\\n{{ \\\n    _SHIFTL(G_SETTILE_DOLPHIN, 24, 8) | _SHIFTL(d_fmt, 20, 4) | _SHIFTL(tile, 16, 3) | \\\n        _SHIFTL(tlut_name, 12, 4) | _SHIFTL(wrap_s, 10, 2) | _SHIFTL(wrap_t, 8, 2) | \\\n        _SHIFTL(shift_s, 4, 4) | _SHIFTL(shift_t, 0, 4), 0 \\\n}}\n\n#define gDPSetTextureImage_Dolphin(pkt, fmt, siz, h, w, img) \\\n{{ \\\n    Gfx* _gfx = (Gfx*)(pkt); \\\n    _gfx->words.w0 = _SHIFTL(G_SETTIMG, 24, 8) | _SHIFTL(fmt, 21, 3) | _SHIFTL(siz, 19, 2) | _SHIFTL(1, 18, 1) | \\\n        _SHIFTL((h/4)-1, 10, 8) | _SHIFTL((w-1), 0, 10); \\\n    _gfx->words.w1 = (unsigned int)img; \\\n}}\n\n#define gDPSetTile_Dolphin(pkt, d_fmt, tile, tlut_name, wrap_s, wrap_t, shift_s, shift_t) \\\n{{ \\\n    Gfx* _gfx = (Gfx*)(pkt); \\\n    _gfx->words.w0 = _SHIFTL(G_SETTILE_DOLPHIN, 24, 8) | _SHIFTL(d_fmt, 20, 4) | _SHIFTL(tile, 16, 3) | \\\n        _SHIFTL(tlut_name, 12, 4) | _SHIFTL(wrap_s, 10, 2) | _SHIFTL(wrap_t, 8, 2) | \\\n        _SHIFTL(shift_s, 4, 4) | _SHIFTL(shift_t, 0, 4); \\\n    /*_gfx->words.w1 = 0;*/ /* bug? they don't set the second word */ \\\n}}\n\n#define G_DOLPHIN_TLUT_DEFAULT_MODE 15 // used almost always? CI palettes are forced to GX_TF_RGB5A3\n#define gsDPLoadTextureBlock_4b_Dolphin(timg, fmt, w, h, pal, ws, wt, ss, st) \\\n    gsDPSetTextureImage_Dolphin(fmt, G_IM_SIZ_4b, h, w, timg), \\\n    gsDPSetTile_Dolphin(G_DOLPHIN_TLUT_DEFAULT_MODE, 0, pal, ws, wt, ss, st)\n\n#define gDPLoadTextureTile_4b_Dolphin(pkt, timg, fmt, w, h) \\\ndo { \\\n    gDPSetTextureImage_Dolphin(pkt, fmt, G_IM_SIZ_4b, h, w, timg); \\\n    gDPSetTile_Dolphin(pkt, G_DOLPHIN_TLUT_DEFAULT_MODE, 0, 0, 0, 0, 0, 0) \\\n} while (0);\n\n#define gsSPNTriangles(n) \\\n{{ \\\n    _SHIFTL(G_TRIN_INDEPEND, 24, 8) | _SHIFTL(n-1, 17, 7), 0 \\\n}}\n\n/* 5 bits per vertex id (32) */\n#define gsSPNTriangleData1(v0, v1, v2, flag) (_SHIFTL(v2, 10, 5) | _SHIFTL(v1, 5, 5) | _SHIFTL(v0, 0, 5))\n\n/* 7 bits per vertex id (128) */\n#define gsSPNTriangleData2(v0, v1, v2, flag) \\\n{{ \\\n    (unsigned long long)(_SHIFTL(v2, 14, 7) | _SHIFTL(v1, 7, 7) | _SHIFTL(v0, 0, 7)) \\\n}}\n\n#define G_VTX_MODE_5bit 0\n#define G_VTX_MODE_7bit 1\n\n#define gSPNTriangles_5b(pkt, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) \\\n{{ \\\n  Gfx* _g = (Gfx*)(pkt); \\\n  _g->words.w0 = (u32)((gsSPNTriangleData1(v9, v10, v11) << 17) | (gsSPNTriangleData1(v6, v7, v8) << 2) | ((gsSPNTriangleData1(v3, v4, v5) >> 13) & 3)); \\\n  _g->words.w1 = (u32)(((gsSPNTriangleData1(v3, v4, v5) & 7) << 19) | (gsSPNTriangleData1(v0, v1, v2) << 4) | G_VTX_MODE_5bit); \\\n}}\n\n#define gSPNTrianglesInit_5b(pkt, n, v0, v1, v2, v3, v4, v5, v6, v7, v8) \\\n{{ \\\n  Gfx* _g = (Gfx*)(pkt); \\\n  _g->words.w0 = (u32)(_SHIFTL(G_TRIN_INDEPEND, 24, 8) | _SHIFTL(n-1, 17, 7) | _SHIFTL(gsSPNTriangleData1(v6, v7, v8, 0), 2, 15) | _SHIFTL(_SHIFTR(gsSPNTriangleData1(v3, v4, v5, 0), 2, 13), 0, 2)); \\\n  _g->words.w1 = (u32)(_SHIFTL(gsSPNTriangleData1(v3, v4, v5, 0), 19, 13) | _SHIFTL(gsSPNTriangleData1(v0, v1, v2, 0), 4, 15) | _SHIFTL(G_VTX_MODE_5bit, 0, 1)); \\\n}}\n\n// TODO: convert\n#define gSPNTriangles_7b(v0, v1, v2, v3, v4, v5, v6, v7, v8) \\\n{{ \\\n    (unsigned long long)((gsSPNTriangleData2(v6, v7, v8) << 43) | (gsSPNTriangleData2(v3, v4, v5) << 22) | \\\n        (gsSPNTriangleData2(v0, v1, v2) << 1)) | G_VTX_MODE_7bit \\\n}}\n\n#define gSPNTrianglesInit_7b(n, v0, v1, v2, v3, v4, v5) \\\n{{ \\\n    (unsigned long long)((((unsigned long long)gsSPNTriangles(n)) << 32) | (gsSPNWTriangleData2(v3, v4, v5) << 22) | \\\n        (gsSPNTriangleData2(v0, v1, v2) << 1)) | G_VTX_MODE_7bit \\\n}}\n\n#define gsSPNTriangles_5b(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) \\\n{{ \\\n    _SHIFTL(gsSPNTriangleData1(v9, v10, v11, 0), 17, 15) | _SHIFTL(gsSPNTriangleData1(v6, v7, v8, 0), 2, 15) | _SHIFTL(_SHIFTR(gsSPNTriangleData1(v3, v4, v5, 0), 2, 13), 0, 2), \\\n    _SHIFTL(gsSPNTriangleData1(v3, v4, v5, 0), 19, 13) | _SHIFTL(gsSPNTriangleData1(v0, v1, v2, 0), 4, 15) | _SHIFTL(G_VTX_MODE_5bit, 0, 1) \\\n}}\n\n#define gsSPNTrianglesInit_5b(n, v0, v1, v2, v3, v4, v5, v6, v7, v8) \\\n{{ \\\n    _SHIFTL(G_TRIN_INDEPEND, 24, 8) | _SHIFTL(n-1, 17, 7) | _SHIFTL(gsSPNTriangleData1(v6, v7, v8, 0), 2, 15) | _SHIFTL(_SHIFTR(gsSPNTriangleData1(v3, v4, v5, 0), 2, 13), 0, 2), \\\n    _SHIFTL(gsSPNTriangleData1(v3, v4, v5, 0), 19, 13) | _SHIFTL(gsSPNTriangleData1(v0, v1, v2, 0), 4, 15) | _SHIFTL(G_VTX_MODE_5bit, 0, 1) \\\n}}\n\n#define gsSPNTriangles_7b(v0, v1, v2, v3, v4, v5, v6, v7, v8) \\\n{{ \\\n    (unsigned long long)((gsSPNTriangleData2(v6, v7, v8) << 43) | (gsSPNTriangleData2(v3, v4, v5) << 22) | \\\n        (gsSPNTriangleData2(v0, v1, v2) << 1)) | G_VTX_MODE_7bit \\\n}}\n\n#define gsSPNTrianglesInit_7b(n, v0, v1, v2, v3, v4, v5) \\\n{{ \\\n    (unsigned long long)((((unsigned long long)gsSPNTriangles(n)) << 32) | (gsSPNWTriangleData2(v3, v4, v5) << 22) | \\\n        (gsSPNTriangleData2(v0, v1, v2) << 1)) | G_VTX_MODE_7bit \\\n}}\n\n#define gDPSetTexEdgeAlpha(pkt, alpha) \\\ndo { \\\n  Gfx* _g = (Gfx*)(pkt); \\\n  _g->words.w0 = (u32)(_SHIFTL(G_SETTEXEDGEALPHA, 24, 8)); \\\n  _g->words.w1 = (u32)(_SHIFTL(alpha, 0, 8)); \\\n} while(0)\n\n#define gsDPSetTexEdgeAlpha(alpha) \\\n{{ \\\n  (u32)(_SHIFTL(G_SETTEXEDGEALPHA, 24, 8)), \\\n  (u32)(_SHIFTL(alpha, 0, 8)) \\\n}}\n\n#define gDPSetTextureAdjustMode(pkt, mode) \\\ndo { \\\n  Gfx* _g = (Gfx*)(pkt); \\\n  _g->words.w0 = (u32)(_SHIFTL(G_SPECIAL_1, 24, 8) | _SHIFTL(G_SPECIAL_TA_MODE, 16, 8) | _SHIFTL(mode, 0, 16)); \\\n  _g->words.w1 = (u32)0; \\\n} while(0)\n\n#define gsDPSetTextureAdjustMode(mode) \\\n{{ \\\n  (u32)(_SHIFTL(G_SPECIAL_1, 24, 8) | _SHIFTL(G_SPECIAL_TA_MODE, 16, 8) | _SHIFTL(mode, 0, 16)), \\\n  (u32)0 \\\n}}\n\n#define GX_CLAMP 0\n#define GX_REPEAT 1\n#define GX_MIRROR 2\n\nenum dvderr_state {\n  DVDERR_NONE = -1,\n\n  DVDERR_COVER_OPEN = 0,\n  DVDERR_NO_DISK,\n  DVDERR_WRONG_DISK,\n  DVDERR_RETRY,\n  DVDERR_FATAL,\n\n  DVDERR_NUM\n};\n\ntypedef void (*DVDERR_DRAW_PROC)();\n\n/* sizeof(dvderr_work) == 0x3F8 */\ntypedef struct dvderr_work_s {\n  /* 0x000 */ Gfx gfx[100];               // display list buffer\n  /* 0x320 */ Gfx* gfx_p;                 // current display list buffer write pointer\n  /* 0x328 */ Mtx ortho;                  // orthographic matrix\n  /* 0x368 */ Mtx lookat;                 // look-at matrix\n  /* 0x3A8 */ Mtx scale;                  // model-scale matrix\n  /* 0x3E8 */ f32 xy_pos;                 // xy position for model-scale matrix\n\n  /* 0x3EC */ DVDERR_DRAW_PROC draw_proc; // current draw routine\n  /* 0x3F0 */ int now_error;              // current dvd error\n  /* 0x3F4 */ int next_error;             // next dvd error\n} dvderr_work;\n\nextern int dvderr_draw();\nextern void dvderr_init();\n\nvoid guOrtho(Mtx *m, float l, float r, float b, float t, float n, float f, float scale);\nvoid guScale(Mtx *m, float x, float y, float z);\n void guLookAt(Mtx *m, \n\t\t\tfloat xEye, float yEye, float zEye,\n\t\t\tfloat xAt,  float yAt,  float zAt,\n\t\t\tfloat xUp,  float yUp,  float zUp);\n\n\n#define mTD_TITLE_DEMO_NUM 5\n\nextern int mTD_get_titledemo_no();\nextern int mTD_demono_get();\n\ntypedef struct demo_npc_s {\n  mActor_name_t npc_name; /* villager id, E0XX */\n  u32 block_x, block_z; /* spawn acre */\n  u32 ut_x, ut_z; /* spawn unit in acre */\n} mNpc_demo_npc_c;\n\ntypedef struct {\n  u8 type;\n  u8 palette;\n  u8 wall_id;\n  u8 floor_id;\n  mActor_name_t main_layer_id;\n  mActor_name_t secondary_layer_id;\n} mNpc_NpcHouseData_c;\n\ntypedef struct npc_conversation_s {\n  u8 beesting:1; // talk to player about their beesting\n  u8 fish_complete:1; // talk to the player about catching all fish\n  u8 insect_complete:1; // talk to the player about catching all insects\n  u8 unk:5;\n} mNpc_NpcConversation_c;\n\ntypedef struct npc_list_s {\n  mActor_name_t name;\n  mActor_name_t field_name;\n  xyz_t house_position;\n  xyz_t position;\n  u8 appear_flag;\n  mNpc_NpcConversation_c conversation_flags;\n  mQst_base_c quest_info;\n  mNpc_NpcHouseData_c house_data;\n  mActor_name_t reward_furniture;\n} mNpc_NpcList_c;\n\ntypedef struct event_npc_s {\n  mActor_name_t event_id; /* event NPC id */\n  mActor_name_t texture_id; /* real NPC id which is used for texture data */\n  mActor_name_t npc_id; /* non-texture NPC id used for other NPC data */\n  mActor_name_t cloth_id; /* cloth texture id */\n  u8 exists; /* has the actor been spawned yet? */\n  u8 in_use; /* is this event npc structure being used? */\n  u16 _A; /* exists based on size of structure, seems unused */\n} mNpc_EventNpc_c;\n\ntypedef struct mask_npc_s {\n  mActor_name_t mask_id; /* 'mask' actor id */\n  mActor_name_t npc_id; /* NPC actor id whose data will be used */\n  mActor_name_t cloth_id; /* cloth actor id */\n  u8 exists; /* has the actor been spawned yet? */\n  u8 in_use; /* is this mask npc structure being used? */\n  Animal_c animal_data; /* animal data is copied if the mask npc is a standard villager NPC */\n} mNpc_MaskNpc_c;\n\n\nextern void initView(View* view, GRAPH* graph);\nextern void setLookAtView(View* view, xyz_t* eye, xyz_t* center, xyz_t* up);\nextern void setScaleView(View* view, f32 scale);\nextern void setPerspectiveView(View* view, f32 fovY, f32 near, f32 far);\nextern void setScissorView(View* view, rect* screen);\nextern int stretchViewInit(View* view);\nextern int showView(View* view, int flags);\nextern int showPerspectiveView(View* view);\nextern int showOrthoView(View* view);\nextern int showView1(View* view, int flag_mask, Gfx** gfx_p);\n\n/* sizeof(struct game_trademark_s) == 0x25A70 */\ntypedef struct game_trademark_s {\n  /* 0x000000 */ GAME game;\n  /* 0x0000E0 */ View view;\n  /* 0x000200 */ xyz_t unused_200; // n64\n  /* 0x00020C */ f32 unused_20c; // n64\n  /* 0x000210 */ u32 unused_210; // n64\n  /* 0x000214 */ int unused_214; // n64\n  /* 0x000218 */ int unused_218[15]; // n64\n  /* 0x000254 */ int unused_254; // n64\n  /* 0x000258 */ int unused_258[38400]; // n64 texture\n  /* 0x025A58 */ u32 alpha;\n  /* 0x025A5C */ s16 logo_timer;\n  /* 0x025A5E */ u16 alpha2;\n  /* 0x025A60 */ s16 move_timer;\n  /* 0x025A62 */ s16 unused_25a62; // n64\n  /* 0x025A64 */ s16 unused_25a64; // n64\n  /* 0x025A66 */ u8 stage;\n  /* 0x025A67 */ u8 unused_25a67; // n64\n  /* 0x025A68 */ u8 cancel;\n  /* 0x025A69 */ u8 check;\n  /* 0x025A6C */ int unused_25a6c; // n64\n} GAME_TRADEMARK;\n\nextern void trademark_init(GAME* game);\nextern void trademark_cleanup(GAME* game);\n\n#define mAGrw_FOSSIL_NUM 5\n#define mAGrw_HANIWA_NUM 3\n#define mAGrw_FTR_TREE_NUM 2\n#define mAGrw_MAX_PAST_DAYS 5\n#define mAGrw_GRASS_TABLE_NUM 12\n#define mAGrw_MONEY_TREE_NUM 30\n#define mAGrw_MAX_TREES_PER_BLOCK 32\n#define mAGrw_ISL_TREE_MAX_LINE 3\n#define mAGrw_ISL_MAX_TREES_PER_BLOCK 15\n#define mAGrw_DUMP_ITEM_NUM 2\n#define mAGrw_GRASS_PER_DAY 5\n\nenum {\n  mAGrw_GROW_FIRST,\n  mAGrw_GROW,\n  mAGrw_GROW_FIRST_FORCE, /* Used when you go back in time */\n\n  mAGrw_GROW_ISLAND_FIRST,\n  mAGrw_GROW_ISLAND,\n  mAGrw_GROW_ISLAND_FIRST_FORCE, /* Used when you go back in time */\n\n  mAGrw_GROW_NUM\n};\n\nenum {\n  mAGrw_TREE000,\n  mAGrw_TREE001,\n  mAGrw_TREE002,\n  mAGrw_TREE003,\n  mAGrw_TREE004,\n\n  mAGrw_TREE_STAGE_NUM\n};\n\nenum {\n  mAGrw_AROUND_TOP,\n  mAGrw_AROUND_BOTTOM,\n  mAGrw_AROUND_LEFT,\n  mAGrw_AROUND_RIGHT,\n\n  mAGrw_AROUND_NUM\n};\n\nenum {\n  mAGrw_FLOWER_TIME,\n  mAGrw_NOT_FLOWER_TIME,\n\n  mAGrw_FLOWER_TIME_NUM\n};\n\nenum {\n  mAGrw_TREE_TYPE_APPLE,\n  mAGrw_TREE_TYPE_CHESTNUT, // cherry tree\n  mAGrw_TREE_TYPE_PEAR,\n  mAGrw_TREE_TYPE_PEACH,\n  mAGrw_TREE_TYPE_ORANGE,\n  mAGrw_TREE_TYPE_NORMAL,\n  mAGrw_TREE_TYPE_MONEY,\n  mAGrw_TREE_TYPE_PALM,\n  mAGrw_TREE_TYPE_CEDAR,\n  mAGrw_TREE_TYPE_GOLD,\n\n  mAGrw_TREE_TYPE_NUM\n};\n\nenum {\n  mAGrw_KILL_PALM_TREE,\n  mAGrw_KILL_CEDAR_TREE,\n\n  mAGrw_KILL_TREE_NUM\n};\n\nenum {\n  mAGrw_CARP_UNCHANGED,\n  mAGrw_CARP_PLACE,\n  mAGrw_CARP_REMOVE,\n\n  mAGrw_CARP_NUM\n};\n\nenum {\n  mAGrw_CHECK_CANCEL_12,\n  mAGrw_CHECK_CANCEL_32,\n  mAGrw_CHECK_CANCEL_22,\n  mAGrw_CHECK_CANCEL_36,\n  mAGrw_CHECK_CANCEL_LEFT_45,\n  mAGrw_CHECK_CANCEL_RIGHT_45,\n  mAGrw_CHECK_CANCEL_46,\n  mAGrw_CHECK_CANCEL_23,\n  mAGrw_CHECK_CANCEL_57,\n  mAGrw_CHECK_CANCEL_68,\n  mAGrw_CHECK_CANCEL_77,\n\n  mAGrw_CHECK_CANCEL_NUM\n};\n\ntypedef struct shine_stone_pos_info {\n  u8 block_x;\n  u8 block_z;\n  u8 ut_x;\n  u8 ut_z;\n} mAGrw_SSPosInfo_c;\n\ntypedef struct allgrow_s {\n  mAGrw_SSPosInfo_c shine_pos[TOTAL_PLAYER_NUM];\n  mAGrw_SSPosInfo_c stone_pos[TOTAL_PLAYER_NUM];\n} mAGrw_AllGrow_c;\n\ntypedef struct grow_info_s {\n  mFM_fg_c* around_block[mAGrw_AROUND_NUM];\n\n  int check_plant;\n  int past_days;\n  int block_height;\n  int ocean_row;\n  int flower_time;\n  int spoil_kabu;\n\n  int block_x;\n  int block_z;\n  int ut_x;\n  int ut_z;\n\n  int deposited_item;\n  int money_tree_num;\n  u8 fossil_record;\n  int fossil_num;\n  u8 honeycomb_tree_record;\n  u8 ftr_tree_record;\n  u8 money_stone_spawned;\n} mAGrw_GrowInfo_c;\n\ntypedef struct carp_block_info_s {\n  u8 signboard_in_block:1;\n  u8 carp_already_exists:1;\n  u8 villager_house_in_block:1;\n  u8 signboard_count:5;\n} mAGrw_CarpBlockInfo_c;\n\ntypedef struct carp_info_s {\n  mAGrw_CarpBlockInfo_c block_flags[FG_BLOCK_TOTAL_NUM];\n  u8 signboard_blocks;\n  u8 carp_blocks;\n  u8 villager_house_blocks;\n} mAGrw_CarpInfo_c;\n\ntypedef struct mask_cat_s {\n  mNW_original_design_c design;\n  u8 palette_no;\n  u8 cloth_no;\n  u8 talk_idx;\n  lbRTC_time_c time;\n} MaskCat_c;\n\n#define mEv_TO_DAY(month_day) ((lbRTC_day_t)((u16)(month_day)))\n#define mEv_TO_MONTH(month_day) ((lbRTC_month_t)((u16)(month_day) >> 8))\n\ntypedef struct generic_unit_s {\n  int z;\n  int x;\n} BlockOrUnit_c;\n\ntypedef union event_monthday_s {\n  struct {\n    u8 month;\n    u8 day;\n  };\n  u16 raw;\n} mEv_MonthDay_u;\n\ntypedef struct event_info_s {\n  s8 type;\n  s8 id;\n  u16 year;\n  mEv_MonthDay_u start_date;\n  mEv_MonthDay_u end_date;\n} mEv_info_c;\n\ntypedef struct event_place_data_s {\n  BlockOrUnit_c block;\n  BlockOrUnit_c unit;\n  mActor_name_t actor_name;\n  s16 flag;\n} mEv_place_data_c;\n\ntypedef struct event_place_s {\n  mEv_info_c info;\n  mEv_place_data_c data;\n} mEv_place_c;\n\ntypedef struct event_area_s {\n  mEv_info_c info;\n  int data[11];\n} mEv_area_c;\n\ntypedef struct event_common_s {\n  s16 _00;\n  s16 area_use_bitfield;\n  mEv_area_c area[5];\n  s16 too_short;\n  s16 place_use_bitfield;\n  mEv_place_c place[10];\n  s16 fieldday_event_id;\n  s16 fieldday_event_over_status;\n  u32 unused[2];\n} mEv_common_data_c;\n\ntypedef struct event_save_event_info_s {\n  u8 type;\n  u8 flags;\n} mEv_event_save_info_c;\n\ntypedef struct event_common_save_data {\n  mEv_event_save_info_c special_event;\n  mEv_event_save_info_c weekly_event;\n  u16 dates[8];\n  int area_use_bitfield;\n  mEv_area_c area[5];\n  int last_date;\n  int _120;\n  u32 valentines_day_date;\n  u32 white_day_date; /* unused in AC */\n  u16 ghost_day;\n  u16 bridge_day; // last date suspension bridge event was active\n  union {\n    struct {\n      u8 used_all_locations:1; // set to true when tortimer has cycled through all possible bridge locations?\n      u8 locations_used:7; // index of river acre w/ possible bridge location currently at\n    };\n    \n    u8 raw;\n  } bridge_flags;\n  u8 ghost_event_type; // 0x72 will spawn wisp, 0x77 won't?\n  u8 soncho_event_type; // checked not equal to 0xFF for summer & fall fishing tournies\n  u8 current_event_state; // used to signal when you've received an item from gracie or woken gulliver up\n} mEv_save_common_data_c;\n\ntypedef struct Save_s {\n  /* 0x000000 */ mFRm_chk_t save_check; /* save information */\n  /* 0x000014 */ int scene_no; /* current 'scene' id */\n  /* 0x000018 */ u8 now_npc_max; /* current number of villagers living in town (see mNpc_(Add/Sub)NowNpcMax) */\n  /* 0x000019 */ u8 remove_animal_idx; /* index of the villager which is scheduled to leave town, 0xFF when none selected */\n  /* 0x00001A */ u16 copy_protect; /* 'unique' value between [1, 65520] used for copy protection (see mCD_get_land_copyProtect) */\n  /* 0x00001C */ u8 pad_1C[4];\n  /* 0x000020 */ Private_c private_data[PLAYER_NUM]; /* player data */\n  /* 0x009120 */ mLd_land_info_c land_info; /* town name & id */\n  /* 0x00912C */ mNtc_board_post_c noticeboard[mNtc_BOARD_POST_COUNT]; /* noticeboard posts */\n  /* 0x009CE4 */ u8 pad_9CE4[4];\n  /* 0x009CE8 */ mHm_hs_c homes[PLAYER_NUM]; /* player house data */\n  /* 0x0137A8 */ mFM_fg_c fg[FG_BLOCK_Z_NUM][FG_BLOCK_X_NUM]; /* fg items (fg = foreground?) */\n  /* 0x0173A8 */ mFM_combination_c combi_table[BLOCK_Z_NUM][BLOCK_X_NUM]; /* acre 'combination' data */\n  /* 0x017438 */ Animal_c animals[ANIMAL_NUM_MAX]; /* villagers in town */\n  /* 0x020330 */ AnmPersonalID_c last_removed_animal_id; /* ID of last villager who left town */\n  /* 0x020340 */ Shop_c shop; /* Nook's shop */\n  /* 0x020480 */ Kabu_price_c kabu_price_schedule; /* Stalk Market info */\n  /* 0x020498 */ mEv_event_save_c event_save_data;\n  /* 0x020554 */ mEv_save_common_data_c event_save_common;\n  /* 0x020688 */ mActor_name_t fruit; /* town fruit type */\n  /* 0x02068A */ u8 house_arrangement; /* 2 bits for each player for the # of house they own */\n  /* 0x02068B */ u8 num_statues; /* number of statues built for players who have paid off their debts */\n  /* 0x02068C */ lbRTC_time_c all_grow_renew_time; /* renewal time for fg items handled by mAgrw_RenewalFgItem_ovl */\n  /* 0x020694 */ PostOffice_c post_office; /* post office data */\n  /* 0x020ED0 */ PoliceBox_c police_box; /* police station lost & found */\n  /* 0x020EF8 */ mSN_snowman_save_c snowmen; /* saved snowmen data */\n  /* 0x020F08 */ u64 melody; /* town tune, each nibble is a note (16 notes) */\n  /* 0x020F10 */ Config_c config; /* saved config for sound mode, voice mode, and vibration */\n  /* 0x020F14 */ lbRTC_ymd_c renew_time; /* next renew date */\n  /* 0x020F18 */ u8 station_type; /* train station type */\n  /* 0x020F19 */ u8 weather; /* upper nibble is intensity, lower nibble is type */\n  /* 0x020F1A */ u8 save_exist; /* unsure, set in mCD_SaveHome_bg_set_data (1) & mCD_SaveHome_bg (bss) */\n  /* 0x020F1B */ u8 npc_force_go_home; /* when set to 1, forces the 'm_go_home' code to activate */\n  /* 0x020F1C */ u16 deposit[FG_BLOCK_X_NUM * FG_BLOCK_Z_NUM][UT_Z_NUM]; /* flags for which items are buried around town */\n  /* 0x0212DC */ lbRTC_time_c last_grow_time; /* last time that a new villager moved into town */\n  /* 0x0212E4 */ mPr_mother_mail_info_c mother_mail[PLAYER_NUM]; /* info on when mom sent player letters and what event was sent */\n  /* 0x02131C */ mMsr_time_c mushroom_time; /* last time mushroom season info was updated */\n  /* 0x021322 */ lbRTC_ymd_c _021322;\n  /* 0x021326 */ u16 _021326[20];\n  /* 0x02134E */ u8 npc_used_tbl[32];\n  /* 0x02136E */ lbRTC_time_c _02136E;\n  /* 0x021376 */ u8 cheated_flag;\n  /* 0x021377 */ u8 _021377[7]; \n  /* 0x02137E */ lbRTC_time_c treasure_buried_time; /* last time treasure was actually buried */\n  /* 0x021386 */ lbRTC_time_c treasure_checked_time; /* last time check to bury treasure was executed */\n  /* 0x02138E */ u8 saved_rom_debug; /* flag to set save to 'debug rom' mode */\n  /* 0x02138F */ u8 snowman_year; /* year last snowman was built */\n  /* 0x021390 */ u8 snowman_month; /* month last snowman was built */\n  /* 0x021391 */ u8 snowman_day; /* day last snowman was built */\n  /* 0x021392 */ u8 snowman_hour; /* hour last snowman was built */\n  /* 0x021393 */ u8 haniwa_scheduled; /* when set, gyroids will be spwaned */\n  /* 0x021394 */ u8 dust_flag; /* set by field assessment for too much 'dust' (garbage) around town, causes immediate fail of town ranking */\n  /* 0x021395 */ u8 clear_grass; /* set by Wisp, removes all weeds */\n  /* 0x021396 */ lbRTC_ymd_c event_year_ymd; /* might not exist and just be lbRTC_year_t */\n  /* 0x02139A */ u8 unused_2139A[6];\n  /* 0x0213A0 */ u8 keep_house_size[PLAYER_NUM]; /* saved flags for house sizes */\n  /* 0x0213A4 */ lbRTC_ymd_c force_remove_date; /* last time the NPC force remove timer was updated */\n  /* 0x0213A8 */ mMmd_info_c museum_display; /* museum display bits */\n  /* 0x0213E7 */ u8 _tmp6[0x213F0 - 0x213E7];\n  /* 0x0213F0 */ PlusBridge_c bridge; /* additional bridge info */\n  /* 0x021400 */ mNW_needlework_c needlework; /* Able Sisters' designs */\n  /* 0x022500 */ u8 _tmp7[0x22528 - 0x22500];\n  /* 0x022528 */ OSTime time_delta; /* time delta against GC RTC */\n  /* 0x022540 */ Island_c island; /* island data */\n  /* 0x023E40 */ mAGrw_AllGrow_c allgrow_ss_pos_info;\n  /* 0x023E68 */ mFR_record_c fishRecord[mFR_RECORD_NUM];\n  /* 0x023F20 */ MaskCat_c mask_cat;\n  /* 0x024160 */ Anmret_c return_animal; /* information about villager which moved back in to your town after moving to someone else's town */\n  /* 0x02416C */ LightHouse_c LightHouse; /* info for tracking the light house quest */\n  /* 0x024174 */ u8 insect_term; /* current insect term idx */\n  /* 0x024175 */ u8 insect_term_transition_offset; /* days offset from end of term to begin transition */\n  /* 0x024176 */ u8 gyoei_term; /* current fish term idx */\n  /* 0x024177 */ u8 gyoei_term_transition_offset; /* days offset from end of term to begin transition */\n  /* 0x024178 */ mFAs_GoodField_c good_field; /* field assessment last info */\n  /* 0x024184 */ u8 bg_tex_idx; /* Grass type */\n  /* 0x024185 */ lbRTC_month_t rainbow_month;\n  /* 0x024186 */ lbRTC_day_t rainbow_day;\n  /* 0x024187 */ u8 rainbow_reserved;\n  /* 0x024188 */ u8 _24188;\n  /* 0x024189 */ u8 _24189;\n  /* 0x02418A */ u8 town_day;\n  /* 0x02418B */ u8 _2418B[0x241A0 - 0x2418B];\n  /* 0x0241A0 */ lbRTC_time_c saved_auto_nwrite_time; /* save data notice time used for fishing tourney results? */\n  /* 0x0241A8 */ u8 _241A8[0x26000 - 0x241A8];\n} Save_t;\n\ntypedef struct joint_s {\n  Gfx* model;\n  u8 child;\n  u8 flags;\n  s_xyz translation;\n} cKF_Joint_R_c;\n\ntypedef struct skeleton_s {\n  u8 num_joints;\n  u8 num_shown_joints;\n  cKF_Joint_R_c* joint_table;\n} cKF_Skeleton_R_c;\n\ntypedef struct animation_s {\n  u8* flag_table;\n  s16* data_table;\n  s16* key_table;\n  s16* fixed_table;\n  s16 pad;\n  s16 frames;\n} cKF_Animation_R_c;\n\nenum {\n  cKF_FRAMECONTROL_STOP,\n  cKF_FRAMECONTROL_REPEAT,\n\n  cKF_FRAMECONTROL_NUM\n};\n\ntypedef struct frame_control_s {\n  f32 start_frame;\n  f32 end_frame;\n  f32 max_frames;\n  f32 speed;\n  f32 current_frame;\n  int mode;\n} cKF_FrameControl_c;\n\ntypedef struct skeleton_info_s {\n  cKF_FrameControl_c frame_control;\n  cKF_Skeleton_R_c* skeleton;\n  cKF_Animation_R_c* animation;\n\n  f32 morph_counter;\n  s_xyz* current_joint;\n  s_xyz* target_joint;\n  s_xyz* rotation_diff_table;\n\n  int animation_enabled;\n  xyz_t base_world_position;\n  s16 base_angle_y;\n\n  xyz_t base_model_translation;\n  s_xyz base_model_rotation;\n  s_xyz updated_base_model_rotation;\n\n  f32 fixed_counter;\n  xyz_t model_world_position_correction;\n  s16 model_angle_correction;\n} cKF_SkeletonInfo_R_c;\n\ntypedef struct combine_work_set_s {\n    cKF_SkeletonInfo_R_c* keyframe;\n    u8* anm_check_bit_tbl;\n    s16* anm_const_val_tbl;\n    s16* anm_data_src;\n    s16* anm_key_num;\n    int anm_key_num_idx;\n    int anm_const_val_tbl_idx;\n    int anm_data_src_idx;\n}cKF_SkeletonInfo_R_combine_work_c;\n\ntypedef struct tex_anim_s {\n  s16 frame;\n  s16 timer;\n} cKF_TextureAnimation_c;\n\ntypedef int (*cKF_draw_callback)(GAME*, cKF_SkeletonInfo_R_c*, int, Gfx**, u8*, void*, s_xyz*, xyz_t*);\n\ntypedef union save_u {\n  Save_t save;\n  //u8 raw[0x26000]; /* Temp to force length */\n} Save;\n\ntypedef struct bg_side_contact_s {\n  s16 name;\n  s16 angle;\n} mCoBG_side_contact_c;\n\ntypedef struct bg_contact_s {\n  mCoBG_side_contact_c side_contact[5];\n  int side_count;\n  s16 on_contact_names[5];\n  int on_count;\n} mCoBG_bg_contact_c;\n\ntypedef struct bg_size_s {\n  f32 right_size; // x |   *->\n  f32 left_size; //  x | <-*\n  f32 up_size; //   z | ^\n  f32 down_size; // z | v\n} mCoBG_bg_size_c;\n\ntypedef struct bg_register_s {\n  xyz_t* wpos;\n  xyz_t* last_wpos;\n  s16* angle_y;\n  mCoBG_bg_contact_c* contact;\n  mCoBG_bg_size_c* bg_size;\n  xyz_t* base_ofs;\n  f32 height;\n  u32 attribute;\n  f32 active_dist;\n  f32* scale_percent;\n} mCoBG_bg_regist_c;\n\ntypedef struct furniture_actor_s FTR_ACTOR;\n\nenum {\n  aFTR_SHAPE_TYPEB_90, /* 2x1 (facing up)*/\n  aFTR_SHAPE_TYPEB_180, /* 2x1 [- *] */\n  aFTR_SHAPE_TYPEB_270, /* 2x1 (facing down) */\n  aFTR_SHAPE_TYPEB_0, /* 2x1 [* -] */\n  aFTR_SHAPE_TYPEA, /* 1x1 */\n  aFTR_SHAPE_TYPEC, /* 2x2 */\n\n  aFTR_SHAPE_TYPE_NUM\n};\n\nenum {\n  aFTR_INTERACTION_STORAGE_DRAWERS, // dressers\n  aFTR_INTERACTION_STORAGE_WARDROBE, // double doors\n  aFTR_INTERACTION_STORAGE_CLOSET, // single door\n  aFTR_INTERACTION_MUSIC_DISK,\n  aFTR_INTERACTION_NO_COLLISION,\n  aFTR_INTERACTION_HANIWA,\n  aFTR_INTERACTION_FISH,\n  aFTR_INTERACTION_INSECT,\n  aFTR_INTERACTION_MANNEKIN,\n  aFTR_INTERACTION_UMBRELLA,\n  aFTR_INTERACTION_FOSSIL,\n  aFTR_INTERACTION_FAMICOM,\n  aFTR_INTERACTION_START_DISABLED, // mainly used for TVs to be off when placed\n  // there may be more types, but I didn't see any\n\n  aFTR_INTERACTION_NUM\n};\n\nenum {\n  aFTR_CONTACT_ACTION_CHAIR_UNIDIRECTIONAL, // only can sit from the front\n  aFTR_CONTACT_ACTION_CHAIR_MULTIDIRECTIONAL, // can sit from any direction\n  aFTR_CONTACT_ACTION_CHAIR_SOFA, // cam sit anywhere from the front\n  aFTR_CONTACT_ACTION_BED_SINGLE, // single bed (can't roll)\n  aFTR_CONTACT_ACTION_BED_DOUBLE, // double bed (can roll)\n\n  aFTR_CONTACT_ACTION_NUM\n};\n\ntypedef void (*aFTR_FTR_CT_PROC)(FTR_ACTOR*, u8*);\ntypedef void (*aFTR_FTR_MOVE_PROC)(FTR_ACTOR*, ACTOR*, GAME*, u8*);\ntypedef void (*aFTR_FTR_DRAW_PROC)(FTR_ACTOR*, ACTOR*, GAME*, u8*);\ntypedef void (*aFTR_FTR_DT_PROC)(FTR_ACTOR*, u8*);\ntypedef void (*aFTR_FTR_DMA_PROC)(mActor_name_t, u8*);\n\ntypedef struct ftr_vtbl_s {\n  aFTR_FTR_CT_PROC ct_proc;\n  aFTR_FTR_MOVE_PROC move_proc;\n  aFTR_FTR_DRAW_PROC draw_proc;\n  aFTR_FTR_DT_PROC dt_proc;\n  aFTR_FTR_DMA_PROC dma_proc;\n} aFTR_vtable_c;\n\ntypedef struct ftr_rig_s {\n  cKF_Skeleton_R_c* skeleton;\n  cKF_Animation_R_c* animation;\n  f32 speed;\n} aFTR_rig_c;\n\ntypedef struct ftr_tex_animation_s {\n  u8** animation;\n  int animation_count;\n} aFTR_tex_anim_c;\n\ntypedef struct ftr_profile_s {\n  Gfx* opaque0;\n  Gfx* opaque1;\n  Gfx* translucent0;\n  Gfx* translucent1;\n  u8* texture;\n  u16* palette;\n  aFTR_rig_c* rig;\n  aFTR_tex_anim_c* tex_anim;\n  f32 height;\n  f32 scale;\n  u8 shape; /* aFTR_SHAPE_TYPE* */\n  u8 move_bg_type; /* mCoBG_FTR_TYPE* */\n  u8 check_rotation; /* when non-zero extra checks are performed for items in the way during rotation? */\n  u8 kankyo_map; /* lighting map */\n  u8 contact_action; /* action on contact */\n  u16 interaction_type; /* action when interacting */\n  aFTR_vtable_c* vtable; /* unique furniture functions */\n} aFTR_PROFILE;\n\ntypedef struct furniture_collision_s {\n  f32 start[2]; /* starting xz pos */\n  f32 end[2]; /* ending xz pos */\n  f32 normal[2]; /* xz normal */\n  f32 height; /* collision y */\n  f32 edge_contact_ratio; /* percentage of the xz collision in contact with edge to count as collision */ \n} aFTR_collision_c;\n\n\nstruct furniture_actor_s {\n  u16 name;\n  u16 _004;\n  int id;\n  xyz_t position;\n  xyz_t last_position;\n  xyz_t target_position;\n  int target_distance; /* distance to target position */\n  f32 player_distance; /* distance to the player */\n  f32 angle_y; /* current Y angle */\n  f32 angle_y_target; /* goal Y angle */\n  s16 state;\n  u8 shape_type; /* current size & shape (rotation) */\n  u8 original_shape_type; /* original size & shape (rotation) */\n  xyz_t base_position;\n  aFTR_collision_c edge_collision[4]; /* collision for each edge */\n  s16 collision_direction;\n  int move_bg_idx;\n  mCoBG_bg_regist_c bg_register;\n  mCoBG_bg_contact_c bg_contact;\n  s16 s_angle_y; /* current Y angle but 'binangle' format */\n  f32 collision_scale;\n  u8 switch_bit; /* furniture on/off state */\n  u8 switch_changed_flag; /* signal that the on/off state is toggled */\n  s8 haniwa_step;\n  s16 haniwa_state;\n  cKF_SkeletonInfo_R_c keyframe; /* for actor animations */\n  s_xyz joint[9];\n  s_xyz morph[9];\n  Mtx skeleton_mtx[2][12];\n  cKF_TextureAnimation_c tex_animation; /* used for texture animations like TVs */\n  xyz_t scale;\n  f32 birth_scale_modifier; /* modifies scale for \"birth\" animation */\n  s16 birth_anim_counter;\n  s16 birth_anim_step;\n  s16 rotation_delay_timer;\n  s16 dynamic_work_s[5]; /* reserved for any use by each unique furniture actor */\n  f32 dynamic_work_f[2]; /* reserved for any use by each unique furniture actor */\n  s16 layer; /* layer the furniture actor resides on */\n  s16 _83E;\n  s16 open_music_disk; /* set when a music player is interacted with */\n  s16 dust_timer;\n  mActor_name_t items[mCoBG_LAYER_NUM - 1]; /* used for holding items (music players & wardrobes)  */\n  int _84C;\n  u16* pal_p; /* used for furniture actors with dynamic palettes such as the structure model items */\n  int _854;\n};\n\n/* sizeof(aGYO_Init_c) == 0x18 */\ntypedef struct gyoei_init_s {\n  /* 0x00 */ int fish_type;\n  /* 0x04 */ xyz_t position;\n  /* 0x10 */ int extra_data;\n  /* 0x14 */ GAME* game;\n} aGYO_Init_c;\n\n/* sizeof(aGYO_Clip_c) == 0x1C */\ntypedef struct ac_gyoei_clip_s {\n  /* 0x00 */ int (*make_gyoei_proc)(aGYO_Init_c*);\n  /* 0x04 */ int unused_04; // unused clip proc in AC\n  /* 0x08 */ void (*dt_gyoei_proc)(ACTOR*, GAME*);\n  /* 0x0C */ void (*ballcheck_gyoei_proc)(xyz_t*, s16);\n  /* 0x10 */ void (*hitcheck_gyoei_proc)(xyz_t*, s16);\n  /* 0x14 */ int (*chk_live_gyoei_proc)(int, int);\n  /* 0x18 */ int (*search_near_gyoei_proc)(f32, f32);\n} aGYO_Clip_c;\n\n/* sizeof(aINS_Init_c) == 0x18 */\ntypedef struct insect_init_s {\n  /* 0x00 */ int insect_type;\n  /* 0x04 */ xyz_t position;\n  /* 0x10 */ int extra_data;\n  /* 0x14 */ GAME* game;\n} aINS_Init_c;\n\n/* sizeof(aINS_INSECT_DUMMY_ACTOR) == 0x288 */\ntypedef struct insect_dummy_actor_s {\n  ACTOR actor;\n  /* TODO: finish */\n} aINS_INSECT_DUMMY_ACTOR;\n\ntypedef aINS_INSECT_DUMMY_ACTOR* (*aINS_make_insect_proc)(aINS_Init_c*, int);\ntypedef void (*aINS_make_ant_proc)(aINS_Init_c*, s8, s8);\ntypedef void (*aINS_dt_proc)(ACTOR*, GAME*);\ntypedef aINS_INSECT_DUMMY_ACTOR* (*aINS_make_actor_proc)(GAME*, int, xyz_t*);\ntypedef void (*aINS_set_pl_act_tim_proc)(int, int, int);\ntypedef int (*aINS_chk_live_insect_proc)(int, int, GAME*);\ntypedef void (*aINS_position_move_proc)(ACTOR*);\ntypedef ACTOR* (*aINS_search_near_insect_proc)(GAME*, f32, f32);\n\n/* sizeof(aINS_Clip_c) == 0x50 */\ntypedef struct ac_insect_clip_s {\n  /* 0x00 */ aINS_make_insect_proc make_insect_proc;\n  /* 0x04 */ aINS_make_ant_proc make_ant_proc; // unused clip proc in AC\n  /* 0x08 */ void* unused_08;\n  /* 0x0C */ aINS_dt_proc dt_proc;\n  /* 0x10 */ aINS_make_actor_proc make_actor_proc;\n  /* 0x14 */ aINS_set_pl_act_tim_proc set_pl_act_tim_proc;\n  /* 0x18 */ aINS_chk_live_insect_proc chk_live_insect_proc;\n  /* 0x1C */ aINS_search_near_insect_proc search_near_insect_proc;\n  /* 0x20 */ int pl_action;\n  /* 0x24 */ int pl_action_ut_x;\n  /* 0x28 */ int pl_action_ut_z;\n  /* 0x2C */ aINS_position_move_proc position_move_proc;\n  /* 0x30 */ int ant_spawn_pending;\n  /* 0x34 */ aINS_Init_c ant_spawn_info;\n  /* 0x4C */ u8 ant_ut_x;\n  /* 0x4D */ u8 ant_ut_z;\n} aINS_Clip_c;\n\n#define aSTR_ACTOR_TBL_COUNT 9\n#define aSTR_OVERLAY_SIZE 0x2400\n\nenum structure_type {\n  aSTR_TYPE_HOUSE1,\n  aSTR_TYPE_HOUSE2,\n  aSTR_TYPE_HOUSE3,\n  aSTR_TYPE_HOUSE4,\n  aSTR_TYPE_HOUSE5,\n  aSTR_TYPE_MYHOME,\n  aSTR_TYPE_6,\n  aSTR_TYPE_7,\n  aSTR_TYPE_SHOP1,\n  aSTR_TYPE_SHOP2,\n  aSTR_TYPE_SHOP3,\n  aSTR_TYPE_SHOP4,\n  aSTR_TYPE_POST_OFFICE,\n  aSTR_TYPE_STATION1,\n  aSTR_TYPE_STATION2,\n  aSTR_TYPE_STATION3,\n  aSTR_TYPE_TRAIN0,\n  aSTR_TYPE_TRAIN1,\n  aSTR_TYPE_POLICE_BOX,\n  aSTR_TYPE_FALLS,\n  aSTR_TYPE_FALLSESW,\n  aSTR_TYPE_RESERVE,\n  aSTR_TYPE_SHRINE,\n  aSTR_TYPE_BRSHOP,\n  aSTR_TYPE_BUGGY,\n  aSTR_TYPE_S_CAR,\n  aSTR_TYPE_KAMAKURA, // also used for camping tent\n  aSTR_TYPE_GOZA,\n  aSTR_TYPE_RADIO,\n  aSTR_TYPE_YATAI,\n  aSTR_TYPE_TUKIMI,\n  aSTR_TYPE_TUKIMI2,\n  aSTR_TYPE_MIKUJI,\n  aSTR_TYPE_COUNT,\n  aSTR_TYPE_COUNT02,\n  aSTR_TYPE_SPORTSFAIR_A,\n  aSTR_TYPE_SPORTSFAIR_B,\n  aSTR_TYPE_TURI,\n  aSTR_TYPE_TURI2,\n  aSTR_TYPE_KOINOBORI,\n  aSTR_TYPE_DUMP,\n  aSTR_TYPE_WINDMILL,\n  aSTR_TYPE_LOTUS,\n  aSTR_TYPE_MIKANBOX,\n  aSTR_TYPE_DOUZOU,\n  aSTR_TYPE_TOUDAI,\n  aSTR_TYPE_GHOG,\n  aSTR_TYPE_HTABLE,\n  aSTR_TYPE_MUSEUM,\n  aSTR_TYPE_BRIDGE_A,\n  aSTR_TYPE_50,\n  aSTR_TYPE_NEEDLEWORK_SHOP,\n  aSTR_TYPE_FLAG,\n  aSTR_TYPE_BOAT,\n  aSTR_TYPE_COTTAGE_MY,\n  aSTR_TYPE_COTTAGE_NPC,\n\n  aSTR_TYPE_NUM\n};\n\nenum structure_palette {\n  aSTR_PAL_HOUSE1_A,\n  aSTR_PAL_HOUSE1_B,\n  aSTR_PAL_HOUSE1_C,\n  aSTR_PAL_HOUSE1_D,\n  aSTR_PAL_HOUSE1_E,\n  aSTR_PAL_HOUSE2_A,\n  aSTR_PAL_HOUSE2_B,\n  aSTR_PAL_HOUSE2_C,\n  aSTR_PAL_HOUSE2_D,\n  aSTR_PAL_HOUSE2_E,\n  aSTR_PAL_HOUSE3_A,\n  aSTR_PAL_HOUSE3_B,\n  aSTR_PAL_HOUSE3_C,\n  aSTR_PAL_HOUSE3_D,\n  aSTR_PAL_HOUSE3_E,\n  aSTR_PAL_HOUSE4_A,\n  aSTR_PAL_HOUSE4_B,\n  aSTR_PAL_HOUSE4_C,\n  aSTR_PAL_HOUSE4_D,\n  aSTR_PAL_HOUSE4_E,\n  aSTR_PAL_HOUSE5_A,\n  aSTR_PAL_HOUSE5_B,\n  aSTR_PAL_HOUSE5_C,\n  aSTR_PAL_HOUSE5_D,\n  aSTR_PAL_HOUSE5_E,\n  aSTR_PAL_MYHOME_A,\n  aSTR_PAL_MYHOME_B,\n  aSTR_PAL_MYHOME_C,\n  aSTR_PAL_MYHOME_D,\n  aSTR_PAL_MYHOME_E,\n  aSTR_PAL_MYHOME_F,\n  aSTR_PAL_MYHOME_G,\n  aSTR_PAL_MYHOME_H,\n  aSTR_PAL_MYHOME_I,\n  aSTR_PAL_MYHOME_J,\n  aSTR_PAL_MYHOME_K,\n  aSTR_PAL_MYHOME_L,\n  aSTR_PAL_SHOP1,\n  aSTR_PAL_SHOP2,\n  aSTR_PAL_SHOP3,\n  aSTR_PAL_SHOP4,\n  aSTR_PAL_POST_OFFICE,\n  aSTR_PAL_STATION1_A,\n  aSTR_PAL_STATION1_B,\n  aSTR_PAL_STATION1_C,\n  aSTR_PAL_STATION1_D,\n  aSTR_PAL_STATION1_E,\n  aSTR_PAL_STATION2_A,\n  aSTR_PAL_STATION2_B,\n  aSTR_PAL_STATION2_C,\n  aSTR_PAL_STATION2_D,\n  aSTR_PAL_STATION2_E,\n  aSTR_PAL_STATION3_A,\n  aSTR_PAL_STATION3_B,\n  aSTR_PAL_STATION3_C,\n  aSTR_PAL_STATION3_D,\n  aSTR_PAL_STATION3_E,\n  aSTR_PAL_TRAIN1_A1,\n  aSTR_PAL_TRAIN1_A2,\n  aSTR_PAL_POLICE_BOX,\n  aSTR_PAL_FALLS,\n  aSTR_PAL_FALLSESW,\n  aSTR_PAL_RESERVE,\n  aSTR_PAL_SHRINE,\n  aSTR_PAL_BR_SHOP,\n  aSTR_PAL_BUGGY,\n  aSTR_PAL_S_CAR,\n  aSTR_PAL_KAMAKURA,\n  aSTR_PAL_GOZA,\n  aSTR_PAL_RADIO,\n  aSTR_PAL_YATAI,\n  aSTR_PAL_TUKIMI,\n  aSTR_PAL_TUKIMI2,\n  aSTR_PAL_MIKUJI,\n  aSTR_PAL_COUNT,\n  aSTR_PAL_COUNT02,\n  aSTR_PAL_KAGO_R,\n  aSTR_PAL_KAGO_W,\n  aSTR_PAL_TURI,\n  aSTR_PAL_TURI2,\n  aSTR_PAL_KOINOBORI_A,\n  aSTR_PAL_DUMP,\n  aSTR_PAL_WINDMILL_A,\n  aSTR_PAL_WINDMILL_B,\n  aSTR_PAL_WINDMILL_C,\n  aSTR_PAL_WINDMILL_D,\n  aSTR_PAL_WINDMILL_E,\n  aSTR_PAL_01_LOTUS,\n  aSTR_PAL_MIKANBOX,\n  aSTR_PAL_DOUZOU_DAI,\n  aSTR_PAL_TOUDAI,\n  aSTR_PAL_MUSEUM,\n  aSTR_PAL_BRIDGE_A,\n  aSTR_PAL_TAILOR,\n  aSTR_PAL_FLAG,\n  aSTR_PAL_BOAT,\n  aSTR_PAL_MYHOME_ISLAND,\n  aSTR_PAL_HOUSE_I,\n\n  aSTR_PAL_NUM\n};\n\ntypedef struct actor_structure_control_s STRUCTURE_CONTROL_ACTOR;\ntypedef struct actor_structure_s STRUCTURE_ACTOR;\n\ntypedef STRUCTURE_ACTOR* (*aSTR_SETUP_ACTOR_PROC)(GAME*, mActor_name_t, s16, f32, f32);\ntypedef void (*aSTR_GET_OVERLAY_AREA_PROC)(ACTOR_DLFTBL*);\ntypedef void (*aSTR_FREE_OVERLAY_AREA_PROC)(ACTOR_DLFTBL*);\ntypedef STRUCTURE_ACTOR* (*aSTR_GET_ACTOR_AREA_PROC)();\ntypedef void (*aSTR_FREE_ACTOR_AREA_PROC)(STRUCTURE_ACTOR*);\ntypedef u16* (*aSTR_GET_PAL_SEGMENT_PROC)(s16);\n\ntypedef void (*aSTR_MOVE_PROC)(ACTOR*, GAME*);\n\ntypedef struct actor_overlay_info_s {\n  u8* overlay_p;\n  int used;\n} aSTR_Overlay_info_c;\n\ntypedef struct actor_structure_clip_s {\n  aSTR_SETUP_ACTOR_PROC setup_actor_proc;\n  aSTR_GET_OVERLAY_AREA_PROC get_overlay_area_proc;\n  aSTR_FREE_OVERLAY_AREA_PROC free_overlay_area_proc;\n  aSTR_GET_ACTOR_AREA_PROC get_actor_area_proc;\n  aSTR_FREE_ACTOR_AREA_PROC free_actor_area_proc;\n\n  STRUCTURE_ACTOR* structure_actor_tbl[aSTR_ACTOR_TBL_COUNT];\n  int structure_actor_used_tbl[aSTR_ACTOR_TBL_COUNT];\n\n  aSTR_Overlay_info_c overlay_area[aSTR_ACTOR_TBL_COUNT];\n\n  aSTR_GET_PAL_SEGMENT_PROC get_pal_segment_proc;\n} aSTR_Clip_c;\n\nstruct actor_structure_control_s {\n  ACTOR actor_class;\n  int _174;\n  mActor_name_t str_door_name;\n  u8 reset;\n};\n\ntypedef void (*aAL_DATA_INIT_PROC)(GAME_PLAY*);\n\ntypedef struct animal_logo_clip_s {\n  aAL_DATA_INIT_PROC data_init_proc;\n} aAL_Clip_c;\n\ntypedef struct npc_actor_s NPC_ACTOR;\n\n#define aNPC_SPNPC_BIT_CURATOR 0\n#define aNPC_SPNPC_BIT_EV_SONCHO 5\n\n#define aNPC_SPNPC_BIT_GET(field, bit) (((field) >> (bit)) & 1)\n#define aNPC_SPNPC_BIT_SET(field, bit) ((field) |= (1 << (bit)))\n#define aNPC_SPNPC_BIT_CLR(field, bit) ((field) &= ~(1 << (bit)))\n\ntypedef struct ac_npc_clip_s aNPC_Clip_c;\n\ntypedef struct npc_draw_data_s {\n  s16 model_bank;\n  s16 texture_bank;\n  u8 _04[0x68]; // TODO\n} aNPC_draw_data_c;\n\nenum {\n  aNPC_ATTENTION_TYPE_NONE,\n  aNPC_ATTENTION_TYPE_ACTOR,\n  aNPC_ATTENTION_TYPE_POSITION,\n\n  aNPC_ATTENTION_TYPE_NUM\n};\n\nenum {\n  aNPC_THINK_WAIT,\n  aNPC_THINK_WANDER,\n  aNPC_THINK_WANDER2,\n  aNPC_THINK_GO_HOME,\n  aNPC_THINK_INTO_HOUSE,\n  aNPC_THINK_LEAVE_HOUSE,\n  aNPC_THINK_IN_BLOCK,\n  aNPC_THINK_PITFALL,\n  aNPC_THINK_SLEEP,\n  aNPC_THINK_SPECIAL,\n\n  aNPC_THINK_NUM\n};\n\nenum {\n  aNPC_THINK_TYPE_INIT,\n  aNPC_THINK_TYPE_CHK_INTERRUPT,\n  aNPC_THINK_TYPE_MAIN,\n\n  aNPC_THINK_TYPE_NUM\n};\n\ntypedef void (*aNPC_TALK_REQUEST_PROC)(ACTOR*, GAME*);\ntypedef int (*aNPC_TALK_INIT_PROC)(ACTOR*, GAME*);\ntypedef int (*aNPC_TALK_END_CHECK_PROC)(ACTOR*, GAME*);\n\ntypedef struct npc_ct_data_s {\n  mActor_proc move_proc;\n  mActor_proc draw_proc;\n  int _08;\n  aNPC_TALK_REQUEST_PROC talk_request_proc;\n  aNPC_TALK_INIT_PROC talk_init_proc;\n  aNPC_TALK_END_CHECK_PROC talk_end_check_proc;\n  int _18;\n} aNPC_ct_data_c;\n\ntypedef int (*aNPC_SETUP_ACTOR_PROC)(GAME_PLAY*, mActor_name_t, s8, int, s16, int, int, int, int);\ntypedef void (*aNPC_DMA_DRAW_DATA_PROC)(aNPC_draw_data_c*, mActor_name_t);\ntypedef void (*aNPC_FREE_OVERLAY_AREA_PROC)(ACTOR_DLFTBL*);\ntypedef ACTOR* (*aNPC_GET_ACTOR_AREA_PROC)(size_t, const char*, int);\ntypedef void (*aNPC_FREE_ACTOR_AREA_PROC)(ACTOR*);\ntypedef void (*aNPC_SET_ATTENTION_REQUEST_PROC)(u8, ACTOR*, xyz_t*);\ntypedef int (*aNPC_BIRTH_CHECK_PROC)(ACTOR*, GAME*);\ntypedef void (*aNPC_CT_PROC)(ACTOR*, GAME*, aNPC_ct_data_c*);\ntypedef void (*aNPC_DT_PROC)(ACTOR*, GAME*);\ntypedef void (*aNPC_SAVE_PROC)(ACTOR*, GAME*);\ntypedef void (*aNPC_INIT_PROC)(ACTOR*, GAME*);\ntypedef void (*aNPC_MOVE_PROC)(ACTOR*, GAME*);\ntypedef void (*aNPC_MOVE_BEFORE_PROC)(ACTOR*, GAME*);\ntypedef void (*aNPC_MOVE_AFTER_PROC)(ACTOR*, GAME*);\ntypedef void (*aNPC_DRAW_PROC)(ACTOR*, GAME*);\n\ntypedef void (*aNPC_REBUILD_DMA_PROC)();\ntypedef void (*aNPC_ANIMATION_INIT_PROC)(ACTOR*, int, int);\ntypedef int (*aNPC_CLIP_THINK_PROC)(NPC_ACTOR*, GAME_PLAY*, int, int);\n\ntypedef int (*aNPC_FORCE_CALL_REQ_PROC)(NPC_ACTOR*, int);\n\nstruct ac_npc_clip_s {\n  /* 0x000 */ aNPC_SETUP_ACTOR_PROC setupActor_proc;\n  /* 0x004 */ void* _004;\n  /* 0x008 */ aNPC_FREE_OVERLAY_AREA_PROC free_overlay_area_proc;\n  /* 0x00C */ aNPC_GET_ACTOR_AREA_PROC get_actor_area_proc;\n  /* 0x010 */ aNPC_FREE_ACTOR_AREA_PROC free_actor_area_proc;\n  /* 0x014 */ aNPC_DMA_DRAW_DATA_PROC dma_draw_data_proc;\n  /* 0x018 */ aNPC_SET_ATTENTION_REQUEST_PROC set_attention_request_proc;\n  /* 0x01C */ void* _01C[(0x0CC - 0x01C) / sizeof(void*)];\n  /* 0x0CC */ aNPC_BIRTH_CHECK_PROC birth_check_proc;\n  /* 0x0D0 */ aNPC_CT_PROC ct_proc;\n  /* 0x0D4 */ aNPC_DT_PROC dt_proc;\n  /* 0x0D8 */ aNPC_SAVE_PROC save_proc;\n  /* 0x0DC */ aNPC_INIT_PROC init_proc;\n  /* 0x0E0 */ aNPC_MOVE_PROC move_proc;\n  /* 0x0E4 */ aNPC_MOVE_BEFORE_PROC move_before_proc;\n  /* 0x0E8 */ aNPC_MOVE_AFTER_PROC move_after_proc;\n  /* 0x0EC */ void* _0EC;\n  /* 0x0F0 */ void* _0F0;\n  /* 0x0F4 */ aNPC_DRAW_PROC draw_proc;\n  /* 0x0F8 */ aNPC_REBUILD_DMA_PROC rebuild_dma_proc;\n  /* 0x0FC */ void* _0FC[(0x114 - 0x0FC) / sizeof(void*)];\n  /* 0x114 */ aNPC_ANIMATION_INIT_PROC animation_init_proc;\n  /* 0x118 */ void* _118;\n  /* 0x11C */ void* _11C;\n  /* 0x120 */ aNPC_CLIP_THINK_PROC think_proc;\n  /* 0x124 */ aNPC_FORCE_CALL_REQ_PROC force_call_req_proc;\n  /* 0x128 */ void* _128;\n};\n\ntypedef struct npc_info_s {\n  Animal_c* animal;\n  mNpc_NpcList_c* list;\n  mNPS_schedule_c* schedule;\n  mNpc_EventNpc_c* event;\n  mNpc_MaskNpc_c* mask;\n  mActor_name_t npc_name;\n} NpcActorInfo_c;\n\n/* TODO: draw data */\ntypedef struct npc_draw_info_s {\n  /* 0x000 */ u8 _000[0x584 - 0x000];\n  /* 0x584 */ int texture_bank_idx;\n  /* 0x588 */ u8 _588[0x5BD - 0x588];\n  /* 0x5BD */ u8 _5BD;\n  /* 0x5BE */ u8 _5BE[0x630 - 0x5BE];\n} aNPC_draw_info_c;\n\ntypedef void (*aNPC_THINK_PROC)(NPC_ACTOR*, GAME_PLAY*, int);\n\n#define aNPC_THINK_INTERRUPT_FRIENDSHIP (1 << 0)\n#define aNPC_THINK_INTERRUPT_FATIGUE    (1 << 1)\n#define aNPC_THINK_INTERRUPT_OBSTANCE   (1 << 2)\n#define aNPC_THINK_INTERRUPT_ENTRANCE   (1 << 3)\n\ntypedef struct npc_think_info_s {\n  int idx;\n  u8 end_flag;\n  u8 force_call_flag;\n  u16 force_call_timer;\n  int force_call_msg_no;\n  u8 force_call_camera_type;\n  aNPC_THINK_PROC think_proc;\n  u32 interrupt_flags;\n} aNPC_think_info_c;\n\ntypedef void (*aNPC_SCHEDULE_PROC)(NPC_ACTOR*, GAME_PLAY*, int);\n\ntypedef struct npc_schedule_info_s {\n  u8 type;\n  u8 state;\n  mNPS_schedule_c schedule;\n  aNPC_SCHEDULE_PROC schedule_proc;\n} aNPC_schedule_info_c;\n\nenum {\n  aNPC_ACT_OBJ_NONE,\n  aNPC_ACT_OBJ_PLAYER,\n  aNPC_ACT_OBJ_ANY_NPC,\n  aNPC_ACT_OBJ_TARGET_NPC,\n  aNPC_ACT_OBJ_4,\n  aNPC_ACT_OBJ_5,\n  aNPC_ACT_OBJ_INSECT,\n  aNPC_ACT_OBJ_FISH,\n\n  aNPC_ACT_OBJ_NUM\n};\n\ntypedef void (*aNPC_ACTION_PROC)(NPC_ACTOR*, GAME_PLAY*, int);\n\n#define aNPC_ACTION_END_STEP 0xFF\n\ntypedef struct npc_action_s {\n  u8 priority;\n  u8 idx;\n  u8 step;\n  u8 type;\n  u8 prev_priority;\n  u8 prev_step;\n  s16 act_timer;\n  u8 feel;\n  u8 act_obj;\n  u16 act_obj_id;\n  s16 move_x;\n  s16 move_z;\n  aNPC_ACTION_PROC act_proc;\n} aNPC_action_c;\n\ntypedef struct npc_request_s {\n  u8 act_priority;\n  u8 act_idx;\n  u8 act_type;\n  u16 act_args[6];\n  u8 umb_flag;\n  u8 _11;\n  u8 head_priority;\n  u8 head_type;\n  ACTOR* head_target;\n  xyz_t head_pos;\n} aNPC_request_c;\n\n#define aNPC_COND_DEMO_SKIP_MOVE_RANGE_CHECK  (1 <<  0) /* 0x0001 */\n#define aNPC_COND_DEMO_SKIP_MOVE_CIRCLE_REV   (1 <<  1) /* 0x0002 */\n#define aNPC_COND_DEMO_SKIP_MOVE_Y            (1 <<  2) /* 0x0004 */\n#define aNPC_COND_DEMO_SKIP_OBJ_COL_CHECK     (1 <<  3) /* 0x0008 */\n#define aNPC_COND_DEMO_SKIP_BGCHECK           (1 <<  4) /* 0x0010 */\n#define aNPC_COND_DEMO_SKIP_FORWARD_CHECK     (1 <<  5) /* 0x0020 */\n#define aNPC_COND_DEMO_SKIP_ITEM              (1 <<  6) /* 0x0040 */\n#define aNPC_COND_DEMO_SKIP_TALK_CHECK        (1 <<  7) /* 0x0080 */\n#define aNPC_COND_DEMO_SKIP_HEAD_LOOKAT       (1 <<  8) /* 0x0100 */\n#define aNPC_COND_DEMO_SKIP_ENTRANCE_CHECK    (1 <<  9) /* 0x0200 */\n#define aNPC_COND_DEMO_SKIP_KUTIPAKU          (1 << 10) /* 0x0400 */\n#define aNPC_COND_DEMO_SKIP_FOOTSTEPS         (1 << 11) /* 0x0800 */\n#define aNPC_COND_DEMO_SKIP_FEEL_CHECK        (1 << 12) /* 0x1000 */\n#define aNPC_COND_DEMO_SKIP_LOVE_CHECK        (1 << 13) /* 0x2000 */\n#define aNPC_COND_DEMO_SKIP_FOOTSTEPS_VFX     (1 << 14) /* 0x4000 */\n#define aNPC_COND_DEMO_SKIP_UZAI_CHECK        (1 << 15) /* 0x8000 */\n\ntypedef struct npc_condition_s {\n  u8 hide_flg;\n  u8 hide_request;\n  u8 action;\n  u8 talk_condition;\n  u8 greeting_flag;\n  u8 entrance_flag;\n  u16 fatigue;\n  int feel_tim;\n  int _0C;\n  u32 demo_flg;\n  u32 talk_demo_flg_save;\n  u32 trans_demo_flg_save;\n  u8 appear_flag;\n  u8 appear_rotation;\n  u8 pitfall_flag;\n  u32 actor_state_save;\n  int _24;\n  int _28;\n  int _2C;\n  s8* friendship;\n  int over_friendship;\n  mActor_name_t* under_fg_p;\n  int ut_x;\n  int ut_z;\n} aNPC_condition_info_c;\n\ntypedef struct npc_uzai_s {\n  int step;\n  u8 tool;\n  u8 flag;\n  u8 cross;\n} aNPC_uzai_c;\n\ntypedef struct npc_hand_s {\n  u8 item_type;\n  u8 requested_item_type;\n  mActor_name_t item;\n  u8 after_mode;\n  u8 present_flag;\n  u8 umbrella_disabled_flag;\n  u8 umbrella_type;\n  ACTOR* item_actor_p;\n  ACTOR* prev_item_actor_p;\n  xyz_t pos;\n} aNPC_hand_c;\n\ntypedef struct npc_head_s {\n  s16 angle_x;\n  s16 angle_y;\n  s16 angle_add_x;\n  s16 angle_add_y;\n  s16 _08;\n  u8 lock_flag;\n  u8 target_type;\n  ACTOR* target;\n  xyz_t pos;\n} aNPC_head_c;\n\nenum {\n  aNPC_FOOT_LEFT,\n  aNPC_FOOT_RIGHT,\n\n  aNPC_FOOT_NUM\n};\n\ntypedef struct npc_movement_s {\n  f32 max_speed;\n  f32 acceleration;\n  f32 deceleration;\n  f32 target_pos_x;\n  f32 target_pos_z;\n  f32 avoid_pos_x;\n  f32 avoid_pos_z;\n  s16 move_timer;\n  u8 avoid_direction;\n  u8 range_type;\n  f32 range_center_x;\n  f32 range_center_z;\n  f32 range_radius;\n  s16 mv_angl;\n  s16 mv_add_angl;\n  f32 arrival_area_radius;\n  ACTOR* target;\n  s8 movement_ut_x;\n  s8 movement_ut_z;\n  s16 body_angle;\n  u8 override_body_angle_flag;\n  u8 demo_move_timer;\n} aNPC_movement_c;\n\ntypedef struct npc_collision_s {\n  ClObjPipe_c pipe;\n  f32 BGcheck_radius;\n  u8 collision_flag;\n  u8 priority;\n  u8 turn_flag;\n  u16 _24;\n  s16 turn_angle;\n  f32 bg_rev_add;\n} aNPC_collision_c;\n\ntypedef struct npc_actor_talk_info_s {\n  aNPC_TALK_REQUEST_PROC talk_request_proc;\n  aNPC_TALK_INIT_PROC talk_init_proc;\n  aNPC_TALK_END_CHECK_PROC talk_end_check_proc;\n  u8 type;\n  u8 default_act;\n  u8 demo_code;\n  u8 turn;\n  s16 default_animation;\n  s16 default_turn_animation;\n  s16 melody_inst;\n  s16 npc_voice_id;\n  u8 feel;\n  u8 memory;\n  u8 kutipaku_timer; // frames of mouth movement animation\n} aNPC_talk_info_c;\n\ntypedef struct npc_accessory_s {\n  s16 type;\n  s16 pos_joint_idx; // might be better suited as base_joint_idx?\n  ACTOR* accessory;\n} aNPC_accessory_c;\n\n/* Used for think, schedule, action, & talk */\ntypedef void (*aNPC_PROC)(NPC_ACTOR* npc_actorx, GAME_PLAY* play, int schedule_idx);\ntypedef void (*aNPC_SUB_PROC)(NPC_ACTOR* npc_actorx, GAME_PLAY* play);\n\nstruct npc_actor_s {\n  ACTOR actor_class;\n  int _174;\n  int _178;\n  NpcActorInfo_c npc_info;\n  aNPC_draw_info_c draw;\n  aNPC_think_info_c think;\n  aNPC_schedule_info_c schedule;\n  aNPC_action_c action;\n  aNPC_request_c request;\n  f32 eye_y;\n  aNPC_condition_info_c condition_info;\n  aNPC_uzai_c uzai;\n  aNPC_hand_c left_hand;\n  aNPC_hand_c right_hand;\n  aNPC_head_c head;\n  xyz_t feet[aNPC_FOOT_NUM];\n  mActor_proc move_proc;\n  mActor_proc draw_proc;\n  ACTOR* palActor;\n  int palActorIgnoreTimer;\n  aNPC_movement_c movement;\n  aNPC_collision_c collision;\n  aNPC_talk_info_c talk_info;\n  aNPC_accessory_c accessory;\n  int act_react_tool_timer;\n  int _98C;\n  int _990;\n};\n\ntypedef struct npc_control_cloth_s {\n  u8 dma_flag;\n  u8 init_flag;\n  s16 _02;\n  mActor_name_t cloth_item;\n  u8 in_use_count;\n  Object_Bank_c texture_bank;\n  Object_Bank_c palette_bank;\n} aNPC_cloth_c;\n\ntypedef struct npc_control_actor_s {\n  ACTOR* actor_class;\n  aNPC_cloth_c cloth[10];\n  u8 _8F4[0x9D8 - 0x8F4]; // TODO\n} NPC_CONTROL_ACTOR;\n\nextern ACTOR_PROFILE Npc_Profile;\n\ntypedef struct aprilfool_event_save_data_s {\n  u16 talk_bitfield[PLAYER_NUM];\n} aAPC_event_save_data_c;\n\ntypedef int (*aAPC_TALK_CHK_PROC)(mActor_name_t);\ntypedef void (*aAPC_TALK_SET_PROC)(mActor_name_t);\ntypedef int (*aAPC_GET_MSG_NUM_PROC)(mActor_name_t, int);\n\ntypedef struct aprilfool_control_clip_s {\n  aAPC_TALK_CHK_PROC talk_chk_proc;\n  aAPC_TALK_SET_PROC talk_set_proc;\n  aAPC_GET_MSG_NUM_PROC get_msg_num_proc;\n  aAPC_event_save_data_c* event_save_data_p;\n} aAPC_Clip_c;\n\nenum {\n  eEC_LIGHT_COLOR_DISABLED,\n  eEC_LIGHT_COLOR_INCREASING,\n  eEC_LIGHT_COLOR_MAXIMUM,\n  eEC_LIGHT_COLOR_DECREASING,\n\n  eEC_LIGHT_COLOR_NUM\n};\n\nenum effect_type {\n  eEC_EFFECT_SHOCK,\n  eEC_EFFECT_DUST,\n  eEC_EFFECT_MUKA,\n  eEC_EFFECT_WARAU,\n  /* TODO: finish */\n  eEC_DOUZOU_LIGHT = 101,\n  eEC_HEM_LIGHT = 123,\n  \n  eEC_EFFECT_NUM = 126\n};\n\n\ntypedef void (*eEC_NAME2EFFECTMAKE_PROC)(int, xyz_t, int, short, GAME*, u16, s16, s16);\n\ntypedef int (*eEC_EFFECTLIGHTSTATUS_PROC)(rgba_t*, int*); // returns eEC_LIGHT_COLOR_*\n\ntypedef struct effect_control_clip_s {\n  /* 0x00 */ eEC_NAME2EFFECTMAKE_PROC effect_make_proc;\n  /* 0x04 */ u8 _04[0x3C - 0x04];\n  /* 0x3C */ eEC_EFFECTLIGHTSTATUS_PROC effect_light_status;\n  /* 0x40 */ void* _40;\n  /* 0x44 */ void* _44;\n} eEC_EffectControl_Clip_c;\n\ntypedef struct manekin_actor_s {\n  xyz_t wpos;\n  int ut_x;\n  int ut_z;\n  mActor_name_t item;\n  u8* tex_p;\n  u8* palette_p;\n  mCoBG_bg_regist_c bg_regist;\n  int move_bg_num;\n  int _4C;\n  int naked;\n} MANEKIN_ACTOR;\n\ntypedef struct shop_manekin_actor_s SHOP_MANEKIN_ACTOR;\n\ntypedef void (*aSM_MANEKIN_DMA_AGAIN_PROC)();\ntypedef void (*aSM_CHANGE2NAKEDMANEKIN_PROC)(int ut_x, int ut_z);\ntypedef void (*aSM_NAKED2CLOTH_PROC)(int ut_x, int ut_z);\n\ntypedef struct shop_manekin_clip_s {\n  SHOP_MANEKIN_ACTOR* shop_manekin_actor_p;\n  aSM_MANEKIN_DMA_AGAIN_PROC manekin_dma_again_proc;\n  aSM_CHANGE2NAKEDMANEKIN_PROC change2naked_manekin_proc;\n  aSM_NAKED2CLOTH_PROC naked2cloth_proc;\n} aSM_Clip_c;\n\nstruct shop_manekin_actor_s {\n  ACTOR actor_class;\n  int current_block_manekin_num;\n  MANEKIN_ACTOR* manekin_actors;\n  int now_block_x;\n  int now_block_z;\n  aSM_Clip_c clip;\n  u8* naked_tex_p;\n  u8* naked_pal_p;\n  int _19C;\n};\n\ntypedef struct shop_indoor_actor_s SHOP_INDOOR_ACTOR;\n\ntypedef int (*aSI_CHANGE_WALL_PROC)(mActor_name_t item);\ntypedef int (*aSI_CHANGE_CARPET_PROC)(mActor_name_t item);\ntypedef void (*aSI_INDOOR_DMA_AGAIN_PROC)();\ntypedef void (*aSI_CHANGE2DEFAULT_PROC)();\n\ntypedef struct shop_indoor_clip_s {\n  SHOP_INDOOR_ACTOR* shop_indoor_actor;\n  aSI_CHANGE_WALL_PROC change_wall_proc;\n  aSI_CHANGE_CARPET_PROC change_carpet_proc;\n  aSI_INDOOR_DMA_AGAIN_PROC indoor_dma_again_proc;\n  aSI_CHANGE2DEFAULT_PROC change2default_proc;\n} aSI_Clip_c;\n\nstruct shop_indoor_actor_s {\n  ACTOR actor_class;\n  s16 floor_default_tex_no;\n  s16 wall_default_tex_no;\n  s16 floor_data_idx;\n  s16 wall_data_idx;\n  int _17C;\n  u8* floor_data_p[2];\n  u8* wall_data_p[2];\n  s16 shop_idx;\n  aSI_Clip_c clip;\n  int fukubiki_active;\n};\n\ntypedef struct my_room_actor_s MY_ROOM_ACTOR;\n\ntypedef struct my_room_clock_info_s {\n  int tick0; /* set on frame 15 */\n  int tick1; /* set on frame 45 */\n  int tick_stop; /* set on frame 0 */\n  int frame; /* 0-119 */\n} aMR_clock_info_c;\n\ntypedef int (*aMR_JUDGE_BREED_NEW_FTR_PROC)(GAME_PLAY* play, u16 ftr_no, int* ut_x, int* ut_z, u16* rotation, int* square_offset, int* layer);\ntypedef mActor_name_t (*aMR_SEARCH_PICKUP_FURNITURE_PROC)(GAME_PLAY* play);\ntypedef void (*aMR_FURNITURE2ITEMBAG_PROC)(GAME_PLAY* play);\ntypedef int (*aMR_JUDGE_PLAYER_ACTION_PROC)(xyz_t* wpos0, xyz_t* wpos1, int ftr_actor_idx);\ntypedef void (*aMR_PLAYER_MOVE_FURNITURE_PROC)(int ftr_actor_idx, xyz_t* wpos);\ntypedef int (*aMR_FTR_ID_2_WPOS_PROC)(xyz_t* wpos, int ftr_id);\ntypedef int (*aMR_UNIT_NUM_2_FTR_ITEMNO_FTRID_PROC)(mActor_name_t* ftr_item_no, int* ftr_id, int ut_x, int ut_z, s16 layer);\ntypedef void (*aMR_FTR_ID_2_EXTINGUISH_FURNITURE_PROC)(int ftr_id);\ntypedef void (*aMR_REDMA_FTR_BANK_PROC)();\ntypedef int (*aMR_RESERVE_FURNITURE_PROC)(GAME_PLAY* play, u16 ftr_no, int judge_res, int ut_x, int ut_z, u16 rotation, int square_offset, int layer);\ntypedef int (*aMR_COUNT_FRIEND_FURNITURE_PROC)(FTR_ACTOR* ftr_actor, u8 switch_on);\ntypedef int (*aMR_JUDGE_PLACE_2ND_LAYER_PROC)(int ut_x, int ut_z);\ntypedef void (*aMR_OPEN_CLOSE_COMMON_MOVE_PROC)(FTR_ACTOR* ftr_actor, ACTOR* actor, GAME* game, f32 start_frame, f32 end_frame);\n\ntypedef struct my_room_clip_s {\n  MY_ROOM_ACTOR* my_room_actor_p;\n  aMR_JUDGE_BREED_NEW_FTR_PROC judge_breed_new_ftr_proc;\n  aMR_SEARCH_PICKUP_FURNITURE_PROC search_pickup_ftr_proc;\n  aMR_FURNITURE2ITEMBAG_PROC ftr2itemBag_proc;\n  aMR_JUDGE_PLAYER_ACTION_PROC judge_player_action_proc;\n  aMR_PLAYER_MOVE_FURNITURE_PROC player_move_ftr_proc;\n  aMR_FTR_ID_2_WPOS_PROC ftrId2wpos_proc;\n  aMR_UNIT_NUM_2_FTR_ITEMNO_FTRID_PROC unitNum2ftrItemNoftrId_proc;\n  aMR_FTR_ID_2_EXTINGUISH_FURNITURE_PROC ftrId2extinguishFtr_proc;\n  aMR_REDMA_FTR_BANK_PROC redma_ftr_bank_proc;\n  aMR_RESERVE_FURNITURE_PROC reserve_ftr_proc;\n  aMR_COUNT_FRIEND_FURNITURE_PROC count_friend_ftr_proc;\n  aMR_JUDGE_PLACE_2ND_LAYER_PROC judge_place_2nd_layer_proc;\n  aMR_OPEN_CLOSE_COMMON_MOVE_PROC open_close_common_move_proc;\n  /* TODO: function definitions */\n  void* get_bed_action_proc;\n  void* mini_disk_common_move_proc;\n  void* famicom_emum_common_move_proc;\n  void* set_leaf_proc;\n  void* ftr2leaf_proc;\n  void* leaf_start_pos_proc;\n  void* pickup_ftr_layer_proc;\n  void* leaf_pickuped_proc;\n  void* ftrNo2bankAddress_proc;\n  void* call_sit_down_ongen_pos_se_proc;\n  aMR_clock_info_c* clock_info_p; /* used for playing the clock tick? sfx */\n  void* sound_melody_proc;\n  void* check_danna_kill_proc;\n} aMR_Clip_c;\n\ntypedef struct my_indoor_actor_s MY_INDOOR_ACTOR;\n\ntypedef mActor_name_t (*aMI_CHANGE_WALL_PROC)(mActor_name_t item);\ntypedef mActor_name_t (*aMI_CHANGE_CARPET_PROC)(mActor_name_t item);\ntypedef void (*aMI_INDOOR_DMA_AGAIN_PROC)();\ntypedef void (*aMI_CHANGE_2_DEFAULT_PROC)();\ntypedef void (*aMI_WALL_IDX_2_CHANGE_WALL_PROC)(int wall_idx, int is_original_design);\ntypedef void (*aMI_FLOOR_IDX_2_CHANGE_FLOOR_PROC)(int floor_idx, int is_original_design);\n\ntypedef struct my_room_actor_clip_s {\n  MY_INDOOR_ACTOR* my_indoor_actor_p;\n  aMI_CHANGE_WALL_PROC change_wall_proc;\n  aMI_CHANGE_CARPET_PROC change_carpet_proc;\n  aMI_INDOOR_DMA_AGAIN_PROC indoor_dma_again_proc;\n  aMI_CHANGE_2_DEFAULT_PROC change_2_default_proc;\n  aMI_WALL_IDX_2_CHANGE_WALL_PROC wall_idx_2_change_wall_proc;\n  aMI_FLOOR_IDX_2_CHANGE_FLOOR_PROC floor_idx_2_change_floor_proc;\n} aMI_Clip_c;\n\ntypedef struct my_indoor_data_bank_s {\n  u8 _00[0x0C - 0x00];\n  u8* floor_data_p;\n  u8* wall_data_p;\n  int _14;\n} aMI_bank_c;\n\nstruct my_indoor_actor_s {\n  ACTOR actor_class;\n  s16 floor_num;\n  s16 wall_num;\n  int floor_is_original_design;\n  int wall_is_original_design;\n  s16 floor_bank_idx;\n  s16 wall_bank_idx;\n  aMI_bank_c banks[2];\n  int _1B4;\n  aMI_Clip_c clip;\n  s16 room_kind;\n  int change_wall_flag;\n  int reserved_wall_num;\n  int reserved_wall_is_original_design;\n  int change_floor_flag;\n  int reserved_floor_num;\n  int reserved_floor_is_original_design;\n  int room_step[4];\n  int _200; // very small chance this is part of room_step\n  int house_floor_no;\n};\n\ntypedef struct arrange_room_actor_s ARRANGE_ROOM_ACTOR;\n\ntypedef void (*aAR_REDMA_PROC)();\n\ntypedef struct arrange_room_actor_clip_s {\n  ARRANGE_ROOM_ACTOR* arrange_room_actor_p;\n  aAR_REDMA_PROC redma_proc;\n} aAR_Clip_c;\n\nstruct arrange_room_actor_s {\n  ACTOR actor_class;\n  int _174;\n  u8* wall_data_p;\n  int wall_num;\n  u8* floor_data_p;\n  int floor_num;\n  aAR_Clip_c clip;\n};\n\ntypedef struct shop_umbrella_actor_s SHOP_UMBRELLA_ACTOR;\n\ntypedef void (*aShopUmbrella_UMBRELLA_DMA_AGAIN_PROC)();\ntypedef void (*aShopUmbrella_DELETE_UMBRELLA_PROC)(int ut_x, int ut_z);\n\ntypedef struct shop_umbrella_actor_clip_s {\n  SHOP_UMBRELLA_ACTOR* shop_umbrella_actor_p;\n  aShopUmbrella_UMBRELLA_DMA_AGAIN_PROC umbrella_dma_again_proc;\n  aShopUmbrella_DELETE_UMBRELLA_PROC delete_umbrella_proc;\n} aShopUmbrella_Clip_c;\n\ntypedef struct umbrella_actor_s {\n  xyz_t wpos;\n  int ut_x;\n  int ut_z;\n  mActor_name_t item;\n  int umbrella_idx;\n  int _1C;\n  mCoBG_bg_regist_c bg_regist;\n  int move_bg_idx;\n  int _4C;\n  s16 state;\n  f32 scale;\n} aShopUmbrella_umbrella_c;\n\nstruct shop_umbrella_actor_s {\n  ACTOR actor_class;\n  int umbrella_num;\n  aShopUmbrella_umbrella_c* umbrellas;\n  int bx;\n  int bz;\n  aShopUmbrella_Clip_c clip;\n};\n\ntypedef struct hand_over_item_actor_s HANDOVERITEM_ACTOR;\n\ntypedef ACTOR* (*aHOI_BIRTH_PROC)(mActor_name_t, int, int, ACTOR*);\ntypedef ACTOR* (*aHOI_CHG_MASTER_PROC)(ACTOR*);\ntypedef int (*aHOI_CHG_REQUEST_MODE_PROC)(ACTOR*, int);\ntypedef void (*aHOI_REBUILD_DMA_PROC)(Object_Exchange_c*, ACTOR*); /* yoinked from DnM, unused in AC */\n\ntypedef struct hand_over_item_clip_s {\n  aHOI_BIRTH_PROC birth_proc;\n  aHOI_CHG_MASTER_PROC chg_master_proc;\n  aHOI_CHG_REQUEST_MODE_PROC chg_request_mode_proc;\n  u8 request_mode;\n  u8 player_after_mode;\n  mActor_name_t item;\n  ACTOR* master_actor;\n  ACTOR* target_actor;\n  u8 present_flag;\n  u8 master_changed_flag;\n  HANDOVERITEM_ACTOR* handOverItem_p;\n  aHOI_REBUILD_DMA_PROC rebuild_dma_proc;\n} aHOI_Clip_c;\n\ntypedef struct actor_structure_s STRUCTURE_ACTOR;\n\ntypedef struct background_item_shadow_s {\n  u32 vtx_num;\n  u8* vtx_fix_flags;\n  f32 size;\n  Vtx* vtx;\n  Gfx* gfx;\n} bIT_ShadowData_c;\n\ntypedef void (*bIT_SHADOW_DRAW_PROC)(GAME*, bIT_ShadowData_c*, int);\n\ntypedef int (*bIT_FRUIT_SET_PROC)(mActor_name_t item, int ut_x, int ut_z, s16 p0, s16 p1);\ntypedef void (*bIT_ITEM_TREE_FRUIT_DROP_PROC)(mActor_name_t item, int ut_x, int ut_z, xyz_t* pos);\n\n\ntypedef struct background_item_clip_s {\n  void* _00;\n  bIT_SHADOW_DRAW_PROC draw_shadow_proc;\n  void* _08[(0x30 - 0x08) / sizeof(void*)];\n  bIT_FRUIT_SET_PROC fruit_set_proc;\n  void* _34;\n  bIT_ITEM_TREE_FRUIT_DROP_PROC item_tree_fruit_drop_proc;\n  void* _3C[(0x54 - 0x3C) / sizeof(void*)];\n} bIT_Clip_c;\n\ntypedef void (*CLIP_NONE_PROC)();\n\n/* sizeof(Clip_c) == 0x104 */\ntypedef struct clip_s {\n  /* 0x000 */ void* _000[(0x020 - 0x000) / sizeof(void*)];\n  /* 0x020 */ int arrange_ftr_num;\n  /* 0x024 */ void* _024[(0x040 - 0x024) / sizeof(void*)];\n  /* 0x040 */ aNPC_Clip_c* npc_clip;\n  /* 0x044 */ void* _044[(0x060 - 0x044) / sizeof(void*)];\n  /* 0x060 */ aSM_Clip_c* shop_manekin_clip;\n  /* 0x064 */ void* _064;\n  /* 0x068 */ CLIP_NONE_PROC _068;\n  /* 0x06C */ void* _06C;\n  /* 0x070 */ aSI_Clip_c* shop_indoor_clip;\n  /* 0x074 */ bIT_Clip_c* bg_item_clip;\n  /* 0x078 */ void* _078;\n  /* 0x07C */ aINS_Clip_c* insect_clip;\n  /* 0x080 */ aMR_Clip_c* my_room_clip;\n  /* 0x084 */ void* _084;\n  /* 0x088 */ aHOI_Clip_c* handOverItem_clip;\n  /* 0x08C */ aSTR_Clip_c* structure_clip;\n  /* 0x090 */ eEC_EffectControl_Clip_c* effect_clip;\n  /* 0x094 */ void* tools_clip;\n  /* 0x098 */ void* _098;\n  /* 0x09C */ aMI_Clip_c* my_indoor_clip;\n  /* 0x0A0 */ void* demo_clip; /* can be multiple clip classes */\n  /* 0x0A4 */ void* demo_clip2; /* can be multiple clip classes */\n  /* 0x0A8 */ void* _0A8;\n  /* 0x0AC */ aGYO_Clip_c* gyo_clip;\n  /* 0x0B0 */ void* _0B0;\n  /* 0x0B4 */ void* _0B4;\n  /* 0x0B8 */ aShopUmbrella_Clip_c* shop_umbrella_clip;\n  /* 0x0BC */ aAR_Clip_c* arrange_room_clip;\n  /* 0x0C0 */ void* _0C0;\n  /* 0x0C4 */ void* _0C4;\n  /* 0x0C8 */ void* shrine_clip;\n  /* 0x0CC */ void* _0CC;\n  /* 0x0D0 */ void* _0D0;\n  /* 0x0D4 */ CLIP_NONE_PROC ball_redma_proc; /* removed in DnM+ */\n  /* 0x0D8 */ void* _0D8;\n  /* 0x0DC */ aAL_Clip_c* animal_logo_clip;\n  /* 0x0E0 */ void* _0E0;\n  /* 0x0E4 */ void* _0E4;\n  /* 0x0E8 */ void* _0E8;\n  /* 0x0EC */ aAPC_Clip_c* aprilfool_control_clip;\n  /* 0x0F0 */ void* event_manager_clip;\n  /* 0x0F4 */ void* groundhog_control_clip;\n  /* 0x0F8 */ void* _0F8;\n  /* 0x0FC */ void* _0FC;\n  /* 0x100 */ void* _100;\n} Clip_c;\n\nextern int none_proc1();\n\n#define mISL_ISLANDER_NUM 1\n#define SCHEDULE_NUM ANIMAL_NUM_MAX + mISL_ISLANDER_NUM\n\n#define mNpcW_GET_WALK_NUM(x) (int)((x) / 3)\n#define mNpcW_MAX mNpcW_GET_WALK_NUM(ANIMAL_NUM_MAX)\n\ntypedef struct goal_data_s {\n  u8* types;\n  u8 count;\n  int end_time;\n} mNpcW_GoalData_c;\n\ntypedef struct goal_data_table_s {\n  mNpcW_GoalData_c* data_p;\n  int count;\n} mNpcW_GoalDataTable_c;\n\nenum {\n  mNpcW_GOAL_SHRINE,    /* Shrine/Wishing Well acre */\n  mNpcW_GOAL_HOME,      /* Randomly selected acre with a villager house */\n  mNpcW_GOAL_ALONE,     /* Randomly selected acre with no other animals in it */\n  mNpcW_GOAL_MY_HOME,   /* Acre containing the villager's house */\n\n  mNpcW_GOAL_NUM\n};\n\nenum {\n  mNpcW_GOAL_BLOCK_SHRINE,\n  mNpcW_GOAL_BLOCK_HOME,\n\n  mNpcW_GOAL_BLOCK_NUM\n};\n\n/* TODO: figure out remaining enums */\nenum {\n  mNpcW_APPEAR_STATUS_0,\n  mNpcW_APPEAR_STATUS_1,\n\n  mNpcW_APPEAR_STATUS_NUM\n};\n\nenum {\n  mNpcW_APPEAR_WAY_UP,\n  mNpcW_APPEAR_WAY_DOWN,\n  mNpcW_APPEAR_WAY_LEFT,\n  mNpcW_APPEAR_WAY_RIGHT,\n\n  mNpcW_APPEAR_WAY_NUM\n};\n\n/* TODO: figure out remaining enums */\nenum {\n  mNpcW_INFO_STATUS_0,\n  mNpcW_INFO_STATUS_WALKING,\n  mNpcW_INFO_STATUS_2,\n  mNpcW_INFO_STATUS_3,\n  mNpcW_INFO_STATUS_4,\n\n  mNpcW_INFO_STATUS_NUM\n};\n\ntypedef struct npc_walk_appear_s {\n  u8 status;\n  u8 way;\n} mNpcW_appear_c;\n\ntypedef struct npc_walk_information_s {\n  AnmPersonalID_c id;\n  int idx;\n  u8 status;\n  u8 goal_type;\n  u8 goal_block_x;\n  u8 goal_block_z;\n  mNpcW_appear_c appear_info;\n} mNpcW_info_c;\n\ntypedef struct npc_walk_s {\n  mNpcW_info_c info[mNpcW_MAX];\n  u16 used_idx_bitfield;\n  u8 used_info_num;\n  u8 info_max;\n} mNpc_walk_c;\n\nenum demo_clip_type {\n  mDemo_CLIP_TYPE_NONE,\n  mDemo_CLIP_TYPE_INTRO_DEMO,\n  mDemo_CLIP_TYPE_RIDE_OFF_DEMO,\n\n  mDemo_CLIP_TYPE_NUM\n};\n\ntypedef struct transition_s {\n  u8 _00; // only set in Global_kankyo_ct?\n  u8 fade_rate;\n  u8 wipe_rate;\n  u8 wipe_type;\n} Transition_c;\n\ntypedef struct broker_event_common_s {\n  PersonalID_c entered_pid;\n  int hide_npc;\n} mEv_broker_common_c;\n\ntypedef struct santa_event_common_s {\n  u8 present;\n  u8 talk_counter;\n  s8 bx;\n  s8 bz;\n  mActor_name_t last_talk_cloth;\n} mEv_santa_event_common_c;\n\ntypedef union {\n  mEv_broker_common_c broker;\n  mEv_santa_event_common_c santa;\n} mEv_event_common_u;\n\ntypedef struct {\n  mLd_land_info_c land;\n  PersonalID_c pid[PLAYER_NUM];\n} mCD_persistent_data_c;\n\ntypedef struct agb_landinfo_s {\n  u8 name[LAND_NAME_SIZE];\n  s8 exists;\n  u16 id;\n} mISL_landinfo_agb_c;\n\ntypedef struct agb_floor_s {\n  /* 0x000 */ mHm_lyr_c layers[mHm_LAYER_NUM];\n  /* 0x8A0 */ mHm_wf_c wall_floor;\n  /* 0x8A2 */ u16 pad_8A2;\n  /* 0x8A4 */ TempoBeat_c tempo_beat;\n  /* 0x8A8 */ u32 floor_bit_info;\n} mISL_flr_agb_c;\n\ntypedef struct agb_cottage_s {\n  /* 0x000 */ mHm_wf_c unused_wall_floor; /* Has wallpaper & flooring bounds checks in sChk_CheckSaveData_Cattage */\n  /* 0x002 */ u8 pad_2[2];\n  /* 0x004 */ u8 unk_2[2]; /* struct/array that is two bytes long, maybe another wall floor? */\n  /* 0x008 */ mISL_flr_agb_c room; /* Cottage room */\n  /* 0x8B8 */ u8 unk_8B8; // unk_4\n  /* 0x8B9 */ u8 unk_8B9; // unk_5\n  /* 0x8BA */ u8 pad_8BA;\n  /* 0x8BB */ u8 pad_8BB;\n  /* 0x8BC */ mHm_goki_c goki; /* Cottage cockroaches */\n  /* 0x8C8 */ u32 pad_8C8;\n  /* 0x8CC */ u32 music_box[2]; /* Cottage music storage... separate from main home? */\n} mISL_cottage_agb_c;\n\ntypedef struct agb_anmplayermail_s {\n  /* 0x000 */ u8 font; /* 'font' to use for letter info */\n  /* 0x001 */ u8 paper_type; \n  /* 0x002 */ mActor_name_t present;\n  /* 0x004 */ u8 header_back_start; /* position for name insertion in header */\n  /* 0x005 */ u8 pad_5[3]; /* likely pad */\n  /* 0x008 */ u8 header[MAIL_HEADER_LEN];\n  /* 0x020 */ u8 body[MAIL_BODY_LEN];\n  /* 0x0E0 */ u8 footer[MAIL_FOOTER_LEN];\n  /* 0x100 */ lbRTC_ymd_c date; /* sent date */\n} mISL_Anmplmail_agb_c;\n\ntypedef struct agb_anmmem_s {\n  PersonalID_c player_id;\n  lbRTC_time_c last_speak_time;\n  memuni_u memuni;\n  u64 saved_town_tune;\n  s8 friendship;\n  u32 letter_info;\n  mISL_Anmplmail_agb_c letter;\n} mISL_Anmmem_agb_c;\n\ntypedef struct agb_quest_base_s {\n  /* 0x00 */ u32 info;\n  /* 0x04 */ lbRTC_time_c time_limit;\n} mISL_quest_base_c;\n\ntypedef struct agb_quest_contest_s {\n  /* 0x00 */ mISL_quest_base_c base; /* quest base struct */\n  /* 0x0C */ mActor_name_t requested_item; /* item (if any) requested by the villager */\n  /* 0x0E */ u8 pad_0E[2];\n  /* 0x10 */ PersonalID_c player_id; /* personal id of the player */\n  /* 0x24 */ s8 type; /* type of quest, seems to be repeat of data in quest base */\n  /* 0x25 */ u8 pad_25[3];\n  /* 0x28 */ mQst_contest_info_u info; /* contest info for flower & letter quests */\n} mISL_quest_contest_c;\n\ntypedef struct agb_animal_s {\n  /* 0x000 */ AnmPersonalID_c id; /* this villager's ID */\n  /* 0x010 */ mISL_Anmmem_agb_c memories[ANIMAL_MEMORY_NUM]; /* memories of players who've spoken to this villager */\n  /* 0x8D0 */ Anmhome_c home_info; /* home position info */\n  /* 0x8D5 */ u8 pad_8D5[3];\n  /* 0x8D8 */ u8 catchphrase[ANIMAL_CATCHPHRASE_LEN]; /* may be called 'word_ending' */\n  /* 0x8E2 */ u8 pad_8E2[2];\n  /* 0x8E4 */ mISL_quest_contest_c contest_quest; /* current contest quest information */\n  /* 0x910 */ u8 parent_name[PLAYER_NAME_LEN]; /* name of the player who 'spawned' the villager in, unsure why this is tracked */\n  /* 0x918 */ u8 pad_918[4];\n  /* 0x91C */ anmuni_u anmuni; /* name of the last town the villager lived in or saved island ftr */\n  /* 0x924 */ u8 pad_924[4]; /* may include last_land_id */\n  /* 0x928 */ u8 mood; /* probably called 'feel' based on code */\n  /* 0x929 */ u8 mood_time; /* probably called 'feel_tim' based on code */\n  /* 0x92A */ mActor_name_t cloth; /* shirt the villager is wearing */\n  /* 0x92C */ u16 remove_info; /* info about villager moving between towns? kinda stubbed */\n  /* 0x92D */ u8 is_home; /* TRUE when the villager is home, otherwise FALSE */\n  /* 0x92E */ u8 moved_in; /* TRUE when the villager moved in after town creation, FALSE if they started out in town */\n  /* 0x92F */ u8 removing; /* TRUE when the villager is leaving town, FALSE otherwise */\n  /* 0x930 */ u8 cloth_original_id; /* 0xFF when not wearing an Able Sister's pattern, otherwise 0-3 indicating which pattern */\n  /* 0x931 */ s8 umbrella_id; /* 0xFF when no umbrella, 0-31 when a standard umbrella, 32-35 when using an Able Sister's pattern\n  /* 0x932 */ u8 unk_932; /* Exists according to mISL_gc_to_agb_animal, but seems unused in practice */\n  /* 0x934 */ mActor_name_t present_cloth; /* The most recently received shirt from a letter which the villager may change into */\n  /* 0x936 */ u8 pad_936[6];\n  /* 0x93C */ u8 animal_relations[ANIMAL_NUM_MAX]; /* relationships between all villagers in town, starts at 128 which is neutral */\n  /* 0x94B */ u8 pad_94B[5];\n  /* 0x950 */ AnmHPMail_c hp_mail[ANIMAL_HP_MAIL_NUM]; /* mail password info storage */\n  /* 0x9C0 */ u8 _9C0[24]; /* unknown usage/unused */\n} mISL_Animal_agb_c;\n\ntypedef struct island_agb_s {\n  /* 0x0000 */ u8 _0000[8];\n  /* 0x0008 */ u8 name[mISL_ISLAND_NAME_LEN]; /* island name */\n  /* 0x0010 */ u8 grass_tex_type; /* grass type */\n  /* 0x0011 */ u8 _0011[2];\n  /* 0x0013 */ u8 _0013;\n  /* 0x0014 */ mISL_landinfo_agb_c landinfo; /* land info for town */\n  /* 0x0020 */ u8 _0020[4];\n  /* 0x0024 */ mFM_fg_c fgblock[mISL_FG_BLOCK_Z_NUM][mISL_FG_BLOCK_X_NUM]; /* island item actor data */\n  /* 0x0424 */ u8 _0424[4];\n  /* 0x0428 */ mISL_cottage_agb_c cottage; /* player shared cottage data */\n  /* 0x0D00 */ mNW_original_design_c flag_design; /* island flag design */\n  /* 0x0F20 */ mISL_Animal_agb_c animal; /* islander info */\n  /* 0x18F8 */ u16 deposit[mISL_FG_BLOCK_X_NUM * mISL_FG_BLOCK_Z_NUM][UT_Z_NUM]; /* buried item bitfield */\n  /* 0x1938 */ u8 bg_data[mISL_ISLAND_BLOCK_NUM]; /* island acre ids */\n  /* 0x193A */ u8 weather;\n  /* 0x193C */ lbRTC_time_c renew_time; /* last time island was visited? */\n  /* 0x1944 */ int npc_idx;\n  /* 0x1948 */ u32 earth_tex[1024];\n  /* 0x2948 */ u32 npc_tex[1024];\n  /* 0x3948 */ u16 npc_pal[16];\n  /* 0x3968 */ u8 _3968[20];\n  /* 0x397C */ u8 _397C;\n  /* 0x397D */ u8 last_song_male; /* last song kapp'n sang for a male character */\n  /* 0x397E */ u8 last_song_female; /* last song kapp'n sang for a female character */\n  /* 0x397F */ u8 checksum;\n} Island_agb_c;\n\ntypedef void (*mDemo_REQUEST_PROC)(ACTOR*);\n\ntypedef struct demo_req_s {\n  ACTOR* actor;\n  int type;\n  mDemo_REQUEST_PROC proc;\n  f32 talk_weight;\n} mDemo_Request_c;\n\n/* sizeof(common_data_t) == 0x2DC00 */\ntypedef struct common_data_s {\n  /* 0x000000 */ Save save;\n  /* 0x026000 */ u8 game_started;\n  /* 0x026001 */ u8 field_type;\n  /* 0x026002 */ u8 field_draw_type;\n  /* 0x026003 */ u8 player_no;\n  /* 0x026004 */ int last_scene_no;\n  /* 0x026008 */ int player_data_mode;\n  /* 0x02600C */ Clip_c clip;\n  /* 0x026110 */ Time_c time;\n  /* 0x02613C */ Private_c* now_private;\n  /* 0x026140 */ mHm_hs_c* now_home;\n  /* 0x026144 */ u8 map_flag;\n  /* 0x026145 */ u8 fish_location;\n  /* 0x026146 */ u8 npc_is_summercamper;\n  /* 0x026147 */ u8 player_select_animal_no;\n  /* 0x026148 */ u8 _26148[0x2614C - 0x26148];\n  /* 0x02614C */ Transition_c transition;\n  /* 0x026150 */ s16 bg_item_type;\n  /* 0x026152 */ s16 bg_item_profile;\n  /* 0x026154 */ u8 _26154[0x26164 - 0x26154];\n  /* 0x026164 */ mNpc_NpcList_c npclist[ANIMAL_NUM_MAX + 1];\n  /* 0x0264E4 */ mNpc_NpcList_c island_npclist[1]; // TODO: define for island npc count\n  /* 0x02651C */ mActor_name_t house_owner_name;\n  /* 0x02651E */ mActor_name_t last_field_id;\n  /* 0x026520 */ u8 in_initial_block; /* when TRUE, the player is in the acre which they exited a building. FALSE otherwise. */\n  /* 0x026521 */ u8 submenu_disabled; /* when set, submenus cannot be accessed from start button */\n  /* 0x026522 */ u8 sunlight_flag;\n  /* 0x026523 */ u8 train_flag;\n  /* 0x026522 */ u8 _26524[0x2666C - 0x26524];\n  /* 0x02666C */ s16 weather;\n  /* 0x02666E */ s16 weather_intensity;\n  /* 0x026670 */ lbRTC_time_c weather_time;\n  /* 0x026678 */ s_xyz wind;\n  /* 0x026680 */ f32 wind_speed;\n  /* 0x026684 */ mEv_event_common_u special_event_common;\n  /* 0x02669C */ mQst_not_saved_c quest;\n  /* 0x0266A4 */ int scene_from_title_demo; /* next scene to be loaded when title demo finishes */\n  /* 0x0266A8 */ mNPS_schedule_c npc_schedule[SCHEDULE_NUM];\n  /* 0x0267A8 */ mNpc_walk_c npc_walk;\n  /* 0x026838 */ mNpc_EventNpc_c event_npc[mNpc_EVENT_NPC_NUM];\n  /* 0x026878 */ mNpc_MaskNpc_c mask_npc[mNpc_MASK_NPC_NUM];\n  /* 0x028528 */ int snowman_msg_id;\n  /* 0x02852C */ s16 money_power;\n  /* 0x02852E */ s16 goods_power;\n  /* 0x028530 */ Door_data_c door_data; /* misc door data */\n  /* 0x028544 */ Door_data_c structure_exit_door_data; /* door data for when exiting a building */\n  /* 0x028558 */ mDemo_Request_c start_demo_request;\n  /* 0x028568 */ Door_data_c event_door_data;\n  /* 0x02857C */ Door_data_c famicom_emu_exit_door_data;\n  /* 0x028590 */ u8 remove_cut_tree_info_bitfield; /* resets the cut tree states for trees in a visible acre */\n  /* 0x028591 */ u8 floor_idx;\n  /* 0x028592 */ s16 demo_profiles[mDemo_CLIP_TYPE_NUM - 1];\n  /* 0x028596 */ u8 _28596[0x285BE - 0x28596];\n  /* 0x0285BE */ s8 player_actor_exists;\n  /* 0x0285BF */ s8 payment_completed_type;\n  /* 0x0285C0 */ s8 player_decoy_flag;\n  /* 0x0285C1 */ u8 _285C1;\n  /* 0x0285C2 */ u8 make_npc2_actor;\n  /* 0x0285C4 */ s16 event_id;\n  /* 0x0285C6 */ u8 event_title_flags;\n  /* 0x0285C7 */ u8 event_title_fade_in_progress;\n  /* 0x0285C8 */ mEv_common_data_c event_common;\n  /* 0x0287F8 */ s8 current_famicom_rom;\n  /* 0x0287F9 */ s8 famicom_287F9;\n  /* 0x0287FA */ u8 _287FA[0x28838 - 0x0287FA]; \n  /* 0x028838 */ s8 player_bee_swell_flag;\n  /* 0x028839 */ s8 player_bee_chase_flag;\n  /* 0x02883A */ u8 goki_shocked_flag;\n  /* 0x02883B */ u8 time_changed_flag;\n  /* 0x02883C */ u8 unable_to_wade_flag;\n  /* 0x02883D */ u8 _02883D;\n  /* 0x02883E */ u8 train_coming_flag; /* state tracker for when train is going to spawn/has spawned */\n  /* 0x02883F */ u8 train_exists_flag; /* state tracker for when train exists */\n  /* 0x028840 */ u8 train_control_state; /* current train state */\n  /* 0x028841 */ u8 train_last_control_state; /* previous train state */\n  /* 0x028842 */ u8 train_signal;\n  /* 0x028843 */ u8 train_day;\n  /* 0x028844 */ u8 train_action;\n  /* 0x028845 */ u8 train_timer;\n  /* 0x028848 */ u32 train_start_timer;\n  /* 0x02884C */ f32 train_speed;\n  /* 0x028850 */ xyz_t train_position;\n  /* 0x02885C */ f32 unused_02885C;\n  /* 0x028860 */ f32 unused_028860;\n  /* 0x028864 */ u16 unused_028864;\n  /* 0x028866 */ u16 unused_028866;\n  /* 0x028868 */ u8 reset_flag;\n  /* 0x028869 */ u8 reset_type;\n  /* 0x02886A */ u8 force_mail_delivery_flag;\n  /* 0x02886B */ u8 post_girl_npc_type;\n  /* 0x02886C */ xyz_t ball_pos;\n  /* 0x028878 */ u8 ball_type;\n  /* 0x028879 */ u8 auto_nwrite_count;\n  /* 0x02887A */ lbRTC_year_t auto_nwrite_year;\n  /* 0x02887C */ u8 save_error_type; /* set to one of the mFRm_ERROR_* states when save is invalid */\n  /* 0x02887D */ u8 train_approaching_flag; /* set when the train is coming */\n  /* 0x02887E */ u8 buried_treasure_flag; /* when set, treasure cannot be buried */\n  /* 0x02887F */ u8 spnpc_first_talk_flags;\n  /* 0x028880 */ u8 needlework_first_talk_flags;\n  /* 0x028882 */ u16 event_notification_active;\n  /* 0x028884 */ lbRTC_time_c newly_set_time; /* time set by player in time adjust menu */\n  /* 0x02888C */ lbRTC_time_c old_time; /* time before being changed by the player */\n  /* 0x028894 */ s16 balloon_state; /* balloon's current state */\n  /* 0x028896 */ s16 balloon_last_spawn_min; /* last minute the balloon was spawned */\n  /* 0x028898 */ f32 balloon_spawn_percent; /* chance that a balloon will spawn */\n  /* 0x02889C */ int tanuki_shop_status; /* adjusted based on any current events happening to Nook's shop */\n  /* 0x0288A0 */ u8 pad_connected; /* is gamepad 0 connected? */\n  /* 0x0288A1 */ u8 unk288A1;\n  /* 0x0288A2 */ s16 current_sound_effect;\n  /* 0x0288A4 */ u8 _288a4[0x0288C0 - 0x0288A4];\n  /* 0x0288C0 */ Island_c transfer_island; /* used when transferring islands with the GBA */\n  /* 0x02A1C0 */ Island_agb_c agb_island; /* converted island data sent over to the GBA */\n  /* 0x02DB40 */ u8 auto_nwrite_set; /* when true, saved nwrite time will be utilized. Seems to be used to keep same date for fishing tourney stuff. */\n  /* 0x02DB42 */ u16 select_last_select_no;\n  /* 0x02DB44 */ u16 select_last_top_no;\n  /* 0x02DB46 */ mCD_persistent_data_c travel_persistent_data; /* used for checking if travelling back to town */\n  /* 0x02DBA2 */ s16 island_weather;\n  /* 0x02DBA4 */ s16 island_weather_intensity;\n  /* 0x02DBA6 */ u8 _2DBA6[0x2DBAC - 0x2DBA6];\n  /* 0X02DBAC */ int famicom_2DBAC;\n  /* 0x02DBB0 */ s16 can_look_goki_count;\n  /* 0x02DBB4 */ f32 rainbow_opacity; /* current opacity of rainbow (0.0f - 1.0f) */\n  /* 0x02DBB8 */ u32 event_flags[mEv_EVENT_TYPE_NUM];\n  /* 0x02DBD4 */ xyz_t* pluss_bridge_pos; /* position of extra bridge */\n  /* 0x02DBD8 */ lbRTC_time_c auto_nwrite_time; /* cached notice time used for fishing tourney results? */\n  /* 0x02DBE0 */ u8 rhythym_updated;\n  /* 0x02DBE1 */ u8 _2dbe1;\n  /* 0x02DBE2 */ u8 hem_visible; /* controls farley's visiblilty during cutscene? */\n  /* 0x02DBE4 */ u8* carde_program_p; /* pointer to current e-Reader program data */\n  /* 0x02DBE8 */ size_t carde_program_size; /* size of current e-Reader program data */\n  /* 0x02DBEC */ int unk_nook_present_count; /* something possibly to do withhanding over password present? */\n  /* 0x02DBF0 */ u8 pad[16];\n} common_data_t;\n\nextern common_data_t common_data;\n\n#define Common_Get(name) (common_data.name)\n#define Common_GetPointer(name) (&common_data.name)\n#define Common_Set(name, value) (common_data.name = (value))\n\n#define Save_Get(name) (Common_Get(save.save.name))\n#define Save_GetPointer(name) (Common_GetPointer(save.save.name))\n#define Save_Set(name, value) (Common_Set(save.save.name, value))\n\nextern void play_init(GAME*);\n\n#define GAME_NEXT_GAME(game, init_name, class_name) \\\ndo { \\\n  GAME* g = (game); \\\n  g->next_game_init = (void (*)(struct game_s*))init_name##_init; \\\n  g->next_game_class_size = sizeof(GAME_##class_name); \\\n} while (0)\n\n#define GAME_GOTO_NEXT(game, init_name, class_name) \\\ndo { \\\n  GAME* t_game = (game); \\\n  t_game->doing = FALSE; \\\n  GAME_NEXT_GAME(t_game, init_name, class_name); \\\n} while (0)\n\nextern void SetGameFrame(int frame);\n\nextern void game_get_controller(GAME* game);\nextern void game_debug_draw_last(GAME* game, GRAPH* graph);\nextern void game_draw_last(GRAPH* graph);\n\nextern GAME* gamePT;\n\nextern GAME* game_class_p;\nextern u8 game_GameFrame;\nextern float game_GameFrameF;\nextern float game_GameFrame_2F;\nextern float game_GameFrame__1F;\n\nenum {\n  mFI_CLIMATE_0,\n  mFI_CLIMATE_ISLAND,\n  mFI_CLIMATE_2,\n  mFI_CLIMATE_3,\n  mFI_CLIMATE_4,\n  mFI_CLIMATE_5,\n  mFI_CLIMATE_NUM\n};\n\n#define BUTTON_NONE 0x0000\n#define BUTTON_CRIGHT 0x0001\n#define BUTTON_CLEFT 0x0002\n#define BUTTON_CDOWN 0x0004\n#define BUTTON_CUP 0x0008\n#define BUTTON_R 0x0010\n#define BUTTON_L 0x0020\n#define BUTTON_X 0x0040\n#define BUTTON_Y 0x0080\n#define BUTTON_DRIGHT 0x0100\n#define BUTTON_DLEFT 0x0200\n#define BUTTON_DDOWN 0x0400\n#define BUTTON_DUP 0x0800\n#define BUTTON_START 0x1000\n#define BUTTON_Z 0x2000\n#define BUTTON_B 0x4000\n#define BUTTON_A 0x8000\n\nextern void DisplayList_initialize(GRAPH* graph, u32 clear_r, u32 clear_g, u32 clear_b, GAME* game);\nextern void fade_black_draw(Gfx** gfxpp, u32 alpha);\n\n\n/* sizeof(struct second_game_s) == 0xE0 */\ntypedef struct second_game_s {\n  /* 0x00 */ GAME game;\n} GAME_SECOND;\n\nextern void second_game_init(GAME* game);\nextern void second_game_cleanup(GAME* game);\n\nenum pads {\n  PAD0,\n  PAD1,\n  PAD2,\n  PAD3,\n\n  PAD_NUM\n};\n\nextern int padmgr_isConnectedController(int pad);\nextern void Na_InitAudio(void (*fatal_callback)(), u8* load_addr, size_t load_size, u8* bootsound, size_t bootsound_size, BOOL cut_flag);\nextern void Na_GameFrame();\nextern u8 Na_CheckNeosBoot();\nextern void Na_RestartPrepare();\nextern u8 Na_CheckRestartReady();\nextern void Na_Restart();\nextern void init_rnd();\n\nextern int zurumode_flag;\n\n#define OS_RESET_RESTART 0\n#define OS_RESET_HOTRESET 1 /* Soft reset */\n#define OS_RESET_SHUTDOWN 2\n\nextern s32 osAppNMIBuffer[];\n\n#define APPNMI_FLAGS_IDX 15\n\n#define APPNMI_GETVAL() (osAppNMIBuffer[APPNMI_FLAGS_IDX])\n\n#define APPNMI_SET(v) (osAppNMIBuffer[APPNMI_FLAGS_IDX] |= v)\n#define APPNMI_CLR(v) (osAppNMIBuffer[APPNMI_FLAGS_IDX] &= ~v)\n#define APPNMI_GET(v) (osAppNMIBuffer[APPNMI_FLAGS_IDX] & v)\n#define APPNMI_FLP(v) (osAppNMIBuffer[APPNMI_FLAGS_IDX] ^= v)\n\n/* ZURUMODE (Cheat mode) related values */\n#define APPNMI_ZURUMODE_SET() APPNMI_SET(1)\n#define APPNMI_ZURUMODE_CLR() APPNMI_CLR(1)\n#define APPNMI_ZURUMODE_GET() APPNMI_GET(1)\n#define APPNMI_ZURUMODE_FLP() APPNMI_FLP(1)\n#define APPNMI_ZURUMODE2_SET() APPNMI_SET(8)\n#define APPNMI_ZURUMODE2_CLR() APPNMI_CLR(8)\n#define APPNMI_ZURUMODE2_GET() APPNMI_GET(8)\n#define APPNMI_ZURUMODE2_FLP() APPNMI_FLP(8)\n#define APPNMI_ZURUMODE3_SET() APPNMI_SET(16)\n#define APPNMI_ZURUMODE3_CLR() APPNMI_CLR(16)\n#define APPNMI_ZURUMODE3_GET() APPNMI_GET(16)\n#define APPNMI_ZURUMODE3_FLP() APPNMI_FLP(16)\n\n#define APPNMI_RESETEXEMPT_SET() APPNMI_SET(2)\n#define APPNMI_RESETEXEMPT_CLR() APPNMI_CLR(2)\n#define APPNMI_RESETEXEMPT_GET() APPNMI_GET(2)\n#define APPNMI_RESETEXEMPT_FLP() APPNMI_FLP(2)\n#define APPNMI_RESETEXEMPT2_SET() APPNMI_SET(4)\n#define APPNMI_RESETEXEMPT2_CLR() APPNMI_CLR(4)\n#define APPNMI_RESETEXEMPT2_GET() APPNMI_GET(4)\n#define APPNMI_RESETEXEMPT2_FLP() APPNMI_FLP(4)\n\n#define APPNMI_DEBUGMODE_SET() APPNMI_SET(32)\n#define APPNMI_DEBUGMODE_CLR() APPNMI_CLR(32)\n#define APPNMI_DEBUGMODE_GET() APPNMI_GET(32)\n#define APPNMI_DEBUGMODE_FLP() APPNMI_FLP(32)\n\n#define APPNMI_TESTMODE_SET() APPNMI_SET(64)\n#define APPNMI_TESTMODE_CLR() APPNMI_CLR(64)\n#define APPNMI_TESTMODE_GET() APPNMI_GET(64)\n#define APPNMI_TESTMODE_FLP() APPNMI_FLP(64)\n\n#define APPNMI_EXTENDEDMEMORY_SET() APPNMI_SET(128)\n#define APPNMI_EXTENDEDMEMORY_CLR() APPNMI_CLR(128)\n#define APPNMI_EXTENDEDMEMORY_GET() APPNMI_GET(128)\n#define APPNMI_EXTENDEDMEMORY_FLP() APPNMI_FLP(128)\n\n#define APPNMI_SHOPPROMOVERSION_SET() APPNMI_SET(256)\n#define APPNMI_SHOPPROMOVERSION_CLR() APPNMI_CLR(256)\n#define APPNMI_SHOPPROMOVERSION_GET() APPNMI_GET(256)\n#define APPNMI_SHOPPROMOVERSION_FLP() APPNMI_FLP(256)\n\n/* Not fully sure this is the right name */\n#define APPNMI_HOTRESET_SET() (osAppNMIBuffer[APPNMI_FLAGS_IDX] |= 0x200)\n#define APPNMI_HOTRESET_CLR() (osAppNMIBuffer[APPNMI_FLAGS_IDX] &= ~0x200)\n#define APPNMI_HOTRESET_GET() (osAppNMIBuffer[APPNMI_FLAGS_IDX] & 0x200)\n#define APPNMI_HOTRESET_FLP() (osAppNMIBuffer[APPNMI_FLAGS_IDX] ^= 0x200)\n\nenum {\n  mPr_PLAYER_0,\n  mPr_PLAYER_1,\n  mPr_PLAYER_2,\n  mPr_PLAYER_3,\n  mPr_FOREIGNER,\n\n  mPr_PLAYER_NUM\n};\n\nextern void mNpc_CopyAnimalPersonalID(AnmPersonalID_c* dst, AnmPersonalID_c* src);\nextern AnmPersonalID_c* mNpc_GetOtherAnimalPersonalID(AnmPersonalID_c* ids, int num_ids);\n\n#define ARRAY_SIZE(arr, type) (sizeof(arr) / sizeof(type))\n\n#define mFont_MODE_POLY 0\n#define mFont_MODE_FONT 1\n\n#define CHAR_INVERT_EXCLAMATION 0\n#define CHAR_INVERT_QUESTIONMARK 1\n#define CHAR_DIAERESIS_A 2\n#define CHAR_GRAVE_A 3\n#define CHAR_ACUTE_A 4\n#define CHAR_CIRCUMFLEX_A 5\n#define CHAR_TILDE_A 6\n#define CHAR_ANGSTROM_A 7\n#define CHAR_CEDILLA 8\n#define CHAR_GRAVE_E 9\n#define CHAR_ACUTE_E 10\n#define CHAR_CIRCUMFLEX_E 11\n#define CHAR_DIARESIS_E 12\n#define CHAR_GRAVE_I 13\n#define CHAR_ACUTE_I 14\n#define CHAR_CIRCUMFLEX_I 15\n#define CHAR_DIARESIS_I 16\n#define CHAR_ETH 17                 /* \u0110 */\n#define CHAR_TILDE_N 18\n#define CHAR_GRAVE_O 19\n#define CHAR_ACUTE_O 20\n#define CHAR_CIRCUMFLEX_O 21\n#define CHAR_TILDE_O 22\n#define CHAR_DIARESIS_O 23\n#define CHAR_OE 24                   /* \u00d8 */\n#define CHAR_GRAVE_U 25\n#define CHAR_ACUTE_U 26\n#define CHAR_CIRCUMFLEX_U 27\n#define CHAR_DIARESIS_U 28\n#define CHAR_LOWER_BETA 29           /* \u03b2 */\n#define CHAR_THORN 30                /* \u00de */\n#define CHAR_GRAVE_a 31\n#define CHAR_SPACE 32                /* ' ' */\n#define CHAR_EXCLAMATION 33\n#define CHAR_QUOTATION 34\n#define CHAR_ACUTE_a 35\n#define CHAR_CIRCUMFLEX_a 36\n#define CHAR_PERCENT 37\n#define CHAR_AMPERSAND 38\n#define CHAR_APOSTROPHE 39\n#define CHAR_OPEN_PARENTHESIS 40\n#define CHAR_CLOSE_PARENTHESIS 41\n#define CHAR_TILDE 42\n#define CHAR_SYMBOL_HEART 43\n#define CHAR_COMMA 44\n#define CHAR_DASH 45\n#define CHAR_PERIOD 46\n#define CHAR_SYMBOL_MUSIC_NOTE 47\n#define CHAR_ZERO 48\n#define CHAR_ONE 49\n#define CHAR_TWO 50\n#define CHAR_THREE 51\n#define CHAR_FOUR 52\n#define CHAR_FIVE 53\n#define CHAR_SIX 54\n#define CHAR_SEVEN 55\n#define CHAR_EIGHT 56\n#define CHAR_NINE 57\n#define CHAR_COLON 58\n#define CHAR_SYMBOL_DROPLET 59\n#define CHAR_LESS_THAN 60\n#define CHAR_EQUALS 61\n#define CHAR_GREATER_THAN 62\n#define CHAR_QUESTIONMARK 63\n#define CHAR_AT_SIGN 64\n#define CHAR_A 65\n#define CHAR_B 66\n#define CHAR_C 67\n#define CHAR_D 68\n#define CHAR_E 69\n#define CHAR_F 70\n#define CHAR_G 71\n#define CHAR_H 72\n#define CHAR_I 73\n#define CHAR_J 74\n#define CHAR_K 75\n#define CHAR_L 76\n#define CHAR_M 77\n#define CHAR_N 78\n#define CHAR_O 79\n#define CHAR_P 80\n#define CHAR_Q 81\n#define CHAR_R 82\n#define CHAR_S 83\n#define CHAR_T 84\n#define CHAR_U 85\n#define CHAR_V 86\n#define CHAR_W 87\n#define CHAR_X 88\n#define CHAR_Y 89\n#define CHAR_Z 90\n#define CHAR_TILDE_a 91\n#define CHAR_SYMBOL_ANNOYED 92\n#define CHAR_DIARESIS_a 93\n#define CHAR_ANGSTROM_a 94\n#define CHAR_UNDERSCORE 95\n#define CHAR_LOWER_CEDILLA 96\n#define CHAR_a 97\n#define CHAR_b 98\n#define CHAR_c 99\n#define CHAR_d 100\n#define CHAR_e 101\n#define CHAR_f 102\n#define CHAR_g 103\n#define CHAR_h 104\n#define CHAR_i 105\n#define CHAR_j 106\n#define CHAR_k 107\n#define CHAR_l 108\n#define CHAR_m 109\n#define CHAR_n 110\n#define CHAR_o 111\n#define CHAR_p 112\n#define CHAR_q 113\n#define CHAR_r 114\n#define CHAR_s 115\n#define CHAR_t 116\n#define CHAR_u 117\n#define CHAR_v 118\n#define CHAR_w 119\n#define CHAR_x 120\n#define CHAR_y 121\n#define CHAR_z 122\n#define CHAR_GRAVE_e 123\n#define CHAR_ACUTE_e 124\n#define CHAR_CIRCUMFLEX_e 125\n#define CHAR_DIARESIS_e 126\n#define CHAR_CONTROL_CODE 127\n#define CHAR_MESSAGE_TAG 128\n#define CHAR_GRAVE_i 129\n#define CHAR_ACUTE_i 130\n#define CHAR_CIRCUMFLEX_i 131\n#define CHAR_DIARESIS_i 132\n#define CHAR_INTERPUNCT 133           /* \u00b7 */\n#define CHAR_LOWER_ETH 134            /* \u0111 */\n#define CHAR_TILDE_n 135\n#define CHAR_GRAVE_o 136\n#define CHAR_ACUTE_o 137\n#define CHAR_CIRCUMFLEX_o 138\n#define CHAR_TILDE_o 139\n#define CHAR_DIARESIS_o 140\n#define CHAR_oe 141\n#define CHAR_GRAVE_u 142\n#define CHAR_ACUTE_u 143\n#define CHAR_HYPHEN 144\n#define CHAR_CIRCUMFLEX_u 145\n#define CHAR_DIARESIS_u 146\n#define CHAR_ACUTE_y 147\n#define CHAR_DIARESIS_y 148\n#define CHAR_LOWER_THORN 149\n#define CHAR_ACUTE_Y 150\n#define CHAR_BROKEN_BAR 151           /* \u00a6 */\n#define CHAR_SILCROW 152              /* \u00a7 */\n#define CHAR_FEMININE_ORDINAL 153\n#define CHAR_MASCULINE_ORDINAL 154        /* \u00b0 */\n#define CHAR_DOUBLE_VERTICAL_BAR 155\n#define CHAR_LATIN_MU 156\n#define CHAR_SUPERSCRIPT_THREE 157\n#define CHAR_SUPERSCRIPT_TWO 158\n#define CHAR_SUPRESCRIPT_ONE 159\n#define CHAR_MACRON_SYMBOL 160\n#define CHAR_LOGICAL_NEGATION 161\n#define CHAR_ASH 162\n#define CHAR_LOWER_ASH 163\n#define CHAR_INVERT_QUOTATION 164\n#define CHAR_GUILLEMET_OPEN 165\n#define CHAR_GUILLEMET_CLOSE 166\n#define CHAR_SYMBOL_SUN 167\n#define CHAR_SYMBOL_CLOUD 168\n#define CHAR_SYMBOL_UMBRELLA 169\n#define CHAR_SYMBOL_WIND 170\n#define CHAR_SYMBOL_SNOWMAN 171\n#define CHAR_LINES_CONVERGE_RIGHT 172\n#define CHAR_LINES_CONVERGE_LEFT 173\n#define CHAR_FORWARD_SLASH 174\n#define CHAR_INFINITY 175\n#define CHAR_CIRCLE 176\n#define CHAR_CROSS 177\n#define CHAR_SQUARE 178\n#define CHAR_TRIANGLE 179\n#define CHAR_PLUS 180\n#define CHAR_SYMBOL_LIGTNING 181 // ?? maybe electric also?\n#define CHAR_MARS_SYMBOL 182 // aka male symbol\n#define CHAR_VENUS_SYMBOL 183 // aka female symbol\n#define CHAR_SYMBOL_FLOWER 184\n#define CHAR_SYMBOL_STAR 185\n#define CHAR_SYMBOL_SKULL 186\n#define CHAR_SYMBOL_SURPRISE 187\n#define CHAR_SYMBOL_HAPPY 188\n#define CHAR_SYMBOL_SAD 189\n#define CHAR_SYMBOL_ANGRY 190\n#define CHAR_SYMBOL_SMILE 191\n#define CHAR_DIMENSION_SIGN 192 // multiplication character\n#define CHAR_OBELUS_SIGN 193 // division character\n#define CHAR_SYMBOL_HAMMER 194\n#define CHAR_SYMBOL_RIBBON 195\n#define CHAR_SYMBOL_MAIL 196\n#define CHAR_SYMBOL_MONEY 197\n#define CHAR_SYMBOL_PAW 198\n#define CHAR_SYMBOL_SQUIRREL 199 // might be dog? would make a bit more sense ig\n#define CHAR_SYMBOL_CAT 200\n#define CHAR_SYMBOL_RABBIT 201\n#define CHAR_SYMBOL_OCTOPUS 202 // could also be bird...?\n#define CHAR_SYMBOL_COW 203\n#define CHAR_SYMBOL_PIG 204\n#define CHAR_NEW_LINE 205\n#define CHAR_SYMBOL_FISH 206\n#define CHAR_SYMBOL_BUG 207\n#define CHAR_SEMICOLON 208\n#define CHAR_HASHTAG 209\n#define CHAR_SPACE_2 210 // Short space\n#define CHAR_SPACE_3 211 // Wide space\n#define CHAR_SYMBOL_KEY 212\n/* Begin EU-only symbols, unused in AC */\n#define CHAR_LEFT_QUOTATION 213\n#define CHAR_RIGHT_QUOTATION 214\n#define CHAR_LEFT_APOSTROPHE 215\n#define CHAR_RIGHT_APOSTROPHE 216\n#define CHAR_ETHEL 217\n#define CHAR_LOWER_ETHEL 218\n#define CHAR_ORDINAL_e 219\n#define CHAR_ORDINAL_er 220\n#define CHAR_ORDINAL_re 221\n#define CHAR_BACKSLASH 222\n/* Unused characters */\n#define CHAR_223 223\n#define CHAR_224 224\n#define CHAR_225 225\n#define CHAR_226 226\n#define CHAR_227 227\n#define CHAR_228 228\n#define CHAR_229 229\n#define CHAR_230 230\n#define CHAR_231 231\n#define CHAR_232 232\n#define CHAR_233 233\n#define CHAR_234 234\n#define CHAR_235 235\n#define CHAR_236 236\n#define CHAR_237 237\n#define CHAR_238 238\n#define CHAR_239 239\n#define CHAR_240 240\n#define CHAR_241 241\n#define CHAR_242 242\n#define CHAR_243 243\n#define CHAR_244 244\n#define CHAR_245 245\n#define CHAR_246 246\n#define CHAR_247 247\n#define CHAR_248 248\n#define CHAR_249 249\n#define CHAR_250 250\n#define CHAR_251 251\n#define CHAR_252 252\n#define CHAR_253 253\n#define CHAR_254 254\n#define CHAR_255 255\n\n#define TOTAL_CHARS 256\n\ntypedef struct save_pak_s {\n  u8 unused[0x54];\n} sCPk_c;\n\nextern int sCPk_PakOpen(sCPk_c* s_pak);\n\ntypedef struct contpak_s {\n  int _00;\n  sCPk_c save_pak;\n} mCPk_c;\n\nextern int mCPk_InitPak(int pak_idx);\nextern int mCPk_PakOpen(mCPk_c* cpak, int pak_idx);\nextern int  mCPk_SavePak(Private_c* private_data, Animal_c* animals, mCPk_c* cpak);\nextern mCPk_c* mCPk_get_pkinfo();\n\nextern f32 mFont_SetLineStrings_AndSpace(GAME* game, u8* str, int len, f32 x, f32 y, int r, int g, int b, int a, int flag_revert, int flag_cut, int unused, f32 scale_x, f32 scale_y, int mode);\n\nenum save_mode {\n  SAVE_MODE_BEGIN,\n\n  SAVE_MODE_FLASHROM = SAVE_MODE_BEGIN,\n  SAVE_MODE_CPAK,\n\n  SAVE_MODE_NUM\n};\n\nenum save_error {\n  SAVE_ERROR_NONE,\n  SAVE_ERROR_FLASHROM,\n  SAVE_ERROR_CPAK,\n  SAVE_ERROR_EXIT,\n\n  SAVE_ERROR_NUM\n};\n\ntypedef struct menu_color_s {\n  int r, g, b;\n} save_menu_color;\n\n/* sizeof(struct game_save_menu_s) == 0x0228 */\ntypedef struct game_save_menu_s {\n  /* 0x0000 */ GAME game;\n  /* 0x00E0 */ View view;\n  /* 0x0200 */ u32 frame;\n  /* 0x0204 */ int mode;\n  /* 0x0208 */ int error;\n  /* 0x020C */ int cursor_col[SAVE_MODE_NUM][3];\n} GAME_SAVE_MENU;\n\nextern void save_menu_init(GAME* game);\nextern void save_menu_cleanup(GAME* game);\n\nenum birth_type {\n  mRmTp_BIRTH_TYPE_GRP_A = 0,\n  mRmTp_BIRTH_TYPE_GRP_B = 1,\n  mRmTp_BIRTH_TYPE_GRP_C = 2,\n  mRmTp_BIRTH_TYPE_EVENT = 3,\n  mRmTp_BIRTH_TYPE_BIRTHDAY = 4,\n  mRmTp_BIRTH_TYPE_HALLOWEEN = 5,\n  mRmTp_BIRTH_TYPE_HANIWA = 6,\n  mRmTp_BIRTH_TYPE_LOTTERY = 7,\n  mRmTp_BIRTH_TYPE_FTR_CLOTH = 8,\n  mRmTp_BIRTH_TYPE_FTR_UMBRELLA = 9,\n  mRmTp_BIRTH_TYPE_FTR_INSECT = 10,\n  mRmTp_BIRTH_TYPE_FTR_FISH = 11,\n  mRmTp_BIRTH_TYPE_SINGLE_FOSSIL = 12,\n  mRmTp_BIRTH_TYPE_MULTI_FOSSIL = 13,\n  mRmTp_BIRTH_TYPE_XMAS = 14,\n  mRmTp_BIRTH_TYPE_SANTA = 15,\n  mRmTp_BIRTH_TYPE_UNOBTAINABLE = 16,\n  mRmTp_BIRTH_TYPE_SNOWMAN = 17,\n  mRmTp_BIRTH_TYPE_HALLOWEEN_TRICK = 18,\n  mRmTp_BIRTH_TYPE_POST_OFFICE = 19,\n  mRmTp_BIRTH_TYPE_MARK_ROOM = 20,\n  mRmTp_BIRTH_TYPE_SONCHO = 21,\n  mRmTp_BIRTH_TYPE_JONASON = 22,\n  mRmTp_BIRTH_TYPE_UNUSED_23 = 23,\n  mRmTp_BIRTH_TYPE_FAMICOM_EREADER = 24,\n  mRmTp_BIRTH_TYPE_ISLAND = 25,\n  mRmTp_BIRTH_TYPE_FAMICOM_ISLAND = 26,\n  mRmTp_BIRTH_TYPE_MY_ORIGINAL = 27,\n  mRmTp_BIRTH_TYPE_FAMICOM_CODE = 28,\n  mRmTp_BIRTH_TYPE_MUSEUM = 29,\n  mRmTp_BIRTH_TYPE_SONCHO_LIGHTHOUSE_QUEST = 30,\n  mRmTp_BIRTH_TYPE_FTR_DIARY = 31,\n  mRmTp_BIRTH_TYPE_GROUNDHOG = 32,\n  mRmTp_BIRTH_TYPE_KAMAKURA = 33,\n  mRmTp_BIRTH_TYPE_NINTENDO_CODE = 34,\n  mRmTp_BIRTH_TYPE_HARVEST_FESTIVAL = 35,\n  mRmTp_BIRTH_TYPE_UNUSED_36 = 36,\n  mRmTp_BIRTH_TYPE_SUMMER_CAMPER = 37,\n\n  mRmTp_BIRTH_TYPE_NUM\n};\n\n#define ABS(x) (((x) >= 0) ? (x) : -(x))\n\nextern mActor_name_t mRmTp_FtrItemNo2Item1ItemNo(mActor_name_t ftr_item_no, void* unused); /* second paramter is probably GAME*? */\nextern int mRmTp_FtrItemNo2FtrIdx(mActor_name_t ftr_item_no);\nextern mActor_name_t mRmTp_FtrIdx2FtrItemNo(int ftr_idx, int rotation);\nextern int mRmTp_FurnitureIdx2FurnitureKind(int ftr_idx);\nextern mActor_name_t mRmTp_Item1ItemNo2FtrItemNo_AtPlayerRoom(mActor_name_t item_no, int flag);\n\nextern int mSP_SearchItemCategoryPriority(mActor_name_t item_no, int category, int priority, GAME* unused);\nextern u32 mSP_ItemNo2ItemPrice(mActor_name_t item_no);\n\n#define mMpswd_PASSWORD_KEY_IDX 1\n#define mMpswd_PASSWORD_DATA_LEN 21\n#define mMpswd_PASSWORD_STR_LEN 28\n\n#define mMpswd_BITMIX_CODE_IDX 1\n#define mMpswd_RSA_R_PRIME_IDX 5\n#define mMpswd_RSA_INFO_IDX 15\n#define mMpswd_RSA_KEYSAVE_IDX 20\n\n#define mMpswd_SPECIAL_NPC_NUM 32\n#define NPC_NUM 0xEC\n#define NPC_ISLANDER_NUM 18\n\nenum {\n  mMpswd_CODETYPE_FAMICOM,\n  mMpswd_CODETYPE_POPULAR,\n  mMpswd_CODETYPE_CARD_E,\n  mMpswd_CODETYPE_MAGAZINE,\n  mMpswd_CODETYPE_USER,\n  mMpswd_CODETYPE_CARD_E_MINI,\n\n  mMpswd_CODETYPE_NUM\n};\n\nenum {\n  mMpswd_NPCTYPE_NORMAL,\n  mMpswd_NPCTYPE_SPECIAL,\n\n  mMpswd_NPCTYPE_NUM\n};\n\ntypedef struct mail_check_password_s {\n  mActor_name_t item;\n  u8 npc_type;\n  u8 npc_code;\n  u8 type;\n  u8 hit_rate_index;\n  u8 checksum;\n  u8 str0[PLAYER_NAME_LEN];\n  u8 str1[PLAYER_NAME_LEN];\n} mMpswd_password_c;\n\nextern u32 pswd_famicom_list_max;\nextern u16 pswd_famicom_list[];\n\ntypedef struct player_actor_s PLAYER_ACTOR;\n\nenum {\n  mPlayer_INDEX_DMA,\n  mPlayer_INDEX_INTRO,\n  mPlayer_INDEX_REFUSE,\n  mPlayer_INDEX_REFUSE_PICKUP,\n  mPlayer_INDEX_RETURN_DEMO,\n  mPlayer_INDEX_RETURN_OUTDOOR,\n  mPlayer_INDEX_RETURN_OUTDOOR2,\n  mPlayer_INDEX_WAIT,\n  mPlayer_INDEX_WALK,\n  mPlayer_INDEX_RUN,\n  mPlayer_INDEX_DASH,\n  mPlayer_INDEX_TUMBLE,\n  mPlayer_INDEX_TUMBLE_GETUP,\n  mPlayer_INDEX_TURN_DASH,\n  mPlayer_INDEX_FALL,\n  mPlayer_INDEX_WADE,\n  mPlayer_INDEX_DOOR,\n  mPlayer_INDEX_OUTDOOR,\n  mPlayer_INDEX_INVADE,\n  mPlayer_INDEX_HOLD,\n  mPlayer_INDEX_PUSH,\n  mPlayer_INDEX_PULL,\n  mPlayer_INDEX_ROTATE_FURNITURE,\n  mPlayer_INDEX_OPEN_FURNITURE,\n  mPlayer_INDEX_WAIT_OPEN_FURNITURE,\n  mPlayer_INDEX_CLOSE_FURNITURE,\n  mPlayer_INDEX_LIE_BED,\n  mPlayer_INDEX_WAIT_BED,\n  mPlayer_INDEX_ROLL_BED,\n  mPlayer_INDEX_STANDUP_BED,\n  mPlayer_INDEX_PICKUP,\n  mPlayer_INDEX_PICKUP_JUMP,\n  mPlayer_INDEX_PICKUP_FURNITURE,\n  mPlayer_INDEX_PICKUP_EXCHANGE,\n  mPlayer_INDEX_SITDOWN,\n  mPlayer_INDEX_SITDOWN_WAIT,\n  mPlayer_INDEX_STANDUP,\n  mPlayer_INDEX_SWING_AXE,\n  mPlayer_INDEX_AIR_AXE,\n  mPlayer_INDEX_REFLECT_AXE,\n  mPlayer_INDEX_BROKEN_AXE,\n  mPlayer_INDEX_SLIP_NET,\n  mPlayer_INDEX_READY_NET,\n  mPlayer_INDEX_READY_WALK_NET,\n  mPlayer_INDEX_SWING_NET,\n  mPlayer_INDEX_PULL_NET,\n  mPlayer_INDEX_STOP_NET,\n  mPlayer_INDEX_NOTICE_NET,\n  mPlayer_INDEX_PUTAWAY_NET,\n  mPlayer_INDEX_READY_ROD,\n  mPlayer_INDEX_CAST_ROD,\n  mPlayer_INDEX_AIR_ROD,\n  mPlayer_INDEX_RELAX_ROD,\n  mPlayer_INDEX_COLLECT_ROD,\n  mPlayer_INDEX_VIB_ROD,\n  mPlayer_INDEX_FLY_ROD,\n  mPlayer_INDEX_NOTICE_ROD,\n  mPlayer_INDEX_PUTAWAY_ROD,\n  mPlayer_INDEX_DIG_SCOOP,\n  mPlayer_INDEX_FILL_SCOOP,\n  mPlayer_INDEX_REFLECT_SCOOP,\n  mPlayer_INDEX_AIR_SCOOP,\n  mPlayer_INDEX_GET_SCOOP,\n  mPlayer_INDEX_PUTAWAY_SCOOP,\n  mPlayer_INDEX_PUTIN_SCOOP,\n  mPlayer_INDEX_TALK,\n  mPlayer_INDEX_RECIEVE_WAIT,\n  mPlayer_INDEX_RECIEVE_STRETCH,\n  mPlayer_INDEX_RECIEVE,\n  mPlayer_INDEX_RECIEVE_PUTAWAY,\n  mPlayer_INDEX_GIVE,\n  mPlayer_INDEX_GIVE_WAIT,\n  mPlayer_INDEX_TAKEOUT_ITEM,\n  mPlayer_INDEX_PUTIN_ITEM,\n  mPlayer_INDEX_DEMO_WAIT,\n  mPlayer_INDEX_DEMO_WALK,\n  mPlayer_INDEX_DEMO_GETON_TRAIN,\n  mPlayer_INDEX_DEMO_GETON_TRAIN_WAIT,\n  mPlayer_INDEX_DEMO_GETOFF_TRAIN,\n  mPlayer_INDEX_DEMO_STANDING_TRAIN,\n  mPlayer_INDEX_DEMO_WADE,\n  mPlayer_INDEX_HIDE,\n  mPlayer_INDEX_GROUNDHOG,\n  mPlayer_INDEX_RELEASE_CREATURE,\n  mPlayer_INDEX_WASH_CAR,\n  mPlayer_INDEX_TIRED,\n  mPlayer_INDEX_ROTATE_OCTAGON,\n  mPlayer_INDEX_THROW_MONEY,\n  mPlayer_INDEX_PRAY,\n  mPlayer_INDEX_SHAKE_TREE,\n  mPlayer_INDEX_MAIL_JUMP,\n  mPlayer_INDEX_MAIL_LAND,\n  mPlayer_INDEX_READY_PITFALL,\n  mPlayer_INDEX_FALL_PITFALL,\n  mPlayer_INDEX_STRUGGLE_PITFALL,\n  mPlayer_INDEX_CLIMBUP_PITFALL,\n  mPlayer_INDEX_STUNG_BEE,\n  mPlayer_INDEX_NOTICE_BEE,\n  mPlayer_INDEX_REMOVE_GRASS,\n  mPlayer_INDEX_SHOCK,\n  mPlayer_INDEX_KNOCK_DOOR,\n  mPlayer_INDEX_CHANGE_CLOTH,\n  mPlayer_INDEX_PUSH_SNOWBALL,\n  mPlayer_INDEX_ROTATE_UMBRELLA,\n  mPlayer_INDEX_WADE_SNOWBALL,\n  mPlayer_INDEX_COMPLETE_PAYMENT,\n  mPlayer_INDEX_FAIL_EMU,\n  mPlayer_INDEX_STUNG_MOSQUITO,\n  mPlayer_INDEX_NOTICE_MOSQUITO,\n  mPlayer_INDEX_SWING_FAN,\n  mPlayer_INDEX_SWITCH_ON_LIGHTHOUSE,\n  mPlayer_INDEX_RADIO_EXERCISE,\n  mPlayer_INDEX_DEMO_GETON_BOAT,\n  mPlayer_INDEX_DEMO_GETON_BOAT_SITDOWN,\n  mPlayer_INDEX_DEMO_GETON_BOAT_WAIT,\n  mPlayer_INDEX_DEMO_GETON_BOAT_WADE,\n  mPlayer_INDEX_DEMO_GETOFF_BOAT_STANDUP,\n  mPlayer_INDEX_DEMO_GETOFF_BOAT,\n  mPlayer_INDEX_DEMO_GET_GOLDEN_ITEM,\n  mPlayer_INDEX_DEMO_GET_GOLDEN_ITEM2,\n  mPlayer_INDEX_DEMO_GET_GOLDEN_AXE_WAIT\n};\n\n/* sizeof(struct player_actor_s) == 0x13A8 */\nstruct player_actor_s {\n  /* 0x0000 */ ACTOR actor_class;\n  /* 0x0174 */ u8 tmp0174[0x1270 - 0x0174];\n  /* 0x1270 */ int (*request_main_invade_all_proc)(GAME*, int);\n  /* 0x1274 */ int (*request_main_refuse_all_proc)(GAME*, int);\n  /* 0x1278 */ int (*request_main_return_demo_all_proc)(GAME*, int, f32, int);\n  /* 0x127C */ int (*request_main_wait_all_proc)(GAME*, f32, int, int);\n  /* 0x1280 */ int (*request_main_talk_all_proc)(GAME*, ACTOR*, int, f32, int, int);\n  /* 0x1284 */ int (*request_main_hold_all_proc)(GAME*, int, int, const xyz_t*, f32, int, int);\n  /* 0x1288 */ int (*request_main_recieve_wait_all_proc)(GAME*, ACTOR*, int, int, mActor_name_t, int, int);\n  /* 0x128C */ int (*request_main_give_all_proc)(GAME*, ACTOR*, int, int, mActor_name_t, int, int, int, int);\n  /* 0x1290 */ int (*request_main_sitdown_all_proc)(GAME*, int, const xyz_t*, int, int);\n  /* 0x1294 */ int (*request_main_close_furniture_all_proc)(GAME*, int);\n  /* 0x1298 */ int (*request_main_lie_bed_all_proc)(GAME*, int, const xyz_t*, int, int, int);\n  /* 0x129C */ int (*request_main_hide_all_proc)(GAME*, int);\n  /* 0x12A0 */ int (*request_main_groundhog_proc)(GAME*, int);\n  /* 0x12A4 */ int (*request_main_door_all_proc)(GAME*, const xyz_t*, s16, int, void*, int);\n  /* 0x12A8 */ int (*request_main_outdoor_all_proc)(GAME*, int, int, int);\n  /* 0x12AC */ int (*request_main_wash_car_all_proc)(GAME*, const xyz_t*, const xyz_t*, s16, ACTOR*, int);\n  /* 0x12B0 */ int (*request_main_rotate_octagon_all_proc)(GAME*, ACTOR*, int, int, const xyz_t*, s16, int);\n  /* 0x12B4 */ int (*request_main_throw_money_all_proc)(GAME*, const xyz_t*, s16, int);\n  /* 0x12B8 */ int (*request_main_pray_all_proc)(GAME*, const xyz_t*, s16, int);\n  /* 0x12BC */ int (*request_main_mail_jump_all_proc)(GAME*, const xyz_t*, s16, int);\n  /* 0x12C0 */ int (*request_main_demo_wait_all_proc)(GAME*, int, void*, int);\n  /* 0x12C4 */ int (*request_main_demo_walk_all_proc)(GAME*, f32, f32, f32, int, int);\n  /* 0x12C8 */ int (*request_main_demo_geton_train_all_proc)(GAME*, const xyz_t*, s16, int);\n  /* 0x12CC */ int (*request_main_demo_getoff_train_all_proc)(GAME*, const xyz_t*, s16, int);\n  /* 0x12D0 */ int (*request_main_demo_standing_train_all_proc)(GAME*, int);\n  /* 0x12D4 */ int (*request_main_stung_bee_all_proc)(GAME*, int);\n  /* 0x12D8 */ int (*request_main_shock_all_proc)(GAME*, f32, s16, s8, int, int);\n  /* 0x12DC */ int (*request_main_change_cloth_forNPC_proc)(GAME*, mActor_name_t, int);\n  /* 0x12E0 */ int (*request_main_push_snowball_all_proc)(GAME*, void*, int, int);\n  /* 0x12E4 */ int (*request_main_stung_mosquito_all_proc)(GAME*, int, int);\n  /* 0x12E8 */ int (*request_main_switch_on_lighthouse_all_proc)(GAME*, const xyz_t*, int, int);\n  /* 0x12EC */ int (*request_main_demo_geton_boat_all_proc)(GAME*, const xyz_t*, s16, int);\n  /* 0x12F0 */ int (*request_main_demo_getoff_boat_standup_all_proc)(GAME*, const xyz_t*, s16, int);\n  /* 0x12F4 */ int (*request_main_demo_get_golden_item2_all_proc)(GAME*, int, int);\n  /* 0x12F8 */ int (*request_main_demo_get_golden_axe_wait_all_proc)(GAME*, int);\n  /* 0x12FC */ int (*check_request_main_priority_proc)(GAME*, int); \n  /* 0x1300 */ void* (*get_door_label_proc)(GAME*); \n  /* 0x1304 */ int (*Set_Item_net_catch_request_table_proc)(ACTOR*, GAME*, u32, s8, const xyz_t*, f32);\n  /* 0x1308 */ f32 (*Get_Item_net_catch_swing_timer_proc)(ACTOR*, GAME*);\n  /* 0x130C */ u8 (*Set_Item_net_catch_request_force_proc)(ACTOR*, GAME*, u32, s8);\n  /* 0x1310 */ void (*Set_force_position_angle_proc)(GAME*, const xyz_t*, const s_xyz*, u8);\n  /* 0x1314 */ u8 (*Get_force_position_angle_proc)(GAME*, xyz_t*, s_xyz*);\n  /* 0x1318 */ int (*Get_WadeEndPos_proc)(GAME*, xyz_t*);\n  /* 0x131C */ u8 tmp131C[0x138C - 0x131C];\n  /* 0x138C */ int a_btn_pressed;\n  /* 0x1390 */ int a_btn_triggers_submenu;\n  /* 0x1394 */ mActor_name_t item_in_front; /* item directly in front of the player */\n  /* 0x1396 */ u8 _1396[0x13A8 - 0x1396];\n  /* TODO: finish */\n};\n\nextern PLAYER_ACTOR* get_player_actor_withoutCheck(GAME_PLAY* play);\nextern void mPlib_SetData1_controller_data_for_title_demo(f32 stick_x, f32 stick_y, int btn_a, int btn_b);\nextern void mPlib_SetData2_controller_data_for_title_demo(mActor_name_t tool);\nextern void mPlib_request_main_invade_type1(GAME_PLAY* play);\nextern mActor_name_t mPlib_Get_itemNo_forWindow();\nextern int mPlib_check_able_change_camera_normal_index();\n\nenum field_type2 {\n  mFI_FIELDTYPE2_FG,\n  mFI_FIELDTYPE2_PLAYER_ROOM,\n  mFI_FIELDTYPE2_NPC_ROOM,\n  mFI_FIELDTYPE2_ROOM,\n\n  mFI_FIELDTYPE2_NUM\n};\n\nextern Gfx fki_win_mode[];\nextern Gfx fki_win_w3T_model[];\nextern Gfx fki_win_w2T_model[];\nextern Gfx fki_win_w4_model[];\nextern Gfx fki_win_w1T_model[];\n\nextern Gfx cam_win_winT_model[];\nextern Gfx cam_win_cT_model[];\nextern Gfx cam_win_mojiT_model[];\nextern Gfx cam_win_yajirushi_model[];\n\nextern Gfx elc_win_winT_model[];\nextern Gfx elc_win_zT_model[];\nextern Gfx elc_win_moji_model[];\nextern Gfx elc_win_moji2T_model[];\n\nextern Gfx mny_win_ueT_model[];\nextern Gfx mny_win_beruT_model[];\nextern Gfx mny_win_mojiT_model[];\n\n#define SCREEN_WIDTH 320\n#define SCREEN_HEIGHT 240\n\n#define SCREEN_WIDTH_F ((f32)SCREEN_WIDTH)\n#define SCREEN_HEIGHT_F ((f32)SCREEN_HEIGHT)\n\n/* audio is monophonic */\n#define MONO(id) (id | 0x1000)\n\n#define SE_COIN 0x4C\n#define SE_REGISTER MONO(0x50)\n\n#define MONEY_NUM 4\n\n#define ITM_MONEY_START 0x2100\n#define ITM_MONEY_1000 ITM_MONEY_START // 0x2100\n#define ITM_MONEY_10000 (ITM_MONEY_1000 + 1) // 0x2101\n#define ITM_MONEY_30000 (ITM_MONEY_10000 + 1) // 0x2102\n#define ITM_MONEY_100 (ITM_MONEY_30000 + 1) // 0x2103\n#define ITM_MONEY_END ITM_MONEY_100 // 0x2103\n\nextern int mPr_GetPossessionItemSumWithCond(Private_c* priv, mActor_name_t item_no, u32 cond);\n\nenum {\n  mPr_ITEM_COND_NORMAL,\n  mPr_ITEM_COND_PRESENT,\n  mPr_ITEM_COND_QUEST,\n  \n  mPr_ITEM_COND_NUM\n};\n\nextern mActor_name_t mPlib_Get_itemNo_forWindow();\nextern int mPlib_check_able_change_camera_normal_index();\n\nextern void Matrix_push();\nextern void Matrix_pull();\nextern void Matrix_get(MtxF* m);\nextern void Matrix_put(MtxF* m);\nextern void new_Matrix(GAME* game);\n\nextern void Matrix_softcv3_mult(xyz_t* src, s_xyz* dest);\nextern Mtx* _MtxF_to_Mtx(MtxF* src, Mtx* dest);\nextern void Matrix_mult(MtxF* m, s8 flag);\nextern void Matrix_scale(f32 x, f32 y, f32 z, s8 flag);\nextern void Matrix_translate(f32 x, f32 y, f32 z, s8 flag);\nextern void Matrix_Position(xyz_t* wpos, xyz_t* screen_pos);\nextern Mtx* _Matrix_to_Mtx_new(GRAPH* graph);\n\nextern f32 mFont_SetLineStrings(\n  GAME* game,\n  u8* str,\n  int len,\n  f32 x, f32 y,\n  int r, int g, int b, int a,\n  int flag_revert, int flag_cut,\n  f32 scale_x, f32 scale_y,\n  int mode\n);\n\nextern int mFont_UnintToString(\n  u8* str,\n  int figure,\n  u32 num,\n  int figure_start,\n  int left_cut,\n  int fill_zero,\n  int separator\n);\n\nextern int mFont_GetStringWidth(u8* str, int len, int cut);\nextern int mMl_strlen(u8* str, int maxlen, u8 check_char);\n\nextern f32 add_calc(f32* pValue, f32 target, f32 fraction, f32 maxStep, f32 minStep);\n\nextern inline float sqrtf(float x)\n{\n    static const double half = 0.5;\n    static const double three = 3.0;\n\tvolatile float y;\n\tif(x > 0.0f)\n\t{\n\t\tdouble guess = __frsqrte((double)x);   // returns an approximation to\n\t\tguess = half*guess*(three - guess*guess*x);  // now have 12 sig bits\n\t\tguess = half*guess*(three - guess*guess*x);  // now have 24 sig bits\n\t\tguess = half*guess*(three - guess*guess*x);  // now have 32 sig bits\n\t\ty=(float)(x*guess);\n\t\treturn y;\n\t}\n\treturn x;\n}\n\ntypedef struct watch_my_step_s {\n  f32 pos_x;\n  f32 pos_y;\n  \n  f32 opacity;\n  \n  f32 trans_x;\n  f32 trans_y;\n\n  f32 scale;\n\n  s16 timer;\n\n  mActor_name_t item_no;\n\n  u8 mode;\n  u8 item_name[mIN_ITEM_NAME_LEN];\n  u8 draw_type;\n} mWt_watch_my_step_c;\n\nstatic mWt_watch_my_step_c S_watch_my_step;\n\ntypedef struct navigate_s {\n  f32 opacity;\n  s16 timer;\n  u8 mode;\n  u8 draw_type;\n} mWt_navigate_c;\n\nstatic mWt_navigate_c S_navigate;\n\ntypedef struct mybell_confirmation_s {\n  f32 opacity;\n  u32 all_money;\n  s16 coin_sfx_timer;\n  u8 mode;\n  u8 draw_type;\n  u8 update_money;\n  u8 play_finish_sfx;\n} mWt_mybell_confirmation_c;\n\nstatic mWt_mybell_confirmation_c S_mybell_conf;\n\nextern int ScreenWidth;\nextern int ScreenHeight;\n\nextern void Matrix_RotateX(s16 x, s8 flag);\nextern void Matrix_RotateY(s16 x, s8 flag);\nextern void Matrix_RotateZ(s16 x, s8 flag);\n\nvoid guOrtho(Mtx *m, float l, float r, float b, float t, float n, float f, float scale);\n\nvoid guRotate(Mtx* m, float a, float x, float y, float z);\n\n void guLookAt(Mtx *m, \n\t\t\tfloat xEye, float yEye, float zEye,\n\t\t\tfloat xAt,  float yAt,  float zAt,\n\t\t\tfloat xUp,  float yUp,  float zUp);\n\t\t\t\nvoid guPerspective(Mtx *m, u16 *perspNorm, float fovy, \n\t\t\t  float aspect, float near, float far, float scale);\n\n\n\n#define mTM_SECONDS_IN_HOUR 60 * 60\n#define mTM_SECONDS_IN_MINUTE 60\n\n#define SCENE_INVALID -1\n\nenum weather_intensity {\n  mEnv_WEATHER_INTENSITY_NONE,\n  mEnv_WEATHER_INTENSITY_LIGHT,\n  mEnv_WEATHER_INTENSITY_NORMAL,\n  mEnv_WEATHER_INTENSITY_HEAVY,\n\n  mEnv_WEATHER_INTENSITY_NUM,\n};\n\nenum {\n  mPr_SUNBURN_RANK_MIN,\n\n  mPr_SUNBURN_RANK0 = mPr_SUNBURN_RANK_MIN,\n  mPr_SUNBURN_RANK1,\n  mPr_SUNBURN_RANK2,\n  mPr_SUNBURN_RANK3,\n  mPr_SUNBURN_RANK4,\n  mPr_SUNBURN_RANK5,\n  mPr_SUNBURN_RANK6,\n  mPr_SUNBURN_RANK7,\n  mPr_SUNBURN_RANK8,\n  \n  mPr_SUNBURN_RANK_MAX = mPr_SUNBURN_RANK8,\n\n  mPr_SUNBURN_RANK_NUM\n};\n\nenum {\n  mPr_SEX_MALE,\n  mPr_SEX_FEMALE,\n  mPr_SEX_OTHER,\n\n  mPr_SEX_NUM = mPr_SEX_OTHER\n};\n\nenum {\n  mPr_FACE_TYPE0,\n  mPr_FACE_TYPE1,\n  mPr_FACE_TYPE2,\n  mPr_FACE_TYPE3,\n  mPr_FACE_TYPE4,\n  mPr_FACE_TYPE5,\n  mPr_FACE_TYPE6,\n  mPr_FACE_TYPE7,\n\n  mPr_FACE_TYPE_NUM\n};\n\nextern void mTM_set_renew_time(lbRTC_ymd_c* renew_time, lbRTC_time_c* rtc_time);\nextern void mTM_set_season();\n\nenum {\n  mTM_SEASON_BEGIN = 0,\n  mTM_SEASON_SPRING = mTM_SEASON_BEGIN,\n  mTM_SEASON_SUMMER,\n  mTM_SEASON_AUTUMN,\n  mTM_SEASON_WINTER,\n  mTM_SEASON_NUM\n};\n\n\n\n#define SELECT_COURSE_NUM_VISIBLE 14\n\ntypedef void (*GAME_PROC)(GAME*, int);\n\nenum {\n  SELECT_CHECK_A_BUTTON_RTC,\n  SELECT_CHECK_A_BUTTON_TIME,\n  SELECT_CHECK_A_BUTTON_STEP,\n  SELECT_CHECK_A_BUTTON_WEATHER,\n  SELECT_CHECK_A_BUTTON_SEX,\n  SELECT_CHECK_A_BUTTON_FACE_TYPE,\n  SELECT_CHECK_A_BUTTON_SWELL,\n  SELECT_CHECK_A_BUTTON_DECOY,\n  SELECT_CHECK_A_BUTTON_CLOTH,\n  SELECT_CHECK_A_BUTTON_SUNBURN,\n  SELECT_CHECK_A_BUTTON_EVENT,\n\n  SELECT_CHECK_A_BUTTON_NUM\n};\n\nenum {\n  SELECT_STATUS_MAIN,\n  SELECT_STATUS_SETUP,\n  SELECT_STATUS_TIME_SET,\n  SELECT_STATUS_CLOTH_SEL,\n\n  SELECT_STATUS_NUM\n};\n\n/* sizeof(struct game_select_s) == 0x0238 */\ntypedef struct game_select_s {\n  /* 0x0000 */ GAME game;\n  /* 0x00E0 */ View view;\n  /* 0x0200 */ int status;\n  /* 0x0204 */ int cursor_x;\n  /* 0x0208 */ int cursor_y;\n  /* 0x020C */ int step;\n  /* 0x0210 */ int step_add;\n  /* 0x0214 */ int selected_course;\n  /* 0x0218 */ int top_course; /* course at top of screen it seems */\n  /* 0x021C */ u32 unk_21C;\n  /* 0x0220 */ int button_step;\n  /* 0x0224 */ u8 name[PLAYER_NAME_LEN];\n  /* 0x0228 */ int unk_228[3];\n} GAME_SELECT;\n\nextern void select_init(GAME* game);\nextern void select_cleanup(GAME* game);\n\n\n#define cKF_FRAMERATE 30.0f\n#define cKF_FRAMETIME (1.0f / cKF_FRAMERATE)\n#define cKF_EPSILON 0.008f\n\nextern f32 cKF_HermitCalc(f32 t, f32 tension, f32 p0, f32 p1, f32 m0, f32 m1);\nextern void cKF_SkeletonInfo_subRotInterpolation(f32 t, s16* out, s16 rot1, s16 rot2);\n\nextern void cKF_SkeletonInfo_R_ct(cKF_SkeletonInfo_R_c* keyframe, cKF_Skeleton_R_c* skeleton, cKF_Animation_R_c* animation, s_xyz* work_table, s_xyz* target_table);\nextern void cKF_SkeletonInfo_R_dt();\n\nextern void cKF_SkeletonInfo_R_init_standard_stop(cKF_SkeletonInfo_R_c* keyframe, cKF_Animation_R_c* animation, s_xyz* rotation_diff_table);\nextern void cKF_SkeletonInfo_R_init_standard_stop_morph(cKF_SkeletonInfo_R_c* keyframe, cKF_Animation_R_c* animation, s_xyz* rotation_diff_table, f32 morph);\nextern void cKF_SkeletonInfo_R_init_standard_repeat(cKF_SkeletonInfo_R_c* keyframe, cKF_Animation_R_c* animation, s_xyz* rotation_diff_table);\nextern void cKF_SkeletonInfo_R_init_standard_repeat_morph(cKF_SkeletonInfo_R_c* keyframe, cKF_Animation_R_c* animation, s_xyz* rotation_diff_table, f32 morph);\n\nextern void cKF_SkeletonInfo_R_init(cKF_SkeletonInfo_R_c* keyframe, cKF_Skeleton_R_c* skeleton, cKF_Animation_R_c* animation, f32 start_frame, f32 end_frame, \nf32 current_frame, f32 frame_speed, f32 morph_counter,int mode,s_xyz* rotation_diff_table);\n\nextern int cKF_SkeletonInfo_R_play(cKF_SkeletonInfo_R_c* keyframe);\n\nextern void cKF_Si3_draw_SV_R_child(GAME* game, cKF_SkeletonInfo_R_c* keyframe, int* joint_num, cKF_draw_callback prerender_callback, cKF_draw_callback postrender_callback, void* arg, Mtx** mtxpp);\nextern void cKF_Si3_draw_R_SV(GAME* game, cKF_SkeletonInfo_R_c* keyframe, Mtx* mtxp, cKF_draw_callback prerender_callback, cKF_draw_callback postrender_callback, void* arg);\n\nextern void cKF_SkeletonInfo_R_init_standard_repeat_speedsetandmorph(cKF_SkeletonInfo_R_c* keyframe, cKF_Animation_R_c* animation, s_xyz* rotation_diff_table, f32 frame_speed, f32 morph_counter);\nextern void cKF_SkeletonInfo_R_init_standard_repeat_setframeandspeedandmorph(cKF_SkeletonInfo_R_c* keyframe, cKF_Animation_R_c* animation, s_xyz* rotation_diff_table, f32 frame, f32 frame_speed, f32 morph_counter);\nextern void cKF_SkeletonInfo_R_init_standard_setframeandspeedandmorphandmode(cKF_SkeletonInfo_R_c* keyframe, cKF_Animation_R_c* animation, s_xyz* rotation_diff_table, f32 frame, f32 frame_speed, f32 morph_counter, int mode);\nextern void cKF_SkeletonInfo_R_init_reverse_setspeedandmorphandmode(cKF_SkeletonInfo_R_c* keyframe, cKF_Animation_R_c* animation, s_xyz* rotation_diff_table, f32 frame_speed, f32 morph_counter, int mode);\n\nextern void cKF_SkeletonInfo_R_combine_work_set(cKF_SkeletonInfo_R_combine_work_c* combine, cKF_SkeletonInfo_R_c* keyframe);\nextern void cKF_SkeletonInfo_R_combine_translation(s16** joint, int* flag, cKF_SkeletonInfo_R_combine_work_c* combine , s8* cwork_num);\nextern void cKF_SkeletonInfo_R_combine_rotation(s16** joint, int* flag, cKF_SkeletonInfo_R_combine_work_c* combine , s8* cwork_num);\n\nextern int cKF_SkeletonInfo_R_combine_play(cKF_SkeletonInfo_R_c* info1, cKF_SkeletonInfo_R_c* info2,s8* flag);\n\nextern void cKF_SkeletonInfo_R_T_combine_play(int* arg1, int* arg2, int* arg3,cKF_SkeletonInfo_R_c* info1, cKF_SkeletonInfo_R_c* info2, cKF_SkeletonInfo_R_c* info3,s8* flag);\nextern void cKF_SkeletonInfo_R_Animation_Set_base_shape_trs(f32 transx, f32 transy, f32 transz, cKF_SkeletonInfo_R_c* keyframe, s16 anglex, s16 angley, s16 anglez);\nextern void cKF_SkeletonInfo_R_AnimationMove_ct_base(f32 counter, xyz_t* basepos, xyz_t* correctpos, s16 ybase, s16 yidle, cKF_SkeletonInfo_R_c* keyframe, int animation_flag);\nextern void cKF_SkeletonInfo_R_AnimationMove_dt(cKF_SkeletonInfo_R_c* keyframe);\nextern void cKF_SkeletonInfo_R_AnimationMove_base(xyz_t* base, s_xyz* sbase, xyz_t* move, s16 yidle, cKF_SkeletonInfo_R_c* keyframe);\n\nextern void cKF_SkeletonInfo_R_AnimationMove_CulcTransToWorld(f32 calcx, f32 calcy, f32 calcz, xyz_t* base, xyz_t* calcp, s16 val, xyz_t* trans, cKF_SkeletonInfo_R_c* keyframe, int animation_flag);\n\nextern f32 cos_s(s16 angle);\nextern f32 sin_s(s16 angle);\n\nextern int mNpc_SearchAnimalinfo(Animal_c* animal, mActor_name_t npc_name, int count);\nextern int mNpc_RegistEventNpc(mActor_name_t actor_name, mActor_name_t tex_name, mActor_name_t npc_name, mActor_name_t cloth_name);\nextern void mNpc_ClearAnimalInfo(Animal_c* animal_p);\nextern Animal_c* mNpc_GetInAnimalP();\n\nextern Gfx* gfx_gSPTextureRectangle1(Gfx* gfx, u32 ulx, u32 uly, u32 lrx, u32 lry, int tile, int s, int t, int dsdx, int dtdy);\n\n#define aAL_BACK_FADEIN_RATE 20\n#define aAL_BACK_FADEIN_MAX 220\n\n#define aAL_TIMER 60\n#define aAL_FADEOUT_TIMER 26\n\n#define aAL_COPYRIGHT_ALPHA_RATE 63\n\ntypedef struct actor_animal_logo_s ANIMAL_LOGO_ACTOR;\n\ntypedef void (*ANIMAL_LOGO_ACTION_PROC)(ANIMAL_LOGO_ACTOR*, GAME*);\n\nstruct actor_animal_logo_s {\n  ACTOR actor_class;\n  \n  int action;\n  ANIMAL_LOGO_ACTION_PROC action_proc;\n  \n  cKF_SkeletonInfo_R_c animal_skeleton;\n  s_xyz* animal_work_area_p;\n  s_xyz* animal_morph_area_p;\n\n  cKF_SkeletonInfo_R_c cros_skeleton;\n  s_xyz* cros_work_area_p;\n  s_xyz* cros_morph_area_p;\n\n  cKF_SkeletonInfo_R_c sing_skeleton;\n  s_xyz* sing_work_area_p;\n  s_xyz* sing_morph_area_p;\n\n  s_xyz animal_work_area[22];\n  s_xyz animal_morph_area[22];\n\n  s_xyz cros_work_area[15];\n  s_xyz cros_morph_area[15];\n\n  s_xyz sing_work_area[15];\n  s_xyz sing_morph_area[15];\n\n  s16 back_opacity;\n  int copyright_opacity;\n  f32 press_start_opacity;\n  s16 start_opacity_timer;\n  int title_timer;\n  int titledemo_no;\n\n  int unused_56C[6];\n};\n\nenum {\n  aAL_ACTION_IN,\n  aAL_ACTION_BACK_FADE_IN,\n  aAL_ACTION_START_KEY_CHK_START,\n  aAL_ACTION_GAME_START,\n  aAL_ACTION_FADE_OUT_START,\n  aAL_ACTION_OUT,\n  aAL_ACTION_6,\n\n  aAL_ACTION_NUM\n};\n\nextern ACTOR_PROFILE Animal_Logo_Profile;\n\nextern inline double fabs(double x)\n{\n   return __fabs(x) ;\n}\n\ninline float fabsf(float x) {\n\treturn (float)fabs((double)x);\n}\n\nextern mFM_combo_info_c data_combi_table[];\nextern int data_combi_table_number;\n\n#define mMP_RESIDENTS_PER_BLOCK_MAX 4\n#define mMP_BLOCKX_MAX 6\n#define mMP_BLOCKZ_MAX 7\n\n#define mMP_CURSOR_FRAMES 18\n#define mMP_LABEL_WORD_NUM 2\n\n#define mMP_BLOCK_SIZE_F 22.0f\n\nenum label_type {\n  mMP_LABEL_NPC,\n  mMP_LABEL_PLAYER,\n  mMP_LABEL_SHOP,\n  mMP_LABEL_POLICE,\n  mMP_LABEL_POST,\n  mMP_LABEL_SHRINE,\n  mMP_LABEL_STATION,\n  mMP_LABEL_JUNK,\n  mMP_LABEL_MUSEUM,\n  mMP_LABEL_NEEDLE,\n  mMP_LABEL_PORT,\n\n  mMP_LABEL_NUM\n};\n\ntypedef struct map_resident_info_s {\n  u8 name[PLAYER_NAME_LEN];\n  s8 sex;\n  u8 house_layer;\n  u8 house_idx;\n} mMP_ResidentInfo_c;\n\ntypedef struct map_labelinfo_s {\n  mMP_ResidentInfo_c* residents[mMP_RESIDENTS_PER_BLOCK_MAX];\n  s16 label_cnt;\n  s16 label_no;\n} mMP_LabelInfo_c;\n\ntypedef struct map_house_pos_entry_s {\n  u8 ut_x;\n  u8 ut_z;\n\n  u8 idx;\n} mMP_HousePos_Entry_c;\n\ntypedef struct map_house_pos_s {\n  mActor_name_t fgblock_name;\n  mMP_HousePos_Entry_c entries[3];\n} mMP_HousePos_c;\n\ntypedef struct map_label_word_s {\n  f32 ofs_x;\n  f32 ofs_y;\n\n  u8* str;\n  int str_len;\n} mMP_LabelWord_c;\n\ntypedef struct map_label_s {\n  f32 ofs_x;\n  f32 ofs_y;\n\n  Gfx* gfx;\n  mMP_LabelWord_c* words[mMP_LABEL_WORD_NUM];\n} mMP_Label_c;\n\nstruct map_overlay_s {\n  u8 sel_bx;\n  u8 sel_bz;\n\n  u8 player_bx;\n  u8 player_bz;\n\n  f32 map_cursor_current_xpos;\n  f32 map_cursor_current_zpos;\n\n  f32 map_cursor_target_xpos;\n  f32 map_cursor_target_zpos;\n\n  int cursor_frame;\n\n  int unk_18[2];\n\n  u8* map_texture[FG_BLOCK_TOTAL_NUM];\n  u8 map_pal[FG_BLOCK_TOTAL_NUM];\n\n  mFM_combo_info_c* combination_table;\n  \n  mMP_ResidentInfo_c player_info[PLAYER_NUM];\n  mMP_ResidentInfo_c animal_info[ANIMAL_NUM_MAX];\n\n  mMP_LabelInfo_c label_info[FG_BLOCK_Z_NUM][FG_BLOCK_X_NUM];\n\n  int unk_3E8[2];\n\n  u8 land_name_str_len;\n  int unk_3F4;\n};\n\nenum {\n  mHS_HOUSE0, /* Top-left house */\n  mHS_HOUSE1, /* Top-right house */\n  mHS_HOUSE2, /* Bottom-left house */\n  mHS_HOUSE3, /* Bottom-right house */\n\n  mHS_HOUSE_NUM\n};\n\nextern void mAGrw_RenewalFgItem_ovl(lbRTC_time_c* time, int* haniwa_scheduled);\nextern void mAGrw_SearchDump(mFI_unit_c* dump_info);\n\n/* Macro to generate a random float in the range of [0, n) */\n#define RANDOM_F(n) (fqrand() * (f32)(n))\n\n/* Macro to generate a random integer in the range of [0, n) */\n#define RANDOM(n) ((int)RANDOM_F(n))\n\nextern void mMsm_DepositItemBlock_cancel(mActor_name_t* fg_items, mActor_name_t deposit_item, mCoBG_Collision_u* col_data, u16* deposit, u16* cancel_ut, u8 valid_ut_count);\nextern u8 mMsm_GetDepositBlockNum(u8);\n\n#define PI 3.14159265358979323846\n#define F_PI ((f32)PI)\n\n#define SQRT2 (1.4142135623730950488016887242097)\n#define F_SQRT2 ((f32)SQRT2)\n\n#define SHT_MIN_S -32768 /* 0x8000 */\n#define SHT_MAX_S  32767 /* 0x7FFF */\n\n#define SHT_MIN ((f32)SHT_MIN_S)\n#define SHT_MAX ((f32)SHT_MAX_S)\n\n#define SHT_MINV (1.0f / SHT_MAX)\n#define ABS(x) (((x) >= 0) ? (x) : -(x))\n#define SQ(x) ((x)*(x))\n\n/* radians -> short angle */\n#define RAD2SHORT_ANGLE(rad) ((s16)(int)((rad) * (65536.0f / (2.0f * F_PI))))\n#define RAD2SHORTANGLE(rad)\t((s16)((32768.0f / F_PI) * ((f32)(rad))))\n\n/* short angle -> radians */\n#define SHORT2RAD_ANGLE(s) ((((f32)(s)) / (65536.0f / (2.0f * F_PI))))\n#define SHORTANGLE2RAD(sangle)\t((F_PI / 32768.0f) * ((f32)(sangle)))\n\n/* degrees -> short angle */\n#define DEG2SHORT_ANGLE(deg) ((s16)((deg) * (65536.0f / 360.0f)))\n\n/* short angle -> degrees */\n#define SHORT2DEG_ANGLE(s) ((((f32)(s)) / (65536.0f / 360.0f)))\n\n/* radians -> degrees */\n#define RAD2DEG(rad) ((180.0f / F_PI) * (rad))\n\n/* degrees -> radians */\n#define DEG2RAD(deg) ((F_PI / 180.0f) * (deg))\n\nextern s_xyz ZeroSVec;\nextern xyz_t ZeroVec;\n\nenum actor_profile_table {\n  mAc_PROFILE_PLAYER,\n  mAc_PROFILE_BGITEM,\n  mAc_PROFILE_SAMPLE,\n  mAc_PROFILE_FIELDM_DRAW,\n  mAc_PROFILE_FIELD_DRAW,\n  mAc_PROFILE_AIRPLANE,\n  mAc_PROFILE_ROOM_SUNSHINE,\n  mAc_PROFILE_LAMP_LIGHT,\n  mAc_PROFILE_EV_ANGLER,\n  mAc_PROFILE_BALL,\n  mAc_PROFILE_HANIWA,\n  mAc_PROFILE_MY_ROOM,\n  mAc_PROFILE_MBG,\n  mAc_PROFILE_T_TAMA,\n  mAc_PROFILE_BOXMANAGER,\n  mAc_PROFILE_BOXMOVE,\n  mAc_PROFILE_BOXTRICK01,\n  mAc_PROFILE_ARRANGE_ROOM,\n  mAc_PROFILE_ARRANGE_FURNITURE,\n  mAc_PROFILE_TRAINDOOR,\n  mAc_PROFILE_T_KEITAI,\n  mAc_PROFILE_HALLOWEEN_NPC,\n  mAc_PROFILE_EV_PUMPKIN,\n  mAc_PROFILE_RIDE_OFF_DEMO,\n  mAc_PROFILE_NPC_MAMEDANUKI,\n  mAc_PROFILE_HANABI_NPC0,\n  mAc_PROFILE_HANABI_NPC1,\n  mAc_PROFILE_SNOWMAN,\n  mAc_PROFILE_NPC_POST_GIRL,\n  mAc_PROFILE_NPC_ENGINEER,\n  mAc_PROFILE_NPC_MAJIN3,\n  mAc_PROFILE_NPC_SLEEP_OBABA,\n  mAc_PROFILE_NPC,\n  mAc_PROFILE_EFFECT_CONTROL,\n  mAc_PROFILE_NPC2,\n  mAc_PROFILE_KAMAKURA_NPC0,\n  mAc_PROFILE_NPC_POST_MAN,\n  mAc_PROFILE_SHOP_DESIGN,\n  mAc_PROFILE_QUEST_MANAGER,\n  mAc_PROFILE_MAILBOX,\n  mAc_PROFILE_HOUSE,\n  mAc_PROFILE_SHOP_LEVEL,\n  mAc_PROFILE_SHOP,\n  mAc_PROFILE_MYHOUSE,\n  mAc_PROFILE_EV_ARTIST,\n  mAc_PROFILE_EV_BROKER,\n  mAc_PROFILE_EV_DESIGNER,\n  mAc_PROFILE_T_UMBRELLA,\n  mAc_PROFILE_NPC_SHOP_MASTER,\n  mAc_PROFILE_BIRTH_CONTROL,\n  mAc_PROFILE_SHOP_MANEKIN,\n  mAc_PROFILE_SHOP_INDOOR,\n  mAc_PROFILE_EVENT_MANAGER,\n  mAc_PROFILE_SHOP_GOODS,\n  mAc_PROFILE_BRSHOP,\n  mAc_PROFILE_WEATHER,\n  mAc_PROFILE_POST_OFFICE,\n  mAc_PROFILE_NPC_GUIDE,\n  mAc_PROFILE_NPC_GUIDE2,\n  mAc_PROFILE_INSECT,\n  mAc_PROFILE_STATION,\n  mAc_PROFILE_EV_CARPETPEDDLER,\n  mAc_PROFILE_EV_KABUPEDDLER,\n  mAc_PROFILE_RESERVE,\n  mAc_PROFILE_HANDOVERITEM,\n  mAc_PROFILE_NPC_CONV_MASTER,\n  mAc_PROFILE_NPC_SUPER_MASTER,\n  mAc_PROFILE_NPC_DEPART_MASTER,\n  mAc_PROFILE_TOOLS,\n  mAc_PROFILE_STRUCTURE,\n  mAc_PROFILE_EV_GYPSY,\n  mAc_PROFILE_NPC_POLICE,\n  mAc_PROFILE_TRAIN0,\n  mAc_PROFILE_TRAIN1,\n  mAc_PROFILE_NPC_STATION_MASTER,\n  mAc_PROFILE_EV_SANTA,\n  mAc_PROFILE_NPC_POLICE2,\n  mAc_PROFILE_POLICE_BOX,\n  mAc_PROFILE_BGPOLICEITEM,\n  mAc_PROFILE_BGCHERRYITEM,\n  mAc_PROFILE_BGWINTERITEM,\n  mAc_PROFILE_BGXMASITEM,\n  mAc_PROFILE_BGPOSTITEM,\n  mAc_PROFILE_FALLS,\n  mAc_PROFILE_FALLSESW,\n  mAc_PROFILE_EV_BROKER2,\n  mAc_PROFILE_BROKER_DESIGN,\n  mAc_PROFILE_T_UTIWA,\n  mAc_PROFILE_PSNOWMAN,\n  mAc_PROFILE_MY_INDOOR,\n  mAc_PROFILE_NPC_RCN_GUIDE,\n  mAc_PROFILE_INTRO_DEMO,\n  mAc_PROFILE_SHRINE,\n  mAc_PROFILE_BUGGY,\n  mAc_PROFILE_T_HANABI,\n  mAc_PROFILE_CONVENI,\n  mAc_PROFILE_SUPER,\n  mAc_PROFILE_DEPART,\n  mAc_PROFILE_HANAMI_NPC0,\n  mAc_PROFILE_S_CAR,\n  mAc_PROFILE_HANAMI_NPC1,\n  mAc_PROFILE_NPC_P_SEL,\n  mAc_PROFILE_NPC_P_SEL2,\n  mAc_PROFILE_NPC_RCN_GUIDE2,\n  mAc_PROFILE_TRAIN_WINDOW,\n  mAc_PROFILE_NPC_MAJIN4,\n  mAc_PROFILE_KAMAKURA,\n  mAc_PROFILE_GYOEI,\n  mAc_PROFILE_NPC_MAJIN,\n  mAc_PROFILE_T_NPCSAO,\n  mAc_PROFILE_EV_SONCHO,\n  mAc_PROFILE_UKI,\n  mAc_PROFILE_NPC_MAJIN2,\n  mAc_PROFILE_NORMAL_NPC,\n  mAc_PROFILE_SET_MANAGER,\n  mAc_PROFILE_SET_NPC_MANAGER,\n  mAc_PROFILE_NPC_SHOP_MASTERSP,\n  mAc_PROFILE_ROOM_SUNSHINE_POSTHOUSE,\n  mAc_PROFILE_ROOM_SUNSHINE_POLICE,\n  mAc_PROFILE_EFFECTBG,\n  mAc_PROFILE_EV_CHERRY_MANAGER,\n  mAc_PROFILE_EV_YOMISE,\n  mAc_PROFILE_TOKYOSO_NPC0,\n  mAc_PROFILE_TOKYOSO_NPC1,\n  mAc_PROFILE_GOZA,\n  mAc_PROFILE_RADIO,\n  mAc_PROFILE_YATAI,\n  mAc_PROFILE_TOKYOSO_CONTROL,\n  mAc_PROFILE_SHOP_UMBRELLA,\n  mAc_PROFILE_GYO_RELEASE,\n  mAc_PROFILE_TUKIMI,\n  mAc_PROFILE_KAMAKURA_INDOOR,\n  mAc_PROFILE_EV_MIKO,\n  mAc_PROFILE_GYO_KAGE,\n  mAc_PROFILE_MIKUJI,\n  mAc_PROFILE_HOUSE_GOKI,\n  mAc_PROFILE_T_CRACKER,\n  mAc_PROFILE_NPC_NEEDLEWORK,\n  mAc_PROFILE_T_PISTOL,\n  mAc_PROFILE_T_FLAG,\n  mAc_PROFILE_T_TUMBLER,\n  mAc_PROFILE_TUKIMI_NPC0,\n  mAc_PROFILE_TUKIMI_NPC1,\n  mAc_PROFILE_NEEDLEWORK_SHOP,\n  mAc_PROFILE_COUNTDOWN_NPC0,\n  mAc_PROFILE_COUNTDOWN_NPC1,\n  mAc_PROFILE_TURI_NPC0,\n  mAc_PROFILE_TAISOU_NPC0,\n  mAc_PROFILE_COUNT,\n  mAc_PROFILE_GARAGARA,\n  mAc_PROFILE_TAMAIRE_NPC0,\n  mAc_PROFILE_TAMAIRE_NPC1,\n  mAc_PROFILE_HATUMODE_NPC0,\n  mAc_PROFILE_NPC_TOTAKEKE,\n  mAc_PROFILE_COUNT02,\n  mAc_PROFILE_HATUMODE_CONTROL,\n  mAc_PROFILE_TAMA,\n  mAc_PROFILE_KAGO,\n  mAc_PROFILE_TURI,\n  mAc_PROFILE_HOUSE_CLOCK,\n  mAc_PROFILE_TUNAHIKI_CONTROL,\n  mAc_PROFILE_TUNAHIKI_NPC0,\n  mAc_PROFILE_TUNAHIKI_NPC1,\n  mAc_PROFILE_KOINOBORI,\n  mAc_PROFILE_BEE,\n  mAc_PROFILE_NAMEPLATE,\n  mAc_PROFILE_DUMP,\n  mAc_PROFILE_ROPE,\n  mAc_PROFILE_EV_DOZAEMON,\n  mAc_PROFILE_WINDMILL,\n  mAc_PROFILE_LOTUS,\n  mAc_PROFILE_ANIMAL_LOGO,\n  mAc_PROFILE_MIKANBOX,\n  mAc_PROFILE_DOUZOU,\n  mAc_PROFILE_NPC_RTC,\n  mAc_PROFILE_TOUDAI,\n  mAc_PROFILE_NPC_RESTART,\n  mAc_PROFILE_NPC_MAJIN5,\n  mAc_PROFILE_FUUSEN,\n  mAc_PROFILE_EV_DOKUTU,\n  mAc_PROFILE_DUMMY,\n  mAc_PROFILE_NPC_CURATOR,\n  mAc_PROFILE_MUSEUM,\n  mAc_PROFILE_EV_GHOST,\n  mAc_PROFILE_MUSEUM_PICTURE,\n  mAc_PROFILE_185,\n  mAc_PROFILE_MUSEUM_FISH,\n  mAc_PROFILE_MUSEUM_INSECT,\n  mAc_PROFILE_BRIDGE_A,\n  mAc_PROFILE_ROOM_SUNSHINE_MUSEUM,\n  mAc_PROFILE_NEEDLEWORK_INDOOR,\n  mAc_PROFILE_ROOM_SUNSHINE_MINSECT,\n  mAc_PROFILE_MUSEUM_FOSSIL,\n  mAc_PROFILE_MURAL,\n  mAc_PROFILE_AC_SIGN,\n  mAc_PROFILE_ANT,\n  mAc_PROFILE_NPC_SENDO,\n  mAc_PROFILE_FLAG,\n  mAc_PROFILE_PRESENT_DEMO,\n  mAc_PROFILE_PRESENT_NPC,\n  mAc_PROFILE_BOAT,\n  mAc_PROFILE_BOAT_DEMO,\n  mAc_PROFILE_COTTAGE_MY,\n  mAc_PROFILE_COTTAGE_NPC,\n  mAc_PROFILE_EV_SONCHO2,\n  mAc_PROFILE_NPC_MASK_CAT,\n  mAc_PROFILE_NPC_MASK_CAT2,\n  mAc_PROFILE_RESET_DEMO,\n  mAc_PROFILE_GO_HOME_NPC,\n  mAc_PROFILE_MISIN,\n  mAc_PROFILE_LIGHTHOUSE_SWITCH,\n  mAc_PROFILE_MUSEUM_INDOOR,\n  mAc_PROFILE_T_ANRIUM1,\n  mAc_PROFILE_T_BISCUS1,\n  mAc_PROFILE_T_BISCUS2,\n  mAc_PROFILE_T_HASU1,\n  mAc_PROFILE_T_HAT1,\n  mAc_PROFILE_T_ZINNIA1,\n  mAc_PROFILE_T_BISCUS3,\n  mAc_PROFILE_T_BISCUS4,\n  mAc_PROFILE_T_ZINNIA2,\n  mAc_PROFILE_T_HAT2,\n  mAc_PROFILE_T_HAT3,\n  mAc_PROFILE_T_REI1,\n  mAc_PROFILE_T_REI2,\n  mAc_PROFILE_NPC_SHASHO,\n  mAc_PROFILE_T_BAG1,\n  mAc_PROFILE_T_BAG2,\n  mAc_PROFILE_EV_CASTAWAY,\n  mAc_PROFILE_T_COBRA1,\n  mAc_PROFILE_BALLOON,\n  mAc_PROFILE_NPC_SONCHO,\n  mAc_PROFILE_APRILFOOL_CONTROL,\n  mAc_PROFILE_EV_MAJIN,\n  mAc_PROFILE_HARVEST_NPC0,\n  mAc_PROFILE_HARVEST_NPC1,\n  mAc_PROFILE_GROUNDHOG_CONTROL,\n  mAc_PROFILE_EV_SPEECH_SONCHO,\n  mAc_PROFILE_GROUNDHOG_NPC0,\n  mAc_PROFILE_EV_TURKEY,\n  mAc_PROFILE_GHOG,\n  mAc_PROFILE_HTABLE,\n  mAc_PROFILE_NPC_HEM,\n  mAc_PROFILE_TENT,\n  mAc_PROFILE_PTERMINAL,\n  mAc_PROFILE_MSCORE_CONTROL,\n\n  mAc_PROFILE_NUM\n};\n\nextern int Camera2_request_main_simple(GAME_PLAY* play, xyz_t* pos, s_xyz* dir, f32 dist, int morph_counter, int priority);\nextern int Camera2_request_main_inter(GAME_PLAY* play, xyz_t* start_center, xyz_t* start_eye, xyz_t* goal_center, xyz_t* goal_eye, f32 s0, f32 s1, u32 flags, int morph_counter, int priority);\nextern int Camera2_request_main_cust_talk(GAME_PLAY* play, ACTOR* speaker, ACTOR* listener, f32 center_ratio, int priority, s16 angle_x, s16 angle_y, f32 distance);\n\nextern f32 Math3d_normalizeXyz_t(xyz_t* vec);\nextern f32 Math3DLength(xyz_t* v0, xyz_t* v1);\nextern void Math3DInDivPos2(xyz_t* v0, xyz_t* v1, xyz_t* v2, f32 percent);\ns16 sins(u16);\ns16 coss(u16);\nf32 fatan2(f32, f32);\nf64 fsqrt(f32);\nf32 facos(f32);\nextern double sin(double deg);\nextern double cos(double deg);\nextern double tan(double deg);\n\nextern s16 add_calc_short_angle2(s16* pValue, s16 target, f32 fraction, s16 maxStep, s16 minStep);\nextern int chase_f(f32* const pValue, const f32 target, f32 step);\nextern f32 mFI_GetBlockWidth();\nextern f32 mFI_GetBlockHeight();\nextern int mFI_Wpos2BkandUtNuminBlock(int* block_x, int* block_z, int* ut_x, int* ut_z, xyz_t wpos);\nextern f32 get_percent_forAccelBrake(const f32 now, const f32 start, const f32 end, const f32 accelerateDist, const f32 brakeDist);\n\nextern u32 mCoBG_UtNum2BgAttr(int ut_x, int ut_z);\nextern f32 mCoBG_UtNum2UtCenterY(int ut_x, int ut_z);\nextern int mCoBG_CheckCliffAttr(u32 attribute);\n\nextern int mFI_Wpos2UtNum(int* ut_x, int* ut_z, xyz_t wpos);\nextern f32 search_position_distance(const xyz_t* const pos, const xyz_t* const target);\nextern void inter_float(f32* const pValue, const f32 arg1, const int step);\n\n#define F32_IS_ZERO(v) (fabsf(v) < 0.008f)\n\nextern void mQst_PrintQuestInfo(gfxprint_t* gfxprint);\nextern void mQst_ClearGrabItemInfo();\nextern int mQst_GetRandom(int max);\n\nextern void mEv_EventON(u32 event_kind);\n\nextern void sMath_RotateX(xyz_t* pos, f32 rad);\nextern void sMath_RotateY(xyz_t* pos, f32 rad);\nextern void sMath_RotateZ(xyz_t* pos, f32 rad);\n\n#define mChoice_CHOICE_STRING_LEN 16\n\ntypedef struct choice_s mChoice_c;\ntypedef struct choice_data_s mChoice_Data_c;\n\nenum choice {\n  mChoice_CHOICE0,\n  mChoice_CHOICE1,\n  mChoice_CHOICE2,\n  mChoice_CHOICE3,\n  mChoice_CHOICE4,\n  mChoice_CHOICE5,\n\n  mChoice_CHOICE_NUM\n};\n\nenum {\n  mChoice_AUTOMOVE_STOPPED,\n  mChoice_AUTOMOVE_INCREMENT_WAIT,\n  mChoice_AUTOMOVE_INCREMENT,\n  mChoice_AUTOMOVE_DECREMENT_WAIT,\n  mChoice_AUTOMOVE_DECREMENT,\n\n  mChoice_AUTOMOVE_NUM\n};\n\nenum {\n  mChoice_MAIN_HIDE,\n  mChoice_MAIN_APPEAR,\n  mChoice_MAIN_NORMAL,\n  mChoice_MAIN_DISAPPEAR,\n\n  mChoice_MAIN_INDEX_NUM\n};\n\nstruct choice_data_s {\n  u8 strings[mChoice_CHOICE_NUM][mChoice_CHOICE_STRING_LEN];\n  int string_lens[mChoice_CHOICE_NUM];\n  u8 determination_string[mChoice_CHOICE_STRING_LEN];\n  int determination_len;\n  int choice_num;\n  int selected_choice_idx;\n};\n\nstruct choice_s {\n  /* Current XY position (centered) */\n  f32 center_x;\n  f32 center_y;\n\n  /* Initial XY position */\n  f32 center_x_begin;\n  f32 center_y_begin;\n\n  /* Target XY position */\n  f32 center_x_target;\n  f32 center_y_target;\n\n  /* Text settings */\n  rgba_t text_color;\n  f32 text_scale_x;\n  f32 text_scale_y;\n  f32 text_x;\n  f32 text_y;\n\n  /* Window scaling XY */\n  f32 scale_x;\n  f32 scale_y;\n\n  /* Text related data */\n  mChoice_Data_c data;\n\n  int selected_choice_idx;\n  rgba_t selected_choice_text_color;\n  \n  rgba_t background_color;\n\n  f32 _D4;\n  f32 _D8;\n\n  f32 scale; // total choice window scaling percentage\n\n  int main_index;\n  int requested_main_index;\n\n  int window_visible_flag;\n  int font_visible_flag;\n\n  int choice_automove_type;\n  f32 choice_automove_timer;\n\n  f32 timer;\n\n  u8 no_b_flag; // can't press B to select last option\n  u8 no_close_flag; // pressing B won't auto-cancel the choice selection?\n};\n\nextern mChoice_c* mChoice_Get_base_window_p();\nextern int mChoice_Get_ChoseNum(mChoice_c* choice);\n\n#define mMsg_MSG_BUF_SIZE 1600\n#define mMsg_FREE_STRING_LEN 16\n#define mMsg_MAIL_STRING_LEN 132\n\nenum {\n  mMsg_INDEX_HIDE,\n  mMsg_INDEX_APPEAR,\n  mMsg_INDEX_NORMAL,\n  mMsg_INDEX_CURSOL,\n  mMsg_INDEX_DISAPPEAR,\n  mMsg_INDEX_APPEAR_WAIT,\n  mMsg_INDEX_WAIT,\n  mMsg_INDEX_DISAPPEAR_WAIT,\n\n  mMsg_INDEX_NUM\n};\n\nenum {\n  mMsg_FREE_STR0,\n  mMsg_FREE_STR1,\n  mMsg_FREE_STR2,\n  mMsg_FREE_STR3,\n  mMsg_FREE_STR4,\n  mMsg_FREE_STR5,\n  mMsg_FREE_STR6,\n  mMsg_FREE_STR7,\n  mMsg_FREE_STR8,\n  mMsg_FREE_STR9,\n  mMsg_FREE_STR10,\n  mMsg_FREE_STR11,\n  mMsg_FREE_STR12,\n  mMsg_FREE_STR13,\n  mMsg_FREE_STR14,\n  mMsg_FREE_STR15,\n  mMsg_FREE_STR16,\n  mMsg_FREE_STR17,\n  mMsg_FREE_STR18,\n  mMsg_FREE_STR19,\n\n  mMsg_FREE_STR_NUM\n};\n\nenum {\n  mMsg_ITEM_STR0,\n  mMsg_ITEM_STR1,\n  mMsg_ITEM_STR2,\n  mMsg_ITEM_STR3,\n  mMsg_ITEM_STR4,\n\n  mMsg_ITEM_STR_NUM\n};\n\nenum {\n  mMsg_MAIL_STR0,\n\n  mMsg_MAIL_STR_NUM\n};\n\ntypedef struct message_window_s mMsg_Window_c;\ntypedef struct message_data_s mMsg_Data_c;\n\n/* These are hinted at due to the 8-byte alignment forced onto these structs */\n\ntypedef struct {\n  int saved_main_index;\n} mMsg_MainAppearWait_Data_c;\n\ntypedef struct {\n  int saved_main_index;\n} mMsg_MainDisappearWait_Data_c;\n\ntypedef struct {\n  int saved_main_index;\n} mMsg_MainWait_Data_c;\n\ntypedef union {\n  mMsg_MainAppearWait_Data_c main_appear_wait;\n  mMsg_MainDisappearWait_Data_c main_disappear_wait;\n  mMsg_MainWait_Data_c main_wait;\n  u64 align;\n} mMsg_Main_Data_c;\n\ntypedef struct {\n  ACTOR* speaker_actor;\n  int msg_no;\n  int name_shown_flag;\n  rgba_t window_color;\n} mMsg_Request_MainAppear_Data_c;\n\ntypedef struct {\n  int saved_main_index;\n  int init_flags;\n} mMsg_Request_MainAppearWait_Data_c;\n\ntypedef struct {\n  int init_flags;\n} mMsg_Request_MainCursor_Data_c;\n\ntypedef struct {\n  int init_flags;\n} mMsg_Request_MainDisappearWait_Data_c;\n\ntypedef struct {\n  int init_flags;\n} mMsg_Request_MainNormal_Data_c;\n\ntypedef struct {\n  int saved_main_index;\n} mMsg_Request_MainWait_Data_c;\n\ntypedef union {\n  mMsg_Request_MainAppear_Data_c request_main_appear;\n  mMsg_Request_MainAppearWait_Data_c request_main_appear_wait;\n  mMsg_Request_MainCursor_Data_c request_main_cursor;\n  mMsg_Request_MainDisappearWait_Data_c request_main_disappear_wait;\n  mMsg_Request_MainNormal_Data_c request_main_normal;\n  mMsg_Request_MainWait_Data_c request_main_wait;\n  u64 align;\n} mMsg_Request_Data_c;\n\ntypedef union {\n  u8 data[mMsg_MSG_BUF_SIZE];\n  u64 align;\n} mMsg_MsgBuf_c;\n\nstruct message_data_s {\n  int data_loaded;\n  int msg_no;\n  int msg_len;\n  int cut;\n\n  mMsg_MsgBuf_c text_buf;\n};\n\nstruct message_window_s {\n  /* 0x000 */ int data_loaded;\n  /* 0x004 */ int msg_no;\n  /* 0x008 */ int _008;\n  /* 0x00C */ mMsg_Data_c* msg_data;\n  /* 0x010 */ f32 center_x;\n  /* 0x014 */ f32 center_y;\n  /* 0x018 */ f32 width;\n  /* 0x01C */ f32 height;\n  \n  /* 0x020 */ ACTOR* talk_actor;\n  /* 0x024 */ int show_actor_name;\n  /* 0x028 */ int actor_name_len;\n  /* 0x02C */ int nameplate_x;\n  /* 0x030 */ int nameplay_y;\n\n  /* 0x034 */ int show_continue_button;\n\n  /* 0x038 */ u8 free_str[mMsg_FREE_STR_NUM][mMsg_FREE_STRING_LEN];\n  /* 0x178 */ int free_str_article[mMsg_FREE_STR_NUM];\n\n  /* 0x1C8 */ u8 item_str[mMsg_ITEM_STR_NUM][mMsg_FREE_STRING_LEN];\n  /* 0x218 */ int item_str_article[mMsg_ITEM_STR_NUM];\n\n  /* 0x22C */ u8 mail_str[mMsg_MAIL_STR_NUM][mMsg_MAIL_STRING_LEN];\n\n  /* 0x2B0 */ rgba_t name_text_color;\n  /* 0x2B4 */ rgba_t name_background_color;\n\n  /* 0x2B8 */ rgba_t window_background_color;\n  /* 0x2BC */ rgba_t font_color[4];\n\n  /* 0x2CC */ rgba_t continue_button_color;\n\n  /* 0x2D0 */ f32 font_scale_x;\n  /* 0x2D4 */ f32 font_scale_y;\n\n  /* 0x2D8 */ int _2D8;\n  /* 0x2DC */ int _2DC;\n\n  /* 0x2E0 */ int text_lines;\n  /* 0x2E4 */ int current_line;\n\n  /* 0x2E8 */ mChoice_c choice_window;\n\n  /* 0x3E8 */ int _3E8;\n\n  /* 0x3EC */ u16 end_timer;\n  /* 0x3EE */ s16 animal_voice_idx;\n  /* 0x3F0 */ int voice_sfx_idx;\n  /* 0x3F4 */ u8 voice_idx;\n  /* 0x3F5 */ u8 voice2_idx;\n  /* 0x3F6 */ u8 voice3_idx;\n  /* 0x3F7 */ s8 hide_choice_window_timer;\n  /* 0x3F8 */ u8 force_voice_enable_flag;\n  /* 0x3FC */ int spec;\n  /* 0x400 */ u8 free_str_color_idx[4];\n  /* 0x408 */ u8 _404[8]; // unused?\n  /* 0x40C */ u32 status_flags;\n\n  /* 0x410 */ f32 timer;\n  /* 0x414 */ f32 cursor_timer;\n  /* 0x418 */ f32 continue_button_timer;\n\n  /* 0x41C */ int start_text_cursor_idx;\n  /* 0x420 */ int end_text_cursor_idx;\n  /* 0x424 */ f32 window_scale;\n  /* 0x428 */ f32 text_scale;\n\n  /* 0x42C */ int requested_main_index;\n  /* 0x430 */ int requested_priority;\n\n  /* 0x434 */ int main_index;\n  /* 0x438 */ int draw_flag;\n  /* 0x43C */ int cancel_flag;\n  /* 0x440 */ int cancelable_flag;\n  /* 0x444 */ int continue_msg_no;\n  /* 0x448 */ int continue_cancel_flag;\n  /* 0x44C */ int force_next;\n  /* 0x450 */ int lock_continue;\n  /* 0x454 */ s8 now_utter;\n\n  /* 0x458 */ mMsg_Main_Data_c main_data;\n  /* 0x460 */ mMsg_Request_Data_c request_data;\n};\n\nextern mMsg_Window_c* mMsg_Get_base_window_p();\nextern void mMsg_Set_free_str_art(mMsg_Window_c* msg, int free_str_no, u8* str, int str_size, int article_no);\nextern void mMsg_Set_item_str_art(mMsg_Window_c* msg, int free_str_no, u8* str, int str_size, int article_no);\n\nextern int mFI_GetItemNumOnBlockInField(int block_x, int block_z, mActor_name_t start_item, mActor_name_t end_item);\n\nextern void mNpc_GetActorWorldName(u8* buf, mActor_name_t id);\nextern u8 mNpc_CheckNormalMail_length(int* len, u8* body);\nextern mActor_name_t mNpc_GetNpcFurniture(AnmPersonalID_c* pid);\n\n#define MAIL_FOOTER2_LEN 48\n#define MAIL_HEADER2_LEN (MAIL_FOOTER2_LEN - PLAYER_NAME_LEN)\n\nenum {\n  mHandbill_FREE_STR0,\n  mHandbill_FREE_STR1,\n  mHandbill_FREE_STR2,\n  mHandbill_FREE_STR3,\n  mHandbill_FREE_STR4,\n  mHandbill_FREE_STR5,\n  mHandbill_FREE_STR6,\n  mHandbill_FREE_STR7,\n  mHandbill_FREE_STR8,\n  mHandbill_FREE_STR9,\n  mHandbill_FREE_STR10,\n  mHandbill_FREE_STR11,\n  mHandbill_FREE_STR12,\n  mHandbill_FREE_STR13,\n  mHandbill_FREE_STR14,\n  mHandbill_FREE_STR15,\n  mHandbill_FREE_STR16,\n  mHandbill_FREE_STR17,\n  mHandbill_FREE_STR18,\n  mHandbill_FREE_STR19,\n\n  mHandbill_FREE_STR_NUM\n};\n\nextern void mHandbill_Load_HandbillFromRom(u8* header, int* header_back_start, u8* footer, u8* body, int mail_no);\nextern void mHandbill_Load_HandbillFromRom2(u8* header, int header_size, int* header_back_pos, u8* footer, int footer_size, u8* body, int handbill_no);\nextern void mHandbill_Set_free_str(int free_str_no, u8* str, int str_len);\nextern void mHandbill_Set_free_str_art(int free_str_no, u8* str, int str_len, int article_no);\n\nenum {\n  mNpc_LOOKS_GIRL,\n  mNpc_LOOKS_KO_GIRL,\n  mNpc_LOOKS_BOY,\n  mNpc_LOOKS_SPORT_MAN,\n  mNpc_LOOKS_GRIM_MAN,\n  mNpc_LOOKS_NANIWA_LADY,\n  mNpc_LOOKS_UNSET,\n\n  mNpc_LOOKS_NUM = mNpc_LOOKS_UNSET\n};\n\nenum {\n  mMl_FONT_0,\n  mMl_FONT_SEND,\n  mMl_FONT_2,\n  mMl_FONT_3,\n  mMl_FONT_4,\n\n  mMl_FONT_NUM\n};\n\nenum events {\n  mEv_SPNPC_SHOP = (int)mEv_SET(mEv_SPNPC_EVENT, 0),\n  mEv_SPNPC_DESIGNER,\n  mEv_SPNPC_BROKER,\n  mEv_SPNPC_ARTIST,\n  mEv_SPNPC_ARABIAN,\n  mEv_SPNPC_GYPSY,\n\n  mEv_SAVED_RENEWSHOP = (int)mEv_SET(mEv_SAVED_EVENT, 0), /* renew shop */\n  mEv_SAVED_UNK1, /* unused */\n  \n  /* intro through chores */\n  mEv_SAVED_FIRSTJOB_PLR0,\n  mEv_SAVED_FIRSTJOB_PLR1,\n  mEv_SAVED_FIRSTJOB_PLR2,\n  mEv_SAVED_FIRSTJOB_PLR3,\n\n  /* selecting house */\n  mEv_SAVED_FIRSTINTRO_PLR0,\n  mEv_SAVED_FIRSTINTRO_PLR1,\n  mEv_SAVED_FIRSTINTRO_PLR2,\n  mEv_SAVED_FIRSTINTRO_PLR3,\n\n  /* wait for next day to talk about HRA */\n  mEv_SAVED_HRAWAIT_PLR0,\n  mEv_SAVED_HRAWAIT_PLR1,\n  mEv_SAVED_HRAWAIT_PLR2,\n  mEv_SAVED_HRAWAIT_PLR3,\n\n  /* Nook will talk about HRA when entering the shop */\n  mEv_SAVED_HRATALK_PLR0,\n  mEv_SAVED_HRATALK_PLR1,\n  mEv_SAVED_HRATALK_PLR2,\n  mEv_SAVED_HRATALK_PLR3,\n\n  /* Do a 'favor' for a villager during chores */\n  mEv_SAVED_FJOPENQUEST_PLR0,\n  mEv_SAVED_FJOPENQUEST_PLR1,\n  mEv_SAVED_FJOPENQUEST_PLR2,\n  mEv_SAVED_FJOPENQUEST_PLR3,\n\n  /* Player going to another town, set at train station */\n  mEv_SAVED_GATEWAY_PLR0,\n  mEv_SAVED_GATEWAY_PLR1,\n  mEv_SAVED_GATEWAY_PLR2,\n  mEv_SAVED_GATEWAY_PLR3,\n  mEv_SAVED_GATEWAY_FRGN, /* Foreigner */\n\n  mEv_DAILY_0 = (int)mEv_SET(mEv_DAILY_EVENT, 0), /* unused */\n  mEv_DAILY_1, /* unused */\n  mEv_DAILY_2, /* unused */\n  mEv_DAILY_OPEN_SHOP, /* shop opened */\n\n  mEv_SPECL_DESIGNER_COMPLETE = (int)mEv_SET(mEv_SPECL_EVENT, 0)\n};\n\n#define mPr_GET_ITEM_COND(all_cond, slot_no) (((all_cond) >> (((u32)(slot_no)) << 1)) & 3)\n\nenum {\n  mHm_HANIWA_TRADE_0,\n  mHm_HANIWA_TRADE_1,\n  mHm_HANIWA_TRADE_2,\n  mHm_HANIWA_TRADE_3,\n  \n  mHm_HANIWA_TRADE_NUM\n};\n\nenum {\n  mHm_OUTLOOK_PAL_0,\n  mHm_OUTLOOK_PAL_1,\n  mHm_OUTLOOK_PAL_2,\n  mHm_OUTLOOK_PAL_3,\n  mHm_OUTLOOK_PAL_4,\n  mHm_OUTLOOK_PAL_5,\n  mHm_OUTLOOK_PAL_6,\n  mHm_OUTLOOK_PAL_7,\n  mHm_OUTLOOK_PAL_8,\n  mHm_OUTLOOK_PAL_9,\n  mHm_OUTLOOK_PAL_10,\n  mHm_OUTLOOK_PAL_11,\n\n  mHm_OUTLOOK_PAL_NUM\n};\n\nenum {\n  mNpc_MOOD_0,\n  mNpc_MOOD_1,\n  mNpc_MOOD_2,\n  mNpc_MOOD_3,\n  mNpc_MOOD_4,\n  mNpc_MOOD_5,\n  mNpc_MOOD_6,\n  mNpc_MOOD_7,\n  mNpc_MOOD_8,\n\n  mNpc_MOOD_NUM\n};\n\nenum {\n  Config_SOUND_MODE_0,\n  Config_SOUND_MODE_1,\n  Config_SOUND_MODE_2,\n  Config_SOUND_MODE_3,\n\n  Config_SOUND_MODE_NUM\n};\n\nenum {\n  Config_VOICE_MODE_0,\n  Config_VOICE_MODE_1,\n  Config_VOICE_MODE_2,\n  Config_VOICE_MODE_3,\n\n  Config_VOICE_MODE_NUM\n};\n\nenum {\n  mNW_PALETTE0,\n  mNW_PALETTE1,\n  mNW_PALETTE2,\n  mNW_PALETTE3,\n  mNW_PALETTE4,\n  mNW_PALETTE5,\n  mNW_PALETTE6,\n  mNW_PALETTE7,\n  mNW_PALETTE8,\n  mNW_PALETTE9,\n  mNW_PALETTE10,\n  mNW_PALETTE11,\n  mNW_PALETTE12,\n  mNW_PALETTE13,\n  mNW_PALETTE14,\n  mNW_PALETTE15,\n\n  mNW_PALETTE_NUM\n};\n\n#define mMC_TALK_IDX_MAX 10\n\n#define Kabu_PRICE_MIN 10\n#define Kabu_PRICE_MAX 2000\n\n#define mPO_KEEP_MAIL_PLAYERS_MAX 10\n\n#define mFRm_SAVE_ID ('GAFE')\n\n#define mFRm_ERROR_INFO_NUM 10\n#define mFRm_NO_ERROR_NO 7\n\nenum save_error_type {\n  mFRm_ERROR_BAD_RTC, /* RTC returned abnormal value */\n  mFRm_ERROR_MEMCARD_TRAVELDATA_CONFLICT, /* travel data is on the same memory card as requesting to save town data */\n  mFRm_ERROR_DATA_CORRUPTED, /* save data is corrupt */\n  mFRm_ERROR_MEMCARD_NO_FILES, /* memory card is out of \"files\" */\n  mFRm_ERROR_MEMCARD_DAMAGED, /* memory card is damaged */\n  mFRm_ERROR_MEMCARD_FORMAT, /* memory card requires formatting (corrupt or different region?) */\n  mFRm_ERROR_MEMCARD_INVALID, /* memory card type \"cannot be used with Animal Crossing\" */\n  mFRm_ERROR_MEMCARD_NO_SPACE, /* memory card has free files, but not enough free space for save */\n  mFRm_ERROR_NOT_MEMCARD, /* device in card slot is not a memory card */\n  mFRm_ERROR_NO_MEMCARD, /* nothing inserted in either Slot A or Slot B */\n  \n  mFRm_ERROR_NUM\n};\n\ntypedef struct flashrom_error_info {\n  int err_no;\n  int proc_idx;\n} mFRm_err_info_c;\n\nstatic int l_mfrm_msg_idx;\nstatic int l_mfrm_now_color;\nstatic mFRm_err_info_c l_mfrm_err_info[mFRm_ERROR_INFO_NUM];\nstatic int l_mfrm_err_debug[] = {0, 0, 0, 0, 0, 0};\n\n#define mFRm_ERRORLINE(line) mFRm_set_errInfo(l_mfrm_err_info, (line), l_mfrm_now_color)\n#define mFRm_ERROR() mFRm_ERRORLINE(__LINE__)\n\ntypedef lbRTC_time_c OSRTCTime;\n\nenum {\n  mSP_PRIORITY_COMMON,\n  mSP_PRIORITY_UNCOMMON,\n  mSP_PRIORITY_RARE,\n\n  mSP_PRIORITY_NUM\n};\n\n#define mEnv_SAVE_GET_WEATHER_TYPE(w) (((w) & 0xF0) >> 4)\n#define mEnv_SAVE_GET_WEATHER_INTENSITY(w) ((w) & 0xF)\n\nenum {\n  mPO_SENDTYPE_MAIL,\n  mPO_SENDTYPE_LEAFLET,\n  mPO_SENDTYPE_EVENT_LEAFLET,\n\n  mPO_SENDTYPE_NUM\n};\n\nextern void mNpc_GetNpcWorldNameTableNo(u8* buf, mActor_name_t name_id);\nextern void mNpc_GetRandomAnimalName(u8* buf);\nextern mActor_name_t mSP_SelectFishginPresent(int player_no);\nextern int mEvMN_GetJointEventRandomNpc(mActor_name_t* selected_npc_id);\nextern void* zelda_malloc_align(size_t,u32);\nextern void* zelda_malloc(size_t);\nextern void* zelda_malloc_r(size_t);\nextern void zelda_free(void*);\nextern void zelda_GetFreeArena(size_t* max, size_t* free, size_t* alloc);\nextern size_t zelda_GetTotalFreeSize(void);\nextern size_t zelda_GetMemBlockSize(void*);\nextern void zelda_InitArena(void*, size_t);\nextern void zelda_AddBlockArena(void*, size_t);\nextern void zelda_CleanupArena(void);\nextern int zelda_MallocIsInitalized();\n\nenum resource_index {\n  RESOURCE_FGDATA,\n  RESOURCE_MAIL,\n  RESOURCE_MAIL_TABLE,\n  RESOURCE_MAILA,\n  RESOURCE_MAILA_TABLE,\n  RESOURCE_MAILB,\n  RESOURCE_MAILB_TABLE,\n  RESOURCE_MAILC,\n  RESOURCE_MAILC_TABLE,\n  RESOURCE_PALLET_BOY,\n  RESOURCE_PS,\n  RESOURCE_PS_TABLE,\n  RESOURCE_PSZ,\n  RESOURCE_PSZ_TABLE,\n  RESOURCE_SELECT,\n  RESOURCE_SELECT_TABLE,\n  RESOURCE_STRING,\n  RESOURCE_STRING_TABLE,\n  RESOURCE_SUPERZ,\n  RESOURCE_SUPERZ_TABLE,\n  RESOURCE_SUPER,\n  RESOURCE_SUPER_TABLE,\n  RESOURCE_TEX_BOY,\n  RESOURCE_FACE_BOY,\n  RESOURCE_FGNPCDATA,\n  RESOURCE_MESSAGE,\n  RESOURCE_MESSAGE_TABLE,\n  RESOURCE_MY_ORIGINAL,\n  RESOURCE_NEEDLEWORK_JOYBOOT,\n  RESOURCE_PLAYER_ROOM_FLOOR,\n  RESOURCE_PLAYER_ROOM_WALL,\n  RESOURCE_NPC_NAME_STR_TABLE,\n  RESOURCE_D_OBJ_NPC_STOCK_SCH,\n  RESOURCE_D_OBJ_NPC_STOCK_SCL,\n  RESOURCE_TITLE,\n  RESOURCE_MURA_SPRING,\n  RESOURCE_MURA_SUMMER,\n  RESOURCE_MURA_FALL,\n  RESOURCE_MURA_WINTER,\n  RESOURCE_ODEKAKE,\n  RESOURCE_OMAKE,\n  RESOURCE_EKI1,\n  RESOURCE_EKI1_2,\n  RESOURCE_EKI1_3,\n  RESOURCE_EKI1_4,\n  RESOURCE_EKI1_5,\n  RESOURCE_EKI2,\n  RESOURCE_EKI2_2,\n  RESOURCE_EKI2_3,\n  RESOURCE_EKI2_4,\n  RESOURCE_EKI2_5,\n  RESOURCE_EKI3,\n  RESOURCE_EKI3_2,\n  RESOURCE_EKI3_3,\n  RESOURCE_EKI3_4,\n  RESOURCE_EKI3_5,\n  RESOURCE_TEGAMI,\n  RESOURCE_TEGAMI2,\n  RESOURCE_FAMIKON,\n  RESOURCE_BOY1,\n  RESOURCE_BOY2,\n  RESOURCE_BOY3,\n  RESOURCE_BOY4,\n  RESOURCE_BOY5,\n  RESOURCE_BOY6,\n  RESOURCE_BOY7,\n  RESOURCE_BOY8,\n  RESOURCE_GIRL11,\n  RESOURCE_GIRL12,\n  RESOURCE_GIRL13,\n  RESOURCE_GIRL14,\n  RESOURCE_GIRL15,\n  RESOURCE_GIRL16,\n  RESOURCE_GIRL17,\n  RESOURCE_GIRL18,\n  RESOURCE_D_BG_ISLAND_SCH,\n\n  RESOURCE_NUM\n};\n\nenum {\n  mTM_TERM_BEGIN = 0,\n  mTM_TERM_0 = mTM_TERM_BEGIN,\n  mTM_TERM_1,\n  mTM_TERM_2,\n  mTM_TERM_3,\n  mTM_TERM_4,\n  mTM_TERM_5,\n  mTM_TERM_6,\n  mTM_TERM_7,\n  mTM_TERM_8,\n  mTM_TERM_9,\n  mTM_TERM_10,\n  mTM_TERM_11,\n  mTM_TERM_12,\n  mTM_TERM_13,\n  mTM_TERM_14,\n  mTM_TERM_15,\n  mTM_TERM_16,\n  mTM_TERM_17,\n  mTM_TERM_NUM\n};\n\nenum {\n  mFR_SIZE_SMALL,\n  mFR_SIZE_MEDIUM,\n  mFR_SIZE_LARGE,\n\n  mFR_SIZE_NUM\n};\n\n#define mFI_UT_WORLDSIZE_HALF_X_F (mFI_UT_WORLDSIZE_X_F / 2.0f)\n#define mFI_UT_WORLDSIZE_HALF_Z_F (mFI_UT_WORLDSIZE_X_F / 2.0f)\n\n#define mFI_BK_WORLDSIZE_X_F (mFI_UT_WORLDSIZE_X_F * UT_X_NUM)\n#define mFI_BK_WORLDSIZE_Z_F (mFI_UT_WORLDSIZE_Z_F * UT_Z_NUM)\n\n#define mFM_VISIBLE_BLOCK_NUM 4 /* number of visible blocks (nearest to the Player) */\n#define mFM_SOUND_SOURCE_NUM 6\n#define mFM_MOVE_ACTOR_NUM 16\n#define mFM_HANIWA_STEP_NUM 4\n\n#define mFM_BG_ID_MAX 293\n\n#define mFM_FG_START 0\n#define mFM_FG_NUM 416\n#define mFM_FG_NPC_START mFM_FG_NUM\n#define mFM_FG_NPC_NUM 536\n#define mFM_FG_ID_MAX (mFM_FG_NUM + mFM_FG_NPC_NUM)\n#define mFM_FG2_ID_MAX 743\n\n#define mFM_FIELD_PAL_NUM 12\n#define mFM_FIELD_TEX_NUM 27\n\nenum {\n  mFM_BG_TEX_TRIANGLE,\n  mFM_BG_TEX_SQUARE,\n  mFM_BG_TEX_CIRCLE,\n\n  mFM_BG_TEX_NUM\n};\n\ntypedef struct evw_anime_s {\n  s8 segment; /* Negative segments signal the end of the animation data array */\n  s16 type;\n  void* data_p;\n} EVW_ANIME_DATA;\n\ntypedef struct field_display_list_info_s {\n  int block_x;\n  int block_z;\n  u32 dma_loaded;\n} mFM_field_draw_info_c;\n\ntypedef struct field_pal_s {\n  u16* earth_pal;\n  u16* cliff_pal;\n  u16* bush_pal;\n  u16* flower0_pal;\n  u16* flower1_pal;\n  u16* flower2_pal;\n  u16* grass_pal;\n  u16* tree_pal;\n  u16* cedar_tree_pal; // probably?\n  u16* palm_tree_pal;\n  u16* golden_tree_pal;\n} mFM_field_pal_c;\n\ntypedef struct field_bg_sound_source_s {\n  s16 kind;\n  xyz_t pos;\n} mFM_bg_sound_source_c;\n\ntypedef struct field_bg_info_s {\n  mFM_combination_c bg_id;\n  Gfx* opaque_gfx;\n  Gfx* translucent_gfx;\n  EVW_ANIME_DATA* animation;\n  s8 animation_count;\n  u8 block_type;\n  u32 block_kind;\n  int rom_start_addr;\n  int rom_size;\n  mCoBG_Collision_u collision[UT_Z_NUM][UT_X_NUM];\n  u8 keep_h[UT_Z_NUM][UT_X_NUM]; // base height?\n  mFM_bg_sound_source_c sound_source[mFM_SOUND_SOURCE_NUM];\n} mFM_bg_info_c;\n\ntypedef struct field_fg_move_actor_s {\n  mActor_name_t name_id;\n  s8 ut_x;\n  s8 ut_z;\n  s8 npc_info_idx;\n  s16 arg;\n} mFM_move_actor_c;\n\ntypedef struct field_fg_move_actor_data_s {\n  mActor_name_t name_id;\n  int block_x;\n  int block_z;\n  u8 ut_x;\n  u8 ut_z;\n  s8 npc_info_idx;\n  s16 arg;\n  u32 desired_block_kind;\n} mFM_move_actor_data_c;\n\ntypedef struct field_fg_info_s {\n  mActor_name_t fg_id;\n  mActor_name_t* items_p;\n  u16* deposit_p;\n  mFM_move_actor_c move_actors[mFM_MOVE_ACTOR_NUM];\n  u16 move_actor_bit_data;\n  u8 haniwa_step[mFM_HANIWA_STEP_NUM];\n} mFM_fg_info_c;\n\ntypedef struct field_block_info_s {\n  mFM_bg_info_c bg_info;\n  mFM_fg_info_c fg_info;\n} mFM_block_info_c;\n\ntypedef struct field_bg_sound_source_data_s {\n  s16 kind;\n  u8 ut_x;\n  u8 ut_z;\n} mFM_bg_sound_source_data_c;\n\ntypedef struct field_bg_data_s {\n  mActor_name_t bg_id;\n  Gfx* opaque_gfx;\n  Gfx* translucent_gfx;\n  EVW_ANIME_DATA* animation;\n  s8 animation_count;\n  u32 _14;\n  u32 _18;\n  mCoBG_Collision_u collision[UT_Z_NUM][UT_X_NUM];\n  mFM_bg_sound_source_data_c sound_source[mFM_SOUND_SOURCE_NUM];\n} mFM_bg_data_c;\n\ntypedef struct field_fg_data_s {\n  mActor_name_t fg_id;\n  mActor_name_t items[UT_Z_NUM][UT_X_NUM];\n  u8 haniwa_step[mFM_HANIWA_STEP_NUM];\n} mFM_fg_data_c;\n\ntypedef struct field_data_s {\n  mActor_name_t field_name;\n  u8 block_x_max;\n  u8 block_z_max;\n  mFM_combination_c combi[BLOCK_TOTAL_NUM];\n  mFM_move_actor_data_c* move_actor_data;\n  u32 _94;\n  u32 _98;\n  u32 _9C;\n  u32 _A0;\n} mFM_field_data_c;\n\ntypedef struct field_info_s {\n  mActor_name_t field_id;\n  u32 _04; // only set, never read?\n  mFM_field_draw_info_c bg_draw_info[mFM_VISIBLE_BLOCK_NUM];\n  u8* bg_display_list_p[mFM_VISIBLE_BLOCK_NUM];\n  mFM_field_pal_c field_palette;\n  mFM_block_info_c* block_info;\n  mActor_name_t** fg2_p;\n  int last_bg_idx[mFM_VISIBLE_BLOCK_NUM];\n  u16 bg_max;\n  u8 bg_num;\n  u8 update_fg;\n  u8 born_item;\n  u8 born_actor;\n  u8 block_x_max;\n  u8 block_z_max;\n} mFM_fdinfo_c;\n\nextern mFM_fdinfo_c* g_fdinfo;\nextern int l_bg_disp_num;\nextern int l_bg_disp_size;\n\nextern mFM_bg_data_c data_bgd[];\nextern int data_bgd_number;\n\nextern int mFI_CheckShopFieldName(mActor_name_t field_name);\nextern int mFI_GetMoveActorListIdx(mFM_move_actor_c* move_actor_list, int list_size, mActor_name_t name);\nextern int mFI_GetNowPlayerHouseFloorNo();\nextern int mFI_BlockUtNumtoFGSet(mActor_name_t item, int bx, int bz, int ut_x, int ut_z);\nextern void mFI_InitMoveActorBitData();\nextern void mFI_ClearColKeep();\nextern void mFI_InitAreaInfo();\nextern void mFI_InitRegisterBgInfo();\nextern mFM_block_info_c* mFI_GetBlockTopP();\nextern int mFI_GetBlockNum(int block_x, int block_z);\n\nextern int mNpc_GetIslandRoomFtrNum();\nextern mActor_name_t* mNpc_GetIslandRoomP(mActor_name_t npc_name);\nextern void mNpc_ChangeIslandRoom(mActor_name_t* items);\nextern void mNpc_SetNpcFurnitureRandom(mFM_fg_data_c** fg_data_list, int fg_name_start);\nextern void mNpc_SetNpcHomeYpos();\nextern void mNpc_SendRegisteredGoodbyMail();\nextern void mNpc_IslandNpcRoomDataSet(mFM_fg_data_c** sorted_fg_data_list, int fg_name_start);\n\ntypedef struct bg_tex_obj_s {\n  void* data;\n  size_t size;\n} mBGTex_obj_c;\n\nextern u8 sprashC_tex_dummy[];\nextern u8 sprashA_tex_dummy[];\nextern u8 wave3_tex_dummy[];\nextern u8 wave2_tex_dummy[];\nextern u8 wave1_tex_dummy[];\nextern u8 sand_tex_dummy[];\nextern u8 beach_pal_dummy2[];\nextern u8 beach2_tex_dummy2[];\nextern u8 beach1_tex_dummy2[];\nextern u8 beach_tex_dummy[];\nextern u8 tunnel_tex_dummy[];\nextern u8 rail_pal_dummy[];\nextern u8 bush_pal_dummy[];\nextern u8 cliff_pal_dummy[];\nextern u8 earth_pal_dummy[];\nextern u8 station_pal_dummy[];\nextern u8 bridge_2_pal_dummy[];\nextern u8 bridge_1_pal_dummy[];\nextern u8 tekkyo_tex_dummy[];\nextern u8 bridge_2_tex_dummy[];\nextern u8 bridge_1_tex_dummy[];\nextern u8 water_2_tex_dummy[];\nextern u8 water_1_tex_dummy[];\nextern u8 river_tex_dummy[];\nextern u8 stone_tex_dummy[];\nextern u8 station_tex_dummy[];\nextern u8 rail_tex_dummy[];\nextern u8 grass_tex_dummy[];\nextern u8 bush_b_tex_dummy[];\nextern u8 bush_a_tex_dummy[];\nextern u8 cliff_tex_dummy[];\nextern u8 earth_tex_dummy[];\n\nextern void* gamealloc_malloc(GameAlloc* gamealloc, size_t size);\nextern void gamealloc_free(GameAlloc* gamealloc, void* ptr);\nextern void gamealloc_cleanup(GameAlloc* gamealloc);\nextern void gamealloc_init(GameAlloc* gamealloc);\n\nextern mActor_name_t mSP_GetNowShopFgNum();\nextern mActor_name_t mSP_GetNowShopBgNum();\n\nextern mActor_name_t mRmTp_GetPlayerRoomCollisionIdx(mActor_name_t field_name, mActor_name_t bg_name);\nextern u8 mRmTp_GetFloorIdx();\n\nextern void mRF_MakeRandomField(mFM_combination_c* combi_table, mFM_combo_info_c* combo_info, int combo_count, GAME* game);\nextern void mBGMPsComp_museum_status(int museum_status);\n\nextern int mCoBG_Change2PoorAttr(mCoBG_Collision_u* col);\n\nextern u32 mSC_check_ArbeitPlayer();\nextern int mSC_LightHouse_travel_check();\n#define mSC_TROPHY_GOLDEN_AXE 29\n\n#define mSc_IS_SCENE_PLAYER_ROOM(scene) \\\n  ((scene) == SCENE_MY_ROOM_S || (scene) == SCENE_MY_ROOM_M || (scene) == SCENE_MY_ROOM_L || \\\n   (scene) == SCENE_MY_ROOM_LL1 || (scene) == SCENE_MY_ROOM_LL2 || (scene) == SCENE_MY_ROOM_BASEMENT_S || \\\n   (scene) == SCENE_MY_ROOM_BASEMENT_M || (scene) == (SCENE_MY_ROOM_BASEMENT_L) || (scene) == SCENE_MY_ROOM_BASEMENT_LL1 || \\\n   (scene) == SCENE_COTTAGE_MY)\n\n#define mSc_IS_SCENE_MUSEUM_ROOM(scene) \\\n  ((scene) >= SCENE_MUSEUM_ENTRANCE && (scene) <= SCENE_MUSEUM_ROOM_FISH)\n\n#define mNT_IS_RESERVE(n) ((n) >= SIGN00 && (n) <= SIGN20)\n\nextern u32 mRF_Type2BlockInfo(u8 type);\n\n#define ALIGN_PREV(u, align) (u & (~(align-1)))\n#define ALIGN_NEXT(u, align) ((u + (align-1)) & (~(align-1)))\n\nenum {\n  mFI_MOVEDIR_NONE,\n  mFI_MOVEDIR_RIGHT,\n  mFI_MOVEDIR_LEFT,\n  mFI_MOVEDIR_UP,\n  mFI_MOVEDIR_DOWN,\n\n  mFI_MOVEDIR_NUM\n};\n\nenum player_wade_state {\n  mFI_WADE_NONE,\n  mFI_WADE_START,\n  mFI_WADE_INPROGRESS,\n  mFI_WADE_END,\n  mFI_WADE_ERROR,\n\n  mFI_WADE_NUM\n};\n\nenum {\n  mFI_DIGSTATUS_MISS,\n  mFI_DIGSTATUS_CANCEL,\n  mFI_DIGSTATUS_FILLIN,\n  mFI_DIGSTATUS_DIG,\n  mFI_DIGSTATUS_PUT_ITEM,\n  mFI_DIGSTATUS_GET_ITEM,\n  \n  mFI_DIGSTATUS_NUM\n};\n\nenum {\n  mFI_SET_STRUCTURE_SET,\n  mFI_SET_STRUCTURE_REMOVE,\n\n  mFI_SET_STRUCTURE_NUM\n};\n\n#define mFI_BK_WORLDSIZE_X (mFI_UT_WORLDSIZE_X * UT_X_NUM)\n#define mFI_BK_WORLDSIZE_Z (mFI_UT_WORLDSIZE_Z * UT_Z_NUM)\n\n#define mFI_NUM_COL_KEEP 9\n#define mFI_NUM_SOUND_SOURCES 6\n#define mFI_SET_SHELL_NUM 20\n#define mFI_MAX_SHELLS_PER_BLOCK 4\n\nenum {\n  mFI_DEPOSIT_ON,\n  mFI_DEPOSIT_OFF,\n  mFI_DEPOSIT_GET,\n\n  mFI_DEPOSIT_NUM\n};\n\ntypedef struct visible_block_item_info_s {\n  int count;\n  mFI_block_tbl_c block_info_tbl[mFM_VISIBLE_BLOCK_NUM];\n} mFI_item_table_c;\n\n#define mCoBG_HEIGHT_MAX 31\n\nextern mFM_field_draw_info_c* mFI_BGDisplayListTop();\nextern void mFI_SetFGUpData();\nextern u8 mFI_BkNum2BlockType(int block_x, int block_z);\nextern u32 mFI_BkNum2BlockKind(int block_x, int block_z);\nextern u8 mFI_GetBlockXMax();\nextern u8 mFI_GetBlockZMax();\nextern int mFI_Wpos2BlockNum(int* block_x, int* block_z, xyz_t world_pos);\nextern mActor_name_t* mFI_GetUnitFG(xyz_t wpos);\nextern mActor_name_t* mFI_BkNumtoUtFGTop(int bx, int bz);\n\nextern int mPlib_check_player_actor_main_index_AllWade(GAME_PLAY* play);\n\n#define GET_PLAYER_ACTOR(play) get_player_actor_withoutCheck(play)\n#define GET_PLAYER_ACTOR_NOW() get_player_actor_withoutCheck((GAME_PLAY*)gamePT)\n\nstatic int mFI_CheckNothing(mActor_name_t* item, xyz_t wpos);\nstatic mActor_name_t mFM_GetReseveName(int bx, int bz);\n\n#define aAPC_GET_NPC_BIT(bitfield, data_idx) ((1 << (data_idx)) & (bitfield))\n#define aAPC_SET_NPC_BIT(bitfield, data_idx) ((bitfield) | (1 << (data_idx)))\n\nextern ACTOR_PROFILE Aprilfool_Control_Profile;\n\ntypedef struct aprilfool_control_s {\n  ACTOR actor_class;\n  aAPC_Clip_c clip;\n} APRILFOOL_CONTROL_ACTOR;\n\n#define mEnv_POINT_LIGHT_NUM 4\n#define mEnv_RAINBOW_TIME_START (9 * mTM_SECONDS_IN_HOUR)\n#define mEnv_RAINBOW_TIME_END (15 * mTM_SECONDS_IN_HOUR)\n#define mEnv_RAINBOW_TIME_BYE (15 * mTM_SECONDS_IN_HOUR + 30 * mTM_SECONDS_IN_MINUTE)\n#define mEnv_TERM_NUM 8\n#define mEnv_FOG_NEAR_MAX 996\n#define mEnv_FOG_FAR_MAX 1600\n#define mEnv_LIGHT_ANIME_FRAMES 20\n#define mEnv_NPC_LIGHTS_OFF_TIME (5 * mTM_SECONDS_IN_HOUR)\n#define mEnv_NPC_LIGHTS_ON_TIME (18 * mTM_SECONDS_IN_HOUR)\n\nenum {\n  mEnv_LIGHT_TYPE_PLAYER,\n  mEnv_LIGHT_TYPE_TENT,\n  mEnv_LIGHT_TYPE_LIGHTHOUSE,\n\n  mEnv_LIGHT_TYPE_NUM\n};\n\nenum {\n mEnv_SWITCH_STATUS_ON,\n mEnv_SWITCH_STATUS_OFF,\n mEnv_SWITCH_STATUS_TURNING_OFF,\n mEnv_SWITCH_STATUS_TURNING_ON,\n\n mEnv_SWITCH_STATUS_NUM\n};\n\nenum field_draw_type {\n  FIELD_DRAW_TYPE_OUTDOORS,\n  FIELD_DRAW_TYPE_INDOORS,\n  FIELD_DRAW_TYPE_TRAIN,\n  FIELD_DRAW_TYPE_PLAYER_SELECT,\n\n  FIELD_DRAW_TYPE_NUM\n};\n\nextern int mRmTp_GetNowSceneLightSwitchIndex();\nextern void mRmTp_IndexLightSwitchOFF(int index);\nextern void mRmTp_IndexLightSwitchON(int index);\nextern int mRmTp_Index2LightSwitchStatus(int index);\nextern int mRmTp_NowSceneLightSwitchON();\nextern int mRmTp_NowSceneLightSwitchOFF();\n\nenum {\n  mRmTp_LIGHT_SWITCH_HOUSE0_MAIN_UPPER,\n  mRmTp_LIGHT_SWITCH_HOUSE0_BASEMENT,\n  mRmTp_LIGHT_SWITCH_HOUSE1_MAIN_UPPER,\n  mRmTp_LIGHT_SWITCH_HOUSE1_BASEMENT,\n  mRmTp_LIGHT_SWITCH_HOUSE2_MAIN_UPPER,\n  mRmTp_LIGHT_SWITCH_HOUSE2_BASEMENT,\n  mRmTp_LIGHT_SWITCH_HOUSE3_MAIN_UPPER,\n  mRmTp_LIGHT_SWITCH_HOUSE3_BASEMENT,\n  mRmTp_LIGHT_SWITCH_COTTAGE_MY,\n  mRmTp_LIGHT_SWITCH_9,\n  mRmTp_LIGHT_SWITCH_NPC,\n  mRmTp_LIGHT_SWITCH_LIGHTHOUSE,\n  mRmTp_LIGHT_SWITCH_TENT,\n\n  mRmTp_LIGHT_SWITCH_NUM\n};\n\n\nextern void Global_light_ct(Global_light* glight);\nextern Light_list* Global_light_list_new(GAME_PLAY*, Global_light* glight, Lights* light);\nextern void Global_light_list_delete(Global_light* glight, Light_list* light);\nextern void Light_list_point_draw(GAME_PLAY* play);\nextern void Light_point_ct(Lights* lights, s16 x, s16 y, s16 z, u8 r, u8 g, u8 b, s16 radius);\nextern void Light_diffuse_ct(Lights* lights, s8 x, s8 y, s8 z, u8 r, u8 g, u8 b);\n\ntypedef enum {\n  DEBUG_REG_START = 0,\n  DEBUG_REG_REG = DEBUG_REG_START,\n  DEBUG_REG_SREG,\n  DEBUG_REG_OREG,\n  DEBUG_REG_PREG,\n  DEBUG_REG_QREG,\n  DEBUG_REG_MREG,\n  DEBUG_REG_SBREG,\n  DEBUG_REG_DREG,\n  DEBUG_REG_UREG,\n  DEBUG_REG_IREG,\n  DEBUG_REG_ZREG,\n  DEBUG_REG_CRV,\n  DEBUG_REG_NS1,\n  DEBUG_REG_SND,\n  DEBUG_REG_XREG,\n  DEBUG_REG_CRV2,\n  DEBUG_REG_DEMOREG,\n  DEBUG_REG_TREG,\n  DEBUG_REG_WREG,\n  DEBUG_REG_AREG,\n  DEBUG_REG_VREG,\n  DEBUG_REG_HREG,\n  DEBUG_REG_GREG,\n  DEBUG_REG_mREG,\n  DEBUG_REG_nREG,\n  DEBUG_REG_BREG,\n  DEBUG_REG_DORO,\n  DEBUG_REG_kREG,\n  DEBUG_REG_BAK,\n  DEBUG_REG_PLAYERREG,\n  DEBUG_REG_NMREG,\n  \n  DEBUG_REG_NIIREG,\n  DEBUG_REG_GENREG,\n  DEBUG_REG_MYKREG,\n  DEBUG_REG_CAMREG,\n  DEBUG_REG_SAKREG,\n  DEBUG_REG_TAKREG,\n  DEBUG_REG_PL2REG,\n\n  DEBUG_REG_MAX\n} DEBUG_REG;\n\n#define DEBUG_REG_SIZE 16\n#define DEBUG_REG_GROUP 6\n\n#define DEBUG_REG_COUNT (DEBUG_REG_SIZE * DEBUG_REG_GROUP * DEBUG_REG_MAX)\n\ntypedef struct debug_mode_s {\n  u8 mode;\n  u8 type;\n  s8 input_r;\n  s8 key_wait;\n\n  int old_key;\n  int __pad[3];\n\n  s16 r[DEBUG_REG_SIZE * DEBUG_REG_GROUP * DEBUG_REG_MAX];\n} Debug_mode;\n\nextern Debug_mode* debug_mode;\n\n#define REGADDR(reg, idx) (debug_mode->r[DEBUG_REG_SIZE * DEBUG_REG_GROUP * DEBUG_REG_##reg + (idx)])\n\n#define GETREG(reg, idx) ((s16)(REGADDR(reg, idx)))\n#define SETREG(reg, idx, val) (REGADDR(reg, idx) = (val))\n\n#define mTM_SECONDS_IN_MINUTE 60\n#define mTM_SECONDS_IN_HALFDAY (12*60*60)\n#define mTM_SECONDS_IN_DAY (24*60*60)\n\n#define mTM_MINUTES_IN_HOUR 60\n\nextern Animal_c* mNpc_GetAnimalInfoP(mActor_name_t npc_name);\nextern mNPS_schedule_c* mNPS_get_schedule_area(AnmPersonalID_c* anm_id);\n\n#define mSc_IS_SCENE_BASEMENT(scene) \\\n  ((scene) == SCENE_MY_ROOM_BASEMENT_S || \\\n   (scene) == SCENE_MY_ROOM_BASEMENT_M || \\\n   (scene) == SCENE_MY_ROOM_BASEMENT_L || \\\n   (scene) == SCENE_MY_ROOM_BASEMENT_LL1)\n\nextern f32 get_percent(const int max, const int min, const int x);\n\ntypedef struct electric_light_s {\n  f32 point_light_percent;\n  u8 point_light_color[3];\n  s16 _08;\n  s16 now_weather;\n  s16 next_weather;\n  f32 change_weather_env_rate;\n  s16 light_animating_on;\n  s16 light_anime_frame;\n  int point_light_on_type;\n  int point_light_off_type;\n  f32 point_light_off_step;\n  s16 point_light_is_flame; /* flickering effect when non-zero */\n  f32 staffroll_fade_rate;\n  f32 sun_percent;\n  f32 shadow_adjust;\n  f32 windowlight_alpha;\n  Light_list* current_point_light;\n  s16 add_moon_color[3];\n  Light_list* point_light_list_buf[mEnv_POINT_LIGHT_NUM];\n  Lights point_lights[mEnv_POINT_LIGHT_NUM];\n  int switch_status;\n  f32 point_light_min;\n  f32 diffuse_light_effect_rate;\n  s16 _98;\n  s16 shadow_alpha;\n  f32 diffuse_adjust;\n  u8 shadow_alpha_adjust;\n} mEnv_electric_light_c;\n\nstatic mEnv_electric_light_c l_mEnv_electric_light;\n\nenum {\n  mEnv_WIND_STATE_STEADY,\n  mEnv_WIND_STATE_FAST,\n  mEnv_WIND_STATE_SLOW,\n  mEnv_WIND_STATE_REDUCING,\n  \n  mEnv_WIND_STATE_NUM\n};\n\n#define mEnv_WEATHER_TERM_NUM 20\n#define mEnv_WIND_TERM_NUM 4\n#define mEnv_WIND_CHANGE_RATE (f32)(10*mTM_SECONDS_IN_MINUTE*60) // 60fps, 10 minutes\n\nenum {\n  mTM_RENEW_TIME_BEGIN = 0,\n  mTM_RENEW_TIME_WEATHER = mTM_RENEW_TIME_BEGIN,\n  mTM_RENEW_TIME_DAILY\n};\n\n#define mMkRm_HINT_NUM 19\n#define mMkRm_REWARD0_POINTS 70000\n#define mMkRm_REWARD1_POINTS 100000\n\n#define mMkRm_LETTER_BIT_NECESSITIES_COMPLETE (1ull << 0)\n#define mMkRm_LETTER_BIT_NECESSITIES_COMPLETE_SAME_SERIES (1ull << 1)\n#define mMkRm_LETTER_BIT_BASE_SERIES_FTR_COMPLETE (1ull << 2)\n#define mMkRm_LETTER_BIT_BASE_SERIES_WALL_OR_FLOOR_MATCH (1ull << 3)\n#define mMkRm_LETTER_BIT_BASE_SERIES_MATCHING_WALL_AND_FLOOR (1ull << 4)\n#define mMkRm_LETTER_BIT_THEME_SERIES_WALL_AND_FLOOR_MATCH (1ull << 5)\n#define mMkRm_LETTER_BIT_THEME_SERIES_COMPLETE (1ull << 6)\n#define mMkRm_LETTER_BIT_THEME_OBSTACLE (1ull << 7)\n//#define mMkRm_LETTER_BIT_THEME_SERIES_WALL_AND_FLOOR_MATCH (1ull << 9) // only set when low theme ftr but wall & carpet match\n#define mMkRm_LETTER_BIT_BAD_DIRECTION (1ull << 16)\n#define mMkRm_LETTER_BIT_LETS_CLEAN (1ull << 17)\n#define mMkRm_LETTER_BIT_SET_SERIES_COMPLETE (1ull << 32)\n#define mMkRm_LETTER_BIT_SERIES_STARTED (1ull << 33) // at least 6 items in the theme series exist\n#define mMkRm_LETTER_BIT_BASE_SERIES_FTR_ALMOST_COMPLETE (1ull << 34)\n#define mMkRm_LETTER_BIT_SERIES_ALMOST_COMPLETE (1ull << 35)\n\n#define mMkRm_EVALUATE_BASE_POINT (1u << 0)\n#define mMkRm_EVALUATE_NECESSITY (1u << 1)\n#define mMkRm_EVALUATE_BASE_SERIES (1u << 2)\n#define mMkRm_EVALUATE_THEME_SERIES (1u << 3)\n#define mMkRm_EVALUATE_SET_SERIES (1u << 4)\n#define mMkRm_EVALUATE_LUCKY_FTR (1u << 5)\n#define mMkRm_EVALUATE_DIRECTION (1u << 6)\n#define mMkRm_EVALUATE_LETS_CLEAN (1u << 7)\n\n#define mMkRm_FULL_EVALUATION ( \\\n  mMkRm_EVALUATE_BASE_POINT | mMkRm_EVALUATE_NECESSITY | mMkRm_EVALUATE_BASE_SERIES | \\\n  mMkRm_EVALUATE_THEME_SERIES | mMkRm_EVALUATE_SET_SERIES | mMkRm_EVALUATE_LUCKY_FTR | \\\n  mMkRm_EVALUATE_DIRECTION | mMkRm_EVALUATE_LETS_CLEAN \\\n)\n\n#define mMkRm_UPPER_EVALUATION ( \\\n  mMkRm_EVALUATE_BASE_POINT | mMkRm_EVALUATE_SET_SERIES | mMkRm_EVALUATE_LUCKY_FTR | \\\n  mMkRm_EVALUATE_DIRECTION | mMkRm_EVALUATE_LETS_CLEAN \\\n)\n\n#define mMkRm_THEME_OBSTACLE_PENALTY 4000\n#define mMkRm_FACING_WALL_PENALTY 800\n#define mMkRm_LUCKY_BONUS 777\n#define mMkRm_SET_SERIES_COMPLETE_BONUS 3000\n#define mMkRm_THEME_SERIES_COMPLETE_FTR_BONUS 7000\n#define mMkRm_THEME_SERIES_COMPLETE_BONUS_WALL_OR_FLOOR 10000\n#define mMkRm_THEME_SERIES_COMPLETE_BONUS_WALL_AND_FLOOR 15000\n#define mMkRm_BASE_SERIES_COMPLETE_FTR_BONUS 48000\n#define mMkRm_BASE_SERIES_MATCHING_WALL_OR_FLOOR_BONUS 4800\n#define mMkRm_BASE_SERIES_MATCHING_WALL_AND_FLOOR_BONUS 10000\n#define mMkRm_NECESSITY_COMPLETE_SAME_SERIES_BONUS 16000\n#define mMkRm_NECESSITY_COMPLETE_DIFF_SERIES_BONUS 4400\n\nenum {\n  mMkRm_SERIES_EXOTIC,\n  mMkRm_SERIES_LOVELY,\n  mMkRm_SERIES_CLASSIC,\n  mMkRm_SERIES_RANCH,\n  mMkRm_SERIES_CABANA,\n  mMkRm_SERIES_BLUE,\n  mMkRm_SERIES_MODERN,\n  mMkRm_SERIES_REGAL,\n  mMkRm_SERIES_GREEN,\n  mMkRm_SERIES_CABIN,\n  mMkRm_SERIES_SPOOKY,\n  mMkRm_SERIES_JINGLE,\n  mMkRm_SERIES_KIDDIE,\n  mMkRm_SERIES_GARDEN,\n  mMkRm_SERIES_ROCKGARDEN,\n  mMkRm_SERIES_JAPANESE,\n  mMkRm_SERIES_CONSTRUCTION,\n  mMkRm_SERIES_SPACE,\n  mMkRm_SERIES_PUBLICBATH,\n  mMkRm_SERIES_SCHOOL,\n  mMkRm_SERIES_CHESS,\n  mMkRm_SERIES_BONSAI,\n  mMkRm_SERIES_WRITING,\n  mMkRm_SERIES_VASE,\n  mMkRm_SERIES_VENDING,\n  mMkRm_SERIES_NINTENDO,\n  mMkRm_SERIES_DARUMA,\n  mMkRm_SERIES_CACTUS,\n  mMkRm_SERIES_BEAR,\n  mMkRm_SERIES_FIGURE,\n  mMkRm_SERIES_TOTEMPOLE,\n  mMkRm_SERIES_GUITAR,\n  mMkRm_SERIES_DRUM,\n  mMkRm_SERIES_STRINGS,\n  mMkRm_SERIES_OFFICE,\n  mMkRm_SERIES_TRICERA,\n  mMkRm_SERIES_TREX,\n  mMkRm_SERIES_BRONT,\n  mMkRm_SERIES_STEGO,\n  mMkRm_SERIES_PTERA,\n  mMkRm_SERIES_PLESIO, /* HUBATA was a mistranslation of futabasaurus */\n  mMkRm_SERIES_MAMMOTH,\n  mMkRm_SERIES_ROBOT,\n  mMkRm_SERIES_APPLE,\n  mMkRm_SERIES_CITRUS,\n  mMkRm_SERIES_MELON,\n  mMkRm_SERIES_PEAR,\n  mMkRm_SERIES_LUCKY,\n  mMkRm_SERIES_PINE,\n  mMkRm_SERIES_FROGGY,\n  mMkRm_SERIES_IRIS,\n  mMkRm_SERIES_TULIP,\n  mMkRm_SERIES_DAFFODIL,\n  mMkRm_SERIES_OTHER,\n  mMkRm_SERIES_SNOWMAN,\n  mMkRm_SERIES_WESTERN,\n  mMkRm_SERIES_BACKYARD,\n  mMkRm_SERIES_HARVEST,\n  mMkRm_SERIES_BOXING,\n  mMkRm_SERIES_MARIO,\n\n  mMkRm_SERIES_NUM\n};\n\nenum {\n  mMkRm_SERIES_TYPE_ONE,\n  mMkRm_SERIES_TYPE_BASE,\n  mMkRm_SERIES_TYPE_THEME,\n  mMkRm_SERIES_TYPE_SET,\n\n  mMkRm_SERIES_TYPE_NUM\n};\n\nenum {\n  mMkRm_NECESSITY_CHAIR,\n  mMkRm_NECESSITY_DRESSER,\n  mMkRm_NECESSITY_WARDROBE,\n  mMkRm_NECESSITY_TABLE,\n  mMkRm_NECESSITY_BED,\n  mMkRm_NOT_NECESSITY,\n\n  mMkRm_NECESSITY_NUM\n};\n\nenum {\n  mMkRm_SURFACE_TYPE_NONE,\n  mMkRm_SURFACE_TYPE_SURFACE,\n  mMkRm_SURFACE_TYPE_PLACEABLE,\n\n  mMkRm_SURFACE_TYPE_NUM\n};\n\nenum {\n  mMkRm_LUCK_TYPE_NOT_LUCKY,\n  mMkRm_LUCK_TYPE_LUCKY,\n\n  mMkRm_LUCK_TYPE_NUM\n};\n\nenum {\n  mMkRm_FACE_TYPE_NO_FACE,\n  mMkRm_FACE_TYPE_HAS_FACE,\n\n  mMkRm_FACE_TYPE_NUM\n};\n\nextern int mNpc_RegistEventNpc(mActor_name_t actor_name, mActor_name_t tex_name, mActor_name_t npc_name, mActor_name_t cloth_name);\nextern int mNpc_RegistMaskNpc(mActor_name_t mask_id, mActor_name_t npc_id, mActor_name_t cloth);\nextern void mRmTp_MakeFtrNoTable(mActor_name_t* dst, mActor_name_t* src);\n\n#define mRmTp_FTR_UNIT_MAX 4\nenum {\n  mRmTp_DIRECT_SOUTH,\n  mRmTp_DIRECT_EAST,\n  mRmTp_DIRECT_NORTH,\n  mRmTp_DIRECT_WEST,\n\n  mRmTp_DIRECT_NUM\n};\n\ntypedef struct room_type_place_info_one_s {\n  int exists;\n  int ut_x;\n  int ut_z;\n} mRmTp_FtrPlaceInfoOne_t;\n\ntypedef struct room_type_place_info_s {\n  mRmTp_FtrPlaceInfoOne_t units[mRmTp_FTR_UNIT_MAX];\n} mRmTp_FtrPlaceInfo_t;\n\nextern int mRmTp_GetFurnitureData(mActor_name_t ftr, int ut_x, int ut_z, mRmTp_FtrPlaceInfoOne_t* place_info);\n\n#define mHandbill_HRA_REWARD0 0x221\n#define mHandbill_HRA_REWARD1 0x222\n\n#define mString_DAY_START 0x64E\n#define mString_MONTH_START 0x66D\n\n#define FTR_GET_ROTATION(f) ((f) & 3)\n\nextern void mSP_SelectRandomItem_New(GAME* game, mActor_name_t* goods_table, int goods_count, mActor_name_t* goods_exist_table, int goods_exist_count, int category, int list_type, int uncollected_only);\nextern int mSP_ShopSaleReport(mActor_name_t sold_item, mActor_name_t* goods_table, int goods_count, mActor_name_t rsv_item);\nextern u32 mSP_ItemNo2ItemPrice(mActor_name_t item_no);\nextern int mSP_SearchItemCategoryPriority(mActor_name_t item_no, int category, int list_type, GAME* game);\nextern int mSP_CountElementInGoodsList();\nextern int mSP_CheckExchangeDay2();\nextern int mSP_CheckExchangeMonth();\nextern void mSP_NewExchangeDay();\nextern void mSP_ShopItsumoChirashi(int house_no, int shop_level, mActor_name_t item, int type, int send_proc);\nextern void mSP_SetShopRareFurnitureChirashi(int player_no, mActor_name_t* goods_list, int goods_count, GAME* game);\nextern void mSP_SetRenewalChiraswhi_AppoDay();\nextern void mSP_ExchangeLineUp_InGame(GAME* game);\nextern void mSP_PlusSales(u32 sum);\nextern int mSP_SetNewVisitor();\nextern u32 mSP_GetSalesSum();\nextern u16 mSP_GetShopLevel();\nextern int mSP_RenewShopLevel();\nextern int mSP_GetRealShopLevel();\nextern int mSP_GetGoodsPercent(int priority);\nextern void mSP_PrintNowShopSalesSum(gfxprint_t* gfxprint);\nextern void mSP_GetGoodsPriority(u8* abc_priorities, int category);\nextern void mSP_ExchangeLineUp_ZeldaMalloc();\nextern void mSP_LotteryLineUp_ZeldaMalloc();\nextern void mSP_ExchangeLineUp_GameAlloc(GAME* game);\nextern void mSP_LotteryLineUp_GameAlloc(GAME* game);\nextern void mSP_InitShopSaveData();\nextern void mSP_ShopGameStartCt(GAME* game);\nextern mActor_name_t mSP_GetNowShopBgNum();\nextern int mSP_WhatSpecialSale();\nextern mActor_name_t mSP_GetNowShopFgNum();\nextern lbRTC_hour_t mSP_GetShopOpenTime();\nextern lbRTC_hour_t mSP_GetShopCloseTime();\nextern lbRTC_hour_t mSP_GetShopCloseTime_Bgm();\nextern int mSP_InRenewal();\nextern int mSP_ShopOpen();\nextern void mSP_RandomHaniwaSelect(mActor_name_t* haniwa_list, int count);\nextern void mSP_RandomMDSelect(mActor_name_t* md_list, int count);\nextern void mSP_RandomUmbSelect(mActor_name_t* umb_list, int count);\nextern mActor_name_t mSP_RandomOneFossilSelect(int multi_fossil);\nextern int mSP_Chk_HukubukuroSail();\nextern int mSP_CheckFukubikiDay();\nextern int mSP_SetGoods2ReservedPoint(mActor_name_t goods, mActor_name_t reserved_no);\nextern int mSP_CheckHallowinDay();\nextern void mSP_SetTanukiShopStatus();\nextern int mSP_money_check(u32 amount);\nextern void mSP_get_sell_price(u32 amount);\nextern mActor_name_t mSP_SelectFishginPresent(int player_no);\nextern void mSP_SelectRandomItemToAGB();\nextern const char* mSP_ShopStatus2String(int status);\nextern mActor_name_t mSP_GetRandomStationToyItemNo();\n\nenum {\n  mSP_CLOTH_SEASON_ANY,\n  mSP_CLOTH_SEASON_SPRING,\n  mSP_CLOTH_SEASON_SUMMER,\n  mSP_CLOTH_SEASON_AUTUMN,\n  mSP_CLOTH_SEASON_WINTER,\n\n  mSP_CLOTH_SEASON_NUM\n};\n\nenum {\n  mSP_GOODS_TYPE_PAPER,\n  mSP_GOODS_TYPE_CLOTH,\n  mSP_GOODS_TYPE_FTR,\n  mSP_GOODS_TYPE_RARE_FTR,\n  mSP_GOODS_TYPE_CARPET,\n  mSP_GOODS_TYPE_WALL,\n  mSP_GOODS_TYPE_6,\n  mSP_GOODS_TYPE_7,\n  mSP_GOODS_TYPE_SAPLING,\n  mSP_GOODS_TYPE_TOOL,\n  mSP_GOODS_TYPE_PLANT,\n\n  mSP_GOODS_TYPE_NUM\n};\n\nenum {\n  mSP_SHOP_TYPE_ZAKKA,\n  mSP_SHOP_TYPE_COMBINI,\n  mSP_SHOP_TYPE_SUPER,\n  mSP_SHOP_TYPE_DSUPER,\n\n  mSP_SHOP_TYPE_NUM\n};\n\nenum {\n  mSP_SHOP_STATUS_PRE,\n  mSP_SHOP_STATUS_END,\n  mSP_SHOP_STATUS_OPEN,\n  mSP_SHOP_STATUS_RENEW,\n  mSP_SHOP_STATUS_PREEVENT,\n  mSP_SHOP_STATUS_ENDEVENT,\n  mSP_SHOP_STATUS_OPENEVENT,\n\n  mSP_SHOP_STATUS_NUM\n};\n\nenum {\n  mSP_TANUKI_SHOP_STATUS_NORMAL,\n  mSP_TANUKI_SHOP_STATUS_EVENT,\n  mSP_TANUKI_SHOP_STATUS_HALLOWEEN,\n  mSP_TANUKI_SHOP_STATUS_FUKUBIKI,\n  mSP_TANUKI_SHOP_STATUS_HUKUBUKURO_SALE,\n\n  mSP_TANUKI_SHOP_STATUS_NUM\n};\n\n#define mSP_PERSONAL_ID_COUNT 10\n#define mSP_GOODS_COUNT 39\n#define mSP_LOTTERY_ITEM_COUNT 3\n\n#define mSP_SIGNBOARD_PRICE 500\n#define mSP_FORIEGN_FRUIT_PRICE 2000\n\n#define mSP_NET_SALES_SUM  3000 // minimum sales sum before net appears (Nook's Cranny only)\n#define mSP_ROD_SALES_SUM  8000 // minimum sales sum before rod appears (Nook's Cranny only)\n#define mSP_AXE_SALES_SUM 12000 // minimum sales sum before axe appears (Nook's Cranny only)\n\n#define mSP_COMBINI_SUM 25000 // sales sum for upgrading to Nook 'n' Go\n#define mSP_SUPER_SUM   90000 // sales sum for upgrading to Nookway\n#define mSP_DSUPER_SUM 240000 // sales sum for upgrading to Nookington's\n\nextern u8* mRmTp_CheckFtrBirthInfoTop();\nextern int mCoBG_GetHoleNumber(xyz_t wpos);\nextern mQst_errand_c* mQst_GetFirstJobData();\n\nenum {\n  mHandbillz_TYPE_SUPER,\n  mHandbillz_TYPE_MAILA,\n  mHandbillz_TYPE_MAILB,\n  mHandbillz_TYPE_MAILC,\n  mHandbillz_TYPE_PS,\n\n  mHandbillz_TYPE_NUM\n};\n\ntypedef struct mHandbillz_info_s {\n  u8* super_buf_p;\n  size_t super_buf_size;\n\n  u8* mail_buf_p;\n  size_t mail_buf_size;\n\n  u8* ps_buf_p;\n  size_t ps_buf_size;\n\n  int super_no;\n  int maila_no;\n  int mailb_no;\n  int mailc_no;\n  int ps_no;\n\n  int header_back_start;\n} mHandbillz_Info_c;\n\nextern u8* mLd_GetLandName();\n#define ARRAY_COUNT(arr) (int)(sizeof(arr) / sizeof(arr[0]))\nextern int mMC_get_mail_hit_rate(int* len, u8* str, GAME* game);\n\nenum {\n  mNpc_EVENT_MAIL_VT_DAY, /* valentine's day */\n  mNpc_EVENT_MAIL_WT_DAY, /* white day (JP only) */\n\n  mNpc_EVENT_MAIL_NUM\n};\n\ntypedef struct npc_default_data_s {\n  mActor_name_t cloth;\n  u16 catchphrase_str_idx;\n  s8 umbrella;\n} mNpc_Default_Data_c;\n\nenum {\n  mNpc_EVENT_MAIL_BEST_FRIEND,\n  mNpc_EVENT_MAIL_OK_FRIEND,\n  mNpc_EVENT_MAIL_NOT_FRIEND,\n\n  mNpc_EVENT_MAIL_FRIEND_NUM\n};\n\nenum {\n  mNpc_GROW_STARTER,\n  mNpc_GROW_MOVE_IN,\n  mNpc_GROW_ISLANDER,\n\n  mNpc_GROW_NUM\n};\n\nstatic Mail_c l_npc_mail;\n\nextern void mNpc_SetDefAnimal(Animal_c* animal, mActor_name_t npc_id, mNpc_Default_Data_c* def_data);\nextern void mFI_SetMoveActorBitData_ON(s16 move_actor_idx, int bx, int bz);\nextern int mEvNM_CheckJointEvent(u32 id);\n\nenum {\n  mNpc_NAME_TYPE_SPNPC,\n  mNpc_NAME_TYPE_NPC,\n\n  mNpc_NAME_TYPE_NUM\n};\n\nenum {\n  mNpc_FEEL_NORMAL,\n  mNpc_FEEL_HAPPY,\n  mNpc_FEEL_ANGRY,\n  mNpc_FEEL_SAD,\n  mNpc_FEEL_SLEEPY,\n  mNpc_FEEL_PITFALL,\n\n  mNpc_FEEL_NUM\n};\n\nenum {\n  mNpc_PATIENCE_MILDLY_ANNOYED,\n  mNpc_PATIENCE_ANNOYED,\n  mNpc_PATIENCE_NORMAL,\n\n  mNpc_PATIENCE_NUM\n};\n\nstatic u8 l_no_name_npc_name[ANIMAL_NAME_LEN] = { 0xD4, 0x8E, 0xA6, 0x90, 0x85, 0x42 }; // never translated\nstatic u8 l_no_ending_npc_ending[ANIMAL_CATCHPHRASE_LEN] = { 0xD3, 0xAF, 0x9D, 0x20 }; // never translated\n\nextern mNpc_Default_Data_c npc_def_list[];\nextern s8 npc_grow_list[];\nextern mNpc_NpcHouseData_c npc_house_list[];\n\nextern mNpc_EventNpc_c* mNpc_GetSameEventNpc(mActor_name_t);\nextern mNpc_MaskNpc_c* mNpc_GetSameMaskNpc(mActor_name_t);\n\n#define mNpc_MINIMUM_DAYS_BEFORE_FORCE_REMOVAL 10\nextern int mCoBG_Attr2CheckPlaceNpc(u32 attribute);\nextern int mCoBG_ExistHeightGap_KeepAndNow(xyz_t wpos);\nextern int mFI_CheckFGNpcOn(mActor_name_t item);\n\nextern void mNpc_AddNpc_inBlock(mFM_move_actor_c* move_actor_list, u8 bx, u8 bz);\nstatic int mNpc_GetLooks2NotHaveAppearedNum(u8 looks);\nextern int mNpc_GetSameLooksNum(u8 looks);\nstatic void mNpc_SetDefAnimalInfo(Animal_c* animal, mActor_name_t npc_id, u8 looks, mNpc_Default_Data_c* def_data);\n\n#define mNpc_ISLAND_FTR_NUM 16\n\nenum {\n  mRmTp_FTRSIZE_1x1, /* x */\n  mRmTp_FTRSIZE_1x2, /* yy OR y */\n                     /*       y */\n  mRmTp_FTRSIZE_2x2, /* zz */\n                     /* zz */\n  mRmTp_FTRSIZE_NUM\n};\n\nextern int mNpc_CheckFtrIsIslandBestFtr(mActor_name_t ftr);\nextern int mNpc_SetIslandFtr(PersonalID_c* pid, mActor_name_t ftr);\nextern void mNpc_ClearIslandPresentFtrInfo();\nextern void mNpc_RestoreIslandPresentFtr();\nextern PersonalID_c* mNpc_GetIslandPresentFtrPersonalID();\nextern mActor_name_t mNpc_GetIslandPresentFtr();\nextern f32 mCoBG_GetBgY_OnlyCenter_FromWpos2(xyz_t wpos, f32 foot_dist);\n\nextern int aMR_CorrespondFurniture(mActor_name_t ftr0, mActor_name_t ftr1);\nextern int aMR_GetFurnitureUnit(mActor_name_t ftr);\nextern mActor_name_t aMR_FurnitureFg_to_FurnitureFgWithDirect(mActor_name_t ftr, int direct);\nextern int mNpc_GetAnimalMemoryIdx(PersonalID_c*, Anmmem_c*, int);\nextern int mNpc_ForceGetFreeAnimalMemoryIdx(Animal_c*, Anmmem_c*, int);\nextern void mNpc_SetAnimalMemory(PersonalID_c*, AnmPersonalID_c*, Anmmem_c*);\nextern int mNpc_GetIslandFtrIdx(mActor_name_t);\nextern int mNpc_CheckIslandNpcRoomFtrIdx(int);\nextern int mPr_NullCheckPersonalID(PersonalID_c*);\n\nenum {\n  mFM_BLOCK_TYPE_BORDER_CLIFF_TOP,\n  mFM_BLOCK_TYPE_BORDER_CLIFF_RIVER,\n  mFM_BLOCK_TYPE_BORDER_CLIFF_LEFT,\n  mFM_BLOCK_TYPE_3,\n  mFM_BLOCK_TYPE_BORDER_CLIFF_RIGHT,\n  mFM_BLOCK_TYPE_BORDER_CLIFF_CORNER_TOP_LEFT,\n  mFM_BLOCK_TYPE_6,\n  mFM_BLOCK_TYPE_7,\n  mFM_BLOCK_TYPE_BORDER_CLIFF_CORNER_TOP_RIGHT,\n  mFM_BLOCK_TYPE_BORDER_CLIFF_LEFT_TUNNEL,\n  mFM_BLOCK_TYPE_BORDER_CLIFF_RIGHT_TUNNEL,\n  mFM_BLOCK_TYPE_TRACKS_STATION,\n  mFM_BLOCK_TYPE_TRACKS_DUMP,\n  mFM_BLOCK_TYPE_TRACKS_RIVER,\n  mFM_BLOCK_TYPE_PLAYER_HOUSE,\n  mFM_BLOCK_TYPE_CLIFF_HORIZONTAL,\n  mFM_BLOCK_TYPE_CLIFF_BOTTOM_RIGHT_CORNER,\n  mFM_BLOCK_TYPE_CLIFF_VERTICAL_RIGHT,\n  mFM_BLOCK_TYPE_CLIFF_TOP_RIGHT_CORNER,\n  mFM_BLOCK_TYPE_CLIFF_TOP_LEFT_CORNER,\n  mFM_BLOCK_TYPE_CLIFF_VERTICAL_LEFT,\n  mFM_BLOCK_TYPE_CLIFF_BOTTOM_LEFT_CORNER,\n  mFM_BLOCK_TYPE_WATERFALL_STRAIGHT_CLIFF_HORIZONTAL,\n  mFM_BLOCK_TYPE_WATERFALL_STRAIGHT_CLIFF_BOTTOM_RIGHT_CORNER,\n  mFM_BLOCK_TYPE_RIVER_STRAIGHT_CLIFF_VERTICAL_RIGHT,\n  mFM_BLOCK_TYPE_RIVER_STRAIGHT_CLIFF_TOP_RIGHT_CORNER,\n  mFM_BLOCK_TYPE_WATERFALL_STRAIGHT_CLIFF_TOP_LEFT_CORNER,\n  mFM_BLOCK_TYPE_RIVER_STRAIGHT_CLIFF_VERTICAL_LEFT,\n  mFM_BLOCK_TYPE_RIVER_STRAIGHT_CLIFF_BOTTOM_LEFT_CORNER,\n  mFM_BLOCK_TYPE_RIVER_STRAIGHT_CLIFF_HORIZONTAL,\n  mFM_BLOCK_TYPE_WATERFALL_EAST_CLIFF_BOTTOM_RIGHT_CORNER,\n  mFM_BLOCK_TYPE_WATERFALL_EAST_CLIFF_VERTICAL_RIGHT,\n  mFM_BLOCK_TYPE_RIVER_EAST_CLIFF_TOP_RIGHT_CORNER,\n  mFM_BLOCK_TYPE_RIVER_EAST_CLIFF_TOP_LEFT_CORNER,\n  mFM_BLOCK_TYPE_RIVER_WEST_CLIFF_HORIZONTAL,\n  mFM_BLOCK_TYPE_RIVER_WEST_CLIFF_TOP_RIGHT_CORNER,\n  mFM_BLOCK_TYPE_RIVER_WEST_CLIFF_TOP_LEFT_CORNER,\n  mFM_BLOCK_TYPE_WATERFALL_WEST_CLIFF_VERTICAL_LEFT,\n  mFM_BLOCK_TYPE_WATERFALL_WEST_CLIFF_BOTTOM_LEFT_CORNER,\n  mFM_BLOCK_TYPE_FLAT, // grass\n  mFM_BLOCK_TYPE_RIVER_SOUTH,\n  mFM_BLOCK_TYPE_RIVER_EAST,\n  mFM_BLOCK_TYPE_RIVER_WEST,\n  mFM_BLOCK_TYPE_RIVER_SOUTH_EAST,\n  mFM_BLOCK_TYPE_RIVER_EAST_SOUTH,\n  mFM_BLOCK_TYPE_RIVER_SOUTH_WEST,\n  mFM_BLOCK_TYPE_RIVER_WEST_SOUTH,\n  mFM_BLOCK_TYPE_RIVER_SOUTH_BRIDGE,\n  mFM_BLOCK_TYPE_RIVER_EAST_BRIDGE,\n  mFM_BLOCK_TYPE_RIVER_WEST_BRIDGE,\n  mFM_BLOCK_TYPE_RIVER_SOUTH_EAST_BRIDGE,\n  mFM_BLOCK_TYPE_RIVER_EAST_SOUTH_BRIDGE,\n  mFM_BLOCK_TYPE_RIVER_SOUTH_WEST_BRIDGE,\n  mFM_BLOCK_TYPE_RIVER_WEST_SOUTH_BRIDGE,\n  mFM_BLOCK_TYPE_SLOPE_HORIZONTAL,\n  mFM_BLOCK_TYPE_SLOPE_BOTTOM_RIGHT_CORNER,\n  mFM_BLOCK_TYPE_SLOPE_VERTICAL_RIGHT,\n  mFM_BLOCK_TYPE_SLOPE_TOP_RIGHT_CORNER,\n  mFM_BLOCK_TYPE_SLOPE_TOP_LEFT_CORNER,\n  mFM_BLOCK_TYPE_SLOPE_VERTICAL_LEFT,\n  mFM_BLOCK_TYPE_SLOPE_BOTTOM_LEFT_CORNER,\n  mFM_BLOCK_TYPE_BORDER_CLIFF_LEFT_TRANSITION,\n  mFM_BLOCK_TYPE_BORDER_CLIFF_RIGHT_TRANSITION,\n  mFM_BLOCK_TYPE_BEACH,\n  mFM_BLOCK_TYPE_BEACH_RIVER,\n  mFM_BLOCK_TYPE_TRACKS_SHOP,\n  mFM_BLOCK_TYPE_SHRINE,\n  mFM_BLOCK_TYPE_TRACKS_POST_OFFICE,\n  mFM_BLOCK_TYPE_POLICE_BOX,\n  mFM_BLOCK_TYPE_POOL_SOUTH,\n  mFM_BLOCK_TYPE_POOL_EAST,\n  mFM_BLOCK_TYPE_POOL_WEST,\n  mFM_BLOCK_TYPE_POOL_SOUTH_EAST,\n  mFM_BLOCK_TYPE_POOL_EAST_SOUTH,\n  mFM_BLOCK_TYPE_POOL_SOUTH_WEST,\n  mFM_BLOCK_TYPE_POOL_WEST_SOUTH,\n  mFM_BLOCK_TYPE_76,\n  mFM_BLOCK_TYPE_77,\n  mFM_BLOCK_TYPE_78,\n  mFM_BLOCK_TYPE_79,\n  mFM_BLOCK_TYPE_BORDER_CLIFF_OCEAN_LEFT,\n  mFM_BLOCK_TYPE_BORDER_CLIFF_OCEAN_RIGHT,\n  mFM_BLOCK_TYPE_BEACH_RIVER_BRIDGE,\n  mFM_BLOCK_TYPE_OCEAN,\n  mFM_BLOCK_TYPE_MUSEUM,\n  mFM_BLOCK_TYPE_NEEDLEWORK,\n  mFM_BLOCK_TYPE_86,\n  mFM_BLOCK_TYPE_87,\n  mFM_BLOCK_TYPE_88,\n  mFM_BLOCK_TYPE_89,\n  mFM_BLOCK_TYPE_90,\n  mFM_BLOCK_TYPE_91,\n  mFM_BLOCK_TYPE_92,\n  mFM_BLOCK_TYPE_93,\n  mFM_BLOCK_TYPE_OCEAN_2,\n  mFM_BLOCK_TYPE_OCEAN_3,\n  mFM_BLOCK_TYPE_OCEAN_4,\n  mFM_BLOCK_TYPE_OCEAN_5,\n  mFM_BLOCK_TYPE_ISLAND_LEFT,\n  mFM_BLOCK_TYPE_ISLAND_RIGHT,\n  mFM_BLOCK_TYPE_PORT,\n  mFM_BLOCK_TYPE_SEA_EXCEPTIONAL,\n  mFM_BLOCK_TYPE_OCEAN_6,\n  mFM_BLOCK_TYPE_OCEAN_7,\n  mFM_BLOCK_TYPE_OCEAN_8,\n  mFM_BLOCK_TYPE_105,\n  mFM_BLOCK_TYPE_106,\n  mFM_BLOCK_TYPE_107,\n\n  mFM_BLOCK_TYPE_NUM,\n\n  mFM_BLOCK_TYPE_NONE = 255\n};\n\n#define mRF_BLOCK_TYPE_MAX 108 // TODO: this is likely a giant enum lol\n#define mRF_DIRECT_ERROR 100\n\nenum {\n  mRF_GATE_NONE,\n  mRF_GATE1_TYPE0,\n  mRF_GATE1_TYPE1,\n  mRF_GATE2_TYPE0,\n  mRF_GATE2_TYPE1,\n  mRF_GATE3_TYPE0,\n\n  mRF_GATE_TYPE_NUM\n};\n\nenum {\n  mRF_DIRECT_NORTH,\n  mRF_DIRECT_WEST,\n  mRF_DIRECT_SOUTH,\n  mRF_DIRECT_EAST,\n\n  mRF_DIRECT_NUM\n};\n\nenum {\n  mRF_RIVER0,\n  mRF_RIVER1,\n  mRF_RIVER2,\n  mRF_RIVER3,\n  mRF_RIVER4,\n  mRF_RIVER5,\n  mRF_RIVER6,\n\n  mRF_RIVER_NUM\n};\n\nenum {\n  mRF_FIELD_STEP1,  /* first level */\n  mRF_FIELD_STEP2,  /* second level*/\n  mRF_FIELD_STEP3,  /* third level */\n  mRF_FIELD_STEP4,  /* fourth level */\n\n  mRF_FIELD_STEP_NUM\n};\n\nenum {\n  mNT_ITEM_TYPE_NONE,\n  mNT_ITEM_TYPE_APPLE,\n  mNT_ITEM_TYPE_ORANGE,\n  mNT_ITEM_TYPE_PEACH,\n  mNT_ITEM_TYPE_PEAR,\n  mNT_ITEM_TYPE_NUTS,\n  mNT_ITEM_TYPE_MATSUTAKE,\n  mNT_ITEM_TYPE_KABU,\n  mNT_ITEM_TYPE_FISH,\n  mNT_ITEM_TYPE_BAG,\n  mNT_ITEM_TYPE_LEAF,\n  mNT_ITEM_TYPE_ROLL,\n  mNT_ITEM_TYPE_BOX,\n  mNT_ITEM_TYPE_PACK,\n  mNT_ITEM_TYPE_PRESENT,\n  mNT_ITEM_TYPE_SEED,\n  mNT_ITEM_TYPE_HANIWA,\n  mNT_ITEM_TYPE_ETC,\n  mNT_ITEM_TYPE_CAGE,\n  mNT_ITEM_TYPE_TOOL,\n  mNT_ITEM_TYPE_FOSSIL,\n  mNT_ITEM_TYPE_TRASH,\n  mNT_ITEM_TYPE_LETTER,\n  mNT_ITEM_TYPE_OTOSI,\n  mNT_ITEM_TYPE_SHELLA,\n  mNT_ITEM_TYPE_SHELLB,\n  mNT_ITEM_TYPE_SHELLC,\n  mNT_ITEM_TYPE_CANDY,\n  mNT_ITEM_TYPE_COCONUT,\n  mNT_ITEM_TYPE_OMIKUJI,\n  mNT_ITEM_TYPE_CLOTH,\n  mNT_ITEM_TYPE_CARPET,\n  mNT_ITEM_TYPE_WALL,\n  mNT_ITEM_TYPE_AXE,\n  mNT_ITEM_TYPE_NET,\n  mNT_ITEM_TYPE_ROD,\n  mNT_ITEM_TYPE_SHOVEL,\n  mNT_ITEM_TYPE_AXE2,\n  mNT_ITEM_TYPE_NET2,\n  mNT_ITEM_TYPE_ROD2,\n  mNT_ITEM_TYPE_SHOVEL2,\n  mNT_ITEM_TYPE_UMBRELLA,\n  mNT_ITEM_TYPE_KAZA,\n  mNT_ITEM_TYPE_UTIWA,\n  mNT_ITEM_TYPE_PAPER,\n  mNT_ITEM_TYPE_FLOWER_SEED,\n  mNT_ITEM_TYPE_HUKUBUKURO,\n  mNT_ITEM_TYPE_TAISOU,\n  mNT_ITEM_TYPE_MD,\n  mNT_ITEM_TYPE_TICKET,\n  mNT_ITEM_TYPE_BONE,\n  mNT_ITEM_TYPE_DIARY,\n  mNT_ITEM_TYPE_FORK_ON,\n\n  mNT_ITEM_TYPE_NUM\n};\n\nenum {\n  mNT_TREE_SIZE_FULL,\n  mNT_TREE_SIZE_S2,\n  mNT_TREE_SIZE_S1,\n  mNT_TREE_SIZE_S0,\n\n  mNT_TREE_SIZE_NUM\n};\n\ntypedef struct collision_offset_table_s {\n    u8 unit_attribute;\n    s8 centerRight_offset; \n    s8 leftUp_offset;\n    s8 leftDown_offset;\n    s8 rightDown_offset;\n    s8 rightUp_offset;\n    s8 slate_switch;\n} mCoBG_OffsetTable_c;\n\ntypedef struct offset_table_s {\n  int type;\n  mCoBG_OffsetTable_c table;\n} mNT_offset_table_c;\n\ntypedef struct collision_unit_info_s {\n  mCoBG_Collision_u* collision;\n  f32 leftUp_offset;\n  f32 leftDown_offset;\n  f32 rightUp_offset;\n  f32 rightDown_offset;\n  f32 base_height;\n  f32 pos_x;\n  f32 pos_z;\n  int ut_x;\n  int ut_z;\n  int shape;\n  u8 attribute;\n  mActor_name_t item;\n} mCoBG_UnitInfo_c;\n\nenum {\n  mCoBG_DIRECT_N,\n  mCoBG_DIRECT_W,\n  mCoBG_DIRECT_S,\n  mCoBG_DIRECT_E,\n  mCoBG_DIRECT_NW,\n  mCoBG_DIRECT_NE,\n  mCoBG_DIRECT_SE,\n  mCoBG_DIRECT_SW,\n\n  mCoBG_DIRECT_NUM\n};\n\nenum {\n  mCoBG_AREA_N,\n  mCoBG_AREA_W,\n  mCoBG_AREA_S,\n  mCoBG_AREA_E,\n\n  mCoBG_AREA_NUM\n};\n\n#define mFI_UNIT_BASE_SIZE 40\n#define mFI_UNIT_BASE_SIZE_F ((f32)mFI_UNIT_BASE_SIZE)\n\ntypedef struct xz_s {\n    f32 x, z;\n} xz_t;\n\nextern mCoBG_Collision_u* mFI_UtNum2UtCol(int ut_x, int ut_z);\nextern mActor_name_t* mFI_UtNum2UtFG(int ut_x, int ut_z);\nextern f32 mFI_UtNum2BaseHeight(int ut_x, int ut_z);\n\ntypedef struct collision_actor_info_s {\n  mActor_name_t name_id;\n  u8 _02;\n  u8 on_ground;\n  u8 _04;\n  u8 in_water;\n  u8 _06[2]; // alignment?\n  mCoBG_CheckResult_c* check_res_p;\n  xz_t speed_xz0;\n  xz_t speed_xz1;\n  xyz_t center_pos;\n  xyz_t old_center_pos;\n  xyz_t rev_pos;\n  u8 _40[4];\n  f32 _44;\n  f32 _48;\n  f32 _4C;\n  u8 _50[0x20];\n} mCoBG_ActorInf_c;\n\n#define mDemo_ORDER_VALUE_NUM 16\n#define mDemo_ORDER_VALUE_MAX 10\n#define mDemo_REQUEST_NUM 32\n\n#define mDemo_MSG_PRIORITY 5\n#define mDemo_CAMERA_PRIORITY 6\n\n#define mDemo_WINDOW_COLOR_R 235\n#define mDemo_WINDOW_COLOR_G 255\n#define mDemo_WINDOW_COLOR_B 235\n#define mDemo_WINDOW_COLOR_A 255\n\nenum {\n  mDemo_STATE_WAIT,\n  mDemo_STATE_READY,\n  mDemo_STATE_RUN,\n  // ???\n  mDemo_STATE_STOP = 9,\n\n  mDemo_STATE_NUM\n};\n\nenum {\n  mDemo_DIRECT_N,\n  mDemo_DIRECT_NE,\n  mDemo_DIRECT_E,\n  mDemo_DIRECT_SE,\n  mDemo_DIRECT_S,\n  mDemo_DIRECT_SW,\n  mDemo_DIRECT_W,\n  mDemo_DIRECT_NW,\n\n  mDemo_DIRECT_NUM\n};\n\nenum demo_type {\n  mDemo_TYPE_NONE,\n  mDemo_TYPE_SCROLL,\n  mDemo_TYPE_2,\n  mDemo_TYPE_DOOR,\n  mDemo_TYPE_4,\n  mDemo_TYPE_SCROLL2,\n  mDemo_TYPE_DOOR2,\n  mDemo_TYPE_TALK,\n  mDemo_TYPE_SPEAK,\n  mDemo_TYPE_REPORT,\n  mDemo_TYPE_SPEECH,\n  mDemo_TYPE_OUTDOOR,\n  mDemo_TYPE_12,\n  mDemo_TYPE_EVENTMSG,\n  mDemo_TYPE_EVENTMSG2,\n  mDemo_TYPE_15,\n  mDemo_TYPE_SCROLL3,\n\n  mDemo_TYPE_NUM\n};\n\nenum demo_order_type {\n  mDemo_ORDER_PLAYER,\n  mDemo_ORDER_1,\n  mDemo_ORDER_2,\n  mDemo_ORDER_3,\n  mDemo_ORDER_NPC0,\n  mDemo_ORDER_NPC1,\n  mDemo_ORDER_NPC2,\n  mDemo_ORDER_7,\n  mDemo_ORDER_8,\n  mDemo_ORDER_QUEST,\n\n  mDemo_ORDER_NUM\n};\n\ntypedef struct demo_door_data_s {\n  int type;\n\n  struct {\n    f32 size;\n    int direct;\n  } house_info;\n} mDemo_door_data_c;\n\ntypedef struct demo_emsg_data_s {\n  int msg_no;\n  rgba_t window_color;\n  int msg_delay_timer;\n  int scene_delay_timer;\n  Door_data_c door_data;\n  u8 _24[4]; // unused?\n} mDemo_emsg_data_c;\n\ntypedef struct demo_talk_data_s {\n  int msg_no;\n  int turn;\n  int use_zoom_sound;\n  int display_name;\n  int change_player;\n  int return_get_golden_axe_demo;\n  int return_demo_wait;\n  rgba_t window_color;\n  u8 actor_saved_weight;\n} mDemo_talk_data_c;\n\ntypedef struct demo_data_s {\n  ACTOR* speaker_actor;\n  ACTOR* listen_actor;\n  int speaker_able;\n  int listen_able;\n  u16 order_data[mDemo_ORDER_NUM][mDemo_ORDER_VALUE_MAX];\n  s8 change_player_destiny;\n  int state;\n  mDemo_Request_c current;\n  mDemo_Request_c request[mDemo_REQUEST_NUM];\n  int request_num;\n  int priority_type;\n  int camera_type;\n  int keep_camera_type;\n\n  union {\n    mDemo_door_data_c door;\n    mDemo_emsg_data_c emsg;\n    mDemo_talk_data_c talk;\n  } data;\n\n  mDemo_Request_c request_save;\n} mDemo_Data_c;\n\nextern ACTOR* mDemo_Get_talk_actor();\nextern void mDemo_Set_speaker_actor(ACTOR* actor);\nextern void mDemo_Set_OrderValue(int type, int idx, u16 value);\nextern u16 mDemo_Get_OrderValue(int type, int idx);\nextern void mDemo_Set_msg_num(int msg_num);\nextern int mDemo_Get_Talk_Actors(ACTOR** speaker, ACTOR** listener);\nextern void mDemo_Set_change_player_destiny(s8 destiny);\nextern void mDemo_Set_use_zoom_sound(u8 use_zoom_sound);\nextern int mDemo_Get_use_zoom_sound();\nextern void mDemo_Set_talk_display_name(s8 display_name);\nextern int mDemo_Get_talk_display_name();\nextern void mDemo_Set_talk_change_player(u8 change_player);\nextern int mDemo_Get_talk_change_player();\nextern void mDemo_Set_talk_return_demo_wait(u8 return_demo_wait);\nextern int mDemo_Get_talk_return_demo_wait();\nextern void mDemo_Set_talk_return_get_golden_axe_demo(u8 return_get_golden_axe_demo);\nextern int mDemo_Get_talk_return_get_golden_axe_demo();\nextern void mDemo_Set_talk_turn(u8 turn);\nextern int mDemo_Get_talk_turn();\nextern void mDemo_Set_talk_window_color(rgba_t* window_color);\nextern rgba_t* mDemo_Get_talk_window_color_p();\nextern void mDemo_Set_camera(u8 camera_type);\nextern int mDemo_Get_camera();\nextern int mDemo_CheckDemoType();\nextern int mDemo_Set_house_info(f32 size, int direct);\nextern void mDemo_stock_clear();\nextern int mDemo_Request(int type, ACTOR* actor, mDemo_REQUEST_PROC req_proc);\nextern int mDemo_Check(int type, ACTOR* actor);\nextern int mDemo_Start(ACTOR* actor);\nextern int mDemo_Check_and_Go(int type, ACTOR* actor);\nextern int mDemo_End(ACTOR* actor);\nextern void mDemo_Main(GAME_PLAY* play);\nextern void mDemo_Init(GAME_PLAY* play);\nextern int mDemo_CheckDemo();\nextern int mDemo_CheckDemo4Event();\nextern void mDemo_Set_SpeakerAble();\nextern void mDemo_Set_ListenAble();\nextern void mDemo_Unset_SpeakerAble();\nextern void mDemo_Unset_ListenAble();\nextern int mDemo_Check_SpearkerAble();\nextern int mDemo_Check_ListenAble();\nextern int mDemo_Check_DiffAngle_forTalk(s16 diff_angle);\nextern void mDemo_KeepCamera(int camera_type);\n\n\nenum {\n  mSM_OVL_PROC_MOVE,\n  mSM_OVL_PROC_PLAY,\n  mSM_OVL_PROC_WAIT,\n  mSM_OVL_PROC_OBEY,\n  mSM_OVL_PROC_END,\n\n  mSM_OVL_PROC_NUM\n};\n\nenum {\n  mWR_STATE_OUT,\n  mWR_STATE_IN,\n\n  mWR_STATE_NUM\n};\n\nstruct warning_ovl_s {\n  u8 selected;\n  u8 state;\n  f32 scale;\n};\n\n#define mDI_ENTRY_SIZE 992\n\ntypedef struct diary_entry_s {\n  u8 text[mDI_ENTRY_SIZE];\n} mDi_entry_c;\n\ntypedef struct diary_data_s {\n  u16 checksum;\n  mDi_entry_c entries[PLAYER_NUM][lbRTC_MONTHS_MAX];\n} mDi_data_c;\n\nextern int mDi_strlen(u8* str, int max_len, u8 end_char);\n\nenum {\n  mDI_FIELD_BODY,\n\n  mDI_FIELD_NUM\n};\n\nstruct diary_ovl_s {\n  mDi_data_c* data;\n  u8 field;\n  u8 _05;\n  s16 entry_len[mDI_FIELD_NUM];\n  mDi_entry_c* current_entry;\n  int _0C;\n  int _10;\n  int _14;\n  int _18;\n  s16 move_proc;\n  s16 _1E;\n  s16 _20;\n  s16 _22;\n  s16 _24;\n  f32 _28;\n  s16 _2C;\n  s16 _2E;\n  s16 _30;\n  s16 _32;\n  u32 trigger;\n  u32 button;\n  u32 last_button;\n  s16 _40;\n  s16 _42;\n  s16 cursor_idx;\n  s16 _46;\n  s16 _48;\n};\n\nenum {\n  mWR_WARNING_MAILBOX,\n  mWR_WARNING_PR_LEAVE,\n  mWR_WARNING_MONEY,\n  mWR_WARNING_PR_FOOD,\n  mWR_WARNING_PR_QUEST,\n  mWR_WARNING_5,\n  mWR_WARNING_6,\n  mWR_WARNING_7,\n  mWR_WARNING_8,\n  mWR_WARNING_PUT_MAX_FURNITURE,\n  mWR_WARNING_PUT_FURNITURE,\n  mWR_WARNING_PUT_ITEM,\n  mWR_WARNING_PUT_PLANT,\n  mWR_WARNING_HUKUBUKURO_OPEN,\n  mWR_WARNING_PRESENT_MAIL,\n  mWR_WARNING_WRITE,\n  mWR_WARNING_MUSIC,\n  mWR_WARNING_MUSIC2,\n  mWR_WARNING_ORIGINAL,\n  mWR_WARNING_PUT_SIGN,\n  mWR_WARNING_PUT_SIGN_OTHER,\n  mWR_WARNING_PUT_SIGN_ISLAND,\n  mWR_WARNING_PR_CARD,\n  mWR_WARNING_LOCK_DIARY,\n  mWR_WARNING_PUT_FAMI,\n  mWR_WARNING_WORD_OVER,\n  mWR_WARNING_PW_CHK,\n  mWR_WARNING_PR_FORK,\n\n  mWR_WARNING_NUM\n};\n\n#define mWR_SHOW_WARNING(submenu, warning) \\\n  mSM_open_submenu(submenu, mSM_OVL_WARNING, warning, 0)\n\nextern Mtx Mtx_clear;\n\n#define mFont_MARKTYPE_VERT_ARROW 0\n#define mFont_MARKTYPE_HORI_ARROW 1\n#define mFont_MARKTYPE_CURSOR 2\n#define mFont_MARKTYPE_NEXT 3\n#define mFont_MARKTYPE_CHOICE 4\n#define mFont_MARKTYPE_TOTAL 5\n\nextern Gfx* two_tex_scroll_dolphin(GRAPH* graph, int tile1, int x1, int y1, int width1, int height1, int tile2, int x2, int y2, int width2, int height2);\n\n#define mED_COLUMNS 10\n#define mED_ROWS 4\n\n#define mED_NG_WORD_START 0x74A\n#define mED_NG_WORD_NUM 14\n\nenum {\n  mED_TYPE_BOARD,\n  mED_TYPE_HBOARD,\n  mED_TYPE_NOTICE,\n  mED_TYPE_LEDIT,\n  mED_TYPE_CP_TITLE,\n  mED_TYPE_DIARY,\n  mED_TYPE_PASSWORDMAKE,\n  mED_TYPE_PASSWORDCHK,\n\n  mED_TYPE_NUM\n};\n\nenum {\n  mED_STICK_AREA_LEFT,\n  mED_STICK_AREA_TOP_LEFT,\n  mED_STICK_AREA_TOP,\n  mED_STICK_AREA_TOP_RIGHT,\n  mED_STICK_AREA_RIGHT,\n  mED_STICK_AREA_BOTTOM_RIGHT,\n  mED_STICK_AREA_BOTTOM,\n  mED_STICK_AREA_BOTTOM_LEFT,\n  mED_STICK_AREA_CENTER,\n\n  mED_STICK_AREA_NUM\n};\n\nenum {\n  mED_COMMAND_NONE,\n  mED_COMMAND_CURSOL_RIGHT,\n  mED_COMMAND_CURSOL_LEFT,\n  mED_COMMAND_CURSOL_UPPER,\n  mED_COMMAND_CURSOL_LOWER,\n  mED_COMMAND_END_EDIT,\n  mED_COMMAND_BACKSPACE,\n  mED_COMMAND_EXCHANGE_CODE,\n  mED_COMMAND_OUTPUT_CODE,\n  mED_COMMAND_9\n};\n\nenum {\n  mED_SHIFT_LOWER,\n  mED_SHIFT_UPPER,\n\n  mED_SHIFT_NUM\n};\n\nenum {\n  mED_ARRANGE_QWERTY,\n  mED_ARRANGE_ALPHA,\n\n  mED_ARRANGE_NUM\n};\n\nenum {\n  mED_INPUT_MODE_LETTER,\n  mED_INPUT_MODE_SIGN,\n  mED_INPUT_MODE_MARK,\n\n  mED_INPUT_MODE_NUM\n};\n\nenum {\n  mED_LINETYPE_SINGLE,\n  mED_LINETYPE_MULTI,\n  mED_LINETYPE_PW,\n\n  mED_LINETYPE_NUM\n};\n\nenum {\n  mED_LINE_OK,\n  mED_LINE_NEWLINE,\n  mED_LINE_WIDTH_OVER,\n  mED_LINE_NUM_OVER,\n\n  mED_LINE_NUM\n};\n\ntypedef void (*mED_ENDCODE_DRAW_PROC)(Submenu*, GAME*, f32, f32);\ntypedef void (*mED_CURSOL_DRAW_PROC)(Submenu*, GAME*, f32, f32);\n\nstruct editor_ovl_s {\n  u8 stick_area;\n  u8 stick_area_changed;\n  u8 select_col;\n  u8 select_row;\n  u8 stick_area_held_frames;\n  u8 input_mode;\n  u8 shift_mode;\n  u8 arrange;\n  int _08;\n  u8 _0C;\n  u8 _0D;\n  u8 _0E;\n  u8 _0F;\n  u8 _10;\n  u8 command;\n  u8 _12;\n  u8 now_code;\n  u8 _14;\n  u8 _15;\n  s16 cursor_idx;\n  s16 input_length;\n  s16 max_line_no;\n  s16 line_width;\n  s16 now_str_len;\n  s16 exchange_code;\n  s16 _22;\n  s16 _24;\n  s16 _26;\n  u8* input_str;\n  mED_ENDCODE_DRAW_PROC end_code_draw;\n  mED_CURSOL_DRAW_PROC cursol_draw;\n  u8 _34;\n};\n\nextern void sAdo_VoiceSe(u8 num, u8 num2, u8 num3, s16 character_idx, u8 scale, u8 mode);\n\ntypedef struct submenu_dlftbl {\n  void* _00;\n  int _04;\n  int _08;\n  int _0C;\n  int _10;\n  int _14;\n  const char* name;\n} mSM_dlftbl_c;\n\nenum {\n  mSM_DLF_SUBMENU_OVL,\n  mSM_DLF_PLAYER_ACTOR,\n\n  mSM_DLF_NUM\n};\n\n#define INSECT_ONLY_NUM 40\n\nextern void mSM_open_submenu(Submenu* submenu, int type, int arg0, int arg1);\nextern void mSM_open_submenu_new(Submenu* submenu, int type, int arg0, int arg1, void* arg2);\nextern void mSM_open_submenu_new2(Submenu* submenu, int type, int arg0, int arg1, void* arg2, int arg3);\n\n#define mSM_MAP_BUTTON BUTTON_X\n#define mSM_INV_BUTTON_0 BUTTON_START\n#define mSM_INV_BUTTON_1 BUTTON_Y\n\nextern void mSM_menu_ovl_init(Submenu* submenu);\n\n#define ACTOR_OBJ_BANK_14 14\n#define ACTOR_OBJ_BANK_15 15\n\nextern int mCoBG_SearchWaterLimitDistN(xyz_t* water_pos, xyz_t wpos, s16 angle, float max_dist, int divisor);\n\n#define gDPSetTileSize_Dolphin(pkt, tile, s, t, width, height)\t\t\\\ndo { \\\n    Gfx* _gfx = (Gfx*)(pkt); \\\n    _gfx->words.w0 = _SHIFTL(G_SETTILESIZE, 24, 8) | _SHIFTL(s, 10, 14) | _SHIFTL(width - 1, 0, 10); \\\n    _gfx->words.w1 = _SHIFTL(1, 31, 1) | _SHIFTL(tile, 24, 3) | _SHIFTL(t, 10, 14) | _SHIFTL(height - 1, 0, 10); \\\n} while (0)\n\ntypedef void (*mHP_SET_HANIWAPORTRAIT_PROC)(Submenu*, mSM_MenuInfo_c*, GRAPH*, GAME*, f32, f32);\ntypedef void (*mHP_HANIWAPORTRAIT_SHAPE_MOVE_PROC)(Submenu*);\n\nstruct haniwaPortrait_ovl_s {\n  cKF_SkeletonInfo_R_c keyframe;\n  s_xyz keyframe_work[8];\n  s_xyz keyframe_morph[8];\n  u8 _0D0[72];\n  mHP_SET_HANIWAPORTRAIT_PROC set_haniwaPortrait_proc;\n  mHP_HANIWAPORTRAIT_SHAPE_MOVE_PROC haniwaPortrait_shape_move_proc;\n};\n\n#define mTI_MIN_YEAR 1\n#define mTI_MAX_YEAR 30\n\nenum {\n  mTI_IDX_HOUR,\n  mTI_IDX_MIN,\n  mTI_IDX_MONTH,\n  mTI_IDX_DAY,\n  mTI_IDX_YEAR,\n  mTI_IDX_OK,\n\n  mTI_IDX_NUM = mTI_IDX_OK\n};\n\nenum {\n  mTI_OVL_OPEN_NORMAL,\n  mTI_OVL_OPEN_INITIAL,\n\n  mTI_OVL_OPEN_NUM\n};\n\nstruct timeIn_ovl_s {\n  u16 values[mTI_IDX_NUM];\n  int sel_idx;\n  u16 saved_min;\n  u16 input_disabled_flag;\n  lbRTC_time_c original_time;\n  int init_flag;\n};\n\n#define mHB_LINE_WIDTH_MAX 192\n#define mHB_LINE_NUM 4\n\nenum {\n  mHB_LINE_CHECK_OK,\n  mHB_LINE_CHECK_NEWLINE,\n  mHB_LINE_CHECK_OVER_WIDTH,\n  mHB_LINE_CHECK_OVER_STR_LEN,\n\n  mHB_LINE_CHECK_NUM\n};\n\nenum {\n  mRP_CURSOR_100000,\n  mRP_CURSOR_10000,\n  mRP_CURSOR_1000,\n  mRP_CURSOR_100,\n  mRP_CURSOR_10,\n  mRP_CURSOR_1,\n  mRP_CURSOR_OK,\n\n  mRP_CURSOR_NUM\n};\n\nstruct repay_ovl_s {\n  u32 money;\n  u32 loan;\n  u32 repay_amount;\n  u32 max_money;\n  u32 max_repay;\n  int cursor_idx;\n};\n\nenum {\n  mEE_TYPE_BOARD,\n  mEE_TYPE_NOTICE,\n  mEE_TYPE_MSCORE,\n  mEE_TYPE_CPORIGINAL,\n  mEE_TYPE_ORIGINAL_DESIGN,\n\n  mEE_TYPE_NUM\n};\n\n#define mNT_MAX_WIDTH 192\n#define mNT_MAX_LINES 6\n\nenum {\n  mNT_PLAY_PAGE_READ,\n  mNT_PLAY_PAGE_MOVE,\n  mNT_PLAY_PAGE_TO_WRITE,\n  mNT_PLAY_PAGE_TO_READ,\n\n  mNT_PLAY_PAGE_NUM\n};\n\nenum {\n  mNT_LINE_CHECK_OK,\n  mNT_LINE_CHECK_NEWLINE,\n  mNT_LINE_CHECK_OVERLINE,\n  mNT_LINE_CHECK_OVERSTRING,\n\n  mNT_LINE_CHECK_NUM\n};\n\nstruct notice_ovl_s {\n  u8 mode;\n  u8 stick_area;\n  u8 page_center;\n  u8 page_count;\n  u8 now_page;\n  u8 disp_page;\n  u8 move_time;\n  mNtc_board_post_c post;\n  f32 control_position;\n};\n\nenum {\n  mBR_Ovl_IDX_MONTH,\n  mBR_Ovl_IDX_DAY,\n  mBR_Ovl_IDX_DATE_NUM,\n\n  mBR_Ovl_IDX_OK = mBR_Ovl_IDX_DATE_NUM,\n  mBR_Ovl_IDX_NUM\n};\n\nstruct birthday_ovl_s {\n  u16 birthday_data[mBR_Ovl_IDX_DATE_NUM];\n  int idx;\n};\n\nextern Gfx birthday_win_mode[];\nextern Gfx birthday_win_model[];\nextern Gfx brt_win_month_model[];\n\nextern u8 tim_win_january_tex_rgb_i4[];\nextern u8 tim_win_february_tex_rgb_i4[];\nextern u8 tim_win_march_tex_rgb_i4[];\nextern u8 tim_win_april_tex_rgb_i4[];\nextern u8 tim_win_may_tex_rgb_i4[];\nextern u8 tim_win_june_tex_rgb_i4[];\nextern u8 tim_win_july_tex_rgb_i4[];\nextern u8 tim_win_august_tex_rgb_i4[];\nextern u8 tim_win_september_tex_rgb_i4[];\nextern u8 tim_win_october_tex_rgb_i4[];\nextern u8 tim_win_november_tex_rgb_i4[];\nextern u8 tim_win_december_tex_rgb_i4[];\n\nextern u16 getTrigger();\nextern void mPr_SetPossessionItem(Private_c* priv, int idx, mActor_name_t item, u32 cond);\n\ntypedef void (*mTG_INIT_TAG_DATA_ITEM_WIN_PROC)(Submenu*);\n\n/* TODO */\nstruct tag_ovl_s {\n  /* 0x000 */ u8 _000[0x2E0 - 0x000];\n  /* 0x2E0 */ mTG_INIT_TAG_DATA_ITEM_WIN_PROC init_tag_data_item_win_proc;\n  /* 0x2E4 */ u8 _2E4[0x3C4 - 0x2E4];\n};\n\n#define mBD_MAX_WIDTH 192\n#define mBD_BODY_LINE_NUM 6\n\nenum {\n  mBD_LINE_CHECK_OK,\n  mBD_LINE_CHECK_NEWLINE,\n  mBD_LINE_CHECK_OVERLINE,\n  mBD_LINE_CHECK_OVERSTRING,\n\n  mBD_LINE_CHECK_NUM\n};\n\nextern void mBD_board_ovl_set_proc(Submenu* submenu);\nextern void mBD_board_ovl_construct(Submenu* submenu);\nextern void mBD_board_ovl_destruct(Submenu* submenu);\n\ntypedef struct tools_s{\n  /* 0x000 */ ACTOR actor_class;\n  /* 0x174 */ int tool_name;\n  /* 0x178 */ MtxF matrix_work;\n  /* 0x1B8 */ int init_matrix;\n  /* 0x1BC */ int unk1BC;\n  /* 0x1C0 */ int work0;\n  /* 0x1C4 */ int work1;\n  /* 0x1C8 */ int work2;\n}TOOLS_ACTOR;\n\nenum {\n  aHOI_REQUEST_NO_REQUEST,\n  aHOI_REQUEST_TRANSFER,\n  aHOI_REQUEST_TRANS_WAIT,\n  aHOI_REQUEST_GET,\n  aHOI_REQUEST_GET_PULL,\n  aHOI_REQUEST_EAT,\n  aHOI_REQUEST_CHANGE,\n  aHOI_REQUEST_PUTAWAY,\n  aHOI_REQUEST_GET_PULL_WAIT,\n  aHOI_REQUEST_RETURN,\n  aHOI_REQUEST_RETURN_WAIT,\n  aHOI_REQUEST_ESTIMATE,\n\n  aHOI_REQUEST_NUM\n};\n\nenum {\n  aHOI_NOT_PRESENT,\n  aHOI_PRESENT,\n\n  aHOI_PRESENT_TYPE_NUM\n};\n\nstruct hand_over_item_actor_s {\n  TOOLS_ACTOR tools_class;\n  int mode;\n  f32 anm_cnt;\n  xyz_t trans;\n  f32 scale;\n  u8 trans_flag;\n  u8 item_type;\n  u8 draw_type;\n  u8 se_set_flag;\n  int item;\n  int gyo_type;\n  int gyo_flag;\n};\n\nstruct actor_structure_s {\n  ACTOR actor_class;\n  int keyframe_state;\n  cKF_SkeletonInfo_R_c keyframe;\n  int keyframe_saved_keyframe;\n  s_xyz work_area[15];\n  s_xyz morph_area[15];\n  aSTR_MOVE_PROC action_proc;\n  int _2A4;\n  int structure_type; /* aSTR_TYPE_* */\n  int structure_pal; /* aSTR_PAL_* */\n  int request_type;\n  int action;\n\n  /* general purpose members with unique usage between structure actors */\n  int arg0;\n  int arg1;\n  int arg2;\n  int arg3;\n\n  /* general purpose float members with unique usage between structure actors*/\n  f32 arg0_f;\n  f32 arg1_f;\n  f32 arg2_f;\n  f32 arg3_f;\n\n  u32 season;\n};\n\nextern ACTOR* Actor_info_fgName_search(Actor_info* actor_info, mActor_name_t fgName, int part);\n\ntypedef struct ac_shrine_s SHRINE_ACTOR;\n\ntypedef void (*aSHR_ANIME_PLAY_PROC)();\n\ntypedef struct ac_shrine_clip_s {\n  aSHR_ANIME_PLAY_PROC anime_play_proc;\n  int play_flag;\n  int hem_flag;\n} aSHR_Clip_c;\n\n#define aSHR_GET_CLIP() ((aSHR_Clip_c*)(Common_Get(clip).shrine_clip))\n#define aSHR_SET_CLIP(v) (Common_Get(clip).shrine_clip = (v))\n\ntypedef struct ac_shrine_present_s aSHR_Present_c;\ntypedef void (*aSHR_Present_PROC)(aSHR_Present_c*);\n\nstruct ac_shrine_present_s {\n  xyz_t trans;\n  f32 percent;\n  int finish_flag;\n  aSHR_Present_PROC move_proc;\n};\n\nstruct ac_shrine_s {\n  STRUCTURE_ACTOR structure_class;\n};\n\nenum {\n  aCR_ACTION_WAIT,\n  aCR_ACTION_SLEEP_WAIT,\n  aCR_ACTION_SLEEP,\n\n  aCR_ACTION_NUM\n};\n\nenum {\n  aCR_TALK_END_WAIT,\n  aCR_TALK_AFTER_TALK_START_WAIT,\n  aCR_TALK_CHK_REQUEST,\n  aCR_TALK_CHK_DECIDE_TO_DONATE,\n  aCR_TALK_CHK_DECIDE_TO_DONATE2,\n  aCR_TALK_MENU_OPEN_WAIT,\n  aCR_TALK_MSG_WIN_CLOSE_WAIT,\n  aCR_TALK_MENU_CLOSE_WAIT,\n  aCR_TALK_GET_DEMO_START_WAIT,\n  aCR_TALK_GET_DEMO_END_WAIT,\n  aCR_TALK_MSG_WIN_OPEN_WAIT,\n  aCR_TALK_RETURN_DEMO_START_WAIT,\n  aCR_TALK_RETURN_DEMO_START_WAIT2,\n  aCR_TALK_RETURN_DEMO_END_WAIT,\n  aCR_TALK_RETURN_DEMO_END_WAIT2,\n  aCR_TALK_CHK_CONTINUE_TO_DONATE,\n  aCR_TALK_CHK_CONTINUE_TO_DONATE2,\n  aCR_TALK_CHK_CONTINUE_TO_DONATE3,\n  aCR_TALK_PUTAWAY_DEMO_START_WAIT,\n  aCR_TALK_PUTAWAY_DEMO_START_WAIT2,\n  aCR_TALK_PUTAWAY_DEMO_START_WAIT3,\n  aCR_TALK_PUTAWAY_DEMO_START_WAIT4,\n  aCR_TALK_PUTAWAY_DEMO_START_WAIT5,\n  aCR_TALK_PUTAWAY_DEMO_START_WAIT6,\n  aCR_TALK_PUTAWAY_DEMO_START_WAIT5_2,\n  aCR_TALK_PUTAWAY_DEMO_END_WAIT,\n  aCR_TALK_PUTAWAY_DEMO_END_WAIT2,\n  aCR_TALK_PUTAWAY_DEMO_END_WAIT3,\n  aCR_TALK_PUTAWAY_DEMO_END_WAIT4,\n  aCR_TALK_PUTAWAY_DEMO_END_WAIT5,\n  aCR_TALK_PUTAWAY_DEMO_END_WAIT6,\n  aCR_TALK_AFTER_EXPLAIN_INSECT,\n  aCR_TALK_THANKS_FOSSIL_MSG_END_WAIT,\n  aCR_TALK_CHK_ALL_COMPLETE,\n\n  aCR_TALK_NUM\n};\n\n#define aCR_SLEEP_WAIT_TIMER  (6 * 60) // 6 seconds (calculated in frames frames)\n#define aCR_SLEEP_TIME_START  ( 6 * mTM_SECONDS_IN_HOUR)\n#define aCR_SLEEP_TIME_END    (18 * mTM_SECONDS_IN_HOUR)\n\ntypedef struct npc_curator_actor_s NPC_CURATOR_ACTOR;\n\ntypedef void (*aCR_SETUPTALKACTION_PROC)(NPC_CURATOR_ACTOR*, GAME_PLAY*, int);\ntypedef void (*aCR_ACTION_PROC)(NPC_ACTOR*, GAME_PLAY*);\ntypedef void (*aCR_ACT_PROC)(NPC_CURATOR_ACTOR*, GAME_PLAY*);\ntypedef void (*aCR_TALK_ACT_PROC)(NPC_CURATOR_ACTOR*, GAME_PLAY*);\n\nstruct npc_curator_actor_s {\n  NPC_ACTOR npc_class;\n  int action;\n  aCR_ACT_PROC action_proc;\n  int sleep_wait_timer;\n  int talk_act_idx;\n  aCR_TALK_ACT_PROC talk_proc;\n  aCR_SETUPTALKACTION_PROC setupTalkAction_proc;\n  int msg_no;\n  int _9B0; // might be unused 'awake' state\n  mActor_name_t donated_item;\n};\n\n#define FTR_IDX_2_NO(f) (((int)(f)) >> 2)\n\ntypedef struct _GXColor {\n  u8 r;\n  u8 g;\n  u8 b;\n  u8 a;\n} GXColor;\n\ntypedef struct _GXTexObj {\n  u32 dummy[8];\n} GXTexObj;\n\ntypedef struct _GXTlutObj {\n  u32 dummy[3];\n} GXTlutObj;\n\ntypedef enum _GXProjectionType {\n  GX_PERSPECTIVE,\n  GX_ORTHOGRAPHIC,\n} GXProjectionType;\n\ntypedef float Mtx44[4][4];\n\ntypedef struct {\n  f32 x;\n  f32 y;\n  f32 z;\n} Vec;\n\n#define mMsg_STATUS_FLAG_ZOOMDOWN_LONG (1 << 11) /* When set, mMsg_sound_ZOOMDOWN_SHORT() sfx will not play */\n#define mMsg_STATUS_FLAG_USE_AM (1 << 17) /* 'AM' when set, 'PM' when not set */\n\nextern int mMsg_CopyPlayerName(u8* data, int idx, int max_size, int capitalize);\nextern int mMsg_CopyTalkName(ACTOR* actor, u8* data, int idx, int max_size, int capitalize);\nextern int mMsg_CopyTail(ACTOR* actor, u8* data, int idx, int max_size, int capitalize);\nextern int mMsg_CopyYear(u8* data, int idx, int max_size);\nextern int mMsg_CopyMonth(u8* data, int idx, int max_size);\nextern int mMsg_CopyWeek(u8* data, int idx, int max_size);\nextern int mMsg_CopyDay(u8* data, int idx, int max_size);\nextern int mMsg_CopyHour(u8* data, int idx, int max_size);\nextern int mMsg_CopyMin(u8* data, int idx, int max_size);\nextern int mMsg_CopySec(u8* data, int idx, int max_size);\nextern int mMsg_CopyFree(mMsg_Window_c* msg_win, int free_idx, u8* data, int idx, int max_size, int article, int capitalize);\nextern int mMsg_CopyDetermination(mMsg_Window_c* msg_win, u8* data, int idx, int max_size);\nextern int mMsg_CopyCountryName(u8* data, int idx, int max_size, int capitalize);\nextern int mMsg_CopyRandomNumber2(u8* data, int idx, int max_size);\nextern int mMsg_CopyItem(mMsg_Window_c* msg_win, int item_idx, u8* data, int idx, int max_size, int article, int capitalize);\nextern int mMsg_CopyMail(mMsg_Window_c* msg_win, int mail_idx, u8* data, int idx, int max_size);\nextern int mMsg_CopyIslandName(u8* data, int idx, int max_size, int capitalize);\nextern int mMsg_CopyAmPm(mMsg_Window_c* msg_win, u8* data, int idx, int max_size);\n\nenum {\n  mFont_CONT_CODE_BEGIN = 0,\n  mFont_CONT_CODE_LAST = mFont_CONT_CODE_BEGIN,\n  mFont_CONT_CODE_CONINTUE,\n  mFont_CONT_CODE_CLEAR,\n  mFont_CONT_CODE_CURSOR_SET_TIME,\n  mFont_CONT_CODE_BUTTON,\n  mFont_CONT_CODE_COLOR,\n  mFont_CONT_CODE_ABLE_CANCEL,\n  mFont_CONT_CODE_UNABLE_CANCEL,\n  mFont_CONT_CODE_SET_DEMO_ORDER_PLAYER,\n  mFont_CONT_CODE_SET_DEMO_ORDER_NPC0,\n  mFont_CONT_CODE_SET_DEMO_ORDER_NPC1,\n  mFont_CONT_CODE_SET_DEMO_ORDER_NPC2,\n  mFont_CONT_CODE_SET_DEMO_ORDER_QUEST,\n  mFont_CONT_CODE_SET_SELECT_WINDOW,\n  mFont_CONT_CODE_SET_NEXT_MESSAGE_F,\n  mFont_CONT_CODE_SET_NEXT_MESSAGE_0,\n  mFont_CONT_CODE_SET_NEXT_MESSAGE_1,\n  mFont_CONT_CODE_SET_NEXT_MESSAGE_2,\n  mFont_CONT_CODE_SET_NEXT_MESSAGE_3,\n  mFont_CONT_CODE_SET_NEXT_MESSAGE_RANDOM_2,\n  mFont_CONT_CODE_SET_NEXT_MESSAGE_RANDOM_3,\n  mFont_CONT_CODE_SET_NEXT_MESSAGE_RANDOM_4,\n  mFont_CONT_CODE_SET_SELECT_STRING_2,\n  mFont_CONT_CODE_SET_SELECT_STRING_3,\n  mFont_CONT_CODE_SET_SELECT_STRING_4,\n  mFont_CONT_CODE_SET_FORCE_NEXT,\n  mFont_CONT_CODE_PUT_STRING_PLAYER_NAME,\n  mFont_CONT_CODE_PUT_STRING_TALK_NAME,\n  mFont_CONT_CODE_PUT_STRING_TAIL,\n  mFont_CONT_CODE_PUT_STRING_YEAR,\n  mFont_CONT_CODE_PUT_STRING_MONTH,\n  mFont_CONT_CODE_PUT_STRING_WEEK,\n  mFont_CONT_CODE_PUT_STRING_DAY,\n  mFont_CONT_CODE_PUT_STRING_HOUR,\n  mFont_CONT_CODE_PUT_STRING_MIN,\n  mFont_CONT_CODE_PUT_STRING_SEC,\n  mFont_CONT_CODE_PUT_STRING_FREE0,\n  mFont_CONT_CODE_PUT_STRING_FREE1,\n  mFont_CONT_CODE_PUT_STRING_FREE2,\n  mFont_CONT_CODE_PUT_STRING_FREE3,\n  mFont_CONT_CODE_PUT_STRING_FREE4,\n  mFont_CONT_CODE_PUT_STRING_FREE5,\n  mFont_CONT_CODE_PUT_STRING_FREE6,\n  mFont_CONT_CODE_PUT_STRING_FREE7,\n  mFont_CONT_CODE_PUT_STRING_FREE8,\n  mFont_CONT_CODE_PUT_STRING_FREE9,\n  mFont_CONT_CODE_PUT_STRING_DETERMINATION,\n  mFont_CONT_CODE_PUT_STRING_COUNTRY_NAME,\n  mFont_CONT_CODE_PUT_STRING_RANDOM_NUMBER_2,\n  mFont_CONT_CODE_PUT_STRING_ITEM0,\n  mFont_CONT_CODE_PUT_STRING_ITEM1,\n  mFont_CONT_CODE_PUT_STRING_ITEM2,\n  mFont_CONT_CODE_PUT_STRING_ITEM3,\n  mFont_CONT_CODE_PUT_STRING_ITEM4,\n  mFont_CONT_CODE_PUT_STRING_FREE10,\n  mFont_CONT_CODE_PUT_STRING_FREE11,\n  mFont_CONT_CODE_PUT_STRING_FREE12,\n  mFont_CONT_CODE_PUT_STRING_FREE13,\n  mFont_CONT_CODE_PUT_STRING_FREE14,\n  mFont_CONT_CODE_PUT_STRING_FREE15,\n  mFont_CONT_CODE_PUT_STRING_FREE16,\n  mFont_CONT_CODE_PUT_STRING_FREE17,\n  mFont_CONT_CODE_PUT_STRING_FREE18,\n  mFont_CONT_CODE_PUT_STRING_FREE19,\n  mFont_CONT_CODE_PUT_STRING_MAIL,\n  mFont_CONT_CODE_SET_PLAYER_DESTINY0,\n  mFont_CONT_CODE_SET_PLAYER_DESTINY1,\n  mFont_CONT_CODE_SET_PLAYER_DESTINY2,\n  mFont_CONT_CODE_SET_PLAYER_DESTINY3,\n  mFont_CONT_CODE_SET_PLAYER_DESTINY4,\n  mFont_CONT_CODE_SET_PLAYER_DESTINY5,\n  mFont_CONT_CODE_SET_PLAYER_DESTINY6,\n  mFont_CONT_CODE_SET_PLAYER_DESTINY7,\n  mFont_CONT_CODE_SET_PLAYER_DESTINY8,\n  mFont_CONT_CODE_SET_PLAYER_DESTINY9,\n  mFont_CONT_CODE_SET_MESSAGE_CONTENTS_NORMAL,\n  mFont_CONT_CODE_SET_MESSAGE_CONTENTS_ANGRY,\n  mFont_CONT_CODE_SET_MESSAGE_CONTENTS_SAD,\n  mFont_CONT_CODE_SET_MESSAGE_CONTENTS_FUN,\n  mFont_CONT_CODE_SET_MESSAGE_CONTENTS_SLEEPY,\n  mFont_CONT_CODE_SET_COLOR_CHAR,\n  mFont_CONT_CODE_SOUND_CUT,\n  mFont_CONT_CODE_SET_LINE_OFFSET,\n  mFont_CONT_CODE_SET_LINE_TYPE,\n  mFont_CONT_CODE_SET_CHAR_SCALE,\n  mFont_CONT_CODE_BUTTON2,\n  mFont_CONT_CODE_BGM_MAKE,\n  mFont_CONT_CODE_BGM_DELETE,\n  mFont_CONT_CODE_MSG_TIME_END,\n  mFont_CONT_CODE_SOUND_TRG_SYS,\n  mFont_CONT_CODE_SET_LINE_SCALE,\n  mFont_CONT_CODE_SOUND_NO_PAGE,\n  mFont_CONT_CODE_VOICE_TRUE,\n  mFont_CONT_CODE_VOICE_FALSE,\n  mFont_CONT_CODE_SELECT_NO_B,\n  mFont_CONT_CODE_GIVE_OPEN,\n  mFont_CONT_CODE_GIVE_CLOSE,\n  mFont_CONT_CODE_SET_MESSAGE_CONTENTS_GLOOMY,\n  mFont_CONT_CODE_SELECT_NO_B_CLOSE,\n  mFont_CONT_CODE_SET_NEXT_MESSAGE_RANDOM_SECTION,\n  mFont_CONT_CODE_AGB_DUMMY0,\n  mFont_CONT_CODE_AGB_DUMMY1,\n  mFont_CONT_CODE_AGB_DUMMY2,\n  mFont_CONT_CODE_SPACE,\n  mFont_CONT_CODE_AGB_DUMMY3,\n  mFont_CONT_CODE_AGB_DUMMY4,\n  mFont_CONT_CODE_AGB_MALE_FEMALE_CHECK,\n  mFont_CONT_CODE_AGB_DUMMY5,\n  mFont_CONT_CODE_AGB_DUMMY6,\n  mFont_CONT_CODE_AGB_DUMMY7,\n  mFont_CONT_CODE_AGB_DUMMY8,\n  mFont_CONT_CODE_AGB_DUMMY9,\n  mFont_CONT_CODE_AGB_DUMMY10,\n  mFont_CONT_CODE_PUT_STRING_ISLAND_NAME,\n  mFont_CONT_CODE_SET_CURSOR_JUST,\n  mFont_CONT_CODE_CLR_CURSOR_JUST,\n  mFont_CONT_CODE_CUT_ARTICLE,\n  mFont_CONT_CODE_CAPITAL_LETTER,\n  mFont_CONT_CODE_PUT_STRING_AM_PM,\n  mFont_CONT_CODE_SET_NEXT_MESSAGE_4,\n  mFont_CONT_CODE_SET_NEXT_MESSAGE_5,\n  mFont_CONT_CODE_SET_SELECT_STRING_5,\n  mFont_CONT_CODE_SET_SELECT_STRING_6,\n\n  mFont_CONT_CODE_NUM,\n  mFont_CONT_CODE_END = 256\n};\n\nenum item_article {\n  mIN_ARTICLE_NONE,\n  mIN_ARTICLE_A,\n  mIN_ARTICLE_AN,\n  mIN_ARTICLE_THE,\n  mIN_ARTICLE_SOME,\n\n  mIN_ARTICLE_NUM\n};\n\n#define mChoice_SELECT_STR_NUM 607\nextern f32 mFont_SetMarkChar(GAME* game, u8 mark_type, f32 x, f32 y, int r, int g, int b, int a, int revert_flag, f32 scale_x, f32 scale_y, int mode);\n\nenum {\n  mEv_SAVE_DATE_TODAY,\n  mEv_SAVE_DATE_LAST_PLAY_DATE,\n  mEv_SAVE_DATE_BIRTHDAY,\n  mEv_SAVE_DATE_SPECIAL0, /* Initialized to rtc month-day in init_special_event */\n  mEv_SAVE_DATE_SPECIAL1, /* Initialized to beginning month-day of special event in init_special_event */\n  mEv_SAVE_DATE_SPECIAL2, /* Initialized to ending month-day of special event in init_special_event */\n  mEv_SAVE_DATE_WEEKLY,\n  mEv_SAVE_DATE_SPECIAL3, /* Initialized to opening hours for shop sale in init_special_event */\n\n  mEv_SAVE_DATE_NUM\n};\n\nstatic u16 after_n_day(u16 month_day, int n_day);\nstatic int check_date_range(u16 date, u16 lower_bound, u16 upper_bound);", "diff_flags": [], "diff_label": "init_weekly_event", "libraries": []}