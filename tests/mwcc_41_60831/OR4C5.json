{"compiler": "mwcc_41_60831", "compiler_flags": "-enc SJIS -lang c -W all -fp fmadd -Cpp_exceptions off -O4 -sym dwarf-2 -ipa file -d DECOMP -d SPM_EU0 -inline all -sdata 8 -sdata2 8", "source_code": "void dummy();\nvoid dummy() {\n    __dummy_str(\" in \\\"%s\\\" on line %d.\\n\");\n    __dummy_str(\"\\nAddress:      Back Chain    LR Save\\n\");\n    __dummy_str(\"0x%08x:   0x%08x    0x%08x\\n\");\n}\n\nvoid __OSUnhandledException(u8 exception, OSContext * context, u32 dsisr, u32 dar)\n{\n\tOSTime time;\n\n\ttime = OSGetTime();\n\n\tif ((context->srr1 & 2) == 0)\n\t{\n\t\tOSReport(\"Non-recoverable Exception %d\", exception);\n\t}\n\telse\n\t{\n\t\tif (exception == OS_ERROR_PROGRAM && (context->srr1 & 0x100000) != 0 &&\n\t\t    __OSErrorTable[OS_ERROR_FP_EXCEPTION] != 0)\n\t\t{\n\t\t\tu32 fpscr;\n\t\t\tu32 msr;\n\n\t\t\texception = OS_ERROR_FP_EXCEPTION;\n\n\t\t\tmsr = PPCMfmsr();\n\t\t\tPPCMtmsr(msr | MSR_FP);\n\n\t\t\tif (OS_CURRENT_FPU_CONTEXT)\n\t\t\t\tOSSaveFPUContext((OSContext *) OS_CURRENT_FPU_CONTEXT);\n\n\t\t\tfpscr = PPCMffpscr();\n\t\t\tfpscr &= ~(FPSCR_VXVC | FPSCR_VXIMZ | FPSCR_VXZDZ | FPSCR_VXIDI | FPSCR_VXISI |\n\t\t\t           FPSCR_VXSNAN | FPSCR_VXSOFT | FPSCR_VXSQRT | FPSCR_VXCVI | FPSCR_XX |\n\t\t\t\t\t   FPSCR_ZX | FPSCR_UX | FPSCR_OX | FPSCR_FX | FPSCR_FI);\n\t\t\tPPCMtfpscr(fpscr);\n\n\t\t\tPPCMtmsr(msr);\n\n\t\t\tif (OS_CURRENT_FPU_CONTEXT == context)\n\t\t\t{\n\t\t\t\tOSDisableScheduler();\n\n\t\t\t\t__OSErrorTable[exception](exception, context, dsisr, dar);\n\t\t\t\tcontext->srr1 &= ~0x2000;\n\t\t\t\tOS_CURRENT_FPU_CONTEXT = NULL;\n\t\t\t\tcontext->fpscr &= ~(FPSCR_VXVC | FPSCR_VXIMZ | FPSCR_VXZDZ | FPSCR_VXIDI |\n\t\t\t\t                    FPSCR_VXISI | FPSCR_VXSNAN | FPSCR_VXSOFT | FPSCR_VXSQRT |\n\t\t\t\t\t\t\t\t\tFPSCR_VXCVI | FPSCR_XX | FPSCR_ZX | FPSCR_UX | FPSCR_OX |\n\t\t\t\t\t\t\t\t\tFPSCR_FX | FPSCR_FI);\n\n\t\t\t\tOSEnableScheduler();\n\t\t\t\t__OSReschedule();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcontext->srr1 &= ~0x2000;\n\t\t\t\tOS_CURRENT_FPU_CONTEXT = NULL;\n\t\t\t}\n\n\t\t\tOSLoadContext(context);\n\t\t}\n\n\t\tif (__OSErrorTable[exception])\n\t\t{\n\t\t\tOSDisableScheduler();\n\n\t\t\t__OSErrorTable[exception](exception, context, dsisr, dar);\n\n\t\t\tOSEnableScheduler();\n\t\t\t__OSReschedule();\n\n\t\t\tOSLoadContext(context);\n\t\t}\n\n\t\tif (exception == OS_ERROR_DECREMENTER)\n\t\t\tOSLoadContext(context);\n\n\t\tOSReport(\"Unhandled Exception %d\", exception);\n\t}\n\n\tOSReport(\"\\n\");\n\tOSDumpContext(context);\n\n\tOSReport(\"\\nDSISR = 0x%08x                   DAR  = 0x%08x\\n\", dsisr, dar);\n\tOSReport(\"TB = 0x%016llx\\n\", time);\n\tswitch (exception)\n\t{\n\t\tcase OS_ERROR_DSI:\n\t\t\tOSReport(\"\\nInstruction at 0x%x (read from SRR0) attempted to access invalid address \"\n\t\t\t         \"0x%x (read from DAR)\\n\", context->srr0, dar);\n\t\t\tbreak;\n\t\tcase OS_ERROR_ISI:\n\t\t\tOSReport(\"\\nAttempted to fetch instruction from invalid address 0x%x (read from SRR0)\"\n\t\t\t\t\t \"\\n\", context->srr0);\n\t\t\tbreak;\n\t\tcase OS_ERROR_ALIGNMENT:\n\t\t\tOSReport(\"\\nInstruction at 0x%x (read from SRR0) attempted to access unaligned address\"\n\t\t\t         \" 0x%x (read from DAR)\\n\", context->srr0, dar);\n\t\t\tbreak;\n\t\tcase OS_ERROR_PROGRAM:\n\t\t\tOSReport(\"\\nProgram exception : Possible illegal instruction/operation at or around \"\n\t\t\t         \"0x%x (read from SRR0)\\n\", context->srr0, dar);\n\t\t\tbreak;\n\t\tcase OS_ERROR_PROTECTION:\n\t\t\tOSReport(\"\\n\");\n\t\t\tOSReport(\"AI DMA Address =   0x%04x%04x\\n\", DSP_HW_REGS[DSP_AI_DMA_START_H],\n\t\t\t         DSP_HW_REGS[DSP_AI_DMA_START_L]);\n\t\t\tOSReport(\"ARAM DMA Address = 0x%04x%04x\\n\", DSP_HW_REGS[DSP_AR_DMA_MMADDR_H],\n\t\t\t         DSP_HW_REGS[DSP_AR_DMA_MMADDR_L]);\n\t\t\tOSReport(\"DI DMA Address =   0x%08x\\n\", DI_HW_REGS[DI_DMA_MMADDR]);\n\t\t\tbreak;\n\t}\n\n\tOSReport(\"\\nLast interrupt (%d): SRR0 = 0x%08x  TB = 0x%016llx\\n\", __OSLastInterrupt,\n\t         __OSLastInterruptSrr0, __OSLastInterruptTime);\n\n\tPPCHalt();\n}\n", "context": "\n#ifdef __cplusplus\n    extern \"C\" {\n#endif\n\n// Unknown function declaration\n\n#define UNKNOWN_FUNCTION(name) void name(void)\n\n// Forward declares a function to allow it to be mangled, and adds extern \"C\"\n// to it to prevent any functions it references being mangled\n// Should be used for any C++ inline asm includes\n\n#ifdef __cplusplus\n    #define MANGLED_ASM(prototype) \\\n        prototype; \\\n        extern \"C\" asm prototype\n#endif\n\n// Data dummy helpers\n\nvoid __dummy_str(const char *);\nvoid __dummy_float(float);\nvoid __dummy_double(double);\nvoid __dummy_pointer(const void *);\n\n// Force a symbol to be stripped by elf2rel/elf2dol\n\n#pragma section RX \"forcestrip\"\n#ifndef __INTELLISENSE__ \n    #define FORCESTRIP __declspec(section \"forcestrip\")\n#else\n    #define FORCESTRIP\n#endif\n\n// Wrap in force_active pragmas to force a piece of data active\n#define DUMMY_POINTER(name) \\\n    void dummy_ptr_##name(); \\\n    void FORCESTRIP dummy_ptr_##name() \\\n    { \\\n        __dummy_pointer((const void *)&name); \\\n    }\n\n// Unfortunately these don't work on older compilers\n\n#define HAVE_PRAGMA_PUSH (__MWERKS__ >= 0x4199)\n\n#if HAVE_PRAGMA_PUSH\n\n// Disable deadstripping for a region\n\n#define FORCEACTIVE_START _Pragma(\"push\") \\\n                          _Pragma(\"force_active on\")\n#define FORCEACTIVE_END _Pragma(\"pop\")\n\n// Disable deadstripping for a bit of data\n\n#define FORCEACTIVE_DATA(name) \\\n    FORCEACTIVE_START \\\n    DUMMY_POINTER(name) \\\n    FORCEACTIVE_END\n\n#define HAVE_FORCEACTIVE 1\n\n#else\n\n#define HAVE_FORCEACTIVE 0\n\n#endif\n\n// Rel symbol definition\n\n#pragma section RW \"relsymdef\"\n\ntypedef struct\n{\n    unsigned long addr;\n    const void * ref;\n} __RelSymbolDef;\n\n#if HAVE_FORCEACTIVE\n\n#define REL_SYMBOL_AT(name, addr) \\\n    __declspec(section \"relsymdef\") __RelSymbolDef rel_sym_##name = \\\n    {addr, (const void *)&name}; \\\n    FORCEACTIVE_DATA(rel_sym_##name)\n\n#else\n\n// May need manual forceactive pragmas if stripping is enabled on the rel\n#define REL_SYMBOL_AT(name, addr) \\\n    __declspec(section \"relsymdef\") __RelSymbolDef rel_sym_##name = \\\n    {addr, (const void *)&name};\n\n#endif\n\n// BSS ordering hack\n\n#define ORDER_BSS_DATA static asm void order_bss()\n#define ORDER_BSS(s) lis r3, s@ha\n\n// Dummy signatures for functions used in inline asm\n\n#define qr0 0\n\n#define cr0lt 0\n#define cr0gt 1\n#define cr0eq 2\n#define cr0un 3\n#define cr1lt 4\n#define cr1gt 5\n#define cr1eq 6\n#define cr1un 7\n#define cr2lt 8\n#define cr2gt 9\n#define cr2eq 10\n#define cr2un 11\n#define cr3lt 12\n#define cr3gt 13\n#define cr3eq 14\n#define cr3un 15\n#define cr4lt 16\n#define cr4gt 17\n#define cr4eq 18\n#define cr4un 19\n#define cr5lt 20\n#define cr5gt 21\n#define cr5eq 22\n#define cr5un 23\n#define cr6lt 24\n#define cr6gt 25\n#define cr6eq 26\n#define cr6un 27\n#define cr7lt 28\n#define cr7gt 29\n#define cr7eq 30\n#define cr7un 31\n\nvoid _savegpr_14(void);\nvoid _savegpr_15(void);\nvoid _savegpr_16(void);\nvoid _savegpr_17(void);\nvoid _savegpr_18(void);\nvoid _savegpr_19(void);\nvoid _savegpr_20(void);\nvoid _savegpr_21(void);\nvoid _savegpr_22(void);\nvoid _savegpr_23(void);\nvoid _savegpr_24(void);\nvoid _savegpr_25(void);\nvoid _savegpr_26(void);\nvoid _savegpr_27(void);\nvoid _savegpr_28(void);\nvoid _savegpr_29(void);\nvoid _savegpr_30(void);\nvoid _savegpr_31(void);\n\nvoid _restgpr_14(void);\nvoid _restgpr_15(void);\nvoid _restgpr_16(void);\nvoid _restgpr_17(void);\nvoid _restgpr_18(void);\nvoid _restgpr_19(void);\nvoid _restgpr_20(void);\nvoid _restgpr_21(void);\nvoid _restgpr_22(void);\nvoid _restgpr_23(void);\nvoid _restgpr_24(void);\nvoid _restgpr_25(void);\nvoid _restgpr_26(void);\nvoid _restgpr_27(void);\nvoid _restgpr_28(void);\nvoid _restgpr_29(void);\nvoid _restgpr_30(void);\nvoid _restgpr_31(void);\n\nvoid _savefpr_14(void);\nvoid _savefpr_15(void);\nvoid _savefpr_16(void);\nvoid _savefpr_17(void);\nvoid _savefpr_18(void);\nvoid _savefpr_19(void);\nvoid _savefpr_20(void);\nvoid _savefpr_21(void);\nvoid _savefpr_22(void);\nvoid _savefpr_23(void);\nvoid _savefpr_24(void);\nvoid _savefpr_25(void);\nvoid _savefpr_26(void);\nvoid _savefpr_27(void);\nvoid _savefpr_28(void);\nvoid _savefpr_29(void);\nvoid _savefpr_30(void);\nvoid _savefpr_31(void);\n\nvoid _restfpr_14(void);\nvoid _restfpr_15(void);\nvoid _restfpr_16(void);\nvoid _restfpr_17(void);\nvoid _restfpr_18(void);\nvoid _restfpr_19(void);\nvoid _restfpr_20(void);\nvoid _restfpr_21(void);\nvoid _restfpr_22(void);\nvoid _restfpr_23(void);\nvoid _restfpr_24(void);\nvoid _restfpr_25(void);\nvoid _restfpr_26(void);\nvoid _restfpr_27(void);\nvoid _restfpr_28(void);\nvoid _restfpr_29(void);\nvoid _restfpr_30(void);\nvoid _restfpr_31(void);\n\nvoid __div2u(void);\nvoid __div2i(void);\nvoid __mod2u(void);\nvoid __mod2i(void);\nvoid __shl2i(void);\n\nvoid __cvt_sll_flt(void);\nvoid __cvt_ull_flt(void);\nvoid __cvt_dbl_usll(void);\nvoid __cvt_dbl_ull(void);\nvoid __cvt_fp2unsigned(void);\n\nvoid __unexpected(void);\n\n#ifdef __cplusplus\n    }\n#endif\n\n\n#if (defined DECOMP) && !(defined SKIP_PPCDIS)\n// Decomp should include ppcdis.h in all files\n#else\n// Unknown function is useful outside of decomp too\n#define UNKNOWN_FUNCTION(name) void name(void)\n#endif\n\n// Intellisense doesn't like asm compiler extensions\n#ifdef __INTELLISENSE__ \n    #define asm\n#endif\n\n// Helpers for compiler feature checking\n#ifdef __has_builtin\n    #define HAS_BUILTIN(x) __has_builtin(x)\n#else\n    #define HAS_BUILTIN(x) 0\n#endif\n#ifdef __has_attribute\n    #define HAS_ATTRIBUTE(x) __has_attribute(x)\n#else\n    #define HAS_ATTRIBUTE(x) 0\n#endif\n\n// Basic types\n\n// Decomp needs long for matching, int is slightly more convenient for casting in mods\n#ifdef DECOMP\n    #define INT_TYPE long\n#else\n    #define INT_TYPE int\n#endif\n\ntypedef unsigned long long u64;\ntypedef unsigned INT_TYPE u32;\ntypedef unsigned short u16;\ntypedef unsigned char u8;\n\ntypedef signed long long s64;\ntypedef signed INT_TYPE s32;\ntypedef signed short s16;\ntypedef signed char s8;\n\n#undef INT_TYPE\n\ntypedef float f32;\ntypedef double f64;\n\n#ifdef USE_STL\n    #include <cstddef>\n    static_assert(sizeof(size_t) == 4, \"Expected 32-bit size_t\");\n#else\n    typedef u32 size_t;\n    #define NULL 0\n    #if HAS_BUILTIN(__builtin_offsetof)\n        #define offsetof __builtin_offsetof\n    #else\n        #define offsetof(type, member) ((u32)&((type *)0)->member)\n    #endif\n#endif\n\ntypedef s32 BOOL;\n\n#ifndef __cplusplus\n    #define bool char\n\n    #define true 1\n    #define false 0\n#endif\n\n#ifndef __cplusplus\n    #define wchar_t s16\n#endif\n\n#ifdef DECOMP\n    typedef wchar_t wchar16_t;\n#else\n    typedef s16 wchar16_t;\n#endif\n\n// Unknown type\ntypedef u32 Unk;\ntypedef u32 Unk32;\ntypedef u16 Unk16;\ntypedef u8 unk8;\n\n// Use CW special static assert\n#ifdef __MWERKS__\n    #define static_assert(cond, msg) __static_assert(cond, msg) \n#endif\n\n// Macro for quick size static assert\n#ifndef M2C\n    #define SIZE_ASSERT(type, size) static_assert(sizeof(type) == size, \"Size wrong for \"#type);\n    #define OFFSET_ASSERT(type, member, offset) \\\n        static_assert(offsetof(type, member) == offset, \"Offset wrong for \"#member\" in \"#type);\n#else\n    // Pycparser workaround\n    #define SIZE_ASSERT(type, size)\n    #define OFFSET_ASSERT(type, member, offset)\n#endif\n\n// Macro for something that should only be exposed outside of decomp\n#ifdef DECOMP\n    #define DECOMP_STATIC(expr)\n#else\n    #define DECOMP_STATIC(expr) extern expr;\n#endif\n\n// Use extern \"C\" in C++, use namespacing in mods\n#ifdef __cplusplus\n    #ifndef DECOMP\n        #define CPP_WRAPPER(ns) \\\n            namespace ns { \\\n            extern \"C\" {\n        #define CPP_WRAPPER_END() }}\n    #else\n        #define CPP_WRAPPER(ns) \\\n            extern \"C\" {\n        #define CPP_WRAPPER_END() }\n    #endif\n#else\n    #define CPP_WRAPPER(ns)\n    #define CPP_WRAPPER_END()\n#endif\n\n// Macro for potential using statements\n// Should go inside a CPP_WRAPPER\n#if (defined __cplusplus) && !(defined DECOMP)\n    #define USING(name) using name;\n#else\n    #define USING(name)\n#endif\n\n// For GCC these have to be defined in the linker script\n#if (defined __MWERKS__) && !(defined M2C) && !(defined __INTELLISENSE__)\n    #define FIXED_ADDR(type, name, addr) \\\n        type name : addr\n#else\n    #define FIXED_ADDR(type, name, addr) \\\n        extern type name\n#endif\n\n#if !(defined __INTELLISENSE__) && !(defined M2C)\n    #define ATTRIBUTE(x) __attribute__((x))\n#else\n    #define ATTRIBUTE(x)\n#endif\n\n#if HAS_ATTRIBUTE(noreturn)\n    #define NORETURN ATTRIBUTE(noreturn)\n#else\n    #define NORETURN\n#endif\n\n#define ALIGNED(x) ATTRIBUTE(aligned(x))\n\n#if HAS_ATTRIBUTE(format)\n    #define ATTRIBUTE_FORMAT(...) __attribute__((format(__VA_ARGS__)))\n#else\n    #define ATTRIBUTE_FORMAT(...)\n#endif\n\n#define SQUARE(x) ((x) * (x))\n#define CUBE(x) ((x) * (x) * (x))\n#define QUART(x) ((x) * (x) * (x) * (x))\n/*\n    Functions to manage execution of the game's evt bytecode scripts\n*/\n\n\n\n\n\n\nCPP_WRAPPER(wii::os)\n\nvoid * OSGetMEM1ArenaHi();\nvoid * OSGetMEM2ArenaHi();\nvoid * OSGetArenaHi();\nvoid * OSGetMEM1ArenaLo();\nvoid * OSGetMEM2ArenaLo();\nvoid * OSGetArenaLo();\nvoid OSSetMEM1ArenaHi(void * arenaHi);\nvoid OSSetMEM2ArenaHi(void * arenaHi);\nvoid OSSetArenaHi(void * arenaHi);\nvoid OSSetMEM1ArenaLo(void * arenaLo);\nvoid OSSetMEM2ArenaLo(void * arenaLo);\nvoid OSSetArenaLo(void * arenaLo);\nUNKNOWN_FUNCTION(OSAllocFromMEM1ArenaLo);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::os)\n\nUNKNOWN_FUNCTION(DCEnable);\nUNKNOWN_FUNCTION(DCInvalidateRange);\nvoid * DCFlushRange(void * ptr, size_t length);\nUNKNOWN_FUNCTION(DCFlushRangeNoSync);\nUNKNOWN_FUNCTION(DCZeroRange);\nvoid ICInvalidateRange(void * ptr, u32 size);\nUNKNOWN_FUNCTION(ICFlashInvalidate);\nUNKNOWN_FUNCTION(ICEnable);\nUNKNOWN_FUNCTION(LCDisable);\nUNKNOWN_FUNCTION(DMAErrorHandler);\nUNKNOWN_FUNCTION(__OSCacheInit);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::os)\n\ntypedef struct\n{\n/* 0x000 */ u32 gpr[32];\n/* 0x080 */ u32 cr;\n/* 0x084 */ u32 lr;\n/* 0x088 */ u32 ctr;\n/* 0x08C */ u32 xer;\n/* 0x090 */ f64 fpr[32];\n/* 0x190 */ u8 unknown_0x190[0x194 - 0x190];\n/* 0x194 */ u32 fpscr;\n/* 0x198 */ u32 srr0;\n/* 0x19C */ u32 srr1;\n/* 0x1A0 */ u16 mode;\n/* 0x1A2 */ u16 state;\n/* 0x1A4 */ u32 gqr[8];\n/* 0x1C0 */ u8 unknown_0x1c4[0x1c8 - 0x1c4];\n/* 0x1C8 */ f64 psf[32];\n} OSContext;\nSIZE_ASSERT(OSContext, 0x2c8)\n\nvoid __OSLoadFPUContext(u32, OSContext *);\nvoid __OSSaveFPUContext(u32, u32, OSContext *);\nvoid OSSaveFPUContext(OSContext * context);\n\nvoid OSSetCurrentContext(OSContext * context);\nOSContext * OSGetCurrentContext();\n\nu32 OSSaveContext(OSContext * context);\nu32 OSLoadContext(OSContext * context);\n\nu32 OSGetStackPointer();\n\ns32 OSSwitchFiber(u32 pc, u32 r1);\ns32 OSSwitchFiberEx(u32, u32, u32, u32, u32 pc, u32 r1);\n\nvoid OSClearContext(OSContext * context);\nvoid OSInitContext(OSContext * context, u32 pc, u32 r1);\nvoid OSDumpContext(OSContext * context);\n\nUNKNOWN_FUNCTION(OSSwitchFPUContext);\nvoid __OSContextInit();\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::os)\n\nUSING(wii::os::OSContext)\n\n#define OS_ERROR_SYSTEM_RESET 0\n#define OS_ERROR_MACHINE_CHECK 1\n#define OS_ERROR_DSI 2\n#define OS_ERROR_ISI 3\n#define OS_ERROR_EXT_INTERRUPT 4\n#define OS_ERROR_ALIGNMENT 5\n#define OS_ERROR_PROGRAM 6\n#define OS_ERROR_FP_UNAVAIL 7\n#define OS_ERROR_DECREMENTER 8\n#define OS_ERROR_SYSTEM_CALL 9\n#define OS_ERROR_TRACE 10\n#define OS_ERROR_PERF_MONITOR 11\n#define OS_ERROR_IABR 12\n#define OS_ERROR_SMI 13\n#define OS_ERROR_THERMAL 14\n#define OS_ERROR_PROTECTION 15\n#define OS_ERROR_FP_EXCEPTION 16\n#define OS_ERROR_MAX 17\n\ntypedef void (*OSErrorHandler)(u16 error, OSContext* context, u32 dsisr, u32 dar, ...);\nextern OSErrorHandler __OSErrorTable[OS_ERROR_MAX];\n\nDECOMP_STATIC(char __OSUnhandledException_msg1[])\nDECOMP_STATIC(char __OSUnhandledException_msg2[])\nDECOMP_STATIC(char __OSUnhandledException_msg3[])\n\nATTRIBUTE_FORMAT(printf, 1, 2) void OSReport(const char * message, ...);\nUNKNOWN_FUNCTION(OSVReport);\n\n// Weak symbol, game overrides with its own\nATTRIBUTE_FORMAT(printf, 3, 4) void OSPanic(const char * filename, s32 line,\n                                            const char * msg, ...);\n\nUNKNOWN_FUNCTION(OSSetErrorHandler);\nvoid __OSUnhandledException(u8 exception, OSContext* context, u32 dsisr, u32 dar);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::os)\n\nUNKNOWN_FUNCTION(PackArgs);\nvoid Run(void * code);\nUNKNOWN_FUNCTION(__OSGetExecParams);\nUNKNOWN_FUNCTION(__OSLaunchNextFirmware);\nUNKNOWN_FUNCTION(__OSLaunchMenu);\nUNKNOWN_FUNCTION(__OSRelaunchTitle);\nUNKNOWN_FUNCTION(__OSBootDolSimple);\nUNKNOWN_FUNCTION(__OSBootDol);\nUNKNOWN_FUNCTION(_ES_GetTicketViews);\nUNKNOWN_FUNCTION(_ES_LaunchTitle);\n\nCPP_WRAPPER_END()\n\n/*\n    Revolution SDK GX Library\n*/\n\n\n/*\n    Revolution SDK MTX library\n*/\n\n\n\nCPP_WRAPPER(wii::mtx)\n\n#define DEG_TO_RAD(a) (a * 0.01745329238474369f)\n\ntypedef struct\n{\n    f32 x, y;\n} Vec2;\n\ntypedef struct\n{\n    s32 x, y;\n} Vec2i;\n\ntypedef struct\n{\n    f32 x, y, z;\n} Vec3;\n\ntypedef struct\n{\n    s32 x, y, z;\n} Vec3i;\n\ntypedef f32 Mtx34[3][4];\ntypedef f32 Mtx44[4][4];\n\nvoid PSMTXIdentity(Mtx34 * dest);\nUNKNOWN_FUNCTION(PSMTXCopy);\nUNKNOWN_FUNCTION(PSMTXConcat);\nUNKNOWN_FUNCTION(PSMTXInverse);\nUNKNOWN_FUNCTION(PSMTXInvXpose);\nUNKNOWN_FUNCTION(PSMTXRotRad);\nUNKNOWN_FUNCTION(PSMTXRotTrig);\nUNKNOWN_FUNCTION(__PSMTXRotAxisRadInternal);\nUNKNOWN_FUNCTION(PSMTXRotAxisRad);\nvoid PSMTXTrans(Mtx34 * dest, f32 x, f32 y, f32 z);\nvoid PSMTXTransApply(Mtx34 * src, Mtx34 * dest, f32 x, f32 y, f32 z);\nvoid PSMTXScale(Mtx34 * dest, f32 x, f32 y, f32 z);\nvoid PSMTXScaleApply(Mtx34 * src, Mtx34 * dest, f32 x, f32 y, f32 z);\nUNKNOWN_FUNCTION(PSMTXQuat);\nUNKNOWN_FUNCTION(C_MTXLookAt);\nUNKNOWN_FUNCTION(C_MTXLightFrustum);\nUNKNOWN_FUNCTION(C_MTXLightPerspective);\nUNKNOWN_FUNCTION(C_MTXLightOrtho);\nUNKNOWN_FUNCTION(PSMTXMultVec);\nUNKNOWN_FUNCTION(PSMTXMultVecArray);\nUNKNOWN_FUNCTION(PSMTXMultVecSR);\nUNKNOWN_FUNCTION(C_MTXFrustum);\nUNKNOWN_FUNCTION(C_MTXPerspective);\nvoid C_MTXOrtho(Mtx44 * dest, f32 top, f32 bottom, f32 left, f32 right, f32 near, f32 far);\nUNKNOWN_FUNCTION(PSMTX44Copy);\nUNKNOWN_FUNCTION(PSMTX44MultVec);\nUNKNOWN_FUNCTION(PSMTX44MultVecArray);\nUNKNOWN_FUNCTION(PSVECAdd);\nvoid PSVECSubtract(Vec3 * src1, Vec3 * src2, Vec3 * dest);\nvoid PSVECScale(Vec3 * src, Vec3 * dest, f32 scale);\nvoid PSVECNormalize(Vec3 * src, Vec3 * dest);\nf32 PSVecSquareMag(Vec3 * src);\nf32 PSVecMag(Vec3 * src);\nf32 PSVECDotProduct(Vec3 * src1, Vec3 * src2);\nvoid PSVECCrossProduct(Vec3 * src1, Vec3 * src2, Vec3 * dest);\nUNKNOWN_FUNCTION(VECHalfAngle);\nUNKNOWN_FUNCTION(VECReflect);\nUNKNOWN_FUNCTION(PSVECSquareDistance);\nUNKNOWN_FUNCTION(PSVECDistance);\nUNKNOWN_FUNCTION(QUATMtx);\nUNKNOWN_FUNCTION(QUATSlerp);\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(wii::gx)\n\nUSING(wii::mtx::Mtx34)\nUSING(wii::mtx::Mtx44)\n\ntypedef struct\n{\n    u8 r, g, b, a;\n} GXColor;\n\ntypedef struct\n{\n/* 0x0 */ u8 unknown_0x0[0x3c - 0x0];\n} GXRenderModeObj;\nSIZE_ASSERT(GXRenderModeObj, 0x3c)\n\ntypedef struct\n{\n/* 0x0 */ u8 unknown_0x0[0x20 - 0x0];\n} GXTexObj;\nSIZE_ASSERT(GXTexObj, 0x20)\n\n// Parameters from libogc's gx.h\n\nUNKNOWN_FUNCTION(__GXDefaultTexRegionCallback);\nUNKNOWN_FUNCTION(__GXDefaultTlutRegionCallback);\nUNKNOWN_FUNCTION(__GXShutdown);\nUNKNOWN_FUNCTION(__GXInitRevisionBits);\nUNKNOWN_FUNCTION(GXInit);\nUNKNOWN_FUNCTION(__GXInitGX);\nUNKNOWN_FUNCTION(GXCPInterruptHandler);\nUNKNOWN_FUNCTION(GXInitFifoBase);\nUNKNOWN_FUNCTION(CPGPLinkCheck);\nUNKNOWN_FUNCTION(GXSetCPUFifo);\nUNKNOWN_FUNCTION(GXSetGPFifo);\nUNKNOWN_FUNCTION(__GXSaveFifo);\nUNKNOWN_FUNCTION(__GXIsGPFifoReady);\nUNKNOWN_FUNCTION(GXGetCPUFifo);\nUNKNOWN_FUNCTION(GXGetFifoCount);\nUNKNOWN_FUNCTION(GXGetFifoWrap);\nUNKNOWN_FUNCTION(GXSetBreakPtCallback);\nUNKNOWN_FUNCTION(__GXFifoInit);\nUNKNOWN_FUNCTION(__GXCleanGPFifo);\nUNKNOWN_FUNCTION(GXResetOverflowCount);\nvoid GXSetVtxDesc(u8 attr, u8 type);\nUNKNOWN_FUNCTION(GXSetVtxDescv);\nUNKNOWN_FUNCTION(__GXSetVCD);\nUNKNOWN_FUNCTION(__GXCalculateVLim);\nUNKNOWN_FUNCTION(GXGetVtxDesc);\nUNKNOWN_FUNCTION(GXGetVtxDescv);\nvoid GXClearVtxDesc();\nvoid GXSetVtxAttrFmt(u8 vtxfmt, u32 vtxattr, u32 comptype, u32 compsize, u32 frac);\nUNKNOWN_FUNCTION(GXSetVtxAttrFmtv);\nUNKNOWN_FUNCTION(__GXSetVAT);\nUNKNOWN_FUNCTION(GXGetVtxAttrFmt);\nUNKNOWN_FUNCTION(GXGetVtxAttrFmtv);\nUNKNOWN_FUNCTION(GXSetArray);\nUNKNOWN_FUNCTION(GXInvalidateVtxCache);\nUNKNOWN_FUNCTION(GXSetTexCoordGen2);\nvoid GXSetNumTexGens(u32 nr);\nUNKNOWN_FUNCTION(GXSetMisc);\nUNKNOWN_FUNCTION(GXFlush);\nUNKNOWN_FUNCTION(GXResetWriteGatherPipe);\nUNKNOWN_FUNCTION(__GXAbort);\nUNKNOWN_FUNCTION(GXAbortFrame);\nvoid GXSetDrawSync(u16 token);\nu16 GXReadDrawSync();\nUNKNOWN_FUNCTION(GXDrawDone);\nUNKNOWN_FUNCTION(GXPixModeSync);\nUNKNOWN_FUNCTION(GXTexModeSync);\nUNKNOWN_FUNCTION(GXPokeAlphaMode);\nUNKNOWN_FUNCTION(GXPokeAlphaRead);\nUNKNOWN_FUNCTION(GXPokeAlphaUpdate);\nUNKNOWN_FUNCTION(GXPokeBlendMode);\nUNKNOWN_FUNCTION(GXPokeColorUpdate);\nUNKNOWN_FUNCTION(GXPokeDstAlpha);\nUNKNOWN_FUNCTION(GXPokeDither);\nUNKNOWN_FUNCTION(GXPokeZMode);\nUNKNOWN_FUNCTION(GXSetDrawSyncCallback);\nUNKNOWN_FUNCTION(GXTokenInterruptHandler);\nUNKNOWN_FUNCTION(GXSetDrawDoneCallback);\nUNKNOWN_FUNCTION(GXFinishInterruptHandler);\nUNKNOWN_FUNCTION(__GXPEInit);\nUNKNOWN_FUNCTION(__GXSetDirtyState);\nvoid GXBegin(u8 primitive, u8 vtxfmt, u16 vtxcnt);\nUNKNOWN_FUNCTION(__GXSendFlushPrim);\nUNKNOWN_FUNCTION(GXSetLineWidth);\nUNKNOWN_FUNCTION(GXSetPointSize);\nUNKNOWN_FUNCTION(GXEnableTexOffsets);\nvoid GXSetCullMode(u8 mode);\nUNKNOWN_FUNCTION(GXGetCullMode);\nUNKNOWN_FUNCTION(GXSetCoPlanar);\nUNKNOWN_FUNCTION(GXAdjustForOverscan);\nUNKNOWN_FUNCTION(GXSetDispCopySrc);\nUNKNOWN_FUNCTION(GXSetTexCopySrc);\nUNKNOWN_FUNCTION(GXSetDispCopyDst);\nUNKNOWN_FUNCTION(GXSetTexCopyDst);\nUNKNOWN_FUNCTION(GXSetDispCopyFrame2Field);\nUNKNOWN_FUNCTION(GXSetCopyClamp);\nUNKNOWN_FUNCTION(GXGetYScaleFactor);\nUNKNOWN_FUNCTION(GXSetDispCopyYScale);\nUNKNOWN_FUNCTION(GXSetCopyClear);\nUNKNOWN_FUNCTION(GXSetCopyFilter);\nUNKNOWN_FUNCTION(GXSetDispCopyGamma);\nUNKNOWN_FUNCTION(GXCopyDisp);\nUNKNOWN_FUNCTION(GXCopyTex);\nUNKNOWN_FUNCTION(GXClearBoundingBox);\nUNKNOWN_FUNCTION(GXReadBoundingBox);\nUNKNOWN_FUNCTION(GXInitLightAttn);\nUNKNOWN_FUNCTION(GXInitLightSpot);\nUNKNOWN_FUNCTION(GXInitLightDistAttn);\nUNKNOWN_FUNCTION(GXInitLightPos);\nUNKNOWN_FUNCTION(GXInitLightDir);\nUNKNOWN_FUNCTION(GXInitLightColor);\nUNKNOWN_FUNCTION(GXLoadLightObjImm);\nUNKNOWN_FUNCTION(GXSetChanAmbColor);\nvoid GXSetChanMatColor(s32 channel, const GXColor * colour);\nvoid GXSetNumChans(u8 num);\nvoid GXSetChanCtrl(s32 chan, u8 enable, u8 ambsrc, u8 matsrc, u8 litmask, u8 diff_fn, u8 attn_fn);\nUNKNOWN_FUNCTION(GXGetTexBufferSize);\nUNKNOWN_FUNCTION(__GetImageTileCount);\nUNKNOWN_FUNCTION(GXInitTexObj);\nUNKNOWN_FUNCTION(GXInitTexObjCI);\nUNKNOWN_FUNCTION(GXInitTexObjLOD);\nvoid GXInitTexObjData(GXTexObj * texObj, void * image);\nUNKNOWN_FUNCTION(GXInitTexObjWrapMode);\nUNKNOWN_FUNCTION(GXInitTexObjTlut);\nUNKNOWN_FUNCTION(GXInitTexObjFilter);\nUNKNOWN_FUNCTION(GXGetTexObjWidth);\nUNKNOWN_FUNCTION(GXGetTexObjHeight);\nUNKNOWN_FUNCTION(GXGetTexObjFmt);\nUNKNOWN_FUNCTION(GXGetTexObjMipMap);\nUNKNOWN_FUNCTION(GXGetTexObjTlut);\nUNKNOWN_FUNCTION(GXLoadTexObjPreLoaded);\nUNKNOWN_FUNCTION(GXLoadTexObj);\nUNKNOWN_FUNCTION(GXInitTlutObj);\nUNKNOWN_FUNCTION(GXLoadTlut);\nUNKNOWN_FUNCTION(GXInitTexCacheRegion);\nUNKNOWN_FUNCTION(GXInitTexPreLoadRegion);\nUNKNOWN_FUNCTION(GXInitTlutRegion);\nUNKNOWN_FUNCTION(GXInvalidateTexAll);\nUNKNOWN_FUNCTION(GXSetTexRegionCallback);\nUNKNOWN_FUNCTION(GXSetTlutRegionCallback);\nUNKNOWN_FUNCTION(GXPreLoadEntireTexture);\nUNKNOWN_FUNCTION(__SetSURegs);\nUNKNOWN_FUNCTION(__GXSetSUTexRegs);\nUNKNOWN_FUNCTION(__GXSetTmemConfig);\nUNKNOWN_FUNCTION(GXSetTevIndirect);\nUNKNOWN_FUNCTION(GXSetIndTexMtx);\nUNKNOWN_FUNCTION(GXSetIndTexCoordScale);\nUNKNOWN_FUNCTION(GXSetIndTexOrder);\nUNKNOWN_FUNCTION(GXSetNumIndStages);\nUNKNOWN_FUNCTION(GXSetTevDirect);\nUNKNOWN_FUNCTION(GXSetTevIndWarp);\nUNKNOWN_FUNCTION(__GXUpdateBPMask);\nUNKNOWN_FUNCTION(__GXSetIndirectMask);\nUNKNOWN_FUNCTION(__GXFlushTextureState);\nvoid GXSetTevOp(u8 tevstage, u8 mode);\nUNKNOWN_FUNCTION(GXSetTevColorIn);\nUNKNOWN_FUNCTION(GXSetTevAlphaIn);\nUNKNOWN_FUNCTION(GXSetTevColorOp);\nUNKNOWN_FUNCTION(GXSetTevAlphaOp);\nUNKNOWN_FUNCTION(GXSetTevColor);\nUNKNOWN_FUNCTION(GXSetTevColorS10);\nUNKNOWN_FUNCTION(GXSetTevKColor);\nUNKNOWN_FUNCTION(GXSetTevKColorSel);\nUNKNOWN_FUNCTION(GXSetTevKAlphaSel);\nvoid GXSetTevSwapMode(u8 tevstage, u8 ras_sel, u8 tex_sel);\nUNKNOWN_FUNCTION(GXSetTevSwapModeTable);\nvoid GXSetAlphaCompare(u8 comp0, u8 ref0, u8 aop, u8 comp1, u8 ref1);\nUNKNOWN_FUNCTION(GXSetZTexture);\nvoid GXSetTevOrder(u8 tevstage, u8 texcoord, u32 texmap, u8 color);\nvoid GXSetNumTevStages(u8 num);\nvoid GXSetFog(u8 type, f32 startz, f32 endz, f32 nearz, f32 farz, const GXColor * col);\nUNKNOWN_FUNCTION(GXSetFogRangeAdj);\nvoid GXSetBlendMode(u8 type, u8 src_fact, u8 dst_fact, u8 op);\nUNKNOWN_FUNCTION(GXSetColorUpdate);\nUNKNOWN_FUNCTION(GXSetAlphaUpdate);\nvoid GXSetZMode(u8 enable, u8 func, u8 update_enable);\nvoid GXSetZCompLoc(u8 before_tex);\nUNKNOWN_FUNCTION(GXSetPixelFmt);\nUNKNOWN_FUNCTION(GXSetDither);\nUNKNOWN_FUNCTION(GXSetDstAlpha);\nUNKNOWN_FUNCTION(GXSetFieldMask);\nUNKNOWN_FUNCTION(GXSetFieldMode);\nUNKNOWN_FUNCTION(GXDrawSphere);\nUNKNOWN_FUNCTION(GXDrawCubeFace);\nUNKNOWN_FUNCTION(GXDrawCube);\nUNKNOWN_FUNCTION(GXBeginDisplayList);\nUNKNOWN_FUNCTION(GXEndDisplayList);\nUNKNOWN_FUNCTION(GXCallDisplayList);\nUNKNOWN_FUNCTION(GXProject);\nUNKNOWN_FUNCTION(__GXSetProjection);\nvoid GXSetProjection(Mtx44 * mtx, u32 type);\nUNKNOWN_FUNCTION(GXSetProjectionv);\nUNKNOWN_FUNCTION(GXGetProjectionv);\nvoid GXLoadPosMtxImm(Mtx34 * mtx, u32 pnidx);\nUNKNOWN_FUNCTION(GXLoadNrmMtxImm);\nvoid GXSetCurrentMtx(u32 mtx);\nUNKNOWN_FUNCTION(GXLoadTexMtxImm);\nUNKNOWN_FUNCTION(__GXSetViewport);\nUNKNOWN_FUNCTION(GXSetViewportJitter);\nUNKNOWN_FUNCTION(GXSetViewport);\nUNKNOWN_FUNCTION(GXGetViewportv);\nUNKNOWN_FUNCTION(GXSetZScaleOffset);\nUNKNOWN_FUNCTION(GXSetScissor);\nUNKNOWN_FUNCTION(GXGetScissor);\nUNKNOWN_FUNCTION(GXSetScissorBoxOffset);\nUNKNOWN_FUNCTION(GXSetClipMode);\nUNKNOWN_FUNCTION(__GXSetMatrixIndex);\nUNKNOWN_FUNCTION(GXSetGPMetric);\nUNKNOWN_FUNCTION(GXClearGPMetric);\n\ninline void GXEnd() { }\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(wii::os)\n\nUSING(wii::gx::GXColor)\n\nUNKNOWN_FUNCTION(ScreenReport);\nUNKNOWN_FUNCTION(ConfigureVideo);\nvoid OSFatal(const GXColor * fg, const GXColor * bg, const char * message) NORETURN;\nUNKNOWN_FUNCTION(Halt);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::os)\n\nUNKNOWN_FUNCTION(GetFontCode);\nUNKNOWN_FUNCTION(Decode);\ns32 OSGetFontEncode();\nUNKNOWN_FUNCTION(OSSetFontEncode);\nUNKNOWN_FUNCTION(ReadFont);\nvoid OSLoadFont(void * fontHeader, void * temp);\nUNKNOWN_FUNCTION(ParseStringS);\nUNKNOWN_FUNCTION(ParseStringW);\nchar * OSGetFontTexel(const char * str, void * image, s32 pos, s32 stride, s32 * width);\n\nCPP_WRAPPER_END()\n\n\n\nCPP_WRAPPER(wii::os)\n\n#define OSClockSpeed ((*(u32 *) 0x800000F8) / 4)\n#define OSTicksToMilliseconds(ticks) ((ticks) / (OSClockSpeed / 1000))\n#define OSMillisecondsToTicks(ms) ((ms) * (OSClockSpeed / 1000))\n#define OSSecondsToTicks(s) ((s) * (OSClockSpeed))\n\ntypedef s64 OSTime;\ntypedef u32 OSTick;\n\nOSTime OSGetTime();\nOSTick OSGetTick();\n\nUNKNOWN_FUNCTION(__OSGetSystemTime);\nUNKNOWN_FUNCTION(__OSTimeToSystemTime);\nUNKNOWN_FUNCTION(GetDates);\nUNKNOWN_FUNCTION(OSTicksToCalendarTime);\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(wii::os)\n\nUSING(wii::OS::OSTime)\n\nextern volatile OSTime __OSLastInterruptTime;\nextern volatile s16 __OSLastInterrupt;\nextern volatile u32 __OSLastInterruptSrr0;\n\nu32 OSDisableInterrupts();\nUNKNOWN_FUNCTION(OSEnableInterrupts);\nvoid OSRestoreInterrupts(u32 interruptMask);\nUNKNOWN_FUNCTION(__OSSetInterruptHandler);\nUNKNOWN_FUNCTION(__OSGetInterruptHandler);\nUNKNOWN_FUNCTION(__OSInterruptInit);\nUNKNOWN_FUNCTION(SetInterruptMask);\nUNKNOWN_FUNCTION(__OSMaskInterrupts);\nUNKNOWN_FUNCTION(__OSUnmaskInterrupts);\nUNKNOWN_FUNCTION(__OSDispatchInterrupt);\nUNKNOWN_FUNCTION(ExternalInterruptHandler);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::os)\n\ntypedef void (RelExportFunc)();\n\n// Unions are offsets in file then pointers after OSLink\ntypedef struct _RelHeader\n{\n    u32 id;\n    struct _RelHeader * next;\n    struct _RelHeader * prev;\n    u32 numSections;\n    union\n    {\n        u32 sectionInfoOffset;\n        void * sectionInfo;\n    };\n    union\n    {\n        u32 nameOffset;\n        void * name;\n    };\n    u32 nameSize;\n    u32 version;\n    u32 bssSize;\n    union\n    {\n        u32 relOffset;\n        void * relocationTable;\n    };\n    union\n    {\n        u32 impOffset;\n        void * impTable;\n    };\n    u32 impSize;\n    u8 prologSection;\n    u8 epilogSection;\n    u8 unresolvedSection;\n    u8 bssSection;\n    union\n    {\n        u32 prologOffset;\n        RelExportFunc * prolog;\n    };\n    union\n    {\n        u32 epilogOffset;\n        RelExportFunc * epilog;\n    };\n    union\n    {\n        u32 unresolvedOffset;\n        RelExportFunc * unresolved;\n    };\n    u32 align;\n    u32 bssAlign;\n    u32 fixSize;\n} RelHeader;\nSIZE_ASSERT(RelHeader, 0x4c)\n\nFIXED_ADDR(RelHeader *, firstRel, 0x800030c8);\nFIXED_ADDR(RelHeader *, lastRel, 0x800030cc);\n\nUNKNOWN_FUNCTION(OSNotifyLink);\nUNKNOWN_FUNCTION(OSNotifyUnlink);\nUNKNOWN_FUNCTION(OSNotifyPreLink);\nUNKNOWN_FUNCTION(OSNotifyPostLink);\nUNKNOWN_FUNCTION(Relocate);\nUNKNOWN_FUNCTION(Link);\nbool OSLink(RelHeader * relFile, void * bss);\nUNKNOWN_FUNCTION(Undo);\nUNKNOWN_FUNCTION(OSUnlink);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::os)\n\ntypedef struct\n{\n    u8 unknown_0x0[0x18 - 0x0];\n} OSMutex;\nSIZE_ASSERT(OSMutex, 0x18)\n\nvoid OSInitMutex(OSMutex * mutex);\nUNKNOWN_FUNCTION(OSLockMutex);\nUNKNOWN_FUNCTION(OSUnlockMutex);\nUNKNOWN_FUNCTION(__OSUnlockAllMutex);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::os)\n\nvoid __OSReboot(Unk param_1, Unk param_2);\nUNKNOWN_FUNCTION(OSGetSaveRegion);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::os)\n\nUNKNOWN_FUNCTION(OSRegisterShutdownFunction);\nUNKNOWN_FUNCTION(__OSCallShutdownFunctions);\nUNKNOWN_FUNCTION(__OSShutdownDevices);\nvoid OSShutdownSystem();\nUNKNOWN_FUNCTION(__OSRebootForNANDAPP);\nvoid OSRestart(s32 code);\nvoid OSReturnToMenu();\nUNKNOWN_FUNCTION(__OSReturnToMenuForError);\ns32 OSGetResetCode();\nUNKNOWN_FUNCTION(OSResetSystem);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::os)\n\ntypedef void (*PowerCallback)();\n\nvoid OSSetResetCallback(PowerCallback * func);\nvoid OSSetPowerCallback(PowerCallback * func);\nUNKNOWN_FUNCTION(__OSInitSTM);\nUNKNOWN_FUNCTION(__OSShutdownToSBY);\nUNKNOWN_FUNCTION(__OSHotReset);\nUNKNOWN_FUNCTION(__OSSetVIForceDimming);\nUNKNOWN_FUNCTION(__OSUnregisterStateEvent);\nUNKNOWN_FUNCTION(__OSVIDimReplyHandler);\nUNKNOWN_FUNCTION(__OSDefaultResetCallback);\nUNKNOWN_FUNCTION(__OSDefaultPowerCallback);\nUNKNOWN_FUNCTION(__OSStateEventHandler);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::os)\n\nUSING(wii::os::OSContext)\n\ntypedef struct _OSThread\n{\n    OSContext context;\n    u8 unknown_0x2c8[0x2fc - 0x2c8];\n    struct _OSThread * next;\n    struct _OSThread * prev;\n    u8 unknown_0x304[0x318 - 0x304];\n} OSThread;\nSIZE_ASSERT(OSThread, 0x318)\n\ntypedef struct\n{\n/* 0x0 */ u8 unknown_0x0[0x8 - 0x0];\n} OSThreadQueue;\nSIZE_ASSERT(OSThreadQueue, 0x8)\n\nFIXED_ADDR(OSThread *, currentThread, 0x800000e4);\n\ntypedef void (*ThreadFunc)();\n\nUNKNOWN_FUNCTION(DefaultSwitchThreadCallback);\nUNKNOWN_FUNCTION(__OSThreadInit);\nUNKNOWN_FUNCTION(OSInitThreadQueue);\nOSThread * OSGetCurrentThread();\nUNKNOWN_FUNCTION(OSDisableScheduler);\nUNKNOWN_FUNCTION(OSEnableScheduler);\nUNKNOWN_FUNCTION(UnsetRun);\nUNKNOWN_FUNCTION(__OSGetEffectivePriority);\nUNKNOWN_FUNCTION(SetEffectivePriority);\nUNKNOWN_FUNCTION(__OSPromoteThread);\nUNKNOWN_FUNCTION(SelectThread);\nUNKNOWN_FUNCTION(__OSReschedule);\nvoid OSYieldThread();\ns32 OSCreateThread(OSThread * thread, ThreadFunc * func, void * funcParam, void * stackTop,\n                   u32 stackSize, s32 priority, u16 param_7);\nUNKNOWN_FUNCTION(OSExitThread);\nvoid OSCancelThread(OSThread * thread);\nUNKNOWN_FUNCTION(OSJoinThread);\ns32 OSResumeThread(OSThread * thread);\ns32 OSSuspendThread(OSThread * thread);\nvoid OSSleepThread(OSThreadQueue * thread);\nvoid OSWakeupThread(OSThreadQueue * thread);\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::evtmgr)\n\nUSING(wii::os::OSTime)\n\n/*\n    Defines from asserts\n*/\n#define EVT_max 0x78\n#define EVT_ENTRY_MAX 0x80\n#define MAX_EVT_JMPTBL 16\n\n/*\n    EvtEntry.flags values\n*/\n\n// Entry is being used to run a script\n#define EVT_FLAG_IN_USE 0x1\n\n// Entry's script is temporarily stopped\n#define EVT_FLAG_PAUSED 0x2\n\n// Entry's lifetime doesn't increase\n#define EVT_FLAG_STOP_TIME 0x4\n\n// Entry's script is temporarily stopped until its child script finishes\n#define EVT_FLAG_WAIT_CHILD 0x10\n\n// Entry should still execute this frame if created while evtmgrMain is running\n#define EVT_FLAG_START_IMMEDIATE 0x20\n\n// Same effect as EVT_FLAG_PAUSED?\n#define EVT_FLAG_80 0x80\n\nstruct _EvtEntry;\ntypedef s32 (UserFunc)(struct _EvtEntry * entry, bool firstRun);\ntypedef s32 EvtScriptCode;\ntypedef s32 EvtVar;\n\ntypedef struct _EvtEntry\n{\n/* 0x000 */ OSTime lifetime; // Time this script has been running & not paused\n/* 0x008 */ u8 flags; // Bit flags, see defines above\n/* 0x009 */ u8 curDataLength; // Number of pieces of data (4 bytes each) belonging to the\n                              // current instruction\n/* 0x00A */ u8 curOpcode; // Opcode of the current instruction\n/* 0x00B */ u8 priority; // Priority for script to run (higher value -> earlier)\n/* 0x00C */ u8 type; // Type mask for stopping/starting\n/* 0x00D */ s8 blocked; // Keep re-exucuting the current instruction if true\n                        // (decomp doesn't match as bool)\n/* 0x00E */ s8 doWhileDepth; // Number of do-while loops the current instruction is nested into\n/* 0x00F */ s8 switchDepth; // Number of switches the current instruction is nested into\n/* 0x010 */ EvtScriptCode * pCurInstruction; // Current instruction being executed\n/* 0x014 */ EvtScriptCode * pCurData; // Args for the current instruction being executed\n/* 0x018 */ s8 labelIds[MAX_EVT_JMPTBL]; // Each correspond to an address in the jump table\n/* 0x028 */ EvtScriptCode * jumptable[MAX_EVT_JMPTBL]; // Addresses for each label\n/* 0x068 */ struct _EvtEntry * parent; // Script that started this one as a child\n/* 0x06C */ struct _EvtEntry * childEntry; // Script started by this one, pausing this until it's\n                                           // finished\n/* 0x070 */ struct _EvtEntry * brotherEntry; // Script started by this one which will be stopped if\n                                             // this one is\n/* 0x074 */ union\n            {\n                s32 tempS[3];\n                u32 tempU[3];\n            }; // Temp values with meanings varying by instruction / user func\n/* 0x080 */ u8 unknown_0x80[0x94 - 0x80];\n/* 0x094 */ UserFunc * userFunc; // Function set & called by the user_func opcode\n/* 0x098 */ s32 lw[16]; // Local Work variables\n/* 0x0D8 */ u32 lf[3]; // Local Flag variables\n/* 0x0E4 */ EvtScriptCode * doWhileStartPtrs[8]; // Pointer to do opcodes for active while loops\n/* 0x104 */ s32 doWhileCounters[8]; // Counters for active while loops\n/* 0x124 */ s8 switchStates[8]; // Sates of active switch statements\n/* 0x12C */ s32 switchValues[8]; // Values passed into active switch statements\n/* 0x14C */ union\n            {\n                s32 * readAddr;\n                f32 * readfAddr;\n            }; // Current addr for read/readf instructions\n/* 0x150 */ s32 * uw; // User Work variables pointer\n/* 0x154 */ u32 * uf; // User Flag variables pointer\n/* 0x158 */ s32 id; // Script id\n/* 0x15C */ f32 speed; // timeToRun given per frame\n/* 0x160 */ f32 timeToRun; // Number of instructions to execute this frame\n/* 0x164 */ s32 casedrvId;\n/* 0x168 */ void * ownerNPC;\n/* 0x16C */ void * ownerMOBJ;\n/* 0x170 */ s32 unknown_0x170;\n/* 0x174 */ s32 msgWindowId;\n/* 0x178 */ s32 unknown_0x178;\n/* 0x17C */ f32 unknown_0x17c;\n/* 0x180 */ f32 unknown_0x180;\n/* 0x184 */ f32 unknown_0x184;\n/* 0x188 */ s32 msgPri;\n/* 0x18C */ u8 unknown_0x18c[0x198 - 0x18c];\n/* 0x198 */ EvtScriptCode * scriptStart; // Pointer to the start of this script\n/* 0x19C */ char * name; // debug thing, unused?\n/* 0x1A0 */ void * pPrevInstruction; // Pointer to last instruction executed\n/* 0x1A4 */ u8 unknown_0x1a4[0x1a8 - 0x1a4];\n} EvtEntry;\nSIZE_ASSERT(EvtEntry, 0x1a8)\n\ntypedef struct\n{\n/* 0x00 */ s32 entryCount; // Number of EvtEntry structs in the entries array\n/* 0x04 */ s32 gw[32]; // Global Work variables\n/* 0x84 */ u32 gf[3]; // Global Flag variables\n/* 0x90 */ EvtEntry * entries; // Entry array\n/* 0x04 */ // Alignment padding 0x94-97\n/* 0xA0 */ OSTime time; // Time evtmgrMain last ran\n} EvtWork;\nSIZE_ASSERT(EvtWork, 0xa0)\n\n// Next script id to use\nDECOMP_STATIC(s32 evtmgr_evtId)\n\n// Default speed for scripts\nDECOMP_STATIC(f32 evtmgr_evtSpd)\n\n// Number of scripts running\nDECOMP_STATIC(s32 evtmgr_evtMax)\n\n// Numbers of entries in the priority table\nDECOMP_STATIC(s32 evtmgr_priTblNum)\n\n// Whether evtmgrMain is running\nDECOMP_STATIC(s32 evtmgr_runMainF)\n\n/*\n    Returns pointer to the EvtWork struct\n*/\nEvtWork * evtGetWork();\n\n/*\n    Allocates memories for entries and zeros global evt variables\n*/\nvoid evtmgrInit();\n\n/*\n    Zeros all entries\n*/\nvoid evtmgrReInit();\n\n/*\n    Stops scripts based on _spmarioSystemLevel\n*/\nvoid evtEntryRunCheck();\n\n/*\n    Starts execution of a script\n*/\n// TODO: try fix const in decomp\n#ifdef DECOMP\nEvtEntry * evtEntry(EvtScriptCode * script, u32 priority, u8 flags);\nEvtEntry * evtEntryType(EvtScriptCode * script, u32 priority, u8 flags, u8 type);\nEvtEntry * evtChildEntry(EvtEntry * parent, EvtScriptCode * script, u8 flags);\nEvtEntry * evtBrotherEntry(EvtEntry * brother, EvtScriptCode * script, u8 flags);\n#else\nEvtEntry * evtEntry(const EvtScriptCode * script, u32 priority, u8 flags);\nEvtEntry * evtEntryType(const EvtScriptCode * script, u32 priority, u8 flags, u8 type);\nEvtEntry * evtChildEntry(EvtEntry * parent, const EvtScriptCode * script, u8 flags);\nEvtEntry * evtBrotherEntry(EvtEntry * brother, const EvtScriptCode * script, u8 flags);\n#endif\n\n/*\n    Restarts a entry\n*/\nEvtEntry * evtRestart(EvtEntry * entry);\n\n/*\n    Sets up entry executions, called every frame\n*/\nvoid evtmgrMain();\n\n/*\n    Terminates a entry and all its children & brothers\n*/\nvoid evtDelete(EvtEntry * entry);\n\n/*\n    Terminates a entry by id and all its children & brothers\n*/\nvoid evtDeleteID(s32 id);\n\n/*\n    Checks if a entry is running by id\n*/\nbool evtCheckID(s32 id);\n\n/*\n    Sets the execution priority of a entry\n*/\nvoid evtSetPri(EvtEntry * entry, u32 pri);\n\n/*\n    Sets the execution speed of a entry\n*/\nvoid evtSetSpeed(EvtEntry * entry, f32 multiplier);\n\n/*\n    Sets the type mask of a entry\n*/\nvoid evtSetType(EvtEntry * entry, u32 type);\n\n/*\n    Pauses execution a entry and all its children & brothers with types included in the mask\n*/\nvoid evtStop(EvtEntry * entry, u32 mask);\n\n/*\n    Resumes execution of a entry and all its children & brothers with types included in the mask\n*/\nvoid evtStart(EvtEntry * entry, u32 mask);\n\n/*\n    Pauses execution of a entry by id and all its children & brothers\n*/\nvoid evtStopID(s32 id);\n\n/*\n    Resumes execution of a entry by id and all its children & brothers\n*/\nvoid evtStartID(s32 id);\n\n/*\n    Pauses execution of all entries with types included in the mask\n*/\nvoid evtStopAll(u32 mask);\n\n/*\n    Resumes execution of all entries with types included in the mask\n*/\nvoid evtStartAll(u32 mask);\n\n/*\n    Pauses execution of all entries with types included in the mask other than one specific entry\n*/\nvoid evtStopOther(EvtEntry * entry, u32 mask);\n\n/*\n    Resumes execution of all entries with types included in the mask other than one specific entry\n*/\nvoid evtStartOther(EvtEntry * entry, u32 mask);\n\n/*\n    Gets an entry by its index into the array of entries\n*/\nEvtEntry * evtGetPtr(s32 index);\n\n/*\n    Gets an entry by its id\n*/\nEvtEntry * evtGetPtrID(s32 id);\n\nCPP_WRAPPER_END()\n/*\n    Functions to execute interpreted evt script code and handle evt variables\n*/\n\n\n\nCPP_WRAPPER(spm::evtmgr_cmd)\n\nUSING(spm::evtmgr::EvtEntry)\nUSING(spm::evtmgr::EvtScriptCode)\nUSING(spm::evtmgr::EvtVar)\n\n// Data types\n#define EVTDAT_ADDR_MAX -290000000\n#define EVTDAT_FLOAT_MAX -220000000\n#define EVTDAT_UF_MAX -200000000\n#define EVTDAT_UW_MAX -180000000\n#define EVTDAT_GSW_MAX -160000000\n#define EVTDAT_LSW_MAX -140000000\n#define EVTDAT_GSWF_MAX -120000000\n#define EVTDAT_LSWF_MAX -100000000\n#define EVTDAT_GF_MAX -80000000\n#define EVTDAT_LF_MAX -60000000\n#define EVTDAT_GW_MAX -40000000\n#define EVTDAT_LW_MAX -20000000\n\n#define EVTDAT_ADDR_BASE 270000000\n#define EVTDAT_FLOAT_BASE 240000000\n#define EVTDAT_UF_BASE 210000000\n#define EVTDAT_UW_BASE 190000000\n#define EVTDAT_GSW_BASE 170000000\n#define EVTDAT_LSW_BASE 150000000\n#define EVTDAT_GSWF_BASE 130000000\n#define EVTDAT_LSWF_BASE 110000000\n#define EVTDAT_GF_BASE 90000000\n#define EVTDAT_LF_BASE 70000000\n#define EVTDAT_GW_BASE 50000000\n#define EVTDAT_LW_BASE 30000000\n\n/*\n    Instruction / User Func Return values\n*/\n\n// Stop execution of all scripts this frame\n#define EVT_RET_END_FRAME -1\n\n// Keep re-executing current instruction, continue next frame if too much time passed\n#define EVT_RET_BLOCK_WEAK 0\n\n// Move to next instruction, continue next frame if too much time passed\n#define EVT_RET_CONTINUE_WEAK 1\n\n// Move to next instruction\n#define EVT_RET_CONTINUE 2\n\n// Keep re-executing current instruction\n#define EVT_RET_BLOCK 3\n\n// Stop running current script\n#define EVT_RET_END 0xff\n\n/*\n    evtmgrCmd return values\n*/\n\n#define EVTCMD_RET_END -1\n#define EVTCMD_RET_CONTINUE 0\n#define EVTCMD_RET_END_ALL 1\n\n/*\n    Opcodes\n*/\nenum EvtOpcode\n{\n/* 0x00 */ EVT_OPC_NEXT,\n/* 0x01 */ EVT_OPC_END_SCRIPT,\n/* 0x02 */ EVT_OPC_END_EVT,\n/* 0x03 */ EVT_OPC_LBL,\n/* 0x04 */ EVT_OPC_GOTO,\n/* 0x05 */ EVT_OPC_DO,\n/* 0x06 */ EVT_OPC_WHILE,\n/* 0x07 */ EVT_OPC_DO_BREAK,\n/* 0x08 */ EVT_OPC_DO_CONTINUE,\n/* 0x09 */ EVT_OPC_WAIT_FRM,\n/* 0x0A */ EVT_OPC_WAIT_MSEC,\n/* 0x0B */ EVT_OPC_HALT,\n/* 0x0C */ EVT_OPC_IF_STR_EQUAL,\n/* 0x0D */ EVT_OPC_IF_STR_NOT_EQUAL,\n/* 0x0E */ EVT_OPC_IF_STR_SMALL,\n/* 0x0F */ EVT_OPC_IF_STR_LARGE,\n/* 0x10 */ EVT_OPC_IF_STR_SMALL_EQUAL,\n/* 0x11 */ EVT_OPC_IF_STR_LARGE_EQUAL,\n/* 0x12 */ EVT_OPC_IFF_EQUAL,\n/* 0x13 */ EVT_OPC_IFF_NOT_EQUAL,\n/* 0x14 */ EVT_OPC_IFF_SMALL,\n/* 0x15 */ EVT_OPC_IFF_LARGE,\n/* 0x16 */ EVT_OPC_IFF_SMALL_EQUAL,\n/* 0x17 */ EVT_OPC_IFF_LARGE_EQUAL,\n/* 0x18 */ EVT_OPC_IF_EQUAL,\n/* 0x19 */ EVT_OPC_IF_NOT_EQUAL,\n/* 0x1A */ EVT_OPC_IF_SMALL,\n/* 0x1B */ EVT_OPC_IF_LARGE,\n/* 0x1C */ EVT_OPC_IF_SMALL_EQUAL,\n/* 0x1D */ EVT_OPC_IF_LARGE_EQUAL,\n/* 0x1E */ EVT_OPC_IF_FLAG,\n/* 0x1F */ EVT_OPC_IF_NOT_FLAG,\n/* 0x20 */ EVT_OPC_ELSE,\n/* 0x21 */ EVT_OPC_END_IF,\n/* 0x22 */ EVT_OPC_SWITCH,\n/* 0x23 */ EVT_OPC_SWITCHI,\n/* 0x24 */ EVT_OPC_CASE_EQUAL,\n/* 0x25 */ EVT_OPC_CASE_NOT_EQUAL,\n/* 0x26 */ EVT_OPC_CASE_SMALL,\n/* 0x27 */ EVT_OPC_CASE_LARGE,\n/* 0x28 */ EVT_OPC_CASE_SMALL_EQUAL,\n/* 0x29 */ EVT_OPC_CASE_LARGE_EQUAL,\n/* 0x2A */ EVT_OPC_CASE_ETC,\n/* 0x2B */ EVT_OPC_CASE_OR,\n/* 0x2C */ EVT_OPC_CASE_AND,\n/* 0x2D */ EVT_OPC_CASE_FLAG,\n/* 0x2E */ EVT_OPC_CASE_END,\n/* 0x2F */ EVT_OPC_CASE_BETWEEN,\n/* 0x30 */ EVT_OPC_SWITCH_BREAK,\n/* 0x31 */ EVT_OPC_END_SWITCH,\n/* 0x32 */ EVT_OPC_SET,\n/* 0x33 */ EVT_OPC_SETI,\n/* 0x34 */ EVT_OPC_SETF,\n/* 0x35 */ EVT_OPC_ADD,\n/* 0x36 */ EVT_OPC_SUB,\n/* 0x37 */ EVT_OPC_MUL,\n/* 0x38 */ EVT_OPC_DIV,\n/* 0x39 */ EVT_OPC_MOD,\n/* 0x3A */ EVT_OPC_ADDF,\n/* 0x3B */ EVT_OPC_SUBF,\n/* 0x3C */ EVT_OPC_MULF,\n/* 0x3D */ EVT_OPC_DIVF,\n/* 0x3E */ EVT_OPC_SET_READ,\n/* 0x3F */ EVT_OPC_READ,\n/* 0x40 */ EVT_OPC_READ2,\n/* 0x41 */ EVT_OPC_READ3,\n/* 0x42 */ EVT_OPC_READ4,\n/* 0x43 */ EVT_OPC_READ_N,\n/* 0x44 */ EVT_OPC_SET_READF,\n/* 0x45 */ EVT_OPC_READF,\n/* 0x46 */ EVT_OPC_READF2,\n/* 0x47 */ EVT_OPC_READF3,\n/* 0x48 */ EVT_OPC_READF4,\n/* 0x49 */ EVT_OPC_READF_N,\n/* 0x4A */ EVT_OPC_CLAMP_INT,\n/* 0x4B */ EVT_OPC_SET_USER_WRK,\n/* 0x4C */ EVT_OPC_SET_USER_FLG,\n/* 0x4D */ EVT_OPC_ALLOC_USER_WRK,\n/* 0x4E */ EVT_OPC_AND,\n/* 0x4F */ EVT_OPC_ANDI,\n/* 0x50 */ EVT_OPC_OR,\n/* 0x51 */ EVT_OPC_ORI,\n/* 0x52 */ EVT_OPC_SET_FRAME_FROM_MSEC,\n/* 0x53 */ EVT_OPC_SET_MSEC_FROM_FRAME,\n/* 0x54 */ EVT_OPC_SET_RAM,\n/* 0x55 */ EVT_OPC_SET_RAMF,\n/* 0x56 */ EVT_OPC_GET_RAM,\n/* 0x57 */ EVT_OPC_GET_RAMF,\n/* 0x58 */ EVT_OPC_SETR,\n/* 0x59 */ EVT_OPC_SETRF,\n/* 0x5A */ EVT_OPC_GETR,\n/* 0x5B */ EVT_OPC_GETRF,\n/* 0x5C */ EVT_OPC_USER_FUNC,\n/* 0x5D */ EVT_OPC_RUN_EVT,\n/* 0x5E */ EVT_OPC_RUN_EVT_ID,\n/* 0x5F */ EVT_OPC_RUN_CHILD_EVT,\n/* 0x60 */ EVT_OPC_DELETE_EVT,\n/* 0x61 */ EVT_OPC_RESTART_EVT,\n/* 0x62 */ EVT_OPC_SET_PRI,\n/* 0x63 */ EVT_OPC_SET_SPD,\n/* 0x64 */ EVT_OPC_SET_TYPE,\n/* 0x65 */ EVT_OPC_STOP_ALL,\n/* 0x66 */ EVT_OPC_START_ALL,\n/* 0x67 */ EVT_OPC_STOP_OTHER,\n/* 0x68 */ EVT_OPC_START_OTHER,\n/* 0x69 */ EVT_OPC_STOP_ID,\n/* 0x6A */ EVT_OPC_START_ID,\n/* 0x6B */ EVT_OPC_CHK_EVT,\n/* 0x6C */ EVT_OPC_INLINE_EVT,\n/* 0x6D */ EVT_OPC_INLINE_EVT_ID,\n/* 0x6E */ EVT_OPC_END_INLINE,\n/* 0x6F */ EVT_OPC_BROTHER_EVT,\n/* 0x70 */ EVT_OPC_BROTHER_EVT_ID,\n/* 0x71 */ EVT_OPC_END_BROTHER,\n/* 0x72 */ EVT_OPC_DEBUG_PUT_MSG,\n/* 0x73 */ EVT_OPC_DEBUG_MSG_CLEAR,\n/* 0x74 */ EVT_OPC_DEBUG_PUT_REG,\n/* 0x75 */ EVT_OPC_DEBUG_NAME,\n/* 0x76 */ EVT_OPC_DEBUG_REM,\n/* 0x77 */ EVT_OPC_DEBUG_BP\n};\n\n// Script instruction functions\ns32 evt_end_evt(EvtEntry * entry);\ns32 evt_lbl(EvtEntry * entry);\ns32 evt_goto(EvtEntry * entry);\ns32 evt_do(EvtEntry * entry);\ns32 evt_while(EvtEntry * entry);\ns32 evt_do_break(EvtEntry * entry);\ns32 evt_do_continue(EvtEntry * entry);\ns32 evt_wait_frm(EvtEntry * entry);\ns32 evt_wait_msec(EvtEntry * entry);\ns32 evt_halt(EvtEntry * entry);\ns32 evt_if_str_equal(EvtEntry * entry);\ns32 evt_if_str_not_equal(EvtEntry * entry);\ns32 evt_if_str_small(EvtEntry * entry);\ns32 evt_if_str_large(EvtEntry * entry); \ns32 evt_if_str_small_equal(EvtEntry * entry);\ns32 evt_if_str_large_equal(EvtEntry * entry); \ns32 evt_iff_equal(EvtEntry * entry);\ns32 evt_iff_not_equal(EvtEntry * entry);\ns32 evt_iff_small(EvtEntry * entry);\ns32 evt_iff_large(EvtEntry * entry);\ns32 evt_iff_small_equal(EvtEntry * entry);\ns32 evt_iff_large_equal(EvtEntry * entry);\ns32 evt_if_equal(EvtEntry * entry);\ns32 evt_if_not_equal(EvtEntry * entry);\ns32 evt_if_small(EvtEntry * entry);\ns32 evt_if_large(EvtEntry * entry);\ns32 evt_if_small_equal(EvtEntry * entry);\ns32 evt_if_large_equal(EvtEntry * entry);\ns32 evt_if_flag(EvtEntry * entry);\ns32 evt_if_not_flag(EvtEntry * entry);\ns32 evt_else(EvtEntry * entry);\ns32 evt_end_if(EvtEntry * entry);\ns32 evt_switch(EvtEntry * entry);\ns32 evt_switchi(EvtEntry * entry);\ns32 evt_case_equal(EvtEntry * entry);\ns32 evt_case_not_equal(EvtEntry * entry);\ns32 evt_case_small(EvtEntry * entry);\ns32 evt_case_small_equal(EvtEntry * entry);\ns32 evt_case_large(EvtEntry * entry);\ns32 evt_case_large_equal(EvtEntry * entry);\ns32 evt_case_between(EvtEntry * entry);\ns32 evt_case_etc(EvtEntry * entry);\ns32 evt_case_flag(EvtEntry * entry);\ns32 evt_case_or(EvtEntry * entry);\ns32 evt_case_and(EvtEntry * entry);\ns32 evt_case_end(EvtEntry * entry);\ns32 evt_switch_break(EvtEntry * entry);\ns32 evt_end_switch(EvtEntry * entry);\ns32 evt_set(EvtEntry * entry);\ns32 evt_seti(EvtEntry * entry);\ns32 evt_setf(EvtEntry * entry);\ns32 evt_add(EvtEntry * entry);\ns32 evt_sub(EvtEntry * entry);\ns32 evt_mul(EvtEntry * entry);\ns32 evt_div(EvtEntry * entry);\ns32 evt_mod(EvtEntry * entry);\ns32 evt_addf(EvtEntry * entry);\ns32 evt_subf(EvtEntry * entry);\ns32 evt_mulf(EvtEntry * entry);\ns32 evt_divf(EvtEntry * entry);\ns32 evt_set_read(EvtEntry * entry);\ns32 evt_set_readf(EvtEntry * entry);\ns32 evt_read(EvtEntry * entry);\ns32 evt_read2(EvtEntry * entry);\ns32 evt_read3(EvtEntry * entry);\ns32 evt_read4(EvtEntry * entry);\ns32 evt_read_n(EvtEntry * entry);\ns32 evt_readf(EvtEntry * entry);\ns32 evt_readf2(EvtEntry * entry);\ns32 evt_readf3(EvtEntry * entry);\ns32 evt_readf4(EvtEntry * entry);\ns32 evt_readf_n(EvtEntry * entry);\ns32 evt_clamp_int(EvtEntry * entry);\ns32 evt_set_user_wrk(EvtEntry * entry);\ns32 evt_set_user_flg(EvtEntry * entry);\ns32 evt_alloc_user_wrk(EvtEntry * entry);\ns32 evt_and(EvtEntry * entry);\ns32 evt_andi(EvtEntry * entry);\ns32 evt_or(EvtEntry * entry);\ns32 evt_ori(EvtEntry * entry);\ns32 evt_set_frame_from_msec(EvtEntry * entry);\ns32 evt_set_msec_from_frame(EvtEntry * entry);\ns32 evt_set_ram(EvtEntry * entry);\ns32 evt_set_ramf(EvtEntry * entry);\ns32 evt_get_ram(EvtEntry * entry);\ns32 evt_get_ramf(EvtEntry * entry);\ns32 evt_setr(EvtEntry * entry);\ns32 evt_setrf(EvtEntry * entry);\ns32 evt_getr(EvtEntry * entry);\ns32 evt_getrf(EvtEntry * entry);\ns32 evt_user_func(EvtEntry * entry);\ns32 evt_run_evt(EvtEntry * entry);\ns32 evt_run_evt_id(EvtEntry * entry);\ns32 evt_run_child_evt(EvtEntry * entry);\ns32 evt_restart_evt(EvtEntry * entry);\ns32 evt_delete_evt(EvtEntry * entry);\ns32 evt_set_pri(EvtEntry * entry);\ns32 evt_set_spd(EvtEntry * entry);\ns32 evt_set_type(EvtEntry * entry);\ns32 evt_stop_all(EvtEntry * entry);\ns32 evt_start_all(EvtEntry * entry);\ns32 evt_stop_other(EvtEntry * entry);\ns32 evt_start_other(EvtEntry * entry);\ns32 evt_stop_id(EvtEntry * entry);\ns32 evt_start_id(EvtEntry * entry);\ns32 evt_chk_evt(EvtEntry * entry);\ns32 evt_inline_evt(EvtEntry * entry);\ns32 evt_inline_evt_id(EvtEntry * entry);\ns32 evt_end_inline(EvtEntry * entry);\ns32 evt_brother_evt(EvtEntry * entry);\ns32 evt_brother_evt_id(EvtEntry * entry);\ns32 evt_end_brother(EvtEntry * entry);\ns32 evt_debug_put_msg(EvtEntry * entry);\ns32 evt_debug_msg_clear(EvtEntry * entry);\ns32 evt_debug_put_reg(EvtEntry * entry);\ns32 evt_debug_name(EvtEntry * entry);\ns32 evt_debug_rem(EvtEntry * entry);\ns32 evt_debug_bp(EvtEntry * entry);\n\n/*\n    Executes an entry's script until it pauses or finishes\n*/\ns32 evtmgrCmd(EvtEntry * entry);\n\n/*\n    Gets the value of an evt variable\n*/\ns32 evtGetValue(EvtEntry * entry, EvtVar variable);\n\n// evtGetNumber (unused)\n\n/*\n    Sets the value of an evt variable\n*/\ns32 evtSetValue(EvtEntry * entry, EvtVar variable, s32 value);\n\n/*\n    Gets the value of a float evt variable\n*/\nf32 evtGetFloat(EvtEntry * entry, EvtVar variable);\n\n/*\n    Sets the value of a float evt variable\n*/\nf32 evtSetFloat(EvtEntry * entry, EvtVar variable, f32 value);\n\n// TODO: static?\n\n/*\n    Returns a pointer to the instruction after the specified label\n    in an entry's script\n*/\nEvtScriptCode * evtSearchLabel(EvtEntry * entry, s32 id); // inlined\n\n/*\n    Returns a pointer to the instruction after the next else on the\n    current if else depth in an entry's script\n*/\nEvtScriptCode * evtSearchElse(EvtEntry * entry);\n\n/*\n    Returns a pointer to the instruction after the next end if on the\n    current if else depth in an entry's script\n*/\nEvtScriptCode * evtSearchEndIf(EvtEntry * entry);\n\n/*\n    Returns a pointer to the the next end switch on the current switch\n    depth in an entry's script\n*/\nEvtScriptCode * evtSearchEndSwitch(EvtEntry * entry);\n\n/*\n    Returns a pointer to the next case or end switch on the current\n    switch depth in an entry's script\n*/\nEvtScriptCode * evtSearchCase(EvtEntry * entry);\n\n/*\n    Returns a pointer to the instruction after the next while on the\n    current do while depth in an entry's script\n*/\nEvtScriptCode * evtSearchWhile(EvtEntry * entry);\n\n/*\n    Returns a pointer to the next while instruction on the current do\n    while depth in an entry's script\n*/\nEvtScriptCode * evtSearchJustBeforeWhile(EvtEntry * entry);\n\nDECOMP_STATIC(char evt_debug_put_reg_str[256])\n\nCPP_WRAPPER_END()\n\n#define EVT_DECLARE_USER_FUNC(symbol, argCount) \\\n    s32 symbol(EvtEntry * script, bool isFirstCall);\n\n#define EVT_UNKNOWN_USER_FUNC(symbol) \\\n    s32 symbol(EvtEntry * script, bool isFirstCall);\n\n#define EVT_DEFINE_USER_FUNC(name) \\\n    s32 name(EvtEntry * evt, bool isFirstCall)\n\n#define EVT_DECLARE(symbol) \\\n    extern EvtScriptCode symbol[];\n\n#define EVT_CMD_(opcode) \\\n    (0 << 16) | opcode\n\n#define EVT_CMD(opcode, ...) \\\n    ((sizeof((EvtScriptCode[]){__VA_ARGS__})/sizeof(EvtScriptCode)) << 16) | (opcode), \\\n    __VA_ARGS__\n\n#define UF(id) ((id) - EVTDAT_UF_BASE)\n#define UW(id) ((id) - EVTDAT_UW_BASE)\n#define GSW(id) ((id) - EVTDAT_GSW_BASE)\n#define LSW(id) ((id) - EVTDAT_LSW_BASE)\n#define GSWF(id) ((id) - EVTDAT_GSWF_BASE)\n#define LSWF(id) ((id) - EVTDAT_LSWF_BASE)\n#define GF(id) ((id) - EVTDAT_GF_BASE)\n#define LF(id) ((id) - EVTDAT_LF_BASE)\n#define GW(id) ((id) - EVTDAT_GW_BASE)\n#define LW(id) ((id) - EVTDAT_LW_BASE)\n#define FLOAT(value) (((s32) ((value) * 1024.f)) - EVTDAT_FLOAT_BASE)\n\n#define PTR(addr) \\\n    ((s32)(addr))\n    \n#define EVT_NULLPTR (-EVTDAT_ADDR_BASE)\n\n#define EVT_BEGIN(symbol) \\\n    EvtScriptCode symbol[] = {\n\n#define EVT_END() \\\n    EVT_CMD_(EVT_OPC_END_SCRIPT) \\\n    };\n\n/*\n    Instructions\n*/\n\n#define RETURN() \\\n    EVT_CMD_(EVT_OPC_END_EVT),\n\n#define LBL(id) \\\n    EVT_CMD(EVT_OPC_LBL, id),\n#define GOTO(id) \\\n    EVT_CMD(EVT_OPC_GOTO, id),\n\n#define DO(n) \\\n    EVT_CMD(EVT_OPC_DO, n),\n#define WHILE() \\\n    EVT_CMD_(EVT_OPC_WHILE),\n#define DO_BREAK() \\\n    EVT_CMD_(EVT_OPC_DO_BREAK),\n#define DO_CONTINUE() \\\n    EVT_CMD_(EVT_OPC_DO_CONTINUE),\n\n#define WAIT_FRM(frames) \\\n    EVT_CMD(EVT_OPC_WAIT_FRM, frames),\n#define WAIT_MSEC(msecs) \\\n    EVT_CMD(EVT_OPC_WAIT_MSEC, msecs),\n#define HALT(condition) \\\n    EVT_CMD(EVT_OPC_HALT, condition),\n\n#define IF_STR_EQUAL(s1, s2) \\\n    EVT_CMD(EVT_OPC_IF_STR_EQUAL, s1, s2),\n#define IF_STR_NOT_EQUAL(s1, s2) \\\n    EVT_CMD(EVT_OPC_IF_STR_NOT_EQUAL, s1, s2),\n#define IF_STR_SMALL(s1, s2) \\\n    EVT_CMD(EVT_OPC_IF_STR_SMALL, s1, s2),\n#define IF_STR_LARGE(s1, s2) \\\n    EVT_CMD(EVT_OPC_IF_STR_LARGE, s1, s2),\n#define IF_STR_SMALL_EQUAL(s1, s2) \\\n    EVT_CMD(EVT_OPC_IF_STR_SMALL_EQUAL, s1, s2),\n#define IF_STR_LARGE_EQUAL(s1, s2) \\\n    EVT_CMD(EVT_OPC_IF_STR_LARGE_EQUAL, s1, s2),\n\n#define IFF_EQUAL(f1, f2) \\\n    EVT_CMD(EVT_OPC_IFF_EQUAL, f1, f2),\n#define IFF_NOT_EQUAL(f1, f2) \\\n    EVT_CMD(EVT_OPC_IFF_NOT_EQUAL, f1, f2),\n#define IFF_SMALL(f1, f2) \\\n    EVT_CMD(EVT_OPC_IFF_SMALL, f1, f2),\n#define IFF_LARGE(f1, f2) \\\n    EVT_CMD(EVT_OPC_IFF_LARGE, f1, f2),\n#define IFF_SMALL_EQUAL(f1, f2) \\\n    EVT_CMD(EVT_OPC_IFF_SMALL_EQUAL, f1, f2),\n#define IFF_LARGE_EQUAL(f1, f2) \\\n    EVT_CMD(EVT_OPC_IFF_LARGE_EQUAL, f1, f2),\n\n#define IF_EQUAL(v1, v2) \\\n    EVT_CMD(EVT_OPC_IF_EQUAL, v1, v2),\n#define IF_NOT_EQUAL(v1, v2) \\\n    EVT_CMD(EVT_OPC_IF_NOT_EQUAL, v1, v2),\n#define IF_SMALL(v1, v2) \\\n    EVT_CMD(EVT_OPC_IF_SMALL, v1, v2),\n#define IF_LARGE(v1, v2) \\\n    EVT_CMD(EVT_OPC_IF_LARGE, v1, v2),\n#define IF_SMALL_EQUAL(v1, v2) \\\n    EVT_CMD(EVT_OPC_IF_SMALL_EQUAL, v1, v2),\n#define IF_LARGE_EQUAL(v1, v2) \\\n    EVT_CMD(EVT_OPC_IF_LARGE_EQUAL, v1, v2),\n\n#define IF_FLAG(value, mask) \\\n    EVT_CMD(EVT_OPC_IF_FLAG, value, mask),\n#define IF_NOT_FLAG(value, mask) \\\n    EVT_CMD(EVT_OPC_IF_NOT_FLAG, value, mask),\n\n#define ELSE() \\\n    EVT_CMD_(EVT_OPC_ELSE),\n#define END_IF() \\\n    EVT_CMD_(EVT_OPC_END_IF),\n\n#define SWITCH(value) \\\n    EVT_CMD(EVT_OPC_SWITCH, value),\n#define SWITCHI(value) \\\n    EVT_CMD(EVT_OPC_SWITCHI, value),\n\n#define CASE_EQUAL(value) \\\n    EVT_CMD(EVT_OPC_CASE_EQUAL, value),\n#define CASE_NOT_EQUAL(value) \\\n    EVT_CMD(EVT_OPC_CASE_NOT_EQUAL, value),\n#define CASE_SMALL(value) \\\n    EVT_CMD(EVT_OPC_CASE_SMALL, value),\n#define CASE_LARGE(value) \\\n    EVT_CMD(EVT_OPC_CASE_LARGE, value),\n#define CASE_SMALL_EQUAL(value) \\\n    EVT_CMD(EVT_OPC_CASE_SMALL_EQUAL, value),\n#define CASE_LARGE_EQUAL(value) \\\n    EVT_CMD(EVT_OPC_CASE_LARGE_EQUAL, value),\n#define CASE_ETC() \\\n    EVT_CMD_(EVT_OPC_CASE_ETC),\n#define CASE_OR(value) \\\n    EVT_CMD(EVT_OPC_CASE_OR, value),\n#define CASE_AND(value) \\\n    EVT_CMD(EVT_OPC_CASE_AND, value),\n#define CASE_FLAG(value) \\\n    EVT_CMD(EVT_OPC_CASE_FLAG, value),\n#define CASE_END() \\\n    EVT_CMD_(EVT_OPC_CASE_END),\n#define EVT_CASE_BETWEEN(min, max) \\\n    EVT_CMD(EVT_OPC_CASE_BETWEEN, min, max),\n#define SWITCH_BREAK() \\\n    EVT_CMD_(EVT_OPC_SWITCH_BREAK),\n#define END_SWITCH() \\\n    EVT_CMD_(EVT_OPC_END_SWITCH),\n\n#define SET(var, value) \\\n    EVT_CMD(EVT_OPC_SET, var, value),\n#define SETI(var, value) \\\n    EVT_CMD(EVT_OPC_SETI, var, value),\n#define SETF(var, value) \\\n    EVT_CMD(EVT_OPC_SETF, var, value),\n\n#define ADD(var, value) \\\n    EVT_CMD(EVT_OPC_ADD, var, value),\n#define SUB(var, value) \\\n    EVT_CMD(EVT_OPC_SUB, var, value),\n#define MUL(var, value) \\\n    EVT_CMD(EVT_OPC_MUL, var, value),\n#define DIV(var, value) \\\n    EVT_CMD(EVT_OPC_DIV, var, value),\n#define MOD(var, value) \\\n    EVT_CMD(EVT_OPC_MOD, var, value),\n\n#define ADDF(var, value) \\\n    EVT_CMD(EVT_OPC_ADDF, var, value),\n#define SUBF(var, value) \\\n    EVT_CMD(EVT_OPC_SUBF, var, value),\n#define MULF(var, value) \\\n    EVT_CMD(EVT_OPC_MULF, var, value),\n#define DIVF(var, value) \\\n    EVT_CMD(EVT_OPC_DIVF, var, value),\n\n#define SET_READ(addr) \\\n    EVT_CMD(EVT_OPC_SET_READ, addr),\n#define READ(dest) \\\n    EVT_CMD(EVT_OPC_READ, dest),\n#define READ2(dest1, dest2) \\\n    EVT_CMD(EVT_OPC_READ2, dest1, dest2),\n#define READ3(dest1, dest2, dest3) \\\n    EVT_CMD(EVT_OPC_READ3, dest1, dest2, dest3),\n#define READ4(dest1, dest2, dest3, dest4) \\\n    EVT_CMD(EVT_OPC_READ4, dest1, dest2, dest3, dest4),\n#define READ_N(dest, idx) \\\n    EVT_CMD(EVT_OPC_READ_N, dest, idx),\n\n#define SET_READF(addr) \\\n    EVT_CMD(EVT_OPC_SET_READF, addr),\n#define READF(dest) \\\n    EVT_CMD(EVT_OPC_READF, dest),\n#define READF2(dest1, dest2) \\\n    EVT_CMD(EVT_OPC_READF2, dest1, dest2),\n#define READF3(dest1, dest2, dest3) \\\n    EVT_CMD(EVT_OPC_READF3, dest1, dest2, dest3),\n#define READF4(dest1, dest2, dest3, dest4) \\\n    EVT_CMD(EVT_OPC_READF4, dest1, dest2, dest3, dest4),\n#define READF_N(dest, idx) \\\n    EVT_CMD(EVT_OPC_READF_N, dest, idx),\n\n#define CLAMP_INT(var, min, max) \\\n    EVT_CMD(EVT_OPC_CLAMP_INT, var, min, max),\n\n#define SET_USER_WRK(addr) \\\n    EVT_CMD(EVT_OPC_SET_USER_WRK, addr),\n#define SET_USER_FLG(addr) \\\n    EVT_CMD(EVT_OPC_SET_USER_FLG, addr),\n#define ALLOC_USER_WRK(count) \\\n    EVT_CMD(EVT_OPC_ALLOC_USER_WRK, count),\n\n#define AND(dest, mask) \\\n    EVT_CMD(EVT_OPC_AND, dest, mask),\n#define ANDI(dest, mask) \\\n    EVT_CMD(EVT_OPC_ANDI, dest, mask),\n#define OR(dest, mask) \\\n    EVT_CMD(EVT_OPC_OR, dest, mask),\n#define ORI(dest, mask) \\\n    EVT_CMD(EVT_OPC_ORI, dest, mask),\n\n#define SET_FRAME_FROM_MSEC(dest, msecs) \\\n    EVT_CMD(EVT_OPC_SET_FRAME_FROM_MSEC, dest, msecs),\n#define SET_MSEC_FROM_FRAMES(dest, frames) \\\n    EVT_CMD(EVT_OPC_SET_MSEC_FROM_FRAME, dest, frames),\n\n#define SET_RAM(value, addr) \\\n    EVT_CMD(EVT_OPC_SET_RAM, value, addr),\n#define SET_RAMF(value, addr) \\\n    EVT_CMD(EVT_OPC_SET_RAMF, value, addr),\n#define GET_RAM(dest, addr) \\\n    EVT_CMD(EVT_OPC_GET_RAM, dest, addr),\n#define GET_RAMF(dese, addr) \\\n    EVT_CMD(EVT_OPC_GET_RAMF, dest, addr),\n\n#define SETR(dest, value) \\\n    EVT_CMD(EVT_OPC_SETR, dest, value),\n#define SETRF(dest, value) \\\n    EVT_CMD(EVT_OPC_SETRF, dest, value),\n#define GETR(value, dest) \\\n    EVT_CMD(EVT_OPC_GETR, value, dest),\n#define GETRF(value, dest) \\\n    EVT_CMD(EVT_OPC_GETRF, value, dest),\n\n#define USER_FUNC(...) \\\n    EVT_CMD(EVT_OPC_USER_FUNC, (s32) __VA_ARGS__),\n\n#define RUN_EVT(evt) \\\n    EVT_CMD(EVT_OPC_RUN_EVT, evt),\n#define RUN_EVT_ID(evt, dest) \\\n    EVT_CMD(EVT_OPC_RUN_EVT_ID, evt, dest),\n#define RUN_CHILD_EVT(evt) \\\n    EVT_CMD(EVT_OPC_RUN_CHILD_EVT, evt),\n#define DELETE_EVT(id) \\\n    EVT_CMD(EVT_OPC_DELETE_EVT, id),\n#define RESTART_EVT(id) \\\n    EVT_CMD(EVT_OPC_RESTART_EVT, id),\n\n#define SET_PRI(pri) \\\n    EVT_CMD(EVT_OPC_SET_PRI, pri),\n#define SET_SPD(spd) \\\n    EVT_CMD(EVT_OPC_SET_SPD, spd),\n#define SET_TYPE(type) \\\n    EVT_CMD(EVT_OPC_SET_TYPE, type),\n\n#define STOP_ALL(type) \\\n    EVT_CMD(EVT_OPC_STOP_ALL, type),\n#define START_ALL(type) \\\n    EVT_CMD(EVT_OPC_START_ALL, type),\n#define STOP_OTHER(type) \\\n    EVT_CMD(EVT_OPC_STOP_OTHER, type),\n#define START_OTHER(type) \\\n    EVT_CMD(EVT_OPC_START_OTHER, type),\n#define STOP_ID(id) \\\n    EVT_CMD(EVT_OPC_STOP_ID, id),\n#define START_ID(id) \\\n    EVT_CMD(EVT_OPC_START_ID, id),\n#define CHK_EVT(id, dest) \\\n    EVT_CMD(EVT_OPC_CHK_EVT, id, dest),\n\n#define INLINE_EVT() \\\n    EVT_CMD_(EVT_OPC_INLINE_EVT),\n#define INLINE_EVT_ID(dest) \\\n    EVT_CMD(EVT_OPC_INLINE_EVT_ID, dest),\n#define END_INLINE() \\\n    EVT_CMD_(EVT_OPC_END_INLINE),\n#define BROTHER_EVT() \\\n    EVT_CMD_(EVT_OPC_BROTHER_EVT),\n#define BROTHER_EVT_ID(dest) \\\n    EVT_CMD(EVT_OPC_BROTHER_EVT_ID, dest),\n#define END_BROTHER() \\\n    EVT_CMD_(EVT_OPC_END_BROTHER),\n\n#define DEBUG_PUT_MSG(msg) \\\n    EVT_CMD(EVT_OPC_DEBUG_PUT_MSG, msg),\n#define DEBUG_MSG_CLEAR() \\\n    EVT_CMD(EVT_OPC_DEBUG_MSG_CLEAR),\n#define DEBUG_PUT_REG(reg) \\\n    EVT_CMD(EVT_OPC_DEBUG_PUT_REG, reg),\n#define DEBUG_NAME(name) \\\n    EVT_CMD(EVT_OPC_DEBUG_NAME, name),\n#define DEBUG_REM() \\\n    EVT_CMD_(EVT_OPC_DEBUG_REM),\n#define DEBUG_BP() \\\n    EVT_CMD_(EVT_OPC_DEBUG_BP),\n/*\n    /dev/fs\n*/\n\n\n\nCPP_WRAPPER(ios::fs)\n\nenum FsErr\n{\n    ERR_FS_EINVAL = -101,\n    ERR_FS_ENOENT = -106\n};\n\nenum FsIoctl\n{\n    IOCTL_FS_FORMAT = 1,\n    IOCTL_FS_GET_STATS = 2,\n    IOCTL_FS_CREATE_DIR = 3,\n    IOCTL_FS_READ_DIR = 4,\n    IOCTL_FS_SET_ATTR = 5,\n    IOCTL_FS_GET_ATTR = 6,\n    IOCTL_FS_DELETE = 7,\n    IOCTL_FS_RENAME = 8,\n    IOCTL_FS_CREATE_FILE = 9,\n    IOCTL_FS_GET_FILE_STATS = 11,\n    IOCTL_FS_SHUTDOWN = 14\n};\n\n/*\n    GetFileStats output\n*/\ntypedef struct\n{\n/* 0x0 */ u32 length;\n/* 0x4 */ u32 position;\n} FsFileStats;\nSIZE_ASSERT(FsFileStats, 8)\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(ios)\n\n#define IOS_ALIGN 32\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(msl::math)\n\n#define PI 3.141592653589793f\n#define PIx2 (PI * 2.0f)\n\ndouble cos(double x);\n#define cosf(x) ((f32)cos(x))\n\ndouble sin(double x);\n#define sinf(x) ((f32)sin(x))\n\ndouble fmod(double numer, double denom);\n#define fmodf(numer, denom) ((f32)fmod(numer, denom))\n\ndouble sqrt(double x);\n#define sqrtf(x) ((f32)sqrt(x))\n\n#define fabs(x) __fabs(x)\n#define fabsf(x) __fabsf(x)\n#define abs(x) __abs(x)\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(msl::stdarg)\n\n// Based on open_rvl\n\ntypedef enum _va_arg_type {\n    arg_ARGPOINTER,\n    arg_WORD,\n    arg_DOUBLEWORD,\n    arg_ARGREAL\n} _va_arg_type;\n\ntypedef struct __va_list_struct {\n    char gpr;\n    char fpr;\n    char* input_arg_area;\n    char* reg_save_area;\n} va_list[1];\n\nvoid* __va_arg(va_list, int);\n\n#ifndef __INTELLISENSE__\n#define va_start(VA_LIST, ARG) ((void)ARG, __builtin_va_info(&VA_LIST))\n#define va_end(VA_LIST) ((void)VA_LIST)\n#define va_arg(VA_LIST, ARG_TYPE)                                              \\\n    (*(ARG_TYPE*)__va_arg(VA_LIST, _var_arg_typeof(ARG_TYPE)))\n#else\n#include <stdarg.h> // makectx-ignore\n#endif\n\nCPP_WRAPPER_END()\n/*\n    Codewarrior's standard library stdio functions\n*/\n\n\nCPP_WRAPPER(msl::stdio)\n\nUSING(msl::stdarg::va_list)\n\nint vsprintf(char * s, const char * format, va_list arg);\n\nint ATTRIBUTE_FORMAT(printf, 3, 4) snprintf(char * dest, size_t n, const char * format, ...);\nint ATTRIBUTE_FORMAT(printf, 2, 3) sprintf(char * dest, const char * format, ...);\nint ATTRIBUTE_FORMAT(scanf, 2, 3) sscanf(const char * str, const char * format, ...);\n\nCPP_WRAPPER_END()\n/*\n    Codewarrior's standard library string functions\n*/\n\n\nCPP_WRAPPER(msl::string)\n\nvoid * memcpy(void * dest, const void * src, size_t num);\nvoid * memset(void * ptr, int value, size_t num);\nchar * strcpy(char * dest, const char * src);\nchar * strncpy(char * dest, const char * src, size_t n);\nchar * strcat(char * dest, const char * src);\nvoid * memmove(void * dest, const void * src, size_t num);\nint memcmp(const void * p1, const void * p2, size_t num);\nint strcmp(const char * s1, const char * s2);\nint strncmp(const char * s1, const char * s2, size_t num);\nconst char * strchr(const char * str, char c);\nsize_t strlen(const char * str);\nconst char * strstr(const char * str1, const char * str2);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(nw4r::snd)\n\n// TODO: these are c++ functions used in spmario.c\n\nextern UNKNOWN_FUNCTION(func_802f4d0c); // nw4r::snd::detail::AxManager::getInstance\nextern UNKNOWN_FUNCTION(func_802f54a0); // nw4r::snd::detail::AxManager::SetMasterVolume\n\nCPP_WRAPPER_END()\n/*\n    acdrv handles action commands for item usage (and possibly other things?)\n*/\n\n\n/*\n    memory is the game's custom library for handling memory allocation\n    Heap 7 is the 'smart' heap, which regularly tries to move allocations forwards in\n    the heap so that free space is in a larger block at the end. Allocations are accessed\n    by structs instead of direct pointers, since the data location can change.\n*/\n\n\n/*\n    Revolution SDK MEM Library\n*/\n\n\n\nCPP_WRAPPER(wii::mem)\n\ntypedef struct _MEMAllocation\n{\n/* 0x0 */ u16 magic; // 'UD' / 'FR'\n/* 0x2 */ u16 flags;\n/* 0x4 */ u32 size;\n/* 0x8 */ struct _MEMAllocation * prev;\n/* 0xC */ struct _MEMAllocation * next;\n} MEMAllocation;\nSIZE_ASSERT(MEMAllocation, 0x10)\n\ntypedef struct _MEMEXPHeap\n{\n/* 0x00 */ u32 magic; // 'EXPH'\n/* 0x04 */ struct _MEMEXPHeap * prevHeap;\n/* 0x08 */ struct _MEMEXPHeap * nextHeap;\n/* 0x0C */ u8 unknown_0xc[0x18 -  0xc];\n/* 0x18 */ void * start;\n/* 0x1C */ void * end;\n/* 0x20 */ u8 unknown_0x20[0x3c - 0x20];\n/* 0x3C */ MEMAllocation * firstFree;\n/* 0x40 */ MEMAllocation * lastFree;\n/* 0x44 */ MEMAllocation * firstUsed;\n/* 0x48 */ MEMAllocation * lastUsed;\n/* 0x4C */ u8 unknown_0x4c[0x50 - 0x4c];\n} MEMEXPHeap;\nSIZE_ASSERT(MEMEXPHeap, 0x50)\n\n#define MEM_FLAG_FILL_0 (1 << 0) // initialise allocated memory as 0\n#define MEM_FLAG_THREAD_CONTROL (1 << 2) // use mutexes for access when handling heap\n\ntypedef void * MEMHeapHandle;\n\nUNKNOWN_FUNCTION(FindContainHeap_);\nUNKNOWN_FUNCTION(MEMiInitHeapHead);\nUNKNOWN_FUNCTION(MEMiFinalizeHeap);\nMEMHeapHandle MEMFindContainHeap(void * ptr);\nUNKNOWN_FUNCTION(AllocUsedBlockFromFreeBlock_);\nUNKNOWN_FUNCTION(AllocFromHead_);\nUNKNOWN_FUNCTION(AllocFromTail_);\nUNKNOWN_FUNCTION(RecycleRegion_);\nMEMHeapHandle MEMCreateExpHeapEx(void * memory, size_t size, s32 flags);\nvoid MEMDestroyExpHeap(MEMHeapHandle handle);\nvoid * MEMAllocFromExpHeapEx(MEMHeapHandle handle, size_t size, u32 alignment);\nvoid MEMFreeToExpHeap(MEMHeapHandle handle, void * ptr);\nsize_t MEMGetAllocatableSizeForExpHeapEx(MEMHeapHandle handle, u32 alignment);\nsize_t MEMGetSizeForMBlockExpHeap(void * ptr);\nUNKNOWN_FUNCTION(MEMCreateFrmHeapEx);\nUNKNOWN_FUNCTION(MEMDestroyFrmHeap);\nUNKNOWN_FUNCTION(MEMAllocFromFrmHeapEx);\nUNKNOWN_FUNCTION(MEMFreeToFrmHeap);\nUNKNOWN_FUNCTION(MEMGetAllocatableSizeForFrmHeapEx);\nUNKNOWN_FUNCTION(AllocatorAllocForExpHeap_);\nUNKNOWN_FUNCTION(AllocatorFreeForExpHeap_);\nUNKNOWN_FUNCTION(AllocatorAllocForFrmHeap_);\nUNKNOWN_FUNCTION(AllocatorFreeForFrmHeap_);\nUNKNOWN_FUNCTION(MEMAllocFromAllocator);\nUNKNOWN_FUNCTION(MEMFreeToAllocator);\nUNKNOWN_FUNCTION(MEMInitAllocatorForExpHeap);\nUNKNOWN_FUNCTION(MEMInitAllocatorForFrmHeap);\nUNKNOWN_FUNCTION(MEMInitList);\nUNKNOWN_FUNCTION(MEMAppendListObject);\nUNKNOWN_FUNCTION(MEMRemoveListObject);\nUNKNOWN_FUNCTION(MEMGetNextListObject);\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::filemgr)\n\nstruct _FileEntry;\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::memory)\n\nUSING(spm::filemgr::_FileEntry)\nUSING(wii::gx::GXTexObj)\nUSING(wii::mem::MEMHeapHandle)\n\n#define MEM1_HEAP_COUNT 3\n#define MEM2_HEAP_COUNT 6\n#define HEAP_COUNT 9\n#define SMART_HEAP_ID 7\n#define SMART_ALLOCATION_MAX 2048\n\nenum Heap\n{\n/* 0x0 */ HEAP_MAIN,\n/* 0x1 */ HEAP_MAP,\n/* 0x2 */ HEAP_MEM1_UNUSED,\n/* 0x3 */ HEAP_EXT,\n/* 0x4 */ HEAP_EFFECT,\n/* 0x5 */ HEAP_WPAD,\n/* 0x6 */ HEAP_SOUND,\n/* 0x7 */ HEAP_SMART,\n/* 0x8 */ HEAP_MEM2_UNUSED\n};\n\nenum HeapSizeType\n{\n/* 0x0 */ HEAPSIZE_PERCENT_REMAINING,\n/* 0x1 */ HEAPSIZE_ABSOLUTE_KB\n};\n\ntypedef struct\n{\n/* 0x0 */ s32 type; // see enum above\n/* 0x4 */ s32 size;\n} HeapSize;\nSIZE_ASSERT(HeapSize, 0x8)\n\nDECOMP_STATIC(HeapSize memory_size_table[9])\n\ntypedef struct\n{\n/* 0x00 */ MEMHeapHandle heapHandle[HEAP_COUNT]; // pointer to the MEM library's heap struct\n/* 0x24 */ void * heapStart[HEAP_COUNT]; // pointer to the start of the heap\n/* 0x48 */ void * heapEnd[HEAP_COUNT]; // pointer to the end of the heap\n} MemWork;\nSIZE_ASSERT(MemWork, 0x6c)\n\nDECOMP_STATIC(MemWork memory_work)\nDECOMP_STATIC(MemWork * memory_wp)\n\ntypedef struct _SmartAllocation\n{\n/* 0x00 */ void * data; // space on the smart heap for the user to put their data,\n                        // may change during lifetime\n/* 0x04 */ size_t size; // size of the space for data on the smart heap\n/* 0x08 */ struct _FileEntry * fileEntry; // set if this allocation is being used for a file,\n                                          // gives special behaviour\n/* 0x0C */ u16 flag; // 1 for in use, 0 otherwise\n/* 0x0E */ u8 type; // used to group for de-allocation\n/* 0x0F */ u8 unknown_0xf; // padding?\n/* 0x10 */ size_t spaceAfter; // space after the data before the next allocated data\n                              // (or the end of the heap)\n/* 0x14 */ struct _SmartAllocation * next; // next item in the allocated or free linked list\n/* 0x18 */ struct _SmartAllocation * prev; // previous item in the allocated or free linked list\n} SmartAllocation;\nSIZE_ASSERT(SmartAllocation, 0x1c)\n\ntypedef struct\n{\n/* 0x0000 */ void * heapStart; // pointer to the block of allocated memory to work with\n/* 0x0004 */ SmartAllocation allocations[SMART_ALLOCATION_MAX];\n/* 0xE004 */ size_t heapStartSpace; // free space at the beginning of the heap\n/* 0xE008 */ SmartAllocation * allocatedStart; // first item in the allocated linked list\n/* 0xE00C */ SmartAllocation * allocatedEnd; // last item in the allocated linked list\n/* 0xE010 */ SmartAllocation * freeStart; // first item in free allocation linked list\n/* 0xE014 */ SmartAllocation * freeEnd; // last item in free allocation linked list\n/* 0xE018 */ u32 freedThisFrame; // number of allocations freed this frame\n} SmartWork;\nSIZE_ASSERT(SmartWork, 0xe01c)\n\nDECOMP_STATIC(SmartWork memory_smartWork)\nDECOMP_STATIC(SmartWork * memory_swp)\n\nextern s32 g_bFirstSmartAlloc;\n\n/*\n    Initialise heaps\n*/\nvoid memInit();\n\n/*\n    Clear the contents of a heap\n*/\nvoid memClear(s32 heapId);\n\n/*\n    Allocate a block of memory from a heap\n*/\nvoid * __memAlloc(s32 heapId, size_t size);\n\n/*\n    Free a block of memory back to a heap\n*/\nvoid __memFree(s32 heapId, void * ptr);\n\n/*\n    Initialise the smart heap (requires memInit to have ran)\n*/\nvoid smartInit();\n\n/*\n    Frees all allocations of a certain type\n    Freeing type 3 also frees type 4\n*/  \nvoid smartAutoFree(s32 type);\n\n/*\n    Frees a smart allocation back to the smart heap\n*/\nvoid smartFree(SmartAllocation * lp);\n\n/*\n    Allocates memory from the smart heap of a certain type\n*/\nSmartAllocation * smartAlloc(size_t size, u8 type);\n\n/*\n    Moves allocations forwards in the heap where possible to collect empty space\n    into a larger block at the end\n*/\nvoid smartGarbage();\n\n/*\n    Sets up a GXTexObj with an image stored behind a smart allocation\n*/\nGXTexObj * smartTexObj(GXTexObj * texObj, SmartAllocation * imageAllocation);\n\n// New to SPM:\n\n// TODO: C++\n\n/*\n    C++ operator new\n*/\nvoid * __nw__FUl(size_t size);\n\n/*\n    C++ operator delete\n*/\nvoid __dl__FPv(void * ptr);\n\n/*\n    Frees a block of memory back to heap 0\n*/\nvoid __sys_free(void * ptr);\n\nCPP_WRAPPER_END()\n\n/*\n    Functions to access files on the game's disc\n*/\n\n\n/*\n    dvdmgr provides lower level file reading than Filemgr\n*/\n\n\n\n\nCPP_WRAPPER(wii::dvd)\n\nUSING(wii::os::OSThreadQueue)\n\n#define DVD_ALIGN 32\n\nstruct _DVDCommandBlock;\ntypedef void (DVDCBCallback)(s32 code, struct _DVDCommandBlock * block);\n\ntypedef struct _DVDCommandBlock\n{\n/* 0x00 */ u8 unknown_0x0[0x8 - 0x0];\n/* 0x08 */ s32 command;\n/* 0x0C */ s32 state;\n/* 0x10 */ u32 offset;\n/* 0x14 */ u8 unknown_0x14[0x28 - 0x14];\n/* 0x28 */ DVDCBCallback * callback;\n/* 0x2C */ void * userData;\n} DVDCommandBlock;\nSIZE_ASSERT(DVDCommandBlock, 0x30)\n\ntypedef struct _DVDFileInfo\n{\n/* 0x00 */ DVDCommandBlock commandBlock;\n/* 0x30 */ u32 startAddr;\n/* 0x34 */ u32 length;\n/* 0x38 */ u8 unknown_0x38[0x3c - 0x38];\n} DVDFileInfo;\nSIZE_ASSERT(DVDFileInfo, 0x3c)\n\ntypedef void (DVDFICallback)(s32 code, struct _DVDFileInfo * fileInfo);\n\ntypedef struct\n{\n    u8 isDir : 8;\n    u32 stringOffset : 24;\n    union\n    {\n        struct\n        {\n            u32 unknown_0x4;\n            u32 next;\n        } dir;\n        struct\n        {\n            u32 startAddr;\n            u32 length;\n        } file;\n    };\n} FstEntry;\nSIZE_ASSERT(FstEntry, 0xc)\n\ntypedef struct\n{\n    u32 entrynum;\n    u32 location;\n    u32 next;\n} DVDDir;\nSIZE_ASSERT(DVDDir, 0xc)\n\ntypedef struct\n{\n    u32 entrynum;\n    BOOL isDir;\n    const char * name;\n} DVDDirEntry;\nSIZE_ASSERT(DVDDirEntry, 0xc)\n\n// Just a normal string literal, but useful for riivo detection\nextern char devDiStr[]; // \"/dev/di\"\n\nDECOMP_STATIC(OSThreadQueue __DVDThreadQueue)\nDECOMP_STATIC(u32 MaxEntryNum)\nDECOMP_STATIC(char * FstStringStart)\nDECOMP_STATIC(FstEntry * FstStart)\nDECOMP_STATIC(u32 PauseFlag)\nDECOMP_STATIC(u32 executing)\n\n\nUNKNOWN_FUNCTION(__DVDFSInit);\ns32 DVDConvertPathToEntrynum(const char * path);\ns32 DVDFastOpen(s32 entrynum, DVDFileInfo * fileInfo);\ns32 DVDClose(DVDFileInfo * fileInfo);\ns32 DVDReadAsyncPrio(DVDFileInfo * fileInfo, void * addr, s32 length, s32 offset,\n                     DVDFICallback * callback, s32 priority);\nUNKNOWN_FUNCTION(cbForReadAsync);\ns32 DVDReadPrio(DVDFileInfo * fileInfo, void * dest, s32 length, s32 offset, s32 priority);\nUNKNOWN_FUNCTION(cbForReadSync);\nUNKNOWN_FUNCTION(StampCommand);\nUNKNOWN_FUNCTION(defaultOptionalCommandChecker);\nUNKNOWN_FUNCTION(DVDInit);\nUNKNOWN_FUNCTION(stateReadingFST);\nUNKNOWN_FUNCTION(cbForStateReadingFST);\nUNKNOWN_FUNCTION(FatalAlarmHandler);\nUNKNOWN_FUNCTION(cbForStateError);\nUNKNOWN_FUNCTION(cbForStoreErrorCode1);\nUNKNOWN_FUNCTION(cbForStoreErrorCode2);\nUNKNOWN_FUNCTION(CategorizeError);\nUNKNOWN_FUNCTION(cbForStoreErrorCode3);\nUNKNOWN_FUNCTION(cbForStateGettingError);\nUNKNOWN_FUNCTION(cbForUnrecoveredError);\nUNKNOWN_FUNCTION(cbForUnrecoveredErrorRetry);\nUNKNOWN_FUNCTION(cbForStateGoToRetry);\nUNKNOWN_FUNCTION(stateCheckID);\nUNKNOWN_FUNCTION(cbForStateReadingTOC);\nUNKNOWN_FUNCTION(cbForStateReadingPartitionInfo);\nUNKNOWN_FUNCTION(cbForStateOpenPartition);\nUNKNOWN_FUNCTION(cbForStateOpenPartition2);\nUNKNOWN_FUNCTION(cbForStateCheckID1);\nUNKNOWN_FUNCTION(cbForStateCheckID2);\nUNKNOWN_FUNCTION(stateCoverClosed);\nUNKNOWN_FUNCTION(ResetAlarmHandler);\nUNKNOWN_FUNCTION(cbForStateReset);\nUNKNOWN_FUNCTION(stateDownRotation);\nUNKNOWN_FUNCTION(cbForStateDownRotation);\nUNKNOWN_FUNCTION(stateCoverClosed_CMD);\nUNKNOWN_FUNCTION(cbForStateCoverClosed);\nUNKNOWN_FUNCTION(cbForPrepareCoverRegister);\nUNKNOWN_FUNCTION(CoverAlarmHandler);\nUNKNOWN_FUNCTION(stateReady);\nUNKNOWN_FUNCTION(stateBusy);\nUNKNOWN_FUNCTION(cbForStateBusy);\nUNKNOWN_FUNCTION(DVDReadAbsAsyncPrio);\nUNKNOWN_FUNCTION(DVDInquiryAsync);\nUNKNOWN_FUNCTION(DVDGetCommandBlockStatus);\nUNKNOWN_FUNCTION(DVDGetDriveStatus);\nUNKNOWN_FUNCTION(DVDSetAutoInvalidation);\nUNKNOWN_FUNCTION(DVDResume);\nUNKNOWN_FUNCTION(DVDCancelAsync);\nUNKNOWN_FUNCTION(DVDCancel);\nUNKNOWN_FUNCTION(cbForCancelSync);\nUNKNOWN_FUNCTION(__BS2DVDLowCallback);\nUNKNOWN_FUNCTION(__DVDGetCoverStatus);\nUNKNOWN_FUNCTION(__DVDPrepareResetAsync);\nUNKNOWN_FUNCTION(Callback);\nUNKNOWN_FUNCTION(__DVDPrepareReset);\nUNKNOWN_FUNCTION(__DVDTestAlarm);\nUNKNOWN_FUNCTION(__DVDStopMotorAsync);\nUNKNOWN_FUNCTION(__DVDRestartMotor);\nUNKNOWN_FUNCTION(__DVDClearWaitingQueue);\ns32 __DVDPushWaitingQueue(s32 priority, DVDCommandBlock * commandBlock);\nUNKNOWN_FUNCTION(__DVDPopWaitingQueue);\nUNKNOWN_FUNCTION(__DVDCheckWaitingQueue);\nUNKNOWN_FUNCTION(__DVDGetNextWaitingQueue);\nUNKNOWN_FUNCTION(__DVDDequeueWaitingQueue);\nUNKNOWN_FUNCTION(cbForNandClose);\nUNKNOWN_FUNCTION(cbForNandWrite);\nUNKNOWN_FUNCTION(cbForNandSeek);\nUNKNOWN_FUNCTION(cbForNandCreate);\nUNKNOWN_FUNCTION(cbForNandCreateDir);\nUNKNOWN_FUNCTION(__DVDStoreErrorCode);\nUNKNOWN_FUNCTION(DVDCompareDiskID);\nUNKNOWN_FUNCTION(__DVDShowFatalMessage);\nUNKNOWN_FUNCTION(DVDSetAutoFatalMessaging);\nUNKNOWN_FUNCTION(__DVDGetAutoFatalMessaging);\nUNKNOWN_FUNCTION(__DVDPrintFatalMessage);\nUNKNOWN_FUNCTION(doTransactionCallback);\nUNKNOWN_FUNCTION(doCoverCallback);\nUNKNOWN_FUNCTION(DVDLowInit);\nUNKNOWN_FUNCTION(DVDLowReadDiskId);\nUNKNOWN_FUNCTION(DVDLowOpenPartition);\nUNKNOWN_FUNCTION(DVDLowClosePartition);\nUNKNOWN_FUNCTION(DVDLowUnencryptedRead);\nUNKNOWN_FUNCTION(DVDLowStopMotor);\nUNKNOWN_FUNCTION(DVDLowInquiry);\nUNKNOWN_FUNCTION(DVDLowRequestError);\nUNKNOWN_FUNCTION(DVDLowSetSpinupFlag);\nUNKNOWN_FUNCTION(DVDLowReset);\nUNKNOWN_FUNCTION(DVDLowAudioBufferConfig);\nUNKNOWN_FUNCTION(DVDLowSetMaxRotation);\nUNKNOWN_FUNCTION(DVDLowRead);\nUNKNOWN_FUNCTION(DVDLowSeek);\nUNKNOWN_FUNCTION(DVDLowGetCoverRegister);\nUNKNOWN_FUNCTION(DVDLowPrepareCoverRegister);\nUNKNOWN_FUNCTION(DVDLowGetImmBufferReg);\nUNKNOWN_FUNCTION(DVDLowUnmaskStatusInterrupts);\nUNKNOWN_FUNCTION(DVDLowMaskCoverInterrupt);\nUNKNOWN_FUNCTION(DVDLowClearCoverInterrupt);\nUNKNOWN_FUNCTION(__DVDLowTestAlarm);\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::dvdmgr)\n\nUSING(wii::dvd::DVDFileInfo)\n\ntypedef void (DVDMgrCallback)(s32 result, DVDFileInfo * fileInfo);\n\n#define MAX_DVD_ENTRY 0x200\n\n#define DVD_FLAG_IN_USE 0x8000\n\ntypedef struct\n{\n/* 0x00 */ char path[64];\n/* 0x40 */ DVDFileInfo fileInfo;\n/* 0x7C */ void * dest;\n/* 0x80 */ s32 lengthRemaining;\n/* 0x84 */ s32 offset;\n/* 0x88 */ s32 lengthRead;\n/* 0x8C */ DVDMgrCallback * readCallback;\n/* 0x90 */ u16 flags;\n/* 0x92 */ u16 priority;\n/* 0x94 */ s16 openP3;\n/* 0x96 */ u8 unknown_0x96[0x98 - 0x96]; // possibly padding?\n/* 0x98 */ s32 entrynum;\n} DVDEntry;\nSIZE_ASSERT(DVDEntry, 0x9c)\n\ntypedef struct\n{\n/* 0x0 */ DVDEntry * entries; // array of num\n/* 0x4 */ s32 num; // 0x200\n} DVDWork;\nSIZE_ASSERT(DVDWork, 0x8)\n\nDECOMP_STATIC(DVDWork dvdmgr_work)\nDECOMP_STATIC(DVDWork * dvdmgr_wp)\n\n/*\n    Initialises data used by dvdmgr functions\n*/\nvoid DVDMgrInit();\n\n/*\n    Stub\n*/\nvoid DVDMgrDelete();\n\n/*\n    Opens a file on the disc\n*/\nDVDEntry * DVDMgrOpen(const char * name, s32 priority, s16 param_3);\n\n/*\n    Read from a file synchronously\n*/\ns32 DVDMgrRead(DVDEntry * entry, void * dest, s32 length, s32 offset);\n\n/*\n    Calls an entry's callback\n*/\nDECOMP_STATIC(void dvdmgr__cb(s32 result, DVDFileInfo * fileInfo))\n\n/*\n    Read from a file asynchronously\n*/\ns32 DVDMgrReadAsync(DVDEntry * entry, void * dest, s32 length, s32 offset,\n                    DVDMgrCallback * callback);\n\n/*\n    Close a an entry\n*/\nvoid DVDMgrClose(DVDEntry * entry);\n\n/*\n    Get the length of the file\n*/\ns32 DVDMgrGetLength(DVDEntry * entry);\n\nCPP_WRAPPER_END()\n/*\n    Revolution SDK TPL format\n    Documentation used from http://wiki.tockdom.com/wiki/TPL_(File_Format)\n*/\n\n\n\nCPP_WRAPPER(wii::tpl)\n\n// Unions are offsets in files and pointers after loading\n\nenum ImageFormat\n{\n/* 0x0 */ IMG_FMT_I4,\n/* 0x1 */ IMG_FMT_I8,\n/* 0x2 */ IMG_FMT_IA4,\n/* 0x3 */ IMG_FMT_IA8,\n/* 0x4 */ IMG_FMT_RGB565,\n/* 0x5*/ IMG_FMT_RGB5A3,\n/* 0x6 */ IMG_FMT_RGBA32,\n/* 0x7 */ IMG_FMT_7,\n/* 0x8 */ IMG_FMT_C4,\n/* 0x9 */ IMG_FMT_C8,\n/* 0xA */ IMG_FMT_C14X2,\n/* 0xB */ IMG_FMT_11,\n/* 0xC */ IMG_FMT_12,\n/* 0xD */ IMG_FMT_13,\n/* 0xE */ IMG_FMT_CMPR\n};\n\ntypedef struct\n{\n    u16 height;\n    u16 width;\n    u32 format;\n    union\n    {\n        u32 dataOffset;\n        void * data;\n    };\n    u32 wrapS;\n    u32 wrapT;\n    u32 minFilter;\n    u32 magFilter;\n    f32 LODBias;\n    bool edgeLODEnable;\n    u8 minLOD;\n    u8 maxLOD;\n    bool unpacked;\n} ImageHeader;\nSIZE_ASSERT(ImageHeader, 0x24)\n\ntypedef struct\n{\n    u16 entryCount;\n    bool unpacked;\n    u32 format;\n    union\n    {\n        u32 dataOffset;\n        void * data;\n    };\n} PaletteHeader;\nSIZE_ASSERT(PaletteHeader, 0xc)\n\ntypedef struct\n{\n    union\n    {\n        u32 imageOffset;\n        ImageHeader * image;\n    };\n    union\n    {\n        u32 paletteOffset;\n        PaletteHeader * palette;\n    };\n} ImageTableEntry;\nSIZE_ASSERT(ImageTableEntry, 0x8)\n\ntypedef struct\n{\n    u32 version; // 0x20af30\n    u32 imageCount;\n    union\n    {\n        u32 imageTableOffset;\n        ImageTableEntry * imageTable;\n    };\n} TPLHeader;\nSIZE_ASSERT(TPLHeader, 0xc)\n\n// offset will be a pointer to the table if unpacked\n#define IS_TPL_PACKED(tpl) (tpl->imageTableOffset < (u32) tpl)\n\n#define VALIDATE_TPL_VERSION(line, palette) \\\n    if (palette->version != 0x20af30) \\\n    { \\\n        OSPanic(__FILE__, line, \"invalid version number for texture palette\"); \\\n    }\n\n/*\n    Takes a TPL file and converts all offsets in it to pointers\n*/\nvoid TPLBind(TPLHeader * palette);\n\nUNKNOWN_FUNCTION(TPLGet);\nUNKNOWN_FUNCTION(TPLGetGXTexObjFromPalette);\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::memory)\n\nstruct _SmartAllocation;\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::filemgr)\n\nUSING(spm::dvdmgr::DVDEntry)\nUSING(spm::memory::_SmartAllocation)\nUSING(wii::dvd::DVDFileInfo)\nUSING(wii::tpl::TPLHeader)\n\n#define FILE_ENTRY_MAX 1024\n\nenum FileType\n{\n/* 0x0 */ FILETYPE_0, // home button bins, rel (comp & decomp), setup dats, win/card.dat,\n                      // lyt/title.bin, camera_road.bin\n/* 0x1 */ FILETYPE_1,\n/* 0x2 */ FILETYPE_2,\n/* 0x3 */ FILETYPE_3,\n/* 0x4 */ FILETYPE_TPL, // not used for bg tpls?\n/* 0x5 */ FILETYPE_5, // a/%s (no dash)\n/* 0x6 */ FILETYPE_6,\n/* 0x7 */ FILETYPE_7,\n/* 0x8 */ FILETYPE_8,\n/* 0x9 */ FILETYPE_9,\n/* 0xA */ FILETYPE_10,\n/* 0xB */ FILETYPE_11 // eff/%s/%s.dat, eff/%seffdata.dat\n};\n\ntypedef struct _FileEntry\n{\n/* 0x00 */ u8 state;\n/* 0x01 */ s8 fileType;\n/* 0x02 */ s16 touchCnt;\n/* 0x04 */ u8 unknown_0x4[0x20 - 0x4];\n/* 0x20 */ char path[64]; // size is uncertain\n/* 0x60 */ u8 unknown_0x60[0xa0 - 0x60];\n/* 0xA0 */ u32 length;\n/* 0xA4 */ struct _SmartAllocation * sp; // smart pointer to file data\n/* 0xA8 */ struct _FileEntry * next; // next entry in free or allocated list\n/* 0xAC */ void * readDoneCb;\n/* 0xB0 */ DVDEntry * dvdEntry;\n} FileEntry;\nSIZE_ASSERT(FileEntry, 0xb4)\n\ntypedef struct\n{\n/* 0x00 */ FileEntry * entries; // array of 1024 (FILE_ENTRY_MAX)\n/* 0x04 */ FileEntry * allocatedStart; // first item in the allocated linked list\n/* 0x08 */ FileEntry * allocatedEnd; // last item in the allocated linked list\n/* 0x0C */ FileEntry * freeStart; // first item in the free linked list\n/* 0x10 */ FileEntry * freeEnd; // last item in the allocated linked list\n} FileWork;\nSIZE_ASSERT(FileWork, 0x14)\n\nDECOMP_STATIC(FileWork filemgr_work)\nDECOMP_STATIC(FileWork * filemgr_afp)\n\n/*\n    Initialise entries\n*/\nvoid fileInit();\n\n/*\n    Takes a TPL file and converts all offsets in it to pointers\n*/\nvoid UnpackTexPalette(TPLHeader * palette);\n\n/*\n    Takes a TPL file and converts all pointers in it back to offsets\n*/\nvoid PackTexPalette(TPLHeader * palette);\n\n/*\n    Converts self-pointers in file data to offsets to allow safe moving\n*/\nvoid fileGarbageDataAdrClear(FileEntry * entry);\n\n/*\n    Converts offsets in file data back to self-pointers\n*/\nvoid fileGarbageDataAdrSet(void * data, s32 fileType);\n\n/*\n    Safely moves memory containing file data, preserving any self-pointers\n*/\nvoid fileGarbageMoveMem(void * dest, FileEntry * sourceEntry);\n\nvoid _fileGarbage(s32);\n\n/*\n    Reads a file into memory\n    Calling on its own will be a synchronous load\n    Calling after Asyncf is finished allows accessing data loaded asynchronously\n    Returns -1 if there's an error\n*/\nFileEntry * fileAllocf(s32 fileType, const char * format, ...);\nFileEntry * fileAlloc(const char * path, s32 fileType);\nFileEntry * _fileAlloc(const char * path, s32 fileType, s32 p3);\n\n/*\n    Unloads a file\n*/\nvoid fileFree(FileEntry * entry);\n\nDECOMP_STATIC(void filemgr_dvdReadDoneCallback(s32 result, DVDFileInfo * fileInfo))\n\n/*\n    Loads a file asynchronously\n    Returns a null pointer if the file isn't loaded yet\n*/\nATTRIBUTE_FORMAT(printf, 3, 4)\nFileEntry * fileAsyncf(s32 fileType, s32 p2, const char * format, ...);\nFileEntry * fileAsync(const char * path, s32 fileType, s32 p3);\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::pausewin)\n\nUSING(wii::mtx::Vec2)\nUSING(spm::evtmgr::EvtEntry)\nUSING(spm::filemgr::FileEntry)\n\n#define PAUSE_FLAG_HIGHLIGHT 0x10\n#define PAUSE_FLAG_OSCILLATE 0x100\n\nenum PauseTextureId\n{\n    // Special\n/* 0x00 */ PAUSETEX_NONE = 0, // use with boxOnly\n\n    // Actual textures\n/* 0x00 */ PAUSETEX_CHARACTERS_BTN = 0,\n/* 0x01 */ PAUSETEX_PIXLS_BTN,\n/* 0x02 */ PAUSETEX_ITEMS_BTN,\n/* 0x03 */ PAUSETEX_KEY_ITEMS_BTN,\n/* 0x04 */ PAUSETEX_CHAPTERS_BTN,\n/* 0x05 */ PAUSETEX_CARDS_BTN,\n/* 0x06 */ PAUSETEX_RECIPES_BTN,\n/* 0x07 */ PAUSETEX_MAPS_BTN,\n/* 0x08 */ PAUSETEX_CHAPTER_1_BTN,\n/* 0x09 */ PAUSETEX_CHAPTER_2_BTN,\n/* 0x0A */ PAUSETEX_CHAPTER_3_BTN,\n/* 0x0B */ PAUSETEX_CHAPTER_4_BTN,\n/* 0x0C */ PAUSETEX_CHAPTER_5_BTN,\n/* 0x0D */ PAUSETEX_CHAPTER_6_BTN,\n/* 0x0E */ PAUSETEX_CHAPTER_7_BTN,\n/* 0x0F */ PAUSETEX_CHAPTER_8_BTN\n    // ...\n};\n\nenum PlusWinButtonIdx\n{\n/* 0x0 */ PLUSWIN_BTN_CHARS,\n/* 0x1 */ PLUSWIN_BTN_PIXLS,\n/* 0x2 */ PLUSWIN_BTN_ITEMS,\n/* 0x3 */ PLUSWIN_BTN_KEY_ITEMS,\n/* 0x4 */ PLUSWIN_BTN_CHAPTERS,\n/* 0x5 */ PLUSWIN_BTN_CARDS,\n/* 0x6 */ PLUSWIN_BTN_RECIPES,\n/* 0x7 */ PLUSWIN_BTN_MAPS,\n/* 0x8 */ PLUSWIN_BTN_BG,\n/* 0x9 */ PLUSWIN_BTN_HELP,\n/* 0xA */ PLUSWIN_BTN_STATS\n};\n\nenum PluswinState\n{\n/* 0x00 */ PLUSWIN_STATE_MAIN_MENU = 0,\n/* 0x0A */ PLUSWIN_STATE_KEY_ITEMS = 10,\n/* 0x14 */ PLUSWIN_STATE_CHAPTERS = 20,\n/* 0x1E */ PLUSWIN_STATE_CARDS = 30,\n/* 0x28 */ PLUSWIN_STATE_RECIPES = 40,\n/* 0x32 */ PLUSWIN_STATE_MAPS = 50\n};\n\nstruct _PausewinEntry;\n\ntypedef void (PausewinFunc)(struct _PausewinEntry *);\n\ntypedef struct _PausewinEntry\n{\n/* 0x00 */ u16 flags;\n/* 0x02 */ u16 id;\n/* 0x04 */ Vec2 pos;\n/* 0x0C */ f32 width;\n/* 0x10 */ f32 height;\n/* 0x14 */ Vec2 moveStart;\n/* 0x1C */ Vec2 moveDest;\n/* 0x24 */ Vec2 originalPos;\n/* 0x2C */ f32 scale;\n/* 0x30 */ u8 unknown_0x30[0x34 - 0x30];\n/* 0x34 */ s32 alpha;\n/* 0x38 */ s32 stateProgress;\n/* 0x3C */ s32 state;\n/* 0x40 */ s32 boxOnly;\n/* 0x44 */ s32 textureId;\n/* 0x48 */ s32 priority;\n/* 0x4C */ s32 curMsgLine;\n/* 0x50 */ s32 msgWidth;\n/* 0x54 */ const char * msg;\n/* 0x58 */ u8 unknown_0x58[0x64 - 0x58];\n/* 0x5C */ PausewinFunc * initFunc;\n/* 0x60 */ PausewinFunc * mainFunc;\n/* 0x64 */ PausewinFunc * dispFunc;\n/* 0x68 */ PausewinFunc * lateDispFunc;\n/* 0x6C */ PausewinFunc * deleteFunc;\n} PausewinEntry;\nSIZE_ASSERT(PausewinEntry, 0x78)\n\ntypedef struct \n{\n/* 0x00 */ u32 num;\n/* 0x04 */ PausewinEntry * entries;\n/* 0x08 */ FileEntry * pauseTpl;\n/* 0x0C */ s32 entriesUsingPauseTpl;\n/* 0x10 */ FileEntry * pause2Tpl;\n/* 0x14 */ s32 entriesUsingPause2Tpl;\n/* 0x18 */ s32 * entryIdQueue;\n/* 0x1C */ s32 curMenuId;\n/* 0x20 */ EvtEntry * itemUseEvt;\n/* 0x24 */ s32 itemUseEvtId;\n/* 0x28 */ u8 unknown_0x28[0x2c - 0x28];\n/* 0x2C */ s32 useItemId;\n/* 0x30 */ s32 subMenuOpenButtonIdx;\n/* 0x34 */ s32 currentPixl;\n/* 0x38 */ bool charPixlItemWinOpen;\n/* 0x39 */ u8 unknown_0x39[0x3c - 0x39];\n/* 0x3C */ f32 gameSpeedBackup;\n} PausewinWork;\nSIZE_ASSERT(PausewinWork, 0x40)\n\ntypedef struct\n{\n/* 0x000 */ s16 cursorOff;\n/* 0x002 */ u8 unknown_0x2[0x4 - 0x2];\n/* 0x004 */ s32 entryIds[11];\n/* 0x030 */ u8 unknown_0x30[0x84 - 0x30];\n/* 0x084 */ s32 state;\n/* 0x088 */ s32 selectedButton;\n/* 0x08C */ s32 prevSelectedButton;\n/* 0x090 */ Vec2 cursorMoveDest;\n/* 0x098 */ Vec2 cursorPos;\n/* 0x0A0 */ s8 submenuEntryIds[10];\n/* 0x0AA */ u8 unknown_0xaa[0x164 - 0xaa];\n/* 0x164 */ s32 submenuSelectedButton;\n/* 0x168 */ s32 chapterLevel;\n/* 0x16C */ u8 unknown_0x16c[0x184 - 0x16c];\n/* 0x184 */ EvtEntry * keyItemEvt;\n/* 0x188 */ s32 keyItemEvtId;\n/* 0x18C */ u8 unknown_0x18c[0x1a4 - 0x18c];\n/* 0x1A4 */ s32 selectedItemId;\n/* 0x1A8 */ u32 submenuFlags;\n/* 0x1AC */ bool submenuIsFullClose;\n/* 0x1AD */ u8 unknown_0x1ad[0x1b0 - 0x1ad];\n/* 0x1B0 */ s64 openingTime;\n} PluswinWork;\nSIZE_ASSERT(PluswinWork, 0x1b8)\n\nDECOMP_STATIC(PluswinWork * pausewin_pluswinWp)\nDECOMP_STATIC(PausewinWork * pausewin_wp)\n\nUNKNOWN_FUNCTION(pausewinGetEntry);\nUNKNOWN_FUNCTION(pausewinGetTpl);\nvoid pausewinInit();\nUNKNOWN_FUNCTION(pausewinReInit);\nUNKNOWN_FUNCTION(pausewinGetOpenButtonMask);\nUNKNOWN_FUNCTION(pausewinCheckMoveUp);\nUNKNOWN_FUNCTION(pausewinCheckMoveDown);\nUNKNOWN_FUNCTION(pausewinCheckMoveLeft);\nUNKNOWN_FUNCTION(pausewinCheckMoveRight);\nUNKNOWN_FUNCTION(pausewinCheckPressOk);\nUNKNOWN_FUNCTION(pausewinCheckPressBack);\nvoid pausewinMain();\nUNKNOWN_FUNCTION(pausewinDisp);\nUNKNOWN_FUNCTION(pausewinEntryDisp);\ns32 pausewinEntry(f32 x, f32 y, f32 width, f32 height, bool boxOnly, s32 textureId,\n                  s32 priority, PausewinFunc * initFunc, PausewinFunc * mainFunc,\n                  PausewinFunc * dispFunc, PausewinFunc * lateDispFunc, PausewinFunc * deleteFunc);\nvoid pausewinMoveTo(s32 id, f32 x, f32 y);\nvoid pausewinAppear(s32 id);\nvoid pausewinDisappear(s32 id);\nvoid pausewinDelete(s32 id);\nUNKNOWN_FUNCTION(pausewinGoNeutral);\nUNKNOWN_FUNCTION(pausewinHide);\nUNKNOWN_FUNCTION(pausewinCheckVisible);\nUNKNOWN_FUNCTION(_pausewinDelete);\nvoid pausewinPauseGame();\nvoid pausewinUnpauseGame();\nUNKNOWN_FUNCTION(pausewinUpdate);\nUNKNOWN_FUNCTION(pausewinNumberToString);\nUNKNOWN_FUNCTION(pausewinCheckHavePixls);\nUNKNOWN_FUNCTION(pausewinCheckHaveCards);\nUNKNOWN_FUNCTION(pausewinCheckHaveRecipes);\nUNKNOWN_FUNCTION(pausewinCheckHaveMaps);\nUNKNOWN_FUNCTION(pluswinStubButtonCheck);\nUNKNOWN_FUNCTION(pluswinOpen);\nUNKNOWN_FUNCTION(pluswinClose);\nUNKNOWN_FUNCTION(pluswinCloseFromSubmenu);\nUNKNOWN_FUNCTION(pluswinMain);\nUNKNOWN_FUNCTION(pluswinCursorDisp);\nUNKNOWN_FUNCTION(pluswinStatsDisp);\nUNKNOWN_FUNCTION(pluswinBgDispSub);\nUNKNOWN_FUNCTION(pluswinBgDisp);\nUNKNOWN_FUNCTION(pausewinMsgBoxInit);\nUNKNOWN_FUNCTION(pausewinMsgBoxMain);\nUNKNOWN_FUNCTION(pausewinMsgBoxDisp);\nUNKNOWN_FUNCTION(pausewinMsgBoxDelete);\nvoid pausewinSetMessage(PausewinEntry * entry, s32 itemId, const char * msgName);\nUNKNOWN_FUNCTION(pausewinSetMessageCard);\nUNKNOWN_FUNCTION(pluswinKeyItemWinOpen);\nUNKNOWN_FUNCTION(pluswinKeyItemMain);\nUNKNOWN_FUNCTION(pluswinKeyItemDisp);\nUNKNOWN_FUNCTION(evt_pluswin_select_return_pipe);\nUNKNOWN_FUNCTION(evt_pluswin_get_return_pipe_msg);\nUNKNOWN_FUNCTION(pluswinCheckChapterUnlocked);\nvoid pluswinChapterWinOpen();\nUNKNOWN_FUNCTION(pluswinCloseChapters);\nUNKNOWN_FUNCTION(pluswinIsChapter1Unlocked);\nUNKNOWN_FUNCTION(pluswinIsChapter2Unlocked);\nUNKNOWN_FUNCTION(pluswinIsChapter3Unlocked);\nUNKNOWN_FUNCTION(pluswinIsChapter4Unlocked);\nUNKNOWN_FUNCTION(pluswinIsChapter5Unlocked);\nUNKNOWN_FUNCTION(pluswinIsChapter6Unlocked);\nUNKNOWN_FUNCTION(pluswinIsChapter7Unlocked);\nUNKNOWN_FUNCTION(pluswinIsChapter8Unlocked);\nUNKNOWN_FUNCTION(pluswinChapterCtrlMain);\nUNKNOWN_FUNCTION(pluswinChapterCtrlDisp);\nUNKNOWN_FUNCTION(pluswinChapterLevelDisp);\nUNKNOWN_FUNCTION(pluswinChapterLevelPreviewDisp);\nUNKNOWN_FUNCTION(pluswinChapterButtonDisp);\nUNKNOWN_FUNCTION(pluswinChapterTitleDisp);\nUNKNOWN_FUNCTION(func_8018c7dc);\nUNKNOWN_FUNCTION(func_8018c85c);\nUNKNOWN_FUNCTION(func_8018c8dc);\nUNKNOWN_FUNCTION(func_8018c95c);\nUNKNOWN_FUNCTION(pluswinCardsWinOpen);\nUNKNOWN_FUNCTION(func_8018cf18);\nUNKNOWN_FUNCTION(func_8018d1ac);\nUNKNOWN_FUNCTION(pluswinCardBgMain);\nUNKNOWN_FUNCTION(pluswinCardBgDisp);\nUNKNOWN_FUNCTION(func_8018e9cc);\nUNKNOWN_FUNCTION(func_8018ea4c);\nUNKNOWN_FUNCTION(pluswinCardCtrlDisp);\nUNKNOWN_FUNCTION(func_8018f200);\nUNKNOWN_FUNCTION(pluswinRecipesWinOpen);\nUNKNOWN_FUNCTION(func_801901b0);\nUNKNOWN_FUNCTION(func_80190444);\nUNKNOWN_FUNCTION(func_80190eb8);\nUNKNOWN_FUNCTION(func_80191128);\nUNKNOWN_FUNCTION(func_80191350);\nUNKNOWN_FUNCTION(pluswinMapsWinOpen);\nUNKNOWN_FUNCTION(func_80191ac0);\nUNKNOWN_FUNCTION(func_80191d54);\nUNKNOWN_FUNCTION(func_80192a98);\nUNKNOWN_FUNCTION(func_80192d78);\nUNKNOWN_FUNCTION(func_8019345c);\nUNKNOWN_FUNCTION(func_80193498);\nUNKNOWN_FUNCTION(func_801936b8);\nUNKNOWN_FUNCTION(func_80193860);\nUNKNOWN_FUNCTION(func_80193874);\nUNKNOWN_FUNCTION(func_80193888);\nUNKNOWN_FUNCTION(func_80193a04);\nUNKNOWN_FUNCTION(minuswinOpen);\nUNKNOWN_FUNCTION(minuswinDisp);\nUNKNOWN_FUNCTION(minuswinMain);\nUNKNOWN_FUNCTION(func_801950f8);\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::acdrv)\n\nUSING(spm::memory::SmartAllocation)\nUSING(spm::pausewin::PausewinEntry)\n\nstruct _AcEntry;\ntypedef void (AcFunc)(struct _AcEntry * entry);\ntypedef void (AcDispFunc)(s8 camId, struct _AcEntry * entry);\n\n// Require wii remote pointed at screen\n#define AC_FLAG_POINTER 4\n// Action command paused\n#define AC_FLAG_PAUSED 2\n// Entry allocated for an action command\n#define AC_FLAG_IN_USE 1\n\ntypedef struct _AcEntry\n{\n/* 0x00 */ u16 flags;\n/* 0x02 */ u8 unknown_0x2[0x4 - 0x2];\n/* 0x04 */ s32 type;\n/* 0x08 */ u8 unknown_0x8[0x10 - 0x8];\n/* 0x10 */ const char * name;\n/* 0x14 */ s32 pausewinEntryId;\n/* 0x18 */ s64 startTime;\n/* 0x20 */ u8 unknown_0x20[0x28 - 0x20];\n/* 0x28 */ s32 state;\n/* 0x2C */ AcFunc * initFunc;\n/* 0x30 */ AcFunc * mainFunc;\n/* 0x34 */ AcFunc * deleteFUnc;\n/* 0x38 */ AcDispFunc * dispFunc;\n/* 0x3C */ u8 unknown_0x3c[0x40 - 0x3c];\n} AcEntry;\nSIZE_ASSERT(AcEntry, 0x40)\n\ntypedef struct\n{\n/* 0x0 */ s32 num; // 4\n/* 0x4 */ AcEntry * entries; // array of num length\n} AcWork;\nSIZE_ASSERT(AcWork, 0x8)\n\nDECOMP_STATIC(AcWork acdrv_work)\nDECOMP_STATIC(AcWork * acdrv_wp)\n\ntypedef struct\n{\n/* 0x00 */ AcFunc * initFunc;\n/* 0x04 */ AcFunc * mainFunc;\n/* 0x08 */ AcFunc * deleteFunc;\n/* 0x0C */ AcDispFunc * dispFunc;\n/* 0x10 */ const char * msgName;\n} AcDef;\nSIZE_ASSERT(AcDef, 0x14)\n\nDECOMP_STATIC(AcDef acdrv_acDefs[19])\nDECOMP_STATIC(SmartAllocation * acdrv_lp)\n\n/*\n    Allocates entries\n*/\nvoid acInit();\n\n/*\n    Clears entries\n*/\nvoid acReInit();\n\nUNKNOWN_FUNCTION(func_8003ebb8);\nUNKNOWN_FUNCTION(func_8003ec24);\n\n/*\n    Updates entries based on their state, calls their mainFuncs and queues their dispFuncs\n*/\nvoid acMain();\n\n/*\n    Creates an acEntry based on the acDef of the type specified\n    Types:\n        0 - kirakira otoshi\n        1 - pow block\n        2 - barrier frame\n        3 - koura de pon\n        4 - kachikachi koura\n        5 - biribiri kinoko\n        6 - obake kinoko\n        7 - nemure yoikoyo\n        8 - stop watch\n        9 - nemuri kaihuku\n        10 - honoo sakuretsu\n        11 - koori kaihuku\n        12 - honoo sakuretsu 2\n        13 - honoo sakuretsu 3\n        14 - honoo sakuretsu 4\n        15 - honoo sakuretsu 5\n        16 - nomikomi kaihuku\n        17 - jiwajiwa kinoko\n        18 - koura de pon 2\n*/\nAcEntry * acEntry(s32 type);\n\n/*\n  Returns a value between 12 and 7 depending on how well the player did in the minigame\n*/\ns32 acReturnResults(const char * name);\n\n/*\n    Deletes an entry, calling its deleteFunc and deleting its pausewin entry\n*/\nvoid acDelete(AcEntry * entry);\n\n/*\n    Halts/unhalts all entries\n*/\nvoid acPauseAll();\nvoid acUnpauseAll();\n\nUNKNOWN_FUNCTION(func_8003f6bc);\n\n/*\n    Returns whether any entries are in use\n*/\nbool acIsRunning();\n\n/*\n    Gets an entry by name\n*/\nAcEntry * acNameToPtr(const char * name);\n\n/*\n    Displays the message for the pausewin entry of an ac entry\n*/\nvoid acMsgDisp(PausewinEntry * entry);\n\nUNKNOWN_FUNCTION(func_8003f934);\nUNKNOWN_FUNCTION(func_8004077c);\nUNKNOWN_FUNCTION(func_80040dac);\nUNKNOWN_FUNCTION(func_80040eb4);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::animdrv)\n\nUSING(wii::os::OSTime)\nUSING(wii::mtx::Mtx34)\n\ntypedef void (AnimPoseDisplayCb)(void * param, s32 animGroupIdx, s32 param_3);\n\ntypedef struct \n{\n/* 0x00 */ char name[60];\n/* 0x3C */ void * data;\n} AnimationModelFileAnimTableEntry;\nSIZE_ASSERT(AnimationModelFileAnimTableEntry, 0x40)\n\ntypedef struct \n{\n/* 0x000 */ u8 unknown_0x0[0x148 - 0x0];\n/* 0x148 */ u32 animCount;\n/* 0x14C */ u8 unknown_0x14c[0x1ac - 0x14c];\n/* 0x1AC */ AnimationModelFileAnimTableEntry * anims;\n} AnimationModelFileHeader;\nSIZE_ASSERT(AnimationModelFileHeader, 0x1b0)\n\ntypedef struct\n{\n/* 0x000 */ u8 unknown_0x0[0x110 - 0x0];\n} AnimWork; // Uncertain size;\n\nAnimWork * animGetPtr();\nOSTime animTimeGetTime();\nDECOMP_STATIC(void * animdrv_testAlloc(u32 size))\nvoid animInit();\nvoid animMain();\nUNKNOWN_FUNCTION(textureGroupEntry);\nUNKNOWN_FUNCTION(animGroupEntry);\nUNKNOWN_FUNCTION(animPoseRefresh);\ns32 animPoseEntry(const char * filename, s32 releaseType);\nUNKNOWN_FUNCTION(animPaperPoseEntry);\nUNKNOWN_FUNCTION(func_80042ec8);\nUNKNOWN_FUNCTION(animPosePeraOff);\nUNKNOWN_FUNCTION(animPoseSetLocalTimeRate);\nUNKNOWN_FUNCTION(animPoseSetLocalTime);\nUNKNOWN_FUNCTION(animPoseSetStartTime);\nvoid animPoseSetAnim(s32 id, const char * animName, bool forceReset);\nUNKNOWN_FUNCTION(animPaperPoseGetId);\nUNKNOWN_FUNCTION(animPoseSetPaperAnimGroup);\nUNKNOWN_FUNCTION(animPoseSetPaperAnim);\nUNKNOWN_FUNCTION(func_80043b90);\nUNKNOWN_FUNCTION(func_80043ca4);\nUNKNOWN_FUNCTION(animPoseSetEffect);\nUNKNOWN_FUNCTION(animPoseSetEffectAnim);\nUNKNOWN_FUNCTION(animPoseSetGXFunc);\nUNKNOWN_FUNCTION(animPoseGetLoopTimes);\nUNKNOWN_FUNCTION(animPoseSetFlagF0On);\nUNKNOWN_FUNCTION(animPoseSetFlagF0Off);\nUNKNOWN_FUNCTION(animPoseSetFlagF4On);\nUNKNOWN_FUNCTION(animPoseSetFlagF4Off);\nUNKNOWN_FUNCTION(animPoseSetMaterialLightFlagOn);\nUNKNOWN_FUNCTION(animPoseSetMaterialLightFlagOff);\nUNKNOWN_FUNCTION(animPoseSetMaterialEvtColor);\nUNKNOWN_FUNCTION(animPoseSetMaterialAnmColor);\nUNKNOWN_FUNCTION(animPoseGetFlagF0);\nUNKNOWN_FUNCTION(animPoseGetFlagF4);\nUNKNOWN_FUNCTION(animPoseGetMaterialEvtColor);\nUNKNOWN_FUNCTION(animPoseSetDispCallBack2);\nUNKNOWN_FUNCTION(func_800451c4);\nvoid animPoseMain(s32 id);\nUNKNOWN_FUNCTION(pushGXModelMtx_TransformNode__);\nUNKNOWN_FUNCTION(pushGXModelMtx_JointNode__);\nUNKNOWN_FUNCTION(func_80047170);\nUNKNOWN_FUNCTION(animSetMaterial_Texture);\nUNKNOWN_FUNCTION(animSetMaterial_ChangeTexture);\nUNKNOWN_FUNCTION(materialProc);\nUNKNOWN_FUNCTION(renderProc);\nUNKNOWN_FUNCTION(dispProc);\nUNKNOWN_FUNCTION(animPoseDraw);\nUNKNOWN_FUNCTION(_animPoseDrawMtx);\nvoid animPoseDrawMtx(s32 id, Mtx34 * mtx, s32 xluStage, f32 rotY, f32 scale);\nUNKNOWN_FUNCTION(animSetPaperTexObj);\ns32 animPoseRelease(s32 id);\nUNKNOWN_FUNCTION(animPaperPoseRelease);\nvoid animPoseAutoRelease(s32 releaseType);\nUNKNOWN_FUNCTION(animPaperPoseDisp);\nUNKNOWN_FUNCTION(animPaperPoseDispSub);\nUNKNOWN_FUNCTION(animPoseDisp_MakeExtTexture);\nUNKNOWN_FUNCTION(animSetPaperTexMtx);\nUNKNOWN_FUNCTION(animGroupBaseAsync);\nUNKNOWN_FUNCTION(animPoseGetAnimPosePtr);\nUNKNOWN_FUNCTION(animPoseGetAnimDataPtr);\nAnimationModelFileHeader * animPoseGetAnimBaseDataPtr(s32 id);\nUNKNOWN_FUNCTION(animPoseGetCurrentAnim);\nUNKNOWN_FUNCTION(func_8004ca08);\nUNKNOWN_FUNCTION(func_8004caec);\nUNKNOWN_FUNCTION(func_8004cd30);\nUNKNOWN_FUNCTION(func_8004cfa8);\nUNKNOWN_FUNCTION(evalProc);\nUNKNOWN_FUNCTION(animPoseWorldPositionEvalOn);\nUNKNOWN_FUNCTION(animPoseWorldMatrixEvalOn);\nvoid animPoseSetDispCallback(s32 animPoseId, AnimPoseDisplayCb * cb, void * param);\nUNKNOWN_FUNCTION(animPoseDrawShape);\nUNKNOWN_FUNCTION(func_8004d96c);\nUNKNOWN_FUNCTION(animPoseGetShapeIdx);\ns32 animPoseGetGroupIdx(s32 id, const char * name);\nUNKNOWN_FUNCTION(animPoseGetGroupIdxSubname);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::bgdrv)\n\nvoid bgInit();\nvoid bgMain();\nUNKNOWN_FUNCTION(func_8004e10c);\nUNKNOWN_FUNCTION(bgLoadTpl);\nUNKNOWN_FUNCTION(func_8004e608);\nUNKNOWN_FUNCTION(bgSetColor);\nUNKNOWN_FUNCTION(func_8004e738);\nUNKNOWN_FUNCTION(bgFlagOn);\nUNKNOWN_FUNCTION(bgFlagOff);\nUNKNOWN_FUNCTION(bgFlag8On);\nUNKNOWN_FUNCTION(bgFlag8Off);\nUNKNOWN_FUNCTION(bgMain);\nUNKNOWN_FUNCTION(func_8004ec64);\nUNKNOWN_FUNCTION(func_8004f53c);\nvoid func_8004f5c8(const char *);\nvoid func_8004f5f0(const char *);\n\nCPP_WRAPPER_END()\n/*\n    camdrv handles the game's cameras\n*/\n\n\n\nCPP_WRAPPER(spm::camdrv)\n\nUSING(wii::mtx::Vec3)\nUSING(wii::mtx::Mtx34)\nUSING(wii::mtx::Mtx44)\nUSING(wii::os::OSTime)\n\nstruct _CamEntry;\ntypedef void (CamDispFunc)(struct _CamEntry * entry);\n\n#define CAMFLAG_16_9 0x10000000\n#define CAMFLAG_LoadBin 0x1\n\nenum CameraId\n{\n/* 0x0 */ CAM_ID_0,\n/* 0x1 */ CAM_ID_1,\n/* 0x2 */ CAM_ID_2,\n/* 0x3 */ CAM_ID_3,\n/* 0x4 */ CAM_ID_4,\n/* 0x5 */ CAM_ID_3D,\n/* 0x6 */ CAM_ID_6,\n/* 0x7 */ CAM_ID_7,\n/* 0x8 */ CAM_ID_8,\n/* 0x9 */ CAM_ID_9,\n/* 0xA */ CAM_ID_10,\n/* 0xB */ CAM_ID_2D,\n/* 0xC */ CAM_ID_12,\n/* 0xD */ CAM_ID_DEBUG,\n/* 0xE */ CAM_ID_DEBUG_3D,\n/* 0xF */ CAM_ID_MAX\n};\n\ntypedef struct _CamEntry\n{\n/* 0x000 */ u32 flag; // CAMFLAG defines\n/* 0x004 */ s32 cam_no; // CAM_ID defines\n/* 0x008 */ u16 cameraMode;\n/* 0x00A */ u8 unknown_0xa[0x18 - 0xa];\n/* 0x018 */ u16 scissorX;\n/* 0x01A */ u16 scissorY;\n/* 0x01C */ u16 scissorWidth;\n/* 0x01E */ u16 scissorHeight;\n/* 0x020 */ f32 viewport[6];\n/* 0x038 */ f32 projection[7];\n/* 0x054 */ Mtx34 viewMtx;\n/* 0x084 */ u8 unknown_0x84[0x94-0x84];\n/* 0x094 */ Mtx44 projMtx;\n/* 0x0D4 */ u8 unknown_0xd4[0xf0 - 0xd4];\n/* 0x0F0 */ f32 top;\n/* 0x0F4 */ f32 bottom;\n/* 0x0F8 */ f32 left;\n/* 0x0FC */ f32 right;\n/* 0x100 */ u8 unknown_0x100[0x158 - 0x100];\n/* 0x158 */ s32 isOrtho;\n/* 0x15C */ Vec3 pos;\n/* 0x168 */ Vec3 target;\n/* 0x174 */ Vec3 up;\n/* 0x180 */ f32 targetAngle;\n/* 0x184 */ f32 targetDistance;\n/* 0x188 */ f32 fovY;\n/* 0x18C */ f32 aspect;\n/* 0x190 */ f32 near;\n/* 0x194 */ f32 far;\n/* 0x198 */ u8 unknown_0x198[0x20c - 0x198];\n/* 0x20C */ Vec3 zoomStartPos;\n/* 0x218 */ Vec3 zoomStartTarget;\n/* 0x224 */ Vec3 zoomDestPos;\n/* 0x230 */ Vec3 zoomDestTarget;\n/* 0x23C */ u8 unknown_0x23c[0x240 - 0x23c];\n/* 0x240 */ OSTime zoomStartTime;\n/* 0x248 */ u8 unknown_0x248[0x254 - 0x248];\n/* 0x254 */ void * cameraRoad;\n/* 0x258 */ CamDispFunc * dispFunc;\n/* 0x25C */ u8 unknown_0x25c[0x2f0 - 0x25c];\n} CamEntry;\nSIZE_ASSERT(CamEntry, 0x2f0)\n\n/*\n    Cameras:\n        0-4 unknown\n        5 3d\n        6-10 unknown\n        11 2d\n        12 fade\n        13 dbg\n        14 dbg3d\n*/\nextern CamEntry * camPtrTbl[15];\n\n/*\n    Creates all camera entries and initialises other data used by camdrv\n*/\nvoid camInit();\n\n/*\n    Creates a perspective camera\n*/\nCamEntry * camEntryPersp(f32 fovY, f32 aspect, f32 near, f32 far, f32 param_5,\n                         f32 param_6, s32 cam_no, CamDispFunc * callback);\n\n/*\n    Creates an orthographic camera\n*/\nCamEntry * camEntryOrtho(f32 top, f32 bottom, f32 left, f32 right, f32 near,\n                         f32 far, s32 cam_no, CamDispFunc * callback);\n\nUNKNOWN_FUNCTION(func_800550f8);\n\n/*\n    Updates all cameras\n*/\nvoid camMain();\n\n/*\n    Calls dispDraw for each camera\n*/\nvoid camDraw();\n\n/*\n    Loads a camera road file from disc asynchronously, returns whether it's done\n*/\nbool camLoadRoadAsync(const char * mapName);\n\n/*\n    Loads a camera road file that's already been read from disc\n*/\nvoid camLoadRoadNoRead(void * file);\n\n/*\n    Unloads a camera road file\n*/\nvoid camUnloadRoad();\n\n/*\n    Returns a camera by cam_no\n*/\nCamEntry * camGetPtr(s32 id);\n\n/*\n    Returns the current camera\n*/\nCamEntry * camGetCurPtr();\n\n/*\n    Returns the current cam_no\n*/\nint camGetCurNo();\n\nUNKNOWN_FUNCTION(func_80055b58);\nUNKNOWN_FUNCTION(func_80055bb4);\nUNKNOWN_FUNCTION(func_80055c10);\nUNKNOWN_FUNCTION(func_80055ce0);\nUNKNOWN_FUNCTION(func_80056948);\n\n/*\n    CamDispFunc for the 3d camera\n*/\nvoid cam3dMain(CamEntry * cp);\n\nUNKNOWN_FUNCTION(func_80057cb0);\nUNKNOWN_FUNCTION(func_80057cc8);\nUNKNOWN_FUNCTION(func_80057ce0);\nUNKNOWN_FUNCTION(func_80057da0);\nUNKNOWN_FUNCTION(func_80057e4c);\nUNKNOWN_FUNCTION(func_80057ec4);\nUNKNOWN_FUNCTION(func_80057ee8);\nUNKNOWN_FUNCTION(func_80058128);\n\n/*\n    Converts coordinates in the world to where they appear on screen\n*/\nvoid getScreenPoint(Vec3 * worldPos, Vec3 * screenPosOut);\n\n/*\n    Checks the 3d flag of a camera\n*/\nbool camCheck3d(s32 camId);\n\nUNKNOWN_FUNCTION(func_80058388);\nUNKNOWN_FUNCTION(func_800583b4);\nUNKNOWN_FUNCTION(func_80058404);\nUNKNOWN_FUNCTION(func_8005869c);\nUNKNOWN_FUNCTION(func_800586c8);\nUNKNOWN_FUNCTION(func_80058700);\nUNKNOWN_FUNCTION(func_800587a0);\nUNKNOWN_FUNCTION(func_80058800);\nUNKNOWN_FUNCTION(func_8005881c);\nUNKNOWN_FUNCTION(func_80058840);\n\n/*\n    Just returns false, unclear purpose\n*/\nbool camUnusedCheck();\n\nUNKNOWN_FUNCTION(func_8005885c);\nUNKNOWN_FUNCTION(func_80058b14);\nUNKNOWN_FUNCTION(func_80058c80);\n\nCPP_WRAPPER_END()\n/*\n    casedrv runs scripts when the player interacts with certain HitObjs\n*/\n\n\n/*\n    Hitdrv handles collision with MOBJs or the map\n*/\n\n\n/*\n    mapdrv handles the rendering & collision of the main map model\n*/\n\n\n\nCPP_WRAPPER(spm::hitdrv)\n\nstruct _HitObj;\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::mapdrv)\n\nUSING(spm::hitdrv::_HitObj)\nUSING(wii::gx::GXColor)\nUSING(wii::mtx::Mtx34)\nUSING(wii::mtx::Vec3)\nUSING(wii::tpl::TPLHeader)\n\nextern BOOL __mapdrv_make_dl;\n\ntypedef struct\n{\n/* 0x0 */ u8 unknown_0x0;\n/* 0x1 */ u8 cullMode;\n/* 0x2 */ u8 flags;\n/* 0x3 */ u8 unknown_0x3;\n/* 0x4 */ u32 lightMask;\n/* 0x8 */ u32 attr;\n/* 0xC */ u8 unknown_0xc[0x10 - 0xc];\n} MapFileJointDrawMode;\nSIZE_ASSERT(MapFileJointDrawMode, 0x10)\n\ntypedef struct\n{\n/* 0x0 */ Unk * material;\n/* 0x4 */ Unk * mesh;\n} MapFileJointPart;\nSIZE_ASSERT(MapFileJointPart, 0x8)\n\ntypedef struct _MapFileJoint\n{\n/* 0x00 */ const char * name;\n/* 0x04 */ const char * type;\n/* 0x08 */ struct _MapFileJoint * parent;\n/* 0x0C */ struct _MapFileJoint * firstChild;\n/* 0x10 */ struct _MapFileJoint * nextSibling;\n/* 0x14 */ struct _MapFileJoint * prevSibling;\n/* 0x18 */ Vec3 scale;\n/* 0x24 */ Vec3 rotation;\n/* 0x30 */ Vec3 translation;\n/* 0x3C */ Vec3 bboxMin;\n/* 0x48 */ Vec3 bboxMax;\n/* 0x54 */ u8 unknown_0x54[0x58 - 0x54];\n/* 0x58 */ MapFileJointDrawMode * drawMode;\n/* 0x5C */ s32 partTableCount;\n    // Actually a VLA, length is partTableCount\n/* 0x60 */ MapFileJointPart partTable[1];\n} MapFileJoint;\nSIZE_ASSERT(MapFileJoint, 0x68)\n\ntypedef struct\n{\n/* 0x00 */ u8 unknown_0x0[0x4 - 0x0];\n/* 0x04 */ s32 type;\n/* 0x08 */ f32 startZ;\n/* 0x0C */ f32 endZ;\n/* 0x10 */ GXColor colour;\n} MapFileFog;\nSIZE_ASSERT(MapFileFog, 0x14)\n\ntypedef struct\n{\n/* 0x00 */ u32 fileSize;\n/* 0x04 */ u32 mainDataSize;\n/* 0x08 */ u32 relTableCount;\n/* 0x0C */ u32 chunkTableCount;\n/* 0x10 */ u8 unknown_0x10[0x20 - 0x10];\n} MapFileHeader;\nSIZE_ASSERT(MapFileHeader, 0x20)\n\ntypedef struct\n{\n/* 0x0 */ u32 offset; // into main data\n/* 0x4 */ u32 nameOffset; // into string table\n} MapFileChunk;\nSIZE_ASSERT(MapFileChunk, 0x8)\n\ntypedef struct\n{\n/* 0x00 */ MapFileHeader fileHeader;\n/* 0x20 */ void * mainData;\n/* 0x24 */ Unk * relTable;\n/* 0x28 */ MapFileChunk * chunkTable;\n/* 0x2C */ u8 unknown_0x2c[0x30 - 0x2c];\n/* 0x30 */ const char * stringTable;\n/* 0x34 */ u8 unknown_0x34[0x3c - 0x34];\n/* 0x3C */ u32 flags;\n/* 0x40 */ void * rawFile;\n} MapFileContext;\nSIZE_ASSERT(MapFileContext, 0x44)\n\ntypedef struct\n{\n/* 0x00 */ const char * name;\n/* 0x04 */ const char * type;\n/* 0x08 */ Vec3 position;\n/* 0x14 */ Vec3 rotation;\n/* 0x20 */ Vec3 scale;\n/* 0x2C */ GXColor colour;\n/* 0x30 */ f32 spotAngle;\n/* 0x34 */ f32 angleAttenuation;\n/* 0x38 */ s32 distanceAttenuationType;\n/* 0x3C */ u32 flags;\n/* 0x40 */ s32 version;\n} MapFileLightEntry;\nSIZE_ASSERT(MapFileLightEntry, 0x44)\n\ntypedef struct\n{\n/* 0x0 */ s32 count;\n/* 0x4 */ MapFileLightEntry * entries[1]; // array of length count\n} MapFileLightTable;\nOFFSET_ASSERT(MapFileLightTable, entries, 0x4)\n\ntypedef struct\n{\n/* 0x00 */ const char * meshName;\n/* 0x04 */ Vec3 translation;\n/* 0x10 */ Vec3 rotation;\n/* 0x1C */ Vec3 scale;\n/* 0x28 */ u8 unknown_0x28[0x58 - 0x28];\n/* 0x58 */ s32 frameCount;\n} MapFileMeshTrack;\nSIZE_ASSERT(MapFileMeshTrack, 0x5c)\n\ntypedef struct\n{\n/* 0x0 */ s32 count;\n/* 0x4 */ MapFileMeshTrack * tracks; // array of length count\n} MapFileMeshTracks;\nSIZE_ASSERT(MapFileMeshTracks, 0x8)\n\ntypedef struct\n{\n/* 0x00 */ const char * name;\n/* 0x04 */ u8 unknown_0x4[0x8 - 0x4];\n/* 0x08 */ f32 duration;\n/* 0x0C */ MapFileMeshTracks * meshTracks;\n/* 0x10 */ Unk * materialTrack;\n/* 0x14 */ u8 unknown_0x14[0x20 - 0x14];\n} MapFileAnimData;\nSIZE_ASSERT(MapFileAnimData, 0x20)\n\n#define MAPOBJ_FLAG0_HIDE 1\n\ntypedef struct _MapObj\n{\n/* 0x000 */ u32 flag0;\n/* 0x004 */ u32 flag4;\n/* 0x008 */ u8 blendMode;\n/* 0x009 */ u8 unknown_0x9[0xc - 0x9];\n/* 0x00C */ MapFileJoint * joint;\n/* 0x010 */ GXColor colour;\n/* 0x014 */ u8 unknown_0x14[0x1c - 0x14];\n/* 0x01C */ Vec3 translation;\n/* 0x028 */ Mtx34 modelWorldMtx;\n/* 0x058 */ u8 unknown_0x58[0xb8 - 0x58];\n/* 0x0B8 */ Mtx34 runtimeWorldMtx;\n/* 0x0E8 */ s16 offscreenId;\n/* 0x0EA */ s16 mapEntryId;\n/* 0x0EC */ struct _MapObj * parent;\n/* 0x0F0 */ struct _MapObj * firstChild;\n/* 0x0F4 */ struct _MapObj * nextSibling;\n/* 0x0F8 */ u16 gxBboxLeft;\n/* 0x0FA */ u16 gxBboxTop;\n/* 0x0FC */ u16 gxBboxRight;\n/* 0x0FE */ u16 gxBboxBottom;\n/* 0x100 */ void * dl_buf[8]; // display list pointers\n/* 0x120 */ u32 dl_size[8]; // display list sizes\n/* 0x140 */ u8 unknown_0x140[0x144 - 0x140];\n} MapObj;\nSIZE_ASSERT(MapObj, 0x144)\n\ntypedef struct\n{\n/* 0x00 */ u16 flags;\n/* 0x02 */ u8 unknown_0x2[0x10 - 0x2];\n/* 0x10 */ f32 timePlayed;\n/* 0x14 */ f32 playRate;\n/* 0x18 */ MapFileAnimData * fileData;\n/* 0x1C */ u8 unknown_0x1c[0x28 - 0x1c];\n} MapAnimObj;\nSIZE_ASSERT(MapAnimObj, 0x28)\n\ntypedef void (MapEntryUnloadCb)();\n\n// Internally referred to as a \"kind\"\ntypedef struct\n{\n/* 0x000 */ s32 mapCount; // active MapEntry count (always 1?)\n/* 0x004 */ u16 flags;\n/* 0x006 */ char name[16];\n/* 0x016 */ GXColor colour;\n/* 0x01A */ GXColor blend1;\n/* 0x01E */ GXColor blend2;\n/* 0x022 */ u8 unknown_0x22[0x24 - 0x22];\n/* 0x024 */ MapFileFog fogDefs[2];\n/* 0x04C */ s32 loadStage; // used for mapLoad\n/* 0x050 */ MapFileContext mapDatContext;\n/* 0x094 */ void * mapDat;\n/* 0x098 */ u32 mapDatSize;\n/* 0x09C */ void * tpl;\n/* 0x0A0 */ u32 tplSize;\n/* 0x0A4 */ Unk * textureTable;\n/* 0x0A8 */ MapFileLightTable * lightTable;\n/* 0x0AC */ MapFileFog * fogData;\n/* 0x0B0 */ Unk * materialNameTable;\n/* 0x0B4 */ Unk * vcdTable;\n/* 0x0B8 */ MapObj * rootMapObj;\n/* 0x0BC */ struct _HitObj * rootHitObj;\n/* 0x0C0 */ Vec3 bboxCorners[2][8];\n/* 0x180 */ s32 mapObjCount;\n/* 0x184 */ MapObj * mapObjs;\n/* 0x188 */ s32 hitObjCount;\n/* 0x18C */ struct _HitObj * hitObj;\n/* 0x190 */ s32 animCount;\n/* 0x194 */ MapAnimObj * animData;\n/* 0x198 */ u32 dl_size; // display list size\n/* 0x19C */ void * dl_buf; // display list buffer\n/* 0x1A0 */ MapEntryUnloadCb * unloadCb;\n} MapEntry;\nSIZE_ASSERT(MapEntry, 0x1a4)\n\ntypedef struct\n{\n/* 0x000 */ MapEntry entries[2]; // being an array is a TTYD leftover\n/* 0x348 */ u8 unknown_0x348[0x34c - 0x348];\n} MapWorkGroup;\nSIZE_ASSERT(MapWorkGroup, 0x34c)\n\ntypedef struct\n{\n/* 0x000 */ MapWorkGroup groups[2];\n/* 0x698 */ s32 activeGroup;\n/* 0x69C */ u8 unknown_0x69c[0x6a0 - 0x69c];\n/* 0x6A0 */ s32 dispOff;\n/* 0x6A4 */ u8 unknown_0x6a4[0x6a8 - 0x6a4];\n/* 0x6A8 */ GXColor paperAmbColor;\n} MapWork;\nSIZE_ASSERT(MapWork, 0x6ac)\n\nDECOMP_STATIC(MapWork mapdrv_work)\nDECOMP_STATIC(MapWork * mapdrv_wp)\n\n/*\n    Records when a MapObj/HitObj isn't found\n    Types:\n        0 - MapObj\n        1 - HitObj\n*/\nvoid mapErrorEntry(s32 type, char * elementName);\n\nUNKNOWN_FUNCTION(func_8007ecc4);\nUNKNOWN_FUNCTION(func_8007ee24);\nUNKNOWN_FUNCTION(func_8007eff0);\n\n/*\n    Hides/unhides the map\n*/\nvoid mapDispOff();\nvoid mapDispOn();\n\n/*\n    Returns the pointer to the active group in mapWork\n*/\nMapWorkGroup * mapGetWork();\n\n/*\n    Counts the children of a MapFileJoint and the joint itself\n*/\nvoid mapGetJointsSub(MapFileJoint * joint, s32 countOut);\nvoid mapGetJoints(MapFileJoint * joint);\n\n/*\n    Returns the bounding box of all MapObjs in the specified map entry\n*/\nvoid mapGetBoundingBox(s32 entryId, Vec3 * minOut, Vec3 * maxOut);\n\n/*\n    Clears work and sets entry bounding boxes to (-)1000.0\n*/\nvoid mapInit();\n\n/*\n    Clears entries\n*/\nvoid mapReset();\n\n/*\n    Initialises textures for a MapObj\n*/\nvoid mapBuildTexture(MapObj * mapObj, TPLHeader * tpl, Unk * textureTable);\n\n/*\n    Creates a MapObj from a MapFileJoint\n*/\nMapObj * _mapEnt(MapFileJoint * joint, MapObj * parent, Mtx34 * mtx, s32 mapEntryId);\n\n/*\n    Creates MapObjs for a joint and its children\n*/\nMapObj * mapEntrySub(MapFileJoint * joint, MapObj * parent, Mtx34 * mtx, bool isRoot,\n                     s32 mapEntryId);\n\n/*\n    Creates the display list for a map entry\n*/\nDECOMP_STATIC(void mapdrv_makeDisplayList(s32 mapEntryId))\n\nUNKNOWN_FUNCTION(func_800808f0);\n\n/*\n    Gets a MapAnimObj by name\n*/\nMapAnimObj * mapSearchAnimObj(const char * animName);\n\n\n/*\n    Checks the progress of an animation\n*/\nvoid mapCheckAnimation(const char * animName, s32 * finishedOut, f32 * timeRemainingOut);\n\n/*\n    Plays an animation which will only progress on the specified system level or lower\n*/\nvoid mapPlayAnimationLv(const char * animName, Unk param_2, s32 level);\n\n/*\n    Creates the MapAnimObjs for a map entry\n*/\nvoid mapEntryAnimation(s32 mapEntryId);\n\n/*\n    Ends/pauses/restarts an animation\n*/\nvoid mapDeleteAnimation(const char * animName);\nvoid mapPauseAnimation(const char * animName);\nvoid mapReStartAnimation(const char * animName);\n\n/*\n    Pauses/restarts all animations\n*/\nvoid mapPauseAnimationAll();\nvoid mapReStartAnimationAll();\n\n/*\n    Sets the speed of an animation\n*/\nvoid mapSetPlayRate(const char * animName, f32 playRate);\n\n/*\n    Jumps to a fraction of the way through an animation\n*/\nvoid mapSetPlayProgress(const char * animName, f32 playProgress);\n\n/*\n    Returns the length of an animation\n*/\nf32 mapGetPlayDuration(const char * animName);\n\n/*\n    Clears the current map, hit, env and light entries\n*/\nvoid mapUnload();\n\n/*\n    Loads a new map\n*/\nvoid mapLoad(const char * name);\n\nUNKNOWN_FUNCTION(func_80083aa4);\n\nvoid mapCalcAnimMatrix(Mtx34 * dest, Mtx34 * parentMtx, MapAnimObj * obj, MapFileMeshTrack * track);\n\nUNKNOWN_FUNCTION(func_80083eb4);\nUNKNOWN_FUNCTION(func_80084098);\nUNKNOWN_FUNCTION(func_80084274);\n\nvoid mapReCalcMatrix(MapObj * mapObj, Mtx34 * dest, bool includeRoot);\n\n/*\n    Updates map visuals and collision\n*/\nvoid mapMain();\n\n/*\n    Renders a MapObj (and its children)\n*/\nvoid _mapDispMapObj(s8 cameraId, MapObj * obj);\nvoid _mapDispMapGrp(s8 cameraId, MapObj * obj);\nvoid mapDispMapObj(s8 cameraId, void * param);\nvoid mapDispMapGrp(s8 cameraId, void * param);\n\n/*\n    Renders an offscreen MapObj (and its children)\n*/\nvoid mapDispMapObj_off(s8 cameraId, void * param);\nvoid mapDispMapGrp_off(s8 cameraId, void * param);\n\n/*\n    Renders a MapObj without a material (and its children)    \n*/\nvoid _mapDispMapObj_NoMaterial(s8 cameraId, MapObj * obj);\nvoid _mapDispMapGrp_NoMaterial(s8 cameraId, MapObj * obj);\n\n/*\n    Updates the GX bounding box of a MapObj (and its children)\n*/\nvoid mapDispMapObj_bbox(s8 cameraId, void * param);\nvoid mapDispMapGrp_bbox(s8 cameraId, void * param);\n\n/*\n    Prepares for & schedules rendering the map\n*/\nvoid mapDisp();\n\nvoid mapSetLight(MapObj *, Unk);\nUNKNOWN_FUNCTION(mapSetMaterialTev);\nUNKNOWN_FUNCTION(mapSetMaterialLastStageBlend);\nUNKNOWN_FUNCTION(mapSetMaterialFog);\nUNKNOWN_FUNCTION(mapSetMaterialFogMapObj);\nUNKNOWN_FUNCTION(mapSetTextureMatrix);\nUNKNOWN_FUNCTION(mapSetMaterial);\nvoid mapSetPaperAmbColor(GXColor * colour);\nUNKNOWN_FUNCTION(mapResetPaperAmbColor);\nUNKNOWN_FUNCTION(mapSetMaterialLight);\nUNKNOWN_FUNCTION(mapSetPolygon);\nUNKNOWN_FUNCTION(mapSetPolygonVtxDesc);\n\nUNKNOWN_FUNCTION(func_8008b4c8);\n\nMapFileJoint * mapSearchDmdJointSub(MapFileJoint * joint, const char * name);\nUNKNOWN_FUNCTION(mapSearchDmdJointSub2);\nUnk * mapSearchDmdMaterial(const char * name);\n\n/*\n    Gets a MapObj by name\n*/\nMapObj * mapGetMapObj(const char * name);\n\n/*\n    Turns on/off flag0 flags for a MapObj (and its children)\n    allowSubName matches MapObjs with the string anywhere in their name (strstr instead of strcmp)\n*/\nvoid mapObjFlagOn(bool allowSubName, const char * name, u32 mask);\nvoid mapObjFlagOff(bool allowSubName, const char * name, u32 mask);\nvoid mapFlgOn(MapObj * obj, u32 mask, bool allowSiblings);\nvoid mapFlgOff(MapObj * obj, u32 mask, bool allowSiblings);\nvoid mapGrpFlagOn(bool allowSubName, const char * name, u32 mask);\nvoid mapGrpFlagOff(bool allowSubName, const char * name, u32 mask);\n\n/*\n    Turns on/off flag4 flags for a MapObj (and its children)\n    allowSubName matches MapObjs with the string anywhere in their name (strstr instead of strcmp)\n*/\nvoid mapObjFlag4On(bool allowSubName, const char * name, u32 mask);\nvoid mapObjFlag4Off(bool allowSubName, const char * name, u32 mask);\nvoid mapFlg4On(MapObj * obj, u32 mask, bool allowSiblings);\nvoid mapFlg4Off(MapObj * obj, u32 mask, bool allowSiblings);\nvoid mapGrpFlag4On(bool allowSubName, const char * name, u32 mask);\nvoid mapGrpFlag4Off(bool allowSubName, const char * name, u32 mask);\n\n/*\n    Sets the offscreen id of a MapObj (and its children)\n*/\nvoid _setOffScrnId(MapObj * obj, s16 ofsId, bool allowSiblings);\nvoid mapObjSetOffscreen(const char * objName, const char * ofsName);\nvoid mapGrpSetOffscreen(const char * objName, const char * ofsName);\n\n/*\n    Removes the offscreen id of a MapObj (and its children), checking the name is correct\n*/\nvoid mapObjClearOffScreen(const char * objName, const char * ofsName);\nvoid mapGrpClearOffScreen(const char * objName, const char * ofsName);\n\nvoid func_8008f2a4(const char *);\nvoid func_8008f324(const char *);\n\n/*\n    Rotates a MapObj in degrees\n*/\nvoid mapObjRotate(const char * objName, f32 x, f32 y, f32 z);\n\n/*\n    Moves a MapObj by the specified amount in each direction\n*/\nvoid mapObjTranslate(const char * objName, f32 x, f32 y, f32 z);\n\n/*\n    Scales a MapObj by the specified amount in each direction\n*/\nvoid mapObjScale(const char * objName, f32 x, f32 y, f32 z);\n\n/*\n    Gets the centre of a MapObj and its children\n*/\nvoid mapObjGetPosSub(MapObj * obj, Vec3 * posOut, s32 * countOut, bool allowSiblings);\nvoid mapObjGetPos(const char * name, Vec3 * posOut);\n\nUNKNOWN_FUNCTION(func_800900cc);\nUNKNOWN_FUNCTION(func_80090270);\n\n/*\n    Sets the fog parameters for a map group\n*/\nvoid mapSetFog(s32 groupId, s32 type, GXColor * colour, f32 startZ, s32 endZ);\n\n/*\n    Enables/disables fog\n*/\nvoid mapFogOn();\nvoid mapFogOff();\n\n/*\n    Sets/gets a blend colour of the active group's first map entry\n*/\nvoid mapSetBlend(GXColor * colour);\nvoid mapSetBlend2(GXColor * colour);\nvoid mapGetBlend(GXColor * colour);\nvoid mapGetBlend2(GXColor * colour);\n\n/*\n    Ddisables a blend colour of the active group's first map entry\n*/\nvoid mapBlendOff();\nvoid mapBlendOff2();\n\n/*\n    Sets the colour of the active group's first map entry\n*/\nvoid mapSetColor(GXColor * colour);\n\n/*\n    Sets the colour of a MapObj (and its children)\n*/\nvoid mapObjSetColor(const char * name, GXColor * colour);\nDECOMP_STATIC(void mapdrv_setColor(MapObj * obj, GXColor * colour, bool allowSiblings))\nvoid mapGrpSetColor(const char * name, GXColor * colour);\n\nUNKNOWN_FUNCTION(spline_maketable);\nUNKNOWN_FUNCTION(spline_getvalue);\n\n/*\n    Applies relocations to a map.dat file and generates its context\n    Returns 0 if successful, -1 if error\n*/\ns32 Locate(MapFileContext * outCtx, void * mapDat, u32 mapDatSize);\n\nUNKNOWN_FUNCTION(mapTextXLU);\n\nCPP_WRAPPER_END()\n/*\n    mobjdrv handles 'map objects' such as question blocks and save blocks\n*/\n\n\n/*\n    itemdrv handles in-world items\n*/\n\n\n/*\n    icondrv handles the display of icons such as items and buttons\n    Icon entries are handled by names, which must be unique, instead of pointers to entries\n*/\n\n\n\nCPP_WRAPPER(spm::icondrv)\n\nUSING(spm::filemgr::FileEntry)\nUSING(wii::gx::GXTexObj)\nUSING(wii::mtx::Vec3)\nUSING(wii::mtx::Mtx34)\n\nenum IconId\n{\n/* 0x00 */ ICON_BTN_WII_REMOTE = 0,\n/* 0x01 */ ICON_BTN_1_UP,\n/* 0x02 */ ICON_BTN_1_DOWN,\n/* 0x03 */ ICON_BTN_2_UP,\n/* 0x04 */ ICON_BTN_2_DOWN,\n/* 0x05 */ ICON_BTN_A_UP,\n/* 0x06 */ ICON_BTN_A_DOWN,\n    /// ...\n/* 0x09 */ ICON_DPAD_NEUTRAL = 9,\n/* 0x0A */ ICON_BTN_A,\n/* 0x0B */ ICON_BTN_POWER,\n/* 0x0C */ ICON_BTN_HOME,\n/* 0x0D */ ICON_BTN_MINUS,\n/* 0x0E */ ICON_BTN_PLUS,\n/* 0x0F */ ICON_BTN_1,\n/* 0x10 */ ICON_BTN_2,\n    /// ...\n/* 0x25 */ ICON_DPAD_UP_PROMPT = 37,\n/* 0x26 */ ICON_DPAD_DOWN_PROMPT,\n/* 0x27 */ ICON_DPAD_LEFT_PROMPT,\n/* 0x28 */ ICON_DPAD_RIGHT_PROMPT,\n/* 0x29 */ ICON_DPAD_NEUTRAL_PROMPT,\n/* 0x2A */ ICON_DPAD_UP_PROMPT_FLASH,\n/* 0x2B */ ICON_DPAD_DOWN_PROMPT_FLASH,\n/* 0x2C */ ICON_DPAD_LEFT_PROMPT_FLASH,\n/* 0x2D */ ICON_DPAD_RIGHT_PROMPT_FLASH,\n/* 0x2E */ ICON_BTN_1_PRESSING,\n/* 0x2F */ ICON_BTN_2_PRESSING,\n/* 0x30 */ ICON_BTN_A_PRESSING\n    /// ...\n};\n\n#define MAX_ICONOBJ_NAME 16\n\ntypedef struct\n{\n/* 0x00 */ u32 flags;\n/* 0x04 */ Vec3 position;\n/* 0x10 */ f32 scale;\n/* 0x14 */ u8 unknown_0x14[0x24 - 0x14];\n/* 0x24 */ char name[MAX_ICONOBJ_NAME];\n/* 0x34 */ s16 iconId;\n/* 0x36 */ u8 unknown_0x36[0x38 - 0x36];\n/* 0x38 */ s32 offscreenId;\n/* 0x3C */ u8 unknown_0x3c[0x3f - 0x3c];\n/* 0x3F */ u8 alpha;\n/* 0x40 */ u8 unknown_0x40[0x4c - 0x40];\n} IconEntry;\nSIZE_ASSERT(IconEntry, 0x4c)\n\ntypedef struct\n{\n/* 0x00 */ s32 num; // 0x100\n/* 0x04 */ IconEntry * entries; // array of num\n/* 0x08 */ FileEntry * wiconTpl; // wicon.tpl from dvd root\n/* 0x0C */ FileEntry * wiconbin; // wicon.bin from dvd root\n} IconWork;\nSIZE_ASSERT(IconWork, 0x10)\n\nDECOMP_STATIC(IconWork icondrv_work)\nDECOMP_STATIC(IconWork * icondrv_wp)\n\n/*\n    Initialise data used by icon functions\n*/\nvoid iconInit();\nvoid iconReInit();\n\n/*\n    Loads icon files if not loaded and displays icons\n*/\nvoid iconMain();\n\n/*\n    Set up an icon to be displayed\n*/\nvoid iconEntry(const char * name, s32 iconId);\nvoid iconEntry2D(const char * name, s32 iconId);\n\n/*\n    Stops an icon being displayed\n*/\nvoid iconDelete(const char * name);\n\n/*\n    Renders an icon\n*/\nvoid iconDisp(s8 cameraId, IconEntry * entry);\n\nUNKNOWN_FUNCTION(func_80072da0);\n\nvoid iconDispGxAlpha(f32 scale, Vec3 * position, Unk param_3, s32 iconId, u8 alpha);\n\n/*\n    Flags:\n        16: seems to be required to display\n         8: flip y\n         4: flip x\n        Others unknown\n*/\nvoid iconDispGx(f32 scale, const Vec3 * position, u32 flags, s32 iconId);\n\nvoid iconDispGx2(Mtx34 * param_1, Unk param_2, s32 iconId);\nvoid iconDispGxCol(Mtx34 * param_1, Unk param_2, s32 iconId, void * param_4);\nvoid iconGetTexObj(GXTexObj * dest, s32 iconId);\nvoid iconGetTexObj2(GXTexObj * dest, s32 iconId, Unk param_3, Unk param_4);\nvoid iconGetWidthHeight(s16 * width, s16 * height, s32 iconId);\nvoid iconGX(Mtx34 * param_1, IconEntry * entry);\nIconEntry * iconNameToPtr(const char * name);\nvoid iconSetPos(const char * name, f32 x, f32 y, f32 z);\nvoid iconFlagOn(const char * name, u32 flag);\nvoid iconFlagOn(const char * name, u32 flag);\nvoid iconSetScale(const char * name, f32 scale);\nvoid iconSetAlpha(const char * name, u8 alpha);\nvoid iconNumberDispGx(Mtx34 * param_1, s32 number, s32 keta, Unk param_4, void * param_5,\n                      Unk param_6);\n\nUNKNOWN_FUNCTION(func_80074f80);\nUNKNOWN_FUNCTION(func_80074fe8);\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::itemdrv)\n\nUSING(spm::evtmgr::EvtScriptCode)\nUSING(spm::evtmgr::EvtVar)\nUSING(spm::filemgr::FileEntry)\nUSING(spm::icondrv::IconEntry)\nUSING(wii::mtx::Vec3)\n\n#define ITEM_NAME_MAX 12\n\ntypedef struct\n{\n/* 0x00 */ u32 flags;\n/* 0x04 */ char name[ITEM_NAME_MAX];\n/* 0x10 */ s16 type;\n/* 0x12 */ s16 behaviour;\n/* 0x14 */ Vec3 position;\n/* 0x20 */ u8 unknown_0x20[0x24 - 0x20];\n/* 0x24 */ IconEntry * icon;\n/* 0x28 */ s32 animPoseId;\n/* 0x2C */ EvtVar switchNumber;\n/* 0x30 */ EvtScriptCode * pickupScript;\n/* 0x34 */ u8 unknown_0x34[0x88 - 0x34];\n} ItemEntry;\nSIZE_ASSERT(ItemEntry, 0x88)\n\ntypedef struct\n{\n/* 0x00 */ s32 num; // 0x100\n/* 0x04 */ ItemEntry * entries; // array of num\n/* 0x08 */ u8 unknown_0x8[0x64 - 0x8];\n/* 0x64 */ s32 tutorialWindowId;\n/* 0x68 */ u8 unknown_0x68[0x80 - 0x68];\n} ItemWork;\nSIZE_ASSERT(ItemWork, 0x80)\n\nDECOMP_STATIC(ItemWork itemdrv_work)\nDECOMP_STATIC(ItemWork * itemdrv_wp)\n\n/*\n    Returns a pointer to the ItemWork instance\n*/\nItemWork * itemGetWork();\n\n/*\n    Initialise data used by item functions\n*/\nvoid itemInit();\nvoid itemReInit();\n\nUNKNOWN_FUNCTION(func_80077724);\n\n/*\n    Handles the effect on the player and sound effects of picking up an item\n*/\nvoid itemHandlePickupEffect(Vec3 * itemPos, s32 itemType);\n\nUNKNOWN_FUNCTION(func_80077c48);\nUNKNOWN_FUNCTION(func_80077c90);\n\n/*\n    Updates items\n*/\nvoid itemMain();\n\n/*\n    Spawns an item\n    Switch number is the script variable (usually GSWF) indicating if it's already bene collected\n*/\nItemEntry * itemEntry(const char * name, s32 type, s32 behaviour, f32 x, f32 y, f32 z,\n                      EvtScriptCode * pickupScript, EvtVar switchNumber);\n\n/*\n    Despawns an item\n*/\nvoid itemDelete(const char * name);\n\n/*\n    Gets an ItemEntry by name\n*/\nItemEntry * itemNameToPtr(const char * name);\n\nUNKNOWN_FUNCTION(func_80079468);\nUNKNOWN_FUNCTION(func_800795b8);\nUNKNOWN_FUNCTION(func_80079814);\nUNKNOWN_FUNCTION(func_80079df4);\nUNKNOWN_FUNCTION(func_8007a2e0);\nUNKNOWN_FUNCTION(func_8007a598);\nUNKNOWN_FUNCTION(func_8007a758);\n\n/*\n    Handles most of the pickup behaviour for items (deletion, xp, switchNumber etc),\n    and calls itemHandlePickup for the rest\n*/\ns32 itemCollect(s32 entryId, ItemEntry * entry);\n\nUNKNOWN_FUNCTION(func_8007bc2c);\n\n/*\n    Converts an item type name to the id for that item type\n    Type names are the name field from items.txt with the following prefixes\n        - ITEM_ID_USE_ for items with ids in the range 65-119 (inclusive)\n        - ITEM_ID_COOK_ for items with ids in the range 120-215 (inclusive)\n        - ITEM_ID_CARD_ for items with ids in the range 282-537 (inclusive)\n    (Items that don't fall within any of these ranges can not be used)\n*/\ns32 itemTypeNameToId(const char * typeNmae);\n\nUNKNOWN_FUNCTION(func_8007be24);\nUNKNOWN_FUNCTION(func_8007bee4);\nUNKNOWN_FUNCTION(func_8007c3b8);\nUNKNOWN_FUNCTION(func_8007c8ec);\nUNKNOWN_FUNCTION(func_8007ce34);\nUNKNOWN_FUNCTION(func_8007cfc0);\nUNKNOWN_FUNCTION(func_8007d1f4);\nUNKNOWN_FUNCTION(func_8007d454);\nUNKNOWN_FUNCTION(func_8007d568);\nUNKNOWN_FUNCTION(func_8007d684);\n\n/*\n    Sets the current animation of an item\n*/\nvoid itemSetAnim(char * itemName,char * animName);\n\nUNKNOWN_FUNCTION(func_8007d868);\n\n/*\n    Checks for the existence of any items in the world with\n    the specified item type id\n*/\nbool itemCheckForId(s32 typeId);\n\nUNKNOWN_FUNCTION(func_8007d8fc);\nUNKNOWN_FUNCTION(func_8007dc24);\nUNKNOWN_FUNCTION(func_8007dd50);\nUNKNOWN_FUNCTION(func_8007dd60);\nUNKNOWN_FUNCTION(func_8007de50);\nUNKNOWN_FUNCTION(func_8007e0e4);\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::hitdrv)\n\nstruct _HitObj;\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::mobjdrv)\n\nUSING(spm::evtmgr::EvtEntry)\nUSING(spm::evtmgr::EvtScriptCode)\nUSING(spm::hitdrv::_HitObj)\nUSING(spm::itemdrv::ItemEntry)\nUSING(spm::mapdrv::MapFileJoint)\nUSING(wii::mtx::Vec3)\n\nstruct _MobjEntry;\ntypedef void (MobjUpdateFunc)(struct _MobjEntry * entry);\n\ntypedef struct\n{\n/* 0x0 */ s32 itemId;\n/* 0x4 */ s32 chance;\n} MobjDropItem;\nSIZE_ASSERT(MobjDropItem, 0x8)\n\ntypedef struct _MobjEntry\n{\n    /*\n        0x10000000 is grabbable with Thoreau\n        0x1 is active\n        Others unknown\n    */\n/* 0x000 */ u32 flag0;\n/* 0x004 */ u32 flag4;\n/* 0x008 */ char instanceName[16];\n/* 0x018 */ Vec3 pos;\n/* 0x024 */ Vec3 scale;\n/* 0x030 */ Vec3 rotation;\n/* 0x03C */ u8 unknown_0x3c[0x48 - 0x3c];\n/* 0x048 */ s32 animPoseId;\n/* 0x04C */ u8 unknown_0x4c[0x5c - 0x4c];\n    /*\n        These are likely an array of structs, but the exact boundaries are unknown\n        MapFileJoint ends in a VLA, so it can't be used directly here\n    */\n/* 0x05c */ struct _HitObj * joint1_HitObj;\n/* 0x060 */ char joint1_Name[16];\n/* 0x070 */ u8 unknown_0x70[0x78 - 0x70];\n/* 0x078 */ u8 joint1[sizeof(MapFileJoint)];\n/* 0x0E0 */ u8 unknown_0xe0[0xe4 - 0xe0];\n/* 0x0E4 */ struct _HitObj * joint2_HitObj;\n/* 0x0E8 */ char joint2_Name[16];\n/* 0x0F8 */ u8 unknown_0xf8[0x100 - 0xf8];\n/* 0x100 */ u8 joint2[sizeof(MapFileJoint)];\n/* 0x168 */ u8 unknown_0x168[0x16c - 0x168];\n/* 0x16C */ struct _HitObj * joint3_HitObj;\n/* 0x170 */ char joint3_Name[16];\n/* 0x180 */ u8 unknown_0x180[0x188 - 0x180];\n/* 0x188 */ u8 joint3[sizeof(MapFileJoint)];\n/* 0x1F0 */ u8 unknown_0x1f0[0x210 - 0x1f0];\n/* 0x210 */ union\n            {\n                MobjDropItem * items;\n                s32 item;\n            };\n/* 0x214 */ u8 unknown_0x214[0x218 - 0x214];\n/* 0x218 */ ItemEntry * itemEntry;\n/* 0x21C */ u8 unknown_0x21c[0x23c - 0x21c];\n/* 0x23C */ s32 evtId; // id of the EvtEntry from mobjRunEvent\n/* 0x240 */ MobjUpdateFunc * updateFunction; // runs every frame in mobjMain\n/* 0x244 */ EvtScriptCode * interactScript; // ran when the player interacts with the object\n/* 0x248 */ EvtScriptCode * afterInteractScript; // usage varies by MOBJ\n/* 0x24C */ s32 state; // values vary by MOBJ\n/* 0x250 */ u8 unknown_0x250[0x2a8 - 0x250];\n} MobjEntry;\nSIZE_ASSERT(MobjEntry, 0x2a8)\n\ntypedef struct // paired with a MobjEntry at the same index, unknown purpose\n{\n/* 0x00 */ Vec3 unknown_0x0;\n/* 0x0C */ Vec3 unknown_0xc;\n} MobjOtherEntry;\nSIZE_ASSERT(MobjOtherEntry, 0x18)\n\ntypedef struct\n{\n/* 0x00 */ s32 entryCountMax; // 0x100\n/* 0x04 */ MobjEntry * entries; // array of entryCountMax length\n/* 0x08 */ u8 unknown_0x8[0x10 - 0x8];\n/* 0x10 */ MobjOtherEntry * otherEntries; // array of entryCountMax length\n/* 0x14 */ bool unkFlag;\n/* 0x15 */ u8 unknown_0x15[0x18 - 0x15];\n} MobjWork;\nSIZE_ASSERT(MobjWork, 0x18)\n\nUNKNOWN_FUNCTION(func_800297c0);\nUNKNOWN_FUNCTION(func_80029c34);\nUNKNOWN_FUNCTION(func_80029e50);\nUNKNOWN_FUNCTION(func_8002a03c);\nUNKNOWN_FUNCTION(func_8002a0bc);\nUNKNOWN_FUNCTION(func_8002a150);\nUNKNOWN_FUNCTION(func_8002a1d4);\nUNKNOWN_FUNCTION(func_8002a258);\nUNKNOWN_FUNCTION(func_8002a31c);\n\n/*\n    Allocates entries and otherEntries, sets entryCountMax and initialises other unknown data\n*/\nvoid mobjInit();\n\n/*\n    Clears entries and re-initialises other unknown data\n*/\nvoid mobjReset();\n\n/*\n    Initialises collision data for a MOBJ\n*/\nvoid mobjHitEntry(MobjEntry * entry, s32 type);\n\n/*\n    Creates a MOBJ, returns its id\n*/\ns32 mobjEntry(const char * instanceName, const char * animPoseName);\n\n/*\n    Deletes a MOBJ\n*/\nvoid mobjDelete(const char * instanceName);\n\n/*\n    Sets a MOBJ's position\n*/\nvoid mobjSetPosition(const char * instanceName, f32 x, f32 y, f32 z);\n\n/*\n    Updates all MOBJs\n*/\nvoid mobjMain();\n\n/*\n    Gets a MobjEntry by instance name\n    NoAssert will return a null pointer if not found, regular will kill the game\n*/\nMobjEntry * mobjNameToPtr(const char * instanceName);\nMobjEntry * mobjNameToPtrNoAssert(const char * instanceName);\n\n/*\n    Runs a script as a MOBJ\n*/\nEvtEntry * mobjRunEvent(MobjEntry * entry, EvtScriptCode * script);\n\n/*\n    Calculate a collision-related matrix for a MOBJ\n*/\nvoid mobjCalcMtx(MobjEntry * entry);\nvoid mobjCalcMtx2(MobjEntry * entry);\n\nUNKNOWN_FUNCTION(func_8002cf0c);\nUNKNOWN_FUNCTION(func_8002cfcc);\nUNKNOWN_FUNCTION(func_8002d2c0);\nUNKNOWN_FUNCTION(mobjHitOn);\nUNKNOWN_FUNCTION(mobjHitOff);\nUNKNOWN_FUNCTION(func_8002d720);\nUNKNOWN_FUNCTION(func_8002d7d8);\nUNKNOWN_FUNCTION(func_8002d890);\nUNKNOWN_FUNCTION(func_8002d89c);\nUNKNOWN_FUNCTION(func_8002d8a8);\nUNKNOWN_FUNCTION(func_8002d914);\nUNKNOWN_FUNCTION(func_8002d9bc);\nUNKNOWN_FUNCTION(func_8002de94);\nUNKNOWN_FUNCTION(func_8002dfc4);\nUNKNOWN_FUNCTION(func_8002e278);\nUNKNOWN_FUNCTION(func_8002e4c8);\nUNKNOWN_FUNCTION(func_8002e940);\nUNKNOWN_FUNCTION(mobjDropFromCatch);\nUNKNOWN_FUNCTION(func_8002e968);\nUNKNOWN_FUNCTION(func_8002e980);\nUNKNOWN_FUNCTION(func_8002e9bc);\nUNKNOWN_FUNCTION(func_8002ea0c);\nUNKNOWN_FUNCTION(func_8002ea54);\nUNKNOWN_FUNCTION(func_8002eb0c);\nUNKNOWN_FUNCTION(mobjGetModelName);\nUNKNOWN_FUNCTION(func_8002eb60);\nUNKNOWN_FUNCTION(func_8002ed80);\nUNKNOWN_FUNCTION(func_8002ed90);\n \nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::hitdrv)\n\nUSING(spm::mapdrv::MapObj)\nUSING(spm::mapdrv::MapFileJoint)\nUSING(spm::mobjdrv::MobjEntry)\nUSING(wii::mtx::Vec3)\nUSING(wii::mtx::Mtx34)\n\n#define HITOBJ_FLAG_DELETED 0x80\n\n// Matrix recalculated\n#define HITOBJ_FLAG_MTX_RECALC 0x40\n\n#define HITOBJ_FLAG_DISABLE 0x1\n\ntypedef struct _HitObj\n{\n/* 0x000 */ u16 flags;\n/* 0x002 */ u8 unknown_0x2[0x4 - 0x2];\n/* 0x004 */ u32 attr; // unknown bitflags\n/* 0x008 */ MapFileJoint * joint;\n/* 0x00C */ u8 unknown_0xc[0xcc - 0xc];\n/* 0x0CC */ Vec3 position; \n/* 0x0D8 */ s16 totalTri;\n/* 0x0DA */ s16 mapEntryIdx;\n/* 0x0DC */ Unk * tris; // array of totalTri length\n/* 0x0E0 */ u8 unknown_0xe0[0x100 - 0xe0];\n/* 0x100 */ union\n            {\n                MobjEntry * mobj;\n                MapObj * mapObj;\n            } owner;\n/* 0x104 */ struct _HitObj * parent;\n/* 0x108 */ struct _HitObj * child;\n/* 0x10C */ struct _HitObj * nextSibling;\n/* 0x110 */ u8 unknown_0x110[0x114 - 0x110];\n} HitObj;\nSIZE_ASSERT(HitObj, 0x114)\n\n/*\n    Stub\n*/\nvoid hitInit();\n\n/*\n    Deletes all map HitObjs & their tris\n*/\nvoid hitReinit();\n\n/*\n    Creates a HitObj for a joint\n*/\nHitObj * _hitEnt(MapFileJoint * joint, HitObj * parent, Mtx34 * parentMtx, s32 mapEntryIdx);\n\n/*\n    Recursively creates HitObjs for a joint and its children\n*/\nHitObj * hitEntrySub(MapFileJoint * joint, HitObj * parent, Mtx34 * parentMtx, bool ignoreSiblings,\n                     s32 mapEntryIdx);\n\n/*\n    Create HitObjs for a joint and its children\n*/\nHitObj * hitEntry(MapFileJoint * joint, Mtx34 * mtx, s32 mapEntryIdx);\nHitObj * hitEntryMOBJ(MapFileJoint * joint, Mtx34 * mtx);\n\n/*\n    Deletes a HitObj by name\n*/\nvoid hitDelete(const char * name);\n\n/*\n    Updates matrices for HitObjs\n*/\nvoid hitMain();\n\nvoid hitRecalcMatrices();\n\n/*\n    Turns on/off flags for a HitObj by name\n    allowSubName matches HitObjs with the string anywhere in their name (strstr instead of strcmp)\n*/\nvoid hitObjFlagOn(bool allowSubName, const char * name, u16 mask);\nvoid hitObjFlagOff(bool allowSubName, const char * name, u16 mask);\n\n/*\n    Recursively turn on/off flags for a HitObj and its children by pointer/name\n    allowSubName matches HitObjs with the string anywhere in their name (strstr instead of strcmp)\n*/\nvoid hitFlgOn(HitObj * hitObj, u16 mask, bool allowSiblings);\nvoid hitFlgOff(HitObj * hitObj, u16 mask, bool allowSiblings);\nvoid hitGrpFlagOn(bool allowSubName, const char * name, u16 mask);\nvoid hitGrpFlagOff(bool allowSubName, const char * name, u16 mask);\n\n/*\n    Turns on/off attr bitflags for a HitObj by name\n    allowSubName matches HitObjs with the string anywhere in their name (strstr instead of strcmp)\n*/\nvoid hitObjAttrOn(bool allowSubName, const char * name, u32 mask);\nvoid hitObjAttrOff(bool allowSubName, const char * name, u32 mask);\n\n/*\n    Recursively turn on/off attr bitflags for a HitObj and its children by pointer/name\n    allowSubName matches HitObjs with the string anywhere in their name (strstr instead of strcmp)\n*/\nvoid hitAtrOn(HitObj * hitObj, u32 mask, bool allowSiblings);\nvoid hitAtrOff(HitObj * hitObj, u32 mask, bool allowSiblings);\nvoid hitGrpAttrOn(bool allowSubName, const char * name, u32 mask);\nvoid hitGrpAttrOff(bool allowSubName, const char * name, u32 mask);\n\nvoid hitReCalcMatrix(HitObj *, Unk);\nvoid hitReCalcMatrix2(HitObj *, Mtx34 *, bool);\nvoid hitCalcVtxPosition(HitObj *);\n\nUNKNOWN_FUNCTION(func_8006da4c);\nUNKNOWN_FUNCTION(func_8006debc);\nUNKNOWN_FUNCTION(func_8006e160);\nUNKNOWN_FUNCTION(func_8006e400);\n\nUNKNOWN_FUNCTION(hitCheckVecFilter);\nbool hitCheckFilter(f32, f32, f32, f32, f32, f32, void *, f32 *, f32 *,\n                    f32 *, f32 *, f32 *, f32 *, f32 *);\n\nUNKNOWN_FUNCTION(func_8006ef1c);\n\nUNKNOWN_FUNCTION(chkFilterAttr);\nUNKNOWN_FUNCTION(hitCheckAttr);\n\nUNKNOWN_FUNCTION(func_8006f128);\nUNKNOWN_FUNCTION(func_8006f47c);\nUNKNOWN_FUNCTION(func_8006f710);\nUNKNOWN_FUNCTION(func_8006f7cc);\nUNKNOWN_FUNCTION(func_8006f884);\n\n/*\n    Gets a HitObj by name / a string anwyhere in its name\n*/\nHitObj * hitNameToPtr(const char * name);\nHitObj * hitSubNameToPtr(const char * subname);\n\n/*\n    Gets the position vector of a HitObj\n*/\nvoid hitObjGetPosSub(HitObj *, Vec3 *, s32 *, bool);\nvoid hitObjGetPos(const char * name, Vec3 * posOut);\n\n/*\n    Gets the normal vector of a HitObj\n*/\nvoid hitObjGetNormal(const char * name, Vec3 * normalOut);\n\n/*\n    Returns the bounding box of the specified map entry\n*/\nvoid hitGetMapEntryBbox(s32 mapEntryIdx, Vec3 * minOut, Vec3 * maxOut);\n\nUNKNOWN_FUNCTION(func_8007058c);\nUNKNOWN_FUNCTION(func_80070790);\n\n/*\n    Gets the name of a HitObj's joint\n*/\nconst char * hitGetName(HitObj * hitObj);\n\n/*\n    Returns the attr of a HitObj\n*/\nu32 hitGetAttr(HitObj * hitGetAttr);\n\n/*\n    Sets the owner of a HitObj\n*/\nvoid hitBindMapObj(const char * hitName, const char * mapObjName);\n\nvoid hitBindUpdate();\nvoid hitCheckVecFilter2();\n\nUNKNOWN_FUNCTION(func_800710b4);\nUNKNOWN_FUNCTION(func_800717d8);\nUNKNOWN_FUNCTION(func_80071f44);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::casedrv)\n\nUSING(spm::evtmgr::EvtScriptCode)\nUSING(spm::hitdrv::HitObj)\n\ntypedef struct\n{\n/* 0x00 */ u16 flags;\n/* 0x02 */ u8 unknown_0x2[0x4 - 0x2];\n    // Touching a HitObj with either name triggers the script\n/* 0x04 */ const char * name;\n/* 0x08 */ const char * name2;\n/* 0x0C */ u8 unknown_0xc[0x10 - 0xc];\n/* 0x10 */ s32 lw[16]; // copied into script's LW on run\n/* 0x50 */ u8 unknown_0x50[0x54 - 0x50];\n/* 0x54 */ EvtScriptCode * script;\n/* 0x58 */ s32 scriptPriority;\n} CaseEntDef;\nSIZE_ASSERT(CaseEntDef, 0x5c)\n\n// Script running this frame\n#define CASE_FLAG_RUN 0x10\n// Entry allocated for a case\n#define CASE_FLAG_IN_USE 1\n\ntypedef struct\n{\n/* 0x00 */ u16 flags; // CASE_FLAG defines\n/* 0x02 */ u8 unknown_0x2[0x4 - 0x2];\n/* 0x04 */ s32 type; // controls the action & type of HitObj required\n/* 0x08 */ char name[64];\n/* 0x48 */ char name2[64];\n/* 0x88 */ s32 id;\n/* 0x8C */ u32 def_0xc; // 0xc-f from CaseEntDef\n/* 0x90 */ s32 lw[16];\n/* 0xD0 */ s32 evtId;\n/* 0xD4 */ EvtScriptCode * script;\n/* 0xD8 */ s32 scriptPriority;\n} CaseEntry;\nSIZE_ASSERT(CaseEntry, 0xdc)\n\ntypedef struct\n{\n/* 0x0 */ s32 n;\n/* 0x4 */ CaseEntry * entries; // array of n length\n/* 0x8 */ u8 unknown_0x8[0x10 - 0x8];\n} CaseWork;\nSIZE_ASSERT(CaseWork, 0x10)\n\nDECOMP_STATIC(CaseWork casedrv_work)\nDECOMP_STATIC(CaseWork * casedrv_wp)\n\n/*\n    Allocates entries\n*/\nvoid caseInit();\n\n/*\n    Clears entries\n*/\nvoid caseReInit();\n\n/*\n    Creates an entry from a CaseEntDef and returns its id\n*/\ns32 caseEntry(CaseEntDef * def);\n\n/*\n    Deletes an entry by id\n*/\nvoid caseDelete(s32 id);\n\nUNKNOWN_FUNCTION(func_80059268);\n\n/*\n    Updates all entries\n*/\nvoid caseMain();\n\n/*\n    Returns an entry by its HitObj\n*/\nCaseEntry * caseCheckHitObj(HitObj * hitObj);\nCaseEntry * caseCheckHitObj2(HitObj * hitObj);\n\n/*\n    Returns an entry by id\n*/\nCaseEntry * caseIdToPtr(s32 id);\n\nUNKNOWN_FUNCTION(func_8005adec);\nUNKNOWN_FUNCTION(func_8005ae08);\nUNKNOWN_FUNCTION(func_8005ae24);\nUNKNOWN_FUNCTION(func_8005ae64);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::charpixlitemwin)\n\nUNKNOWN_FUNCTION(charPixlItemWinInit);\nUNKNOWN_FUNCTION(charPixlItemWinReInit);\nUNKNOWN_FUNCTION(charPixlItemWinOpen);\nUNKNOWN_FUNCTION(func_80195e64);\nbool charPixlItemWinIsClosed();\nUNKNOWN_FUNCTION(charPixlItemWinGetNextWindow);\nUNKNOWN_FUNCTION(func_80196004);\nUNKNOWN_FUNCTION(initCharTab);\nUNKNOWN_FUNCTION(func_80196174);\nUNKNOWN_FUNCTION(func_801969dc);\nUNKNOWN_FUNCTION(dispCharTab);\nUNKNOWN_FUNCTION(deleteCharTab);\nUNKNOWN_FUNCTION(initPixlTab);\nUNKNOWN_FUNCTION(func_80196c8c);\nUNKNOWN_FUNCTION(func_80197544);\nUNKNOWN_FUNCTION(dispPixlTab);\nUNKNOWN_FUNCTION(deletePixlTab);\nUNKNOWN_FUNCTION(initItemTab);\nUNKNOWN_FUNCTION(func_801976e8);\nUNKNOWN_FUNCTION(func_80198238);\nUNKNOWN_FUNCTION(dispItemTab);\nUNKNOWN_FUNCTION(deleteItemTab);\nUNKNOWN_FUNCTION(func_80198290);\nUNKNOWN_FUNCTION(func_80198294);\nUNKNOWN_FUNCTION(func_801982b4);\nUNKNOWN_FUNCTION(func_801982c4);\nUNKNOWN_FUNCTION(func_801984f4);\nUNKNOWN_FUNCTION(func_80198874);\nUNKNOWN_FUNCTION(dispTab);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::debug)\n\ntypedef struct\n{\n/* 0x00 */ u8 unknown_0x0[0x1c - 0x0];\n} DebugWork;\nSIZE_ASSERT(DebugWork, 0x1c)\n\nvoid debugInit();\nvoid debugReInit();\n// OSPanic\n\nDECOMP_STATIC(DebugWork debug_work)\nDECOMP_STATIC(DebugWork * debug_wp)\n\nCPP_WRAPPER_END()\n/*\n    dispdrv is a wrapper for functions that can draw to the screen\n*/\n\n\n\nCPP_WRAPPER(spm::dispdrv)\n\n#define DISP_ZOFFSET 100000.0\n#define MAX_SCISSOR_NO 32\n\ntypedef void (DispCallback)(s32 cameraId, void * param);\n\ntypedef struct\n{\n/* 0x0 */ s8 cameraId;\n/* 0x1 */ s8 renderMode;\n/* 0x2 */ u8 unknown_0x2[0x4 - 0x2];\n/* 0x4 */ f32 order;\n/* 0x8 */ DispCallback * callback;\n/* 0xC */ f32 * callbackParam;\n} DispEntry;\nSIZE_ASSERT(DispEntry, 0x10)\n\nDECOMP_STATIC(DispEntry * dispdrv_pDispWork)\nDECOMP_STATIC(DispEntry ** dispdrv_pSortWork)\nDECOMP_STATIC(s32 dispdrv_entry_n)\nDECOMP_STATIC(DispEntry * dispdrv_currentWorkPtr)\n\ntypedef struct\n{\n/* 0x0 */ u8 unknown_0x0[0x10 - 0x0];\n} DispScissor;\nSIZE_ASSERT(DispScissor, 0x10)\n\nDECOMP_STATIC(DispScissor dispdrv_dispScissors[0x20])\n\n/*\n    Initialise data used by dispdrv functions\n*/\nvoid dispInit();\nvoid dispReInit();\n\n/*\n    Register a function to be displayed this frame\n*/\nvoid dispEntry(s8 cameraId, s8 renderMode, f32 z, DispCallback * callback, void * callbackParam);\n\nvoid dispSetCurScissor(s32 scissorNo);\nvoid dispSetScissor(s32 id, u32 field_0, u32 field_4, u32 field_8, u32 field_c);\n\nDECOMP_STATIC(bool dispdrv__sort(DispEntry ** lhs, DispEntry ** rhs))\nvoid dispSort();\n\n/*\n    Runs every entry's callback\n*/\nvoid dispDraw(s32 cameraId);\n\nf32 dispCalcZ(f32 param_1);\n\n/*\n    Returns the DispEntry currently being executed\n*/\nDispEntry * dispGetCurWork();\n\nUNKNOWN_FUNCTION(func_8005b52c);\n\nCPP_WRAPPER_END()\n/*\n    effdrv handles effect animations\n*/\n\n\n\nCPP_WRAPPER(spm::effdrv)\n\nUSING(spm::filemgr::FileEntry)\nUSING(wii::gx::GXTexObj)\n\nstruct _EffEntry;\ntypedef void (EffFunc)(struct _EffEntry * entry);\n\n#define EFF_FLAG_SOFT_DELETED 4\n#define EFF_FLAG_IN_USE 1\n\ntypedef struct _EffEntry\n{\n/* 0x00 */ u16 flags; // EFF_FLAG defines\n/* 0x02 */ u16 type; // 0 or 1, groups entries for limits\n/* 0x04 */ s32 releaseType; // 0 or 1, groups entries for freeing\n                            // (1 means 'in battle', unused TTYD leftover)\n/* 0x08 */ u8 unknown_0x8[0xc - 0x8];\n/* 0x0C */ void * userWork;\n/* 0x10 */ EffFunc * mainFunc;\n/* 0x14 */ u8 unknown_0x14[0x18 - 0x14];\n/* 0x18 */ char instanceName[16];\n/* 0x28 */ u8 unknown_0x28[0x2c - 0x28];\n} EffEntry;\nSIZE_ASSERT(EffEntry, 0x2c)\n\ntypedef struct\n{\n/* 0x0 */ s32 curCount; // current number of active entries of this type\n/* 0x4 */ s32 maxCount; // maximum number of active entries of this type allowed\n} EffTypeStats;\nSIZE_ASSERT(EffTypeStats, 0x8)\n\ntypedef struct\n{\n/* 0x000 */ s32 entryCount;\n/* 0x004 */ EffEntry * entries; // array of entryCount length\n/* 0x008 */ FileEntry * effectTpl;\n/* 0x00C */ FileEntry * effectN64Tpl;\n/* 0x010 */ u8 unknown_0x10[0x11c - 0x10];\n/* 0x11C */ EffTypeStats typeStats[2];\n/* 0x12C */ u8 unknown_0x12c[0x134 - 0x12c];\n} EffWork;\nSIZE_ASSERT(EffWork, 0x134)\n\nDECOMP_STATIC(EffWork effdrv_work)\nDECOMP_STATIC(EffWork * effdrv_wp)\n\n/*\n    Allocates entries\n*/\nvoid effInit();\n\n/*\n    Gets a tex obj for a texture in the effect TPL\n*/\nvoid effGetTexObj(s32 id, GXTexObj * out);\n\nUNKNOWN_FUNCTION(func_800615cc);\n\n/*\n    Gets a tex obj for a texture in the effect N64 TPL\n*/\nvoid effGetTexObjN64(s32 id, GXTexObj * out);\n\n/*\n    Frees all entries of the specified release type\n*/\nvoid effAutoRelease(s32 releaseType);\n\n/*\n    Creates an entry of type 0\n*/\nEffEntry * effEntry();\n\n/*\n    Creates an entry of the specified type\n*/\nEffEntry * effEntryType(s32 type);\n\n/*\n    Sets the name of an entry\n*/\nvoid effSetName(const char * name);\n\n/*\n    Loads TPLs if not loaded, calls effSubMain and calls the mainFunc of each entry\n*/\nvoid effMain();\n\nUNKNOWN_FUNCTION(func_80061a34);\nUNKNOWN_FUNCTION(func_80061a44);\n\n/*\n    Delete an entry\n*/\nvoid effDelete(EffEntry * entry);\nvoid effSoftDelete(EffEntry * entry);\n\n/*\n    Gets an entry by name\n*/\nEffEntry * effNameToPtr(const char * name);\n\nUNKNOWN_FUNCTION(func_80061c28);\nUNKNOWN_FUNCTION(func_80061cd0);\ns32 func_80061d78();\nUNKNOWN_FUNCTION(func_80061e18);\nUNKNOWN_FUNCTION(func_80061eb8);\nUNKNOWN_FUNCTION(func_800623f8);\nUNKNOWN_FUNCTION(func_80062d04);\nUNKNOWN_FUNCTION(func_80062f9c);\nUNKNOWN_FUNCTION(func_800630b8);\nUNKNOWN_FUNCTION(func_80063130);\nUNKNOWN_FUNCTION(func_80063198);\nUNKNOWN_FUNCTION(func_800631a4);\nUNKNOWN_FUNCTION(func_800631ac);\nUNKNOWN_FUNCTION(func_800631b8);\nUNKNOWN_FUNCTION(func_800632ec);\nUNKNOWN_FUNCTION(func_800632fc);\nUNKNOWN_FUNCTION(func_80063308);\nUNKNOWN_FUNCTION(func_80063374);\nUNKNOWN_FUNCTION(func_8006339c);\nUNKNOWN_FUNCTION(func_800633fc);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::eff_nice)\n\nUSING(spm::effdrv::EffEntry)\n\nEffEntry * effNiceEntry(double param_1, double param_2, double param_3, double param_4, int param_5);\n// more\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::eff_small_star)\n\n// ...\n\nvoid effSmallStar(f32, f32, f32, f32, f32, f32, s32, s32);\n\n// ...\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::eff_spm_confetti)\n\n// ...\n\nvoid effSpmConfetti(f32, f32, f32, s32, s32);\n\n// ...\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::eff_zunbaba)\n\nUNKNOWN_FUNCTION(func_800c1838);\nUNKNOWN_FUNCTION(func_800c1938);\nUNKNOWN_FUNCTION(func_800c1944);\nUNKNOWN_FUNCTION(func_800c1a48);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::envdrv)\n\nvoid envInit();\nUNKNOWN_FUNCTION(envReInit);\nUNKNOWN_FUNCTION(envCapture);\nUNKNOWN_FUNCTION(envCapture2);\nUNKNOWN_FUNCTION(envDisp);\nvoid envMain();\nUNKNOWN_FUNCTION(envDisp_Blur);\nUNKNOWN_FUNCTION(envBlurOn);\nUNKNOWN_FUNCTION(envBlurOff);\nUNKNOWN_FUNCTION(func_80064014);\nUNKNOWN_FUNCTION(func_800646b8);\nUNKNOWN_FUNCTION(func_800646d8);\nUNKNOWN_FUNCTION(func_800646d8);\nUNKNOWN_FUNCTION(func_80064a5c);\nUNKNOWN_FUNCTION(func_80064a68);\nUNKNOWN_FUNCTION(func_80064af8);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_ac)\n\n// evt_ac_entry(const char * name, s32 type)\nEVT_DECLARE_USER_FUNC(evt_ac_entry, 2)\n\n//evt_ac_return_results(const char * name, s32& ret)\nEVT_DECLARE_USER_FUNC(evt_ac_return_results, 2)\n\n//evt_ac_delete(const char * name)\nEVT_DECLARE_USER_FUNC(evt_ac_delete, 1)\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_cam)\n\nEVT_UNKNOWN_USER_FUNC(evt_cam_flag_onoff)\nEVT_UNKNOWN_USER_FUNC(evt_cam_get_at)\nEVT_UNKNOWN_USER_FUNC(evt_cam_get_pos)\nEVT_DECLARE_USER_FUNC(evt_cam_shake, 6)\nEVT_DECLARE_USER_FUNC(evt_cam3d_evt_zoom_in, 9)\nEVT_UNKNOWN_USER_FUNC(func_800e01f8)\nEVT_UNKNOWN_USER_FUNC(func_800e02bc)\nEVT_DECLARE_USER_FUNC(evt_cam_zoom_to_coords, 2)\nEVT_DECLARE_USER_FUNC(evt_cam_look_at_door, 2)\nEVT_UNKNOWN_USER_FUNC(func_800e0720)\nEVT_UNKNOWN_USER_FUNC(func_800e07bc)\nEVT_UNKNOWN_USER_FUNC(func_800e0890)\nEVT_UNKNOWN_USER_FUNC(func_800e08f8)\nEVT_UNKNOWN_USER_FUNC(func_800e092c)\nEVT_UNKNOWN_USER_FUNC(evt_cam_check_dimension)\nEVT_UNKNOWN_USER_FUNC(func_800e0a14)\nEVT_UNKNOWN_USER_FUNC(func_800e0a84)\nEVT_UNKNOWN_USER_FUNC(func_800e0b58)\nEVT_UNKNOWN_USER_FUNC(func_800e0b8c)\nEVT_UNKNOWN_USER_FUNC(func_800e0bbc)\nEVT_UNKNOWN_USER_FUNC(func_800e0c40)\n\nEVT_DECLARE(lbl_80439f10)\n\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_case)\n\nUNKNOWN_FUNCTION(evt_run_case_evt);\nUNKNOWN_FUNCTION(evtRunCaseEntry);\n\nEVT_DECLARE_USER_FUNC(evt_exit_case_evt, 0)\n\nEVT_DECLARE_USER_FUNC(evt_del_case_evt, 2)\n\nUNKNOWN_FUNCTION(evt_set_case_wrk);\nUNKNOWN_FUNCTION(func_800e0f30);\nUNKNOWN_FUNCTION(func_800e0f70);\n\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_door)\n\ntypedef struct\n{\n/* 0x00 */ u8 unknown_0x0[0xc - 0x0];\n/* 0x0C */ const char * name;\n/* 0x10 */ u8 unknown_0x10[0x44 - 0x10];\n/* 0x44 */ const char ** npcNameList;\n/* 0x48 */ u8 unknown_0x48[0x58 - 0x48];\n} DoorDesc;\nSIZE_ASSERT(DoorDesc, 0x58)\n\ntypedef struct\n{\n/* 0x00 */ u32 flags;\n/* 0x04 */ const char * name_l;\n/* 0x08 */ const char * name_r;\n/* 0x0C */ const char * hitName2d;\n/* 0x10 */ const char * hitName3d;\n/* 0x14 */ const char * destMapName;\n/* 0x18 */ const char * unknown_0x18;\n/* 0x1C */ s32 unknown_0x1c;\n} MapDoorDesc;\nSIZE_ASSERT(MapDoorDesc, 0x20)\n\ntypedef struct\n{\n/* 0x00 */ s32 scriptNumber;\n/* 0x04 */ u16 flags;\n/* 0x06 */ u16 _pad_6;\n/* 0x08 */ const char * name;\n/* 0x0C */ const char * mapName;\n/* 0x10 */ const char * hitName2d;\n/* 0x14 */ const char * hitName3d;\n/* 0x19 */ const char * destMapName;\n/* 0x1C */ const char * unknown_0x1c;\n} DokanDesc;\nSIZE_ASSERT(DokanDesc, 0x20)\n\n#define EVT_DOOR_FLAG_DOOR_OPEN 1\n\ntypedef struct\n{\n/* 0x000 */ u16 flags;\n/* 0x002 */ u8 unknown_0x2[0x57c - 0x2];\n} EvtDoorWork;\nSIZE_ASSERT(EvtDoorWork, 0x57c)\n\nUNKNOWN_FUNCTION(evtDoorInit);\nUNKNOWN_FUNCTION(evt_door_flag_onoff);\nUNKNOWN_FUNCTION(func_800e1040);\nUNKNOWN_FUNCTION(func_800e1058);\nUNKNOWN_FUNCTION(func_800e1070);\nUNKNOWN_FUNCTION(evtDoorCheckMapDoorDescExists);\nUNKNOWN_FUNCTION(evtDoorCheckMapDoorDescInUnkMask);\nDoorDesc * evtDoorGetActiveDoorDesc();\nUNKNOWN_FUNCTION(func_800e11d0);\nEVT_DECLARE_USER_FUNC(evt_door_wait_flag, 1)\nUNKNOWN_FUNCTION(func_800e120c);\nUNKNOWN_FUNCTION(evt_door_cmd);\nUNKNOWN_FUNCTION(func_800e186c);\nUNKNOWN_FUNCTION(func_800e18d0);\nUNKNOWN_FUNCTION(func_800e1934);\nUNKNOWN_FUNCTION(func_800e1c6c);\nUNKNOWN_FUNCTION(func_800e1d34);\nUNKNOWN_FUNCTION(func_800e1f34);\nUNKNOWN_FUNCTION(func_800e200c);\nUNKNOWN_FUNCTION(evt_door_set_active_door_desc);\nUNKNOWN_FUNCTION(func_800e21d0);\nUNKNOWN_FUNCTION(func_800e21d8);\nUNKNOWN_FUNCTION(func_800e21e0);\nUNKNOWN_FUNCTION(evt_door_get_desc);\nUNKNOWN_FUNCTION(func_800e2500);\nUNKNOWN_FUNCTION(roomBottomlesssCb);\n\n// evt_door_set_door_descs(DoorDesc * descs, s32 count)\nEVT_DECLARE_USER_FUNC(evt_door_set_door_descs, 1)\n\n\nUNKNOWN_FUNCTION(evt_door_enable_disable_door_desc);\nUNKNOWN_FUNCTION(func_800e2b78);\nUNKNOWN_FUNCTION(func_800e3050);\nUNKNOWN_FUNCTION(func_800e32a0);\nUNKNOWN_FUNCTION(func_800e333c);\nUNKNOWN_FUNCTION(func_800e34f0);\n\n// evt_door_set_dokan_descs(DokanDesc * descs, s32 count)\nEVT_DECLARE_USER_FUNC(evt_door_set_dokan_descs, 1)\n\n// evt_door_enable_disable_dokan_desc(bool enabled, const char * name)\nEVT_DECLARE_USER_FUNC(evt_door_enable_disable_dokan_desc, 2)\n\nUNKNOWN_FUNCTION(func_800e3ad4);\nUNKNOWN_FUNCTION(func_800e3b08);\nUNKNOWN_FUNCTION(func_800e3b60);\nUNKNOWN_FUNCTION(func_800e3ef4);\nUNKNOWN_FUNCTION(func_800e3f74);\nUNKNOWN_FUNCTION(func_800e4014);\nUNKNOWN_FUNCTION(func_800e40e0);\n\n// evt_door_set_map_door_descs(MapDoorDesc * descs, s32 count)\nEVT_DECLARE_USER_FUNC(evt_door_set_map_door_descs, 1)\n\n// evt_door_enable_disable_map_door_desc(bool enabled, const char * name)\nEVT_DECLARE_USER_FUNC(evt_door_enable_disable_map_door_desc, 2)\n\nUNKNOWN_FUNCTION(evt_door_add_map_door_desc_to_unk_mask);\n\n// evt_door_set_event(char *door, int unknown, EvtScriptCode * script)\nEVT_DECLARE_USER_FUNC(evt_door_set_event, 3)\n\nEVT_DECLARE_USER_FUNC(evt_door_openable_onoff, 1)\nUNKNOWN_FUNCTION(evt_door_get_map_door_desc);\nUNKNOWN_FUNCTION(func_800e47a8);\nUNKNOWN_FUNCTION(func_800e56b4);\nUNKNOWN_FUNCTION(evt_door_get_dokan_descs);\nUNKNOWN_FUNCTION(evt_door_get_dokan_desc_num);\nUNKNOWN_FUNCTION(evt_door_get_map_door_descs);\nUNKNOWN_FUNCTION(evt_door_get_map_door_desc_num);\n\nEVT_DECLARE(lbl_80417e10)\nEVT_DECLARE(door_init_evt)\n\nDECOMP_STATIC(EvtDoorWork * evt_door_wp)\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_eff)\n\nEVT_DECLARE_USER_FUNC(evt_eff, 14)\n\n// evt_eff_softdelete(const char * name)\nEVT_DECLARE_USER_FUNC(evt_eff_softdelete, 1)\n\nUNKNOWN_FUNCTION(func_800e617c);\nUNKNOWN_FUNCTION(func_800e61b0);\nUNKNOWN_FUNCTION(func_800e61e0);\nUNKNOWN_FUNCTION(func_800e6210);\nEVT_UNKNOWN_USER_FUNC(func_800e6250)\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_env)\n\nEVT_DECLARE_USER_FUNC(evt_env_blur_on, 2)\nEVT_DECLARE_USER_FUNC(evt_env_static_blur_on, 0)\nUNKNOWN_FUNCTION(func_800e6650);\nUNKNOWN_FUNCTION(func_800e6748);\nUNKNOWN_FUNCTION(func_800e6778);\nUNKNOWN_FUNCTION(func_800e679c);\nUNKNOWN_FUNCTION(func_800e6a94);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_fade)\n\n//evt_fade_entry(int transitionType, everything else is unknown ints)\nEVT_DECLARE_USER_FUNC(evt_fade_entry, 6)\n\n// evt_fade_end_wait(s32)\nEVT_DECLARE_USER_FUNC(evt_fade_end_wait, 1)\n\nUNKNOWN_FUNCTION(func_800e715c);\nEVT_DECLARE_USER_FUNC(evt_fade_callfade, 1)\nUNKNOWN_FUNCTION(func_800e720c);\nUNKNOWN_FUNCTION(func_800e7268);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_fairy)\n\nUNKNOWN_FUNCTION(evt_fairy_get_num);\nUNKNOWN_FUNCTION(func_800e7324);\nUNKNOWN_FUNCTION(func_800e7380);\nUNKNOWN_FUNCTION(func_800e73b0);\nUNKNOWN_FUNCTION(func_800e73e0);\nUNKNOWN_FUNCTION(func_800e7404);\nUNKNOWN_FUNCTION(func_800e7428);\nUNKNOWN_FUNCTION(func_800e7458);\nUNKNOWN_FUNCTION(func_800e747c);\n\n// evt_fairy_set_pos(s32 id, f32 x, f32 y, f32 z)\nEVT_DECLARE_USER_FUNC(evt_fairy_set_pos, 4)\n\nUNKNOWN_FUNCTION(evt_fairy_set_pos_all);\nUNKNOWN_FUNCTION(evt_fairy_get_pos);\nUNKNOWN_FUNCTION(func_800e76d4);\nUNKNOWN_FUNCTION(func_800e7784);\nUNKNOWN_FUNCTION(func_800e77d0);\nUNKNOWN_FUNCTION(func_800e7868);\nUNKNOWN_FUNCTION(func_800e7900);\nUNKNOWN_FUNCTION(func_800e7aec);\nUNKNOWN_FUNCTION(func_800e7b78);\nUNKNOWN_FUNCTION(func_800e7bdc);\nUNKNOWN_FUNCTION(func_800e7d88);\nUNKNOWN_FUNCTION(func_800e7f3c);\nUNKNOWN_FUNCTION(func_800e80ec);\n\n// evt_fairy_flag_onoff(bool onoff, u32 flags)\nEVT_DECLARE_USER_FUNC(evt_fairy_flag_onoff, 2)\n\nUNKNOWN_FUNCTION(evt_fairy_flag_onoff_all);\nUNKNOWN_FUNCTION(func_800e82dc);\nUNKNOWN_FUNCTION(func_800e8350);\nUNKNOWN_FUNCTION(func_800e840c);\nUNKNOWN_FUNCTION(func_800e8468);\n\n// evt_fairy_reset()\nEVT_DECLARE_USER_FUNC(evt_fairy_reset, 0)\n\nEVT_UNKNOWN_USER_FUNC(func_800e8518)\nUNKNOWN_FUNCTION(func_800e86dc);\nUNKNOWN_FUNCTION(func_800e8748);\nUNKNOWN_FUNCTION(func_800e87ac);\nEVT_UNKNOWN_USER_FUNC(func_800e8824)\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_frame)\n\nEVT_UNKNOWN_USER_FUNC(func_800e8854)\nEVT_UNKNOWN_USER_FUNC(func_800e88d0)\nEVT_UNKNOWN_USER_FUNC(func_800e89d4)\nEVT_UNKNOWN_USER_FUNC(func_800e8a58)\nEVT_UNKNOWN_USER_FUNC(func_800e8ab4)\nUNKNOWN_FUNCTION(func_800e8b48);\nUNKNOWN_FUNCTION(func_800e8be8);\nUNKNOWN_FUNCTION(func_800e8cd0);\nUNKNOWN_FUNCTION(func_800e8d0c);\nUNKNOWN_FUNCTION(func_800e8d98);\nUNKNOWN_FUNCTION(func_800e8e2c);\nUNKNOWN_FUNCTION(func_800e8e94);\nUNKNOWN_FUNCTION(func_800e8f4c);\nUNKNOWN_FUNCTION(func_800e902c);\nUNKNOWN_FUNCTION(func_800e90e4);\nUNKNOWN_FUNCTION(func_800e9178);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_guide)\n\nUNKNOWN_FUNCTION(evt_guide_set_pos);\nUNKNOWN_FUNCTION(evt_guide_get_pos);\nUNKNOWN_FUNCTION(func_800e9ce8);\nUNKNOWN_FUNCTION(func_800e9da4);\nUNKNOWN_FUNCTION(func_800e9ddc);\nUNKNOWN_FUNCTION(func_800e9e14);\nUNKNOWN_FUNCTION(func_800e9ff8);\nUNKNOWN_FUNCTION(func_800ea05c);\nUNKNOWN_FUNCTION(func_800ea0a8);\nUNKNOWN_FUNCTION(func_800ea25c);\nUNKNOWN_FUNCTION(func_800ea3ec);\nUNKNOWN_FUNCTION(func_800ea584);\nUNKNOWN_FUNCTION(func_800ea718);\nUNKNOWN_FUNCTION(func_800ea748);\nUNKNOWN_FUNCTION(evt_guide_enter_run_mode_1);\nUNKNOWN_FUNCTION(evt_guide_enter_runmode_2);\nUNKNOWN_FUNCTION(func_800ea7e8);\nUNKNOWN_FUNCTION(func_800ea858);\n\n// evt_guide_flag2_onoff(bool onoff, u32 flags)\nEVT_DECLARE_USER_FUNC(evt_guide_flag2_onoff, 2)\n\nUNKNOWN_FUNCTION(evt_guide_flag0_onoff);\n\n// evt_guide_check_flag0(u32 flags, bool &ret)\nEVT_DECLARE_USER_FUNC(evt_guide_check_flag0, 2)\n\nUNKNOWN_FUNCTION(func_800ea9f4);\nEVT_UNKNOWN_USER_FUNC(func_800eaa88)\nUNKNOWN_FUNCTION(func_800eaadc);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_hit)\n\nUNKNOWN_FUNCTION(func_800eab1c);\nUNKNOWN_FUNCTION(func_800eabb8);\n\n// evt_hitobj_onoff(const char * name, s32 group, bool on)\nEVT_DECLARE_USER_FUNC(evt_hitobj_onoff, 4)\n\nUNKNOWN_FUNCTION(func_800ead20);\nUNKNOWN_FUNCTION(func_800eadec);\nUNKNOWN_FUNCTION(func_800eaed0);\nUNKNOWN_FUNCTION(func_800eb15c);\n\n// evt_hit_bind_mapobj(const char * hit_name, const char * map_name)\nEVT_DECLARE_USER_FUNC(evt_hit_bind_mapobj, 2)\n\n// evt_hit_bind_update(const char * hit_name)\nEVT_DECLARE_USER_FUNC(evt_hit_bind_update, 1)\n\nUNKNOWN_FUNCTION(func_800eb564);\nUNKNOWN_FUNCTION(func_800eb5dc);\nUNKNOWN_FUNCTION(func_800eb654);\n\n// evt_hitobj_attr_onoff(s32 group, bool on, const char * name, u32 mask)\nEVT_DECLARE_USER_FUNC(evt_hitobj_attr_onoff, 4)\n\nUNKNOWN_FUNCTION(func_800eb7f4);\nUNKNOWN_FUNCTION(func_800eb8bc);\nUNKNOWN_FUNCTION(func_800ebd74);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_img)\n\nEVT_DECLARE_USER_FUNC(evt_img_entry, 1)\n\nUNKNOWN_FUNCTION(evt_img_set_position);\nEVT_DECLARE_USER_FUNC(evt_img_set_paper, 2)\nEVT_DECLARE_USER_FUNC(evt_img_set_paper_anim, 2)\nEVT_DECLARE_USER_FUNC(evt_img_alloc_capture, 8)\nEVT_DECLARE_USER_FUNC(evt_img_free_capture, 2)\nUNKNOWN_FUNCTION(evt_img_clear_virtual_space);\nEVT_DECLARE_USER_FUNC(evt_img_release, 1)\nEVT_DECLARE_USER_FUNC(evt_img_wait_animend, 1)\n\nUNKNOWN_FUNCTION(func_800ec998);\nUNKNOWN_FUNCTION(func_800eca64);\nUNKNOWN_FUNCTION(func_800ecae0);\nUNKNOWN_FUNCTION(func_800ecb5c);\nUNKNOWN_FUNCTION(func_800ecbd8);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_item)\n\nEVT_UNKNOWN_USER_FUNC(evt_item_entry)\nUNKNOWN_FUNCTION(func_800ecd70);\nEVT_UNKNOWN_USER_FUNC(func_800ecda0)\nEVT_UNKNOWN_USER_FUNC(func_800ece50)\nEVT_UNKNOWN_USER_FUNC(evt_item_flag_onoff)\nUNKNOWN_FUNCTION(func_800ecf80);\nUNKNOWN_FUNCTION(func_800ed020);\nUNKNOWN_FUNCTION(func_800ed0bc);\nEVT_UNKNOWN_USER_FUNC(evt_item_wait_collected)\nUNKNOWN_FUNCTION(func_800ed188);\nUNKNOWN_FUNCTION(func_800ed1dc);\nUNKNOWN_FUNCTION(func_800ed468);\nUNKNOWN_FUNCTION(func_800ed66c);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_map)\n\n// evt_mapobj_trans(const char * name, s32 x, s32 y, s32 z)\nEVT_DECLARE_USER_FUNC(evt_mapobj_trans, 4)\n\nUNKNOWN_FUNCTION(evt_mapobj_rotate);\nUNKNOWN_FUNCTION(func_800ed7f8);\nUNKNOWN_FUNCTION(evt_map_set_fog);\nUNKNOWN_FUNCTION(evt_map_fog_onoff);\nUNKNOWN_FUNCTION(func_800ed9b0);\nUNKNOWN_FUNCTION(func_800eda74);\nUNKNOWN_FUNCTION(func_800edab4);\n\n// evt_mapobj_color(s32 group, const char * name, u8 r, u8 g, u8 b, u8 a)\nEVT_DECLARE_USER_FUNC(evt_mapobj_color, 6)\n\nEVT_DECLARE_USER_FUNC(evt_map_playanim, 3)\n\nUNKNOWN_FUNCTION(func_800edca8);\n\nEVT_DECLARE_USER_FUNC(evt_map_checkanim, 3)\n\nUNKNOWN_FUNCTION(func_800edd50);\nUNKNOWN_FUNCTION(func_800eddb4);\nUNKNOWN_FUNCTION(evt_map_set_playrate);\nUNKNOWN_FUNCTION(func_800ede70);\nUNKNOWN_FUNCTION(func_800edec8);\n\n// evt_mapobj_flag_onoff(s32 group, bool on, const char * name, u32 mask)\nEVT_DECLARE_USER_FUNC(evt_mapobj_flag_onoff, 4)\n\n// evt_mapobj_flag4_onoff(s32 group, bool on, const char * name, u32 mask)\nEVT_DECLARE_USER_FUNC(evt_mapobj_flag4_onoff, 4)\n\nUNKNOWN_FUNCTION(func_800ee0b4);\nUNKNOWN_FUNCTION(func_800ee13c);\n\n// evt_mapobj_get_position(const char * name, f32& x, f32& y, f32& z)\nEVT_DECLARE_USER_FUNC(evt_mapobj_get_position, 4)\n\nUNKNOWN_FUNCTION(func_800ee290);\nUNKNOWN_FUNCTION(func_800ee51c);\n\nEVT_DECLARE_USER_FUNC(evt_mapdisp_onoff, 1)\n\nUNKNOWN_FUNCTION(func_800ee59c);\nUNKNOWN_FUNCTION(evt_mapobj_blendmode);\nUNKNOWN_FUNCTION(func_800ee9f4);\nUNKNOWN_FUNCTION(func_800eec8c);\nUNKNOWN_FUNCTION(func_800eee68);\nUNKNOWN_FUNCTION(func_800ef198);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_mario)\n\nUNKNOWN_FUNCTION(evt_mario_flag0_onoff);\nUNKNOWN_FUNCTION(evt_mario_flag4_onoff);\n\n// evt_mario_flag8_onoff(bool onOff, u32 mask)\nEVT_DECLARE_USER_FUNC(evt_mario_flag8_onoff, 2)\n\nUNKNOWN_FUNCTION(func_800ef53c);\nUNKNOWN_FUNCTION(evt_mario_cont_onoff);\n\n\n\n// evt_mario_key_on()\nEVT_DECLARE_USER_FUNC(evt_mario_key_on, 0)\n\n// evt_mario_key_off(int)\nEVT_DECLARE_USER_FUNC(evt_mario_key_off, 1)\n\nUNKNOWN_FUNCTION(evt_mario_key_off2);\nUNKNOWN_FUNCTION(func_800ef814);\nUNKNOWN_FUNCTION(func_800ef8c8);\n\n// evt_mario_get_character(s32& ret)\nEVT_DECLARE_USER_FUNC(evt_mario_get_character, 1)\n\nEVT_DECLARE_USER_FUNC(evt_mario_set_character, 1)\n\n// evt_mario_get_pos(f32 x, f32 y, f32 z)\nEVT_DECLARE_USER_FUNC(evt_mario_set_pos, 3)\n\n// evt_mario_get_pos(f32& x, f32& y, f32& z)\nEVT_DECLARE_USER_FUNC(evt_mario_get_pos, 3)\n\nUNKNOWN_FUNCTION(func_800efac4);\nUNKNOWN_FUNCTION(func_800efb50);\nUNKNOWN_FUNCTION(func_800efbdc);\nUNKNOWN_FUNCTION(func_800efc54);\nEVT_UNKNOWN_USER_FUNC(func_800efce0)\n\nEVT_DECLARE_USER_FUNC(evt_mario_direction_reset, 0)\n\nUNKNOWN_FUNCTION(func_800efd58);\n\nEVT_DECLARE_USER_FUNC(evt_mario_direction_face, 2)\n\nUNKNOWN_FUNCTION(func_800eff6c);\n\n// evt_mario_face_npc(const char * name)\nEVT_DECLARE_USER_FUNC(evt_mario_face_npc, 1)\n\n// evt_mario_face_coords(float positionX, float PositionZ)\nEVT_DECLARE_USER_FUNC(evt_mario_face_coords, 2)\n\nUNKNOWN_FUNCTION(func_800f013c);\nUNKNOWN_FUNCTION(func_800f0160);\nUNKNOWN_FUNCTION(func_800f01ac);\nUNKNOWN_FUNCTION(func_800f0210);\nUNKNOWN_FUNCTION(evt_mario_face);\nUNKNOWN_FUNCTION(evt_mario_face_free);\nUNKNOWN_FUNCTION(func_800f0304);\n\nEVT_DECLARE_USER_FUNC(evt_mario_pos_change, 3)\n\nUNKNOWN_FUNCTION(func_800f05b0);\nUNKNOWN_FUNCTION(func_800f074c);\nEVT_UNKNOWN_USER_FUNC(func_800f09c4)\nUNKNOWN_FUNCTION(func_800f0c28);\nUNKNOWN_FUNCTION(func_800f0d58);\nUNKNOWN_FUNCTION(func_800f119c);\nEVT_UNKNOWN_USER_FUNC(func_800f1684)\nUNKNOWN_FUNCTION(func_800f1778);\nUNKNOWN_FUNCTION(func_800f1810);\nUNKNOWN_FUNCTION(func_800f1858);\n\n// evt_mario_set_pose(const char * name, s16 time)\nEVT_DECLARE_USER_FUNC(evt_mario_set_pose, 2)\n\nEVT_DECLARE_USER_FUNC(evt_mario_wait_anim, 0)\nUNKNOWN_FUNCTION(func_800f1a08);\nUNKNOWN_FUNCTION(func_800f1a4c);\nUNKNOWN_FUNCTION(func_800f1abc);\nUNKNOWN_FUNCTION(func_800f1b08);\nUNKNOWN_FUNCTION(func_800f1ba8);\nUNKNOWN_FUNCTION(func_800f1c1c);\nUNKNOWN_FUNCTION(func_800f1c88);\nUNKNOWN_FUNCTION(func_800f1d0c);\nUNKNOWN_FUNCTION(func_800f1d80);\nUNKNOWN_FUNCTION(func_800f1e30);\nUNKNOWN_FUNCTION(func_800f1eb0);\nUNKNOWN_FUNCTION(func_800f1f30);\nUNKNOWN_FUNCTION(func_800f1f9c);\nUNKNOWN_FUNCTION(func_800f2008);\nUNKNOWN_FUNCTION(func_800f2074);\nUNKNOWN_FUNCTION(func_800f2124);\nUNKNOWN_FUNCTION(func_800f212c);\nUNKNOWN_FUNCTION(func_800f2144);\nUNKNOWN_FUNCTION(func_800f2310);\nEVT_UNKNOWN_USER_FUNC(func_800f23e4)\nEVT_UNKNOWN_USER_FUNC(func_800f240c)\n\nEVT_DECLARE_USER_FUNC(evt_mario_fairy_reset, 0)\n\nUNKNOWN_FUNCTION(evt_mario_swim_onoff);\nUNKNOWN_FUNCTION(func_800f24d8);\nUNKNOWN_FUNCTION(func_800f2544);\nUNKNOWN_FUNCTION(evt_set_gravity);\nUNKNOWN_FUNCTION(evt_get_gravity);\nUNKNOWN_FUNCTION(func_800f262c);\nUNKNOWN_FUNCTION(func_800f267c);\nUNKNOWN_FUNCTION(func_800f26c0);\nUNKNOWN_FUNCTION(func_800f27f4);\nUNKNOWN_FUNCTION(func_800f2974);\nUNKNOWN_FUNCTION(func_800f29c8);\nUNKNOWN_FUNCTION(evt_mario_tamara_onoff);\nUNKNOWN_FUNCTION(evt_mario_tamara_chg_mode);\nUNKNOWN_FUNCTION(func_800f2c00);\nUNKNOWN_FUNCTION(func_800f2c98);\nUNKNOWN_FUNCTION(func_800f2cbc);\nUNKNOWN_FUNCTION(func_800f2cfc);\nUNKNOWN_FUNCTION(func_800f2d74);\nUNKNOWN_FUNCTION(func_800f2df4);\nUNKNOWN_FUNCTION(func_800f2e30);\nUNKNOWN_FUNCTION(func_800f2e54);\nUNKNOWN_FUNCTION(evt_mario_set_bottomless_cb);\nUNKNOWN_FUNCTION(evt_mario_get_bottomless_cb);\n\n// evt_mario_set_anim_change_handler(MarioAnimChangeHandler * handler)\nEVT_DECLARE_USER_FUNC(evt_mario_set_anim_change_handler, 1)\n\nUNKNOWN_FUNCTION(func_800f2fa8);\nUNKNOWN_FUNCTION(func_800f2fec);\nUNKNOWN_FUNCTION(func_800f3074);\nUNKNOWN_FUNCTION(func_800f30bc);\nUNKNOWN_FUNCTION(func_800f315c);\nUNKNOWN_FUNCTION(evt_mario_set_pane_boundaries);\nUNKNOWN_FUNCTION(evt_mario_get_pane_for_pos);\nUNKNOWN_FUNCTION(evt_mario_set_pane);\nUNKNOWN_FUNCTION(evt_mario_pane_change_func);\nUNKNOWN_FUNCTION(evt_mario_get_pane_change_func);\nUNKNOWN_FUNCTION(func_800f3310);\nUNKNOWN_FUNCTION(func_800f3334);\nUNKNOWN_FUNCTION(evt_mario_check_3d);\nUNKNOWN_FUNCTION(func_800f33b0);\nUNKNOWN_FUNCTION(evt_mario_calc_damage_to_enemy);\n\nCPP_WRAPPER_END()\n/*\n    Functions used to spawn map objects with the user_func instruction in evt scripts,\n    and the functions the objects use internally\n*/\n\n\n\nCPP_WRAPPER(spm::evt_mobj)\n\n/*\n    Saves the game\n*/\nEVT_DECLARE(mobj_save_blk_sysevt)\n\nUNKNOWN_FUNCTION(evt_mobj_entry);\nUNKNOWN_FUNCTION(evt_mobj_delete);\nEVT_UNKNOWN_USER_FUNC(evt_mobj_exec_cancel)\n\n// evt_mobj_hit_onoff(bool on, const char * name)\nEVT_DECLARE_USER_FUNC(evt_mobj_hit_onoff, 2)\n\nUNKNOWN_FUNCTION(func_800f3714);\nUNKNOWN_FUNCTION(func_800f379c);\n\n// evt_mobj_flag_onoff(bool on, bool flag4, const char * name, u32 mask)\nEVT_DECLARE_USER_FUNC(evt_mobj_flag_onoff, 4)\n\nUNKNOWN_FUNCTION(func_800f38d8);\nUNKNOWN_FUNCTION(func_800f3980);\n\n// evt_mobj_get_position(const char * name, f32& x, f32& y, f32& z)\nEVT_DECLARE_USER_FUNC(evt_mobj_get_position, 4)\n\n// evt_mobj_set_position(const char * name, f32 x, f32 y, f32 z)\nEVT_DECLARE_USER_FUNC(evt_mobj_set_position, 4)\n\nUNKNOWN_FUNCTION(evt_mobj_set_scale);\nUNKNOWN_FUNCTION(evt_mobj_set_rotation);\nUNKNOWN_FUNCTION(evt_mobj_set_anim);\n\n// evt_mobj_wait_animation_end(const char * name, UNUSED)\nEVT_DECLARE_USER_FUNC(evt_mobj_wait_animation_end, 2)\n\nUNKNOWN_FUNCTION(evt_mobj_set_interact_script);\nUNKNOWN_FUNCTION(evt_mobj_set_item);\nUNKNOWN_FUNCTION(func_800f3fa8);\nUNKNOWN_FUNCTION(func_800f4018);\nUNKNOWN_FUNCTION(evt_mobj_check);\nUNKNOWN_FUNCTION(func_800f429c);\nUNKNOWN_FUNCTION(mobj_sui);\nUNKNOWN_FUNCTION(mobj_sui_15);\nUNKNOWN_FUNCTION(evt_mobj_sui);\nUNKNOWN_FUNCTION(mobj_jump_kumo);\nUNKNOWN_FUNCTION(mobj_big_jump_kumo);\nUNKNOWN_FUNCTION(evt_mobj_jump_kumo);\nUNKNOWN_FUNCTION(mobj_jumpstand);\nUNKNOWN_FUNCTION(evt_mobj_jumpstand);\nUNKNOWN_FUNCTION(mobj_hunmer_blk);\nUNKNOWN_FUNCTION(evt_mobj_hunmer_blk);\nUNKNOWN_FUNCTION(mobj_zyo);\nUNKNOWN_FUNCTION(func_800f5a48);\n\n// evt_mobj_zyo(const char * name, s32 lockItemId, f32 x, f32 y, f32 z, f32 yRotation,\n//              EvtScriptCode * interactScript, EvtScriptCode * openScript, EvtVar collectedVar)\nEVT_DECLARE_USER_FUNC(evt_mobj_zyo, 9)\n\nUNKNOWN_FUNCTION(mobj_thako);\n\n// evt_mobj_thako(s32 type, const char * name, f32 x, f32 y, f32 z, EvtScriptCode * interactScript,\n//                EvtScriptCode * openScript, UNK arg8, UNK arg9)\nEVT_DECLARE_USER_FUNC(evt_mobj_thako, 9)\n\nUNKNOWN_FUNCTION(mobj_kan);\n\n/*\n    Spawns a sign mobj\n    \n    rotation:\n        0 for facing 2d camera\n        1 for perpendicular to 2d camera\n*/\n\n// evt_mobj_kan(bool rotation, const char * name, f32 x, f32 y, f32 z,\n//              EvtScriptCode * interactScript, UNK arg7)\nEVT_DECLARE_USER_FUNC(evt_mobj_kan, 7)\n\nUNKNOWN_FUNCTION(mobj_arrow);\n\n// evt_mobj_arrow(const char * name, f32 x, f32 y, f32 z, UNK arg5)\nEVT_DECLARE_USER_FUNC(evt_mobj_arrow, 5)\n\n/*\n    Gets the item id for a mobj_blk to drop\n\n    If using a fixed item, returns that\n    If using a chance table, returns a random id from that\n*/\nUNKNOWN_FUNCTION(mobj_blk_decideItem);\n\nUNKNOWN_FUNCTION(mobj_blk);\nUNKNOWN_FUNCTION(func_800f71d8);\nUNKNOWN_FUNCTION(func_800f7680);\nUNKNOWN_FUNCTION(func_800f7ac0);\nUNKNOWN_FUNCTION(func_800f7bac);\nUNKNOWN_FUNCTION(func_800f7d7c);\nUNKNOWN_FUNCTION(func_800f8030);\nUNKNOWN_FUNCTION(func_800f8214);\nUNKNOWN_FUNCTION(func_800f821c);\nUNKNOWN_FUNCTION(func_800f8408);\nUNKNOWN_FUNCTION(func_800f8a08);\n\n/*\n    Spawns a block mobj (question, brick & variants)\n\n    types:\n        0 = brick block\n        1 = question block\n        the rest unknown\n\n    6th param can be 2 things:\n        s32 itemId\n        or\n        ChanceEntry * chanceTable\n        Format is an array of the following struct, terminated by one with an id of 0\n        struct ChanceEntry\n        {\n            s32 itemId;\n            s32 chance;\n        }\n*/\n// evt_mobj_blk(s32 type, char * instanceName, f32 x, f32 y, f32 z,\n//              s32 itemId / ChanceEntry * chanceTable, EvtScript * hitScript, bool disableHitting)\nEVT_DECLARE_USER_FUNC(evt_mobj_blk, 8)\n\nUNKNOWN_FUNCTION(mobj_eria_block);\nUNKNOWN_FUNCTION(evt_mobj_eria_block);\nUNKNOWN_FUNCTION(func_800f97f0);\nUNKNOWN_FUNCTION(func_800f9b14);\nUNKNOWN_FUNCTION(mobj_fire_block);\nUNKNOWN_FUNCTION(evt_mobj_fire_block);\nUNKNOWN_FUNCTION(mobj_hip_kui);\nUNKNOWN_FUNCTION(evt_mobj_hip_kui);\nUNKNOWN_FUNCTION(mobj_kaze);\nUNKNOWN_FUNCTION(func_800fab28);\nUNKNOWN_FUNCTION(func_800fab88);\nUNKNOWN_FUNCTION(func_800fac0c);\nUNKNOWN_FUNCTION(evt_mobj_kaze);\nUNKNOWN_FUNCTION(mobj_save_blk);\n\n/*\n    Spawns a save block mobj\n*/\n// evt_mobj_save_blk(char * instanceName, f32 x, f32 y, f32 z, EvtScriptCode * interactScript)\nEVT_DECLARE_USER_FUNC(evt_mobj_save_blk, 5)\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_msg)\n\nvoid evt_msg_init();\n\nUNKNOWN_FUNCTION(_evt_msg_print);\n\n// evt_msg_print(u32 flags, const char * msg, s32 mainFunc, const char * speaker)\nEVT_DECLARE_USER_FUNC(evt_msg_print, 4)\n\n\nUNKNOWN_FUNCTION(evt_msg_print_insert);\n\n//evt_msg_print_add(u32 flags, const char * message)\nEVT_DECLARE_USER_FUNC(evt_msg_print_add, 2)\n\nEVT_DECLARE_USER_FUNC(evt_msg_print_add_insert, -1)\n\n// evt_msg_continue()\nEVT_DECLARE_USER_FUNC(evt_msg_continue, 0)\n\nUNKNOWN_FUNCTION(evt_msg_repeat);\nUNKNOWN_FUNCTION(evt_msg_close);\nUNKNOWN_FUNCTION(evt_msg_select);\n\nEVT_DECLARE_USER_FUNC(evt_msg_toge, 4)\n\nUNKNOWN_FUNCTION(evt_msg_togelr);\nUNKNOWN_FUNCTION(evt_msg_pri);\nUNKNOWN_FUNCTION(evtMsgFmtStr);\n\nEVT_DECLARE_USER_FUNC(evt_msg_fmt_str, -1)\n\nUNKNOWN_FUNCTION(evtMsgFmtInt);\nUNKNOWN_FUNCTION(evt_msg_fmt_int);\nUNKNOWN_FUNCTION(func_800fdc6c);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_npc)\n\nUNKNOWN_FUNCTION(_intplGetFloat);\nUNKNOWN_FUNCTION(evtNpcNameToPtr);\nUNKNOWN_FUNCTION(evtNpcNameToPtr_NoAssert);\n\n// evt_npc_get_position(const char * name, f32& x, f32& y, f32& z)\nEVT_DECLARE_USER_FUNC(evt_npc_get_position, 4)\n\n// evt_npc_set_position(const char * instanceName, f32 x, f32 y, f32 z)\nEVT_DECLARE_USER_FUNC(evt_npc_set_position, 4)\n\nUNKNOWN_FUNCTION(func_800fe338);\nUNKNOWN_FUNCTION(func_800fe404);\nUNKNOWN_FUNCTION(func_800fe4e8);\nUNKNOWN_FUNCTION(evt_npc_get_rotation);\nEVT_DECLARE_USER_FUNC(evt_npc_rotate, 4)\nUNKNOWN_FUNCTION(func_800fe760);\nUNKNOWN_FUNCTION(func_800fe82c);\nEVT_DECLARE_USER_FUNC(func_800fe92c, 4)\nUNKNOWN_FUNCTION(func_800fea70);\nUNKNOWN_FUNCTION(func_800feb54);\nUNKNOWN_FUNCTION(func_800fec04);\nUNKNOWN_FUNCTION(func_800fecd0);\nUNKNOWN_FUNCTION(func_800fed9c);\nUNKNOWN_FUNCTION(func_800fee80);\nEVT_UNKNOWN_USER_FUNC(func_800fef30)\nUNKNOWN_FUNCTION(func_800feffc);\nUNKNOWN_FUNCTION(func_800ff100);\nUNKNOWN_FUNCTION(func_800ff1cc);\nUNKNOWN_FUNCTION(func_800ff2a8);\nUNKNOWN_FUNCTION(func_800ff3ec);\nUNKNOWN_FUNCTION(func_800ff470);\nUNKNOWN_FUNCTION(func_800ff5a4);\nUNKNOWN_FUNCTION(func_800ff6f4);\nUNKNOWN_FUNCTION(func_800ff86c);\nEVT_UNKNOWN_USER_FUNC(func_800ff8f8)\nUNKNOWN_FUNCTION(func_800ff9a4);\nUNKNOWN_FUNCTION(func_800ffab4);\nEVT_DECLARE_USER_FUNC(evt_npc_walk_to, 8)\n\n// evt_npc_jump_to(const char * name, f32 destX, f32 destY, f32 destZ, f32 height, s32 length)\nEVT_DECLARE_USER_FUNC(evt_npc_jump_to, 6)\n\nUNKNOWN_FUNCTION(func_801006fc);\nUNKNOWN_FUNCTION(func_80100df8);\nUNKNOWN_FUNCTION(func_80101328);\nUNKNOWN_FUNCTION(func_8010144c);\nUNKNOWN_FUNCTION(func_8010159c);\nUNKNOWN_FUNCTION(func_801017b8);\nUNKNOWN_FUNCTION(func_80101e60);\nUNKNOWN_FUNCTION(func_80101f48);\nUNKNOWN_FUNCTION(func_80102424);\nEVT_UNKNOWN_USER_FUNC(evt_npc_glide_to)\nEVT_UNKNOWN_USER_FUNC(func_80102bf8)\nUNKNOWN_FUNCTION(evt_npc_get_hp);\nUNKNOWN_FUNCTION(evt_npc_get_max_hp);\nUNKNOWN_FUNCTION(evt_npc_set_hp);\n\n// evt_npc_delete(const char * name)\nEVT_DECLARE_USER_FUNC(evt_npc_delete, 1)\n\n//(s32 tribeId, int)\nEVT_DECLARE_USER_FUNC(evt_npc_stats_set_up, 2)\n\n// evt_npc_entry(const char * instanceName, const char * animPoseName, s32 instanceId)\nEVT_DECLARE_USER_FUNC(evt_npc_entry, 3)\n\n\nUNKNOWN_FUNCTION(func_80102fe4);\nEVT_DECLARE_USER_FUNC(evt_npc_add_flip_part, 1)\nEVT_DECLARE_USER_FUNC(evt_npc_set_anim, 3)\nUNKNOWN_FUNCTION(func_801031a0);\nUNKNOWN_FUNCTION(func_80103268);\nUNKNOWN_FUNCTION(evt_npc_get_cur_anim);\nUNKNOWN_FUNCTION(evt_npc_search_anim_defs);\n\n// func_80103410(const char * npcName, s32 partId)\nEVT_DECLARE_USER_FUNC(func_80103410, 2)\n\nUNKNOWN_FUNCTION(func_80103574);\n\n// evt_npc_flag8_onoff(const char * instanceName, bool on, u32 mask)\nEVT_DECLARE_USER_FUNC(evt_npc_flag8_onoff, 3)\n\nUNKNOWN_FUNCTION(evt_npc_flagC_onoff);\nUNKNOWN_FUNCTION(evt_npc_flag46C_onoff);\nUNKNOWN_FUNCTION(evt_npc_flag10_onoff);\nUNKNOWN_FUNCTION(evt_npc_part_flag_onoff);\n\n// evt_npc_animflag_onoff(const char * instanceName, bool on, u32 mask)\nEVT_DECLARE_USER_FUNC(evt_npc_animflag_onoff, 3)\n\nUNKNOWN_FUNCTION(func_80103a44);\nUNKNOWN_FUNCTION(func_80103b40);\nUNKNOWN_FUNCTION(func_80103c24);\nUNKNOWN_FUNCTION(func_80103d20);\nUNKNOWN_FUNCTION(evt_npc_get_unitwork);\n\n\n// evt_npc_set_unitwork(const char * name, s32 idx, s32 val)\nEVT_DECLARE_USER_FUNC(evt_npc_set_unitwork, 3)\n\nUNKNOWN_FUNCTION(evt_npc_get_partswork);\nUNKNOWN_FUNCTION(evt_npc_set_partswork);\nUNKNOWN_FUNCTION(func_80104174);\nUNKNOWN_FUNCTION(func_80104230);\nUNKNOWN_FUNCTION(func_80104304);\nUNKNOWN_FUNCTION(func_801043c0);\nUNKNOWN_FUNCTION(func_80104494);\nUNKNOWN_FUNCTION(func_80104508);\nUNKNOWN_FUNCTION(func_8010457c);\nUNKNOWN_FUNCTION(func_801045ac);\nUNKNOWN_FUNCTION(func_801045dc);\nUNKNOWN_FUNCTION(func_80104638);\nEVT_DECLARE_USER_FUNC(func_80104694, 2)\nUNKNOWN_FUNCTION(func_801046f4);\nUNKNOWN_FUNCTION(func_80104750);\nUNKNOWN_FUNCTION(func_801047ac);\nUNKNOWN_FUNCTION(func_8010480c);\nUNKNOWN_FUNCTION(func_8010486c);\nUNKNOWN_FUNCTION(func_801048cc);\nUNKNOWN_FUNCTION(func_8010495c);\nEVT_UNKNOWN_USER_FUNC(func_801049ec)\nUNKNOWN_FUNCTION(func_80104a3c);\nUNKNOWN_FUNCTION(func_80104a94);\nUNKNOWN_FUNCTION(func_80104af0);\nUNKNOWN_FUNCTION(func_80104b4c);\nUNKNOWN_FUNCTION(func_80104ba8);\nUNKNOWN_FUNCTION(func_80104c10);\n\n// evt_npc_set_property(const char * instanceName, s32 propertyId, s32 value)\nEVT_DECLARE_USER_FUNC(evt_npc_set_property, 3)\n\nUNKNOWN_FUNCTION(modifyPartProperty);\n\n/*\n    partId -1 updates all parts\n*/\n// evt_npc_set_property(const char * instanceName, s32 partId, s32 propertyId, s32 value)\nEVT_DECLARE_USER_FUNC(evt_npc_modify_part, 4)\n\nUNKNOWN_FUNCTION(evt_npc_get_property);\nUNKNOWN_FUNCTION(func_80105248);\nUNKNOWN_FUNCTION(func_801053b4);\nUNKNOWN_FUNCTION(func_80105548);\nEVT_UNKNOWN_USER_FUNC(evt_npc_wait_flip_finished)\nEVT_UNKNOWN_USER_FUNC(evt_npc_finish_flip_instant)\nUNKNOWN_FUNCTION(evt_npc_check_3d);\nEVT_UNKNOWN_USER_FUNC(evt_npc_flip_to)\nEVT_UNKNOWN_USER_FUNC(evt_npc_flip)\nUNKNOWN_FUNCTION(func_801057cc);\nUNKNOWN_FUNCTION(func_80105828);\nUNKNOWN_FUNCTION(func_801058c8);\n\n// evt_npc_get_axis_movement_unit(const char * name, f32& ret)\nEVT_DECLARE_USER_FUNC(evt_npc_get_axis_movement_unit, 2)\n\nEVT_DECLARE_USER_FUNC(func_801059d0, 2)\nUNKNOWN_FUNCTION(func_80105a30);\nUNKNOWN_FUNCTION(func_80105b00);\nEVT_UNKNOWN_USER_FUNC(func_80105b94)\nUNKNOWN_FUNCTION(func_80105bdc);\nUNKNOWN_FUNCTION(func_8010611c);\nUNKNOWN_FUNCTION(func_801061c8);\nUNKNOWN_FUNCTION(func_80106260);\nUNKNOWN_FUNCTION(func_801062b0);\nUNKNOWN_FUNCTION(func_80106300);\nUNKNOWN_FUNCTION(evt_read_setup_file);\n\n// evt_npc_entry_from_template(s32 instanceIdOverride, s32 templateId, s32 x, s32 y,\n//                             s32 z, &s32 instanceId, &char * instanceName)\nEVT_DECLARE_USER_FUNC(evt_npc_entry_from_template, 7)\n\nUNKNOWN_FUNCTION(func_80106904);\nUNKNOWN_FUNCTION(someEvtNpcTemplateSpawn2);\nUNKNOWN_FUNCTION(evt_npc_spawn_sammer_guy);\nUNKNOWN_FUNCTION(func_80106f78);\nUNKNOWN_FUNCTION(func_80106ffc);\nUNKNOWN_FUNCTION(func_80107044);\nUNKNOWN_FUNCTION(func_801070a4);\nUNKNOWN_FUNCTION(func_8010712c);\nUNKNOWN_FUNCTION(func_80107190);\nUNKNOWN_FUNCTION(func_801071f4);\nUNKNOWN_FUNCTION(func_801072a4);\nUNKNOWN_FUNCTION(func_801072f8);\nUNKNOWN_FUNCTION(evt_npc_get_coin_drop_count);\nUNKNOWN_FUNCTION(evt_npc_get_drop_item_type);\n\nEVT_DECLARE_USER_FUNC(evt_npc_id_to_name, 2)\n\nUNKNOWN_FUNCTION(func_801075b8);\nUNKNOWN_FUNCTION(func_80107600);\nUNKNOWN_FUNCTION(func_80107648);\nUNKNOWN_FUNCTION(evt_npc_get_timer_start);\nUNKNOWN_FUNCTION(func_8010781c);\nUNKNOWN_FUNCTION(func_80107910);\nUNKNOWN_FUNCTION(func_801079f0);\nUNKNOWN_FUNCTION(func_80107a5c);\nUNKNOWN_FUNCTION(func_80107ac8);\nUNKNOWN_FUNCTION(func_80107b34);\nUNKNOWN_FUNCTION(func_80107b80);\n\n\n// evt_npc_set_camid(const char * name, s32 camId)\nEVT_DECLARE_USER_FUNC(evt_npc_set_camid, 2)\n\nEVT_DECLARE_USER_FUNC(func_80107c38, 2)\nEVT_DECLARE_USER_FUNC(func_80107cfc, 0)\nEVT_DECLARE_USER_FUNC(func_80107d20, 0)\nUNKNOWN_FUNCTION(func_80107d44);\nUNKNOWN_FUNCTION(func_80107d90);\nUNKNOWN_FUNCTION(func_80107ddc);\nUNKNOWN_FUNCTION(func_80107e40);\nUNKNOWN_FUNCTION(func_80107ec0);\nUNKNOWN_FUNCTION(func_80107f78);\nUNKNOWN_FUNCTION(func_80108054);\nEVT_DECLARE_USER_FUNC(func_80108194, 2)\nUNKNOWN_FUNCTION(func_80108224);\nUNKNOWN_FUNCTION(func_801082f0);\nUNKNOWN_FUNCTION(func_801083d8);\nUNKNOWN_FUNCTION(func_80108440);\nUNKNOWN_FUNCTION(func_801084fc);\nUNKNOWN_FUNCTION(func_801085e4);\nEVT_UNKNOWN_USER_FUNC(func_801086fc)\nUNKNOWN_FUNCTION(func_8010874c);\nUNKNOWN_FUNCTION(func_801087d8);\nUNKNOWN_FUNCTION(func_80108930);\nUNKNOWN_FUNCTION(func_801089d0);\nUNKNOWN_FUNCTION(func_80108a2c);\nUNKNOWN_FUNCTION(func_80108ac0);\nUNKNOWN_FUNCTION(func_80108b8c);\nUNKNOWN_FUNCTION(func_80108bd4);\nUNKNOWN_FUNCTION(func_80108cc0);\nUNKNOWN_FUNCTION(evt_npc_set_part_attack_power);\nUNKNOWN_FUNCTION(func_80108ebc);\nUNKNOWN_FUNCTION(func_80108f50);\nUNKNOWN_FUNCTION(func_80108fe4);\nUNKNOWN_FUNCTION(func_80109078);\nUNKNOWN_FUNCTION(func_801090f4);\nUNKNOWN_FUNCTION(func_801091e0);\nUNKNOWN_FUNCTION(func_80109250);\nUNKNOWN_FUNCTION(func_801092c0);\nUNKNOWN_FUNCTION(func_80109370);\nUNKNOWN_FUNCTION(func_801093e0);\nUNKNOWN_FUNCTION(func_80109434);\nUNKNOWN_FUNCTION(func_801094b4);\nUNKNOWN_FUNCTION(func_80109548);\nUNKNOWN_FUNCTION(func_801095b8);\nUNKNOWN_FUNCTION(func_80109628);\nUNKNOWN_FUNCTION(func_80109698);\nUNKNOWN_FUNCTION(func_801097b0);\nUNKNOWN_FUNCTION(func_8010982c);\nUNKNOWN_FUNCTION(marioLuigiNpcDispCb);\nUNKNOWN_FUNCTION(func_80109980);\nUNKNOWN_FUNCTION(func_80109a00);\nUNKNOWN_FUNCTION(func_80109b10);\nUNKNOWN_FUNCTION(func_80109c20);\nUNKNOWN_FUNCTION(func_80109ca0);\nUNKNOWN_FUNCTION(func_80109d20);\nUNKNOWN_FUNCTION(evt_npc_set_disp_callback);\nUNKNOWN_FUNCTION(func_80109e18);\nUNKNOWN_FUNCTION(func_80109e94);\nUNKNOWN_FUNCTION(func_80109f18);\nUNKNOWN_FUNCTION(func_8010a008);\nUNKNOWN_FUNCTION(func_8010a060);\nUNKNOWN_FUNCTION(func_8010a0e8);\nUNKNOWN_FUNCTION(func_8010a148);\nUNKNOWN_FUNCTION(func_8010a1c4);\nUNKNOWN_FUNCTION(func_8010a1e8);\nUNKNOWN_FUNCTION(func_8010a298);\nUNKNOWN_FUNCTION(evt_npc_try_catch_card);\nUNKNOWN_FUNCTION(func_8010a37c);\nUNKNOWN_FUNCTION(func_8010a418);\nUNKNOWN_FUNCTION(func_8010a4ec);\nUNKNOWN_FUNCTION(func_8010a5ec);\nUNKNOWN_FUNCTION(func_8010a788);\nUNKNOWN_FUNCTION(func_8010a808);\n\n// evt_npc_teleport_effect(bool appearDisappear, const char * instanceName)\nEVT_DECLARE_USER_FUNC(evt_npc_teleport_effect, 2)\n\nUNKNOWN_FUNCTION(func_8010aadc);\nUNKNOWN_FUNCTION(func_8010ab58);\nUNKNOWN_FUNCTION(func_8010abd4);\nUNKNOWN_FUNCTION(func_8010ac50);\nUNKNOWN_FUNCTION(func_8010b550);\nUNKNOWN_FUNCTION(func_8010bc44);\nUNKNOWN_FUNCTION(func_8010bcf0);\nUNKNOWN_FUNCTION(evt_npc_agb_async);\n\n// evt_npc_tribe_agb_async(s32 tribeId)\nEVT_DECLARE_USER_FUNC(evt_npc_tribe_agb_async, 1)\n\nUNKNOWN_FUNCTION(func_8010bf5c);\nUNKNOWN_FUNCTION(func_8010bfa8);\nUNKNOWN_FUNCTION(evt_npc_handle_hit_xp);\nUNKNOWN_FUNCTION(func_8010c088);\nUNKNOWN_FUNCTION(func_8010c110);\nUNKNOWN_FUNCTION(func_8010c16c);\nUNKNOWN_FUNCTION(func_8010c1e8);\nUNKNOWN_FUNCTION(func_8010c264);\nUNKNOWN_FUNCTION(func_8010c2e0);\nUNKNOWN_FUNCTION(func_8010c35c);\nUNKNOWN_FUNCTION(func_8010c3e8);\nUNKNOWN_FUNCTION(func_8010c440);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_offscreen)\n\nEVT_UNKNOWN_USER_FUNC(func_8010c4a4)\nEVT_UNKNOWN_USER_FUNC(func_8010c4d4)\nEVT_UNKNOWN_USER_FUNC(func_8010c504)\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_paper)\n\nEVT_DECLARE_USER_FUNC(evt_paper_entry, 1)\n\nEVT_DECLARE_USER_FUNC(evt_paper_delete, 1)\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_pouch)\n\nEVT_DECLARE_USER_FUNC(evt_pouch_set_hp, 1)\nEVT_DECLARE_USER_FUNC(evt_pouch_get_hp, 1)\nEVT_DECLARE_USER_FUNC(evt_pouch_add_hp, 1)\nEVT_DECLARE_USER_FUNC(evt_pouch_get_max_hp, 1)\nEVT_DECLARE_USER_FUNC(evt_pouch_set_max_hp, 1)\nEVT_DECLARE_USER_FUNC(evt_pouch_get_xp, 1)\nEVT_DECLARE_USER_FUNC(evt_pouch_add_xp, 1)\nEVT_DECLARE_USER_FUNC(evt_pouch_set_attack, 1)\nEVT_DECLARE_USER_FUNC(evt_pouch_get_attack, 1)\nEVT_DECLARE_USER_FUNC(evt_pouch_add_attack, 1)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_set_coins)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_get_coins)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_add_coins)\n\n// evt_pouch_add_item(s32 id)\nEVT_DECLARE_USER_FUNC(evt_pouch_add_item, 1)\n\n// evt_pouch_check_have_item(s32 id, bool& ret)\nEVT_DECLARE_USER_FUNC(evt_pouch_check_have_item, 2)\n\nEVT_DECLARE_USER_FUNC(evt_pouch_remove_item, 1)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_remove_item_idx)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_add_shop_itme)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_remove_shop_item)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_remove_shop_item_idx)\n\n// evt_pouch_set_pixl_selected(s32 id)\nEVT_DECLARE_USER_FUNC(evt_pouch_set_pixl_selected, 1)\n\n\nEVT_UNKNOWN_USER_FUNC(evt_pouch_count_use_items)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_count_free_shop_items)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_count_shop_items)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_check_free_use_item)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_change_char_selectable)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_change_pixl_selectable)\nEVT_DECLARE_USER_FUNC(evt_pouch_get_level, 1)\nEVT_DECLARE_USER_FUNC(evt_pouch_set_level, 1)\nEVT_DECLARE_USER_FUNC(evt_pouch_get_next_level_xp, 1)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_get_arcade_tokens)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_set_arcade_tokens)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_get_total_coins_collected)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_get_max_jump_combo)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_get_max_stylish_combo)\nEVT_UNKNOWN_USER_FUNC(evt_pouch_get_enemies_defeated)\n\n//evt_pouch_increment_enemies_defeated(void)\nEVT_DECLARE_USER_FUNC(evt_pouch_increment_enemies_defeated, 0)\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_seq)\n\n// evt_seq_set_seq(s32 seq, void * p0, void * p1)\nEVT_DECLARE_USER_FUNC(evt_seq_set_seq, 3)\n\n// evt_seq_wait(s32 seq)\nEVT_DECLARE_USER_FUNC(evt_seq_wait, 1)\n\nUNKNOWN_FUNCTION(evt_seq_mapchange);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_shop)\n\ntypedef struct\n{\n/* 0x00 */ s32 type;\n/* 0x04 */ const char * npcName;\n/* 0x08 */ s32 * items; // [itemId, price, arg] repeated then [-1]\n/* 0x0C */ const char * case1Name;\n/* 0x10 */ const char * case2Name;\n} EvtShopDef;\nSIZE_ASSERT(EvtShopDef, 0x14)\n\nEVT_UNKNOWN_USER_FUNC(evt_shop_wait_coin_sfx)\nEVT_UNKNOWN_USER_FUNC(func_8010d2b8)\nEVT_UNKNOWN_USER_FUNC(evt_shop_get_name_items)\nEVT_UNKNOWN_USER_FUNC(func_8010d3d4)\nEVT_UNKNOWN_USER_FUNC(evt_shop_get_fortune_message)\nEVT_UNKNOWN_USER_FUNC(func_8010d5b8)\nEVT_UNKNOWN_USER_FUNC(func_8010d674)\nEVT_UNKNOWN_USER_FUNC(func_8010da90)\nEVT_UNKNOWN_USER_FUNC(func_8010db80)\nEVT_UNKNOWN_USER_FUNC(func_8010dc04)\nEVT_UNKNOWN_USER_FUNC(func_8010e020)\nEVT_UNKNOWN_USER_FUNC(func_8010e110)\nEVT_UNKNOWN_USER_FUNC(evt_shop_get_point_reward)\nEVT_UNKNOWN_USER_FUNC(evt_shop_set_point_reward_collected)\nEVT_UNKNOWN_USER_FUNC(evt_shop_get_shop_points)\nEVT_UNKNOWN_USER_FUNC(evt_shop_add_shop_point)\nEVT_UNKNOWN_USER_FUNC(evt_shop_clear_shop_points)\nEVT_UNKNOWN_USER_FUNC(evt_shop_howzit_select_item)\nEVT_UNKNOWN_USER_FUNC(evt_shop_build_howzit_item_table)\nEVT_UNKNOWN_USER_FUNC(func_8010e700)\nEVT_UNKNOWN_USER_FUNC(evt_shop_add_charm)\nEVT_UNKNOWN_USER_FUNC(func_8010e8bc)\nEVT_UNKNOWN_USER_FUNC(func_8010ea10)\nEVT_UNKNOWN_USER_FUNC(func_8010ea78)\nEVT_UNKNOWN_USER_FUNC(func_8010eb1c)\nEVT_UNKNOWN_USER_FUNC(func_8010eb60)\nEVT_UNKNOWN_USER_FUNC(func_8010ed70)\nEVT_UNKNOWN_USER_FUNC(evt_shop_get_card_give_info)\nEVT_UNKNOWN_USER_FUNC(evt_shop_get_card_bag)\nEVT_UNKNOWN_USER_FUNC(evt_shop_select_card)\nEVT_UNKNOWN_USER_FUNC(evt_shop_count_cards)\nEVT_UNKNOWN_USER_FUNC(evt_shop_init_card_item_flags)\nEVT_UNKNOWN_USER_FUNC(evt_shop_remove_card)\nEVT_UNKNOWN_USER_FUNC(evt_shop_init_flopside_cards)\nEVT_UNKNOWN_USER_FUNC(evt_shop_get_buy_price)\nEVT_UNKNOWN_USER_FUNC(func_801103b8)\nEVT_UNKNOWN_USER_FUNC(evt_shop_get_map_info)\nEVT_UNKNOWN_USER_FUNC(evt_shop_build_map_table)\nEVT_UNKNOWN_USER_FUNC(func_801108f4)\nEVT_UNKNOWN_USER_FUNC(evt_shop_check_all_maps_owned)\nEVT_UNKNOWN_USER_FUNC(evt_shop_build_flimm_flipside_item_tables)\nEVT_UNKNOWN_USER_FUNC(func_80110ac4)\nEVT_UNKNOWN_USER_FUNC(evt_shop_filter_flimm_flipside_items)\nEVT_UNKNOWN_USER_FUNC(evt_shop_flimm_select_item)\nEVT_UNKNOWN_USER_FUNC(func_80111074)\nEVT_UNKNOWN_USER_FUNC(func_80111334)\nEVT_UNKNOWN_USER_FUNC(evt_shop_build_flimm_pit_item_tables)\nEVT_UNKNOWN_USER_FUNC(evt_shop_restore_itemdata_prices)\nEVT_UNKNOWN_USER_FUNC(evt_shop_filter_flimm_pit_items)\nEVT_UNKNOWN_USER_FUNC(evt_shop_select_item)\nEVT_UNKNOWN_USER_FUNC(evt_shop_remove_item)\nEVT_UNKNOWN_USER_FUNC(evt_shop_handle_roten_item_flag)\nEVT_UNKNOWN_USER_FUNC(evt_shop_get_otoya_bgm)\n\n// evt_shop_set_defs(EvtShopDef * defs, s32 count)\nEVT_DECLARE_USER_FUNC(evt_shop_set_defs, 2)\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_snd)\n\n// evt_snd_bgmon(s32 bgmPlayerId, const char * name)\nEVT_DECLARE_USER_FUNC(evt_snd_bgmon, 2)\n\nEVT_DECLARE_USER_FUNC(evt_snd_bgmon_f_d, 3)\n\n// evt_snd_bgmoff(s32 bgmPlayerId)\nEVT_DECLARE_USER_FUNC(evt_snd_bgmoff, 1)\nEVT_DECLARE_USER_FUNC(evt_snd_bgmoff_f_d, 2)\n\nEVT_UNKNOWN_USER_FUNC(func_800d2268)\nEVT_UNKNOWN_USER_FUNC(func_800d2294)\nEVT_UNKNOWN_USER_FUNC(func_800d22d8)\nUNKNOWN_FUNCTION(func_800d231c);\nUNKNOWN_FUNCTION(func_800d2388);\nUNKNOWN_FUNCTION(func_800d23cc);\nUNKNOWN_FUNCTION(func_800d2438);\nUNKNOWN_FUNCTION(func_800d247c);\n\n// evt_snd_get_bgm_wait_time(s32 bgmPlayerId, s32& ret)\nEVT_DECLARE_USER_FUNC(evt_snd_get_bgm_wait_time, 2)\n\nUNKNOWN_FUNCTION(evt_snd_get_bgm_name);\n\n// evt_snd_sfxon(const char * name)\nEVT_DECLARE_USER_FUNC(evt_snd_sfxon, 1)\n\n\nUNKNOWN_FUNCTION(func_800d2834);\nUNKNOWN_FUNCTION(func_800d2894);\n\nEVT_DECLARE_USER_FUNC(evt_snd_sfxon_character, 4)\n\n// evt_snd_sfxon_3d(const char * name, f32 x, f32 y, f32 z)\nEVT_DECLARE_USER_FUNC(evt_snd_sfxon_3d, 4)\n\nUNKNOWN_FUNCTION(func_800d2a58);\n\n// evt_snd_sfxon_npc(const char * sfxName, const char * npcName)\nEVT_DECLARE_USER_FUNC(evt_snd_sfxon_npc, 2)\n\n// evt_snd_sfxon_npc_delay(const char * sfxName, const char * npcName, s32 delayTime)\nEVT_DECLARE_USER_FUNC(evt_snd_sfxon_npc_delay, 3)\n\n// evt_snd_sfxon_3d_player(const char * name)\nEVT_DECLARE_USER_FUNC(evt_snd_sfxon_3d_player, 1)\n\nUNKNOWN_FUNCTION(func_800d2c58);\n\n// evt_snd_sfxon_3d_player_character(const char * marioName, const char * peach,\n//                                   const char * bowserName, const char * luigiName)\nEVT_DECLARE_USER_FUNC(evt_snd_sfxon_3d_player_character, 4)\n\nUNKNOWN_FUNCTION(func_800d2db8);\nUNKNOWN_FUNCTION(func_800d2ed0);\n\n// evt_snd_sfxoff(s32 id)\nEVT_DECLARE_USER_FUNC(evt_snd_sfxoff, 1)\n\nEVT_DECLARE_USER_FUNC(func_800d2fa4, 2)\nUNKNOWN_FUNCTION(func_800d3000);\n\n// evt_snd_get_last_sfx_id(s32& ret)\nEVT_DECLARE_USER_FUNC(evt_snd_get_last_sfx_id, 1)\nUNKNOWN_FUNCTION(func_800d3060);\nUNKNOWN_FUNCTION(func_800d30e8);\nEVT_UNKNOWN_USER_FUNC(func_800d3144)\nEVT_UNKNOWN_USER_FUNC(func_800d31a0)\nUNKNOWN_FUNCTION(func_800d31d0);\nUNKNOWN_FUNCTION(func_800d3248);\nEVT_DECLARE_USER_FUNC(evt_snd_sfx_wait, 1)\nEVT_DECLARE_USER_FUNC(evt_snd_sfx_wait_name, 1)\nUNKNOWN_FUNCTION(evt_snd_sfx_flag_on);\nUNKNOWN_FUNCTION(evt_snd_sfx_flag_off);\nUNKNOWN_FUNCTION(func_800d33dc);\nUNKNOWN_FUNCTION(evt_snd_envon);\nEVT_DECLARE_USER_FUNC(evt_snd_envon_f, 3)\nEVT_DECLARE_USER_FUNC(evt_snd_string_call, 1)\nUNKNOWN_FUNCTION(func_800d34e4);\nUNKNOWN_FUNCTION(func_800d3528);\nUNKNOWN_FUNCTION(func_800d3594);\nEVT_UNKNOWN_USER_FUNC(func_800d35d8)\nEVT_UNKNOWN_USER_FUNC(func_800d3644)\nUNKNOWN_FUNCTION(func_800d3688);\n\n// evt_snd_set_sfx_reverb_mode(s32 mode)\nEVT_DECLARE_USER_FUNC(evt_snd_set_sfx_reverb_mode, 1)\n\nUNKNOWN_FUNCTION(evt_snd_flag_on);\nUNKNOWN_FUNCTION(evt_snd_flag_off);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::evt_sub)\n\nUNKNOWN_FUNCTION(func_800d378c);\nEVT_DECLARE_USER_FUNC(evt_sub_intpl_msec_init, 4)\nEVT_DECLARE_USER_FUNC(evt_sub_intpl_msec_get_value, 0)\nUNKNOWN_FUNCTION(evt_sub_intpl_msec_get_value_para);\nUNKNOWN_FUNCTION(evt_sub_spline_init);\nUNKNOWN_FUNCTION(evt_sub_spline_get_value);\nUNKNOWN_FUNCTION(evt_sub_spline_get_value_manual);\nUNKNOWN_FUNCTION(evt_sub_spline_free);\nUNKNOWN_FUNCTION(evt_sub_get_sincos);\nUNKNOWN_FUNCTION(evt_sub_rumble_onoff);\n\n// Gives a random number from 0 to max (inclusive)\n// evt_sub_random(s32 max, s32& ret)\nEVT_DECLARE_USER_FUNC(evt_sub_random, 2)\n\nUNKNOWN_FUNCTION(evt_sub_get_stopwatch);\nUNKNOWN_FUNCTION(func_800d41a8);\nUNKNOWN_FUNCTION(evt_sub_get_dist);\nUNKNOWN_FUNCTION(evt_sub_get_dir);\nUNKNOWN_FUNCTION(evt_sub_get_system_flag);\nUNKNOWN_FUNCTION(func_800d4460);\nUNKNOWN_FUNCTION(evt_key_get_button);\nUNKNOWN_FUNCTION(evt_key_get_buttonrep);\nUNKNOWN_FUNCTION(evt_key_get_buttontrg);\nUNKNOWN_FUNCTION(func_800d45ac);\nUNKNOWN_FUNCTION(func_800d45dc);\nUNKNOWN_FUNCTION(func_800d46a4);\n\n//evt_sub_set_game_speed(float newSpeed)\nEVT_DECLARE_USER_FUNC(evt_sub_set_game_speed, 1)\n\nUNKNOWN_FUNCTION(evt_sub_get_mapname);\n\n\n// Returns the door/bero name\n// evt_sub_get_entername(&char* ret)\nEVT_DECLARE_USER_FUNC(evt_sub_get_entername, 1)\n\nUNKNOWN_FUNCTION(evt_sub_set_entername);\nUNKNOWN_FUNCTION(func_800d47e4);\nEVT_DECLARE_USER_FUNC(evt_sub_get_language, 1)\n\n// evt_sub_animgroup_async(const char * name)\nEVT_DECLARE_USER_FUNC(evt_sub_animgroup_async, 1)\n\nUNKNOWN_FUNCTION(evt_sub_file_async);\nUNKNOWN_FUNCTION(evt_sub_load_mapdata_bin);\nUNKNOWN_FUNCTION(evt_sub_get_fps);\nUNKNOWN_FUNCTION(evt_sub_fmt_str_int);\nUNKNOWN_FUNCTION(func_800d4b4c);\nUNKNOWN_FUNCTION(func_800d4b60);\nUNKNOWN_FUNCTION(evt_hud_configure);\nUNKNOWN_FUNCTION(func_800d4db0);\nEVT_DECLARE_USER_FUNC(func_800d4de4, 2)\nUNKNOWN_FUNCTION(func_800d4e48);\nUNKNOWN_FUNCTION(func_800d5004);\nUNKNOWN_FUNCTION(func_800d52a8);\nUNKNOWN_FUNCTION(func_800d5588);\nUNKNOWN_FUNCTION(func_800d59ac);\nUNKNOWN_FUNCTION(func_800d59f0);\nUNKNOWN_FUNCTION(func_800d5a24);\nUNKNOWN_FUNCTION(func_800d5a60);\nUNKNOWN_FUNCTION(func_800d5a94);\nUNKNOWN_FUNCTION(func_800d5acc);\nUNKNOWN_FUNCTION(func_800d5e80);\nUNKNOWN_FUNCTION(func_800d6148);\nUNKNOWN_FUNCTION(func_800d61ac);\nUNKNOWN_FUNCTION(func_800d6230);\nUNKNOWN_FUNCTION(func_800d6298);\nUNKNOWN_FUNCTION(func_800d6308);\nUNKNOWN_FUNCTION(func_800d6644);\nUNKNOWN_FUNCTION(func_800d6674);\nEVT_DECLARE_USER_FUNC(func_800d74a0, 2)\nUNKNOWN_FUNCTION(func_800d776c);\nUNKNOWN_FUNCTION(func_800d7858);\nUNKNOWN_FUNCTION(evt_sub_get_save_name);\nUNKNOWN_FUNCTION(evt_zero_vector);\nEVT_UNKNOWN_USER_FUNC(func_800d7930)\nUNKNOWN_FUNCTION(func_800d7b9c);\nUNKNOWN_FUNCTION(func_800d7e70);\nUNKNOWN_FUNCTION(func_800d815c);\nUNKNOWN_FUNCTION(func_800d8498);\nUNKNOWN_FUNCTION(func_800d8700);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::extdrv)\n\nvoid extInit();\nUNKNOWN_FUNCTION(extInit);\nUNKNOWN_FUNCTION(extEntry);\nUNKNOWN_FUNCTION(extMakeTexture);\nUNKNOWN_FUNCTION(extReset);\nvoid extMain();\nUNKNOWN_FUNCTION(compare);\nUNKNOWN_FUNCTION(extGetPosePtr);\nUNKNOWN_FUNCTION(func_80065848);\nUNKNOWN_FUNCTION(extDraw);\nUNKNOWN_FUNCTION(extLoadRenderMode);\nUNKNOWN_FUNCTION(extLoadVertex);\nUNKNOWN_FUNCTION(extLoadTexture);\nUNKNOWN_FUNCTION(extLoadTextureExit);\nUNKNOWN_FUNCTION(extLoadTev);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::fadedrv)\n\nvoid fadeInit();\nUNKNOWN_FUNCTION(fadeEntry);\nUNKNOWN_FUNCTION(func_80066558);\nvoid fadeMain();\nUNKNOWN_FUNCTION(func_80066e4c);\nUNKNOWN_FUNCTION(func_80067588);\nbool fadeIsFinish();\nUNKNOWN_FUNCTION(func_80067824);\nUNKNOWN_FUNCTION(func_8006783c);\nUNKNOWN_FUNCTION(func_800678d0);\nUNKNOWN_FUNCTION(func_800678dc);\n\n/*\n    Sets the transition to be used on the next map change\n    Doesn't affect anything internally in fadedrv, it's just stored with a getter\n    for callers (in map change and minigames) of fadeEntry to use\n*/\nvoid fadeSetMapChangeTransition(s32 in, s32 out);\n\nUNKNOWN_FUNCTION(func_800678fc);\nUNKNOWN_FUNCTION(func_80067908);\nUNKNOWN_FUNCTION(func_80067914);\nUNKNOWN_FUNCTION(func_80067928);\nUNKNOWN_FUNCTION(func_800679d0);\nUNKNOWN_FUNCTION(func_800679d8);\n\nCPP_WRAPPER_END()\n/*\n    fairy controls Pixl entities in game (except Tippi), as well as luvbi and squirps\n*/\n\n\n\nCPP_WRAPPER(spm::fairy)\n\nUSING(wii::gx::GXColor)\nUSING(wii::mtx::Vec3)\n\n#define FAIRYRunEnd 7\n\nenum FairyExtraNo\n{\n/* 0x0 */ FAIRY_EXTRA_TAMARA, // Squirps\n/* 0x1 */ FAIRY_EXTRA_ANGEKO // Luvbi\n};\n\nstruct _FairyEntry;\n\n// Returns an override for the name\ntypedef const char * (FairyAnimChangeHandler)(struct _FairyEntry * fairy, const char * newAnimName);\n\ntypedef struct _FairyEntry\n{\n    /*\n        1 is hide & disable all fairies\n        Others unknown\n    */\n/* 0x00 */ u16 flag0;\n    /*\n        2 is anim changed\n        1 is run mode changed\n        Others unknown\n    */\n/* 0x02 */ u16 flag2;\n/* 0x04 */ s32 itemId; // 0 for extra entries\n/* 0x08 */ u8 unknown_0x8[0xc - 0x8];\n/* 0x0C */ s32 animPoseId;\n/* 0x10 */ const char * curAnimName;\n/* 0x14 */ FairyAnimChangeHandler * animChangeHandler;\n/* 0x18 */ GXColor materialEvtColor;\n/* 0x1C */ u8 unknown_0x1c[0x28 - 0x1c];\n    /*\n        Run modes are from 0-6\n        Currently unknown what each one is\n    */\n/* 0x28 */ s32 runMode;\n/* 0x2C */ s32 prevRunMode;\n/* 0x30 */ u8 unknown_0x30[0x48 - 0x30];\n/* 0x48 */ Vec3 position;\n/* 0x54 */ u8 unknown_0x54[0xd0 - 0x54];\n} FairyEntry;\nSIZE_ASSERT(FairyEntry, 0xd0)\n\ntypedef struct\n{\n/* 0x000 */ u32 flags;\n/* 0x004 */ FairyEntry entries[4];\n/* 0x344 */ s32 max; // 4\n/* 0x348 */ s32 num;\n/* 0x34C */ s32 numExtra;\n/* 0x350 */ s32 extraNo;\n/* 0x354 */ u8 unknown_0x354[0x368 - 0x354];\n} FairyWork;\nSIZE_ASSERT(FairyWork, 0x368)\n\nDECOMP_STATIC(FairyWork fairy_work)\n\nDECOMP_STATIC(const char * fairy_extraAnimPoseNames[2])\n\nUNKNOWN_FUNCTION(func_8011bc08);\nUNKNOWN_FUNCTION(func_8011c4d8);\nUNKNOWN_FUNCTION(func_8011c920);\nUNKNOWN_FUNCTION(func_8011ceb4);\nUNKNOWN_FUNCTION(func_8011d300);\nUNKNOWN_FUNCTION(func_8011d3bc);\nUNKNOWN_FUNCTION(func_8011d440);\n\n/*\n    Creates a fairy entry for the currently selected pixl\n*/\nvoid fairyEntry();\n\n/*\n    Calls _fairyReInit\n*/\nvoid fairyReset();\n\n/*\n    Clears fairy work\n*/\nvoid fairyInit();\n\n/*\n    Calls _fairyReInit\n*/\nvoid fairyReInit();\n\n/*\n    Updates a fairy entry\n*/\nvoid fairyUpdate(FairyEntry * thisFairy, FairyEntry * otherFairy);\n\n/*\n    Calls fairyUpdate for each entry, first with otherFairy as\n    NULL and then with it as every other fairy entry one by one\n*/\nvoid fairyMain();\n\n/*\n    Renders a fairy\n*/\nvoid fairyDisp(s8 camId, FairyEntry * fairy);\n\n/*\n    Does unknown calculations and schedules fairyDisp to run for this fairy this frame\n*/\nvoid fairyDispMain(FairyEntry * fairy);\n\n/*\n    Re-creates all fairys\n*/\nvoid _fairyReInit();\n\n/*\n    Gets a fairy entry by id\n*/\nFairyEntry * fairyIdToPtr(s32 id);\n\n/*\n    Gets a fairy entry by item id\n*/\nFairyEntry * fairyItemIdToPtr(s32 itemId);\n\n/*\n    Returns a pointer to the 'extra' FairyEntries\n*/\nFairyEntry * fairyGetExtra();\n\n/*\n    Sets curAnimName to an new name, and allows animChangeHandler to override it\n*/\nvoid fairySetAnim(FairyEntry * fairy, const char * animName);\n\nUNKNOWN_FUNCTION(func_8011ea48);\n\n/*\n    Functions to change the current run mode of a fairy\n*/\nvoid fairyEnterRunMode(FairyEntry * fairy, s32 runMode);\nvoid fairyIdEnterRunMode(s32 id, s32 runMode);\n    // Less checks & clears flag2 0x1 instead of setting\nvoid fairyEnterRunModeAlt(FairyEntry * fairy, s32 RunMode);\nvoid fairyIdEnterRunMode0(s32 id);\nvoid fairyIdEnterRunMode1(s32 id);\nvoid fairyAllEnterRunMode0();\nvoid fairyAllEnterRunMode1();\nvoid fairyIdEnterRunMode2();\nvoid fairyAllEnterRunMode2();\n\n/*\n    Sets position of all fairies\n*/\nvoid fairySetAllPositions(Vec3 * position);\n\nUNKNOWN_FUNCTION(func_8011f2d4);\nUNKNOWN_FUNCTION(func_8011f320);\n\n/*\n    Returns a pointer to all FairyEntries\n*/\nFairyEntry * fairyGetEntries();\n\n/*\n    Returns how many normal/extra fairies there are\n*/\ns32 fairyGetNum();\ns32 fairyGetNumExtra();\n\nUNKNOWN_FUNCTION(func_8011f39c);\nUNKNOWN_FUNCTION(func_8011f3b0);\nUNKNOWN_FUNCTION(func_8011f45c);\nUNKNOWN_FUNCTION(func_8011f534);\n\n/*\n    Configures the animPose for this fairy based on entry fields\n*/\nvoid fairyUpdateAnimPose(FairyEntry * entry);\n\n/*\n    Sets the alpha of materialEvtColor\n*/\nvoid fairySetMaterialEvtAlpha(FairyEntry * entry, u8 alpha);\n\n/*\n    Creates a 'extra' fairy entry for the character specified by extra no\n*/\nvoid fairyExtraEntry(s32 extraNo);\n\n/*\n    Deletes the 'extra' fairy entry\n*/\nvoid fairyFreeExtra();\n\n/*\n    Disable & hide / enable & unhide all fairies\n*/\nvoid fairyOff();\nvoid fairyOn();\n\nCPP_WRAPPER_END()\n/*\n    fontmgr allows for text to be drawn on the screen\n*/\n\n\n\nCPP_WRAPPER(spm::fontmgr)\n\nUSING(wii::gx::GXColor)\nUSING(wii::mtx::Mtx34)\nUSING(wii::mtx::Vec3)\n\nDECOMP_STATIC(GXColor fontmgr_fontColor) // Color of text, alpha ignored\nDECOMP_STATIC(u8 fontmgr_fontAlpha) // Alpha of text\nDECOMP_STATIC(s32 fontmgr_fontEdge) // Whether the font edge is turned on\nDECOMP_STATIC(u8 fontmgr_lbl_805ae994)\nDECOMP_STATIC(void * fontmgr_pfh)\nDECOMP_STATIC(u32 fontmgr_lbl_805ae99c)\nDECOMP_STATIC(u32 fontmgr_lbl_805ae9a0)\nDECOMP_STATIC(f32 fontmgr_fontScale[3]) // Scale of text\n\n/*\n    Loads the font from disc\n*/\nvoid fontmgrInit();\n\n/*\n    Sets up drawing a new string\n*/  \nvoid FontDrawStart();\n\n/*\n    Sets up drawing a new string with custom transparency\n    (setting the alpha in FontDrawColor's GXColor doesn't work correctly)\n*/\nvoid FontDrawStart_alpha(u8 alpha);\n\n/*\n    Enable / disable drawing a border around text\n*/\nvoid FontDrawEdge();\nvoid FontDrawEdgeOff();\n\n/*\n    Control text changing colour over time\n*/\nvoid FontDrawRainbowColor();\nvoid FontDrawRainbowColorOff();\n\n/*\n    Control noise of text\n*/\nvoid FontDrawNoise();\nvoid FontDrawNoiseOff();\n\n/*\n    Set the text colour to a pre-defined or custom one\n*/\nvoid FontDrawColorIDX(u32 idx);\nvoid FontDrawColor(GXColor * color); // Warning: Overwrites color.a\n\nvoid FontDrawColor_();\n\n/*\n    Returns the current text colour\n*/\nGXColor FontGetDrawColor();\n\n/*\n    Sets the text scale\n*/\nvoid FontDrawScale(f32 scale);\n\nvoid FontDrawCode(f32 x, f32 y, u16 code);\nvoid FontDrawCodeMtx(Mtx34 matrix, u16 code);\n\n/*\n    Draws a string of text at a position\n*/\nvoid FontDrawString(f32 x, f32 y, const char * string);\n\nvoid FontDrawStringVecPitch(Vec3 position, f32 pitch, const char * string);\nvoid FontDrawStringMtx(Mtx34 matrix, const char * string);\nvoid FontDrawStringCenterMtx(Mtx34 matrix, const char * string);\nvoid FontDrawMessage(s32 x, s32 y, const char * message);\nvoid FontDrawMessageMtx(Mtx34 matrix, const char * message);\nu16 hankakuSearch(u8 code);\nu16 kanjiSearch(u16 code);\nu8 kanjiGetWidth(u16 code);\nu16 FontGetMessageWidthLine(const char * message, u16 * outlines);\n\n/*\n    Returns the width a string will cover when drawn\n*/\nu16 FontGetMessageWidth(const char * message);\n\nu32 HSV2RGB(u8 hsv[3]);\n\nUNKNOWN_FUNCTION(JUTFontSetup);\nUNKNOWN_FUNCTION(func_801a2ebc);\nUNKNOWN_FUNCTION(func_801a2ec4);\nUNKNOWN_FUNCTION(JUTFont_CodeToGlyph);\nUNKNOWN_FUNCTION(JUTFont_DrawStart);\nUNKNOWN_FUNCTION(_JUTFont_DrawPos);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::framedrv)\n\nvoid frameInit();\nvoid frameReInit();\nvoid frameMain();\nUNKNOWN_FUNCTION(func_80067c94);\nUNKNOWN_FUNCTION(func_800680a4);\nUNKNOWN_FUNCTION(func_80068254);\nUNKNOWN_FUNCTION(func_800682d8);\nUNKNOWN_FUNCTION(func_80068358);\nUNKNOWN_FUNCTION(func_80068708);\nUNKNOWN_FUNCTION(func_80068b84);\nUNKNOWN_FUNCTION(func_80068e34);\nUNKNOWN_FUNCTION(func_80068e60);\nUNKNOWN_FUNCTION(func_80069050);\nUNKNOWN_FUNCTION(func_800691c0);\nUNKNOWN_FUNCTION(func_80069284);\nUNKNOWN_FUNCTION(func_80069334);\nUNKNOWN_FUNCTION(func_80069420);\nUNKNOWN_FUNCTION(func_8006958c);\nUNKNOWN_FUNCTION(func_8006966c);\nUNKNOWN_FUNCTION(func_8006972c);\nUNKNOWN_FUNCTION(func_800697ec);\nUNKNOWN_FUNCTION(func_800698ac);\nUNKNOWN_FUNCTION(func_80069a48);\nUNKNOWN_FUNCTION(func_80069b8c);\nUNKNOWN_FUNCTION(func_8006a1b0);\nUNKNOWN_FUNCTION(func_8006a3ac);\nUNKNOWN_FUNCTION(func_8006ad9c);\n\nCPP_WRAPPER_END()\n/*\n    guide controls Tippi & Tiptron\n*/\n\n\n\nCPP_WRAPPER(spm::guide)\n\nUSING(wii::mtx::Vec3)\n\n#define GUIDERunEnd 6\n\n// Hide and disable tippi\n#define GUIDE_FLAG0_DISABLE 0x80\n\n// Returns an override for the name\ntypedef const char * (GuideAnimChangeHandler)(const char * newAnimName);\n\ntypedef struct\n{\n    /*\n        See defines above\n    */\n/* 0x00 */ u16 flag0;\n    /*\n        All unknown\n    */\n/* 0x02 */ u8 flag2;\n    /*\n        0x2 is anim changed\n        0x1 is run mode changed\n        Others unknown\n    */\n/* 0x03 */ u8 flag3;\n/* 0x04 */ u8 unknown_0x4[0x8 - 0x4];\n/* 0x08 */ s32 animPoseId;\n/* 0x0C */ char curAnimName[4];\n/* 0x10 */ u8 unknown_0x10[0x1c - 0x10];\n/* 0x1C */ GuideAnimChangeHandler * animChangeHandler;\n    /*\n        Run modes are from 0-5\n        Currently unknown what each one is\n    */\n/* 0x20 */ s32 runMode;\n/* 0x24 */ s32 prevRunMode;\n/* 0x28 */ u8 unknown_0x28[0x40 - 0x28];\n/* 0x40 */ Vec3 pos;\n/* 0x4C */ u8 unknown_0x4c[0xb4 - 0x4c];\n} GuideWork;\nSIZE_ASSERT(GuideWork, 0xb4)\n\nDECOMP_STATIC(GuideWork guide_work)\n\ntypedef void (GuideRunModeFunc)(GuideWork * work);\n\nDECOMP_STATIC(GuideRunModeFunc * guide_runModeMainFuncs[6])\n\n/*\n    Returns a pointer to guideWork\n*/\nGuideWork * guideGetWork();\n\n/*\n    Clears guideWork and sets animPoseId to -1\n*/  \nvoid guideInit();\n\n/*\n    Loads the model and does other unknown tasks\n*/\nvoid guideReInit();\n\n/*\n    Updates and calls the main func for this runMode\n*/\nvoid guideMain();\n\n/*\n    Does unknown calculations and schedules guideDisp to run this frame\n*/\nvoid guideDispMain();\n\n/*\n    Renders Tippi/Tiptron\n*/\nvoid guideDisp(GuideWork * work);\n\n/*\n    Functions ran every frame based on the current runMode\n*/\nvoid runMode0Main(GuideWork * work);\nvoid runMode1Main(GuideWork * work);\nvoid runMode2Main(GuideWork * work);\nvoid runMode3Main(GuideWork * work);\nvoid runMode4Main(GuideWork * work);\nvoid runMode5Main(GuideWork * work);\n\nUNKNOWN_FUNCTION(func_801215f0);\nUNKNOWN_FUNCTION(func_8012167c);\nUNKNOWN_FUNCTION(func_80121900);\nUNKNOWN_FUNCTION(func_80121948);\n\n/*\n    Sets curAnimName to an new name, and allows animChangeHandler to override it\n*/\nvoid guideSetAnim(const char * name);\n\n/*\n    Functions to change the current run mode\n*/\nvoid guideEnterRunMode(s32 runMode);\nvoid guideEnterRunMode1();\nvoid guideEnterRunMode2();\nvoid guideEnterRunMode5(f32, f32, Vec3 *);\n\nUNKNOWN_FUNCTION(func_80121ba4);\nUNKNOWN_FUNCTION(func_80121bc8);\nUNKNOWN_FUNCTION(func_80121bcc);\nUNKNOWN_FUNCTION(guideCanSearch);\nUNKNOWN_FUNCTION(func_80121d84);\nUNKNOWN_FUNCTION(func_80121db4);\nUNKNOWN_FUNCTION(func_80121e18);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::gxsub)\n\nUSING(spm::camdrv::CamEntry)\nUSING(wii::mtx::Mtx34)\nUSING(wii::gx::GXColor)\nUSING(wii::tpl::TPLHeader)\n\nvoid gxsubInit_Tpl(TPLHeader * tpl);\nvoid gxsubDrawTextureMtx(u32 texId, Mtx34 * mtx, const GXColor * colour);\nvoid gxsubDrawTexture(u32 texId, f32 x, f32 y, f32 width, f32 height, const GXColor * colour);\nf32 gxsubGetTexWidth(u32 texId);\nf32 gxsubGetTexHeight(u32 texId);\nvoid gxsubEnableTexAlpha();\nvoid gxsubInit(); // general use\nvoid gxsubInit_Cam(CamEntry * camera); // gxsubInit + specify active camera\nvoid gxsubInit_Colour(); // sets vertex format to include colours\n                         // (incompatible with normal functions)\nvoid gxsubDrawQuad(f32 x, f32 y, f32 width, f32 height, const GXColor * colour);\nvoid gxsubDrawQuadMtx(Mtx34 * mtx, f32 width, f32 height, const GXColor * colour);\nvoid gxsubDrawQuadGradient(f32 x, f32 y, f32 width, f32 height, GXColor * startColour,\n                           GXColor * endColour); // requires gxsubInit_Colour\nvoid gxsubDrawLineSquare(f32 x, f32 y, f32 width, f32 height, u32 thickness,\n                         const GXColor * colour);\nvoid gxsubDrawLineSquareMtx(Mtx34 * mtx, f32 width, f32 height, u32 thickness,\n                            const GXColor * colour);\nvoid gxsubDrawDottedLine(Mtx34 * mtx, f32 width, f32 height, u32 thickness,\n                         const GXColor * colour); // requires no init\nvoid gxsubDrawLine(Mtx34 * mtx, f32 width, f32 height, u32 thickness, const GXColor * colour);\nvoid gxsubDrawSphere(Mtx34 * mtx, const GXColor * colour);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::homebuttondrv)\n\n#define HOMEBUTTON_FLAG_OPEN 0x10\n#define HOMEBUTTON_FLAG_CONTROLLER_DC 0x20\n#define HOMEBUTTON_FLAG_FORBIDDEN 0x40\n\ntypedef struct\n{\n/* 0x00 */ s32 state;\n/* 0x04 */ u16 flags;\n/* 0x06 */ u8 unknown_0x6[0xa0 - 0x6];\n} HomeButtonWork;\nSIZE_ASSERT(HomeButtonWork, 0xa0)\n\nDECOMP_STATIC(HomeButtonWork * homebuttondrv_wp)\n\nvoid homebuttonInit();\nUNKNOWN_FUNCTION(func_802418c8);\nbool homebuttonMain();\nbool func_80242198();\nUNKNOWN_FUNCTION(homebuttonAllowOpen);\nUNKNOWN_FUNCTION(homebuttonForbidOpen);\nUNKNOWN_FUNCTION(func_802421dc);\nUNKNOWN_FUNCTION(func_802421f0);\nUNKNOWN_FUNCTION(homebuttonDumpEfb);\nUNKNOWN_FUNCTION(homebuttonDisp);\n\nCPP_WRAPPER_END()\n\n\n// TODO: probably called statuswindow\n\nCPP_WRAPPER(spm::hud)\n\nvoid hudInit();\nvoid hudReInit();\nUNKNOWN_FUNCTION(hudLoadStats);\nvoid hudMain();\nUNKNOWN_FUNCTION(hudGetPos);\nUNKNOWN_FUNCTION(hudUnhideAlt);\nvoid hudHide();\nUNKNOWN_FUNCTION(func_80199b0c);\nUNKNOWN_FUNCTION(func_80199b5c);\nUNKNOWN_FUNCTION(hudUnhide);\nUNKNOWN_FUNCTION(func_80199c74);\nUNKNOWN_FUNCTION(func_80199c88);\nUNKNOWN_FUNCTION(func_80199c9c);\nUNKNOWN_FUNCTION(func_80199cb0);\ntypedef void (CountdownDoneCb)();\nvoid hudStartCountdown(u32 length, CountdownDoneCb * cb);\nUNKNOWN_FUNCTION(func_80199cf8);\nUNKNOWN_FUNCTION(hudUpdateStats);\nUNKNOWN_FUNCTION(hudDisp);\nvoid func_8019af88();\nvoid hudTurnOffFlipTimeBox(s32 idx);\nUNKNOWN_FUNCTION(func_8019b0dc);\nUNKNOWN_FUNCTION(func_8019be84);\nUNKNOWN_FUNCTION(func_8019bea8);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::imgdrv)\n\nUNKNOWN_FUNCTION(func_8007508c);\nUNKNOWN_FUNCTION(func_80075290);\nUNKNOWN_FUNCTION(func_80075530);\nUNKNOWN_FUNCTION(func_80075554);\nUNKNOWN_FUNCTION(func_80075b40);\nUNKNOWN_FUNCTION(func_8007634c);\nUNKNOWN_FUNCTION(func_80076620);\nUNKNOWN_FUNCTION(func_80076750);\nUNKNOWN_FUNCTION(func_80076abc);\nvoid imgInit();\nUNKNOWN_FUNCTION(func_80076bb4);\nUNKNOWN_FUNCTION(func_80076c8c);\nvoid imgMain();\nUNKNOWN_FUNCTION(func_8007706c);\nUNKNOWN_FUNCTION(func_8007711c);\nUNKNOWN_FUNCTION(func_80077178);\nUNKNOWN_FUNCTION(func_80077188);\nUNKNOWN_FUNCTION(func_80077240);\n\nCPP_WRAPPER_END()\n/*\n    item_data defines the properties of the game's items\n*/\n\n\n\n\n\nCPP_WRAPPER(spm::item_data)\n\n#define ITEM_ID_KEY_START 16\n#define ITEM_ID_KEY_MAX 65\n#define ITEM_ID_USE_START 65\n#define ITEM_ID_USE_MAX 216\n#define ITEM_ID_COOK_START 120\n#define ITEM_ID_COOK_MAX 216\n#define ITEM_ID_CHAR_START 216\n#define ITEM_ID_CHAR_MAX 220\n#define ITEM_ID_FAIRY_START 220\n#define ITEM_ID_FAIRY_MAX 232\n#define ITEM_ID_MAP_START 234\n#define ITEM_ID_MAP_MAX 282\n#define ITEM_ID_CARD_START 282\n#define ITEM_ID_CARD_MAX 538\n#define ITEM_ID_MAX 538\n\nenum ItemType\n{\n/* 0x000 */ ITEM_ID_NULL,\n\n    // In-world items\n/* 0x001 */ ITEM_ID_WORLD_COIN,\n/* 0x002 */ ITEM_ID_WORLD_COIN_x3,\n/* 0x003 */ ITEM_ID_WORLD_SPEED_FLOWER,\n/* 0x004 */ ITEM_ID_WORLD_SLOW_FLOWER,\n/* 0x005 */ ITEM_ID_WORLD_HAPPY_FLOWER,\n/* 0x006 */ ITEM_ID_WORLD_KINOKO,\n/* 0x007 */ ITEM_ID_WORLD_SUPER_KINOKO,\n/* 0x008 */ ITEM_ID_WORLD_ULTRA_KINOKO,\n/* 0x009 */ ITEM_ID_WORLD_BUNSHIN_KINOKO,\n/* 0x00A */ ITEM_ID_WORLD_DOT_STAR,\n/* 0x00B */ ITEM_ID_WORLD_SPEED_CHOKO,\n/* 0x00C */ ITEM_ID_WORLD_POWERUP_CHOKO,\n/* 0x00D */ ITEM_ID_WORLD_MISSILE_CHOKO,\n/* 0x00E */ ITEM_ID_WORLD_BUNSHIN_CHOKO,\n/* 0x00F */ ITEM_ID_WORLD_BARRIER_CHOKO,\n\n    // Key items\n/* 0x010 */ ITEM_ID_KEY_STG1_KEY_00,\n/* 0x011 */ ITEM_ID_KEY_STG2_KEY_00,\n/* 0x012 */ ITEM_ID_KEY_STG2_KEY_01,\n/* 0x013 */ ITEM_ID_KEY_STG3_KEY_00,\n/* 0x014 */ ITEM_ID_KEY_STG3_KEY_01,\n/* 0x015 */ ITEM_ID_KEY_STG3_KEY_02,\n/* 0x016 */ ITEM_ID_KEY_STG4_KINGYO,\n/* 0x017 */ ITEM_ID_KEY_STG4_KINGYO2,\n/* 0x018 */ ITEM_ID_KEY_STG4_HELMET,\n/* 0x019 */ ITEM_ID_KEY_STG4_KOMONJYO,\n/* 0x01A */ ITEM_ID_KEY_STG4_KEY_00,\n/* 0x01B */ ITEM_ID_KEY_STG4_KEY_01,\n/* 0x01C */ ITEM_ID_KEY_STG4_KEY_02,\n/* 0x01D */ ITEM_ID_KEY_STG4_KEY_03,\n/* 0x01E */ ITEM_ID_KEY_STG5_SEKIBAN1,\n/* 0x01F */ ITEM_ID_KEY_STG5_SEKIBAN2,\n/* 0x020 */ ITEM_ID_KEY_STG5_SEKIBAN3,\n/* 0x021 */ ITEM_ID_KEY_STG5_JEWEL,\n/* 0x022 */ ITEM_ID_KEY_STG5_KEY_00,\n/* 0x023 */ ITEM_ID_KEY_STG5_KEY_01,\n/* 0x024 */ ITEM_ID_KEY_STG5_ME,\n/* 0x025 */ ITEM_ID_KEY_STG7_KEY_00,\n/* 0x026 */ ITEM_ID_KEY_STG7_KEY_01,\n/* 0x027 */ ITEM_ID_KEY_STG7_DIETBOOK,\n/* 0x028 */ ITEM_ID_KEY_STG7_KEY_HEAVEN,\n/* 0x029 */ ITEM_ID_KEY_STG7_BLUE_BALL,\n/* 0x02A */ ITEM_ID_KEY_STG7_YELLOW_BALL,\n/* 0x02B */ ITEM_ID_KEY_STG7_RED_BALL,\n/* 0x02C */ ITEM_ID_KEY_URA_DAN_KEY,\n/* 0x02D */ ITEM_ID_KEY_STG7_PEACH,\n/* 0x02E */ ITEM_ID_KEY_STG8_KEY_CASTLE,\n/* 0x02F */ ITEM_ID_KEY_MAC_KEY_00,\n/* 0x030 */ ITEM_ID_KEY_DAN_KEY,\n/* 0x031 */ ITEM_ID_KEY_STG7_WATER_KEY,\n/* 0x032 */ ITEM_ID_KEY_POCKET_DOKAN,\n/* 0x033 */ ITEM_ID_KEY_CRYSTAL_BALL,\n/* 0x034 */ ITEM_ID_KEY_TRAINING_MACHINE,\n/* 0x035 */ ITEM_ID_KEY_REINOMONO,\n/* 0x036 */ ITEM_ID_KEY_PAPERBOARD,\n/* 0x037 */ ITEM_ID_KEY_SIGNED_PAPERBOARD,\n/* 0x038 */ ITEM_ID_KEY_MAC_KEY_HOUSE,\n/* 0x039 */ ITEM_ID_KEY_DISK_R,\n/* 0x03A */ ITEM_ID_KEY_DISK_W,\n/* 0x03B */ ITEM_ID_KEY_DISK_Y,\n/* 0x03C */ ITEM_ID_KEY_DISK_B,\n/* 0x03D */ ITEM_ID_KEY_DISK_G,\n/* 0x03E */ ITEM_ID_KEY_DISK_PU,\n/* 0x03F */ ITEM_ID_KEY_DISK_PI,\n/* 0x040 */ ITEM_ID_KEY_GOLD_CARD,\n\n    // Usable items\n/* 0x041 */ ITEM_ID_USE_HONOO_SAKURETU,\n/* 0x042 */ ITEM_ID_USE_KOORI_NO_IBUKI,\n/* 0x043 */ ITEM_ID_USE_KAMINARI_DOKKAN,\n/* 0x044 */ ITEM_ID_USE_KIRAKIRA_OTOSHI,\n/* 0x045 */ ITEM_ID_USE_POW_BLOCK,\n/* 0x046 */ ITEM_ID_USE_KOURA_DE_PON,\n/* 0x047 */ ITEM_ID_USE_KINKAI_100,\n/* 0x048 */ ITEM_ID_USE_KINKAI_300,\n/* 0x049 */ ITEM_ID_USE_BARIA_FRAME,\n/* 0x04A */ ITEM_ID_USE_KACHIKACHI_KOURA,\n/* 0x04B */ ITEM_ID_USE_TUYOTUYO_DRINK,\n/* 0x04C */ ITEM_ID_USE_BIRIBIRI_KINOKO,\n/* 0x04D */ ITEM_ID_USE_OBAKE_KINOKO,\n/* 0x04E */ ITEM_ID_USE_NEMURE_YOIKO,\n/* 0x04F */ ITEM_ID_USE_STOPWATCH,\n/* 0x050 */ ITEM_ID_USE_KINOKO_DRINK,\n/* 0x051 */ ITEM_ID_USE_SUPER_DRINK,\n/* 0x052 */ ITEM_ID_USE_ULTRA_DRINK,\n/* 0x053 */ ITEM_ID_USE_SHINABITA_KINOKO,\n/* 0x054 */ ITEM_ID_USE_KINKYU_KINOKO,\n/* 0x055 */ ITEM_ID_USE_JIWAJIWA_DRINK,\n/* 0x056 */ ITEM_ID_USE_NANIGA_OKORUKANA,\n/* 0x057 */ ITEM_ID_USE_BLANK_KUN,\n/* 0x058 */ ITEM_ID_USE_SUPER_BLANK_KUN,\n/* 0x059 */ ITEM_ID_USE_HEART_FUERU,\n/* 0x05A */ ITEM_ID_USE_POWER_PLUS,\n/* 0x05B */ ITEM_ID_USE_STG7_BLUE_FRUITS,\n/* 0x05C */ ITEM_ID_USE_STG7_ORANGE_FRUITS,\n/* 0x05D */ ITEM_ID_USE_STG7_RED_FRUITS,\n/* 0x05E */ ITEM_ID_USE_STG7_PINK_FRUITS,\n/* 0x05F */ ITEM_ID_USE_STG7_BLACK_FRUITS,\n/* 0x060 */ ITEM_ID_USE_STAR_MEDAL,\n/* 0x061 */ ITEM_ID_USE_GOLD_MEDAL,\n/* 0x062 */ ITEM_ID_USE_DOKU_KINOKO,\n/* 0x063 */ ITEM_ID_USE_NURU_KINOKO,\n/* 0x064 */ ITEM_ID_USE_PICHI_PEACH,\n/* 0x065 */ ITEM_ID_USE_TOROPICO_MANGO,\n/* 0x066 */ ITEM_ID_USE_PRIMITIVENUT,\n/* 0x067 */ ITEM_ID_USE_GOLD_LEAF,\n/* 0x068 */ ITEM_ID_USE_KAME_LEAF,\n/* 0x069 */ ITEM_ID_USE_INGREDIENTS_OF_SWEET,\n/* 0x06A */ ITEM_ID_USE_TANKOBU,\n/* 0x06B */ ITEM_ID_USE_TUKUSHINBO,\n/* 0x06C */ ITEM_ID_USE_ROW_PASTA,\n/* 0x06D */ ITEM_ID_USE_RED_CHILI_PEPPER,\n/* 0x06E */ ITEM_ID_USE_SUMI_SOUP,\n/* 0x06F */ ITEM_ID_USE_PANSY_TEARS,\n/* 0x070 */ ITEM_ID_USE_HANA_SOUP,\n/* 0x071 */ ITEM_ID_USE_MEET,\n/* 0x072 */ ITEM_ID_USE_VEGETABLES,\n/* 0x073 */ ITEM_ID_USE_HERB,\n/* 0x074 */ ITEM_ID_USE_HACHIMITU,\n/* 0x075 */ ITEM_ID_USE_POWERFUL_MEET,\n/* 0x076 */ ITEM_ID_USE_BIG_EGG,\n/* 0x077 */ ITEM_ID_USE_MILD_CACAO,\n/* 0x078 */ ITEM_ID_COOK_SWEET_CHOKO,\n/* 0x079 */ ITEM_ID_COOK_KINOKO_CHOKO,\n/* 0x07A */ ITEM_ID_COOK_GOLD_CHOKO,\n/* 0x07B */ ITEM_ID_COOK_JIWA_SYRUP,\n/* 0x07C */ ITEM_ID_COOK_PANSY_SYRUP,\n/* 0x07D */ ITEM_ID_COOK_NURU_ESSENCE,\n/* 0x07E */ ITEM_ID_COOK_KINOKO_FRY,\n/* 0x07F */ ITEM_ID_COOK_KINOKO_HOILE_FRY,\n/* 0x080 */ ITEM_ID_COOK_KINOKO_STEAK,\n/* 0x081 */ ITEM_ID_COOK_HUNNY_KINOKO,\n/* 0x082 */ ITEM_ID_COOK_HUNNY_KINOKO_S,\n/* 0x083 */ ITEM_ID_COOK_TEA_KINOKO,\n/* 0x084 */ ITEM_ID_COOK_KINOKO_CREPE,\n/* 0x085 */ ITEM_ID_COOK_KINOKO_CAKE,\n/* 0x086 */ ITEM_ID_COOK_CHOCOLA_CAKE,\n/* 0x087 */ ITEM_ID_COOK_MERO_CAKE,\n/* 0x088 */ ITEM_ID_COOK_MOUSSE_CAKE,\n/* 0x089 */ ITEM_ID_COOK_PEACH_TART,\n/* 0x08A */ ITEM_ID_COOK_TUKUSHI_TART,\n/* 0x08B */ ITEM_ID_COOK_SWEET_COOKIE,\n/* 0x08C */ ITEM_ID_COOK_KAME_MAN,\n/* 0x08D */ ITEM_ID_COOK_HANA_DANGO,\n/* 0x08E */ ITEM_ID_COOK_PRIMITIVE_SPECIAL,\n/* 0x08F */ ITEM_ID_COOK_MANGO_PUDDING,\n/* 0x090 */ ITEM_ID_COOK_LOVE_PUDDING,\n/* 0x091 */ ITEM_ID_COOK_FOREVER,\n/* 0x092 */ ITEM_ID_COOK_FRUITS_PARFAIT,\n/* 0x093 */ ITEM_ID_COOK_FRAPPE,\n/* 0x094 */ ITEM_ID_COOK_SNOW_RABBIT,\n/* 0x095 */ ITEM_ID_COOK_ICHIGO_RABBIT,\n/* 0x096 */ ITEM_ID_COOK_HUNNY_CANDY,\n/* 0x097 */ ITEM_ID_COOK_BIRI_CANDY,\n/* 0x098 */ ITEM_ID_COOK_HERB_TEA,\n/* 0x099 */ ITEM_ID_COOK_KAME_TEA,\n/* 0x09A */ ITEM_ID_COOK_SPAGHETTI,\n/* 0x09B */ ITEM_ID_COOK_KARAI_PASTA,\n/* 0x09C */ ITEM_ID_COOK_IKASUMI_PASTA,\n/* 0x09D */ ITEM_ID_COOK_KAME_SPA,\n/* 0x09E */ ITEM_ID_COOK_LOVE_NOODLE,\n/* 0x09F */ ITEM_ID_COOK_SUNNY_SIDE_UP,\n/* 0x0A0 */ ITEM_ID_COOK_BOMB_EGG,\n/* 0x0A1 */ ITEM_ID_COOK_DOROCY_DYNAMITE,\n/* 0x0A2 */ ITEM_ID_COOK_BARBECUE,\n/* 0x0A3 */ ITEM_ID_COOK_DINNER,\n/* 0x0A4 */ ITEM_ID_COOK_OMELET,\n/* 0x0A5 */ ITEM_ID_COOK_HOT_SOUP,\n/* 0x0A6 */ ITEM_ID_COOK_HOTDOG,\n/* 0x0A7 */ ITEM_ID_COOK_HEALTHY_SALAD,\n/* 0x0A8 */ ITEM_ID_COOK_DOROCY_DINNER,\n/* 0x0A9 */ ITEM_ID_COOK_DOROCY_SPECIAL,\n/* 0x0AA */ ITEM_ID_COOK_DOROCY_DELUX,\n/* 0x0AB */ ITEM_ID_COOK_SPACE_MEAL,\n/* 0x0AC */ ITEM_ID_COOK_EMERGENCY_MEAL,\n/* 0x0AD */ ITEM_ID_COOK_DANGEROUS_COOKING,\n/* 0x0AE */ ITEM_ID_COOK_TRIAL_PAN,\n/* 0x0AF */ ITEM_ID_COOK_FAIL_COOKING1,\n/* 0x0B0 */ ITEM_ID_COOK_FAIL_COOKING2,\n/* 0x0B1 */ ITEM_ID_COOK_HOT_COCOA,\n/* 0x0B2 */ ITEM_ID_COOK_DOUBTFUL_DINNER,\n/* 0x0B3 */ ITEM_ID_COOK_IKASUMI_SOUP,\n/* 0x0B4 */ ITEM_ID_COOK_SUGER_HOUSE,\n/* 0x0B5 */ ITEM_ID_COOK_VOLCANO_KINOKO,\n/* 0x0B6 */ ITEM_ID_COOK_KAMEKAME_RICE,\n/* 0x0B7 */ ITEM_ID_COOK_KARAKARA_COOK,\n/* 0x0B8 */ ITEM_ID_COOK_KINOKO_PUDDING,\n/* 0x0B9 */ ITEM_ID_COOK_GERORIN_FOOD,\n/* 0x0BA */ ITEM_ID_COOK_RPIMITIVE_COOK,\n/* 0x0BB */ ITEM_ID_COOK_GORGEOUS_STEAK,\n/* 0x0BC */ ITEM_ID_COOK_GOLDEN_FOOD,\n/* 0x0BD */ ITEM_ID_COOK_GOTTUAN_SET,\n/* 0x0BE */ ITEM_ID_COOK_KOBUYAKI,\n/* 0x0BF */ ITEM_ID_COOK_JESSY_MORNING,\n/* 0x0C0 */ ITEM_ID_COOK_JESSY_LUNCH,\n/* 0x0C1 */ ITEM_ID_COOK_SUIKA_JUICE,\n/* 0x0C2 */ ITEM_ID_COOK_SUTAMINA_JUICE,\n/* 0x0C3 */ ITEM_ID_COOK_CHOKO_PASTA,\n/* 0x0C4 */ ITEM_ID_COOK_CHINMI_KINOKO,\n/* 0x0C5 */ ITEM_ID_COOK_TUKUSHI_YAKI,\n/* 0x0C6 */ ITEM_ID_COOK_HANAJIRU_SYRUP,\n/* 0x0C7 */ ITEM_ID_COOK_HUMBURG,\n/* 0x0C8 */ ITEM_ID_COOK_PEACH_JUICE,\n/* 0x0C9 */ ITEM_ID_COOK_NORMAL_CHOKO,\n/* 0x0CA */ ITEM_ID_COOK_FRUITS_CAKE,\n/* 0x0CB */ ITEM_ID_COOK_FRUITS_HUMBURG,\n/* 0x0CC */ ITEM_ID_COOK_FRUITS_PONCH,\n/* 0x0CD */ ITEM_ID_COOK_FRUITS_KINOKO,\n/* 0x0CE */ ITEM_ID_COOK_FRAME_FOOD,\n/* 0x0CF */ ITEM_ID_COOK_VEGETABLES_SET,\n/* 0x0D0 */ ITEM_ID_COOK_HENTEKO_EKIS,\n/* 0x0D1 */ ITEM_ID_COOK_HOGEHOGE_SNUCK,\n/* 0x0D2 */ ITEM_ID_COOK_MANGO_JUICE,\n/* 0x0D3 */ ITEM_ID_COOK_MEET_PASTA,\n/* 0x0D4 */ ITEM_ID_COOK_MIX_SHAKE,\n/* 0x0D5 */ ITEM_ID_COOK_MIRACLE_COOK,\n/* 0x0D6 */ ITEM_ID_COOK_MEGATON_DINNER,\n/* 0x0D7 */ ITEM_ID_COOK_LOVELY_CHOKO,\n\n    // Character\n/* 0x0D8 */ ITEM_ID_CHAR_MARIO,\n/* 0x0D9 */ ITEM_ID_CHAR_PEACH,\n/* 0x0DA */ ITEM_ID_CHAR_KOOPA,\n/* 0x0DB */ ITEM_ID_CHAR_LUIGI,\n\n    // Pixl\n/* 0x0DC */ ITEM_ID_FAIRY_MONOSHIRI,\n/* 0x0DD */ ITEM_ID_FAIRY_THROW,\n/* 0x0DE */ ITEM_ID_FAIRY_BAKUDAN,\n/* 0x0DF */ ITEM_ID_FAIRY_SLIT,\n/* 0x0E0 */ ITEM_ID_FAIRY_HIPATTACK,\n/* 0x0E1 */ ITEM_ID_FAIRY_MOVE,\n/* 0x0E2 */ ITEM_ID_FAIRY_KUUKAN,\n/* 0x0E3 */ ITEM_ID_FAIRY_HAMMER,\n/* 0x0E4 */ ITEM_ID_FAIRY_MINI_MINI,\n/* 0x0E5 */ ITEM_ID_FAIRY_PIKKYORO_A,\n/* 0x0E6 */ ITEM_ID_FAIRY_COUNTER,\n/* 0x0E7 */ ITEM_ID_FAIRY_SPIN_DASH,\n\n    // Special\n/* 0x0E8 */ ITEM_ID_SPECIAL_ICON,\n/* 0x0E9 */ ITEM_ID_SPECIAL_CARD_FUKURO,\n\n    // Map\n/* 0x0EA */ ITEM_ID_MAP_NO01,\n/* 0x0EB */ ITEM_ID_MAP_NO02,\n/* 0x0EC */ ITEM_ID_MAP_NO03,\n/* 0x0ED */ ITEM_ID_MAP_NO04,\n/* 0x0EE */ ITEM_ID_MAP_NO05,\n/* 0x0EF */ ITEM_ID_MAP_NO06,\n/* 0x0F0 */ ITEM_ID_MAP_NO07,\n/* 0x0F1 */ ITEM_ID_MAP_NO08,\n/* 0x0F2 */ ITEM_ID_MAP_NO09,\n/* 0x0F3 */ ITEM_ID_MAP_NO10,\n/* 0x0F4 */ ITEM_ID_MAP_NO11,\n/* 0x0F5 */ ITEM_ID_MAP_NO12,\n/* 0x0F6 */ ITEM_ID_MAP_NO13,\n/* 0x0F7 */ ITEM_ID_MAP_NO14,\n/* 0x0F8 */ ITEM_ID_MAP_NO15,\n/* 0x0F9 */ ITEM_ID_MAP_NO16,\n/* 0x0FA */ ITEM_ID_MAP_NO17,\n/* 0x0FB */ ITEM_ID_MAP_NO18,\n/* 0x0FC */ ITEM_ID_MAP_NO19,\n/* 0x0FD */ ITEM_ID_MAP_NO20,\n/* 0x0FE */ ITEM_ID_MAP_NO21,\n/* 0x0FF */ ITEM_ID_MAP_NO22,\n/* 0x100 */ ITEM_ID_MAP_NO23,\n/* 0x101 */ ITEM_ID_MAP_NO24,\n/* 0x102 */ ITEM_ID_MAP_NO25,\n/* 0x103 */ ITEM_ID_MAP_NO26,\n/* 0x104 */ ITEM_ID_MAP_NO27,\n/* 0x105 */ ITEM_ID_MAP_NO28,\n/* 0x106 */ ITEM_ID_MAP_NO29,\n/* 0x107 */ ITEM_ID_MAP_NO30,\n/* 0x108 */ ITEM_ID_MAP_NO31,\n/* 0x109 */ ITEM_ID_MAP_NO32,\n/* 0x10A */ ITEM_ID_MAP_NO33,\n/* 0x10B */ ITEM_ID_MAP_NO34,\n/* 0x10C */ ITEM_ID_MAP_NO35,\n/* 0x10D */ ITEM_ID_MAP_NO36,\n/* 0x10E */ ITEM_ID_MAP_NO37,\n/* 0x10F */ ITEM_ID_MAP_NO38,\n/* 0x110 */ ITEM_ID_MAP_NO39,\n/* 0x111 */ ITEM_ID_MAP_NO40,\n/* 0x112 */ ITEM_ID_MAP_NO41,\n/* 0x113 */ ITEM_ID_MAP_NO42,\n/* 0x114 */ ITEM_ID_MAP_NO43,\n/* 0x115 */ ITEM_ID_MAP_NO44,\n/* 0x116 */ ITEM_ID_MAP_NO45,\n/* 0x117 */ ITEM_ID_MAP_NO46,\n/* 0x118 */ ITEM_ID_MAP_NO47,\n/* 0x119 */ ITEM_ID_MAP_NO48,\n\n    // Card\n/* 0x11A */ ITEM_ID_CARD_KURIBOO,\n/* 0x11B */ ITEM_ID_CARD_TOGEKURI,\n/* 0x11C */ ITEM_ID_CARD_TOGEKURI_BLK,\n/* 0x11D */ ITEM_ID_CARD_PATAKURI,\n/* 0x11E */ ITEM_ID_CARD_MD_PATAKURI_BLK,\n/* 0x11F */ ITEM_ID_CARD_YAMI_KURIBOO,\n/* 0x120 */ ITEM_ID_CARD_ZUTSUKI_KURIBOO,\n/* 0x121 */ ITEM_ID_CARD_ZUTSUKI_KURIBOO_BLK,\n/* 0x122 */ ITEM_ID_CARD_MD_KURIBOO_BLK,\n/* 0x123 */ ITEM_ID_CARD_NOKONOKO,\n/* 0x124 */ ITEM_ID_CARD_TOGENOKO,\n/* 0x125 */ ITEM_ID_CARD_MD_TOGENOKO_BLK,\n/* 0x126 */ ITEM_ID_CARD_MD_NOKONOKO_BLK,\n/* 0x127 */ ITEM_ID_CARD_BOSS_NOKONOKO,\n/* 0x128 */ ITEM_ID_CARD_PATAPATA,\n/* 0x129 */ ITEM_ID_CARD_MD_PATAPATA_BLK,\n/* 0x12A */ ITEM_ID_CARD_MET,\n/* 0x12B */ ITEM_ID_CARD_TOGE_MET,\n/* 0x12C */ ITEM_ID_CARD_TOGE_MET_BLK,\n/* 0x12D */ ITEM_ID_CARD_PATA_MET,\n/* 0x12E */ ITEM_ID_CARD_PATATOGE_MET,\n/* 0x12F */ ITEM_ID_CARD_STONE_MET,\n/* 0x130 */ ITEM_ID_CARD_STONE_MET_BLK,\n/* 0x131 */ ITEM_ID_CARD_TOGEZO,\n/* 0x132 */ ITEM_ID_CARD_MD_TOGEZO_BLK,\n/* 0x133 */ ITEM_ID_CARD_JUGEMU,\n/* 0x134 */ ITEM_ID_CARD_HONENOKO,\n/* 0x135 */ ITEM_ID_CARD_HONENOKO_BLK,\n/* 0x136 */ ITEM_ID_CARD_KARON,\n/* 0x137 */ ITEM_ID_CARD_HAMMER_BROS,\n/* 0x138 */ ITEM_ID_CARD_BOOM_BROS,\n/* 0x139 */ ITEM_ID_CARD_FIRE_BROS,\n/* 0x13A */ ITEM_ID_CARD_MD_HAMMER_BROS_BLK,\n/* 0x13B */ ITEM_ID_CARD_MD_BOOM_BROS_BLK,\n/* 0x13C */ ITEM_ID_CARD_MD_FIRE_BROS_BLK,\n/* 0x13D */ ITEM_ID_CARD_KAMEC_B,\n/* 0x13E */ ITEM_ID_CARD_KAMEC_R_BLK,\n/* 0x13F */ ITEM_ID_CARD_KOURA_SHOOTER,\n/* 0x140 */ ITEM_ID_CARD_KOURA_SHOOTER_M,\n/* 0x141 */ ITEM_ID_CARD_KOURA_SHOOTER_H,\n/* 0x142 */ ITEM_ID_CARD_KOURA_SHOOTER_H_BLK,\n/* 0x143 */ ITEM_ID_CARD_GABON,\n/* 0x144 */ ITEM_ID_CARD_GABON_BLK,\n/* 0x145 */ ITEM_ID_CARD_PAKKUN_FLOWER,\n/* 0x146 */ ITEM_ID_CARD_POISON_PAKKUN,\n/* 0x147 */ ITEM_ID_CARD_ICE_PAKKUN,\n/* 0x148 */ ITEM_ID_CARD_PANSY,\n/* 0x149 */ ITEM_ID_CARD_KIRA_PANSY,\n/* 0x14A */ ITEM_ID_CARD_KIRA_PANSY_BLK,\n/* 0x14B */ ITEM_ID_CARD_CHOROBON,\n/* 0x14C */ ITEM_ID_CARD_FLOWER_CHOROBON,\n/* 0x14D */ ITEM_ID_CARD_FLOWER_CHOROBON_BLK,\n/* 0x14E */ ITEM_ID_CARD_SAMBO,\n/* 0x14F */ ITEM_ID_CARD_DOKU_SAMBO,\n/* 0x150 */ ITEM_ID_CARD_DOKU_SAMBO_BLK,\n/* 0x151 */ ITEM_ID_CARD_BASABASA,\n/* 0x152 */ ITEM_ID_CARD_PUKUPUKU,\n/* 0x153 */ ITEM_ID_CARD_GESSO,\n/* 0x154 */ ITEM_ID_CARD_FUGUMODOKI,\n/* 0x155 */ ITEM_ID_CARD_KUROKUMORN,\n/* 0x156 */ ITEM_ID_CARD_KUROKUMORN_BLK,\n/* 0x157 */ ITEM_ID_CARD_HANNYA,\n/* 0x158 */ ITEM_ID_CARD_HENNYA_BLK,\n/* 0x159 */ ITEM_ID_CARD_NOROINOROI,\n/* 0x15A */ ITEM_ID_CARD_NOROINOROI_M,\n/* 0x15B */ ITEM_ID_CARD_NOROINOROI_P,\n/* 0x15C */ ITEM_ID_CARD_NOROINOROI_R,\n/* 0x15D */ ITEM_ID_CARD_NOROINOROI_Y,\n/* 0x15E */ ITEM_ID_CARD_NOROINOROI_BLK,\n/* 0x15F */ ITEM_ID_CARD_NOROINOROI_P_BLK,\n/* 0x160 */ ITEM_ID_CARD_NOROINOROI_R_BLK,\n/* 0x161 */ ITEM_ID_CARD_NOROINOROI_Y_BLK,\n/* 0x162 */ ITEM_ID_CARD_TERESA,\n/* 0x163 */ ITEM_ID_CARD_DARK_TERESA,\n/* 0x164 */ ITEM_ID_CARD_DARK_TERESA_BLK,\n/* 0x165 */ ITEM_ID_CARD_BUBBLE,\n/* 0x166 */ ITEM_ID_CARD_WANWAN,\n/* 0x167 */ ITEM_ID_CARD_WANWAN_BLK,\n/* 0x168 */ ITEM_ID_CARD_RED_WANWAN,\n/* 0x169 */ ITEM_ID_CARD_WANGWANG_X3,\n/* 0x16A */ ITEM_ID_CARD_SHINNOSUKE,\n/* 0x16B */ ITEM_ID_CARD_SHINEMON,\n/* 0x16C */ ITEM_ID_CARD_SHINEMON_BLK,\n/* 0x16D */ ITEM_ID_CARD_DODON,\n/* 0x16E */ ITEM_ID_CARD_DODON_H,\n/* 0x16F */ ITEM_ID_CARD_DODON_H_BLK,\n/* 0x170 */ ITEM_ID_CARD_DOSSUN,\n/* 0x171 */ ITEM_ID_CARD_GORON,\n/* 0x172 */ ITEM_ID_CARD_KORON,\n/* 0x173 */ ITEM_ID_CARD_KILLER,\n/* 0x174 */ ITEM_ID_CARD_KILLER_CANON,\n/* 0x175 */ ITEM_ID_CARD_OCTARO_R,\n/* 0x176 */ ITEM_ID_CARD_OCTARO,\n/* 0x177 */ ITEM_ID_CARD_OCTARO_G,\n/* 0x178 */ ITEM_ID_CARD_OCTARO_G_BLK,\n/* 0x179 */ ITEM_ID_CARD_OCTARO_W,\n/* 0x17A */ ITEM_ID_CARD_TECKTIE,\n/* 0x17B */ ITEM_ID_CARD_TECKTIE_M,\n/* 0x17C */ ITEM_ID_CARD_TECKTIE_H,\n/* 0x17D */ ITEM_ID_CARD_TECKTIE_H_BLK,\n/* 0x17E */ ITEM_ID_CARD_BOROVOY,\n/* 0x17F */ ITEM_ID_CARD_BOROVOY_M,\n/* 0x180 */ ITEM_ID_CARD_BOROVOY_H_BLK,\n/* 0x181 */ ITEM_ID_CARD_BOROVOY_W,\n/* 0x182 */ ITEM_ID_CARD_JYAMAZO,\n/* 0x183 */ ITEM_ID_CARD_JYAMAZO_H,\n/* 0x184 */ ITEM_ID_CARD_JYAMAZO_H_BLK,\n/* 0x185 */ ITEM_ID_CARD_JYAMAZO_W,\n/* 0x186 */ ITEM_ID_CARD_BANKEN,\n/* 0x187 */ ITEM_ID_CARD_DEKA_BANKEN,\n/* 0x188 */ ITEM_ID_CARD_BIG_EYE,\n/* 0x189 */ ITEM_ID_CARD_BIG_EYE_H,\n/* 0x18A */ ITEM_ID_CARD_GUY,\n/* 0x18B */ ITEM_ID_CARD_GUY_M,\n/* 0x18C */ ITEM_ID_CARD_GUY_H,\n/* 0x18D */ ITEM_ID_CARD_GUY_H_BLK,\n/* 0x18E */ ITEM_ID_CARD_NANOTILE_G,\n/* 0x18F */ ITEM_ID_CARD_NANOTILE_B,\n/* 0x190 */ ITEM_ID_CARD_NANOTILE_R,\n/* 0x191 */ ITEM_ID_CARD_NANOTILE_Y,\n/* 0x192 */ ITEM_ID_CARD_NANOTILE_Y_BLK,\n/* 0x193 */ ITEM_ID_CARD_KAMEREBOMB,\n/* 0x194 */ ITEM_ID_CARD_PATONYAN,\n/* 0x195 */ ITEM_ID_CARD_FLYNYAN,\n/* 0x196 */ ITEM_ID_CARD_DOMNYAN,\n/* 0x197 */ ITEM_ID_CARD_DEKUNYAN,\n/* 0x198 */ ITEM_ID_CARD_UCHU_KURAGE,\n/* 0x199 */ ITEM_ID_CARD_PHOTON,\n/* 0x19A */ ITEM_ID_CARD_WARPWARP,\n/* 0x19B */ ITEM_ID_CARD_FRAGON,\n/* 0x19C */ ITEM_ID_CARD_FRAGON_G,\n/* 0x19D */ ITEM_ID_CARD_FRAGON_G_BLK,\n/* 0x19E */ ITEM_ID_CARD_KAKKUN,\n/* 0x19F */ ITEM_ID_CARD_KAKKUN_H,\n/* 0x1A0 */ ITEM_ID_CARD_KAKKUN_H_BLK,\n/* 0x1A1 */ ITEM_ID_CARD_BARRIER_MAN,\n/* 0x1A2 */ ITEM_ID_CARD_BARRIER_MAN_H,\n/* 0x1A3 */ ITEM_ID_CARD_BARRIER_MAN_H_BLK,\n/* 0x1A4 */ ITEM_ID_CARD_MATRYOSHKA,\n/* 0x1A5 */ ITEM_ID_CARD_MATRYOSHKA_H,\n/* 0x1A6 */ ITEM_ID_CARD_MATRYOSHKA_H_BLK,\n/* 0x1A7 */ ITEM_ID_CARD_LEEPAT,\n/* 0x1A8 */ ITEM_ID_CARD_LEEPAT_H,\n/* 0x1A9 */ ITEM_ID_CARD_LEEPAT_H_BLK,\n/* 0x1AA */ ITEM_ID_CARD_MONMOUTH,\n/* 0x1AB */ ITEM_ID_CARD_MONMOUTH_H_BLK,\n/* 0x1AC */ ITEM_ID_CARD_MONMOUTH_W,\n/* 0x1AD */ ITEM_ID_CARD_HANAZOKU,\n/* 0x1AE */ ITEM_ID_CARD_PRIMITIVE_MAN,\n/* 0x1AF */ ITEM_ID_CARD_NINJYA,\n/* 0x1B0 */ ITEM_ID_CARD_NINJYA_M,\n/* 0x1B1 */ ITEM_ID_CARD_NINJYA_H,\n/* 0x1B2 */ ITEM_ID_CARD_NINJYA_H_BLK,\n/* 0x1B3 */ ITEM_ID_CARD_HAND_1,\n/* 0x1B4 */ ITEM_ID_CARD_SHINIGAMIN_ALPHA,\n/* 0x1B5 */ ITEM_ID_CARD_SHINIGAMIN_BETA,\n/* 0x1B6 */ ITEM_ID_CARD_MD_SHINIGAMIN_ALPHA_BLK,\n/* 0x1B7 */ ITEM_ID_CARD_MD_SHINIGAMIN_BETA_BLK,\n/* 0x1B8 */ ITEM_ID_CARD_SHINIGAMIN_SKY,\n/* 0x1B9 */ ITEM_ID_CARD_SHINIGAMIN_TAKO_A,\n/* 0x1BA */ ITEM_ID_CARD_SHINIGAMIN_TAKO_B,\n/* 0x1BB */ ITEM_ID_CARD_DEATHDEATH,\n/* 0x1BC */ ITEM_ID_CARD_DEATHDEATH_2,\n/* 0x1BD */ ITEM_ID_CARD_DEATHDEATH_2_BLK,\n/* 0x1BE */ ITEM_ID_CARD_MAGE_RED,\n/* 0x1BF */ ITEM_ID_CARD_MAGE_BLUE,\n/* 0x1C0 */ ITEM_ID_CARD_MAGE_YELLOW,\n/* 0x1C1 */ ITEM_ID_CARD_MAGE_YELLOW_BLK,\n/* 0x1C2 */ ITEM_ID_CARD_SAMURAI,\n/* 0x1C3 */ ITEM_ID_CARD_KILLER_KINOKO,\n/* 0x1C4 */ ITEM_ID_CARD_KILLER_KINOKO_H,\n/* 0x1C5 */ ITEM_ID_CARD_DODONTUS,\n/* 0x1C6 */ ITEM_ID_CARD_DIMEEN,\n/* 0x1C7 */ ITEM_ID_CARD_MANERA,\n/* 0x1C8 */ ITEM_ID_CARD_BOSS_ZUNBABA,\n/* 0x1C9 */ ITEM_ID_CARD_BOSS_ZUNBABA_WHITE,\n/* 0x1CA */ ITEM_ID_CARD_KOOPA,\n/* 0x1CB */ ITEM_ID_CARD_BLACK_KOOPA,\n/* 0x1CC */ ITEM_ID_CARD_BLACK_LUIGI,\n/* 0x1CD */ ITEM_ID_CARD_BLACK_MARIO,\n/* 0x1CE */ ITEM_ID_CARD_BLACK_PEACH,\n/* 0x1CF */ ITEM_ID_CARD_GESO,\n/* 0x1D0 */ ITEM_ID_CARD_KAMEREKING,\n/* 0x1D1 */ ITEM_ID_CARD_ROSE,\n/* 0x1D2 */ ITEM_ID_CARD_LUIGI_L,\n/* 0x1D3 */ ITEM_ID_CARD_LUIGI_ROBO,\n/* 0x1D4 */ ITEM_ID_CARD_LUIGI_ROBO_II,\n/* 0x1D5 */ ITEM_ID_CARD_SHINIGAMI,\n/* 0x1D6 */ ITEM_ID_CARD_EARL_DIMENSION,\n/* 0x1D7 */ ITEM_ID_CARD_EARL_ADJUTANT,\n/* 0x1D8 */ ITEM_ID_CARD_DIMEEN_L,\n/* 0x1D9 */ ITEM_ID_CARD_W_KOOPA,\n/* 0x1DA */ ITEM_ID_CARD_W_PEACH,\n/* 0x1DB */ ITEM_ID_CARD_P_PEACH,\n/* 0x1DC */ ITEM_ID_CARD_ANNNA,\n/* 0x1DD */ ITEM_ID_CARD_FAIRY_CATCH,\n/* 0x1DE */ ITEM_ID_CARD_FAIRY_BOMB,\n/* 0x1DF */ ITEM_ID_CARD_FAIRY_SLIT,\n/* 0x1E0 */ ITEM_ID_CARD_FAIRY__HIPATTACK,\n/* 0x1E1 */ ITEM_ID_CARD_FAIRY_RIDE,\n/* 0x1E2 */ ITEM_ID_CARD_FAIRY_REVERSE,\n/* 0x1E3 */ ITEM_ID_CARD_FAIRY_HAMMER,\n/* 0x1E4 */ ITEM_ID_CARD_FAIRY_MINI,\n/* 0x1E5 */ ITEM_ID_CARD_FAIRY_SOUND,\n/* 0x1E6 */ ITEM_ID_CARD_FAIRY_COUNTER,\n/* 0x1E7 */ ITEM_ID_CARD_FAIRY_DASH,\n/* 0x1E8 */ ITEM_ID_CARD_SMRPG64_KURIO,\n/* 0x1E9 */ ITEM_ID_CARD_SMRPG64_KAMEKI,\n/* 0x1EA */ ITEM_ID_CARD_SMRPG64_PINKY,\n/* 0x1EB */ ITEM_ID_CARD_SMRPG64_PALETTA,\n/* 0x1EC */ ITEM_ID_CARD_SMRPG64_LESALESA,\n/* 0x1ED */ ITEM_ID_CARD_SMRPG64_AKARIN,\n/* 0x1EE */ ITEM_ID_CARD_SMRPG64_OPUKU,\n/* 0x1EF */ ITEM_ID_CARD_SMRPG64_POKOPI,\n/* 0x1F0 */ ITEM_ID_CARD_MARIOST_KURI,\n/* 0x1F1 */ ITEM_ID_CARD_MARIOST_NOKO,\n/* 0x1F2 */ ITEM_ID_CARD_MARIOST_CLOUD,\n/* 0x1F3 */ ITEM_ID_CARD_MARIOST_YOSHI,\n/* 0x1F4 */ ITEM_ID_CARD_MARIOST_VIVI,\n/* 0x1F5 */ ITEM_ID_CARD_MARIOST_BARERU,\n/* 0x1F6 */ ITEM_ID_CARD_MARIOST_CHUCHU,\n/* 0x1F7 */ ITEM_ID_CARD_MEIDO_NYAN,\n/* 0x1F8 */ ITEM_ID_CARD_GUARD_NYAN,\n/* 0x1F9 */ ITEM_ID_CARD_DEARU,\n/* 0x1FA */ ITEM_ID_CARD_URA_DEARU,\n/* 0x1FB */ ITEM_ID_CARD_MISUTERU,\n/* 0x1FC */ ITEM_ID_CARD_SANDERU,\n/* 0x1FD */ ITEM_ID_CARD_CRYSTALE,\n/* 0x1FE */ ITEM_ID_CARD_AGERU,\n/* 0x1FF */ ITEM_ID_CARD_MIHARU,\n/* 0x200 */ ITEM_ID_CARD_KOBURON,\n/* 0x201 */ ITEM_ID_CARD_TAMARA,\n/* 0x202 */ ITEM_ID_CARD_DAVID,\n/* 0x203 */ ITEM_ID_CARD_HENRY_STANLAY,\n/* 0x204 */ ITEM_ID_CARD_TONO,\n/* 0x205 */ ITEM_ID_CARD_ANGEL,\n/* 0x206 */ ITEM_ID_CARD_ENNMA,\n/* 0x207 */ ITEM_ID_CARD_KAMISAMA,\n/* 0x208 */ ITEM_ID_CARD_CUBY,\n/* 0x209 */ ITEM_ID_CARD_LUIGI,\n/* 0x20A */ ITEM_ID_CARD_MARIO,\n/* 0x20B */ ITEM_ID_CARD_PEACH,\n/* 0x20C */ ITEM_ID_CARD_RED_GURIN,\n/* 0x20D */ ITEM_ID_CARD_ATOMIC_TERESA,\n/* 0x20E */ ITEM_ID_CARD_MAME_BUBUDO,\n/* 0x20F */ ITEM_ID_CARD_DAI_BUBUDO,\n/* 0x210 */ ITEM_ID_CARD_CHERIRING,\n/* 0x211 */ ITEM_ID_CARD_ICE_CHERIRING,\n/* 0x212 */ ITEM_ID_CARD_POISON_CHERIRING,\n/* 0x213 */ ITEM_ID_CARD_KYORORU,\n/* 0x214 */ ITEM_ID_CARD_ALPHA_KYORORU,\n/* 0x215 */ ITEM_ID_CARD_HORUHOLE,\n/* 0x216 */ ITEM_ID_CARD_CUBELIC,\n/* 0x217 */ ITEM_ID_CARD_KAGE_CHERIRING,\n/* 0x218 */ ITEM_ID_CARD_JYASUMING_2SEI,\n/* 0x219 */ ITEM_ID_CARD_KINOPIO\n};\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::item_data)\n\ntypedef struct\n{\n/* 0x00 */ const char * itemName;\n/* 0x04 */ s16 iconId;\n/* 0x06 */ // padding 0x6-7\n/* 0x08 */ const char * animPoseName; // Used for pixls and cards\n/* 0x0C */ const char * animName; // Used for pixls and cards\n/* 0x10 */ const char * nameMsg;\n/* 0x14 */ const char * descMsg;\n/* 0x18 */ u16 buyPrice;\n/* 0x1A */ u16 sellPrice;\n/* 0x1C */ s16 hpGain;\n/* 0x1E */ s16 xpGain;\n/* 0x20 */ u8 cardBagChance; // weight for showing up in a card bag, if available\n/* 0x21 */ u8 cardShopChance; // weight for showing up in Flopside's card shop, if available\n    /*\n        GSW(0)  -> seq indicator\n        000-010 -> 0\n        011-017 -> 11\n        018-028 -> 12\n        029-037 -> 13\n        038-065 -> 14\n        066-076 -> 21\n        077-082 -> 22\n        083-088 -> 23\n        089-100 -> 24\n        101-105 -> 31\n        106-111 -> 32\n        112-117 -> 33\n        118-128 -> 34\n        129-138 -> 41\n        139-160 -> 42\n        161-178 -> 44\n        179-186 -> 51\n        187-194 -> 52\n        195-202 -> 53\n        203-224 -> 54\n        225-271 -> 61\n        272-289 -> 62\n        290-290 -> 63\n        291-291 -> 64\n        292-306 -> 71\n        307-327 -> 72\n        328-358 -> 74\n        359-370 -> 81\n        371-386 -> 82\n        387-404 -> 83\n        405-420 -> 84\n        421+    -> 90\n        \n        If GSW(0) is high enough to give an indicator above or equal to this,\n        the weights for card bags and the card shop are multiplied by 10\n    */\n/* 0x22 */ u16 cardShopBonusSeq;\n    /*\n        If GSW(0) is below this, the card won't show\n        up in either card bags or the card shop\n    */\n/* 0x24 */ u16 cardShopMinGsw0;\n    /*\n        If this is true, the card can never show up in card bags or the card\n        shop once it's set as known in MarioPouchWork. The exception to this is\n        that selling one allows it to show up again in the shop (but not bags)\n    */\n/* 0x26 */ bool cardShopBlockDuplicate;\n    /*\n        For the NPCs on cards\n        0x2 is dark\n        0x1 is unknown\n        Others unused\n    */\n/* 0x27 */ u8 dispFlags;\n/* 0x28 */ s16 tribe; // For the NPCs on cards\n/* 0x2A */ s16 sortValue; // For sorting in shops, higher value -> lower on the list\n} ItemData;\nSIZE_ASSERT(ItemData, 0x2c)\n\nextern ItemData itemDataTable[ITEM_ID_MAX];\n\nCPP_WRAPPER_END()\n/*\n    item_event_data defines what happens when certain items are used\n*/\n\n\nCPP_WRAPPER(spm::item_event_data)\n\nUSING(spm::evtmgr::EvtScriptCode)\n\n#define ITEM_EVENT_DATA_COUNT 33\n\ntypedef struct\n{\n/* 0x0 */ s32 itemId;\n/* 0x4 */ EvtScriptCode * useScript;\n/* 0x8 */ const char * useMsgName;\n} ItemEventData;\nSIZE_ASSERT(ItemEventData, 0xc)\n\nextern ItemEventData itemEventDataTable[ITEM_EVENT_DATA_COUNT];\n\ntypedef struct\n{\n/* 0x0 */ void * wp;\n/* 0x4 */ u8 unknown_0x4[0x20 - 0x4];\n} ItemEventWork;\nSIZE_ASSERT(ItemEventWork, 0x20)\n\nDECOMP_STATIC(ItemEventWork item_event_data_work)\nDECOMP_STATIC(ItemEventWork * item_event_data_wp)\n\n/*\n    Returns the script for an item in the table by id, or a fallback if the item isn't in there\n*/\nEvtScriptCode * getItemUseEvt(s32 itemId);\n\n/*\n    Returns the name of the use message for an item in the table, or nulll if the item isn't in there\n*/\nconst char * getItemUseMsg(s32 itemId);\n\nUNKNOWN_FUNCTION(func_80025250);\n\n/*\n    Frees wp->wp and sets it to null\n*/\n// evt_item_event_free_work()\nEVT_DECLARE_USER_FUNC(evt_item_event_free_work, 0)\n\n/*\n    Sets wp->wp to null\n*/\nvoid itemEventDataExit();\n\nUNKNOWN_FUNCTION(func_8002574c);\nUNKNOWN_FUNCTION(func_80025ac4);\nUNKNOWN_FUNCTION(func_80025b20);\nUNKNOWN_FUNCTION(func_80025b70);\nUNKNOWN_FUNCTION(evt_item_event_apply_statuses);\nUNKNOWN_FUNCTION(func_80025c50);\nUNKNOWN_FUNCTION(func_80025c84);\nUNKNOWN_FUNCTION(func_80025d9c);\nUNKNOWN_FUNCTION(func_80025e80);\nUNKNOWN_FUNCTION(func_80026364);\nUNKNOWN_FUNCTION(func_800264d4);\nUNKNOWN_FUNCTION(func_8002650c);\nUNKNOWN_FUNCTION(func_80026550);\nUNKNOWN_FUNCTION(func_80026584);\nUNKNOWN_FUNCTION(func_800265f8);\nUNKNOWN_FUNCTION(func_8002691c);\nUNKNOWN_FUNCTION(func_80026a70);\nUNKNOWN_FUNCTION(func_80026c1c);\nUNKNOWN_FUNCTION(func_80027020);\nUNKNOWN_FUNCTION(func_80027410);\nUNKNOWN_FUNCTION(func_80027484);\nUNKNOWN_FUNCTION(func_800274b4);\nUNKNOWN_FUNCTION(func_800274e4);\nUNKNOWN_FUNCTION(func_800276e8);\nUNKNOWN_FUNCTION(func_800277fc);\nUNKNOWN_FUNCTION(func_8002792c);\nUNKNOWN_FUNCTION(func_80027b74);\nUNKNOWN_FUNCTION(func_80027c14);\nUNKNOWN_FUNCTION(func_80027cd4);\nUNKNOWN_FUNCTION(func_80027d38);\nUNKNOWN_FUNCTION(func_80027db4);\nUNKNOWN_FUNCTION(func_80027ed8);\nUNKNOWN_FUNCTION(func_80027f54);\nUNKNOWN_FUNCTION(func_80028040);\nUNKNOWN_FUNCTION(func_800283bc);\nUNKNOWN_FUNCTION(func_80028418);\nUNKNOWN_FUNCTION(func_80028460);\nUNKNOWN_FUNCTION(func_800284d8);\nUNKNOWN_FUNCTION(func_80028550);\nUNKNOWN_FUNCTION(func_800285bc);\nUNKNOWN_FUNCTION(func_80028604);\nUNKNOWN_FUNCTION(func_800286a0);\nUNKNOWN_FUNCTION(func_80028724);\nUNKNOWN_FUNCTION(func_80028774);\nUNKNOWN_FUNCTION(func_80028828);\nUNKNOWN_FUNCTION(func_80028bc0);\nUNKNOWN_FUNCTION(func_80028f8c);\nUNKNOWN_FUNCTION(func_8002904c);\nUNKNOWN_FUNCTION(func_8002912c);\nUNKNOWN_FUNCTION(evt_item_event_get_item_hp_gain);\nUNKNOWN_FUNCTION(func_800291f0);\nUNKNOWN_FUNCTION(func_800292f8);\nUNKNOWN_FUNCTION(func_80029374);\nUNKNOWN_FUNCTION(func_800293a8);\n\n/*\n    Gives the map & door name that the return pipe should go to\n*/\n// evt_itemdata_get_return_pipe_info(char * &mapNameOut, char * &doorNameOut)\nEVT_DECLARE_USER_FUNC(evt_itemdata_get_return_pipe_info, 2)\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::lightdrv)\n\nvoid lightInit();\nvoid lightReInit();\nvoid lightMain();\nUNKNOWN_FUNCTION(lightEntry);\nUNKNOWN_FUNCTION(lightNameToPtr);\nDECOMP_STATIC(UNKNOWN_FUNCTION(lightdrv_sort))\nUNKNOWN_FUNCTION(lightGetNearObj);\nUNKNOWN_FUNCTION(lightGetAmbient);\nUNKNOWN_FUNCTION(lightGetCharaAmbient);\nUNKNOWN_FUNCTION(lightCheckCharaLight);\nUNKNOWN_FUNCTION(lightGetPaper);\n\nCPP_WRAPPER_END()\n/*\n    lz-compressed assets embedded in the dol\n*/\n\n\n\nCPP_WRAPPER(spm::lz_embedded)\n\n// Identical copy of wiimario_snd.dat\n// Unused in favour of the one on the disc\nextern u8 wiimario_snd_dat[];\n\n// Identical copy of ag2tg.bin\n// One on the disc is unused in favour of this\nextern u8 ag2tg[];\n\n// Cooking recipe definitions\n// parse.c xml format\nextern u8 cookingText[];\n\n// Treasure map definitions\n// parse.c xml format \nextern u8 treasureMapText[];\n\n// Pit of 100 Trials (Flipside & Flopside) floor definitions\n// parse.c xml format\nextern u8 pitText[];\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::main)\n\nint main(int argc, char ** argv);\n\nCPP_WRAPPER_END()\n/*\n    Definitions used for loading maps\n*/\n\n\nCPP_WRAPPER(spm::map_data)\n\nUSING(spm::evtmgr::EvtScriptCode)\nUSING(wii::mtx::Vec3)\n\n#define MAP_ID_MAX 0x1d4\n\ntypedef struct\n{\n/* 0x00 */ const char * name;\n/* 0x04 */ const char * filename;\n/* 0x08 */ const char * fallbackDoorName; // door name used if entered with a null name,\n                                          // ignored if this is null\n/* 0x0C */ Vec3 fallbackSpawnPos; // position to use when entered with a null door name\n                                  // and fallbackDoorName isn't set\n/* 0x18 */ EvtScriptCode * initScript; // In rel, linked by prolog function\n} MapData;\nSIZE_ASSERT(MapData, 0x1c)\n\nextern MapData * mapData[MAP_ID_MAX];\n\n/*\n    Returns the MapData for a map by name\n*/\nMapData * mapDataPtr(const char * mapName);\n\n/*\n    Returns the init script for a map by anme\n*/\nEvtScriptCode * mapDataEvtPtr(const char * mapName);\n\nCPP_WRAPPER_END()\n/*\n    mario controls the player characters of the game\n*/\n\n\n/*\n    npcdrv handles the spawning, updating and deleting of NPCs ('actors') in the game\n    NPCS include enemies, friendly characters and some projectiles, but not players or MOBJ\n*/\n\n\n\nCPP_WRAPPER(spm::npcdrv)\n\nUSING(spm::evtmgr::EvtScriptCode)\nUSING(wii::mtx::Vec3)\n\n#define NPCTRIBE_MAX 535\n#define NPCTEMPLATE_MAX 435\n\ntypedef struct\n{\n/* 0x0 */ u8 type;\n/* 0x1 */ u8 defense;\n/* 0x2 */ u16 flags;\n} NPCDefense;\nSIZE_ASSERT(NPCDefense, 0x4)\n\nstruct _NPCPart;\ntypedef void (NPCPartUpdateFunc)(struct _NPCPart * part, Unk);\n\ntypedef struct\n{\n/* 0x0 */ s32 id;\n/* 0x4 */ const char * animName;\n} NPCTribeAnimDef;\nSIZE_ASSERT(NPCTribeAnimDef, 0x8)\n\ntypedef struct\n{\n/* 0x00 */ u16 id;\n/* 0x02 */ u8 unknown_0x2[0x28 - 0x2];\n/* 0x28 */ NPCDefense * defenses;\n/* 0x2C */ Unk * unknown_0x2c;\n/* 0x30 */ NPCPartUpdateFunc * updateFunc;\n/* 0x34 */ Unk * unknown_0x34;\n/* 0x38 */ NPCTribeAnimDef * animDefs;\n/* 0x3C */ u8 unknown_0x3c[0x48 - 0x3c];\n} NPCPartDef;\nSIZE_ASSERT(NPCPartDef, 0x48)\n\ntypedef struct\n{\n/* 0x0 */ s32 itemId;\n/* 0x4 */ s32 chance;\n} NPCDropItem;\nSIZE_ASSERT(NPCDropItem, 0x8)\n\ntypedef struct\n{\n/* 0x00 */ const char * animPoseName;\n/* 0x04 */ NPCTribeAnimDef * animDefs; // list terminated by one with id -1\n/* 0x08 */ s32 catchCardItemId;\n/* 0x0C */ s16 catchCardDefense;\n/* 0x0E */ u8 unknown_0xe[0x18 - 0xe];\n/* 0x18 */ u8 maxHp;\n/* 0x19 */ u8 partsCount;\n/* 0x1A */ // padding 0x1a-1b\n/* 0x1C */ NPCPartDef * partsList; // partsCount length\n/* 0x20 */ u8 unknown_0x20[0x38 - 0x20];\n/* 0x38 */ s16 killXp;\n/* 0x40 */ u8 unknown_0x3a[0x46 - 0x3a];\n/* 0x46 */ u16 coinDropChance; // chance of dropping any coins at all, percentage\n/* 0x48 */ u16 coinDropBaseCount; // minimum amount of coins to drop, if any are dropping\n/* 0x4A */ u16 coinDropExtraChance; // chance for each extra coin to drop, percentage\n/* 0x4C */ u16 coinDropExtraMax; // maximum amount of extra coins to drop on top of base count\n/* 0x4E */ u16 dropItemChance; // chance of dropping any item, percentage\n/* 0x50 */ NPCDropItem * dropItemList; // terminated by an entry with id 0\n/* 0x54 */ u8 unknown_0x54[0x64 - 0x54];\n/* 0x64 */ u8 attackStrength; // only used for the tattle and turn-based combat, doesn't affect normal damage\n/* 0x65 */ u8 unknown_0x65[0x68 - 0x65];\n} NPCTribe;\nSIZE_ASSERT(NPCTribe, 0x68)\n\ntypedef struct\n{\n/* 0x00 */ s32 m_nPoseId;\n/* 0x04 */ char animPoseName[32];\n/* 0x24 */ u8 unknown_0x24[0x48 - 0x24];\n/* 0x48 */ NPCTribeAnimDef * tribeAnims;\n/* 0x4C */ // unknown 0x4c+\n} NPCAnim; // unknown size\nOFFSET_ASSERT(NPCAnim, tribeAnims, 0x48)\n\ntypedef struct _NPCPart\n{\n/* 0x000 */ u16 id;\n/* 0x002 */ u8 unknown_0x2[0x2c - 0x2];\n/* 0x02C */ u32 flag2c;\n/* 0x030 */ u32 flag30;\n/* 0x034 */ u8 unknown_0x34[0x378 - 0x34];\n/* 0x378 */ s32 attackPower; // initialised as 1, changed by onSpawnScript if needed\n/* 0x37C */ u8 unknown_0x37c[0x388 - 0x37c];\n/* 0x388 */ struct _NPCEntry * owner;\n/* 0x38C */ struct _NPCPart * prevPart;\n/* 0x390 */ struct _NPCPart * nextPart;\n/* 0x394 */ u8 unknown_0x394[0x398 - 0x394];\n} NPCPart;\nSIZE_ASSERT(NPCPart, 0x398)\n\ntypedef struct _NPCEntry\n{\n/* 0x000 */ s32 id;\n/* 0x004 */ s32 setupFileIndex; // 1-based index, 0 if not spawned from a setup file\n    /*\n        0x1 is active\n        Others unknown\n    */\n/* 0x008 */ u32 flag8;\n/* 0x00C */ u32 flagC;\n/* 0x010 */ u32 flag10;\n/* 0x014 */ u8 unknown_0x14[0x24 - 0x14];\n/* 0x024 */ char name[32]; // name of this instance, npc_XXXXXXXX for template-spawned ones\n                           // where XXXXXXXX is id in hex\n/* 0x044 */ NPCAnim m_Anim; // unknown size\n/* ????? */ u8 unknown_unk[0x2a0 - 0x44 - sizeof(NPCAnim)];\n/* 0x2A0 */ Vec3 position;\n/* 0x2AC */ u8 unknown_0x2ac[0x348 - 0x2ac];\n/* 0x348 */ EvtScriptCode * templateUnkScript1; // unkScript1 from spawning SetupEnemyTemplate\n                                                // (unknown for non-templated NPCs)\n/* 0x34C */ u8 unknown_0x34c[0x360 - 0x34c];\n/* 0x360 */ EvtScriptCode * templateUnkScript2; // unkScript2 from spawning SetupEnemyTemplate4\n                                                // (unknown for non-templated NPCs)\n/* 0x364 */ EvtScriptCode * templateUnkScript3; // unkScript3 from spawning SetupEnemyTemplate4\n                                                // (unknown for non-templated NPCs)\n/* 0x368 */ EvtScriptCode * templateUnkScript4; // unkScript4 from spawning SetupEnemyTemplate4\n                                                // (unknown for non-templated NPCs)\n/* 0x36C */ EvtScriptCode * templateUnkScript5; // unkScript5 from spawning SetupEnemyTemplate4\n                                                // (unknown for non-templated NPCs)\n/* 0x370 */ EvtScriptCode * templateUnkScript9; // unkScript9 from spawning SetupEnemyTemplate4\n                                                // (unknown for non-templated NPCs)\n/* 0x374 */ EvtScriptCode * templateUnkScript6; // unkScript6 from spawning SetupEnemyTemplate4\n                                                // (unknown for non-templated NPCs)\n/* 0x378 */ EvtScriptCode * templateUnkScript7; // unkScript7 from spawning SetupEnemyTemplate4\n                                                // (unknown for non-templated NPCs)\n/* 0x37C */ EvtScriptCode * templateUnkScript8; // unkScript8 from spawning SetupEnemyTemplate4\n                                                // (unknown for non-templated NPCs)\n/* 0x380 */ u8 unknown_0x380[0x390 - 0x380];\n/* 0x390 */ s32 onSpawnEvtId; // id of the EvtEntry running a templated npc's onSpawn scripts\n                              // (unknown for non-templated NPCs)\n/* 0x394 */ u8 unknown_0x394[0x39c - 0x394];\n/* 0x39C */ f32 tribeField0xE; // field 0xe of spawning NPCTribe cast to float\n/* 0x3A0 */ f32 tribeField0x10; // field 0x10 of spawning NPCTribe cast to float\n/* 0x3A4 */ f32 tribeField0x12; // field 0x12 of spawning NPCTribe cast to float\n/* 0x3A8 */ u8 unknown_0x3a8[0x3ac - 0x3a8];\n/* 0x3AC */ f32 unknown_0x3ac;\n/* 0x3B0 */ u8 unknown_0x3b0[0x46c - 0x3b0];\n    /*\n        0x80000000 is frozen\n        0x40000 is on different pane to Mario\n        0x20000 is hidden & frozen\n    */\n/* 0x46C */ u32 flag46C;\n/* 0x470 */ u8 unknown_0x470[0x478 - 0x470];\n/* 0x478 */ u32 tribeField0x54; // field 0x54 of spawning NPCTribe\n/* 0x47C */ u8 unknown_0x47c[0x49c - 0x47c];\n/* 0x49C */ s32 tribeId; // id of the NPCTribe this NPC was spawned with\n/* 0x4A0 */ s32 tribeId2; // seemingly just a copy of tribeId\n/* 0x4A4 */ u8 unknown_0x4a4[0x4ec - 0x4a4];\n/* 0x4EC */ u32 maxHp; // copied from spawning NPCTribe, 1 for NPCs not spawned by tribe\n/* 0x4F0 */ u32 hp; // copied from spawning NPCTribe, 1 for NPCs not spawned by tribe\n/* 0x4F4 */ u8 unknown_0x4f4[0x508 - 0x4f4];\n/* 0x508 */ u32 axisMovementUnit;\n/* 0x4F4 */ u8 unknown_0x50c[0x510 - 0x50c];\n/* 0x510 */ s32 unitWork[16];\n/* 0x550 */ u8 unknown_0x550[0x574 - 0x550];\n/* 0x574 */ s32 dropItemId; // id of the item this npc would drop if killed (determined on spawn)\n/* 0x578 */ u8 unknown_0x578[0x57c - 0x578];\n/* 0x57C */ u32 templateField0x5C; // field 0x5c of spawning SetupEnemyTemplate\n                                   // (unknown for non-templated NPCs)\n/* 0x580 */ u32 templateField0x60; // field 0x60 of spawning SetupEnemyTemplate\n                                   // (unknown for non-templated NPCs)\n/* 0x584 */ u32 templateField0x64; // field 0x64 of spawning SetupEnemyTemplate\n                                   // (unknown for non-templated NPCs)\n/* 0x588 */ u8 unknown_0x588[0x714 - 0x588];\n/* 0x714 */ NPCPart * parts; // made from tribe's NPCPartDef list, linked list\n/* 0x718 */ EvtScriptCode * templateField0x58; // field 0x58 from spawning SetupEnemyTemplate\n                                               // g(unknown for non-templated NPCs)\n/* 0x71C */ u8 unknown_0x71c[0x748 - 0x71c];\n} NPCEntry;\nSIZE_ASSERT(NPCEntry, 0x748)\n\ntypedef struct\n{\n    /*\n        0x1 is freeze all NPCs\n    */\n/* 0x000 */ u32 flag;\n/* 0x004 */ s32 num;\n/* 0x008 */ NPCEntry * entries;\n/* 0x00C */ u8 unknown_0xc[0x14 - 0xc];\n/* 0x014 */ s32 nextTemplateNpcId;\n/* 0x018 */ Unk * setupFile; // always updated to be v6 on load\n/* 0x01C */ u8 unknown_0x1c[0x728 - 0x1c];\n/* 0x728 */ u8 unknown_0x728[0x400];\n/* 0xB28 */ u8 unknown_0xb28[0xb48 - 0xb28];\n} NPCWork;\nSIZE_ASSERT(NPCWork, 0xb48)\n\nDECOMP_STATIC(NPCWork npcdrv_work)\nDECOMP_STATIC(NPCWork * npcdrv_wp)\n\ntypedef bool (EnemyCanSpawnFunction)();\n\ntypedef struct\n{\n/* 0x00 */ u8 unknown_0x0;\n/* 0x01 */ u8 unknown_0x1;\n/* 0x02 */ u8 unknown_0x2;\n/* 0x03 */ u8 unknown_0x3;\n/* 0x04 */ s32 instanceId; // left blank to be copied from SetupEnemy\n/* 0x08 */ u32 unknown_0x8;\n/* 0x0C */ EnemyCanSpawnFunction * canSpawnFunction;\n/* 0x10 */ u8 unknown_0x10[0x14 - 0x10];\n/* 0x14 */ s32 tribeId;\n/* 0x18 */ const char * instanceName; // overrides instanceName of NPC spawned if not null\n/* 0x1C */ const char * japaneseName; // unused debug information?\n/* 0x20 */ Vec3 pos; // left blank to be copied from SetupEnemy\n/* 0x2C */ u32 flags; // ORd with NPCEntry's flags after spawning\n/* 0x30 */ EvtScriptCode * onSpawnScript;\n/* 0x34 */ EvtScriptCode * unkScript1;\n/* 0x38 */ EvtScriptCode * unkScript2;\n/* 0x3C */ EvtScriptCode * unkScript3;\n/* 0x40 */ EvtScriptCode * unkScript4;\n/* 0x44 */ EvtScriptCode * unkScript5;\n/* 0x48 */ EvtScriptCode * unkScript6;\n/* 0x4C */ EvtScriptCode * unkScript7;\n/* 0x50 */ EvtScriptCode * unkScript8;\n/* 0x54 */ EvtScriptCode * unkScript9;\n/* 0x58 */ void * unknown_0x58;\n/* 0x5C */ u8 unknown_0x5c[0x68 - 0x5c]; // all left blank to be copied from SetupEnemy\n} NPCEnemyTemplate;\nSIZE_ASSERT(NPCEnemyTemplate, 0x68)\n\nextern NPCTribe npcTribes[535];\nextern NPCEnemyTemplate npcEnemyTemplates[NPCTEMPLATE_MAX];\n\nUNKNOWN_FUNCTION(npcSfxOn);\nUNKNOWN_FUNCTION(func_801a96a4);\nvoid npcInit();\nvoid npcReset();\nUNKNOWN_FUNCTION(npcFlag2On);\nvoid npcMain();\nUNKNOWN_FUNCTION(func_801aabe4);\nUNKNOWN_FUNCTION(func_801aaca4);\nUNKNOWN_FUNCTION(func_801aada8);\nUNKNOWN_FUNCTION(npcHitMain);\nUNKNOWN_FUNCTION(func_801ad058);\nUNKNOWN_FUNCTION(func_801adda4);\nvoid npcDispMain();\nUNKNOWN_FUNCTION(func_801aef10);\nUNKNOWN_FUNCTION(func_801aefd0);\nUNKNOWN_FUNCTION(func_801af4fc);\nUNKNOWN_FUNCTION(func_801afefc);\nUNKNOWN_FUNCTION(func_801b000c);\nUNKNOWN_FUNCTION(func_801b0154);\nUNKNOWN_FUNCTION(func_801b0264);\nUNKNOWN_FUNCTION(func_801b0480);\nUNKNOWN_FUNCTION(func_801b0d10);\nUNKNOWN_FUNCTION(func_801b0ed4);\nUNKNOWN_FUNCTION(func_801b19e4);\nUNKNOWN_FUNCTION(func_801b20dc);\nUNKNOWN_FUNCTION(func_801b2460);\nUNKNOWN_FUNCTION(func_801b24c0);\nUNKNOWN_FUNCTION(func_801b2574);\nUNKNOWN_FUNCTION(func_801b2640);\nUNKNOWN_FUNCTION(func_801b285c);\nUNKNOWN_FUNCTION(func_801b2928);\nUNKNOWN_FUNCTION(func_801b33a0);\nUNKNOWN_FUNCTION(npcDispSub);\nUNKNOWN_FUNCTION(func_801b3860);\nUNKNOWN_FUNCTION(mtx_setup);\nUNKNOWN_FUNCTION(func_801b4514);\nUNKNOWN_FUNCTION(func_801b4fcc);\nUNKNOWN_FUNCTION(npcDisp);\nUNKNOWN_FUNCTION(npcPartDisp);\nUNKNOWN_FUNCTION(npcDisp_xlu);\nUNKNOWN_FUNCTION(npcPartDisp_xlu);\nUNKNOWN_FUNCTION(func_801b5118);\nUNKNOWN_FUNCTION(func_801b5214);\nUNKNOWN_FUNCTION(npcDisp_general);\nUNKNOWN_FUNCTION(npcPartDisp_general);\nUNKNOWN_FUNCTION(npcHitboxDisp);\nUNKNOWN_FUNCTION(npcDisp_offscreen);\nUNKNOWN_FUNCTION(npcDisp_offscreen_xlu);\nNPCEntry * npcEntry(const char * instanceName, const char * animPoseName, s32 instanceId,\n                    bool param_4);\nNPCEntry * npcIdToPtr(s32 id);\nNPCEntry * npcNameToPtr(const char * instanceName);\nNPCEntry * npcNameToPtr_NoAssert(const char * instanceName);\nvoid npcDelete(char *name);\nUNKNOWN_FUNCTION(func_801b73cc);\nUNKNOWN_FUNCTION(func_801b7a20);\nUNKNOWN_FUNCTION(func_801b8064);\nUNKNOWN_FUNCTION(func_801b84d4);\nUNKNOWN_FUNCTION(func_801ba124);\nUNKNOWN_FUNCTION(func_801bb6fc);\nUNKNOWN_FUNCTION(func_801bba3c);\nUNKNOWN_FUNCTION(func_801bc5d0);\nUNKNOWN_FUNCTION(func_801bc7cc);\nUNKNOWN_FUNCTION(npcDropFromCatch);\nUNKNOWN_FUNCTION(func_801bcc00);\nUNKNOWN_FUNCTION(func_801bcc8c);\nUNKNOWN_FUNCTION(func_801bce2c);\nUNKNOWN_FUNCTION(func_801bd4ac);\nUNKNOWN_FUNCTION(func_801bd584);\nUNKNOWN_FUNCTION(func_801bd7dc);\nUNKNOWN_FUNCTION(func_801bd86c);\nUNKNOWN_FUNCTION(func_801bde20);\nUNKNOWN_FUNCTION(func_801be14c);\nNPCEntry * npcEntryFromTemplate(NPCEnemyTemplate * enemyTemplate);\nbool npcAreOnSpawnEvtsDone();\nUNKNOWN_FUNCTION(func_801be6cc);\nUNKNOWN_FUNCTION(func_801be7c8);\nUNKNOWN_FUNCTION(func_801be9c4);\nUNKNOWN_FUNCTION(func_801beed4);\nUNKNOWN_FUNCTION(func_801bf554);\nUNKNOWN_FUNCTION(func_801bf5cc);\nUNKNOWN_FUNCTION(func_801bf60c);\nUNKNOWN_FUNCTION(func_801bf6a4);\nNPCEntry * npcEntryFromSetupEnemy(s32 setupFileIndex, Vec3 * pos, s32 nTemplateNo,\n                                  Unk * miscSetupData);\ns32 npcGetNextTemplateNpcId();\nUNKNOWN_FUNCTION(func_801bfc14);\nconst char * npcSearchAnimDefs(NPCTribeAnimDef * defs, s32 id);\nUNKNOWN_FUNCTION(npcSetStayPose);\nUNKNOWN_FUNCTION(npcSetTalkPose);\nUNKNOWN_FUNCTION(npcSetAnimSub);\nUNKNOWN_FUNCTION(_npcSetAnim);\nUNKNOWN_FUNCTION(npcSetAnim);\nUNKNOWN_FUNCTION(func_801c018c);\nUNKNOWN_FUNCTION(func_801c01a8);\nUNKNOWN_FUNCTION(func_801c01c0);\nUNKNOWN_FUNCTION(func_801c01dc);\nUNKNOWN_FUNCTION(func_801c0284);\nUNKNOWN_FUNCTION(npcGetDefense);\nUNKNOWN_FUNCTION(npcGetScript);\nUNKNOWN_FUNCTION(func_801c0454);\nbool npcReadSetupFile(const char * mapName, bool reAllocate);\nvoid npcUpdateSetupFile0To1(Unk * file);\nvoid npcUpdateSetupFile1To2(Unk * file);\nvoid npcUpdateSetupFile2To3(Unk * file);\nvoid npcUpdateSetupFile3To4(Unk * file);\nvoid npcUpdateSetupFile4To5(Unk * file);\nvoid npcUpdateSetupFile5To6(Unk * file);\nvoid npcUpdateSetupFile(void * file);\nNPCEntry * npcGetEntries();\ns32 npcGetMaxEntries();\nUNKNOWN_FUNCTION(func_801c213c);\nNPCPart * npcAddPart(NPCEntry * entry, NPCPartDef * partDef);\nUNKNOWN_FUNCTION(func_801c23b0);\nUNKNOWN_FUNCTION(npcGetPartById);\nUNKNOWN_FUNCTION(func_801c2480);\nUNKNOWN_FUNCTION(func_801c24cc);\nUNKNOWN_FUNCTION(func_801c2558);\nUNKNOWN_FUNCTION(func_801c25d8);\nUNKNOWN_FUNCTION(func_801c3050);\nUNKNOWN_FUNCTION(func_801c35fc);\nUNKNOWN_FUNCTION(func_801c360c);\nvoid func_801c3694(const char *, const char *);\nUNKNOWN_FUNCTION(func_801c3720);\nvoid func_801c37e4(const char *);\nvoid func_801c3848(const char *);\nUNKNOWN_FUNCTION(func_801c38a4);\nUNKNOWN_FUNCTION(func_801c38b4);\nUNKNOWN_FUNCTION(func_801c38c4);\nUNKNOWN_FUNCTION(func_801c38d4);\nUNKNOWN_FUNCTION(func_801c3930);\nUNKNOWN_FUNCTION(func_801c3968);\nUNKNOWN_FUNCTION(func_801c3a74);\nUNKNOWN_FUNCTION(func_801c3a84);\nUNKNOWN_FUNCTION(func_801c3b6c);\nUNKNOWN_FUNCTION(func_801c3b80);\nUNKNOWN_FUNCTION(func_801c3b94);\nUNKNOWN_FUNCTION(func_801c3ba8);\nUNKNOWN_FUNCTION(func_801c3bb8);\nUNKNOWN_FUNCTION(func_801c3bc4);\nUNKNOWN_FUNCTION(func_801c3cb4);\nUNKNOWN_FUNCTION(func_801c3d94);\nUNKNOWN_FUNCTION(func_801c45a4);\nUNKNOWN_FUNCTION(func_801c498c);\nUNKNOWN_FUNCTION(func_801c4afc);\nUNKNOWN_FUNCTION(func_801c5140);\nUNKNOWN_FUNCTION(func_801c65e8);\nUNKNOWN_FUNCTION(func_801c7f68);\nUNKNOWN_FUNCTION(func_801c7fe0);\nUNKNOWN_FUNCTION(func_801c7ff0);\nUNKNOWN_FUNCTION(func_801c8000);\nUNKNOWN_FUNCTION(npcTimerDisp);\nUNKNOWN_FUNCTION(npcHandleHitXp);\nUNKNOWN_FUNCTION(npcTimerMain);\nUNKNOWN_FUNCTION(func_801c85e4);\nUNKNOWN_FUNCTION(func_801c85ec);\nUNKNOWN_FUNCTION(func_801c8760);\nUNKNOWN_FUNCTION(func_801c8b44);\nUNKNOWN_FUNCTION(func_801c8b7c);\nUNKNOWN_FUNCTION(func_801c8b98);\nUNKNOWN_FUNCTION(func_801c8d48);\nUNKNOWN_FUNCTION(func_801c8d54);\nUNKNOWN_FUNCTION(func_801c8d70);\nUNKNOWN_FUNCTION(npcCheckFlipFinished);\nUNKNOWN_FUNCTION(func_801c9874);\nUNKNOWN_FUNCTION(func_801c98f0);\nUNKNOWN_FUNCTION(npcFinishFlipInstant);\nUNKNOWN_FUNCTION(func_801c99b0);\nUNKNOWN_FUNCTION(func_801c9a24);\nNPCTribe * npcGetTribe(s32 tribeId);\nNPCWork * npcGetWorkPtr();\nUNKNOWN_FUNCTION(func_801c9ae4);\nUNKNOWN_FUNCTION(func_801ca150);\nUNKNOWN_FUNCTION(func_801ca198);\nUNKNOWN_FUNCTION(func_801ca1a4);\nUNKNOWN_FUNCTION(func_801ca238);\nUNKNOWN_FUNCTION(func_801ca2d8);\nUNKNOWN_FUNCTION(func_801ca300);\nUNKNOWN_FUNCTION(func_801ca310);\nUNKNOWN_FUNCTION(func_801ca3b8);\nUNKNOWN_FUNCTION(func_801ca3e0);\nUNKNOWN_FUNCTION(func_801ca448);\nUNKNOWN_FUNCTION(func_801ca748);\nUNKNOWN_FUNCTION(func_801ca768);\nUNKNOWN_FUNCTION(func_801caab4);\nUNKNOWN_FUNCTION(func_801cab08);\nUNKNOWN_FUNCTION(func_801cab20);\nUNKNOWN_FUNCTION(func_801cab2c);\nUNKNOWN_FUNCTION(func_801cb268);\nUNKNOWN_FUNCTION(func_801cb274);\nUNKNOWN_FUNCTION(func_801cb754);\nUNKNOWN_FUNCTION(func_801cbf84);\nUNKNOWN_FUNCTION(func_801cbf9c);\nUNKNOWN_FUNCTION(func_801cbfe8);\nUNKNOWN_FUNCTION(func_801cc0a0);\nUNKNOWN_FUNCTION(func_801cc0cc);\nUNKNOWN_FUNCTION(npcGetKillXp);\nUNKNOWN_FUNCTION(func_801cc134);\nUNKNOWN_FUNCTION(func_801cc150);\nUNKNOWN_FUNCTION(func_801cc644);\nUNKNOWN_FUNCTION(func_801cc8d0);\nUNKNOWN_FUNCTION(func_801cc9dc);\nUNKNOWN_FUNCTION(func_801ccb68);\nUNKNOWN_FUNCTION(func_801ccce0);\nUNKNOWN_FUNCTION(func_801cce10);\nUNKNOWN_FUNCTION(func_801ccf74);\nUNKNOWN_FUNCTION(func_801cd124);\nUNKNOWN_FUNCTION(func_801cd210);\nUNKNOWN_FUNCTION(func_801cd3bc);\nUNKNOWN_FUNCTION(func_801cd404);\nUNKNOWN_FUNCTION(func_801cd5e8);\nUNKNOWN_FUNCTION(func_801cd6d4);\nUNKNOWN_FUNCTION(func_801cd82c);\nUNKNOWN_FUNCTION(func_801cd834);\nUNKNOWN_FUNCTION(func_801cd95c);\nUNKNOWN_FUNCTION(func_801cdb84);\nUNKNOWN_FUNCTION(func_801ceb08);\nUNKNOWN_FUNCTION(func_801ceeac);\nUNKNOWN_FUNCTION(func_801cf0a0);\nUNKNOWN_FUNCTION(func_801cf16c);\nUNKNOWN_FUNCTION(func_801d0278);\nUNKNOWN_FUNCTION(func_801d029c);\nUNKNOWN_FUNCTION(func_801d02ac);\nUNKNOWN_FUNCTION(func_801d0610);\nUNKNOWN_FUNCTION(func_801d0624);\nUNKNOWN_FUNCTION(func_801d0640);\nUNKNOWN_FUNCTION(func_801d1058);\nUNKNOWN_FUNCTION(func_801d1064);\nUNKNOWN_FUNCTION(func_801d1074);\nUNKNOWN_FUNCTION(func_801d1084);\nUNKNOWN_FUNCTION(func_801d1094);\nUNKNOWN_FUNCTION(func_801d10a4);\nUNKNOWN_FUNCTION(func_801d10cc);\nUNKNOWN_FUNCTION(func_801d1240);\nUNKNOWN_FUNCTION(func_801d1424);\nUNKNOWN_FUNCTION(func_801d1580);\nUNKNOWN_FUNCTION(func_801d1b9c);\nUNKNOWN_FUNCTION(npcTryCatchCard);\nUNKNOWN_FUNCTION(func_801d1d7c);\nUNKNOWN_FUNCTION(func_801d2028);\nUNKNOWN_FUNCTION(func_801d2208);\nUNKNOWN_FUNCTION(func_801d2304);\nUNKNOWN_FUNCTION(npcFreezeAll);\nUNKNOWN_FUNCTION(func_801d2384);\nUNKNOWN_FUNCTION(func_801d23cc);\nUNKNOWN_FUNCTION(func_801d23d4);\nUNKNOWN_FUNCTION(func_801d2554);\nUNKNOWN_FUNCTION(func_801d25b8);\nUNKNOWN_FUNCTION(func_801d25f4);\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::mario)\n\nUSING(spm::fairy::FairyEntry)\nUSING(spm::hitdrv::HitObj)\nUSING(spm::mobjdrv::MobjEntry)\nUSING(spm::npcdrv::NPCEntry)\nUSING(wii::mtx::Vec3)\nUSING(wii::mtx::Vec3i)\n\n// Returns an override for the name\ntypedef const char * (MarioAnimChangeHandler)(const char * newAnimName);\n\nenum PlayerCharacter\n{\n/* 0x0 */ PLAYER_MARIO,\n/* 0x1 */ PLAYER_PEACH,\n/* 0x2 */ PLAYER_BOWSER,\n/* 0x3 */ PLAYER_LUIGI\n};\n\ntypedef struct\n{\n/* 0x00 */ u8 unknown_0x0[0x34 - 0x0];\n} MarioJumpFallPara;\nSIZE_ASSERT(MarioJumpFallPara, 0x34)\n\n/*\n    Called every frame, fairy is deleted when true is returned\n*/\ntypedef bool (MarioFairyFlagDeleteFunc)(void * data, bool deletionHint);\n\n/*\n    Called when deleted, unless deleted from flag delete func\n*/\ntypedef void (MarioFairyDeleteFunc)(void * data, void * param);\n\n/*\n    Called every frame, commands unknown\n*/\ntypedef void (MarioFairyMainFunc)(void * data, s32 command);\n\ntypedef struct _MarioFairy\n{\n    /*\n        0x8000 deletion hint (for flag delete func)\n        0x2 store data in main heap, not map heap\n        0x1 active\n        Others unknown\n    */\n/* 0x00 */ u16 flags;\n/* 0x02 */ u8 id;\n/* 0x03 */ u8 slotId; // index in MarioWork's array this is stored at\n/* 0x04 */ void * data;\n/* 0x08 */ MarioFairyFlagDeleteFunc * flagDeleteFunc;\n/* 0x0C */ MarioFairyDeleteFunc * deleteFunc;\n/* 0x10 */ MarioFairyMainFunc * mainFunc;\n/* 0x14 */ struct _MarioFairy * next;\n/* 0x18 */ struct _MarioFairy * prev;\n} MarioFairy;\nSIZE_ASSERT(MarioFairy, 0x1c)\n\nstruct _MarioStatus;\n\n/*\n    Returns true if deleted, false otherwise\n    Commands:\n        1 start\n        2 restart?\n*/\ntypedef bool (MarioStatusMainFunc)(struct _MarioStatus * status, Vec3 * iconPos, s32 command);\n\n/*\n    Returns true if it should be deleted, false otherwise\n    Return is ignored except in marioStatusDeleteAll\n*/ \ntypedef bool (MarioStatusDeleteFunc)(struct _MarioStatus * status, s32 level); \n\n/*\n    Called on map change\n*/\ntypedef void (MarioStatusMapChangeFunc)(struct _MarioStatus * status);\n\ntypedef struct _MarioStatus\n{\n    /*\n        0x1 active\n        Others unknown\n    */\n/* 0x00 */ u32 flags;\n/* 0x04 */ u32 type; // same values as MarioWork.statusFlags\n/* 0x08 */ f32 timer; // time remaining, counts down to 0 in increments of marioSpeedScale\n/* 0x0C */ void * userWork;\n/* 0x10 */ MarioStatusMainFunc * mainFunc;\n/* 0x14 */ MarioStatusDeleteFunc * deleteFunc;\n/* 0x18 */ MarioStatusMapChangeFunc * mapChangeFunc;\n/* 0x1C */ struct _MarioStatus * prev;\n/* 0x20 */ struct _MarioStatus * next;\n} MarioStatus;\nSIZE_ASSERT(MarioStatus, 0x24)\n\nenum MarioGravityType\n{\n/* 0x0 */ MARIO_GRAVITY_DOWN,\n/* 0x1 */ MARIO_GRAVITY_UP,\n/* 0x2 */ MARIO_GRAVITY_LEFT,\n/* 0x3 */ MARIO_GRAVITY_RIGHT,\n/* 0x4 */ MARIO_GRAVITY_MAX\n};\n\n/*\n    Commands:\n        0 start\n        1 update\n        2 end\n*/\ntypedef void (MarioAcrobatCallback)(s32 command);\n\ntypedef struct\n{\n/* 0x0 */ f32 min;\n/* 0x4 */ f32 max;\n} MarioPaneBoundary;\nSIZE_ASSERT(MarioPaneBoundary, 0x8)\n\n/*\n    Returns true if the pane change is allowed\n*/\ntypedef bool (MarioPaneChangeFunc)(s32 newPane);\n\n#define MOT_STAY 0x00 // Standing still\n#define MOT_WALK 0x01 // Walking slowly\n#define MOT_DASH 0x02 // Walking at full speed\n#define MOT_JUMP 0x03 // Jumping normally\n#define MOT_CROUCH 0x04 // Crouching\n#define MOT_5 0x05\n#define MOT_SPRING 0x06 // Jumping off spring object\n#define MOT_7 0x07\n#define MOT_8 0x08\n#define MOT_BOUNCE 0x09 // Jumping off of an NPC\n#define MOT_FALL 0x0A // Falling in the air\n#define MOT_11 0x0B\n#define MOT_12 0x0C\n#define MOT_13 0x0D\n#define MOT_THUDLEY_AIR 0x0E // In the air while using thudley\n#define MOT_THUDLEY_LAND 0x0F // Landing whlie using thudley\n#define MOT_HAMMER 0x10 // Using cudge\n#define MOT_JABARA 0x11 // Luigi spring jump(?)\n#define MOT_SLIT 0x12 // Thin with slim\n#define MOT_TALK 0x13 // Talking to an NPC\n#define MOT_20 0x14\n#define MOT_21 0x15\n#define MOT_22 0x16\n#define MOT_FORCE_RESET 0x17 // ? TTYD name\n#define MOT_24 0x18\n#define MOT_BOTTOMLESS 0x19 // Respawning from falling\n#define MOT_FLIP_AIR 0x1A // Flip into midair\n#define MOT_DAMAGE 0x1B // Taking damage\n#define MOT_28 0x1C\n#define MOT_29 0x1D\n#define MOT_30 0x1E\n#define MOT_31 0x1F\n#define MOT_32 0x20\n#define MOT_33 0x21\n#define MOT_34 0x22\n#define MOT_35 0x23\n#define MOT_GRAB 0x24 // Throwing thoreau\n#define MOT_BOMB 0x25 // Placing boomer\n#define MOT_FLEEP 0x26 // Using fleep\n#define MOT_SHRINK 0x27 // Shrinking with dottie\n#define MOT_GROW 0x28 // Growing with dottie\n#define MOT_PICCOLO 0x29 // Using piccolo\n#define MOT_BARRY 0x2A // Using barry\n#define MOT_43 0x2B\n#define MOT_CARRIE_MOUNT 0x2C // Mounting carrie\n#define MOT_CARRIE_DISMOUNT 0x2D // Dismounting carrie\n#define MOT_46 0x2E\n#define MOT_47 0x2F\n#define MOT_48 0x30\n#define MOT_49 0x31\n#define MOT_50 0x32\n#define MOT_51 0x33\n#define MOT_52 0x34\n#define MOT_53 0x35\n#define MOT_54 0x36\n#define MOT_55 0x37\n#define MOT_56 0x38\n#define MOT_57 0x39\n#define MOT_58 0x3A\n#define MOT_59 0x3B\n#define MOT_60 0x3C\n#define MOT_61 0x3D\n#define MOT_62 0x3E\n#define MOT_63 0x3F\n#define MOT_64 0x40\n#define MOT_65 0x41\n#define MOT_66 0x42\n#define MOT_67 0x43\n#define MOT_68 0x44\n#define MOT_SWIM 0x45 // Off-ground underwater\n#define MOT_70 0x46\n#define MOT_CHAR_CHANGE 0x47 // Changing character\n#define MOT_FAIRY_CHANGE 0x48 // Changing pixl\n#define MOT_FLIP 0x49 // Flipping to 2d/3d\n#define MOT_GLIDE 0x4A // Peach parasol glide\n#define MOT_GUARD 0x4B // Peach parasol guard\n#define MOT_FIRE 0x4C // Bowser fire\n#define MOT_77 0x4D\n\n// Off ground, in water\n#define MARIO_MISC_FLAG_SWIM 0x20000000\n\n// Squirps enabled\n#define MARIO_MISC_FLAG_SQUIRPS 0x200000\n\n// Luvbi enabled\n#define MARIO_MISC_FLAG_LUVBI 0x80000\n\n// Near top of water?\n#define MARIO_MISC_FLAG_0x400 0x400\n\n// Can jump out of water?\n#define MARIO_MISC_FLAG_0x200 0x200\n\n// In water\n#define MARIO_MISC_FLAG_WATER 0x100\n\n// Jumping out of water\n#define MARIO_MISC_FLAG_WATER_JUMP 0x10\n\n// Paper pose on\n#define MARIO_DISP_FLAG_PAPER 0x40000000\n\n#define MARIO_DISP_FLAG_0x800000 0x800000\n\n// Lock facing direction towards facingTarget\n#define MARIO_DISP_FLAG_LOCK_FACING 0x20\n\n\ntypedef struct\n{\n    /*\n        General flags\n        0x80000000 squashed (regrowing with dottie without space)\n        0x40000000 mega star damage (double attack & breaking blocks)\n        0x10000000 block motion id change\n        0x2000000 bg mode\n        0x800000 respawn position locked\n        0x8 key off\n        0x2 ctrl off\n        Others unknown\n    */\n/* 0x0000 */ u32 flags;\n    /*\n        More general flags, see defines above\n    */\n/* 0x0004 */ u32 miscFlags;\n    /*\n        Disp flags, see defines above\n    */\n/* 0x0008 */ u32 dispFlags;\n    /*\n        Trig flags\n        0x40000000 blocks clear_hitobj_ride\n        0x1000 pose changed\n        0x1 motion id changed\n    */\n/* 0x000C */ u32 trigFlags;\n    /*\n        Status flags\n        0x8000 ghost shroom\n        0x4000 pal pills\n        0x2000 unused?\n        0x1000 coin flower\n        0x800 slow flower (including triple xp)\n        0x400 speed flower (including triple xp)\n        0x200 barrier\n        0x100 hp regen\n        0x80 electrified\n        0x40 double attack\n        0x20 halved damage\n        0x10 flipped controls\n        0x8 de-jumped\n        0x4 no skills\n        0x2 slow\n        0x1 poison\n        Others unused\n    */\n/* 0x0010 */ u32 statusFlags;\n    /*\n        Effect flags\n        0x8 slow flower trail\n        0x4 speed flower trail\n        0x2 stylish trail\n        Others unknown\n    */\n/* 0x0014 */ u8 effectFlags;\n/* 0x0015 */ u8 unknown_0x15[0x1c - 0x15];\n/* 0x001C */ const char * curPoseName; // current animation name\n/* 0x0020 */ const char * paperPoseName;\n/* 0x0024 */ s16 poseTime; // time in current animation\n/* 0x0026 */ u8 unknown_0x26[0x28 - 0x26];\n/* 0x0028 */ MarioAnimChangeHandler * animChangeHandler;\n/* 0x002C */ u16 motionId; // see enum above\n/* 0x002E */ u16 prevMotionId; // see enum above\n/* 0x0030 */ u8 unknown_0x30[0x34 - 0x30];\n    // freeze the player when > 0 (for cutscenes, talking, etc)\n/* 0x0034 */ u8 ctrl;\n/* 0x0035 */ u8 keyOff;\n/* 0x0036 */ u8 unknown_0x36[0x38 - 0x36];\n/* 0x0038 */ s8 character; // see enum above\n/* 0x0039 */ u8 unknown_0x39[0x3b - 0x39];\n/* 0x003B */ u8 wallTimer;\n/* 0x003C */ s32 subMotionId; // values vary by motion id\n/* 0x0040 */ u8 unknown_0x40[0x50 - 0x40];\n/* 0x0050 */ f32 airTimer; // time in air\n/* 0x0054 */ f32 jumpPeakAirTime; // value of airTimer when reaching top of jump\n/* 0x0058 */ u8 unknown_0x58[0x5c - 0x58];\n/* 0x005C */ Vec3 position;\n/* 0x0068 */ u8 unknown_0x68[0xbc - 0x68];\n/* 0x00BC */ Vec3 scale;\n/* 0x00C8 */ u8 unknown_0xc8[0x120 - 0xc8];\n/* 0x0120 */ s32 camId;\n/* 0x0124 */ u8 unknown_0x124[0x128 - 0x124];\n/* 0x0128 */ Vec3i framebufferPos;\n/* 0x0134 */ u8 unknown_0x134[0x148 - 0x134];\n/* 0x0148 */ f32 xzSpeed; // current horizontal speed\n/* 0x014C */ f32 walkSpeed; // base walk speed\n/* 0x0150 */ f32 dashSpeed; // base dash speed\n/* 0x0154 */ u8 unknown_0x154[0x160 - 0x154];\n/* 0x0160 */ f32 lastGroundSpeed; // xzSpeed when last on ground\n/* 0x0164 */ u8 unknown_0x164[0x174 - 0x164];\n/* 0x0174 */ f32 directionWorld; // degrees\n/* 0x0178 */ f32 directionView; // degrees\n/* 0x017C */ u8 unknown_0x17c[0x180 - 0x17c];\n/* 0x0180 */ f32 dispDirectionCurrent; // rotation of the player's model about y axis, degrees\n/* 0x0184 */ f32 dispDirectionTarget; // dispDirectionCurrent transitions to this target value\n/* 0x0188 */ u8 unknown_0x188[0x194 - 0x188];\n/* 0x0194 */ f32 hitboxWidth;\n/* 0x0198 */ f32 hitboxHeight;\n/* 0x019C */ f32 baseHitboxWidth;\n/* 0x01A0 */ f32 baseHitboxHeight;\n/* 0x01A4 */ u8 unknown_0x1a4[0x1bc - 0x1a4];\n    /*\n        1 is interact (in front of player)\n        2 is stand on\n        3 is jump from\n        6 is head\n        Others unknown\n    */\n/* 0x01BC */ HitObj * hitObjs1[10];\n/* 0x01E4 */ u8 unknown_0x1e4[0x1fc - 0x1e4];\n    /*\n        0 is MOBJ interact\n        Others unknown\n    */\n/* 0x01FC */ HitObj * hitObjs2[3];\n/* 0x0208 */ u8 unknown_0x208[0x24c - 0x208];\n    /*\n        0 is main model\n        1 is back model (Mario only)\n        6 is paper pose\n        8 is slim flip model\n        Others unknown\n    */\n/* 0x024C */ s32 animPoseIds[8];\n/* 0x026C */ u8 unknown_0x26c[0x30c - 0x26c];\n/* 0x030C */ u16 buttonsHeld;\n/* 0x030E */ u16 buttonsPressed;\n/* 0x0310 */ u16 buttonsHeldRepeat;\n/* 0x0312 */ u16 buttonsReleased;\n/* 0x0314 */ u8 unknown_0x314[0x316 - 0x314];\n/* 0x0316 */ u8 pseudoJoystickX;\n/* 0x0317 */ u8 pseudoJoystickY;\n/* 0x0318 */ u8 unknown_0x318[0x31c - 0x318];\n    /*\n        Frames 1/2 has been held\n        -1 if not held\n        Caps at 100\n    */\n/* 0x031E */ s16 held1Time;\n/* 0x0320 */ s16 held2Time;\n/* 0x0322 */ u8 unknown_0x322[0x348 - 0x322];\n/* 0x0348 */ s32 sfxIds[4];\n/* 0x0358 */ u8 unknown_0x358[0x3a4 - 0x358];\n    /*\n        Info on entity caught with Thoreau\n        catchType indicates the type of caught\n        0 nothing\n        1 NPC\n        2 Fairy\n        3 MOBJ\n    */\n/* 0x03A4 */ union\n             {\n                 NPCEntry * npc;\n                 FairyEntry * fairy;\n                 MobjEntry * mobj;\n             } caught;\n/* 0x03A8 */ s32 catchType;\n/* 0x03AC */ u8 unknown_0x3ac[0x3d0 - 0x3ac];\n/* 0x03D0 */ f32 xzSpeedFactor;\n/* 0x03D4 */ u8 unknown_0x3d4[0x3d8 - 0x3d4];\n/* 0x03D8 */ Vec3 respawnPosition;\n/* 0x03E4 */ u8 unknown_0x3e4[0x3ec - 0x3e4];\n/* 0x03EC */ HitObj * hitObjRideArray[24];\n/* 0x044C */ s32 numHitObjRideArray; // number of pointers in the array above\n/* 0x0450 */ u8 unknown_0x450[0x694 - 0x450];\n/* 0x0694 */ HitObj * hitObjInteractArray[50];\n/* 0x075C */ s32 numHitObjInteractArray; // number of pointers in the array above\n/* 0x0760 */ u8 unknown_0x760[0x9b8 - 0x760];\n/* 0x09B8 */ HitObj * hitObjHeadArray[20];\n/* 0x0A08 */ s32 numHitObjHeadArray; // number of pointers in the array above\n/* 0x0A0C */ u8 unknown_0xa0c[0xcd8 - 0xa0c];\n/* 0x0CD8 */ MarioJumpFallPara jumpFallPara;\n/* 0x0D0C */ u8 unknown_0xd0c[0xd58 - 0xd0c];\n/* 0x05D8 */ MarioFairy fairy[10];\n/* 0x0E70 */ MarioFairy * firstFairy;\n/* 0x0E74 */ MarioFairy * lastFairy;\n/* 0x0E78 */ u8 unknown_0xe78[0xe80 - 0xe78];\n/* 0x0E80 */ MarioStatus statusTbl[32];\n/* 0x1300 */ MarioStatus * firstStatus;\n/* 0x1304 */ MarioStatus * lastStatus;\n/* 0x1308 */ u8 unknown_0x1308[0x1360 - 0x1308];\n/* 0x1360 */ s32 gravityType; // see enum above\n    // Unit vectors for each direction under current gravity\n/* 0x1364 */ Vec3 gravUnitRight; // positive x normally\n/* 0x1370 */ Vec3 gravUnitUp; // positive y normally\n/* 0x137C */ Vec3 gravUnitForward; // positive z normally\n/* 0x1388 */ u8 unknown_0x1388[0x1480 - 0x1388];\n/* 0x1480 */ s32 nextCharacter;\n/* 0x1484 */ s32 prevPixl;\n/* 0x1488 */ s32 curPixl;\n/* 0x148C */ u8 unknown_0x148c[0x1498 - 0x148c];\n/* 0x1498 */ u16 acrobatFlags;\n/* 0x149A */ u8 unknown_0x149a[0x149c - 0x149a];\n/* 0x149C */ f32 stylishLevel;\n/* 0x14A0 */ u8 unknown_0x14a0[0x14a4 - 0x14a0];\n/* 0x14A4 */ s32 lastStylishXp;\n/* 0x14A8 */ s32 stylishSfxId;\n/* 0x14AC */ s32 stylishCombo;\n/* 0x14B0 */ u8 unknown_0x14b0[0x14b4 - 0x14b0];\n/* 0x14B4 */ f32 posLockTimer; // freezes the player in place for the stylish spin animation\n/* 0x14B8 */ u8 unknown_0x14b8[0x14c0 - 0x14b8];\n/* 0x14C0 */ u32 acrobatJoystickFlags;\n/* 0x14C4 */ u8 unknown_0x14c4[0x14dc - 0x14c4];\n/* 0x14DC */ MarioAcrobatCallback * acrobatCb;\n/* 0x14E0 */ s32 acrobatStage;\n/* 0x14E4 */ u8 unknown_0x14e4[0x1550 - 0x14e4];\n/* 0x1550 */ s32 pane; // row of the map on z-axis the player is in, -1 if no panes\n/* 0x1554 */ MarioPaneBoundary * paneBoundaries; // null if no panes\n/* 0x1558 */ MarioPaneChangeFunc * paneChangeFunc;\n/* 0x155C */ Vec3 facingTarget;\n/* 0x1568 */ u8 unknown_0x1568[0x156c - 0x1568];\n} MarioWork;\nSIZE_ASSERT(MarioWork, 0x156c)\n\nDECOMP_STATIC(MarioWork mario_work)\n\ntypedef struct\n{\n/* 0x00 */ f32 hitboxWidth;\n/* 0x04 */ f32 hitboxHeight;\n/* 0x08 */ f32 walkSpeed;\n/* 0x0C */ f32 dashSpeed;\n/* 0x10 */ u8 unknown_0x10[0x14 - 0x10];\n} CharacterProperties;\nSIZE_ASSERT(CharacterProperties, 0x14)\n\nextern CharacterProperties characterProperties[4]; // index character id\n\ntypedef void (MarioMotFunc)(MarioWork * mp);\n\ntypedef struct\n{\n/* 0x0 */ MarioMotFunc * mainFunc;\n/* 0x4 */ MarioMotFunc * deleteFunc;\n} MarioMotFuncs;\nSIZE_ASSERT(MarioMotFuncs, 0x8)\n\nextern MarioMotFuncs marioMotTbl[78]; // index motion id\n\nDECOMP_STATIC(s64 mario_mainLastRunTime) // used to adjust marioGameSpeedScale for lag\n\n/*\n    In normal gameplay, this is 1.0 for every frame\n    When lagging, this will increase so the game will try catch up\n    Fast & slow flowers also double/half this\n*/\nDECOMP_STATIC(f32 mario_gameSpeedScale)\n\nUNKNOWN_FUNCTION(func_80121e18);\n\n/*\n    Returns marioGameSpeedScale\n*/\nf32 marioGetGameSpeedScale();\n\nUNKNOWN_FUNCTION(func_80121e58);\nUNKNOWN_FUNCTION(func_80121f40);\n\n/*\n    Returns a pointer to the MarioWork instance\n*/\nMarioWork * marioGetPtr();\n\nUNKNOWN_FUNCTION(func_80121f54);\nUNKNOWN_FUNCTION(func_8012217c);\nUNKNOWN_FUNCTION(func_801222a4);\n\n/*\n    Changes the player's model\n    0 is normal\n    1 is mega\n*/\nvoid marioSetAnimGroup(s32 group);\n\nUNKNOWN_FUNCTION(func_8012244c);\n\n/*\n    Re-reads the characterProperties for the current character into marioWork\n*/\nvoid marioUpdateCharProperties();\n\n/*\n    Returns the characterProperties hitboxWidth for the current character\n*/\nf32 marioGetHitboxWidthRaw();\n\n/*\n    Returns the characterProperties hitboxHeight for the current character\n*/\nf32 marioGetHitboxHeightRaw();\n\n/*\n    Returns the characterProperties hitboxHeight for the current character, or 63 for Bowser\n*/\nf32 marioGetHitboxHeight_BowserSpecial();\n\n/*\n    Returns the characterProperties dashSpeed for the current character\n*/\nf32 marioGetDashSpeedRaw();\n\n/*\n    Updates the player on entering a new map\n    Handles statuses, animations, position and unflipping from Slim\n*/\nvoid marioOnMapChange(f32 spawnX, f32 spawnY, f32 spawnZ);\n\n/*\n    Returns whether player movement is enabled based on keyOff\n*/\nbool marioChkKey();\n\n/*\n    Returns whether player movement is enabled based on ctrl\n*/\nbool marioCtrlOnChk();\n\n/*\n    Returns whether player movement is disabled based on ctrl\n*/\nbool marioCtrlOffChk();\n\n/*\n    Returns whether player movement is disabled based on keyOff\n*/\nbool marioKeyOffChk();\n\n/*\n    Disables movement, increasing ctrl by one and returning it\n*/\ns32 marioCtrlOff();\n\n/*\n    Reduces ctrl by one and returns it, enabling movement if it's 0\n*/\ns32 marioCtrlOn();\n\n/*\n    Disables movement, increasing keyOff by one and returning it\n    XZ speed is also removed\n*/\ns32 marioKeyOff();\n\n/*\n    Reduces keyOff by one and returns it, enabling movement if it's 0\n*/\ns32 marioKeyOn();\n\n/*\n    Sets up the player to walk in the background of the level\n*/\nvoid marioBgModeOn();\n\n/*\n    Stops the player walking in the background of the level\n*/\nvoid marioBgModeOff();\n\n/*\n    Checks if any of the specified conditions in the mask are true\n    0x1: marioWork.flags & 0x10000 is on\n    0x2: marioWork.flags & 0x20000 is on\n    0x4: marioWork.flags & 0x100000 is on\n    0x8: motion id is Luigi super jump\n*/\nbool marioChkSts(u32 mask);\n\n/*\n    Removes references to a HitObj from hitObjs1 & hitObjs2\n*/\nvoid marioResetHitObj(const char * name);  \n\n/*\n    Resets marioWork for a new save file\n*/\nvoid marioReset();\n\nvoid marioOfsRotReset();\n\n/*\n    Clears sfx ids\n*/\nvoid marioSoundInit();\n\n/*\n    Asynchronously sets up front & back models for the player\n    Returns true if finished\n*/\nbool marioPoseInit();\n\n/*\n    Initialises marioWork\n*/\nvoid marioInit();\n\n\n/*\n    Re-initialises marioWork on map unload\n*/\nvoid marioReInit();\n\nUNKNOWN_FUNCTION(func_80123f0c);\n\n/*\n    Updates respawn position if in a safe location to respawn\n*/\nvoid marioUpdateRespawnPos();\n\nUNKNOWN_FUNCTION(func_80124374);\n\n/*\n    Updates the player\n*/\nvoid marioMain();\n\nUNKNOWN_FUNCTION(func_80125854);\nUNKNOWN_FUNCTION(func_80125998);\nUNKNOWN_FUNCTION(func_80126034);\nUNKNOWN_FUNCTION(func_801265a0);\nUNKNOWN_FUNCTION(func_80126618);\nUNKNOWN_FUNCTION(func_8012662c);\nUNKNOWN_FUNCTION(func_80126688);\n\n/*\n    Sets the player's current animation\n*/\nvoid marioChgPose(const char * name);\nvoid marioChgPoseTime(const char * name, s16 time);\n\nvoid marioChgPaper(const char * name);\nvoid marioChgPaper2(const char * name);\nvoid marioSetPaperAnimeLocalTime(s16 time);\nvoid marioPaperOn(const char * name);\nvoid marioPaperOff();\nvoid marioPaperLightOn();\nvoid marioPaperLightOff();\n\n/*\n    Returns whether the player's current animation has finished\n*/\nbool marioIsAnimFinished();\n\nUNKNOWN_FUNCTION(func_80126c98);\nUNKNOWN_FUNCTION(func_80126cfc);\n\n/*\n    Returns screen coordinates for a point in the 3d world\n*/\nvoid marioGetScreenPos(Vec3 * worldPos, f32 * xOut, f32 * yOut, f32 * zOut);\n\n/*\n    Returns whether the given screen coordinates are on screen\n*/\nbool marioChkInScreen(s32 x, s32 y);\n\n/*\n    Returns 0.8 for bg mode, 2.0 otherwise\n*/\nf32 marioGetScale();\n\nUNKNOWN_FUNCTION(func_80126e1c);\nUNKNOWN_FUNCTION(func_80126e6c);\n\n/*\n    Updates the direction the player is facing\n*/\nvoid marioMakeDispDir();\n\nUNKNOWN_FUNCTION(func_801275dc);\n\n/*\n    Prepares for rendering the player\n*/\nvoid marioPreDisp();\n\nUNKNOWN_FUNCTION(func_80127f5c);\nUNKNOWN_FUNCTION(func_801280f8);\n\n/*\n    Enables/disables effect flags\n*/\nvoid marioEffectFlagOn(u8 mask);\nvoid marioEffectFlagOff(u8 mask);\n\nUNKNOWN_FUNCTION(func_80128378);\nUNKNOWN_FUNCTION(func_801289bc);\nUNKNOWN_FUNCTION(func_80128d1c);\n\n/*\n    Renders the player\n*/\nvoid marioDisp();\n\nUNKNOWN_FUNCTION(func_80128f2c);\nUNKNOWN_FUNCTION(func_80128fd4);\nUNKNOWN_FUNCTION(func_801291f8);\n\n/*\n    Converts a front/rear animation name to its rear/front equivalent\n*/\nDECOMP_STATIC(const char * mario_toRearPose(const char * name))\nDECOMP_STATIC(const char * mario_toFrontPose(const char * name))\n\nUNKNOWN_FUNCTION(func_801299f8);\nUNKNOWN_FUNCTION(func_80129d8c);\nUNKNOWN_FUNCTION(func_80129db8);\nUNKNOWN_FUNCTION(func_80129ddc);\nUNKNOWN_FUNCTION(func_80129dfc);\nUNKNOWN_FUNCTION(func_8012a064);\nUNKNOWN_FUNCTION(func_8012a168);\nUNKNOWN_FUNCTION(func_8012a354);\n\n/*\n    Calculates the damage the player will do to an enemy\n*/\ns32 marioCalcDamageToEnemy(s32 damageType, s32 tribeId);\n\n/*\n    Plays a random damage sound effect at the player's position\n*/\nvoid marioPlayDamageSfx();\n\n/*\n    Handles an enemy attack\n    Flags:\n        0x4 don't display damage number\n        0x100 inflict No Jump status\n        0x200 inflict Slow status\n        0x400 inflict No Skills status\n        0x800 inflict Flipped Controls status\n        0x1000 play Nastasia attack effect\n        0x2000 freeze\n        0x4000 sleep\n        0x10000 inflict Poison status\n        0x1, 0x10, 0x8000 unknown\n*/\nvoid marioTakeDamage(Vec3 * position, u32 flags, s32 damage);\n\n/*\n    Updates the entity being held with Thoreau\n*/\nvoid marioUpdateCatch();\n\n/*\n    Calculates the position for the entity being held with Thoreau\n*/\nvoid marioCalcCatchPos(Vec3 * posOut);\n\n/*\n    Drops the entity being held with Thoreau\n*/\nvoid marioDropCatch();\n\nUNKNOWN_FUNCTION(func_8012b018);\n\n/*\n    Returns whether the player is in 3d\n*/\nbool marioCheck3d();\n\nUNKNOWN_FUNCTION(func_8012b090);\nUNKNOWN_FUNCTION(func_8012b218);\nUNKNOWN_FUNCTION(func_8012b2c4);\nUNKNOWN_FUNCTION(func_8012b370);\nUNKNOWN_FUNCTION(func_8012b39c);\nUNKNOWN_FUNCTION(func_8012b498);\nUNKNOWN_FUNCTION(func_8012b4ac);\nUNKNOWN_FUNCTION(func_8012b4f8);\n\n/*\n    Sets the player's gravity direction, see enum above\n*/\nvoid marioSetGravity(s32 dir);\n\n/*\n    Returns the player's gravity direction, see enum above\n*/\ns32 marioGetGravity();\n\n/*\n    Returns a downward unit vector for the current gravity\n*/\nvoid marioGetGravUnitDown(Vec3 * dest);\n\n/*\n    Changes the direction of a vector based on current gravity\n*/\nvoid marioApplyGravity(Vec3 * in, Vec3 * out);\n\n/*\n    Calculates the dot product of a vector with each direction's unit vector\n*/\nvoid marioGravityDotProduct(Vec3 * in, Vec3 * out);\n\nUNKNOWN_FUNCTION(func_8012b7f8);\nUNKNOWN_FUNCTION(func_8012ba68);\nUNKNOWN_FUNCTION(func_8012bb80);\n\n/*\n    Changes the active pane boundaries and updates which pane the player is in\n*/\nvoid marioSetPaneBoundaries(MarioPaneBoundary * boundaries); \n\n/*\n    Calculates the pane of a vector position\n    -1 if no panes are defined or the position doesn't fall within any pane\n*/\ns32 marioGetPaneForPos(Vec3 * pos);\n\n/*\n    Scales the player when they're unable to regrow fully when cancelling Dottie\n*/\nvoid marioHandleSquash();\n\nUNKNOWN_FUNCTION(func_8012c0f8);\nUNKNOWN_FUNCTION(func_8012c188);\nUNKNOWN_FUNCTION(func_8012c218);\nUNKNOWN_FUNCTION(func_8012c948);\nUNKNOWN_FUNCTION(func_8012ca58);\nUNKNOWN_FUNCTION(func_8012caec);\nUNKNOWN_FUNCTION(func_8012cb00);\nUNKNOWN_FUNCTION(func_8012cb6c);\nUNKNOWN_FUNCTION(func_8012cbcc);\nUNKNOWN_FUNCTION(func_8012cc38);\nUNKNOWN_FUNCTION(func_8012cc98);\nUNKNOWN_FUNCTION(func_8012cd9c);\nUNKNOWN_FUNCTION(func_8012ce4c);\nUNKNOWN_FUNCTION(func_8012cea8);\nUNKNOWN_FUNCTION(func_8012cf20);\nUNKNOWN_FUNCTION(func_8012cf44);\n\n/*\n    Forces respawn position\n*/\nvoid marioLockRespawnPos(Vec3 * pos, Unk);\n\n/*\n    Re-enables automatic respawn position calculation\n*/\nvoid marioUnlockRespawnPos();\n\n/*\n    Forces the player model to face towards a point\n*/\nvoid marioLockFacingDir(Vec3 * target);\n\n/*\n    Re-enables free facing direction for the player model\n*/\nvoid marioUnlockFacing();\n\nUNKNOWN_FUNCTION(func_8012d230);\nUNKNOWN_FUNCTION(func_8012d494);\n\n/*\n    Spawns/removes Squirps following the player\n*/\nvoid marioAddTamara();\nvoid marioRemoveTamara();\n\nUNKNOWN_FUNCTION(func_8012d8b4);\n\n/*\n    Spawns/removes Luvbi following the player\n*/\nvoid marioAddAngeko();\nvoid marioRemoveAngeko();\n\nUNKNOWN_FUNCTION(func_8012d98c);\nUNKNOWN_FUNCTION(func_8012d9fc);\nbool func_8012dab0();\n\nCPP_WRAPPER_END()\n\n\n\nCPP_WRAPPER(spm::mario_motion)\n\nUNKNOWN_FUNCTION(marioMotion);\nvoid marioChgMot(s32 nextMotionId);\nUNKNOWN_FUNCTION(marioChgMotSub);\nUNKNOWN_FUNCTION(marioChgMot2);\nUNKNOWN_FUNCTION(marioClearJumpPara);\nUNKNOWN_FUNCTION(func_801435a0);\nUNKNOWN_FUNCTION(marioSetJumpPara);\nUNKNOWN_FUNCTION(marioSetFallPara);\nUNKNOWN_FUNCTION(func_801440a0);\nUNKNOWN_FUNCTION(func_801440f4);\nUNKNOWN_FUNCTION(marioGetJumpParaDef);\nUNKNOWN_FUNCTION(func_801442b4);\nUNKNOWN_FUNCTION(func_801444d0);\nUNKNOWN_FUNCTION(func_8014465c);\nUNKNOWN_FUNCTION(func_80144908);\nUNKNOWN_FUNCTION(func_80144bbc);\nUNKNOWN_FUNCTION(func_80144cf4);\nUNKNOWN_FUNCTION(func_80144de4);\nUNKNOWN_FUNCTION(func_80144e44);\nUNKNOWN_FUNCTION(func_80144ebc);\nUNKNOWN_FUNCTION(func_80144f44);\nUNKNOWN_FUNCTION(func_8014503c);\nUNKNOWN_FUNCTION(func_801450f8);\nUNKNOWN_FUNCTION(func_80145108);\nUNKNOWN_FUNCTION(func_80145174);\nUNKNOWN_FUNCTION(marioJump);\nUNKNOWN_FUNCTION(marioFall);\nUNKNOWN_FUNCTION(marioLandCamShake);\nUNKNOWN_FUNCTION(marioLandon);\nUNKNOWN_FUNCTION(func_80146448);\nUNKNOWN_FUNCTION(func_8014651c);\nUNKNOWN_FUNCTION(func_80146570);\nUNKNOWN_FUNCTION(func_801466a8);\nUNKNOWN_FUNCTION(func_8014680c);\nUNKNOWN_FUNCTION(func_801468c8);\nUNKNOWN_FUNCTION(func_80146ae8);\nUNKNOWN_FUNCTION(func_80146cf0);\nUNKNOWN_FUNCTION(func_80146e00);\nUNKNOWN_FUNCTION(func_80146e24);\nbool func_80146f0c();\nUNKNOWN_FUNCTION(func_8014701c);\nUNKNOWN_FUNCTION(func_801470d8);\nUNKNOWN_FUNCTION(func_801471e8);\nUNKNOWN_FUNCTION(func_801472b4);\nUNKNOWN_FUNCTION(func_801472ec);\nUNKNOWN_FUNCTION(func_8014744c);\nUNKNOWN_FUNCTION(marioChangeCharacter);\nUNKNOWN_FUNCTION(_marioChangeCharacter);\nUNKNOWN_FUNCTION(func_80147748);\nUNKNOWN_FUNCTION(mot_character_change);\nUNKNOWN_FUNCTION(marioChangePixl);\nUNKNOWN_FUNCTION(func_80147f14);\nUNKNOWN_FUNCTION(mot_pixl_change);\nUNKNOWN_FUNCTION(func_801484fc);\nUNKNOWN_FUNCTION(func_801487b0);\nUNKNOWN_FUNCTION(marioChgMotCharAbility);\nUNKNOWN_FUNCTION(func_80148870);\nUNKNOWN_FUNCTION(func_80148928);\nUNKNOWN_FUNCTION(mot_dummy);\nUNKNOWN_FUNCTION(mot_22);\nUNKNOWN_FUNCTION(mot_23);\nUNKNOWN_FUNCTION(func_80148c28);\nUNKNOWN_FUNCTION(func_80149680);\nUNKNOWN_FUNCTION(func_801496cc);\nUNKNOWN_FUNCTION(mot_parasol_guard);\nUNKNOWN_FUNCTION(mot_75_post);\nUNKNOWN_FUNCTION(func_80149f90);\nUNKNOWN_FUNCTION(func_8014a0f0);\nUNKNOWN_FUNCTION(func_8014a2bc);\nUNKNOWN_FUNCTION(mot_fire);\nUNKNOWN_FUNCTION(mot_fire_post);\nUNKNOWN_FUNCTION(func_8014ab68);\nUNKNOWN_FUNCTION(func_8014abf8);\nUNKNOWN_FUNCTION(func_8014acbc);\nUNKNOWN_FUNCTION(mot_talk);\nUNKNOWN_FUNCTION(mot_29);\nUNKNOWN_FUNCTION(func_8014b518);\nUNKNOWN_FUNCTION(mot_28);\nUNKNOWN_FUNCTION(mot_28_post);\nUNKNOWN_FUNCTION(mot_31);\nUNKNOWN_FUNCTION(mot_31_post);\nUNKNOWN_FUNCTION(mot_32);\nUNKNOWN_FUNCTION(mot_32_post);\nUNKNOWN_FUNCTION(mot_33);\nUNKNOWN_FUNCTION(func_8014be7c);\nUNKNOWN_FUNCTION(mot_34);\nUNKNOWN_FUNCTION(mot_34_post);\n\nCPP_WRAPPER_END()\n/*\n    mario_pouch stores information like xp, HP, items and unlocked pixls\n    Note: unlocked characters and pixls are treat as items internally\n*/\n\n\n\nCPP_WRAPPER(spm::mario_pouch)\n\n#define POUCH_KEY_ITEM_MAX 32\n#define POUCH_USE_ITEM_MAX 10\n#define POUCH_SHOP_ITEM_MAX 32\n#define POUCH_CHAR_ITEM_MAX 4\n#define POUCH_FAIRY_ITEM_MAX 16\n\nUSING(wii::os::OSTime)\nUSING(wii::mtx::Vec3)\n\ntypedef struct\n{\n/* 0x0 */ bool selectable;\n/* 0x1 */ bool selected;\n/* 0x2 */ u16 itemType;\n} PouchCharOrPixlInfo;\nSIZE_ASSERT(PouchCharOrPixlInfo, 0x4)\n\ntypedef struct\n{\n/* 0x00 */ s32 characterId;\n/* 0x04 */ s32 score;\n/* 0x08 */ Unk32 unknown_0x8;\n/* 0x0C */ Unk32 unknown_0xc;\n/* 0x10 */ u8 unknown_0x10;\n/* 0x11 */ u8 unknown_0x11[0x18 - 0x11];\n} PouchMinigameScore;\nSIZE_ASSERT(PouchMinigameScore, 0x18)\n\ntypedef struct\n{\n/* 0x00 */ Unk32 unknown_0x0;\n/* 0x04 */ s32 unknown_0x4;\n/* 0x08 */ OSTime unknown_0x8;\n/* 0x10 */ Unk32 unknown_0x10;\n/* 0x14 */ Unk32 unknown_0x14;\n/* 0x18 */ u8 unknown_0x18;\n/* 0x19 */ u8 unknown_0x19[0x20 - 0x19];\n} PouchUnk;\nSIZE_ASSERT(PouchUnk, 0x20)\n\n/*\n    This struct is copied in full to & from the save file\n*/\ntypedef struct\n{\n/* 0x000 */ u8 unknown_0x0[0x4 - 0x0]; // unused?\n/* 0x004 */ s32 level;\n/* 0x008 */ s32 attack;\n/* 0x00C */ s32 hp;\n/* 0x010 */ s32 maxHp;\n/* 0x014 */ s32 flipTimer;\n/* 0x018 */ s32 xp;\n/* 0x01C */ s32 coins;\n/* 0x020 */ u16 keyItem[POUCH_KEY_ITEM_MAX]; // key items\n/* 0x060 */ u16 useItem[POUCH_USE_ITEM_MAX]; // usable items\n/* 0x074 */ u16 shopItem[POUCH_SHOP_ITEM_MAX]; // items stored by the player at a shop\n/* 0x0B4 */ PouchCharOrPixlInfo characters[POUCH_CHAR_ITEM_MAX];\n/* 0x0C4 */ PouchCharOrPixlInfo pixls[POUCH_FAIRY_ITEM_MAX];\n/* 0x104 */ s32 shopPoints;\n/* 0x108 */ u32 shopPointRewardsCollected; // bit mask, index 1 << i\n/* 0x10C */ u8 catchCards[256]; // value is the amount currently owned, index is item id\n                                // minus the first card item id (282)\n/* 0x20C */ u8 unknown_0x20c[0x30c - 0x20c];\n\n            // where x is the item id minus the first treasure map item id (234):\n/* 0x30C */ u32 ownedMaps[2]; // maps currently in inventory, index [x / 32] & 1 << (x % 32)\n/* 0x314 */ u32 foundMaps[2]; // maps with rewards claimed, index [x / 32] & 1 << (x % 32)\n\n            // where x is the item id minus the first cooked item id (120):\n/* 0x31C */ u32 knownRecipes[3]; // flags indicating if a recipe was ever cooked/collected,\n                                 // index [x / 32] & 1 << (x % 32)\n\n            // where x is the item id minus the first card item id (282):\n/* 0x328 */ u32 knownCards[8]; // flags indicating if a card was ever collected,\n                               // index [x / 32] & 1 << (x % 32)\n\n/* 0x348 */ s32 charmsRemaining; // Merlee charms remaining from current purchase\n/* 0x34C */ s32 killsBeforeNextCharm; // kills before the next Merlee charm triggers\n/* 0x350 */ Vec3 unknown_0x350;\n/* 0x35C */ Vec3 unknown_0x35c;\n/* 0x368 */ PouchMinigameScore minigameScores[4][5];\n/* 0x548 */ PouchUnk unknown_0x548[2][5];\n/* 0x688 */ s32 arcadeTokens;\n/* 0x68C */ s32 totalCoinsCollected; // all-time coins collected\n/* 0x690 */ s32 maxJumpCombo;\n/* 0x694 */ s32 maxStylishCombo;\n/* 0x698 */ s32 enemiesDefeated; // all-time enemies defeated\n/* 0x69C */ u8 unknown_0x69c[0x6a0 - 0x69c];\n} MarioPouchWork;\nSIZE_ASSERT(MarioPouchWork, 0x6a0)\n\ntypedef struct\n{\n/* 0x00 */ OSTime unknown_0x0;\n/* 0x08 */ OSTime unknown_0x8;\n/* 0x10 */ s32 unknown_0x10;\n/* 0x14 */ s32 unknown_0x14;\n/* 0x18 */ OSTime unknown_0x18;\n} MarioPouchWork2;\nSIZE_ASSERT(MarioPouchWork2, 0x20)\n\nDECOMP_STATIC(MarioPouchWork mario_pouch_work)\nDECOMP_STATIC(MarioPouchWork mario_pouch_work2)\n\n/*\n    Returns a pointer to the MarioPouchWork / MarioPouchWork2 instance\n*/\nMarioPouchWork * pouchGetPtr();\nMarioPouchWork2 * pouch2GetPtr(); // inlined\n\n/*\n    Initialise data used by pouch functions\n    Overwritten later once a save is loaded\n*/\nvoid pouchInit();\nvoid pouch2Init(); // inlined\nvoid pouchReInit();\n\n/*\n    Updates 3d flip timer\n*/\nvoid pouchMain();\n\nvoid pouchResetFlip();\n\n/*\n    Set/get the player's level\n*/\nvoid pouchSetLevel(s32 level);\ns32 pouchGetLevel();\n\n/*\n    Returns the xp required by the next level\n*/\ns32 pouchGetNextLevelXp();\n\n/*\n    Set/get/add to the player's attack power\n*/\nvoid pouchSetAttack(s32 attack);\ns32 pouchGetAttack();\nvoid pouchAddAttack(s32 increase);\n\n/*\n    Set/get/add to the player's HP\n*/\nvoid pouchSetHp(s32 hp);\ns32 pouchGetHp();\nvoid pouchAddHp(s32 increase);\n\n/*\n    Set/get the player's max HP\n*/\nvoid pouchSetMaxHp(s32 maxHp);\ns32 pouchGetMaxHp();\n\n/*\n    Get/add to the player's xp\n*/\nvoid pouchSetXp(s32 xp); // inlined\ns32 pouchGetXp();\nvoid pouchAddXp(s32 increase);\n\n/*\n    Set/get/add to the player's coin count\n*/\nvoid pouchSetCoin(s32 coins);\ns32 pouchGetCoin();\nvoid pouchAddTotalCoin(s32 increase); // inlined\nvoid pouchAddCoin(s32 increase); // increases totalCoinsCollected\n\n/*\n    Adds the specified item to its corresponding inventory (can't be used for shop items)\n    Returns whether it was successfully added\n*/\nbool pouchAddItem(s32 itemId);\n\n/*\n    Checks whether the specified item id is in its corresponding inventory\n    (can't be used for shop items)\n*/\nbool pouchCheckHaveItem(s16 itemId);\n\n/*\n    Removes the first item with the specified id in its corresponding inventory\n    (can't be used for shop items)\n*/\nvoid pouchRemoveItem(s16 itemId);\n\n/*\n    Removes the with the specified id at the specified index in its corresponding inventory\n    Only supports keyItem and useItem\n    Asserts that the id of the item at the index is what was passed in\n*/\nvoid pouchRemoveItemIdx(s16 itemId, s32 idx);\n\n/*\n    Adds the specified item id to the player's shop stored inventory\n    Returns whether it was successfully added\n*/\nbool pouchAddShopItem(s16 itemId);\n\n/*\n    Removes the first item with the specified id in the player's shop stored inventory\n*/\nvoid pouchRemoveShopItem(s16 itemId);\n\n/*\n    Removes the with the specified id at the specified index in the player's shop stored inventory\n    Asserts that the id of the item at the index is what was passed in\n*/\nvoid pouchRemoveShopItemIdx(s16 itemId, s32 idx);\n\n/*\n    Get the information about a character slot\n*/\nPouchCharOrPixlInfo * pouchGetCharInfo(s32 slot);\n\n/*\n    Make a character selectable/not by id, if it exists in a slot\n*/\nvoid pouchMakeCharSelectable(s16 itemId);\nvoid pouchMakeCharNotSelectable(s16 itemId);\n\n/*\n    Get the information about a pixl slot\n*/\nPouchCharOrPixlInfo * pouchGetPixlInfo(s32 slot);\n\n/*\n    Make a pixl selectable/not by id, if it exists in a slot\n*/\nvoid pouchMakePixlSelectable(s16 itemId);\nvoid pouchMakePixlNotSelectable(s16 itemId);\n\n/*\n    Check if a pixl is selected by id\n*/\nbool pouchCheckPixlSelected(s16 itemId);\n\n/*\n    Returns the id of the currently selected pixl\n*/\nu16 pouchGetCurPixl();\n\n/*\n    Makes a pixl selected by id, if it exists in a slot\n    Deselects all other pixls\n*/\nvoid pouchSetPixlSelected(s16 itemId);\n\n/*\n    Turns on the foundMaps/knownRecipes bitflag for the specified item id\n*/\nvoid pouchRegisterMapFound(s16 itemId);\nvoid pouchRegisterRecipeKnown(s16 itemId);\n\n/*\n    Returns whether the specified recipe item id has ever been cooked/collected\n*/\nbool pouchCheckRecipeKnown(s16 itemId);\n\n/*\n    Returns the amount of the specified card in the inventory\n*/\ns32 pouchGetCardCount(s16 itemId);\n\n/*\n    Returns whether the specified card item id has ever been collected\n*/\nbool pouchCheckCardKnown(s16 itemId);\n\n/*\n    Takes a jump/stylish combo length and updates maxJumpCombo/maxStylishCombo if it's higher\n*/\nvoid pouchRegisterJumpCombo(s32 length);\nvoid pouchRegisterStylishCombo(s32 length);\n\n/*\n    Updates all-time enemies defeated count\n*/\nvoid pouchSetEnemiesDefeated(s32 count);\n\n/*\n    Returns how many coins have ever been collected on this save\n*/\ns32 pouchGetTotalCoinsCollected();\n\n/*\n    Returns the longest jump/stylish combo length recorded\n*/\ns32 pouchGetMaxJumpCombo();\ns32 pouchGetMaxStylishCombo();\n\n/*\n    Returns all-time enemies defeated count\n*/\ns32 pouchGetEnemiesDefeated();\n\n/*\n    Returns/sets the number of arcade tokens in the inventory\n*/\ns32 pouchGetArcadeTokens();\nvoid pouchSetArcadeTokens(s32 count);\n\n/*\n    Returns the number of useItem/keyItem/shopItem/char/pixl slots that aren't empty\n    [and aren't selected]\n*/\ns32 pouchCountUseItems();\ns32 pouchCountKeyItems();\ns32 pouchCountShopItems();\ns32 pouchCountChars();\ns32 pouchCountPixls();\ns32 pouchCountPixlsNotSelected();\n\n/*\n    Returns whether any useItem slot is emtpy\n*/\nbool pouchCheckFreeUseItem();\n\n/*\n    Returns the number of treasure maps currently in the inventory\n*/\ns32 pouchCountMapsOwned();\n\n/*\n    Returns the number of recipes / cards ever collected\n*/\ns32 pouchCountRecipesKnown();\ns32 pouchCountCardsKnown();\n\nCPP_WRAPPER_END()\n/*\n    msgdrv handles the reading of message text files and some of the on-screen display of dialogue\n*/\n\n\n/*\n    windowdrv handles some of the game's UI\n*/\n\n\n\nCPP_WRAPPER(spm::windowdrv)\n\nUSING(spm::memory::SmartAllocation)\nUSING(wii::gx::GXColor)\nUSING(wii::mtx::Mtx34)\nUSING(wii::mtx::Vec2)\nUSING(wii::mtx::Vec3)\n\nstruct _WindowEntry;\n\ntypedef void (WindowFunc)(struct _WindowEntry * entry);\n\ntypedef struct _WindowEntry\n{\n/* 0x00 */ u8 unknown_0x0[0x2 - 0x0];\n    /*\n        1 active\n        Others unknown\n    */\n/* 0x02 */ u16 flags;\n/* 0x04 */ u16 priority;\n/* 0x06 */ u8 unknown_0x6[0x8 - 0x6];\n    /*\n        0 - normal\n        1 - small (used for crowds shouting)\n        2 - sign\n        3 - system\n        4 - sign 2\n        5 - selection\n        6 - TTYD dragon style (unused?)\n        7 - written on letter (used for intermission texts)\n        8 - purple (used by spider Mimi)\n        9 - computer\n        10 - invisible (just text)\n        11 - pixl\n        12 - Tiptron\n        13 - alternate system (used in underchomp battle)\n        14 - invisible with alternate icon (using in Francis dating)\n        15 - alternate selection (used in Francis dating)\n    */\n/* 0x08 */ s32 type;\n/* 0x0C */ Vec2 pos;\n/* 0x14 */ Vec2 scale;\n/* 0x1C */ u8 unknown_0x1c[0x20 - 0x1c];\n/* 0x20 */ s64 lastUpdateTime;\n/* 0x28 */ SmartAllocation * speakerSp; // smart pointer to MsgSpeaker\n/* 0x2C */ u8 unknown_0x2c[0x30 - 0x2c];\n/* 0x30 */ Vec3 speakerPos;\n/* 0x3C */ WindowFunc * mainFunc;\n/* 0x40 */ WindowFunc * deleteFunc;\n/* 0x44 */ u8 unknown_0x44[0x48 - 0x44];\n} WindowEntry;\nSIZE_ASSERT(WindowEntry, 0x48)\n\n#define WINDOW_MAX 7\nDECOMP_STATIC(WindowEntry * windowdrv_wp) // array of WINDOW_MAX\n\n/*\n    Allocates & clears entries\n*/\nvoid windowInit();\n\n/*\n    Clears entries\n*/\nvoid windowReInit();\n\n/*\n    Creates an empty window\n*/\ns32 windowEntry(u16 priority);\n\n/*\n    Delete window entry\n*/\nbool windowDelete(WindowEntry * entry);\nbool windowDeleteID(s32 id);\n\n/*\n    Call mainFunc for all active entries\n*/\nvoid windowMain();\n\nUNKNOWN_FUNCTION(func_80038b08);\nUNKNOWN_FUNCTION(func_80038cc0);\nUNKNOWN_FUNCTION(func_80038fb8);\n\n/*\n    Draws the background for a sign message\n*/\nvoid windowDispGX_Kanban(s32 type, GXColor * colour, f32 x, f32 y, f32 width, f32 height);\n\nUNKNOWN_FUNCTION(func_800393c8);\n\n/*\n    Draws the background for a system message\n*/\nvoid windowDispGX_System(s32 type, u8 alpha, f32 x, f32 y, f32 width, f32 height);\n\nUNKNOWN_FUNCTION(func_80039b80);\nUNKNOWN_FUNCTION(func_80039d40);\n\n/*\n    Draws the background for a regular message\n*/\nvoid windowDispGX_Message(s32 type, Unk, u8 alpha, f32 x, f32 y, f32 width, f32 height, f32, f32);\n\n/*\n    Draws the background for an item list\n*/\nvoid windowDispGX_ItemBox(Unk, GXColor * colour, f32 x, f32 y, f32 width, f32 height);\n\n/*\n    Draws a solid colour rectangle with a black border\n*/\nvoid windowDispGX2_Waku_col(Mtx34 * mtx, u32 gxTexMapId, const GXColor * colour, f32 x, f32 y,\n                            f32 width, f32 height, f32 curve);\n\n/*\n    Checks flag & 2 for a window\n    Returns either 2 or 0 instead of a normalised bool\n*/\ns32 windowCheckID(s32 id);\n\n/*\n    Returns a window by id\n*/\nWindowEntry * windowGetPointer(s32 id);\n\n/*\n    Returns whether any window is open, excluding type 1\n*/\nbool windowCheckOpen();\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::msgdrv)\n\nUSING(spm::memory::SmartAllocation)\nUSING(spm::windowdrv::WindowEntry)\nUSING(wii::dvd::DVDFileInfo)\n\ntypedef void (MsgSpeakerFunc)(s32 state, SmartAllocation * speakerSp);\n\ntypedef struct\n{\n/* 0x0000 */ const char * msgName;\n/* 0x0004 */ u32 flags;\n/* 0x0008 */ u8 unknown_0x8[0x18 - 0x8];\n/* 0x0018 */ s64 openTime; // when the window was opened\n/* 0x0020 */ u8 unknown_0x20[0x30 - 0x20];\n/* 0x0030 */ s64 messageStartTime; // last time text was added\n/* 0x0038 */ s32 cellCount;\n/* 0x003C */ u8 unknown_0x3c[0xf1fc - 0x3c];\n/* 0xF1FC */ MsgSpeakerFunc * mainFunc; // Called multiple times in msgMain with different states\n/* 0xF200 */ u8 unknown_0xf200[0xf204 - 0xf200];\n/* 0xF204 */ char npcName[32];\n/* 0xF224 */ u8 unknown_0xf224[0xf228 - 0xf224];\n    /*\n        0 normal\n        1 typewriter (used in opening cutscene)\n        2 writing\n        3 Francis dating\n        4-15 duplicates of normal\n    */\n/* 0xF228 */ s32 talkSfxGroup;\n/* 0xF22C */ u8 talkVolume;\n/* 0xF22D */ u8 unknown_0xf22d[0xf24b - 0xf22d];\n/* 0xF24C */ WindowEntry * window;\n/* 0xF250 */ s32 talkPoseTime; // frames remaining to be in the talking animation\n/* 0xF254 */ s32 isInTalkPose; // 1 if in talking animation, 0 otherwise\n} MsgSpeaker;\nSIZE_ASSERT(MsgSpeaker, 0xf258)\n\ntypedef struct\n{\n/* 0x0 */ u32 size;\n/* 0x4 */ const char * contents;\n/* 0x8 */ s32 messageCount;\n/* 0xC */ u8 unknown_0xc[0x10 - 0xc];\n} MsgFile;\nSIZE_ASSERT(MsgFile, 0x10)\n\ntypedef struct\n{\n/* 0x00 */ MsgFile files[9]; // 0 is global.txt\n/* 0x90 */ s32 hoshi_2AnimPoseId;\n/* 0x94 */ bool discReadFinished;\n/* 0x95 */ bool parseFinished;\n/* 0x96 */ u8 unknown_0x96[0x98 - 0x96];\n} MsgWork;\nSIZE_ASSERT(MsgWork, 0x98)\n\nDECOMP_STATIC(MsgWork * msgdrv_msgw)\nDECOMP_STATIC(MsgWork msgdrv_work)\n\ntypedef struct\n{\n/* 0x0 */ const char * name;\n/* 0x4 */ s32 iconid;\n} IconNameIdDef;\nSIZE_ASSERT(IconNameIdDef, 0x8)\n\nDECOMP_STATIC(IconNameIdDef msgdrv_msgIcon[24])\n\ntypedef struct\n{\n/* 0x0 */ const char * name1;\n/* 0x4 */ const char * name2;\n/* 0x8 */ const char * name3;\n/* 0xC */ const char * name4;\n} MsgTalkSfxGroup;\nSIZE_ASSERT(MsgTalkSfxGroup, 0x10)\n\nDECOMP_STATIC(MsgTalkSfxGroup * msgdrv_talkSfxGroups[14]) // index MsgSpeaker.talkSfxGroup\nDECOMP_STATIC(const char * msgdrv_skipSfx[16]) //  index MsgSpeaker.talkSfxGroup\n\ntypedef struct\n{\n/* 0x0 */ const char * openName;\n/* 0x4 */ const char * closeName;\n} MsgOpenCloseSfxGroup;\nSIZE_ASSERT(MsgOpenCloseSfxGroup, 0x8)\nDECOMP_STATIC(MsgOpenCloseSfxGroup msgdrv_openCloseSfxGroups[32]) // index WindowEntry.type\n\n// \"msg/XX\"\nDECOMP_STATIC(const char * msgdrv_language_dir[8]) // index gp->language\n\n/*\n    Closes file and sets discReadFinished\n*/\nDECOMP_STATIC(void msgdrv_dvdCb(s32 result, DVDFileInfo * fileInfo))\n\n/*\n    Initialises data and starts the async load of global.txt\n*/\nvoid msgInit();\n\n/*\n    Parses un-parsed message files and loads hoshi_2 model\n*/\nvoid msgdrvMain();\n\n/*\n    Loads the specified text file into the specified file slot\n    Language folder path is generated automatically, not included in textFileName\n    .txt is appended automatically, not included in textFileName\n*/\nbool msgLoad(const char * textFileName, s32 slot);\n\n/*\n    Unloads the text file in the specified slot\n*/\nvoid msgUnLoad(s32 slot);\n\n/*\n    Calls fileAsyncf on the specified message file to start it being loaded from disc\n    Language folder path is generated automatically, not included in textFileName\n    .txt is appended automatically, not included in textFileName\n*/\nvoid msgPreLoad(const char * filename);\n\n/*\n    Creates a smart pointer to a MsgSpeaker struct\n*/\nSmartAllocation * msgSpeakerInit(const char * msg, MsgSpeakerFunc * mainFunc, WindowEntry * window);\n\n/*\n    Updates a MsgSpeaker\n*/\nvoid msgMain(SmartAllocation * speakerSp);\n\n/*\n    Renders the window & text for a MsgSpeaker\n*/\nvoid msgDisp();\n\n/*\n    Draws the star that appears when waiting for input\n*/\nvoid msgDispKeyWait();\n\n/*\n    Configures GX settings for\n*/\nUNKNOWN_FUNCTION(msgDispKeyWait_render);\n\n/*\n    Adds message text to a MsgSpeaker\n*/\nvoid msgAnalize(SmartAllocation * speakerSp, const char * msg);\n\nDECOMP_STATIC(s32 msgdrv_msg_compare(void * param_1, void * param_2))\n\n/*\n    Returns the contents of a message by name\n    Returns \"anna_no_message\" when no message with that name is loaded\n*/\nconst char * msgSearch(const char * msgName);\n\n/*\n    Returns the contents of a message by name\n    Returns a null pointer when no message with that name is loaded\n*/\nconst char * msgSearchNoFallback(const char * msgName);\n\nDECOMP_STATIC(bool msgdrv__ismbblead(char param_1))\n\n/*\n    Splits a message command into tag and value\n    For example, command \"<col ffffff80>\" writes \"col\" to tag and \"ffffff80\" to value\n*/\nconst char * msgGetCommand(const char * command, char * tag, char * value);\n\n/*\n    Takes an icon name (like \"STICK\") and returns the icon id for it\n*/\ns32 msgIconStr2ID(const char * iconStr);\n\n/*\n    Sets a MsgSpeaker's npc/fairy/player/item to their talking/standing animation\n*/\nvoid msgSetTalkPose(SmartAllocation * speakerSp);\nvoid msgSetStayPose(SmartAllocation * speakerSp);\n\n/*\n    Creates a message WindowEntry and its MsgSpeaker\n*/\ns32 msgWindow_Entry(const char * msg, MsgSpeakerFunc * mainFunc, u16 priority);\n\n/*\n    Delete callback for WindowEntry, frees MsgSpeaker\n*/\ns32 msgWindow_Delete(WindowEntry * entry);\n\n/*\n    Adds text on to the end of a window\n*/\nvoid msgWindow_Add(const char * msg, s32 windowId);\n\n/*\n    Moves on from the window\n*/\nvoid msgWindow_Continue(s32 windowId);\n\n/*\n    Restarts text in a window\n*/\nvoid msgWindow_Repeat(s32 windowId);\n\n/*\n    Closes a window\n*/\nvoid msgWindow_ForceClose(const char * messageName);\n\n/*\n    Closes all text windows\n*/\nvoid msgWindow_ForceCloseAll();\n\n/*\n    Main callback for WindowEntry, updates text position, handles inputs\n    and schedules rendering to run this frame\n*/\nvoid msgWindow_Main(WindowEntry * window);\n\nvoid msgWindow_Clear_Main(WindowEntry * window);\n\n/*\n    Renders window background, text and input waiting icon\n*/\nvoid msgWindow_Disp(s8 camId, WindowEntry * window);\n\n/*\n    Main callback for WindowEntry, updates text position, handles inputs\n    and schedules rendering to run this frame\n*/\nvoid selectWindow_Main(WindowEntry * window);\n\n/*\n    Renders window background, text and cursor\n*/\nvoid selectWindow_Disp(s8 camId, WindowEntry * window);\n\nCPP_WRAPPER_END()\n/*\n    Functions to handle NAND interactions, including banner + save files\n    The save games are in title/00010000/52385050/data/wiimario0X (0-3)\n    The files are the SaveFile struct\n*/\n\n\n/*\n    spmario contains the main functions and variables of the game\n    In TTYD, this file was named mariost\n*/\n\n\n/*\n    swdrv handles \"Saved Work\", which are variables used in evt\n    scripts that are saved when closing the game\n    Set, Get & Clear functions handle bools\n    ByteGet and ByteSet functions handle s8 (or s32 for gsw0)\n    LSW(F) functions are prefixed by an underscore, the rest are GSW(F)\n*/\n\n\n\nCPP_WRAPPER(spm::swdrv)\n\n#define MAX_COIN_MAP 32\n#define MAX_COIN_BIT 0x200\n\ntypedef struct\n{\n/* 0x00 */ char mapName[8];\n/* 0x08 */ u32 coinFlags[16];\n} SwCoinEntry;\nSIZE_ASSERT(SwCoinEntry, 0x48)\n\ntypedef struct\n{\n/* 0x0 */ const char * mapName;\n/* 0x4 */ s32 num;\n} AssignTblEntry;\nSIZE_ASSERT(AssignTblEntry, 0x8)\n\ntypedef struct\n{\n/* 0x0 */ s32 coinId;\n/* 0x4 */ s32 gameCoinId;\n} SwWork;\nSIZE_ASSERT(SwWork, 0x8)\n\nDECOMP_STATIC(s32 swdrv_gameCoinGswMap[])\nDECOMP_STATIC(AssignTblEntry swdrv_assign_tbl[])\nDECOMP_STATIC(SwWork swdrv_work)\nDECOMP_STATIC(SwWork * swdrv_wp)\n\n/*\n    Zeros all of the evt variables in SpmarioGlobals (GSW, GSWF, LSW, LSWF),\n    SpMarioGlobals.unknown_0x1184, coinId and gameCoinId\n*/\nvoid swInit();\n\n/*\n    Zeros SpmarioGlobals LSW, LSWF & unknown_0x1184 and coinId\n*/\nvoid swReInit();\n\n/*\n    Turns on a global saved work flag\n*/\nvoid swSet(s32 id);\n\n/*\n    Returns the value of a global saved work flag\n*/\nbool swGet(s32 id);\n\n/*\n    Turns off a global saved work flag\n*/\nvoid swClear(s32 id);\n\n// TTYD symbol map shows there's an swToggle but it went unused in both games\n\n/*\n    Sets a global saved work value\n    Value cast to u8 unless setting GSW 0\n*/\nvoid swByteSet(s32 id, s32 num);\n\n/*\n    Gets a global saved work value\n    Return is u8 unless getting GSW 0\n*/\ns32 swByteGet(s32 id);\n\n/*\n    Turns on a local saved work flag\n*/\nvoid _swSet(s32 id);\n\n/*\n    Returns the value of a local saved work flag\n*/\nbool _swGet(s32 id);\n\n/*\n    Turns off a local saved work flag\n*/\nvoid _swClear(s32 id);\n\n// TTYD symbol map shows there's an _swToggle but it went unused in both games\n\n/*\n    Sets a local saved work value\n*/\nvoid _swByteSet(s32 id, u8 num);\n\n/*\n    Returns a local saved work value\n    Note: return is technically just u8 but calls used wrong casts when it was set to that\n*/\ns32 _swByteGet(s32 id);\n\ns32 swGetCoinId();\nvoid swCoinSet(s32 id);\nvoid swCoinClear(s32 id);\nbool swCoinGet(s32 id);\nvoid swResetCoinId();\nvoid swResetGameCoinId();\ns32 swGetGameCoinId();\nbool swGameCoinGet(s32 id);\nvoid swGameCoinSet(s32 id);\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::spmario)\n\nUSING(spm::swdrv::SwCoinEntry)\nUSING(wii::os::OSThread)\nUSING(wii::os::OSTime)\nUSING(wii::mtx::Vec3)\n\n#define SPMARIO_FLAG_1 1\n#define SPMARIO_FLAG_2 2\n#define SPMARIO_FLAG_4 4\n#define SPMARIO_FLAG_8 8\n\ntypedef struct\n{\n/* 0x0000 */ u32 flags;\n/* 0x0004 */ s32 fps; // not read from save file\n/* 0x0008 */ s32 language; // not read from save file\n/* 0x000C */ u32 discIsEjected;\n/* 0x0010 */ u32 systemLevelFlags;\n/* 0x0014 */ u8 unknown_0x14[0x18 - 0x14];\n/* 0x0018 */ u16 framebufferWidth;\n/* 0x001A */ u16 framebufferHeight;\n/* 0x001C */ f32 gameSpeed;\n/* 0x0020 */ char saveName[32];\n/* 0x0040 */ s32 lastSaveLoaded; // not read from save file\n/* 0x0044 */ char mapName[32];\n/* 0x0064 */ char doorName[32];\n/* 0x0084 */ char gameOverMapName[32];\n/* 0x00A4 */ char prevMapName[32];\n/* 0x00C4 */ u8 unknown_0xc4[0xc8 - 0xc4];\n/* 0x00C8 */ OSTime lastSaveUpdateTime; // last time save file in memory was written to\n/* 0x00D0 */ Vec3 savePosition;\n/* 0x00DC */ s32 saveFileId;\n/* 0x00E0 */ u32 unknown_0xe0; // not read from save file\n/* 0x00E4 */ u8 unknown_0xe4[0xf8 - 0xe4];\n/* 0x00F8 */ OSTime time;\n/* 0x0100 */ OSTime timePlayed;\n/* 0x0108 */ u8 unknown_0x108[0x110 - 0x108];\n/* 0x0110 */ OSTime lastSaveLoadTime;\n/* 0x0118 */ u8 unknown_0x118[0x138 - 0x118];\n/* 0x0138 */ OSTime lastButtonPressTime; // uncertain\n/* 0x0140 */ s32 gsw0; // first GSW is a full word\n/* 0x0144 */ u32 gswf[256]; // 8192 flags\n/* 0x0544 */ s8 gsw[2048]; // index 0 used in favour of gsw0\n/* 0x0D44 */ u32 lswf[16]; // 512 flags\n/* 0x0D84 */ u8 lsw[1024];\n/* 0x1184 */ SwCoinEntry coinEntries[32];\n/* 0x1A84 */ u8 unknown_0x1a84[0x1b00 - 0x1a84];\n/* 0x1B00 */ bool disableRumble[4]; // overrides to force off wpadmgr's enableRumble,\n                                    // index controller id\n/* 0x1B04 */ u8 unknown_0x1b04[0x1b08 - 0x1b04];\n} SpmarioGlobals;\nSIZE_ASSERT(SpmarioGlobals, 0x1b08)\nextern SpmarioGlobals * gp;\nextern SpmarioGlobals spmario;\n\nDECOMP_STATIC(OSThread * spmario_pMainThread)\nextern s32 _spmarioSystemLevel;\nDECOMP_STATIC(s32 spmario_resetCode)\nDECOMP_STATIC(s8 spmario_doReturnToMenu)\nDECOMP_STATIC(s8 spmario_doHomeButtonRestart)\nDECOMP_STATIC(s8 spmario_doShutdown)\nDECOMP_STATIC(s8 spmario_doResetButtonRestart)\nDECOMP_STATIC(s32 spmario_startTick)\nDECOMP_STATIC(s32 spmario_unusedZero)\n\nvoid spmarioInit();\nvoid spmarioMain();\nvoid spmarioDisp();\nvoid spmarioSystemLevel(s32 level);\ns32 spmarioGetSystemLevel();\nDECOMP_STATIC(UNKNOWN_FUNCTION(spmario_viPostCallback))\nDECOMP_STATIC(UNKNOWN_FUNCTION(spmario_wiiDvdCheckThread))\nDECOMP_STATIC(UNKNOWN_FUNCTION(spmario_wiiRumbleCheck))\nvoid resetButtonRestart();\nvoid shutdownConsole();\nvoid homeButtonRestart();\nvoid returnToWiiMenu();\n\nCPP_WRAPPER_END()\n/*\n    Revolution SDK NAND library\n*/\n\n\n\nCPP_WRAPPER(wii::nand)\n\n#define NAND_ALIGN 32\n\n#define NAND_CODE_OK 0\n#define NAND_CODE_BUSY -3\n#define NAND_CODE_5 -5\n#define NAND_CODE_EXISTS -6\n#define NAND_CODE_9 -9\n#define NAND_CODE_11 -11\n#define NAND_CODE_NOT_EXIST -12\n#define NAND_CODE_15 -15\n#define NAND_CODE_FATAL -128\n\n#define NAND_ANSWER_FLAG_1 1\n#define NAND_ANSWER_FLAG_2 2\n#define NAND_ANSWER_FLAG_4 4\n#define NAND_ANSWER_FLAG_8 8\n\n#define NAND_PERMISSION_READ 0x10\n#define NAND_PERMISSION_WRITE 0x20\n#define NAND_PERMISSION_READ_WRITE (NAND_PERMISSION_READ | NAND_PERMISSION_WRITE)\n\n#define NAND_MODE_READ 1\n#define NAND_MODE_WRITE 2\n\n#define NAND_SET_ICON_SPEED(banner, icon, speed) banner->iconSpeed = (u16) ((banner->iconSpeed & ~(3 << 2 * (icon))) | ((speed) << 2 * (icon)))\n\n#define NAND_PATH_LENGTH 64\n#define NAND_FILENAME_LENGTH 13\n\n#define NAND_BANNER_FLAG_NO_COPY 0x1\n#define NAND_BANNER_FLAG_BOUNCE 0x10\n\ntypedef struct\n{\n/* 0x00 */ u8 unknown_0x0[0x8c - 0x0];\n} NANDFileInfo;\nSIZE_ASSERT(NANDFileInfo, 0x8c)\n\ntypedef struct\n{\n/* 0x0000 */ u32 magic;\n/* 0x0004 */ u32 flags;\n/* 0x0008 */ u16 iconSpeed;\n/* 0x000A */ u8 unknown_0xa[0x20 - 0xa];\n/* 0x0020 */ wchar16_t comment[2][32];\n/* 0x00A0 */ u8 bannerTexture[0x6000];\n/* 0x60A0 */ u8 iconTextures[8][0x1200];\n} NANDBanner;\nSIZE_ASSERT(NANDBanner, 0xf0a0)\n\ntypedef struct\n{\n/* 0x00 */ u8 unknown_0x0[0xb8 - 0x0];\n#ifdef SPM_KR0\n/* 0xB0 */ u8 unknown_0xb8[0xbc - 0xb8];\n#endif\n} NANDCommandBlock;\n#ifdef SPM_KR0\nSIZE_ASSERT(NANDCommandBlock, 0xbc)\n#else\nSIZE_ASSERT(NANDCommandBlock, 0xb8)\n#endif\n\ntypedef void (NANDCallback)(s32 result, NANDCommandBlock * commandBlock);\n\nUNKNOWN_FUNCTION(nandCreate);\ns32 NANDCreateAsync(const char * filename, u8 permissions, u8 attributes, NANDCallback * callback,\n                    NANDCommandBlock * commandBlock);\nUNKNOWN_FUNCTION(NANDPrivateCreateAsync);\nUNKNOWN_FUNCTION(NANDDelete);\ns32 NANDDeleteAsync(const char * filename, NANDCallback * callback,\n                    NANDCommandBlock * commandBlock);\nUNKNOWN_FUNCTION(NANDPrivateDeleteAsync);\nUNKNOWN_FUNCTION(NANDRead);\ns32 NANDReadAsync(NANDFileInfo * fileinfo, void * buffer, u32 length, NANDCallback * callback,\n                  NANDCommandBlock * commandBlock);\nUNKNOWN_FUNCTION(NANDWrite);\ns32 NANDWriteAsync(NANDFileInfo * fileInfo, void * buffer, u32 size, NANDCallback * callback,\n                   NANDCommandBlock * commandBlock);\ns32 NANDSeekAsync(NANDFileInfo * fileInfo, u32 offset, u8 mode, NANDCallback * callback,\n                  NANDCommandBlock * commandBlock);\nUNKNOWN_FUNCTION(nandCreateDir);\nUNKNOWN_FUNCTION(NANDPrivateCreateDirAsync);\nUNKNOWN_FUNCTION(nandComposePerm);\nUNKNOWN_FUNCTION(nandSplitPerm);\nUNKNOWN_FUNCTION(nandGetStatus);\nUNKNOWN_FUNCTION(nandGetStatusCallback);\nUNKNOWN_FUNCTION(NANDPrivateGetStatusAsync);\nUNKNOWN_FUNCTION(nandOpen);\nUNKNOWN_FUNCTION(NANDOpen);\nUNKNOWN_FUNCTION(NANDPrivateOpen);\nUNKNOWN_FUNCTION(NANDOpenAsync);\nUNKNOWN_FUNCTION(NANDPrivateOpenAsync);\nUNKNOWN_FUNCTION(nandOpenCallback);\nUNKNOWN_FUNCTION(NANDClose);\nUNKNOWN_FUNCTION(NANDCloseAsync);\ns32 NANDSafeOpenAsync(const char * path, NANDFileInfo * fileInfo, u8 mode, void * buffer,\n                      u32 bufferSize, NANDCallback * callback, NANDCommandBlock * commandBlock);\nUNKNOWN_FUNCTION(nandSafeOpenAsync);\nUNKNOWN_FUNCTION(nandSafeOpenCallback);\nUNKNOWN_FUNCTION(nandReadOpenCallback);\ns32 NANDSafeCloseAsync(NANDFileInfo * fileInfo, NANDCallback * callback,\n                       NANDCommandBlock * commandBlock);\nUNKNOWN_FUNCTION(nandSafeCloseCallback);\nUNKNOWN_FUNCTION(nandReadCloseCallback);\nUNKNOWN_FUNCTION(nandCloseCallback);\nUNKNOWN_FUNCTION(nandRemoveTailToken);\nUNKNOWN_FUNCTION(nandGetHeadToken);\nUNKNOWN_FUNCTION(nandGetRelativeName);\nUNKNOWN_FUNCTION(nandConvertPath);\nUNKNOWN_FUNCTION(nandIsPrivatePath);\nUNKNOWN_FUNCTION(nandIsUnderPrivatePath);\nUNKNOWN_FUNCTION(nandIsInitialised);\nUNKNOWN_FUNCTION(nandReportErrorCode);\nUNKNOWN_FUNCTION(nandConvertErrorCode);\nUNKNOWN_FUNCTION(nandGenerateAbsPath);\nUNKNOWN_FUNCTION(nandGetParentDirectory);\nUNKNOWN_FUNCTION(NANDInit);\nUNKNOWN_FUNCTION(nandOnShutdown);\nUNKNOWN_FUNCTION(nandShutdownCallback);\nUNKNOWN_FUNCTION(nandChangeDir);\ns32 NANDChangeDirAsync(const char * path, NANDCallback * callback, NANDCommandBlock * commandBlock);\nUNKNOWN_FUNCTION(nandChangeDirCallback);\ns32 NANDGetHomeDir(char * path);\nUNKNOWN_FUNCTION(nandCallback);\nUNKNOWN_FUNCTION(nandGetType);\nUNKNOWN_FUNCTION(NANDPrivateGetTypeAsync);\nUNKNOWN_FUNCTION(nandGetTypeCallback);\nUNKNOWN_FUNCTION(nandGetHomeDir);\nvoid NANDInitBanner(NANDBanner * banner, u32 flags, wchar16_t * title, wchar16_t * comment);\nUNKNOWN_FUNCTION(_ES_GetDataDir);\ns32 NANDCheckAsync(u32 blockCount, u32 inodeCount, u32 * answer, NANDCallback * callback,\n                   NANDCommandBlock * commandBlock);\nUNKNOWN_FUNCTION(nandUserAreaCallback);\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::nandmgr)\n\nUSING(spm::mario_pouch::MarioPouchWork)\nUSING(spm::spmario::SpmarioGlobals)\nUSING(wii::nand::NANDBanner)\nUSING(wii::nand::NANDCommandBlock)\nUSING(wii::nand::NANDFileInfo)\n\n#define NAND_BLOCK_COUNT 7\n#define NAND_INODE_COUNT 5\n#define NAND_ATTEMPTS_MAX 100\n\nenum NandTask\n{\n/* 0x0 */ NANDMGR_TASK_NONE,\n/* 0x1 */ NANDMGR_TASK_CHECK,\n/* 0x2 */ NANDMGR_TASK_WRITE_BANNER,\n/* 0x3 */ NANDMGR_TASK_WRITE_ALL_SAVES,\n/* 0x4 */ NANDMGR_TASK_WRITE_SAVE,\n/* 0x5 */ NANDMGR_TASK_WRITE_BANNER_LOAD_ALL_SAVES,\n/* 0x6 */ NANDMGR_TASK_DELETE_SAVE\n};\n\n#define SAVE_FLAG_1 1\n#define SAVE_FLAG_CORRUPT 2\n\ntypedef struct\n{\n/* 0x0000 */ u16 flags;\n/* 0x0002 */ u8 unknown_0x2[0x8 - 0x2];\n/* 0x0008 */ SpmarioGlobals spmarioGlobals;\n/* 0x1B10 */ MarioPouchWork pouch;\n/* 0x21B0 */ u8 unknown_0x21b0[0x400];\n    // Checksums are calculated with checksum set to 0 and checksumNOT set to 0xffff\n/* 0x25B0 */ u32 checksum;\n/* 0x25B4 */ u32 checksumNOT;\n} SaveFile;\nSIZE_ASSERT(SaveFile, 0x25b8)\n\n#define SAVE_FILE_COUNT 4\n\n#define NAND_FLAG_Exec 1\n#define NAND_FLAG_Waiting 2\n#define NAND_FLAG_Error 4\n#define NAND_FLAG_NoSave 0x1000\n\n// 32-byte alignment?\n#define NAND_TEMP_SAVE_SIZE (sizeof(SaveFile) + 0x8)\n\ntypedef struct\n{\n/* 0x000 */ u32 flag;\n/* 0x004 */ void * openingBuffer; // used by NANDSafeOpenAsync\n/* 0x008 */ size_t openingBufferSize; // 0x4000\n/* 0x00C */ u8 unknown_0xc[0x10 - 0xc];\n/* 0x010 */ SaveFile * saves; // array of 4\n/* 0x014 */ void * tempSaveFile; // NAND_TEMP_SAVE_FILE_SIZE bytes\n/* 0x018 */ char homedir[64];\n/* 0x058 */ NANDFileInfo fileInfo;\n/* 0x0E4 */ NANDCommandBlock commandBlock;\n/* 0x19C */ NANDBanner * banner;\n/* 0x1A0 */ u32 bannerSize; // omits unused iconTextures\n/* 0x1A4 */ void * tempBanner;\n/* 0x1A8 */ u32 answer;\n/* 0x1AC */ u32 task; // used by task main functions to track progress\n/* 0x1B0 */ s32 stage;\n/* 0x1B4 */ s32 code;\n/* 0x1B8 */ s32 saveId; // slot of save file to work on\n} NandWork;\n#ifdef SPM_KR0\nSIZE_ASSERT(NandWork, 0x1c0)\n#else\nSIZE_ASSERT(NandWork, 0x1bc)\n#endif\n\nDECOMP_STATIC(NandWork nandmgr_work)\nDECOMP_STATIC(NandWork * nandmgr_wp)\n\n/*\n    Initialises banner, work and saves\n    Saves are zerod with hashes corrected, not loaded from NAND\n*/\nvoid nandInit();\n\n/*\n    Continues the current asynchronous task\n*/\nvoid nandMain();\n\n/*\n    Checks whether an asynchronous task is still running\n*/\nbool nandIsExec();\n\n/*\n    Gets the latest NAND library function return\n*/\ns32 nandGetCode();\n\n/*\n    Returns a pointer to the array of all 4 save files\n*/\nSaveFile * nandGetSaveFiles();\n\n/*\n    Starts NANDCheck being called asynchronously to see that the game's files can all be created\n*/\nvoid nandCheck();\n\n/*\n    Starts banner.bin being written to NAND asynchronously \n*/\nvoid nandWriteBanner();\n\n/*\n    Starts all save files being written to NAND asynchronously \n*/\nvoid nandWriteAllSaves();\n\n/*\n    Starts a save file being written to NAND asynchronously \n*/\nvoid nandWriteSave(s32 saveId);\n\n/*\n    Starts writing banner.bin to and reading all save files from NAND asynchronously \n*/\nvoid nandWriteBannerLoadAllSaves();\n\n/*\n    Starts all save files being deleted from NAND asynchronously\n    Parameter value is ignored\n*/\nvoid nandDeleteSave(s32 saveId);\n\n/*\n    Copies the contents of one save file to another\n    Changes copies in memory only, NAND is not written\n*/\nvoid nandCopySave(s32 sourceId, s32 destId);\n\n/*\n    Clears the contents of a save file\n    Changes the copy in memory only, NAND is not written\n*/\nvoid nandClearSave(s32 saveId);\n\n/*\n    Updates the contents of a save file\n    Changes the copy in memory only, NAND is not written\n*/\nvoid nandUpdateSave(s32 saveId);\n\n/*\n    Loads the contents of a save file into the game's systems\n    For example, SPMarioGlobals are copied to gp.\n    Uses the copy in memory, NAND is not read\n*/\nvoid nandLoadSave(s32 saveId);\n\n/*\n    Disables saving to NAND, all saves are cleared on game over.\n*/\nvoid nandDisableSaving();\n\n/*\n    Re-enables saving to NAND\n*/\nvoid nandEnableSaving();\n\n/*\n    Returns whether saving to NAND is enabled\n*/\nbool nandCheckSaving();\n\n/*\n    Carries out the asynchronous process for nandCheck\n*/\nvoid nandCheckMain();\n\n/*\n    Carries out the asynchronous process for nandWriteBanner\n*/\nvoid nandWriteBannerMain();\n\n/*\n    Carries out the asynchronous process for nandWriteAllSaves\n*/\nvoid nandWriteAllSavesMain();\n\n/*\n    Carries out the asynchronous process for nandWriteSave\n*/\nvoid nandWriteSaveMain();\n\n/*\n    Carries out the asynchronous process for nandWriteBannerLoadAllSaves\n*/\nvoid nandWriteBannerLoadAllSavesMain();\n\n/*\n    Carries out the asynchronous process for nandDeleteSave\n*/\nvoid nandDeleteSaveMain();\n\n/*\n    Callback for NAND library functions\n*/\nDECOMP_STATIC(void nandmgr_genericCallback(s32 result, NANDCommandBlock * commandBlock))\n\n/*\n    Unique callback for NANDCheck\n*/\nDECOMP_STATIC(void nandmgr_checkCallback(s32 result, NANDCommandBlock * commandBlock))\n\nCPP_WRAPPER_END()\n\n// TODO: this isn't a proper file, figure out what it really is\n\nCPP_WRAPPER(spm::npcmisc)\n\nUSING(spm::npcdrv::NPCEntry)\n\nvoid npcDropItem(NPCEntry * npc, s32 itemType, s32 coinCount);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::offscreendrv)\n\nvoid offscreenInit();\nUNKNOWN_FUNCTION(offscreenReset);\nUNKNOWN_FUNCTION(offscreenEntry);\nUNKNOWN_FUNCTION(offscreenDisp);\nvoid offscreenMain();\nUNKNOWN_FUNCTION(offscreenAddBoundingBox);\nUNKNOWN_FUNCTION(func_800350a0);\nUNKNOWN_FUNCTION(func_800350fc);\nUNKNOWN_FUNCTION(offscreenNameToId);\nUNKNOWN_FUNCTION(func_8003521c);\nUNKNOWN_FUNCTION(func_800352b4);\nUNKNOWN_FUNCTION(func_800352cc);\nUNKNOWN_FUNCTION(func_800353c4);\nUNKNOWN_FUNCTION(func_80035478);\nUNKNOWN_FUNCTION(func_800354d8);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::parse)\n\nenum ParseValueType\n{\n/* 0x0 */ PARSE_VALUE_TYPE_STRING,\n/* 0x1 */ PARSE_VALUE_TYPE_1,\n/* 0x2 */ PARSE_VALUE_TYPE_INT,\n/* 0x3 */ PARSE_VALUE_TYPE_FLOAT,\n/* 0x4 */ PARSE_VALUE_TYPE_VEC3\n};\n\nvoid parseInit(const char * text, u32 length);\nDECOMP_STATIC(const char * parse_getTag(const char * text, s32 startIdx, s32 endIdx))\nbool parsePush(const char * tag);\nvoid parsePop();\nvoid parsePopNext();\nbool parseGet1Next(s32 type, void * ret);\nbool parseTagGet1(const char * tag, s32 type, void * ret);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::an)\n\nEVT_DECLARE_USER_FUNC(evt_an_init_tpl, 0)\nEVT_DECLARE_USER_FUNC(evt_an_darkness_onoff, 1)\nEVT_DECLARE_USER_FUNC(evt_an_remove_npcs, 1)\n// more\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::an2_08)\n\ntypedef struct RpgNPC {\n/* 0x00 */ s32 flags;\n/* 0x04 */ s32 unk_4;\n/* 0x08 */ s32 maxHp;\n/* 0x0C */ s32 attackStrength;\n/* 0x10 */ s32 unk_10;\n/* 0x14 */ s32 killXp;\n} RpgNPC;\nSIZE_ASSERT(RpgNPC, 0x18)\n\ntypedef struct RpgMenu {\n/* 0x00 */ const char * option_1;\n/* 0x04 */ int unk_4;\n/* 0x08 */ const char * option_2;\n/* 0x0c */ int unk_c;\n/* 0x10 */ const char * option_3;\n/* 0x14 */ int unk_14;\n/* 0x18 */ const char * option_4;\n/* 0x1c */ int unk_1c;\n/* 0x20 */ const char * option_5;\n/* 0x24 */ int unk_24;\n/* 0x28 */ const char * option_6;\n/* 0x2c */ int unk_2c;\n/* 0x30 */ int unk_30;\n} RpgMenu;\nSIZE_ASSERT(RpgMenu, 0x34)\n\ntypedef struct An2_08Work {\n/* 0x00 */ s32 flags;\n/* 0x04 */ s32 unk_04;\n/* 0x08 */ RpgMenu* rpgMenu;\n/* 0x0C */ RpgNPC rpgNpcInfo[3];\n/* 0x54 */ s32 unk_54;\n/* 0x58 */ s32 unk_58[15];\n/* 0x94 */ char unk_94[4];\n} An2_08Work; //sizeof 0x98\nSIZE_ASSERT(An2_08Work, 0x98)\n\nDECOMP_STATIC(An2_08Work an2_08_wp)\nDECOMP_STATIC(const char * lbl_80def2c8[4])\n\nEVT_DECLARE(begin_rpg_parent_evt)\nEVT_DECLARE(final_rpg_child_evt)\nEVT_DECLARE(underchomp_attack_1_evt)\nEVT_DECLARE(underchomp_attack_2_evt)\nEVT_DECLARE(underchomp_attack_3_evt)\nEVT_DECLARE(rpg_check_win_or_continue_evt)\nEVT_DECLARE(rpg_attacking_evt)\nEVT_DECLARE(rpg_use_pixls_evt)\nEVT_DECLARE(rpg_use_items_evt)\nEVT_DECLARE(rpg_run_away_evt)\nEVT_DECLARE(rpg_snd_miss_evt)\nEVT_DECLARE(rpg_snd_hit_evt)\n\nUNKNOWN_FUNCTION(func_80c6c908);\nu8 rpgHandleMenu(int param_1, RpgMenu * menu);\nUNKNOWN_FUNCTION(func_80c6cccc);\nUNKNOWN_FUNCTION(func_80c6ce24);\nvoid rpg_screen_draw();\n\nEVT_DECLARE_USER_FUNC(evt_rpg_npctribe_handle, 0)\nEVT_DECLARE_USER_FUNC(evt_rpg_change_menu_flag, 0)\nEVT_DECLARE_USER_FUNC(evt_rpg_choice_handler, 5)\nEVT_DECLARE_USER_FUNC(evt_rpg_char_get, 1)\nEVT_DECLARE_USER_FUNC(evt_rpg_underchomp_name_grab, 2)\nEVT_DECLARE_USER_FUNC(evt_rpg_calc_damage_to_enemy, 3)\nEVT_DECLARE_USER_FUNC(evt_rpg_enemy_take_damage, 4)\nEVT_DECLARE_USER_FUNC(evt_rpg_calc_mario_damage, 2)\nEVT_DECLARE_USER_FUNC(evt_rpg_mario_take_damage, 3)\nEVT_DECLARE_USER_FUNC(evt_rpg_point_calculation, 2)\nEVT_DECLARE_USER_FUNC(evt_rpg_enemy_death_check, 2)\nEVT_DECLARE_USER_FUNC(evt_rpg_effect_check, 1)\nEVT_DECLARE_USER_FUNC(evt_rpg_status_remove, 3)\nEVT_DECLARE_USER_FUNC(evt_rpg_menu_effects_handler, 2)\nEVT_DECLARE_USER_FUNC(evt_rpg_wakeup_check, 2)\nEVT_DECLARE_USER_FUNC(evt_rpg_effects_handle, 2)\nEVT_DECLARE_USER_FUNC(evt_rpg_calc_item_stats, 4)\nEVT_DECLARE_USER_FUNC(evt_rpg_add_xp, 1)\nEVT_DECLARE_USER_FUNC(evt_rpg_point_handling, 1)\nEVT_DECLARE_USER_FUNC(evt_rpg_get_item_msg, 2)\nEVT_DECLARE_USER_FUNC(evt_an2_08_draw_face, 2)\nUNKNOWN_FUNCTION(func_80c72d5c);\nUNKNOWN_FUNCTION(func_80c72e10);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::dan)\n\nUSING(spm::evt_door::DokanDesc)\nUSING(spm::evt_door::MapDoorDesc)\nUSING(spm::evt_shop::EvtShopDef)\nUSING(spm::npcdrv::NPCTribeAnimDef)\n\n#define DUNGEON_MAX 200\n#define DAN_PARTS_COUNT 16\n\n// A definition of a possible door setup in the room, read from pitText\ntypedef struct\n{\n    s32 enter; // index of the door to enter the room with\n    s32 exit; // index of the door to exit the room with\n} DanDoor;\nSIZE_ASSERT(DanDoor, 0x8)\n\n// A definition of enemies to spawn in the room, read from pitText\ntypedef struct\n{\n    s32 name; // tribe id + 1 of the enemy type\n    s32 num; // how many of the enemy to spawn\n    s32 pos; // where to spawn the enemy, 0 for random\n} DanEnemy;\nSIZE_ASSERT(DanEnemy, 0xc)\n\n// A definition of one pit room, read from pitText\ntypedef struct\n{\n        // flags for parts of the map to enable\n        // ( https://cdn.discordapp.com/attachments/498246688130203658/858790159141830716/pitparts.png )\n    u32 map;\n    s32 item; // only used in chest rooms\n    s32 doorCount; // amount of used entries in the doors array\n    s32 enemyCount; // amount of used entries in the enemies array\n    DanDoor doors[20]; // possible door setups in this room\n    DanEnemy enemies[16]; // enemies to spawn in this room\n} DanDungeon;\nSIZE_ASSERT(DanDungeon, 0x170)\n\ntypedef struct\n{\n    DanDungeon * dungeons; // array of size DUNGEON_MAX\n    DanDoor doorInfo; // the door configuration that ended up being used in this room\n    s32 spawnTableCount; // number of entries used in the spawm table\n    s32 spawnTable[32]; // door ids enemies can spawn at\n    u8 unknown_0x90[0x110 - 0x90];\n    char enterDoorName_l[64];\n    char enterDoorName_r[64];\n    char enterDoorHitName2d[64];\n    char enterDoorHitName3d[64];\n    char prevMapName[64];\n    char enterDoor_desc0x18[64];\n    char exitDoorName_l[64];\n    char exitDoorName_r[64];\n    char exitDoorHitName2d[64];\n    char exitDoorHitName3d[64];\n    char nextMapName[64];\n    char exitDoor_desc0x18[64];\n    u8 unknown_0x410[0x510 - 0x410];\n    char enterDoorName[64];\n    char exitDoorName[64];\n} DanWork;\nSIZE_ASSERT(DanWork, 0x590)\n\nDECOMP_STATIC(DanWork * dan_wp)\n\nDECOMP_STATIC(const char * dan_mapParts[16])\nDECOMP_STATIC(DokanDesc dan_dokanDescs[8])\nDECOMP_STATIC(MapDoorDesc dan_mapDoorDescs[2])\nDECOMP_STATIC(s32 dan_flipsideLockItems[])\nDECOMP_STATIC(s32 dan_flopsideLockItems[])\n\nEVT_DECLARE(dan_lock_interact_evt)\nEVT_DECLARE(dan_lock_open_evt)\nEVT_DECLARE(dan_enemy_room_init_evt)\n\nDECOMP_STATIC(DokanDesc dan_chestRoomDokanDesc)\nDECOMP_STATIC(MapDoorDesc dan_chestRoomMapDoorDescs[2])\n\nEVT_DECLARE(dan_exit_pipe_sign_interact_evt)\nEVT_DECLARE(dan_chest_open_evt)\n\nDECOMP_STATIC(s32 dan_rotenShopItems[])\nDECOMP_STATIC(EvtShopDef dan_rotenShopDef)\nDECOMP_STATIC(NPCTribeAnimDef dan_rotenTribeAnimDefs[])\n\nEVT_DECLARE(dan_chest_room_init_evt)\n\nDECOMP_STATIC(MapDoorDesc dan_wracktail_map_door_desc)\nDECOMP_STATIC(DokanDesc dan_wracktail_dokan_desc)\nDECOMP_STATIC(DokanDesc dan_shadoo_dokan_desc)\n\nEVT_DECLARE(dan_30_init_evt)\nEVT_DECLARE(dan_70_init_evt)\n\nDECOMP_STATIC(NPCTribeAnimDef dan_dashellTribeAnimDefs[])\n\nEVT_DECLARE(dan_30_chest_interact_evt)\nEVT_DECLARE(dan_30_chest_open_evt)\n\nDECOMP_STATIC(NPCTribeAnimDef dan_wracktailTribeAnimDefs[])\n\nEVT_DECLARE(dan_wracktail_main_evt)\nEVT_DECLARE(dan_start_wracktail_evt)\nEVT_DECLARE(dan_70_mario_chest_open_evt)\nEVT_DECLARE(dan_70_dark_mario_chest_open_evt)\nEVT_DECLARE(dan_70_peach_chest_open_evt)\nEVT_DECLARE(dan_70_dark_peach_chest_open_evt)\nEVT_DECLARE(dan_70_bowser_chest_open_evt)\nEVT_DECLARE(dan_70_dark_bowser_chest_open_evt)\nEVT_DECLARE(dan_70_luigi_chest_open_evt)\nEVT_DECLARE(dan_70_dark_luigi_chest_open_evt)\nEVT_DECLARE(dan_shadoo_main_evt)\nEVT_DECLARE(dan_shadoo_fight_evt)\nEVT_DECLARE(dan_shadoo_defeat_evt)\nEVT_DECLARE(dan_70_reward_appear_evt)\nEVT_DECLARE(dan_start_shadoo_evt)\n\n/*\n    Init work, decompress & read pitText\n*/\n// evt_dan_read_data()\nEVT_DECLARE_USER_FUNC(evt_dan_read_data, 0)\n\n/*\n    Enable & disable parts of the map based on this dungeon's <map> flags\n*/\n// evt_dan_handle_map_parts(s32 no)\nEVT_DECLARE_USER_FUNC(evt_dan_handle_map_parts, 1)\n\n/*\n    Enable & disable parts of the map based on this dungeon's <map> flags\n*/\n// evt_dan_handle_dokans(s32 no)\nEVT_DECLARE_USER_FUNC(evt_dan_handle_dokans, 1)\n\n/*\n    Select which doors to use as the entrance and exit randomly based on this map's <door> entries\n    Outputs the names of the enter & exit doors and the co-ordinates for the lock to spawn at\n*/\n// evt_dan_handle_doors(s32 no, s32 room, &char * enterDoor, &char * exitDoor, &f32 lockX,\n//                      &f32 lockY, &f32 lockZ)\nEVT_DECLARE_USER_FUNC(evt_dan_handle_doors, 7)\n\n/*\n    Get the enter and exit door names\n*/\n// evt_dan_get_door_names(&char * enterName, &char * exitName)\nEVT_DECLARE_USER_FUNC(evt_dan_get_door_names, 2)\n\n/*\n    Get the _l name for the exit door\n*/\n// evt_dan_get_exit_door_name_l(&char * name)\nEVT_DECLARE_USER_FUNC(evt_dan_get_exit_door_name_l, 1)\n\n/*\n    Get the template id and amount of the enemy to spawn for an index into this map's <enemy> entries\n*/\n// evt_dan_get_enemy_info(s32 no, s32 enemyIdx, &s32 templateId, &s32 num)\nEVT_DECLARE_USER_FUNC(evt_dan_get_enemy_info, 4)\n\n/*\n    Makes this dungeon's spawn table based on enabled map parts\n*/\n// evt_dan_make_spawn_table(s32 no)\nEVT_DECLARE_USER_FUNC(evt_dan_make_spawn_table, 1)\n\n/*\n    Returns the spawn coordinates for an enemy which is within the group at <enemyIdx>\n    num is a counter of how many enemies have spawned before this one (in any group)\n*/\n// evt_dan_get_enemy_spawn_pos(s32 num, s32 no, s32 enemyIdx, &f32 x, &f32 y, &f32 z)\nEVT_DECLARE_USER_FUNC(evt_dan_get_enemy_spawn_pos, 6)\n\n/*\n    Gives a key of the specified item id to a random enemy\n*/\n// evt_dan_decide_key_enemy(s32 itemId)\nEVT_DECLARE_USER_FUNC(evt_dan_decide_key_enemy, 1)\n\n/*\n    Hud countdown callback, kills the player\n*/\nvoid danCountdownDone();\n\n/*\n    Starts the 5 minute countdown\n*/\n// evt_dan_start_countdown()\nEVT_DECLARE_USER_FUNC(evt_dan_start_countdown, 0)\n\n/*\n    Returns whether a key exists on the ground within the map boundaries\n*/\nbool danCheckKeyInMapBbox();\n\n/*\n    Returns whether any enemy exists within the map boundaries\n*/\nbool danCheckEnemyInMapBbox();\n\n/*\n    user_func that runs endlessly in a parallel script to spawn the key at the door\n    if it becomes impossible to obtain\n*/\n// evt_dan_handle_key_failsafe()\nEVT_DECLARE_USER_FUNC(evt_dan_handle_key_failsafe, 0)\n\n/*\n    Sets the entering door name, exit pipe destination and door destination for a chest room\n*/\n// evt_dan_handle_chest_room_dokans_and_doors(s32 no)\nEVT_DECLARE_USER_FUNC(evt_dan_handle_chest_room_dokans_and_doors, 1)\n\n/*\n    Returns the item that should be in the chest for the current chest room\n*/\n// evt_dan_get_chest_room_item(s32 no, &s32 itemId)\nEVT_DECLARE_USER_FUNC(evt_dan_get_chest_room_item, 2)\n\n/*\n    Sets the entering door name for a boss room\n*/\n// evt_dan_boss_room_set_door_name()\nEVT_DECLARE_USER_FUNC(evt_dan_boss_room_set_door_name, 0)\n\nvoid func_80c839cc(const char * param_1, bool param_2);\nvoid wracktailDispCb(void * param, s32 animGroupIdx, s32 param_3);\n\n// evt_dan_set_wracktail_disp_cb()\nEVT_DECLARE_USER_FUNC(evt_dan_set_wracktail_disp_cb, 0)\n\n// func_80c83c48()\nEVT_DECLARE_USER_FUNC(func_80c83c48, 0)\n\nvoid screenBlinkDisp(s32 cameraId, void * param);\n\n// evt_dan_screen_blink()\nEVT_DECLARE_USER_FUNC(evt_dan_screen_blink, 0)\n\nconst char * func_80c83f6c(const char * param_1);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::machi)\n\ntypedef struct\n{\n/* 0x00 */ u8 unknown_0x0[0x4 - 0x0];\n/* 0x04 */ const char * name;\n/* 0x08 */ u8 unknown_0x8[0x2c - 0x8];\n} ElvDesc;\nSIZE_ASSERT(ElvDesc, 0x2c)\n\n// ...\n\n// evt_machi_set_elv_descs(ElvDesc * descs, s32 count)\nEVT_DECLARE_USER_FUNC(evt_machi_set_elv_descs, 2)\n\n// ...\n\nEVT_UNKNOWN_USER_FUNC(func_80c4d444)\n\n// ...\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::sp4_13)\n\nUSING(spm::npcdrv::NPCTribeAnimDef)\n\nchar * spReturnAngryAnimPos(char *param_1);\nchar * func_80c5c304(char *param_1);\nEVT_DECLARE_USER_FUNC(func_80c5c36c, 0)\n\nDECOMP_STATIC(NPCTribeAnimDef spMrLStartTribeAnimDefs[1])\nDECOMP_STATIC(NPCTribeAnimDef spMrLTribeAnimDefs[11])\nDECOMP_STATIC(NPCTribeAnimDef spMrLTauntTribeAnimDefs[7])\nDECOMP_STATIC(NPCTribeAnimDef spTheGreenThunderTribeAnimDefs[5])\n\nEVT_DECLARE(mr_l_appear_evt)\nEVT_DECLARE(brobot_appear_evt)\n// more\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::wa1_02)\n\ntypedef struct \n{\n/* 0x00 */ const char * mapName;\n/* 0x04 */ u8 unknown_0x4[0x8 - 0x4];\n/* 0x08 */ s32 alreadyBeatenLsw1;\n/* 0x0C */ u8 unknown_0xc[0x10 - 0xc];\n/* 0x10 */ s32 alreadyBeatenGsw0;\n/* 0x14 */ u8 unknown_0x14[0x28 - 0x14];\n} SammerDef;\nSIZE_ASSERT(SammerDef, 0x28)\n\nextern SammerDef sammerDefsCh6[30];\nextern SammerDef sammerDefsEndgame[30];\n\n// ...\n\nCPP_WRAPPER_END()\n/*\n    relmgr controls the loading and execution of the game's rel file\n\n    Rel files are all in the /rel/ folder at the root of the disk\n    relF.bin is the actual rel, rel.bin and relD.bin are unused\n    .bin rels are lzss10 compressed, the game also supports loading an\n    uncompressed file named relF.rel if relF.bin is not found\n*/\n\n\n\nCPP_WRAPPER(spm::relmgr)\n\nUSING(wii::os::RelHeader)\n\ntypedef struct\n{\n/* 0x0 */ RelHeader * relFile;\n/* 0x4 */ void * bss;\n/* 0x8 */ bool loaded;\n} RelWork;\nSIZE_ASSERT(RelWork, 0xc)\n\nDECOMP_STATIC(RelWork * relmgr_wp)\nDECOMP_STATIC(const char * relmgr_relDecompName)\nDECOMP_STATIC(const char * relmgr_relCompName)\n\n/*\n    Sets the rel loaded bool to false\n*/\nvoid relInit();\n\n/*\n    Attempts to continue the process of loading the rel, if it hasn't already finished\n*/\nvoid relMain();\n\n/*\n    Returns whether the rel has finished loading and had its prolog run\n*/\nbool isRelLoaded();\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::romfont)\n\nUSING(wii::gx::GXColor)\n\n// This file was heavily changed in the Korean version to be NW4R based\n#ifndef SPM_KR0\n\ntypedef struct\n{\n/* 0x000 */ u8 image[0x120];\n/* 0x120 */ s16 character;\n/* 0x122 */ s16 width;\n/* 0x124 */ u8 unknown_0x124[0x140 - 0x124];\n} RomfontEntry;\nSIZE_ASSERT(RomfontEntry, 0x140)\n\ntypedef struct\n{\n/* 0x0 */ RomfontEntry * entries;\n/* 0x4 */ s32 entryCount;\n/* 0x8 */ s32 useSJIS;\n} RomfontWork;\nSIZE_ASSERT(RomfontWork, 0xc)\n\nDECOMP_STATIC(RomfontWork * romfont_wp)\nDECOMP_STATIC(RomfontWork romfont_work)\n\nconst char * romFontGetMessage(s32 id);\nvoid romFontInit();\nDECOMP_STATIC(void romfont_romFontMake())\nvoid ATTRIBUTE_FORMAT(printf, 5, 6) romFontPrintGX(f32 x, f32 y, f32 scale, const GXColor * colour,\n                                                   const char * msg, ...);\ns32 romFontGetWidth(const char * message);\n\n#endif\n\nCPP_WRAPPER_END()\n/*\n    Defines which functions should be called in each sequence for seqdrv\n*/\n\n\n\nCPP_WRAPPER(spm::seqdrv)\n\nstruct _SeqWork;\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::seqdef)\n\nUSING(spm::seqdrv::_SeqWork)\n\n#define SEQ_COUNT 6\n\ntypedef void (SeqFunc)(struct _SeqWork *);\n\ntypedef struct\n{\n    SeqFunc * init;\n    SeqFunc * main;\n    SeqFunc * exit;\n} SeqDef;\nextern SeqDef seq_data[SEQ_COUNT];\n\nCPP_WRAPPER_END()\n/*\n    seqdrv functions control the main loops of the game. One sequence is active at\n    a time: its init function runs first, then its main function is ran every\n    frame, and its exit function runs when changing to another sequence.\n*/\n\n\n\nCPP_WRAPPER(spm::seqdrv)\n\nUSING(spm::seqdef::SeqFunc)\n\nenum SeqdrvSeq\n{\n/* 0x0 */ SEQ_LOGO,\n/* 0x1 */ SEQ_TITLE,\n/* 0x2 */ SEQ_GAME,\n/* 0x3 */ SEQ_MAPCHANGE,\n/* 0x4 */ SEQ_GAMEOVER,\n/* 0x5 */ SEQ_LOAD\n};\n\ntypedef struct _SeqWork\n{\n/* 0x00 */ s32 seq; // enum above, or -1 if none\n/* 0x04 */ s32 stage; // number used by the seq_ functions to track their progress\n/* 0x08 */ const char * p0; // parameter for seq function, only used in MapChange (map name)\n/* 0x0C */ const char * p1; // parameter for seq function, only used in MapChange (door name)\n/* 0x10 */ u8 unknown_0x10[0x20 - 0x10];\n/* 0x20 */ SeqFunc * afterFunc; // ran after every call to the main SeqFunc if not null\n} SeqWork;\nSIZE_ASSERT(SeqWork, 0x24)\n\n/*\n    Initialises data used by seqdrv functions\n*/\nvoid seqInit_SPMARIO();\n\n/*\n    Calls all init, main & exit functions based on now_seq & next_seq\n*/\nvoid seqMain();\n\n/*\n    Sets the current sequence and its prameters\n*/\nvoid seqSetSeq(s32 seqNum, const char * p0, const char * p1);\n\n/*\n    Returns now_seq or 0 if equal to -1\n*/\ns32 seqGetSeq();\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::seq_game)\n\nUSING(spm::seqdrv::SeqWork)\n\nUNKNOWN_FUNCTION(seqGamePreloadScriptsSpawnedNpcs);\nUNKNOWN_FUNCTION(seqGameReadConnectedMapNames);\nUNKNOWN_FUNCTION(seqGamePreloadConnectedMaps);\nUNKNOWN_FUNCTION(loadMapdataBin);\nvoid seq_gameInit(SeqWork * work);\nvoid seq_gameMain(SeqWork * work);\nvoid seq_gameExit(SeqWork * work);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::seq_gameover)\n\nUSING(spm::seqdrv::SeqWork)\n\nvoid seq_gameOverInit(SeqWork * work);\nvoid seq_gameOverMain(SeqWork * work);\nvoid seq_gameOverExit(SeqWork * work);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::seq_load)\n\nUSING(spm::seqdrv::SeqWork)\n\nUNKNOWN_FUNCTION(initNewSaveFile);\nvoid seq_loadInit(SeqWork * work);\nvoid seq_loadMain(SeqWork * work);\nvoid seq_loadExit(SeqWork * work);\n\nCPP_WRAPPER_END()\n/*\n    seq_logo is the sequencethat displays the first 2 screens of the game\n*/\n\n\n\nCPP_WRAPPER(spm::seq_logo)\n\nUSING(spm::evtmgr::EvtEntry)\nUSING(spm::seqdrv::SeqWork)\nUSING(wii::tpl::TPLHeader)\n\ntypedef struct\n{\n/* 0x00 */ u8 unknown_0x0[0x10 - 0x0];\n/* 0x10 */ TPLHeader * healthAndSafetyTPL;\n/* 0x14 */ TPLHeader * holdSidewaysTPL;\n/* 0x18 */ EvtEntry * nandCheckEvtEntry;\n/* 0x1C */ s32 nandCheckEvtEntryId;\n} SeqLogoWork;\nSIZE_ASSERT(SeqLogoWork, 0x20)\nDECOMP_STATIC(SeqLogoWork seq_logo_work)\nDECOMP_STATIC(SeqLogoWork * seq_logo_wp)\n\nvoid seq_logoInit(SeqWork * work);\nvoid seq_logoMain(SeqWork * work);\nvoid seq_logoExit(SeqWork * work);\nUNKNOWN_FUNCTION(seq_logoDisp);\n\nCPP_WRAPPER_END()\n/*\n    seq_mapChange is the sequence that loads a map\n*/\n\n\n\nCPP_WRAPPER(spm::seq_mapchange)\n\nUSING(spm::evtmgr::EvtEntry)\nUSING(spm::seqdrv::SeqWork)\n\ntypedef struct\n{\n/* 0x00 */ char areaName[32];\n/* 0x20 */ char mapName[32];\n/* 0x40 */ char beroName[32]; // door the map was entered with\n/* 0x60 */ EvtEntry * initEvtEntry;\n/* 0x64 */ s32 initEvtEntryId;\n/* 0x68 */ u8 unknown_0x68[0x74 - 0x68];\n} SeqMapChangeWork;\nSIZE_ASSERT(SeqMapChangeWork, 0x74)\n\nDECOMP_STATIC(SeqMapChangeWork * seq_mapchange_wp)\nDECOMP_STATIC(SeqMapChangeWork seq_mapchange_work)\n\nvoid seq_mapChangeInit(SeqWork * work);\nvoid seq_mapChangeExit(SeqWork * work);\nvoid seq_mapChangeMain(SeqWork * work);\nvoid _unload(const char * curMapName, const char * nextMapName, const char * doorName);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::seq_title)\n\nUSING(spm::seqdrv::SeqWork)\n\nvoid seq_titleInit(SeqWork * work);\nvoid seq_titleMain(SeqWork * work);\nvoid seq_titleExit(SeqWork * work);\nUNKNOWN_FUNCTION(func_8017b49c);\nUNKNOWN_FUNCTION(seqTitleInitLayout);\nUNKNOWN_FUNCTION(func_8017b8ac);\n\n// No idea why this is in this file of all places, but it is\nconst char * getNextDanMapname(s32 dungeonNo);\n\nCPP_WRAPPER_END()\n/*\n    setup_data defines the structure of the dat files in \"./setup/\"\n    and handles the item-spawning side of them\n*/\n\n\nCPP_WRAPPER(spm::setup_data)\n\nUSING(wii::mtx::Vec3)\n\n// v0-5 unknown, v0-4 don't have support for items, v0 is unused\n// Skawo has the size of the enemy structs for other versions and an unusual unknown field in v1\n// documented in https://github.com/skawo/Super-Paper-Mario-Level-Editor-Randomizer/\n\ntypedef struct\n{\n/* 0x00 */ s32 instanceId; // ignored if 0\n/* 0x04 */ u8 unknown_0x4[0x10 - 0x4];\n/* 0x10 */ s32 unitWork[16];\n/* 0x50 */ u8 unknown_0x50[0x5c - 0x50];\n/* 0x5C */ f32 gravityRotation; // degrees anti-clockwise about the z-axis\n} MiscSetupDataV6;\nSIZE_ASSERT(MiscSetupDataV6, 0x60)\n\ntypedef struct\n{\n/* 0x00 */ Vec3 pos;\n/* 0x0C */ s32 type; // nTemplateNo, index into npcEnemyTemplates\n/* 0x10 */ MiscSetupDataV6 misc;\n} SetupEnemyV6;\nSIZE_ASSERT(SetupEnemyV6, 0x70)\n\ntypedef struct\n{\n/* 0x0000 */ u16 version;\n/* 0x0002 */ // padding 0x2-3\n/* 0x0004 */ SetupEnemyV6 enemies[100];\n} SetupFileV6;\nSIZE_ASSERT(SetupFileV6, 0x2bc4)\n\ntypedef struct\n{\n/* 0x0 */ u16 flags; // 0x10 and 0x1 required to spawn, others unused\n/* 0x2 */ u16 type; // only 0 is supported, which is a coin\n/* 0x4 */ Vec3 pos;\n} SetupItem;\nSIZE_ASSERT(SetupItem, 0x10)\n\ntypedef struct\n{\n/* 0x0000 */ SetupFileV6 main;\n/* 0x2BC4 */ s32 itemCount;\n/* 0x2BC8 */ s32 itemVersion; // 20051201\n/* 0x2BCC */ SetupItem items[1]; // itemCount items\n} SetupFileV6WithItems;\nOFFSET_ASSERT(SetupFileV6WithItems, items, 0x2bcc)\n\ntypedef struct\n{\n/* 0x0 */ u16 id; // only 0 is used\n/* 0x2 */ u16 itemTeplateId; // index into setupItemTemplates\n} SetupItemTemplate;\nSIZE_ASSERT(SetupItemTemplate, 0x4)\n\nextern SetupItemTemplate setupItemTemplates[1]; // only contains id 0 - a coin\n\n/*\n    Takes a pointer to the item list of a setup file & its length and spawns them \n*/\nvoid setupSpawnItems(s32 count, SetupItem * items);\n\n/*\n    Takes a pointer to a setup file and returns the number of items in it, the\n    version of the item data and the pointer to the array of items\n    \n    Returns all 0s for setup files that aren't v5 or v6, or for v5 & v6 that\n    don't have any item data in them\n    (This reads uninitialised memory that happens to be 0 because of disc alignment)\n*/\nvoid setupReadItemInfo(void * file, s32 * count, s32 * version, SetupItem ** data);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::shadowdrv)\n\nvoid shadowInit();\nvoid shadowMain();\nUNKNOWN_FUNCTION(shadowDisp);\nUNKNOWN_FUNCTION(shadowCharShadowInit);\nUNKNOWN_FUNCTION(polygonInit);\nUNKNOWN_FUNCTION(textureInit);\nUNKNOWN_FUNCTION(_filter);\nUNKNOWN_FUNCTION(shadowCharShadowDisp_Collision);\nUNKNOWN_FUNCTION(shadowCharShadowDisp_Projection);\nUNKNOWN_FUNCTION(shadowCharShadowDisp_Polygon);\nUNKNOWN_FUNCTION(shadowCharShadowDisp_Texture);\nUNKNOWN_FUNCTION(cylinder);\nUNKNOWN_FUNCTION(cylinderShadowDraw);\nUNKNOWN_FUNCTION(shadowEntry);\nUNKNOWN_FUNCTION(shadowEntryMode);\nUNKNOWN_FUNCTION(shadowSetType);\nUNKNOWN_FUNCTION(func_800375e4);\nUNKNOWN_FUNCTION(func_800375fc);\nUNKNOWN_FUNCTION(func_8003763c);\nUNKNOWN_FUNCTION(func_8003765c);\nUNKNOWN_FUNCTION(shadowSetVolumeDecay);\nUNKNOWN_FUNCTION(shadowSetSize);\nUNKNOWN_FUNCTION(shadowSetCollision);\nUNKNOWN_FUNCTION(shadowFlagOff);\nUNKNOWN_FUNCTION(shadowGetCharShadowTexObj);\nUNKNOWN_FUNCTION(shadowGetCharShadowProjTexMtx);\nUNKNOWN_FUNCTION(shadowGetCharShadowColor);\nUNKNOWN_FUNCTION(shadowGetCharShadowProjection);\nUNKNOWN_FUNCTION(shadowGetRamp8TexObj);\nUNKNOWN_FUNCTION(shadowGetRamp16TexObj);\nUNKNOWN_FUNCTION(shadowDepthShadowDrawCountUp);\nUNKNOWN_FUNCTION(shadowGetDepthShadowTexObj);\nUNKNOWN_FUNCTION(shadowGetDepthShadowDepthMtx);\nUNKNOWN_FUNCTION(shadowGetDepthShadowProjTexMtx);\nUNKNOWN_FUNCTION(shadowGetDepthShadowColor);\nUNKNOWN_FUNCTION(shadowGetDepthShadowConfig);\nUNKNOWN_FUNCTION(shadowProjShadowDrawCountUp);\nUNKNOWN_FUNCTION(shadowGetProjShadowTexObj);\nUNKNOWN_FUNCTION(shadowGetProjShadowProjTexMtx);\nUNKNOWN_FUNCTION(shadowGetProjShadowColor);\nUNKNOWN_FUNCTION(shadowGetProjShadowConfig);\nUNKNOWN_FUNCTION(func_800378c8);\nUNKNOWN_FUNCTION(projShadowEnd);\nUNKNOWN_FUNCTION(depthShadowEnd);\n\nCPP_WRAPPER_END()\n\n\n// TODO: C++\n\nCPP_WRAPPER(spm::spmario_snd)\n\nvoid spsndInit();\nvoid spsndMain();\nvoid spsndExit();\nUNKNOWN_FUNCTION(spsndPause);\nUNKNOWN_FUNCTION(spsndUnpause);\nUNKNOWN_FUNCTION(func_8023872c);\nUNKNOWN_FUNCTION(spsndSetPosDirListener);\nUNKNOWN_FUNCTION(spsndSetSFXReverbMode);\nUNKNOWN_FUNCTION(func_80238804);\nUNKNOWN_FUNCTION(func_80238868);\nUNKNOWN_FUNCTION(spsndSetFlag);\nUNKNOWN_FUNCTION(spsndClearFlag);\nUNKNOWN_FUNCTION(spsndGetFlag);\nUNKNOWN_FUNCTION(func_802388f4);\nUNKNOWN_FUNCTION(func_80238b04);\nUNKNOWN_FUNCTION(spsndSFXMain);\nUNKNOWN_FUNCTION(__spsndSFXOn);\ns32 spsndSFXOn(const char * name);\nUNKNOWN_FUNCTION(spsndSFXOnVol);\nUNKNOWN_FUNCTION(spsndSFXOn_UnkEffect);\nUNKNOWN_FUNCTION(_spsndSFXOn);\nUNKNOWN_FUNCTION(spsndSFXOn_3D);\nUNKNOWN_FUNCTION(spsndSFXOff);\nUNKNOWN_FUNCTION(func_8023b38c);\nUNKNOWN_FUNCTION(spsndSetSfxPlayerPos);\nUNKNOWN_FUNCTION(spsndSFX_vol);\nUNKNOWN_FUNCTION(spsndSFX_pit);\nUNKNOWN_FUNCTION(spsndSFX_delay);\nUNKNOWN_FUNCTION(func_8023b680);\nUNKNOWN_FUNCTION(func_8023b77c);\nUNKNOWN_FUNCTION(func_8023b858);\nUNKNOWN_FUNCTION(func_8023b974);\nUNKNOWN_FUNCTION(spsndSFX_flagOn);\nUNKNOWN_FUNCTION(spsndSFX_flagOff);\nUNKNOWN_FUNCTION(spsndSFX_chkName);\nUNKNOWN_FUNCTION(spsndSFX_chk);\nUNKNOWN_FUNCTION(spsndSFX_getIdPlayingName);\nUNKNOWN_FUNCTION(spsndGetSFXEntry);\nUNKNOWN_FUNCTION(spsndBGMMain);\nUNKNOWN_FUNCTION(spsndBGMOn_f_d);\nbool spsndBGMOn(u32 flags, const char * name);\nUNKNOWN_FUNCTION(spsndBGMOn_f_d_alt);\nbool spsndBGMOff_f_d(s32 player, u32 fadeoutTime);\nUNKNOWN_FUNCTION(spsndBGMOff);\nUNKNOWN_FUNCTION(spsndBGMOff_f_d_alt);\nUNKNOWN_FUNCTION(func_8023cab4);\nUNKNOWN_FUNCTION(func_8023cc90);\nUNKNOWN_FUNCTION(func_8023cc98);\nUNKNOWN_FUNCTION(func_8023cc9c);\nUNKNOWN_FUNCTION(func_8023ce1c);\nUNKNOWN_FUNCTION(func_8023ce20);\nUNKNOWN_FUNCTION(func_8023cf14);\nUNKNOWN_FUNCTION(func_8023cfe8);\nUNKNOWN_FUNCTION(func_8023d0dc);\nbool spsndCheckBgmPlaying(s32 player);\nUNKNOWN_FUNCTION(spsndGetBgmName);\nUNKNOWN_FUNCTION(func_8023d1f8);\nUNKNOWN_FUNCTION(func_8023d218);\nUNKNOWN_FUNCTION(func_8023d2b8);\nUNKNOWN_FUNCTION(spsndENVMain);\nUNKNOWN_FUNCTION(spsndENVOn_f_d);\nUNKNOWN_FUNCTION(spsndENVOn);\nUNKNOWN_FUNCTION(func_8023db5c);\nUNKNOWN_FUNCTION(func_8023dc88);\nUNKNOWN_FUNCTION(func_8023dc90);\nUNKNOWN_FUNCTION(func_8023dc94);\nUNKNOWN_FUNCTION(func_8023dda4);\nUNKNOWN_FUNCTION(func_8023de90);\nUNKNOWN_FUNCTION(func_8023dfa0);\nUNKNOWN_FUNCTION(func_8023e08c);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(spm::sptexture)\n\nvoid sptextureInit();\nUNKNOWN_FUNCTION(sptextureSetUnusedBool);\nvoid sptextureMain();\nUNKNOWN_FUNCTION(sptextureGet);\nUNKNOWN_FUNCTION(sptextureIsLoaded);\n\nCPP_WRAPPER_END()\n/*\n    Game's custom system library\n*/\n\n\n\nCPP_WRAPPER(spm::system)\n\nUSING(wii::mtx::Mtx34)\n\nenum IntplMode\n{\n    INTPL_MODE_LINEAR = 0,\n    INTPL_MODE_QUADRATIC_IN = 1,\n    INTPL_MODE_CUBIC_IN = 2,\n    INTPL_MODE_QUARTIC_IN = 3,\n    INTPL_MODE_QUADRATIC_OUT = 4,\n    INTPL_MODE_CUBIC_OUT = 5,\n    INTPL_MODE_QUARTIC_OUT = 6,\n    INTPL_MODE_COS_SLOW_OVERSHOOT = 7,\n    INTPL_MODE_COS_FAST_OVERSHOOT = 8,\n    INTPL_MODE_9 = 9,\n    INTPL_MODE_COS_BOUNCE = 10,\n\n    INTPL_MODE_COS_IN_OUT,\n    INTPL_MODE_SIN_OUT,\n    INTPL_MODE_COS_IN\n};\n\ntypedef f32 (IntplUserFunc)(s32, s32, f32, f32);\n\n#ifdef DECOMP\n\n// TODO: figure out what's going on with the assert if statement in decomp\n// assert in evtmgr.c line 161 is incompatible with (condition) == false\n// assertf dan.c line 144 is incompatible with !(condition)\n// assertf dvdmgr.c line 51 is incompatible with bool check = (condition); !check\n\n#define assert(line, condition, message) \\\n    do \\\n    { \\\n        bool check = (condition); \\\n        if (!check) __assert2(__FILE__, line, #condition, message); \\\n    } while (0)\n\n#define assertf(line, condition, message, ...) \\\n    do \\\n    { \\\n        if ((condition) == false) __assert2(__FILE__, line, #condition, message, __VA_ARGS__); \\\n    } while (0)\n\n#else\n\n#define assert(condition, message) \\\n    if (!(condition)) spm::system::__assert2(__FILE__, __LINE__, #condition, message)\n\n#define assertf(condition, message, ...) \\\n    if (!(condition)) spm::system::__assert2(__FILE__, __LINE__, #condition, message, __VA_ARGS__)\n\n#endif\n\n#define RAND_MAX 0x7fff\n\n\n/*\n    Initialises an unused mutex\n*/\nvoid sysInitMutex();\n\n/*\n    Gets the root path for the DVD filesystem\n*/\nconst char * getSpmarioDVDRoot();\n\n/*\n    Gets the root path for the mapdata folder in the DVD filesystem\n*/\nconst char * getMapdataDvdRoot();\n\n/*\n    Assertion failure handlers\n*/\ns32 NORETURN __assert(const char * filename, s32 line, const char * assertion);\ns32 NORETURN ATTRIBUTE_FORMAT(printf, 4, 5) __assert2(\n    const char * filename, s32 line, const char * assertion, const char * message, ...);\n\n/*\n    Rounds a float to an int\n    Deadstripped, always inlined\n*/\ns32 roundi(f32 x);\n\n/*\n    Adjusts an angle to be 0 <= x < 360\n*/\nf32 reviseAngle(f32 angle);\n\n/*\n    Gets the straight line distance between two 2D points\n*/\nf32 distABf(f32 x1, f32 z1, f32 x2, f32 z2);\n\n/*\n    Calculates b - a in the range -180 <= x < 180 for 0 <= a, b < 360\n*/\nf32 compAngle(f32 a, f32 b);\n\n/*\n    Gets the angle between two 2D points (atan2)\n*/\nf32 angleABf(f32 x1, f32 z1, f32 x2, f32 z2);\n\n/*\n    Gets the sine and cosine of an angle\n*/\nvoid sincosf(f32 x, f32 * sinx, f32 * cosx);\n\n/*\n    Translates a point in along a straight line at an angle\n*/\nvoid movePos(f32 distance, f32 angle, f32 * x, f32 * z);\n\nDECOMP_STATIC(void fsort(char ** table, size_t size))\nvoid qqsort(char * list, size_t nel, size_t size, void * compare);\n\n/*\n    Gets a random number 0 <= x <= RAND_MAX\n*/\ns32 rand();\n\n/*\n    Gets a random number 0 <= x <= limit\n*/\ns32 irand(s32 limit);\nf32 frand(f32 limit);\n\n/*\n    Initialises the RNG seed\n*/\nvoid sysRandInit();\n\n/*\n    Gets the current screen draw token\n    Deadstripped, always inlined\n*/\nu16 sysGetToken();\n\n/*\n    Waits until the next screen draw, or max 100ms\n*/\nvoid sysWaitDrawSync();\n\n/*\n    memcmp/memcpy, done word-by-word rather than byte-by-byte\n*/\ns32 memcmp_as4(const void * a, const void * b, u32 n);\nvoid memcpy_as4(void * dest, const void * source, u32 n);\n\n/*\n    Extracts the rotation of a matrix\n*/\nvoid mtxGetRotationElement(Mtx34 mtx, Mtx34 out, char axis1, char axis2);\n\n/*\n    Extracts the scale factor of a matrix\n*/\nvoid mtxGetScaleElement(Mtx34 mtx, Mtx34 out);\n\n/*\n    Converts a millisecond count to frame count\n*/\ns32 sysMsec2Frame(s32 msec);\n\n/*\n    Interpolates a value, see IntplMode above\n    Mode can also be an IntplUserFunc pointer\n*/\nf32 intplGetValue(s32 mode, f32 min, f32 max, s32 progress, s32 progressMax);\n\nCPP_WRAPPER_END()\n/*\n    winmgr is a higher level wrapper for windowdrv\n*/\n\n\n\nCPP_WRAPPER(spm::winmgr)\n\nUSING(wii::mtx::Vec2)\nUSING(wii::mtx::Vec2i)\n\nstruct _WinmgrEntry;\ntypedef void (WinmgrFunc)(struct _WinmgrEntry * entry);\n\ntypedef struct\n{\n/* 0x00 */ u8 unknown_0x0[0x8 - 0x0];\n/* 0x08 */ s32 cameraId;\n/* 0x0C */ Vec2i pos;\n/* 0x14 */ Vec2i scale;\n/* 0x1C */ u8 unknown_0x1c[0x20 - 0x1c];\n/* 0x20 */ WinmgrFunc * mainFunc;\n/* 0x24 */ WinmgrFunc * deleteFunc;\n} WindowDesc;\nSIZE_ASSERT(WindowDesc, 0x28)\n\ntypedef struct\n{\n/* 0x0 */ u16 entryCount; // number of winmgr entries to create\n/* 0x4 */ WindowDesc * descs; // array of entryCount\n} WinmgrSelectDesc;\nSIZE_ASSERT(WinmgrSelectDesc, 0x8)\n\nDECOMP_STATIC(WindowDesc winmgr_select_desc[2])\nDECOMP_STATIC(WindowDesc winmgr_select_recipe_desc[3]) // 3rd is unused\nDECOMP_STATIC(WindowDesc winmgr_select_card_desc[2])\nDECOMP_STATIC(WinmgrSelectDesc winmgr_select_desc_tbl[8]) // index is winmgr select type\n\ntypedef struct\n{\n/* 0x0 */ s16 itemId;\n/* 0x2 */ u8 unknown_0x2[0x4 - 0x2];\n/* 0x4 */ s32 animPoseId;\n/* 0x8 */ u8 unknown_0x8[0xc - 0x8];\n} WinmgrItem;\nSIZE_ASSERT(WinmgrItem, 0xc)\n\ntypedef struct\n{\n/* 0x00 */ u32 flags;\n/* 0x04 */ u8 unknown_0x4[0x8 - 0x4];\n/* 0x08 */ s32 typeOrItemTable;\n/* 0x0C */ u8 unknown_0xc[0x10 - 0xc];\n/* 0x10 */ s32 selectedItemIdx; // index into item table currently hovered over\n/* 0x14 */ u8 unknown_0x14[0x18 - 0x14];\n/* 0x18 */ Vec2 pos;\n/* 0x20 */ u8 unknown_0x20[0x24 - 0x20];\n/* 0x24 */ s32 entryCount; // number of winmgr entries\n/* 0x28 */ s32 entryIds[3]; // winmgr entry ids\n/* 0x34 */ s32 pausewinId; // id for pausewin entry drawing background box\n/* 0x38 */ WinmgrItem * items;\n/* 0x3C */ s32 itemCount;\n/* 0x40 */ s32 extraItem;\n/* 0x44 */ u8 unknown_0x44[0x6c - 0x44];\n} WinmgrSelect;\nSIZE_ASSERT(WinmgrSelect, 0x6c)\n\ntypedef struct _WinmgrEntry{\n    /*\n        8 is scheduled for deletion\n        1 is active\n        Others unknown\n    */\n/* 0x00 */ u32 flags;\n/* 0x04 */ u8 unknown_0x4[0x10 - 0x4];\n/* 0x10 */ f32 scalarScale;\n/* 0x14 */ u8 unknown_0x14[0x18 - 0x14];\n/* 0x18 */ Vec2i pos;\n/* 0x20 */ Vec2i scale;\n/* 0x28 */ WindowDesc * desc;\n/* 0x2C */ void * param; // for select windows, pointer to WinmgrSelect\n/* 0x30 */ s32 priority;\n} WinmgrEntry;\nSIZE_ASSERT(WinmgrEntry, 0x34)\n\ntypedef struct\n{\n/* 0x0 */ s32 entryCount; // 0x20\n/* 0x4 */ WinmgrEntry * entries; // array of entryCount\n} WinmgrWork;\nSIZE_ASSERT(WinmgrWork, 0x8)\n\nDECOMP_STATIC(WinmgrWork winmgr_work)\nDECOMP_STATIC(WinmgrWork * winmgr_wp)\n\n/*\n    Allocates entries\n*/\nvoid winMgrInit();\n\n/*\n    Clears entries\n*/\nvoid winmgrReInit();\n\n/*\n    Displays a window & calls its disp func\n*/\nvoid winMgrDisp(s32 cameraId, WinmgrEntry * entry);\n\n/*\n    Calls winMgrSeq on each entry & its main func, and schedules winMgrDisp for each func\n*/\nvoid winMgrMain();\n\nvoid winMgrSeq(WinmgrEntry * entry);\n\n/*\n    Creates an entry from a desc and returns its id\n*/\ns32 winMgrEntry(WindowDesc * desc);\n\n/*\n    Sets user data parameter for a window\n*/\nvoid winMgrSetParam(void * param);\n\n/*\n    Opens a window\n*/\nvoid winMgrOpen(s32 id);\n\n/*\n    Closes a window and schedules it to be deleted\n*/\nvoid winMgrCloseAutoDelete(s32 id);\n\n/*\n    Checks the action flag of a window\n*/\nvoid winMgrAction(s32 id);\n\n/*\n    Sets the position and scale of a window\n*/\nvoid winMgrSetSize(s32 id, s32 posX, s32 posY, s32 scaleX, s32 scaleY);\n\n/*\n    Sets the priority of a window\n*/\nvoid winMgrSetPriority(s32 id, s32 priority);\n\n/*\n    Creates an item selection window\n\n    Type values: \n        0 is keyItem selection\n        1 is useItem selection\n        2 is useItem sale\n        3 is useItem store\n        4 is shopItem pickup\n        5 is card selection\n        6 is card sale\n        7 is recipes selection \n    Type can also be a pointer to a list of s32 item ids terminated by -1 (uses type 0's properties)\n\n    Extra item is added at the start of the list\n*/\nWinmgrSelect * winMgrSelectEntry(s32 type, s32 extraItem, u32 flags);\n\n/*\n    Get the resulting item id of a selection window\n    -1 means the user backed out\n    0 means undecided\n*/\ns32 winMgrSelect(WinmgrSelect * select);\n\n\n/*\n    Deletes a selection window\n*/\nvoid winMgrSelectDelete(WinmgrSelect * select);\n\n/*\n    Returns the index of the item currently selected\n*/\ns32 winMgrSelectGetIndex(WinmgrSelect * select);\n\n/*\n    WindowDesc.mainFunc/dispFuncs for a WinmgrSelect window\n    Update & draw the main window\n*/\nvoid select_main(WinmgrEntry * entry);\nvoid select_disp(WinmgrEntry * entry);\n\n/*\n    Displays the instruction to choose one\n*/\nvoid select_disp2(WinmgrEntry * entry);\n\n/*\n    Unused function to display \"msg_window_item_cancel\"\n    This message is defined twice, as either a go back with 1 or \n    select with 2 instruction\n    Seems to have originally been intended for recipe selection\n*/\nvoid select_disp3(WinmgrEntry * entry);\n\nCPP_WRAPPER_END()\n/*\n    wpadmgr handles controller inputs & vibration \n\n    The game reads up to 16 KPADStatuses for each controller but only ever seems to use the latest\n*/\n\n\n/*\n    Revolution SDK KPAD library\n*/\n\n\n\nCPP_WRAPPER(wii::kpad)\n\nUSING(wii::mtx::Vec2)\nUSING(wii::mtx::Vec3)\n\n#define KPAD_EXTENSION_FS 1\n\ntypedef struct\n{\n    Vec2 stickPos;\n    Vec3 acceleration;\n    f32 accelerationMagnitude;\n    f32 accelerationDif;\n} KPADFsExt;\nSIZE_ASSERT(KPADFsExt, 0x1c)\n\ntypedef struct\n{\n    u32 buttonsHeld; // all buttons down\n    u32 buttonsPressed; // buttons down this frame but not last\n    u32 buttonsReleased; // buttons released this frame\n    Vec3 acceleration;\n    f32 accelerationMagnitude;\n    f32 accelerationDif;\n    Vec2 pointingPos;\n    Vec2 pointingPosDif;\n    f32 pointingPosDifSpeed;\n    Vec2 horizontal;\n    Vec2 horizontalDif;\n    f32 horizontalDifSpeed;\n    f32 distance;\n    f32 distanceDif;\n    f32 distanceDifSpeed;\n    Vec2 verticalPos;\n    u8 extensionType;\n    s8 error;\n    s8 dpdStatus;\n    u8 dataFormat;\n    union\n    {\n        KPADFsExt fs;\n        u8 unk[0x24];\n    } extension;\n} KPADStatus;\nSIZE_ASSERT(KPADStatus, 0x84)\n\nvoid KPADSetFSStickClamp(s8 min, s8 max);\nvoid KPADSetBtnRepeat(s32 controller, f32 delay, f32 pulse);\nvoid KPADSetPosParam(s32 controller, f32 radius, f32 sensitivity);\nvoid KPADSetHoriParam(s32 controller, f32 radius, f32 sensitivity);\nvoid KPADSetDistParam(s32 controller, f32 radius, f32 sensitivity);\nvoid KPADSetAccParam(s32 controller, f32 radius, f32 sensitivity);\nUNKNOWN_FUNCTION(reset_kpad);\nvoid KPADCalibrateDPD(s32 controller);\nUNKNOWN_FUNCTION(calc_button_repeat);\nUNKNOWN_FUNCTION(calc_acc_horizon);\nUNKNOWN_FUNCTION(calc_acc_vertical);\nUNKNOWN_FUNCTION(read_kpad_acc);\nUNKNOWN_FUNCTION(select_2obj_first);\nUNKNOWN_FUNCTION(select_2obj_continue);\nUNKNOWN_FUNCTION(select_1obj_first);\nUNKNOWN_FUNCTION(select_1obj_continue);\nUNKNOWN_FUNCTION(calc_dpd_variable);\nUNKNOWN_FUNCTION(read_kpad_dpd);\nUNKNOWN_FUNCTION(clamp_stick_circle);\nUNKNOWN_FUNCTION(clamp_stick_cross);\nUNKNOWN_FUNCTION(read_kpad_stick);\ns32 KPADRead(s32 controller, KPADStatus * dest, u32 maxStatuses);\nvoid KPADInit();\nvoid KPADDisableDPD(s32 controller);\nvoid KPADEnableDPD(s32 controller);\nUNKNOWN_FUNCTION(KPADiSamplingCallback);\nUNKNOWN_FUNCTION(KPADiControlDpdCallback);\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(spm::wpadmgr)\n\nUSING(wii::mtx::Vec2)\nUSING(wii::kpad::KPADStatus)\nUSING(wii::os::OSTime)\n\n// Controller stuff used to be in system.c in TTYD & no asserts in this code so name is unnoficial\n\n#define WPAD_FLAG_ENABLE_CURSOR 2\n\n#define WPAD_STATUS_COUNT 0x10\n\ntypedef struct\n{\n/* 0x0000 */ u32 flags;\n/* 0x0004 */ u32 unknown_0x4[4];\n/* 0x0014 */ u32 unknown_0x14[4];\n/* 0x0024 */ u32 unknown_0x24[4];\n/* 0x0034 */ u32 unknown_0x34[4];\n/* 0x0044 */ bool enableRumble[4]; // index controller id, controller vibrates when true\n/* 0x0048 */ bool rumblePrev[4]; // rumble enable flags from previous frame\n/* 0x004C */ Vec2 pointingPos[4]; // wii remote pointer positions\n    // controller input states, major index controller id, minor index age (latest is 0)\n/* 0x006C */ KPADStatus statuses[4][WPAD_STATUS_COUNT];\n/* 0x216C */ s32 kpadReadRet[4]; // last return from KPADRead for each controller\n/* 0x217C */ KPADStatus pastStatuses[4][60];\n/* 0x9D3C */ u32 unknown_0x9d3c[4];\n/* 0x9D4C */ s32 unknown_0x9d4c[4];\n/* 0x9D5C */ u8 unknown_0x9d5c[0x9d60 - 0x9d5c];\n/* 0x9D60 */ OSTime unknown_0x9d60[4];\n/* 0x9D80 */ f32 unknown_0x9d80[15];\n/* 0x9DBC */ f32 unkknown_0x9dbc;\n/* 0x9DC0 */ u8 unknown_0x9dc0;\n/* 0x9DC1 */ u8 unknown_0x9dc1;\n/* 0x9DC2 */ u8 unknown_0x9dc2[0x9dc8 - 0x9dc2];\n} WpadWork;\nSIZE_ASSERT(WpadWork, 0x9dc8)\n\nDECOMP_STATIC(WpadWork wpadmgr_work)\nDECOMP_STATIC(WpadWork * wpadmgr_wp)\n\n/*\n    Returns the pointer to the WpadWork instance\n*/\nWpadWork * wpadGetWork();\n\n/*\n    Initialises data used by wpad functions and the KPAD library\n*/\nvoid wpadInit();\n\n/*\n    Stops vibration of all controllers\n*/\nvoid wpadAllRumbleOff();\n\n/*\n    Updates all controllers\n*/\nvoid wpadMain();\n\n/*\n    Enables/disables pointers updating on all controllers\n*/\nvoid wpadCursorOn();\nvoid wpadCursorOff();\n\n/*\n    Returns whether cursors are enabled\n*/\nbool wpadGetCursorStatus();\n\n/*\n    Makes a controller start/stop vibrating\n*/\nvoid wpadRumbleOn(s32 controller);\nvoid wpadRumbleOff(s32 controller);\n\n/*\n    Returns whether a controller is vibrating\n    (ignores SpmarioGlobals override)\n*/\nbool wpadGetRumbleStatus(s32 controller);\n\n/*\n    Returns a bitmask of all buttons that are down on a controller \n*/\nu32 wpadGetButtonsHeld(s32 controller);\n\n/*\n    Returns a bitmask of all buttons that have just been released/pressed on a controller\n*/\nu32 wpadGetButtonsReleased(s32 controller);\nu32 wpadGetButtonsPressed(s32 controller);\n\n/*\n    Returns a bitmask of buttons held long enough to trigger the 'repeat' flag\n*/\nu32 wpadGetButtonsHeldRepeat(s32 controller);\n\nu32 func_802376e4(s32 controller);\nvoid func_80237710(s32 controller);\nbool func_80237750();\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::base)\n\n#define FPSCR_FX     0x80000000\n#define FPSCR_FEX    0x40000000\n#define FPSCR_VX     0x20000000\n#define FPSCR_OX     0x10000000\n#define FPSCR_UX     0x8000000\n#define FPSCR_ZX     0x4000000\n#define FPSCR_XX     0x2000000\n#define FPSCR_VXSNAN 0x1000000\n#define FPSCR_VXISI  0x800000\n#define FPSCR_VXIDI  0x400000\n#define FPSCR_VXZDZ  0x200000\n#define FPSCR_VXIMZ  0x100000\n#define FPSCR_VXVC   0x80000\n#define FPSCR_FR     0x40000\n#define FPSCR_FI     0x20000\n#define FPSCR_FPRF   0x1f000\n#define FPSCR_UNK20  0x800\n#define FPSCR_VXSOFT 0x400\n#define FPSCR_VXSQRT 0x200\n#define FPSCR_VXCVI  0x100\n#define FPSCR_VE     0x80\n#define FPSCR_OE     0x40\n#define FPSCR_UE     0x20\n#define FPSCR_ZE     0x10\n#define FPSCR_XE     0x8\n#define FPSCR_NI     0x4\n#define FPSCR_RN     0x3\n\n#define MSR_POW 0x40000\n#define MSR_ILE 0x10000\n#define MSR_EE  0x8000\n#define MSR_PR  0x4000\n#define MSR_FP  0x2000\n#define MSR_ME  0x1000\n#define MSR_FE0 0x800\n#define MSR_SE  0x400\n#define MSR_BE  0x200\n#define MSR_FE1 0x100\n#define MSR_IP  0x40\n#define MSR_IR  0x20\n#define MSR_DR  0x10\n#define MSR_PM  0x4\n#define MSR_RI  0x2\n#define MSR_LE  0x1\n\nu32 PPCMfmsr();\nvoid PPCMtmsr(u32);\n\nu32 PPCMfhid0();\nvoid PPCMthid0(u32);\n\nu32 PPCMfl2cr();\nvoid PPCMtl2cr(u32);\n\nvoid PPCMtdec(u32);\n\nvoid PPCSync();\nvoid PPCHalt();\n\nvoid PPCMtmmcr0(u32);\n\nu32 PPCMfmmcr1();\n\nvoid PPCMtpmc1(u32);\n\nvoid PPCMtpmc2(u32);\n\nvoid PPCMtpmc3(u32);\n\nvoid PPCMtpmc4(u32);\n\nu32 PPCMffpscr();\nvoid PPCMtfpscr(u32);\n\nu32 PPCMfhid2();\nvoid PPCMthid2(u32);\n\nu32 PPCMfwpar();\nvoid PPCMtwpar(u32);\n\nvoid PPCDisableSpeculation();\nvoid PPCSetFpNonIEEEMode();\n\nvoid PPCMthid4(u32);\n\nCPP_WRAPPER_END()\n/*\n    Functions to handle compressed data\n*/\n\n\n\nCPP_WRAPPER(wii::cx)\n\ntypedef struct\n{\n/* 0x0 */ u32 flags;\n/* 0x4 */ u32 decompSize;\n} CXParsedHeader;\nSIZE_ASSERT(CXParsedHeader, 0x8)\n\n/*\n    Reads the header of compressed data and formats it into the struct\n*/\nCXParsedHeader CXGetCompressionHeader(const void * file);\n\n/*\n    Reads the decompressed size from the header of compressed data\n*/\nsize_t CXGetUncompressedSize(const void * file);\n\n/*\n    Decompresses lzss10 compressed data into a buffer\n*/\nvoid CXUncompressLZ(const void * file, void * dest);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::DEMOInit)\n\nextern s32 DemoUseMEMHeap;\n\nvoid DEMOInit();\nUNKNOWN_FUNCTION(DEMOSetRenderMode);\nvoid DEMOBeforeRender();\nvoid DEMODoneRender();\nUNKNOWN_FUNCTION(DEMOGetRenderModeObj);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::dsp)\n\n#define DSP_DSPMBOX_H 0\n#define DSP_DSPMBOX_L 1\n#define DSP_CPUMBOX_H 2\n#define DSP_CPUMBOX_L 3\n#define DSP_REG_0x8 4\n#define DSP_CSR 5\n#define DSP_REG_0xC 6\n#define DSP_REG_0xE 7\n#define DSP_REG_0x10 8\n#define DSP_AR_SIZE 9\n#define DSP_REG_0x14 10\n#define DSP_AR_MODE 11\n#define DSP_REG_0x18 12\n#define DSP_AR_REFRESH 13\n#define DSP_REG_0x1C 14\n#define DSP_REG_0x1E 15\n#define DSP_AR_DMA_MMADDR_H 16\n#define DSP_AR_DMA_MMADDR_L 17\n#define DSP_AR_DMA_ARADDR_H 18\n#define DSP_AR_DMA_ARADDR_L 19\n#define DSP_AR_DMA_CNT_H 20\n#define DSP_AR_DMA_CNT_L 21\n#define DSP_REG_0x2C 22\n#define DSP_REG_0x2E 23\n#define DSP_AI_DMA_START_H 24\n#define DSP_AI_DMA_START_L 25\n#define DSP_REG_0x34 26\n#define DSP_AI_DMA_CSR 27\n#define DSP_REG_0x38 28\n#define DSP_AI_DMA_BYTES_LEFT 29\n\nFIXED_ADDR(volatile u16, DSP_HW_REGS[], 0xCC005000);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::exi)\n\ntypedef struct\n{\n/* 0x00 */ u8 unknown_0x0[0x20 - 0x0];\n/* 0x20 */ s32 unknown_0x20;\n/* 0x24 */ u8 unknown_0x24[0x40 - 0x24];\n} EXIEcb;\nSIZE_ASSERT(EXIEcb, 0x40)\n\nextern EXIEcb Ecb[3];\n\nUNKNOWN_FUNCTION(SetExiInterruptMask);\ns32 EXIImm(s32 chan, void * data, s32 len, s32 mode, void * completionCb);\nUNKNOWN_FUNCTION(EXIImmEx);\nUNKNOWN_FUNCTION(EXIDma);\ns32 EXISync(s32 chan);\nUNKNOWN_FUNCTION(EXISetExiCallback);\ns32 __EXIProbe(s32 chan);\nUNKNOWN_FUNCTION(EXIAttach);\nUNKNOWN_FUNCTION(EXIDetach);\ns32 EXISelect(s32 chan, s32 dev, s32 freq);\ns32 EXIDeselect(s32 chan);\nUNKNOWN_FUNCTION(EXIInterruptHandler);\nUNKNOWN_FUNCTION(TCInterruptHandler);\nUNKNOWN_FUNCTION(EXTInterruptHandler);\nUNKNOWN_FUNCTION(EXIInit);\ns32 EXILock(s32 chan, s32 dev, void * unlockCb);\ns32 EXIUnlock(s32 chan);\nUNKNOWN_FUNCTION(UnlockedHandler);\ns32 EXIGetID(s32 chan, s32 dev, u32 * outId);\nUNKNOWN_FUNCTION(ProbeBarnacle);\nUNKNOWN_FUNCTION(__OSEnableBarnacle);\nUNKNOWN_FUNCTION(EXIWriteReg);\n\n// Re-implemented in game_lib_ext:\n// TODO: should that merge into this project?\ns32 EXIProbe(s32 chan);\n\nCPP_WRAPPER_END()\n\nCPP_WRAPPER(wii::fs)\n\ns32 ISFS_ReadDir(const char * path, char * names, u32 * nameCount);\n\n// more\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::ipc)\n\n/*\n    IOS_Open mode param\n*/\nenum IosOpenMode\n{\n/* 0x0 */ IOS_OPEN_NONE = 0,\n/* 0x1 */ IOS_OPEN_READ = 1,\n/* 0x2 */ IOS_OPEN_WRITE = 2,\n/* 0x3 */ IOS_OPEN_READ_WRITE = IOS_OPEN_READ | IOS_OPEN_WRITE\n};\n\n/*\n    IOS_Seek mode param\n*/\nenum IosSeekMode\n{\n/* 0x0 */ IOS_SEEK_START,\n/* 0x1 */ IOS_SEEK_CURRENT,\n/* 0x2 */ IOS_SEEK_END\n};\n\ntypedef struct\n{\n/* 0x0 */ void * data;\n/* 0x4 */ u32 len;\n} Ioctlv;\nSIZE_ASSERT(Ioctlv, 0x8)\n\nDECOMP_STATIC(s32 ipc_lbl_805ae3b4)\n\nUNKNOWN_FUNCTION(IPCInit);\nUNKNOWN_FUNCTION(IPCReadReg);\nUNKNOWN_FUNCTION(IPCWriteReg);\nUNKNOWN_FUNCTION(IPCGetBufferHi);\nUNKNOWN_FUNCTION(IPCGetBufferLo);\nUNKNOWN_FUNCTION(IPCSetBufferLo);\nUNKNOWN_FUNCTION(strnlen);\nUNKNOWN_FUNCTION(IpcReplyHandler);\nUNKNOWN_FUNCTION(IPCInterruptHandler);\nUNKNOWN_FUNCTION(IPCCltInit);\ns32 __ios_Ipc2(void * param_1, s32 param_2);\nUNKNOWN_FUNCTION(IOS_OpenAsync);\ns32 IOS_Open(const char * path, s32 mode);\nUNKNOWN_FUNCTION(IOS_CloseAsync);\ns32 IOS_Close(s32 fd);\nUNKNOWN_FUNCTION(IOS_ReadAsync);\ns32 IOS_Read(s32 fd, void * dest, u32 length);\nUNKNOWN_FUNCTION(IOS_WriteAsync);\nUNKNOWN_FUNCTION(IOS_Write);\nUNKNOWN_FUNCTION(IOS_SeekAsync);\nUNKNOWN_FUNCTION(IOS_IoctlAsync);\ns32 IOS_Ioctl(s32 fd, s32 command, void * buf, u32 bufSize, void * ioBuf, u32 ioBufSize);\nUNKNOWN_FUNCTION(__ios_Ioctlv);\nUNKNOWN_FUNCTION(IOS_IoctlvAsync);\ns32 IOS_Ioctlv(s32 fd, s32 command, s32 inCount, s32 outCount, Ioctlv * vecs);\nUNKNOWN_FUNCTION(IOS_IoctlvReboot);\nUNKNOWN_FUNCTION(iosCreateHeap);\nUNKNOWN_FUNCTION(__iosAlloc);\nvoid * iosAllocAligned(s32 heapId, u32 size, u32 alignment);\nUNKNOWN_FUNCTION(iosFree);\nUNKNOWN_FUNCTION(IPCiProfInit);\nUNKNOWN_FUNCTION(IPCiProfQueueReq);\nUNKNOWN_FUNCTION(IPCiProfAck);\nUNKNOWN_FUNCTION(IPCiProfReply);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::os)\n\nUSING(wii::os::OSContext)\n\n#define DI_DMA_MMADDR 5\n\nFIXED_ADDR(volatile u32, DI_HW_REGS[], 0xcd006000);\n\nFIXED_ADDR(volatile OSContext *, OS_CURRENT_FPU_CONTEXT, 0x800000d8);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::sc)\n\n#define SC_LANGUAGE_JP 0\n#define SC_LANGUAGE_EN 1\n#define SC_LANGUAGE_GE 2\n#define SC_LANGUAGE_FR 3\n#define SC_LANGUAGE_SP 4\n#define SC_LANGUAGE_IT 5\n#define SC_LANGUAGE_DU 6\n#define SC_LANGUAGE_SC 7\n#define SC_LANGUAGE_TC 8\n#define SC_LANGUAGE_KR 9\n\nUNKNOWN_FUNCTION(SCInit);\nUNKNOWN_FUNCTION(SCCheckStatus);\nUNKNOWN_FUNCTION(SCReloadConfFileAsync);\nUNKNOWN_FUNCTION(OpenCallbackFromReload);\nUNKNOWN_FUNCTION(ReadCallbackFromReload);\nUNKNOWN_FUNCTION(CloseCallbackFromReload);\nUNKNOWN_FUNCTION(FinishFromReload);\nUNKNOWN_FUNCTION(CloseCallbackFromReloadError);\nUNKNOWN_FUNCTION(ParseConfBuf);\nUNKNOWN_FUNCTION(UnpackItem);\nUNKNOWN_FUNCTION(DeleteItemByID);\nUNKNOWN_FUNCTION(CreateItemByID);\nUNKNOWN_FUNCTION(SCFindByteArrayItem);\nUNKNOWN_FUNCTION(SCReplaceByteArrayItem);\nUNKNOWN_FUNCTION(SCReplaceIntegerItem);\nUNKNOWN_FUNCTION(SCFindU8Item);\nUNKNOWN_FUNCTION(SCFindS8Item);\nUNKNOWN_FUNCTION(SCFindU32Item);\nUNKNOWN_FUNCTION(SCReplaceU8Item);\nUNKNOWN_FUNCTION(__SCFlushSyncCallback);\nUNKNOWN_FUNCTION(SCFlushAsync);\nUNKNOWN_FUNCTION(MyNandCallback);\nUNKNOWN_FUNCTION(SCGetAspectRatio);\nUNKNOWN_FUNCTION(SCGetDisplayOffsetH);\nUNKNOWN_FUNCTION(SCGetIdleMode);\nUNKNOWN_FUNCTION(SCGetLanguage);\nUNKNOWN_FUNCTION(SCGetProgressiveMode);\nUNKNOWN_FUNCTION(SCGetScreenSaverMode);\nUNKNOWN_FUNCTION(SCGetSoundMode);\nUNKNOWN_FUNCTION(SCGetCounterBias);\nUNKNOWN_FUNCTION(SCGetBtDeviceInfoArray);\nUNKNOWN_FUNCTION(SCSetBtDeviceInfoArray);\nUNKNOWN_FUNCTION(SCGetBtDpdSensibility);\nUNKNOWN_FUNCTION(SCGetWpadMotorMode);\nUNKNOWN_FUNCTION(SCSetWpadMotorMode);\nUNKNOWN_FUNCTION(SCGetWpadSensorBarPosition);\nUNKNOWN_FUNCTION(SCGetWpadSpeakerVolume);\nUNKNOWN_FUNCTION(SCSetWpadSpeakerVolume);\nUNKNOWN_FUNCTION(__SCF1);\nUNKNOWN_FUNCTION(SCGetProductArea);\n\nCPP_WRAPPER_END()\n\n\nCPP_WRAPPER(wii::vi)\n\n// OnShutdown\nUNKNOWN_FUNCTION(__VIRetraceHandler);\nUNKNOWN_FUNCTION(VISetPreRetraceCallback);\nUNKNOWN_FUNCTION(VISetPostRetraceCallback);\nUNKNOWN_FUNCTION(getTiming);\nUNKNOWN_FUNCTION(__VIInit);\nUNKNOWN_FUNCTION(VIInit);\nvoid VIWaitForRetrace();\nUNKNOWN_FUNCTION(setFbbRegs);\nUNKNOWN_FUNCTION(setVerticalRegs);\nUNKNOWN_FUNCTION(VIConfigure);\nUNKNOWN_FUNCTION(VIConfigurePan);\nvoid VIFlush();\nUNKNOWN_FUNCTION(VISetNextFrameBuffer);\nvoid VISetBlack(bool enabled);\nUNKNOWN_FUNCTION(VIGetRetraceCount);\nUNKNOWN_FUNCTION(VIGetNextField);\nUNKNOWN_FUNCTION(VIGetCurrentLine);\nUNKNOWN_FUNCTION(VIGetTvFormat);\nUNKNOWN_FUNCTION(VIGetScanMode);\nUNKNOWN_FUNCTION(VIGetDTVStatus);\nUNKNOWN_FUNCTION(__VIDisplayPositionToXY);\nUNKNOWN_FUNCTION(VISetVSyncTimingTest);\nUNKNOWN_FUNCTION(VISetTimeToDimming);\nUNKNOWN_FUNCTION(__VIResetRFIdle);\nUNKNOWN_FUNCTION(__VIResetSIIdle);\nUNKNOWN_FUNCTION(WaitMicroTime);\nUNKNOWN_FUNCTION(sendSlaveAddr);\nUNKNOWN_FUNCTION(__VISendI2CData);\nUNKNOWN_FUNCTION(__VISetYUVSEL);\nUNKNOWN_FUNCTION(__VISetFilter4EURGB60);\nUNKNOWN_FUNCTION(__VISetCGMS);\nUNKNOWN_FUNCTION(__VISetWSS);\nUNKNOWN_FUNCTION(__VISetClosedCaption);\nUNKNOWN_FUNCTION(__VISetMacrovision);\nUNKNOWN_FUNCTION(__VISetGammaImm);\nUNKNOWN_FUNCTION(__VISetGamma);\nUNKNOWN_FUNCTION(__VISetTrapFilter);\nUNKNOWN_FUNCTION(__VISetRGBOverDrive);\nUNKNOWN_FUNCTION(VISetRGBModeImm);\nUNKNOWN_FUNCTION(__VISetRGBModeImm);\nUNKNOWN_FUNCTION(__VISetRevolutionModeSimple);\n\nCPP_WRAPPER_END()\n/*\n    Revolution SDK WPAD library\n*/\n\n\n\nCPP_WRAPPER(wii::wpad)\n\n#define WPAD_BTN_NONE 0x0\n#define WPAD_BTN_LEFT 0x1\n#define WPAD_BTN_RIGHT 0x2\n#define WPAD_BTN_DOWN 0x4\n#define WPAD_BTN_UP 0x8\n#define WPAD_BTN_PLUS 0x10\n#define WPAD_BTN_2 0x100\n#define WPAD_BTN_1 0x200\n#define WPAD_BTN_B 0x400\n#define WPAD_BTN_A 0x800\n#define WPAD_BTN_MINUS 0x1000\n#define WPAD_BTN_HOME 0x8000\n#define WPAD_BTN_REPEAT 0x80000000\n\ntypedef void * (WPADAlloc)(u32 size);\ntypedef bool (WPADFree)(void * ptr);\n\nUNKNOWN_FUNCTION(noAlloc);\nUNKNOWN_FUNCTION(noFree);\n// OnShutdown\nUNKNOWN_FUNCTION(WPADiSendData);\nUNKNOWN_FUNCTION(WPADiRadioSensitivity);\nUNKNOWN_FUNCTION(IsControllerDataChanged);\nUNKNOWN_FUNCTION(CheckButtonCombination);\nUNKNOWN_FUNCTION(WPADiCheckContInputs);\nUNKNOWN_FUNCTION(WPADiManageHandler);\nUNKNOWN_FUNCTION(WPADiManageHandler0);\nUNKNOWN_FUNCTION(__ClearControlBlock);\nUNKNOWN_FUNCTION(WPADiInitSub);\nUNKNOWN_FUNCTION(WPADInit);\nUNKNOWN_FUNCTION(WPADStartSimpleSync);\nUNKNOWN_FUNCTION(WPADStopSimpleSync);\nUNKNOWN_FUNCTION(WPADSetSyncDeviceCallback);\nvoid WPADRegisterAllocator(WPADAlloc * alloc, WPADFree * free);\nUNKNOWN_FUNCTION(WPADGetStatus);\nUNKNOWN_FUNCTION(WPADGetRadioSensitivity);\nUNKNOWN_FUNCTION(WPADGetSensorBarPosition);\nUNKNOWN_FUNCTION(setupCallback);\nUNKNOWN_FUNCTION(abortConnCallback);\nUNKNOWN_FUNCTION(firmwareCheckCallback);\nUNKNOWN_FUNCTION(WPADiRetrieveChannel);\nUNKNOWN_FUNCTION(WPADiConnCallback);\nUNKNOWN_FUNCTION(WPADiRecvCallback);\nUNKNOWN_FUNCTION(WPADGetAccGravityUnit);\nUNKNOWN_FUNCTION(CloseCallback);\nUNKNOWN_FUNCTION(WPADDisconnect);\nvoid WPADSetAutoSleepTime(u8 minutes);\nUNKNOWN_FUNCTION(WPADProbe);\nUNKNOWN_FUNCTION(WPADSetSamplingCallback);\nUNKNOWN_FUNCTION(WPADSetConnectCallback);\nUNKNOWN_FUNCTION(WPADSetExtensionCallback);\nUNKNOWN_FUNCTION(WPADGetDataFormat);\nUNKNOWN_FUNCTION(WPADSetDataFormat);\nUNKNOWN_FUNCTION(__infoCallback);\nUNKNOWN_FUNCTION(WPADGetInfoAsync);\nvoid WPADControlMotor(s32 controller, u32 onOff);\nUNKNOWN_FUNCTION(WPADEnableMotor);\nbool WPADIsMotorEnabled();\nUNKNOWN_FUNCTION(WPADControlLed);\nUNKNOWN_FUNCTION(WPADSaveConfig);\nUNKNOWN_FUNCTION(WPADRead);\nUNKNOWN_FUNCTION(WPADSetAutoSamplingBuf);\nUNKNOWN_FUNCTION(WPADiExcludeButton);\nUNKNOWN_FUNCTION(WPADiCopyOut);\nUNKNOWN_FUNCTION(WPADIsSpeakerEnabled);\nUNKNOWN_FUNCTION(WPADControlSpeaker);\nUNKNOWN_FUNCTION(WPADGetSpeakerVolume);\nUNKNOWN_FUNCTION(WPADSetSpeakerVolume);\nUNKNOWN_FUNCTION(IsBusyStream);\nUNKNOWN_FUNCTION(WPADCanSendStreamData);\nUNKNOWN_FUNCTION(WPADSendStreamData);\nUNKNOWN_FUNCTION(WPADGetDpdSensitivity);\nbool WPADIsDpdEnabled(s32 controller);\nUNKNOWN_FUNCTION(__dpdCb);\nUNKNOWN_FUNCTION(WPADControlDpd);\nUNKNOWN_FUNCTION(__SendData);\nUNKNOWN_FUNCTION(WPADiSendSetReportType);\nUNKNOWN_FUNCTION(WPADiSendWriteDataCmd);\nUNKNOWN_FUNCTION(WPADiSendWriteData);\nUNKNOWN_FUNCTION(WPADiSendReadData);\nUNKNOWN_FUNCTION(WPADiClearQueue);\nUNKNOWN_FUNCTION(abortInitExtension);\nUNKNOWN_FUNCTION(getDevConfig);\nUNKNOWN_FUNCTION(getExtConfig);\nUNKNOWN_FUNCTION(getExtType);\nUNKNOWN_FUNCTION(getGameInfo);\nUNKNOWN_FUNCTION(WPADiHIDParser);\nUNKNOWN_FUNCTION(__a1_20_status_report);\nUNKNOWN_FUNCTION(__a1_21_user_data);\nUNKNOWN_FUNCTION(__a1_22_ack);\nUNKNOWN_FUNCTION(__parse_dpd_data);\nUNKNOWN_FUNCTION(__a1_30_data_type);\nUNKNOWN_FUNCTION(__a1_31_data_type);\nUNKNOWN_FUNCTION(__a1_32_data_type);\nUNKNOWN_FUNCTION(__a1_33_data_type);\nUNKNOWN_FUNCTION(__a1_34_data_type);\nUNKNOWN_FUNCTION(__a1_35_data_type);\nUNKNOWN_FUNCTION(__a1_36_data_type);\nUNKNOWN_FUNCTION(__a1_37_data_type);\nUNKNOWN_FUNCTION(__a1_3d_data_type);\nUNKNOWN_FUNCTION(__a1_3e_data_type);\nUNKNOWN_FUNCTION(__a1_3f_data_type);\nUNKNOWN_FUNCTION(__a1_unused_report);\nUNKNOWN_FUNCTION(WPADiCreateKey);\nUNKNOWN_FUNCTION(WPADiCreateKeyFor3rd);\nUNKNOWN_FUNCTION(WPADiDecode);\nUNKNOWN_FUNCTION(DEBUGPrint);\n\n\nCPP_WRAPPER_END()\n\n", "diff_flags": [], "diff_label": "__OSUnhandledException", "libraries": []}