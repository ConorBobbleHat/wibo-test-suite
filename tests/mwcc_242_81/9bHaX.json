{"compiler": "mwcc_242_81", "compiler_flags": "-O0,p -fp hard -Cpp_exceptions off -sym on -sdata2 0 -sdata 0 -inline auto -pool off", "source_code": "void fn_8005B150(void*, void*);\nvoid fn_1_740(void);\nvoid fn_1_E0(void);\ntypedef void (*VoidFunc)(void);\nextern const VoidFunc _ctors[];\nextern const VoidFunc _dtors[];\n\nvoid fn_1_0(void) {\n    fn_8005B150(&fn_1_E0, &fn_1_740);\n}\n\nint _prolog(void) {\n    const VoidFunc* ctors = _ctors;\n    while (*ctors != 0) {\n        (**ctors)();\n        ctors++;\n    }\n    fn_8005B150(&fn_1_E0, &fn_1_740);\n    return 0;\n}\n\nvoid _epilog(void) {\n    const VoidFunc* dtors = _dtors;\n    while (*dtors != 0) {\n        (**dtors)();\n        dtors++;\n    }\n}\n\nvoid fn_1_E0(void) {\n    Vec* var_r29;\n    f32 var_f30;\n    f32 var_f31;\n    s32 var_r31;\n    s32 var_r31_2;\n    w03StructUnk0* temp_r30;\n    s32 i;\n\n    lbl_1_bss_0 = (w03State*)&GWSystem.board_data;\n    lbl_1_bss_0->unk3 = 0;\n    fn_800772EC(0x770000);\n    lbl_1_data_1E0 = fn_8006D9A4(0x770001, NULL, 0);\n    fn_8006DDE8(lbl_1_data_1E0, lbl_1_rodata_10);\n    fn_8006F1A8(lbl_1_data_1E0, lbl_1_rodata_14, lbl_1_rodata_14, lbl_1_rodata_14);\n    fn_8006E2B8(lbl_1_data_1E0, 0, 0x40000001);\n    lbl_1_data_1E8 = fn_8006D9A4(0x770003, NULL, 0);\n    fn_8006DDE8(lbl_1_data_1E8, lbl_1_rodata_10);\n    fn_8006F1A8(lbl_1_data_1E8, lbl_1_rodata_14, lbl_1_rodata_14, lbl_1_rodata_14);\n    fn_8006F61C(lbl_1_data_1E8, 2);\n    lbl_1_data_1E2 = fn_8006D9A4(0x770002, NULL, 0);\n    fn_8006DDE8(lbl_1_data_1E2, lbl_1_rodata_10);\n    fn_8006F1A8(lbl_1_data_1E2, lbl_1_rodata_14, lbl_1_rodata_14, lbl_1_rodata_14);\n    fn_8006E2B8(lbl_1_data_1E2, 0, 0x40000001);\n    lbl_1_data_1E4 = fn_8006D9A4(0x77001B, &lbl_1_data_20C, 0);\n    fn_8006F1A8(lbl_1_data_1E4, lbl_1_rodata_14, lbl_1_rodata_14, lbl_1_rodata_14);\n    fn_8006E2B8(lbl_1_data_1E4, 1, 0x40000001);\n    lbl_1_data_1E6 = fn_8006D9A4(0x2000D, &lbl_1_data_214, 0);\n    fn_8006F1A8(lbl_1_data_1E6, lbl_1_rodata_14, lbl_1_rodata_14, lbl_1_rodata_14);\n    fn_8006E2B8(lbl_1_data_1E6, 1, 0x40000001);\n\n    for (i = 0; i < 0xC; i++) {\n        temp_r30 = &lbl_1_data_0[i];\n        if (temp_r30->datanum != -1) {\n            if ((i == 10) || (i == 11)) {\n                var_r29 = &lbl_1_data_214;\n            } else {\n                var_r29 = NULL;\n            }\n            lbl_1_bss_C[i]= fn_8006D9A4(temp_r30->datanum, var_r29, 0);\n            fn_8006F158(lbl_1_bss_C[i], temp_r30);\n            fn_8006F220(lbl_1_bss_C[i], &temp_r30->unk_0C);\n            fn_8006F2E8(lbl_1_bss_C[i], &temp_r30->unk_18);\n            fn_8006F50C(lbl_1_bss_C[i], 1);\n        }\n    }\n    fn_8006E2B8(lbl_1_bss_C[10], 1, 0x40000001);\n    fn_8006E2B8(lbl_1_bss_C[11], 1, 0x40000001);\n    fn_8006E2B8(lbl_1_bss_C[7], 0, 0x40000002);\n    fn_8006E2B8(lbl_1_bss_C[9], 0, 0x40000002);\n    fn_8006E2B8(lbl_1_bss_C[1], 0, 0x40000002);\n    fn_1_3058();\n    fn_1_6494();\n    fn_1_7ABC();\n    fn_1_9A7C();\n    fn_8005D10C(&fn_1_884, &fn_1_8F0);\n    fn_80073FF4(&fn_1_910);\n    fn_80073FFC(&fn_1_A74);\n    fn_80074004(&fn_1_AF8);\n    fn_80083EDC(lbl_1_data_1E4);\n    fn_800A4F6C(lbl_1_data_1E6);\n    fn_8007A83C(lbl_1_data_1E6);\n    fn_80077AAC(lbl_1_data_1E6);\n    fn_80064D84(0x0000C000);\n    fn_80064D84(0x3000);\n    fn_1_CF4();\n    fn_8006E2B8(lbl_1_bss_C[0], 0, 0x40000001);\n    if (lbl_1_bss_0->unk0 != 0) {\n        var_f30 = lbl_1_data_1EC.unk_10;\n        var_f31 = lbl_1_data_1EC.unk_14;\n        fn_1_63F4(0);\n    } else {\n        var_f30 = lbl_1_data_1EC.unk_00;\n        var_f31 = lbl_1_data_1EC.unk_04;\n        fn_1_63F4(1);\n    }\n    fn_8006E0B0(lbl_1_bss_C[0], var_f30, var_f31);\n    fn_8006E2B8(lbl_1_bss_C[2], 0, 0x40000001);\n    fn_8006E0B0(lbl_1_bss_C[2], 1, 0x64);\n    fn_1_785C();\n    if (lbl_1_bss_0->unk2 != 0) {\n        for (i = 0; i < 4; i++) {\n            if ((lbl_1_bss_0->unk2 & (1 << i)) != 0) {\n                fn_80064338(i, &fn_1_2930);\n                break;\n            }\n        }\n    }\n    fn_1_DEC();\n}\n\nvoid fn_1_740(void) {\n    s32 i;\n\n    fn_1_10B0();\n    fn_1_9A9C();\n    fn_1_7B58();\n    for (i = 0; i < 0x0C; i++) {\n        fn_8006DB90(lbl_1_bss_C[i]);\n        lbl_1_bss_C[i] = -1;        \n    }\n    if (lbl_1_data_1E6 != -1) {\n        fn_8006DB90(lbl_1_data_1E6);\n        lbl_1_data_1E6 = -1;\n    }\n    if (lbl_1_data_1E4 != -1) {\n        fn_8006DB90(lbl_1_data_1E4);\n        lbl_1_data_1E4 = -1;\n    }\n    if (lbl_1_data_1E0 != -1) {\n        fn_8006DB90(lbl_1_data_1E0);\n        lbl_1_data_1E0 = -1;\n    }\n    if (lbl_1_data_1E2 != -1) {\n        fn_8006DB90(lbl_1_data_1E2);\n        lbl_1_data_1E2 = -1;\n    }\n}\n\nextern f32 lbl_1_rodata_18;\nextern f32 lbl_1_rodata_1C;\n\nvoid fn_1_884(void) {\n    s32 var = fn_8006DBD4(lbl_1_data_1E0);\n    Hu3DModelLightInfoSet(var, 1);\n    Hu3DFogSet(lbl_1_rodata_18, lbl_1_rodata_1C, 0xE4U, 0xF0U, 0xFFU);\n}\n\nvoid fn_1_8F0(void) {\n    Hu3DFogClear();\n}\n\ns32 fn_1_910(void) {\n    u32 temp_r3;\n    s32 cur_player_index;\n    s32 unkC;\n\n    cur_player_index = GWSystem.player_curr;\n    unkC = GWPlayer[cur_player_index].unkC;\n    temp_r3 = fn_80074138(0, unkC);\n    if (temp_r3 & 0xC000) {\n        if ((fn_8006413C(cur_player_index) == 2) || ((u8) (( GWPlayer[cur_player_index].placement >> 4U) & 1))) {\n            return 0;\n        }\n        if (temp_r3 & 0x4000) {\n            if (lbl_1_bss_0->unk1 == 0) {\n                return 0;\n            }\n        }\n        else if (temp_r3 & 0x8000 && lbl_1_bss_0->unk1 != 0) {\n            return 0;\n        }\n        \n        return fn_1_309C();\n    }\n    if (temp_r3 & 0x200) {\n        if ((fn_8006413C(cur_player_index) == 2) || ((u8) ((GWPlayer[cur_player_index].placement >> 4U) & 1) != 0)) {\n            return 0;\n        }\n        return fn_1_675C();\n    }\n    return 0;\n}\n\nvoid fn_1_A74(void) {\n    s16 temp = GWPlayer[GWSystem.player_curr].unkC;\n    u32 var = fn_80074138(0, temp) & 0x600000;\n    if (var + -0x200000 == 0) {\n        fn_1_7BA8();\n        return;\n    }\n    if (var + -0x400000 == 0) {\n        fn_1_9AA0();\n    }\n}\n\nvoid fn_1_AF8(void) {\n    if ((fn_8006413C(GWSystem.player_curr) == 0) && (fn_1_12C8() != 0) && (lbl_1_bss_0->unk2 != 0)) {\n        fn_80064D84(0xC00);\n    }\n}\nvoid fn_1_B5C(s32 arg0) {\n    f32 var_f31;\n    f32 var_f30;\n    f32 var_f29;\n    f32 var_f28;\n    f32 temp;\n\n    if (arg0 != 0) {\n        var_f30 = lbl_1_data_1EC.unk_08;\n        var_f29 = lbl_1_data_1EC.unk_0C;\n        var_f31 = lbl_1_data_1EC.unk_10;\n        var_f28 = lbl_1_data_1EC.unk_14;\n        fn_1_63F4(0);\n    } else {\n        var_f30 = lbl_1_data_1EC.unk_18;\n        var_f29 = lbl_1_data_1EC.unk_1C;\n        var_f31 = lbl_1_data_1EC.unk_00;\n        var_f28 = lbl_1_data_1EC.unk_04;\n        fn_1_63F4(1);\n    }\n    fn_8006E2B8(lbl_1_bss_C[0], 0, 0);\n    fn_8006E674(lbl_1_bss_C[0], var_f30);\n    while (1) {\n        temp = fn_8006E6F8(lbl_1_bss_C[0]);\n        if (temp >= var_f29) {\n            break;\n        }\n        HuPrcVSleep();\n    }\n    fn_8006E5C4(lbl_1_bss_C[0], 0x40000001);\n    fn_8006E674(lbl_1_bss_C[0], var_f31);\n    fn_8006E0B0(lbl_1_bss_C[0], (s32) var_f31, (s32) var_f28);\n}\n\nvoid fn_1_CF4(void) {\n    s16 var;\n    s32 i, j;\n    spaceData* temp_r28;\n    spaceData* temp_r31;\n\n    for (i = 0; i < fn_800740B4(0); i++) {\n        var = i + 1;\n        temp_r31 = fn_800740C4(0, var);\n        for (j = 0; j < temp_r31->num_links; j++) {\n            if (fn_80074138(0, temp_r31->links[j]) & 0xC00) {\n                temp_r28 = fn_800740C4(0, temp_r31->links[j]);\n                if (lbl_1_bss_0->unk0 != 0) {\n                    temp_r28->flag |= 0x04000000;\n                    fn_80064D84(0xC00);\n                } else {\n                    temp_r28->flag &= ~0x04000000;\n                    fn_80064D94(0xC00);\n                }\n            }            \n        }\n    }\n}\n\nvoid fn_1_DEC(void) {\n    Vec sp20;\n    Vec sp14;\n    Vec sp8;\n    omObjData* temp_r3;\n    s32 var_r31;\n    s32 var_r31_2;\n    w03UnkStruct2* temp_r29;\n    s32 i;\n\n    temp_r3 = omAddObjEx(lbl_801D3ED4, 0x101, 0, 0, -1, &fn_1_10E4);\n    lbl_1_bss_4 = temp_r3;\n    temp_r29 = (w03UnkStruct2*)&temp_r3->work[0];\n    temp_r29->unk0 = 0;\n    lbl_1_bss_8 = 0;\n    fn_8005D530(&sp20);\n    fn_8005D628(&sp14);\n    HuAudFXListnerSetEX(&sp20, &sp14, 1200.0f, 4800.0f, 36000.0f, 0.0f, 1200.0f);\n    for (i = 0; i < 4; i++) {\n        sp8.x = lbl_1_data_22C[i].x - 3600.0f;\n        sp8.y = lbl_1_data_22C[i].y;\n        sp8.z = lbl_1_data_22C[i].z - 3600.0f;\n        if (lbl_1_bss_0->unk2 != 0) {\n            lbl_1_data_21C[i] = HuAudFXEmiterPlay(lbl_1_data_26C[i], &sp8);\n        } else {\n            lbl_1_data_21C[i] = HuAudFXEmiterPlay(lbl_1_data_25C[i], &sp8);\n        }\n    }\n\n    for (i = 0; i < 4; i++) {\n        if ((WipeStatGet() != 0) || (_CheckFlag(0x1001CU) != 0)) {\n            HuAudFXVolSet(lbl_1_data_21C[i], 0);\n        } else {\n            HuAudFXVolSet(lbl_1_data_21C[i], 0x7F);\n        }        \n    }\n\n    if (_CheckFlag(0x10010) == 0) {\n        if (lbl_1_bss_8 == 0) {\n            HuAudFXPauseAll(1);\n            lbl_1_bss_8 = 1;\n        }\n    } else if (lbl_1_bss_8 != 0) {\n        HuAudFXPauseAll(0);\n        lbl_1_bss_8 = 0;\n    }\n}\n\nvoid fn_1_10B0(void) {\n    if (lbl_1_bss_4) {\n        ((w03UnkStruct2*)&lbl_1_bss_4->work[0])->unk0 = 1;\n    }\n}\n\nvoid fn_1_10E4(omObjData* arg0) {\n    Vec sp14;\n    Vec sp8;\n    s32 i;\n    w03UnkStruct2* temp_r29;\n\n    temp_r29 = (w03UnkStruct2*)&arg0->work[0];\n    if (temp_r29->unk0 != 0 || (fn_8005B6A8() != 0)) {\n        for (i = 0; i < 4; i++) {\n            if (lbl_1_data_21C[i] != -1) {\n                HuAudFXFadeOut(lbl_1_data_21C[i], 100);\n            }            \n        }\n        HuAudFXListnerKill();\n        lbl_1_bss_4 = 0;\n        omDelObjEx(HuPrcCurrentGet(), arg0);\n        return;\n    }\n    fn_8005D628(&sp8);\n    fn_8005D578(&sp14);\n\n    for (i = 0; i < 4; i++) {\n        if ((WipeStatGet() != 0) || (_CheckFlag(0x1001C) != 0)) {\n            HuAudFXVolSet(lbl_1_data_21C[i], 0);\n        } else {\n            HuAudFXVolSet(lbl_1_data_21C[i], 0x7F);\n        }\n    }\n\n    sp14.y += 2000.0f;\n    if (_CheckFlag(0x10010) == 0) {\n        if (lbl_1_bss_8 == 0) {\n            HuAudFXPauseAll(1);\n            lbl_1_bss_8 = 1;\n        }\n    } else if (lbl_1_bss_8 != 0) {\n        HuAudFXPauseAll(0);\n        lbl_1_bss_8 = 0;\n    }\n    HuAudFXListnerUpdate(&sp14, &sp8);\n}\n\ns32 fn_1_12C8(void) {\n    fn_800688E8(0);\n    lbl_1_bss_28 = HuPrcChildCreate(&fn_1_1358, 0x2003, 0x2000, 0, lbl_801D3ED0);\n    HuPrcDestructorSet2(lbl_1_bss_28, &fn_1_152C);\n\n    while (lbl_1_bss_28) {\n        HuPrcVSleep();\n    }\n    return fn_800688E8(1);\n}\n\nvoid fn_1_1358(void) {\n    s32 cur_player_index;\n    s32 unkC;\n\n    cur_player_index = GWSystem.player_curr;\n    unkC = GWPlayer[cur_player_index].unkC;\n    lbl_1_bss_2C = 0;\n    if ((fn_80074138(0, GWPlayer[cur_player_index].unkC) & 0x2000)) {\n        lbl_1_bss_6E = 0;\n        lbl_1_bss_6C = lbl_1_bss_C[3];\n    } else {\n        lbl_1_bss_6E = 1;\n        lbl_1_bss_6C = lbl_1_bss_C[4];\n    }\n    if (fn_1_1650(cur_player_index) != 0) {\n        if (fn_1_1D1C() != 0) {\n            fn_1_1ED4(cur_player_index);\n        } else {\n            fn_1_20E0(cur_player_index);\n        }\n        if (lbl_1_bss_2C) {\n            sprintf(lbl_1_bss_44, \"%d\", lbl_1_bss_2C);\n            BoardWinCreate(0, 0x160006, -1);\n            fn_800706D0(lbl_1_bss_44, 0);\n            BoardWinWait();\n            BoardWinKill();\n            lbl_1_bss_0->unk2 = 1 << cur_player_index;\n            lbl_1_bss_0->unk0 = lbl_1_bss_2C;\n            fn_1_CF4();\n        }\n        fn_1_26E0(cur_player_index);\n        fn_800884F4(1);\n    }\n    fn_80064350(cur_player_index, &fn_1_15E8);\n    BoardWinKill();\n    HuPrcEnd();\n}", "context": "double atan(double x);\ndouble copysign(double x, double y);\ndouble cos(double x);\ndouble floor(double x);\ndouble frexp(double x, int *exp);\ndouble ldexp(double x, int exp);\ndouble modf(double x, double *intpart);\ndouble sin(double x);\ndouble tan(double x);\ndouble acos(double x);\ndouble asin(double x);\ndouble atan2(double y, double x);\ndouble fmod(double x, double y);\ndouble log(double x);\nfloat tanf(float x);\nfloat sinf(float x);\nfloat cosf(float x);\nfloat atan2f(float y, float x);\nfloat acosf(float x);\n\n#define M_PI 3.141592653589793\n\n#define __OS_INTERRUPT_DSP_AI 5\n#define MSR_EE_BIT 16\n#define SPIRTE_ATTR_BILINEAR 0x8\n#define GX_LOAD_INDX_A 0x20\n#define GX_LOAD_INDX_B 0x28\n#define GX_LOAD_INDX_C 0x30\n#define GX_LOAD_INDX_D 0x38\n#define GX_DISABLE ((GXBool)0)\n#define MMCR1_PMC4_SNOOP_RETRY 0x03000000\n#define MMCR1_PMC4_DISPATCHED 0x01000000\n#define OSUncachedToCached(ucaddr) ((void*)((u8*)(ucaddr) - (OS_BASE_UNCACHED - OS_BASE_CACHED)))\n#define OS_FONT_ENCODE_ANSI 0u\n#define QUATDotProduct PSQUATDotProduct\n#define _DOLPHIN_GXFIFO \n#define HID2_DNCERR 0x00400000\n#define _DOLPHIN_GXEXTRA \n#define OS_ERROR_SYSTEM_CALL 9\n#define FPSCR_NI 0x00000004\n#define QUATRotAxisRad C_QUATRotAxisRad\n#define EXI_STATE_BUSY (EXI_STATE_DMA | EXI_STATE_IMM)\n#define _FUNCTIONS_H_ \n#define HID0_EMCP 0x80000000\n#define FPSCR_OE 0x00000040\n#define FPSCR_OX 0x10000000\n#define CARD_RESULT_NOPERM -10\n#define HID2_DQOERR_BIT 11\n#define OS_ERROR_MACHINE_CHECK 1\n#define ARAM_DIR_ARAM_TO_MRAM 0x01\n#define OS_PROGRESSIVE_MODE_OFF 0u\n#define TRUE 1\n#define MMCR1_PMC3_L2_SNOOP_CASTOUT 0x60000000\n#define HSF_OBJ_MAP 9\n#define EXI_MEMORY_CARD_2043A 0x00000180\n#define MMCR0_PMC2_TRANSITION 0x00000003\n#define EXI_MEMORY_CARD_2043B 0x00000280\n#define __OS_EXCEPTION_THERMAL_INTERRUPT 14\n#define FPSCR_OE_BIT 25\n#define MTXTrans PSMTXTrans\n#define FPSCR_UE 0x00000020\n#define OSDiffTick(tick1,tick0) ((s32)(tick1) - (s32)(tick0))\n#define MMCR0 952\n#define MMCR1 956\n#define OS_ERROR_ISI 3\n#define FPSCR_VE 0x00000080\n#define _DOLPHIN_OSRESETSW \n#define MEMORY_DEFAULT_NUM 0x10000000\n#define FPSCR_VX 0x20000000\n#define FPSCR_VXCVI 0x00000100\n#define MTXRadToDeg(a) ((a)*57.29577951f)\n#define _GAME_HSFFORMAT_H \n#define FPSCR_VXSOFT 0x00000400\n#define FPSCR_XE 0x00000008\n#define FPSCR_XX 0x02000000\n#define _DOLPHIN_VIFUNCS \n#define _DOLPHIN_GXTRANSFORM \n#define MMCR1_PMC3SELECT_MASK 0xF8000000\n#define CARD_RESULT_NOCARD -3\n#define GX_MAX_Z24 0x00FFFFFF\n#define OS_CONTEXT_R22 88\n#define FPSCR_VXVC 0x00080000\n#define OSCachedToPhysical(caddr) ((u32)((u8*)(caddr)-OS_BASE_CACHED))\n#define FPSCR_ZE 0x00000010\n#define FPSCR_ZX 0x04000000\n#define __OSCONTEXT_PADDING 452\n#define HSF_OBJ_NONE1 7\n#define HSF_OBJ_NONE2 8\n#define DSP_TASK_FLAG_CANCEL 0x00000002\n#define OS_PROTECT_CONTROL_NONE 0x00\n#define CARD_RESULT_BUSY -1\n#define CARD_ATTR_NO_MOVE 0x10u\n#define DVD_RESULT_FATAL_ERROR -1\n#define OS_ERROR_MAX (OS_ERROR_FPE + 1)\n#define OS_CONSOLE_MINNOW 0x10000003\n#define OS_TIMER_CLOCK (OS_BUS_CLOCK / 4)\n#define PAD_MOTOR_STOP_HARD 2\n#define GX_LOAD_BP_REG 0x61\n#define OS_LANG_DUTCH 5u\n#define SPRITE_BMP_RGB5A3_DUPE 2\n#define M_PI 3.141592653589793\n#define CARD_RESULT_WRONGDEVICE -2\n#define MMCR0_THRESHOLD_MASK 0x003F0000\n#define __OS_INTERRUPT_DSP_ARAM 6\n#define VECSubtract C_VECSubtract\n#define AR_STACK_INDEX_ENTRY_SIZE sizeof(u32)\n#define VECDistance C_VECDistance\n#define MMCR1_PMC4_Bx_MISSED 0x02000000\n#define __OS_EXCEPTION_SYSTEM_RESET 0\n#define SPRITE_BMP_FMTMASK 0xF\n#define CARD_STAT_BANNER_NONE 0\n#define _DOLPHIN_GXDISPLIST \n#define FPSCR_UE_BIT 26\n#define _DOLPHIN_GXENUM \n#define MMCR0_PMC1INTCONTROL 0x00008000\n#define HID0_NAP 0x00400000\n#define __OS_INTERRUPT_MAX 32\n#define OS_ERROR_SYSTEM_INTERRUPT 13\n#define SPRITE_BMP_RGB5A3 1\n#define OS_RESET_PRIO_PAD 127\n#define HSF_TRACK_TRANSFORM 2\n#define MMCR0_DIS 0x80000000\n#define __OS_EXCEPTION_BREAKPOINT 12\n#define CARDSetIconAddress(stat,addr) ((stat)->iconAddr = (u32)(addr))\n#define MMCR1_PMC3_HOLD 0x00000000\n#define _DOLPHIN_GXFRAMEBUFFER \n#define MMCR0_PMC2_LOAD_STORE 0x0000000B\n#define PAD_CHANMAX 4\n#define OSPhysicalToCached(paddr) ((void*)((u32)(paddr) + OS_BASE_CACHED))\n#define OS_INTERRUPTMASK_DSP (OS_INTERRUPTMASK_DSP_AI | OS_INTERRUPTMASK_DSP_ARAM | OS_INTERRUPTMASK_DSP_DSP)\n#define GQR0 912\n#define GQR1 913\n#define GQR2 914\n#define GQR3 915\n#define GQR4 916\n#define GQR5 917\n#define GQR6 918\n#define GQR7 919\n#define MTXRotDeg(m,axis,deg) PSMTXRotRad(m, axis, MTXDegToRad(deg))\n#define L2CR_L2CLK_2_0 0x08000000\n#define L2CR_L2CLK_2_5 0x0A000000\n#define FPSCR_FEX_BIT 1\n#define SRR1_DMA_BIT 0x00200000\n#define L2CR_L2CS 0x00000200\n#define EXI_MEMORY_CARD_2043 0x00000080\n#define OS_INTERRUPTMASK_EXI (OS_INTERRUPTMASK_EXI_0_EXI | OS_INTERRUPTMASK_EXI_0_TC | OS_INTERRUPTMASK_EXI_0_EXT | OS_INTERRUPTMASK_EXI_1_EXI | OS_INTERRUPTMASK_EXI_1_TC | OS_INTERRUPTMASK_EXI_1_EXT | OS_INTERRUPTMASK_EXI_2_EXI | OS_INTERRUPTMASK_EXI_2_TC)\n#define MMCR0_DMR 0x08000000\n#define MMCR0_DMS 0x10000000\n#define OS_CACHED_REGION_PREFIX 0x8000\n#define L2CR_L2DF 0x00004000\n#define FPSCR_OX_BIT 3\n#define L2CR_L2DO 0x00400000\n#define FPSCR_NI_BIT 29\n#define QUATSlerp C_QUATSlerp\n#define QUATLerp C_QUATLerp\n#define MSR_PR_BIT 17\n#define QUATMakeClosest C_QUATMakeClosest\n#define _DOLPHIN_MTX \n#define OS_RESET_RESTART 0\n#define HID0_NHR 0x00010000\n#define MSR_POW 0x00040000\n#define L2CR_RAM_FLOW_THRU_BURST 0x00000000\n#define VI_MPAL 2\n#define OS_CONTEXT_FPR0 144\n#define OS_CONTEXT_FPR1 152\n#define OS_CONTEXT_FPR2 160\n#define OS_CONTEXT_FPR3 168\n#define OS_CONTEXT_FPR4 176\n#define OS_CONTEXT_FPR5 184\n#define OS_CONTEXT_FPR6 192\n#define OS_CONTEXT_FPR7 200\n#define OS_CONTEXT_FPR8 208\n#define OS_CONTEXT_FPR9 216\n#define OS_CONTEXT_R5 20\n#define __OS_INTERRUPT_MEM_3 3\n#define OS_CONTEXT_R6 24\n#define CARD_STAT_SPEED_FAST 1\n#define CARD_STAT_ANIM_MASK 0x04\n#define ASSERTMSG1(exp,msg,param1) ((void)0)\n#define ASSERTMSG2(exp,msg,param1,param2) ((void)0)\n#define ASSERTMSG3(exp,msg,param1,param2,param3) ((void)0)\n#define SI_ERROR_COLLISION 0x0004\n#define CARD_STAT_ICON_MASK 3\n#define QUATInverse PSQUATInverse\n#define HSF_TRACK_CLUSTER_WEIGHT 6\n#define __OS_CONTEXT_FRAME 768\n#define CARD_MAX_FILE 127\n#define VI_DEBUG_PAL 4\n#define R_DOLPHIN_END 203\n#define HSF_TRACK_MATERIAL 9\n#define CARD_ICON_WIDTH 32\n#define L2CR_L2IP 0x00000001\n#define SI_GC_NOMOTOR 0x20000000\n#define HID0_DLOCK 0x00001000\n#define MMCR0_PMC1_Bx_UNRESOLVED 0x000002C0\n#define OS_INTERRUPTMASK_MEM_0 OS_INTERRUPTMASK(__OS_INTERRUPT_MEM_0)\n#define OS_INTERRUPTMASK_MEM_2 OS_INTERRUPTMASK(__OS_INTERRUPT_MEM_2)\n#define OSRoundUp32B(v) (((u32)(v + 31) & ~31))\n#define OS_MESSAGE_BLOCK 1\n#define OS_RESET_TIMEOUT OSMillisecondsToTicks(1000)\n#define SI_N64_KEYBOARD (SI_TYPE_N64 | 0x00020000)\n#define PMC2_OV 0x80000000\n#define PAD_ERR_NOT_READY -2\n#define VI_EURGB60 5\n#define OS_INTERRUPTMASK_PI_ERROR OS_INTERRUPTMASK(__OS_INTERRUPT_PI_ERROR)\n#define EXI_STREAM_HANGER 0x04130000\n#define OS_LANG_FRENCH 2u\n#define OS_CONTEXT_STATE 418\n#define __DOLPHIN_H__ \n#define HID2_DCMERR 0x00200000\n#define ARQ_PRIORITY_HIGH 1\n#define HSF_TRACK_MORPH 3\n#define OS_PRIORITY_IDLE OS_PRIORITY_MAX\n#define LC_BASE_PREFIX 0xE000\n#define MMCR0_PMC1_Bx_STALL_CYCLE 0x00000300\n#define PMC1 953\n#define PMC2 954\n#define PMC3 957\n#define PMC4 958\n#define L2CR_L2PE 0x40000000\n#define MMCR0_PMC2_CYCLE 0x00000001\n#define OS_FONT_ENCODE_MAX 5u\n#define OS_INTERRUPTMASK_PI_RSW OS_INTERRUPTMASK(__OS_INTERRUPT_PI_RSW)\n#define CARD_ATTR_PUBLIC 0x04u\n#define R_DOLPHIN_SECTION 202\n#define OS_INTERRUPTMASK_PI_CP OS_INTERRUPTMASK(__OS_INTERRUPT_PI_CP)\n#define CARD_BANNER_HEIGHT 32\n#define SI_GC_STANDARD 0x01000000\n#define GX_LOAD_CP_REG 0x08\n#define OS_INTERRUPTMASK_PI_DI OS_INTERRUPTMASK(__OS_INTERRUPT_PI_DI)\n#define OS_INTERRUPTMASK_EXI_0_EXI OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_0_EXI)\n#define OS_INTERRUPTMASK_EXI_0_EXT OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_0_EXT)\n#define L2CR_L2SL 0x00008000\n#define FPSCR_ZX_BIT 5\n#define L2CR_L2TS 0x00040000\n#define _GX_TF_CTF 0x20\n#define OS_CONSOLE_EMULATOR 0x10000000\n#define HID0_ILOCK_BIT 18\n#define OS_INTERRUPTMASK_MEM_1 OS_INTERRUPTMASK(__OS_INTERRUPT_MEM_1)\n#define HSF_OBJ_MESH 2\n#define FPSCR_VE_BIT 24\n#define FPSCR_VXIDI_BIT 9\n#define _DOLPHIN_OSTHREAD \n#define MMCR0_PMC1_HOLD 0x00000000\n#define CARD_MODE_NORMAL 0\n#define VI_GCA 6\n#define OS_CONTEXT_FPR10 224\n#define OS_CONTEXT_FPR11 232\n#define OS_CONTEXT_FPR12 240\n#define OS_CONTEXT_FPR13 248\n#define OS_CONTEXT_FPR14 256\n#define OS_CONTEXT_FPR15 264\n#define OS_CONTEXT_FPR16 272\n#define OS_CONTEXT_FPR17 280\n#define OS_CONTEXT_FPR18 288\n#define MSR_ILE 0x00010000\n#define VI_DEBUG 3\n#define L2CR_RAM_PIPELINE_BURST 0x01000000\n#define HID2_PSE_BIT 2\n#define L2CR_L2WT 0x00080000\n#define OS_CONTEXT_FPR21 312\n#define OS_CONTEXT_FPR22 320\n#define OS_CONTEXT_FPR23 328\n#define OS_CONTEXT_FPR24 336\n#define OS_CONTEXT_FPR25 344\n#define OS_CONTEXT_FPR27 360\n#define OS_CONTEXT_FPR28 368\n#define OS_CONTEXT_FPR29 376\n#define CARD_ICON_MAX 8\n#define MMCR1_PMC4_HOLD 0x00000000\n#define QUATMultiply PSQUATMultiply\n#define OS_CONTEXT_FPR30 384\n#define OS_CONTEXT_FPR31 392\n#define OS_BUS_CLOCK (u32)__OSBusClock\n#define QUATSubtract PSQUATSubtract\n#define HID2_DCMEE_BIT 14\n#define L2CR_L2CTR_MASK 0x000000FE\n#define UPMC1 937\n#define UPMC2 938\n#define UPMC3 941\n#define UPMC4 942\n#define OS_CONSOLE_TDEVHW1 0x20000004\n#define OS_CONSOLE_TDEVHW2 0x20000005\n#define OS_CONSOLE_TDEVHW3 0x20000006\n#define DMA_L 923\n#define IBAT0L 529\n#define DMA_U 922\n#define IBAT0U 528\n#define HID0 1008\n#define HID1 1009\n#define HID2 920\n#define PMC4_COUNTER 0x7FFFFFFF\n#define CARD_BANNER_WIDTH 96\n#define L2CR_L2CTL 0x00100000\n#define DVDRead(fileInfo,addr,length,offset) DVDReadPrio((fileInfo), (addr), (length), (offset), 2)\n#define CARD_STAT_SPEED_END 0\n#define QUATSquad C_QUATSquad\n#define IBAT1L 531\n#define IBAT1U 530\n#define VI_TVMODE(format,interlace) (((format) << 2) + (interlace))\n#define AR_CLEAR_INTERNAL_ALL 0x00\n#define OS_CONSOLE_PC_EMULATOR 0x10000001\n#define IBAT2L 533\n#define OS_INTERRUPTMASK_PI_PE (OS_INTERRUPTMASK_PI_PE_TOKEN | OS_INTERRUPTMASK_PI_PE_FINISH)\n#define IBAT2U 532\n#define OS_INTERRUPTMASK_PI_DEBUG OS_INTERRUPTMASK(__OS_INTERRUPT_PI_DEBUG)\n#define OS_CONTEXT_R10 40\n#define OS_CONTEXT_R11 44\n#define OS_CONTEXT_R12 48\n#define OS_CONTEXT_R13 52\n#define OS_CONTEXT_R14 56\n#define OS_CONTEXT_R15 60\n#define OS_CONTEXT_R16 64\n#define OS_CONTEXT_R17 68\n#define OS_CONTEXT_R18 72\n#define OS_CONTEXT_R19 76\n#define OS_PRIORITY_MAX 31\n#define IBAT3L 535\n#define IBAT3U 534\n#define EXI_MEMORY_CARD_2043C 0x00000380\n#define EXI_MEMORY_CARD_2043D 0x00000480\n#define EXI_MEMORY_CARD_2043E 0x00000580\n#define EXI_MEMORY_CARD_2043F 0x00000680\n#define EXI_MEMORY_CARD_2043G 0x00000780\n#define OS_CONTEXT_R20 80\n#define OS_CONTEXT_R21 84\n#define OS_CONTEXT_R23 92\n#define MMCR1_PMC3_BPU_LR_CR 0x88000000\n#define OS_CONTEXT_R25 100\n#define OS_CONTEXT_R26 104\n#define OS_CONTEXT_R27 108\n#define OS_CONTEXT_R28 112\n#define OS_CONTEXT_R29 116\n#define _VARIABLES_H \n#define OS_CONTEXT_R30 120\n#define OS_CONTEXT_R31 124\n#define OS_INTERRUPTMASK_PI_SI OS_INTERRUPTMASK(__OS_INTERRUPT_PI_SI)\n#define __OS_INTERRUPT_AI_AI 8\n#define __OS_INTERRUPT_EXI_0_TC 10\n#define MMCR0_THRESHOLD(n) ((n) << 16)\n#define MTX44_PTR_OFFSET 4\n#define CARD_STAT_SPEED_MASK 3\n#define nullptr NULL\n#define MMCR0_PMC2_SYSTEM 0x0000000E\n#define CARD_STAT_BANNER_C8 1\n#define OS_CONTEXT_PSF11 544\n#define OS_CONTEXT_PSF12 552\n#define OS_CONTEXT_PSF13 560\n#define OS_CONTEXT_PSF14 568\n#define OS_CONTEXT_PSF15 576\n#define OS_CONTEXT_PSF16 584\n#define OS_CONTEXT_PSF17 592\n#define FPSCR_FX_BIT 0\n#define OS_CONTEXT_PSF19 608\n#define SPRITE_BMP_A8 9\n#define OS_INTERRUPTMASK_PI_VI OS_INTERRUPTMASK(__OS_INTERRUPT_PI_VI)\n#define HID0_BCLK 0x08000000\n#define OS_CONTEXT_PSF20 616\n#define OS_CONTEXT_PSF21 624\n#define OS_CONTEXT_PSF22 632\n#define OS_CONTEXT_PSF23 640\n#define OS_CONTEXT_PSF24 648\n#define OS_CONTEXT_PSF25 656\n#define OS_CONTEXT_PSF26 664\n#define OS_CONTEXT_PSF27 672\n#define OS_CONTEXT_PSF28 680\n#define OS_CONTEXT_PSF29 688\n#define SI_ERROR_NO_RESPONSE 0x0008\n#define HSF_CURVE_STEP 0\n#define OS_CONTEXT_PSF30 696\n#define _COMMON_H_ \n#define VECMag C_VECMag\n#define _DOLPHIN_OSALARM \n#define OS_SECTIONINFO_EXEC 0x1\n#define _DOLPHIN_OSALLOC \n#define HID0_DLOCK_BIT 19\n#define SPRITE_BMP_C4 4\n#define AR_CLEAR_EXPANSION 0x02\n#define MTXTransApply PSMTXTransApply\n#define OS_CONSOLE_RETAIL3 0x00000003\n#define _DOLPHIN_GXCULL \n#define OS_CONSOLE_RETAIL4 0x00000004\n#define OS_PRIORITY_MIN 0\n#define OS_INTERRUPTMASK_AI_AI OS_INTERRUPTMASK(__OS_INTERRUPT_AI_AI)\n#define OS_CONTEXT_CTR 136\n#define EXI_STATE_SELECTED 0x04\n#define OS_EURGB60_ON 1u\n#define FPSCR_VXZDZ_BIT 10\n#define SPRITE_BMP_NUM_MASK 0x7FFF\n#define GX_MAX_VTXDESCLIST_SZ (GX_VA_MAX_ATTR + 1)\n#define MTXRotTrig PSMTXRotTrig\n#define EXI_MEMORY_CARD_251 0x00000010\n#define OS_ERROR_FLOATING_POINT 7\n#define OSTicksToCycles(ticks) (((ticks) * ((OS_CORE_CLOCK * 2) / OS_TIMER_CLOCK)) / 2)\n#define MMCR1_PMC3_Bx_TAKEN 0x40000000\n#define SI_TYPE_DOLPHIN 0x08000000u\n#define OS_LANG_GERMAN 1u\n#define _DOLPHIN_OSFASTCAST \n#define OS_INTERRUPTMASK_EXI_1_TC OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_1_TC)\n#define OS_CONTEXT_MODE 416\n#define HSF_TRACK_ATTRIBUTE 10\n#define SPRITE_ATTR_FUNC 0x10\n#define SPRITE_BMP_I4 8\n#define ASSERTMSG4(exp,msg,param1,param2,param3,param4) ((void)0)\n#define CTR 9\n#define OS_FASTCAST_U16 3\n#define OSMicrosecondsToTicks(usec) (((usec) * (OS_TIMER_CLOCK / 125000)) / 8)\n#define MTXLookAt C_MTXLookAt\n#define EXI_ETHER_VIEWER 0x04220001\n#define FPSCR_VXZDZ 0x00200000\n#define MMCR0_PMC2_HOLD 0x00000000\n#define CARD_ENCODE_SJIS 1u\n#define MMCR1_PMC4_DTLB_CYCLE 0x01800000\n#define OS_ERROR_TRACE 10\n#define SI_CHAN_BIT(chan) (SI_CHAN0_BIT >> (chan))\n#define EXI_USB_ADAPTER 0x01010000\n#define OS_LANG_ITALIAN 4u\n#define VECDotProduct C_VECDotProduct\n#define MMCR1_PMC4_COND_STORE_INT 0x02800000\n#define HSF_TRACK_CLUSTER 5\n#define HID2_DMAQL_MASK 0x0F000000\n#define DVD_STATE_NO_DISK 4\n#define HID2_DNCEE_BIT 13\n#define MMCR1_PMC4_INSTRUCTION 0x00800000\n#define MSR_FP_BIT 18\n#define SI_WIRELESS_ID 0x00c0ff00\n#define _GAME_HSFMAN_H \n#define OS_FONT_ENCODE_SJIS 1u\n#define CARD_STAT_ICON_NONE 0\n#define SI_GC_WAVEBIRD (SI_TYPE_GC | SI_GC_WIRELESS | SI_GC_STANDARD | SI_WIRELESS_STATE | SI_WIRELESS_FIX_ID)\n#define OS_ERROR_EXTERNAL_INTERRUPT 4\n#define MMCR1_PMC3_L2_D_MISS 0x38000000\n#define MSR_FE1_BIT 23\n#define HID0_DOZE 0x00800000\n#define _DOLPHIN_OSCONTEXT \n#define MTXReflect PSMTXReflect\n#define HID0_SLEEP 0x00200000\n#define MMCR0_PMC2_DISPATCHED 0x00000004\n#define HSF_CURVE_BITMAP 3\n#define CARDSetBannerFormat(stat,f) ((stat)->bannerFormat = (u8)(((stat)->bannerFormat & ~CARD_STAT_BANNER_MASK) | (f)))\n#define OS_ERROR_PERFORMACE_MONITOR 11\n#define SI_GC_WIRELESS 0x80000000\n#define OS_THREAD_ATTR_DETACH 0x0001u\n#define OS_CONTEXT_SRR0 408\n#define OS_CONTEXT_SRR1 412\n#define OS_CONTEXT_PSF10 536\n#define HID0_ECLK 0x02000000\n#define __OS_INTERRUPT_PI_PE_FINISH 19\n#define MMCR0_PMC2_RESERVED_LOAD 0x0000000A\n#define _DOLPHIN_VITYPES \n#define PAD_CHAN1_BIT 0x40000000\n#define MTXPerspective C_MTXPerspective\n#define MMCR0_PMC1_L1_MISS 0x00000280\n#define SI_WIRELESS_STATE 0x02000000\n#define OS_CONTEXT_PSF18 600\n#define HID2_WPE_BIT 1\n#define MMCR0_PMC2_Bx_OUT_OF_ORDER 0x00000010\n#define PAD_ERR_NO_CONTROLLER -1\n#define UMMCR0 936\n#define UMMCR1 940\n#define PADButtonUp(buttonLast,button) ((((buttonLast) ^ (button)) & (buttonLast)))\n#define L2CR 1017\n#define MSR_FE0 0x00000800\n#define MSR_FE1 0x00000100\n#define FPSCR_FI_BIT 14\n#define DMA_U_LEN_U_MASK 0x0000001F\n#define OS_BASE_CACHED (OS_CACHED_REGION_PREFIX << 16)\n#define MMCR1_PMC3_FPU 0x58000000\n#define __OS_INTERRUPT_EXI_2_EXI 15\n#define OS_SOUND_MODE_MONO 0u\n#define MTXLightPerspective C_MTXLightPerspective\n#define SI_GC_RECEIVER (SI_TYPE_GC | SI_GC_WIRELESS)\n#define _DOLPHIN_OSMESSAGE \n#define MMCR1_PMC3_COND_STORE 0x50000000\n#define _DOLPHIN_GXTEV \n#define ARStartDMARead(mmem,aram,len) ARStartDMA(ARAM_DIR_ARAM_TO_MRAM, mmem, aram, len)\n#define MTXIdentity PSMTXIdentity\n#define MMCR1_PMC4_L2_CASTOUT 0x01400000\n#define HID0_NOOPTI 0x00000001\n#define SI_WIRELESS_FIX_ID 0x00100000\n#define MMCR0_PMC1_EIEIO 0x00000140\n#define SPRITE_ATTR_INVERT 0x100\n#define DVD_FILEINFO_BUSY 1\n#define OS_CONTEXT_PSF1 464\n#define HID0_DBP 0x40000000\n#define GX_TRUE ((GXBool)1)\n#define MSR_SE_BIT 21\n#define HID0_DCE 0x00004000\n#define __OS_EXCEPTION_SYSTEM_CALL 9\n#define OS_INTERRUPTMASK_PI_PE_TOKEN OS_INTERRUPTMASK(__OS_INTERRUPT_PI_PE_TOKEN)\n#define HID2_DCMEE 0x00020000\n#define MMCR0_PMC1SELECT_MASK 0x00001FC0\n#define _TYPES_H_ \n#define ARStartDMAWrite(mmem,aram,len) ARStartDMA(ARAM_DIR_MRAM_TO_ARAM, mmem, aram, len)\n#define OS_EURGB60_OFF 0u\n#define IABR 1010\n#define DMA_L_FLUSH 0x00000001\n#define MTXMultVecArraySR PSMTXMultVecArraySR\n#define OSTicksToMicroseconds(ticks) (((ticks)*8) / (OS_TIMER_CLOCK / 125000))\n#define MSR_FE0_BIT 20\n#define OS_PHYSICAL_MASK 0x3FFF\n#define SPRITE_BMP_IA4 6\n#define DVD_STATE_COVER_OPEN 5\n#define PAD_SPEC_0 0\n#define PAD_SPEC_1 1\n#define PAD_SPEC_2 2\n#define PAD_SPEC_3 3\n#define PAD_SPEC_4 4\n#define PAD_SPEC_5 5\n#define L2CR_L2CLK_3_0 0x0C000000\n#define CARD_COMMENT_SIZE 64\n#define _DOLPHIN_OSRESET \n#define MMCR1_PMC4SELECT_MASK 0x07C00000\n#define CARD_STAT_BANNER_MASK 3\n#define MSR_POW_BIT 13\n#define VECCrossProduct C_VECCrossProduct\n#define PAD_BUTTON_UP 0x0008\n#define SI_GC_STEERING (SI_TYPE_GC | 0x00000000)\n#define DMA_L_LC_ADDR_MASK 0xFFFFFFE0\n#define CARDGetIconSpeed(stat,n) (((stat)->iconSpeed >> (2 * (n))) & CARD_STAT_SPEED_MASK)\n#define OS_CONTEXT_FPR19 296\n#define OS_CONSOLE_DEVELOPMENT 0x10000000\n#define F3DEX_GBI_2 1\n#define EXI_WRITE 1\n#define CARDGetIconAnim(stat) (((stat)->bannerFormat) & CARD_STAT_ANIM_MASK)\n#define OS_INTERRUPTMASK_DSP_AI OS_INTERRUPTMASK(__OS_INTERRUPT_DSP_AI)\n#define GXWGFifo (*(volatile PPCWGPipe*)GXFIFO_ADDR)\n#define _DOLPHIN_OSSERIAL \n#define DMA_L_TRIGGER 0x00000002\n#define HID2_LCE 0x10000000\n#define SPRITE_ATTR_PAUSED 0x1\n#define OS_CONSOLE_RETAIL 0x00000000\n#define GX_CMD_CALL_DL 0x40\n#define CARDSetIconFormat(stat,n,f) ((stat)->iconFormat = (u16)(((stat)->iconFormat & ~(CARD_STAT_ICON_MASK << (2 * (n)))) | ((f) << (2 * (n)))))\n#define SI_WIRELESS_IR 0x04000000\n#define MTXCopy PSMTXCopy\n#define OS_CONTEXT_PSF0 456\n#define CARD_RESULT_ENCODING -13\n#define DMA_L_LOAD 0x00000010\n#define MMCR1_PMC3_TRANSITION 0x18000000\n#define HID0_DPM 0x00100000\n#define HID2_LSQE 0x80000000\n#define HSF_OBJ_NULL1 0\n#define OS_INTERRUPTMASK_EXI_0 (OS_INTERRUPTMASK_EXI_0_EXI | OS_INTERRUPTMASK_EXI_0_TC | OS_INTERRUPTMASK_EXI_0_EXT)\n#define OS_INTERRUPTMASK_EXI_1 (OS_INTERRUPTMASK_EXI_1_EXI | OS_INTERRUPTMASK_EXI_1_TC | OS_INTERRUPTMASK_EXI_1_EXT)\n#define __OS_INTERRUPT_EXI_1_EXI 12\n#define SI_CHAN1 1\n#define M2CTX 1\n#define __OS_INTERRUPT_EXI_1_EXT 14\n#define HSF_OBJ_NULL3 6\n#define SI_GC_KEYBOARD (SI_TYPE_GC | 0x00200000)\n#define EXI_FREQ_16M 4\n#define OS_CONTEXT_PSF7 512\n#define SI_GC_CONTROLLER (SI_TYPE_GC | SI_GC_STANDARD)\n#define MTXMultVecArray PSMTXMultVecArray\n#define _DOLPHIN_GXTEXTURE \n#define CARD_RESULT_FATAL_ERROR -128\n#define _DOLPHIN_OSMODULE \n#define OS_INTERRUPTMASK_PI_HSP OS_INTERRUPTMASK(__OS_INTERRUPT_PI_HSP)\n#define OS_ERROR_PROTECTION 15\n#define OS_INTERRUPTMASK_EXI_2 (OS_INTERRUPTMASK_EXI_2_EXI | OS_INTERRUPTMASK_EXI_2_TC)\n#define OS_ERROR_DECREMENTER 8\n#define __OS_INTERRUPT_PI_HSP 26\n#define AR_CLEAR_INTERNAL_USER 0x01\n#define MMCR0_DP 0x40000000\n#define MMCR0_PMC2_L2_I_MISS 0x00000007\n#define MMCR0_DU 0x20000000\n#define PAD_ERR_NONE 0\n#define GX_FALSE ((GXBool)0)\n#define MSR_IR_BIT 26\n#define OS_INTERRUPTMASK_AI (OS_INTERRUPTMASK_AI_AI)\n#define SI_WIRELESS_CONT 0x00000000\n#define ARQ_PRIORITY_LOW 0\n#define DVD_STATE_CANCELED 10\n#define HSF_OBJ_REPLICA 1\n#define __OS_EXCEPTION_SYSTEM_INTERRUPT 13\n#define SI_CHAN3_BIT 0x10000000\n#define SI_ERROR_WRST 0x0010\n#define OS_FONT_ENCODE_UTF16 4u\n#define OS_CONTEXT_FPR20 304\n#define OS_FONT_ENCODE_UTF32 5u\n#define MTXRotAxisRad PSMTXRotAxisRad\n#define MMCR1_PMC3_Bx_SECOND 0x80000000\n#define OS_CONTEXT_PSF31 704\n#define OS_CONTEXT_FPR26 352\n#define MMCR1_PMC4_CYCLE 0x00400000\n#define PMC3_COUNTER 0x7FFFFFFF\n#define OS_CONTEXT_PSF2 472\n#define OS_CONTEXT_PSF3 480\n#define OS_CONTEXT_PSF4 488\n#define OS_CONTEXT_PSF5 496\n#define OS_CONTEXT_PSF6 504\n#define OS_CONTEXT_PSF8 520\n#define OS_CONTEXT_PSF9 528\n#define __OS_INTERRUPT_PI_ERROR 23\n#define _DOLPHIN_OSARENA \n#define HID2_WPE 0x40000000\n#define CARD_ATTR_COMPANY 0x40u\n#define VECHalfAngle C_VECHalfAngle\n#define DVD_FILEINFO_READY 0\n#define DAR 19\n#define MMCR0_INTONBITTRANS 0x00400000\n#define EXI_MODEM 0x02020000\n#define SI_MAX_COMCSR_OUTLNGTH 128\n#define SPRITE_BMP_ALLOC 0x8000\n#define __OS_EXCEPTION_DSI 2\n#define L2CR_L2DRO 0x00000100\n#define _GX_TF_ZTF 0x10\n#define MMCR0_DISCOUNT 0x02000000\n#define MSR_PM_BIT 29\n#define MMCR0_PMC2_INSTRUCTION 0x00000002\n#define HID0_SGE 0x00000080\n#define CARD_RESULT_NAMETOOLONG -12\n#define OSRoundDown32B(x) (((u32)(x)) & ~31)\n#define __OS_INTERRUPT_EXI_0_EXI 9\n#define __OS_INTERRUPT_EXI_0_EXT 11\n#define OS_RESET_HOTRESET 1\n#define OS_INTERRUPTMASK_MEM_3 OS_INTERRUPTMASK(__OS_INTERRUPT_MEM_3)\n#define DEC 22\n#define TBU 285\n#define SI_TYPE_MASK 0x18000000u\n#define MMCR0_ENINT 0x04000000\n#define _DOLPHIN_OSINTERRUPT \n#define DSISR 18\n#define DVD_STATE_MOTOR_STOPPED 7\n#define FPSCR_VXSOFT_BIT 21\n#define SRR1_L2DP_BIT 0x00100000\n#define __OS_EXCEPTION_PROGRAM 6\n#define __OS_INTERRUPT_PI_CP 17\n#define OS_INTERRUPTMASK_PI (OS_INTERRUPTMASK_PI_CP | OS_INTERRUPTMASK_PI_SI | OS_INTERRUPTMASK_PI_DI | OS_INTERRUPTMASK_PI_RSW | OS_INTERRUPTMASK_PI_ERROR | OS_INTERRUPTMASK_PI_VI | OS_INTERRUPTMASK_PI_PE_TOKEN | OS_INTERRUPTMASK_PI_PE_FINISH | OS_INTERRUPTMASK_PI_DEBUG | OS_INTERRUPTMASK_PI_HSP)\n#define EXI_MEMORY_CARD_1019A 0x00000140\n#define EXI_MEMORY_CARD_1019B 0x00000240\n#define EXI_MEMORY_CARD_1019C 0x00000340\n#define EXI_MEMORY_CARD_1019D 0x00000440\n#define EXI_MEMORY_CARD_1019G 0x00000740\n#define OS_RESETCODE_NETCONFIG 0xC0010000\n#define SPRITE_BMP_C8 3\n#define PMC3_OV 0x80000000\n#define HSF_OBJ_JOINT 4\n#define VI_3D 3\n#define SI_CHAN1_BIT 0x40000000\n#define GX_PROJECTION_SZ 7\n#define QUATNormalize PSQUATNormalize\n#define CARD_STAT_BANNER_RGB5A3 2\n#define OS_ERROR_ALIGNMENT 5\n#define CARD_RESULT_UNLOCKED 1\n#define EXI_MEMORY_CARD_1019E 0x00000540\n#define CARD_STAT_ICON_C8 1\n#define OS_INTERRUPTMASK_MEM (OS_INTERRUPTMASK_MEM_0 | OS_INTERRUPTMASK_MEM_1 | OS_INTERRUPTMASK_MEM_2 | OS_INTERRUPTMASK_MEM_3 | OS_INTERRUPTMASK_MEM_ADDRESS)\n#define EXI_MEMORY_CARD_1019F 0x00000640\n#define MSR_BE 0x00000200\n#define OS_ERROR_PROGRAM 6\n#define _DOLPHIN_GXSTRUCT \n#define GX_OPCODE_MASK 0xF8\n#define __OS_INTERRUPT_MEM_0 0\n#define OS_GQR_S8 0x0006\n#define _DOLPHIN_GXCOMMANDLIST \n#define HID2_DMAQL_SHIFT 24\n#define OS_CORE_CLOCK __OSCoreClock\n#define OS_FONT_FIXED TRUE\n#define DSP_TASK_STATE_YIELD 2\n#define ARQ_CHUNK_SIZE_DEFAULT 4096\n#define OSCachedToUncached(caddr) ((void*)((u8*)(caddr) + (OS_BASE_UNCACHED - OS_BASE_CACHED)))\n#define OS_PROTECT_CONTROL_RDWR (OS_PROTECT_CONTROL_READ | OS_PROTECT_CONTROL_WRITE)\n#define CARD_RESULT_NOFILE -4\n#define MSR_DR 0x00000010\n#define HID0_SPD 0x00000200\n#define OS_GQR_U8 0x0004\n#define MSR_EE 0x00008000\n#define MTXRotAxisDeg(m,axis,deg) PSMTXRotAxisRad(m, axis, MTXDegToRad(deg))\n#define OS_RESETCODE_SYSTEM 0x40000000\n#define OSNanosecondsToTicks(nsec) (((nsec) * (OS_TIMER_CLOCK / 125000)) / 8000)\n#define DSP_TASK_FLAG_CLEARALL 0x00000000\n#define MSR_FP 0x00002000\n#define HID0_ABE 0x00000008\n#define AT_ADDRESS \n#define MMCR0_RTCSELECT_MASK 0x01800000\n#define __OS_EXCEPTION_EXTERNAL_INTERRUPT 4\n#define _GAME_MEMORY_H \n#define MMCR0_PMC1_IC_FETCH_MISS 0x00000340\n#define _DOLPHIN_GXPERF \n#define PAD_TRIGGER_L 0x0040\n#define L2CR_RAM_PIPELINE_LATE 0x01800000\n#define CARD_RESULT_EXIST -7\n#define PAD_TRIGGER_R 0x0020\n#define MMCR1_PMC4_INTEGER 0x03400000\n#define PAD_TRIGGER_Z 0x0010\n#define HID0_IFEM 0x00000100\n#define SI_WIRELESS_CONT_MASK 0x00080000\n#define QUATCompA C_QUATCompA\n#define OS_CONTEXT_FPSCR 400\n#define __OS_INTERRUPT_PI_DEBUG 25\n#define MSR_IP 0x00000040\n#define MSR_IR 0x00000020\n#define OS_CONSOLE_RETAIL1 0x00000001\n#define VECNormalize C_VECNormalize\n#define OS_INTERRUPTMASK_DSP_DSP OS_INTERRUPTMASK(__OS_INTERRUPT_DSP_DSP)\n#define PAD_BUTTON_DOWN 0x0004\n#define PAD_CHAN1 1\n#define QUATLogN C_QUATLogN\n#define GX_DRAW_LINES 0xA8\n#define OS_CONSOLE_RETAIL2 0x00000002\n#define MMCR0_PMC2_SNOOP 0x0000000C\n#define CARD_RESULT_READY 0\n#define HID2_DNCEE 0x00040000\n#define PAD_MOTOR_RUMBLE 1\n#define MSR_LE 0x00000001\n#define MSR_ME 0x00001000\n#define WPAR 921\n#define CARD_STAT_ANIM_BOUNCE 0x04\n#define ARQ_TYPE_ARAM_TO_MRAM ARAM_DIR_ARAM_TO_MRAM\n#define EXI_MEMORY_CARD_59 0x00000004\n#define HID2_PSE 0x20000000\n#define MMCR0_PMC1_ITLB_CYCLE 0x00000180\n#define QUATAdd PSQUATAdd\n#define FPSCR_ZE_BIT 27\n#define SI_WIRELESS_LITE 0x00040000\n#define MSR_PM 0x00000004\n#define MSR_PR 0x00004000\n#define OS_RESET_PRIO_CARD 127\n#define __OS_EXCEPTION_ALIGNMENT 5\n#define L2CR_L2SIZ_512K 0x20000000\n#define DVD_RESULT_CANCELED -3\n#define MSR_RI 0x00000002\n#define SI_CHAN0_BIT 0x80000000\n#define SI_CHAN0 0\n#define GX_VAT_MASK 0x07\n#define SI_CHAN2 2\n#define SI_CHAN3 3\n#define SPRITE_BMP_CMPR 10\n#define MSR_SE 0x00000400\n#define OS_CONTEXT_GQR5 440\n#define GX_DRAW_LINE_STRIP 0xB0\n#define MSR_IP_BIT 25\n#define DABR 1013\n#define CARDGetIconFormat(stat,n) (((stat)->iconFormat >> (2 * (n))) & CARD_STAT_ICON_MASK)\n#define CARD_STAT_ANIM_LOOP 0x00\n#define _GAME_SPRITE_H \n#define PAD_BUTTON_LEFT 0x0001\n#define __OS_INTERRUPT_EXI_1_TC 13\n#define MMCR1_PMC3_INSTRUCTION 0x10000000\n#define MMCR0_PMC2_IC_MISS 0x00000005\n#define DVD_STATE_COVER_CLOSED 3\n#define OS_GQR_S16 0x0007\n#define SPRITE_MAX 384\n#define GX_DRAW_TRIANGLES 0x90\n#define R_DOLPHIN_NOP 201\n#define DSP_TASK_STATE_INIT 0\n#define SPRITE_INVALID -1\n#define SI_WIRELESS_TYPE 0x000f0000\n#define OS_LANG_ENGLISH 0u\n#define HSF_CURVE_CONST 4\n#define MMCR0_PMC1_L2_HIT 0x000001C0\n#define SIA 955\n#define L2CR_L2SIZ_256K 0x10000000\n#define OS_CONSOLE_MASK 0xf0000000\n#define USIA 939\n#define OS_RESET_SHUTDOWN 2\n#define DVDReadAsync(fileInfo,addr,length,offset,callback) DVDReadAsyncPrio((fileInfo), (addr), (length), (offset), (callback), 2)\n#define EXI_MEMORY_CARD_123 0x00000008\n#define SI_MAX_CHAN 4\n#define HID2_DQOEE_BIT 15\n#define EXI_STATE_DMA 0x01\n#define FPSCR_VXIDI 0x00400000\n#define __OS_EXCEPTION_FLOATING_POINT 7\n#define VI_PROGRESSIVE 2\n#define OS_FONT_PROPORTIONAL FALSE\n#define CARD_STAT_ICON_RGB5A3 2\n#define MMCR1_PMC3_DTLB_MISS 0x30000000\n#define GX_ENABLE ((GXBool)1)\n#define MTXAllocStack(sPtr,numMtx) (((MtxStackPtr)(sPtr))->stackBase = (MtxPtr)OSAlloc(((numMtx) * sizeof(Mtx))))\n#define HID0_EBA 0x20000000\n#define HID0_EBD 0x10000000\n#define SI_WIRELESS_ORIGIN 0x00200000\n#define DMA_L_STORE 0x00000000\n#define OS_INTERRUPTMASK_EXI_2_TC OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_2_TC)\n#define OS_MESSAGE_NOBLOCK 0\n#define MMCR0_PMC2_PR_SWITCH 0x00000009\n#define FPSCR_VXISI_BIT 8\n#define GEKKO \n#define L2CR_L2OH_0_5 0x00000000\n#define CARDGetFileNo(fileInfo) ((fileInfo)->fileNo)\n#define HID0_PAR 0x01000000\n#define FPSCR_VXSQRT_BIT 22\n#define EXI_MARLIN 0x03010000\n#define HID2_DCHERR 0x00800000\n#define MMCR1_PMC3_L1_MISS_CYCLE 0x78000000\n#define DVD_STATE_WAITING 2\n#define VI_PAL 1\n#define DVD_STATE_IGNORED 9\n#define _DOLPHIN_DSP \n#define SPRITE_BMP_RGBA8 0\n#define VI_NTSC 0\n#define OSSecondsToTicks(sec) ((sec)*OS_TIMER_CLOCK)\n#define __OS_INTERRUPT_PI_PE_TOKEN 18\n#define PAD_ERR_TRANSFER -3\n#define FPSCR_VXSQRT 0x00000200\n#define _DOLPHIN_TYPES \n#define OS_CONTEXT_STATE_EXC 0x02u\n#define __OS_EXCEPTION_MAX (__OS_EXCEPTION_THERMAL_INTERRUPT+1)\n#define CARD_RESULT_CANCELED -14\n#define _DOLPHIN_DVD \n#define FPSCR_VXIMZ 0x00100000\n#define OSMillisecondsToTicks(msec) ((msec) * (OS_TIMER_CLOCK / 1000))\n#define OS_INTERRUPTMASK_DSP_ARAM OS_INTERRUPTMASK(__OS_INTERRUPT_DSP_ARAM)\n#define PADButtonDown(buttonLast,button) ((((buttonLast) ^ (button)) & (button)))\n#define SRR0 26\n#define SRR1 27\n#define HSF_CURVE_BEZIER 2\n#define PAD_BUTTON_RIGHT 0x0002\n#define MMCR0_PMC1_IABR 0x00000240\n#define CARD_WORKAREA_SIZE (5 * 8 * 1024)\n#define MMCR0_PMC1_CYCLE 0x00000040\n#define OS_ERROR_SYSTEM_RESET 0\n#define OS_PROTECT_CHAN0 0\n#define OS_PROTECT_CHAN1 1\n#define OS_PROTECT_CHAN2 2\n#define OS_PROTECT_CHAN3 3\n#define DVD_STATE_WRONG_DISK 6\n#define NULL ((void *)0)\n#define EXI_STATE_ATTACHED 0x08\n#define OS_ERROR_DSI 2\n#define LC_BASE (LC_BASE_PREFIX << 16)\n#define OS_INTERRUPTMASK(interrupt) (0x80000000u >> (interrupt))\n#define MMCR1_PMC4_DC_MISS 0x07C00000\n#define _DOLPHIN_GXVERT \n#define FPSCR_FR_BIT 13\n#define MSR_LE_BIT 31\n#define GX_DRAW_TRIANGLE_STRIP 0x98\n#define MTXDegToRad(a) ((a)*0.01745329252f)\n#define _DOLPHIN_OSCACHE \n#define HID2_LCE_BIT 3\n#define ASSERT(exp) ((void)0)\n#define FPSCR_VXISI 0x00800000\n#define MMCR1_PMC3_DISPATCHED 0x20000000\n#define MTXOrtho C_MTXOrtho\n#define MTXLightFrustum C_MTXLightFrustum\n#define MMCR0_PMC2SELECT_MASK 0x0000003F\n#define VECSquareMag C_VECSquareMag\n#define OS_CONTEXT_STATE_FPSAVED 0x01u\n#define CARDGetBannerFormat(stat) (((stat)->bannerFormat) & CARD_STAT_BANNER_MASK)\n#define DVD_AIS_SUCCESS 0x0\n#define HSF_OBJ_NULL2 5\n#define OS_INTERRUPTMASK_MEM_ADDRESS OS_INTERRUPTMASK(__OS_INTERRUPT_MEM_ADDRESS)\n#define OS_FASTCAST_U8 2\n#define FPSCR_UX_BIT 4\n#define __OS_INTERRUPT_PI_DI 21\n#define CARDSetCommentAddress(stat,addr) ((stat)->commentAddr = (u32)(addr))\n#define SI_WIRELESS_RECEIVED 0x40000000\n#define _DOLPHIN_OSEXPANSION \n#define EXI_MEMORY_CARD_507 0x00000020\n#define OS_RESET_PRIO_ALARM 4294967295\n#define OS_PROTECT_CONTROL_READ 0x01\n#define CARD_FILENAME_MAX 32\n#define FPSCR_XX_BIT 6\n#define SPRITE_ATTR_NOPAUSE 0x20\n#define ARQ_TYPE_MRAM_TO_ARAM ARAM_DIR_MRAM_TO_ARAM\n#define MTXInvXpose PSMTXInvXpose\n#define MSR_BE_BIT 22\n#define MMCR0_PMC2_Bx_FALL_TROUGH 0x00000008\n#define MMCR0_PMC1_TRANSITION 0x000000C0\n#define OS_CONTEXT_LR 132\n#define MMCR0_RTCSELECT_47 0x01800000\n#define GQR_STORE_SCALE_MASK 0x00003F00\n#define MMCR0_RTCSELECT_51 0x01000000\n#define MMCR0_RTCSELECT_55 0x00800000\n#define HID0_ICFI 0x00000800\n#define _DOLPHIN_GXMANAGE \n#define ATTRIBUTE_ALIGN(num) __attribute__((aligned(num)))\n#define OS_SOUND_MODE_STEREO 1u\n#define MMCR0_RTCSELECT_63 0x00000000\n#define OSTicksToNanoseconds(ticks) (((ticks)*8000) / (OS_TIMER_CLOCK / 125000))\n#define HID0_ICE_BIT 16\n#define PMC2_COUNTER 0x7FFFFFFF\n#define VECScale C_VECScale\n#define MTXInverse PSMTXInverse\n#define DBAT0L 537\n#define CARD_ATTR_GLOBAL 0x20u\n#define DBAT0U 536\n#define DVD_STATE_FATAL_ERROR -1\n#define HID0_ICE 0x00008000\n#define SPRITE_GROUP_MAX 256\n#define OS_FASTCAST_S16 5\n#define __OS_INTERRUPT_MEM_1 1\n#define __OS_INTERRUPT_MEM_2 2\n#define DBAT1L 539\n#define DBAT1U 538\n#define OS_CONSOLE_DEVHW2 0x10000005\n#define OS_ERROR_BREAKPOINT 12\n#define EXI_NPDP_GDEV 0x01020000\n#define ASSERTMSG(exp,...) ((void)0)\n#define DBAT2L 541\n#define DBAT2U 540\n#define FPSCR_XE_BIT 28\n#define OS_CONSOLE_DEVHW1 0x10000004\n#define MMCR1_PMC4_TRANSITION 0x00C00000\n#define OS_CONSOLE_DEVHW3 0x10000006\n#define OS_CONSOLE_DEVHW4 0x10000007\n#define CARD_READ_SIZE 512\n#define VECReflect C_VECReflect\n#define _DOLPHIN_OSMUTEX \n#define DBAT3L 543\n#define DBAT3U 542\n#define FPSCR_VXVC_BIT 12\n#define OS_FONT_ENCODE_UTF8 3u\n#define EXI_MEMORY_CARD_1019 0x00000040\n#define SPRG0 272\n#define SPRG1 273\n#define SPRG2 274\n#define SPRG3 275\n#define FALSE 0\n#define CARD_ATTR_NO_COPY 0x08u\n#define _DOLPHIN_GXDRAW \n#define QUATExp C_QUATExp\n#define _DOLPHIN_OSERROR \n#define SI_N64_MOUSE (SI_TYPE_N64 | 0x02000000)\n#define SI_TYPE_GC SI_TYPE_DOLPHIN\n#define EAR 282\n#define OS_RESETCODE_RESTART 0x80000000\n#define PAD_CHAN3_BIT 0x10000000\n#define _DOLPHIN_OSMEMORY \n#define __OS_EXCEPTION_PERFORMACE_MONITOR 11\n#define MTXScale PSMTXScale\n#define HID2_DCHEE_BIT 12\n#define MMCR0_PMC2_IC_FETCH_MISS 0x0000000F\n#define SPRITE_ATTR_ADDITIVE 0x80\n#define OS_CONTEXT_GQR0 420\n#define OS_CONTEXT_GQR1 424\n#define OS_CONTEXT_GQR2 428\n#define OS_CONTEXT_GQR3 432\n#define OS_CONTEXT_GQR4 436\n#define OS_CONTEXT_GQR6 444\n#define OS_CONTEXT_GQR7 448\n#define _DOLPHIN_OSEXCEPTION \n#define ARQ_DMA_ALIGNMENT 32\n#define MMCR0_PMCTRIGGER 0x00002000\n#define OSTicksToMilliseconds(ticks) ((ticks) / (OS_TIMER_CLOCK / 1000))\n#define FPSCR_VXSNAN 0x01000000\n#define OS_PROTECT_CONTROL_WRITE 0x02\n#define WPAR_BNE 0x00000001\n#define DVD_STATE_RETRY 11\n#define DVD_MIN_TRANSFER_SIZE 32\n#define SI_CHAN2_BIT 0x20000000\n#define FPSCR_FEX 0x40000000\n#define __OS_INTERRUPT_PI_RSW 22\n#define LCGetBase() ((void*)LC_BASE)\n#define CARD_STAT_SPEED_SLOW 3\n#define MTX_PTR_OFFSET 3\n#define MTXScaleApply PSMTXScaleApply\n#define DMA_L_LEN_MASK 0x0000000C\n#define HID0_ILOCK 0x00002000\n#define OSUncachedToPhysical(ucaddr) ((u32)((u8*)(ucaddr)-OS_BASE_UNCACHED))\n#define OS_CONSOLE_TDEVHW4 0x20000007\n#define MTXConcatArray PSMTXConcatArray\n#define SI_ERROR_BUSY 0x0080\n#define SPRITE_LAYER_FLIPX 0x1\n#define OS_CONSOLE_ARTHUR 0x10000002\n#define MTXFreeStack(sPtr) (OSFree((void*)(((MtxStackPtr)(sPtr))->stackBase)))\n#define __OS_EXCEPTION_DECREMENTER 8\n#define DSP_TASK_STATE_RUN 1\n#define MSR_ME_BIT 19\n#define SPRITE_ATTR_LOOP 0x2\n#define OS_MODULE_VERSION 2\n#define VI_INTERLACE 0\n#define QUATScale PSQUATScale\n#define MMCR0_PMC1_INSTRUCTION 0x00000080\n#define OS_CONTEXT_CR 128\n#define _DOLPHIN_GXGET \n#define GQR_LOAD_TYPE_MASK 0x00070000\n#define EXI_FREQ_1M 0\n#define DVD_RESULT_IGNORED -2\n#define OS_INTERRUPTMASK_EXI_1_EXI OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_1_EXI)\n#define PMC1_OV 0x80000000\n#define EXI_FREQ_2M 1\n#define OSAlloc(size) OSAllocFromHeap(__OSCurrHeap, (size))\n#define PAD_CHAN2_BIT 0x20000000\n#define FPSCR_VX_BIT 2\n#define GXFIFO_ADDR 0xCC008000\n#define EXI_FREQ_4M 2\n#define __OS_INTERRUPT_PI_SI 20\n#define CARDSetIconSpeed(stat,n,f) ((stat)->iconSpeed = (u16)(((stat)->iconSpeed & ~(CARD_STAT_SPEED_MASK << (2 * (n)))) | ((f) << (2 * (n)))))\n#define OS_INTERRUPTMASK_EXI_1_EXT OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_1_EXT)\n#define FPSCR_UX 0x08000000\n#define OS_GQR_F32 0x0000\n#define SI_N64_CONTROLLER (SI_TYPE_N64 | 0x05000000)\n#define FPSCR_VXIMZ_BIT 11\n#define MTXLightOrtho C_MTXLightOrtho\n#define MMCR0_PMC2INTCONTROL 0x00004000\n#define SI_WIRELESS_LITE_MASK 0x000c0000\n#define EXI_FREQ_8M 3\n#define OS_LANG_SPANISH 3u\n#define _DOLPHIN_AR \n#define _COMMON_STRUCTS_H \n#define SI_TYPE_N64 0x00000000u\n#define _DOLPHIN_ARQ \n#define CARD_ICON_HEIGHT 32\n#define SPRITE_BMP_IA8 5\n#define R_DOLPHIN_MRKREF 204\n#define MMCR1_PMC4_BPU_THIRD 0x03800000\n#define SDR1 25\n#define SI_N64_MIC (SI_TYPE_N64 | 0x00010000)\n#define OS_ERROR_FPE 16\n#define EXI_STATE_IDLE 0x00\n#define SPRITE_GROUP_INVALID -1\n#define __OS_INTERRUPT_DSP_DSP 7\n#define _DOLPHIN_OSFONT \n#define HID0_BHT 0x00000004\n#define L2CR_L2CLK_1_0 0x02000000\n#define L2CR_L2CLK_1_5 0x04000000\n#define __OS_INTERRUPT_PI_VI 24\n#define WPAR_ADDR 0xFFFFFFE0\n#define THRM1 1020\n#define THRM2 1021\n#define THRM3 1022\n#define GX_DRAW_TRIANGLE_FAN 0xA0\n#define OS_CONTEXT_R0 0\n#define OS_CONTEXT_R1 4\n#define OS_CONTEXT_R2 8\n#define OS_CONTEXT_R3 12\n#define OS_CONTEXT_R4 16\n#define OS_CONTEXT_R7 28\n#define OS_CONTEXT_R8 32\n#define OS_CONTEXT_R9 36\n#define MMCR0_PMC1_EA 0x00000200\n#define CARD_RESULT_NOENT -8\n#define HID2_DQOERR 0x00100000\n#define CARD_STAT_SPEED_MIDDLE 2\n#define EXI_IS_VIEWER 0x05070000\n#define PVR 287\n#define __OS_EXCEPTION_ISI 3\n#define OS_DBINTERFACE_ADDR 0x00000040\n#define LR 8\n#define OSTicksToSeconds(ticks) ((ticks) / OS_TIMER_CLOCK)\n#define HID2_LSQE_BIT 0\n#define HSF_OBJ_ROOT 3\n#define GX_NOP 0x00\n#define L2CR_L2SIZ_1M 0x30000000\n#define SI_ERROR_OVER_RUN 0x0002\n#define OSHalt(msg) OSPanic(__FILE__, __LINE__, msg)\n#define DMA_U_ADDR_MASK 0xFFFFFFE0\n#define PMC4_OV 0x80000000\n#define _DOLPHIN_PAD \n#define SI_WIRELESS_TYPE_ID (SI_WIRELESS_TYPE | SI_WIRELESS_ID)\n#define TBL 284\n#define MTX_USE_PS \n#define SPRITE_ATTR_HIDDEN 0x4\n#define OS_SECTIONINFO_OFFSET(offset) ((offset) & ~0x1)\n#define CARD_RESULT_IOERROR -5\n#define PAD_CHAN0 0\n#define PAD_CHAN2 2\n#define PAD_CHAN3 3\n#define SPRITE_ATTR_REVERSE 0x40\n#define SI_ERROR_RDST 0x0020\n#define OS_EXCEPTION_SAVE_GPRS(context) stw r0, OS_CONTEXT_R0(context); stw r1, OS_CONTEXT_R1(context); stw r2, OS_CONTEXT_R2(context); stmw r6, OS_CONTEXT_R6(context); mfspr r0, GQR1; stw r0, OS_CONTEXT_GQR1(context); mfspr r0, GQR2; stw r0, OS_CONTEXT_GQR2(context); mfspr r0, GQR3; stw r0, OS_CONTEXT_GQR3(context); mfspr r0, GQR4; stw r0, OS_CONTEXT_GQR4(context); mfspr r0, GQR5; stw r0, OS_CONTEXT_GQR5(context); mfspr r0, GQR6; stw r0, OS_CONTEXT_GQR6(context); mfspr r0, GQR7; stw r0, OS_CONTEXT_GQR7(context);\n#define SI_MAX_COMCSR_INLNGTH 128\n#define MMCR1_PMC4_SYNC 0x02C00000\n#define OSFree(ptr) OSFreeToHeap(__OSCurrHeap, (ptr))\n#define CARD_RESULT_BROKEN -6\n#define OSPhysicalToUncached(paddr) ((void*)((u32)(paddr) + OS_BASE_UNCACHED))\n#define _DOLPHIN_AI \n#define _DOLPHIN_GXLIGHTING \n#define SPRITE_LAYER_FLIPY 0x2\n#define OS_CONSOLE_TDEV 0x20000000\n#define OS_INTERRUPTMASK_PI_PE_FINISH OS_INTERRUPTMASK(__OS_INTERRUPT_PI_PE_FINISH)\n#define HID2_DCHERR_BIT 8\n#define OS_PROGRESSIVE_MODE_ON 1u\n#define GQR_STORE_TYPE_MASK 0x00000007\n#define HID0_BTIC 0x00000020\n#define _DOLPHIN_DB \n#define CARD_MODE_FAST 1\n#define SI_GBA (SI_TYPE_N64 | 0x00040000)\n#define _DOLPHIN_GXPIXEL \n#define OS_FONT_ENCODE_VOID 0xffffu\n#define MMCR1_PMC3_PM_SWITCH 0x48000000\n#define GX_DRAW_QUADS 0x80\n#define L2CR_L2E 0x80000000\n#define L2CR_L2I 0x00200000\n#define MTXFrustum C_MTXFrustum\n#define _DOLPHIN_GXBUMP \n#define OS_CONTEXT_R24 96\n#define OS_UNCACHED_REGION_PREFIX 0xC000\n#define _DOLPHIN_GX \n#define MMCR0_PMC2_L1_CASTOUT 0x0000000D\n#define OS_RESET_PRIO_GX 127\n#define OS_GQR_U16 0x0005\n#define HID2_DQOEE 0x00010000\n#define SI_ERROR_UNDER_RUN 0x0001\n#define L2CR_L2OH_1_0 0x00010000\n#define VECSquareDistance C_VECSquareDistance\n#define DVD_RESULT_GOOD 0\n#define OS_INTERRUPTMASK_EXI_2_EXI OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_2_EXI)\n#define OSGetSectionInfo(module) ((OSSectionInfo*)(((OSModuleInfo*)(module))->sectionInfoOffset))\n#define EXI_STATE_LOCKED 0x10\n#define OS_INTERRUPTMASK_EXI_0_TC OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_0_TC)\n#define OS_RESET_PRIO_IP 111\n#define PAD_BUTTON_START 0x1000\n#define PAD_BUTTON_A 0x0100\n#define PAD_BUTTON_B 0x0200\n#define PAD_BUTTON_X 0x0400\n#define PAD_BUTTON_Y 0x0800\n#define _DOLPHIN_GXGEOMETRY \n#define DSP_TASK_FLAG_ATTACHED 0x00000001\n#define QUATMtx C_QUATMtx\n#define _LANGUAGE_C 1\n#define EXI_READ 0\n#define MTXRotRad PSMTXRotRad\n#define ARAM_DIR_MRAM_TO_ARAM 0x00\n#define HID0_DCE_BIT 17\n#define HID0_DCFA 0x00000040\n#define HID0_DCFI 0x00000400\n#define GX_LOAD_XF_REG 0x10\n#define MTXMultVecSR PSMTXMultVecSR\n#define MMCR1_PMC3_DC_MISS 0x28000000\n#define _DOLPHIN_OS \n#define QUATDivide PSQUATDivide\n#define __OS_EXCEPTION_MACHINE_CHECK 1\n#define HSF_CURVE_LINEAR 1\n#define EXI_ETHER 0x04020200\n#define DVD_STATE_END 0\n#define SPRITE_BMP_I8 7\n#define MTXRowCol(m,r,c) ((m)[(r)][(c)])\n#define GX_CMD_INVL_VC 0x48\n#define DVD_STATE_BUSY 1\n#define GQR_LOAD_SCALE_MASK 0x3F000000\n#define OS_RESETCODE_EXEC 0xC0000000\n#define __OS_INTERRUPT_EXI_2_TC 16\n#define EXI_FREQ_32M 5\n#define MMCR1_PMC3_L2_HIT 0x68000000\n#define OS_BASE_UNCACHED (OS_UNCACHED_REGION_PREFIX << 16)\n#define OS_CONTEXT_XER 140\n#define GX_DRAW_POINTS 0xB8\n#define MTXTranspose PSMTXTranspose\n#define MSR_DR_BIT 27\n#define _DOLPHIN_CARD \n#define OS_RESET_PRIO_SO 110\n#define _DOLPHIN_GEOTYPES \n#define L2CR_L2BYP 0x00002000\n#define _MIPS_SZLONG 32\n#define SI_ERROR_UNKNOWN 0x0040\n#define FPSCR_VXSNAN_BIT 7\n#define _DOLPHIN_VI \n#define CARDSetIconAnim(stat,f) ((stat)->bannerFormat = (u8)(((stat)->bannerFormat & ~CARD_STAT_ANIM_MASK) | (f)))\n#define HID2_DCMERR_BIT 10\n#define MSR_RI_BIT 30\n#define PAD_CHAN0_BIT 0x80000000\n#define XER 1\n#define _DOLPHIN_PPCARCH \n#define VECAdd C_VECAdd\n#define OS_ERROR_THERMAL_INTERRUPT 14\n#define MMCR1_PMC3_CYCLE 0x08000000\n#define PMC1_COUNTER 0x7FFFFFFF\n#define DVD_STATE_PAUSING 8\n#define PAD_BUTTON_MENU 0x1000\n#define FPSCR_FI 0x00020000\n#define __OS_INTERRUPT_MEM_ADDRESS 4\n#define MMCR0_PMC1_DISPATCHED 0x00000100\n#define HID2_DNCERR_BIT 9\n#define FPSCR_FR 0x00040000\n#define CARD_RESULT_INSSPACE -9\n#define FPSCR_FX 0x80000000\n#define FPSCR_VXCVI_BIT 23\n#define MSR_ILE_BIT 15\n#define DSP_TASK_STATE_DONE 3\n#define MTXMultVec PSMTXMultVec\n#define MTXConcat PSMTXConcat\n#define CARD_ENCODE_ANSI 0u\n#define PAD_MOTOR_STOP 0\n#define EXI_STATE_IMM 0x02\n#define HID2_DCHEE 0x00080000\n#define ICTC 1019\n#define MTXQuat PSMTXQuat\n#define __OS_EXCEPTION_TRACE 10\n#define CARD_RESULT_LIMIT -11\n#define VI_NON_INTERLACE 1\n#define OS_THREAD_STACK_MAGIC 0xDEADBABE\n#define DVDSeekAsync(fileInfo,offset,callback) DVDSeekAsyncPrio((fileInfo), (offset), (callback), 2)\n#define MMCR0_PMC2_ITLB_MISS 0x00000006\ntypedef signed char s8;\ntypedef signed short int s16;\ntypedef signed long s32;\ntypedef signed long long int s64;\ntypedef unsigned char u8;\ntypedef unsigned short int u16;\ntypedef unsigned long u32;\ntypedef unsigned long long int u64;\ntypedef volatile u8 vu8;\ntypedef volatile u16 vu16;\ntypedef volatile u32 vu32;\ntypedef volatile u64 vu64;\ntypedef volatile s8 vs8;\ntypedef volatile s16 vs16;\ntypedef volatile s32 vs32;\ntypedef volatile s64 vs64;\ntypedef float f32;\ntypedef double f64;\ntypedef volatile f32 vf32;\ntypedef volatile f64 vf64;\ntypedef int BOOL;\ntypedef struct\n{\n    u32 _pad0 :2;\n    u32 loadScale :6;\n    u32 _pad1 :5;\n    u32 loadType :3;\n    u32 _pad2 :2;\n    u32 storeScale :6;\n    u32 _pad3 :5;\n    u32 storeType :3;\n} PPC_GQR_t;\ntypedef union\n{\n    u32 val;\n    PPC_GQR_t f;\n} PPC_GQR_u;\ntypedef struct\n{\n    u32 memAddr :27;\n    u32 dmaLenU :5;\n} PPC_DMA_U_t;\ntypedef union\n{\n    u32 val;\n    PPC_DMA_U_t f;\n} PPC_DMA_U_u;\ntypedef struct\n{\n    u32 lcAddr :27;\n    u32 dmaLd :1;\n    u32 dmaLenL :2;\n    u32 dmaTrigger :1;\n    u32 dmaFlush :1;\n} PPC_DMA_L_t;\ntypedef union\n{\n    u32 val;\n    PPC_DMA_L_t f;\n} PPC_DMA_L_u;\nu32 PPCMfmsr();\nvoid PPCMtmsr(u32 newMSR);\nu32 PPCOrMsr(u32 value);\nu32 PPCMfhid0();\nvoid PPCMthid0(u32 newHID0);\nu32 PPCMfl2cr();\nvoid PPCMtl2cr(u32 newL2cr);\nvoid PPCMtdec(u32 newDec);\nvoid PPCSync();\nvoid PPCHalt();\nu32 PPCMffpscr();\nvoid PPCMtfpscr(u32 newFPSCR);\nu32 PPCMfhid2();\nvoid PPCMthid2(u32 newhid2);\nu32 PPCMfwpar();\nvoid PPCMtwpar(u32 newwpar);\nvoid PPCEnableSpeculation();\nvoid PPCDisableSpeculation();\nvoid PPCSetFpIEEEMode();\nvoid PPCSetFpNonIEEEMode();\ntypedef struct DBInterface\n{\n    u32 bPresent;\n    u32 exceptionMask;\n    void (*ExceptionDestination) ( void );\n    void *exceptionReturn;\n} DBInterface;\nextern DBInterface* __DBInterface;\nvoid DBInit(void);\nvoid DBInitComm(int* inputFlagPtr, int* mtrCallback);\nstatic void __DBExceptionDestination(void);\nvoid DBPrintf(char* format, ...);\ntypedef u8 GXBool;\ntypedef enum _GXProjectionType {\n  GX_PERSPECTIVE,\n  GX_ORTHOGRAPHIC,\n} GXProjectionType;\ntypedef enum _GXCompare {\n  GX_NEVER,\n  GX_LESS,\n  GX_EQUAL,\n  GX_LEQUAL,\n  GX_GREATER,\n  GX_NEQUAL,\n  GX_GEQUAL,\n  GX_ALWAYS,\n} GXCompare;\ntypedef enum _GXAlphaOp {\n  GX_AOP_AND,\n  GX_AOP_OR,\n  GX_AOP_XOR,\n  GX_AOP_XNOR,\n  GX_MAX_ALPHAOP,\n} GXAlphaOp;\ntypedef enum _GXZFmt16 {\n  GX_ZC_LINEAR,\n  GX_ZC_NEAR,\n  GX_ZC_MID,\n  GX_ZC_FAR,\n} GXZFmt16;\ntypedef enum _GXGamma {\n  GX_GM_1_0,\n  GX_GM_1_7,\n  GX_GM_2_2,\n} GXGamma;\ntypedef enum _GXPixelFmt {\n  GX_PF_RGB8_Z24,\n  GX_PF_RGBA6_Z24,\n  GX_PF_RGB565_Z16,\n  GX_PF_Z24,\n  GX_PF_Y8,\n  GX_PF_U8,\n  GX_PF_V8,\n  GX_PF_YUV420,\n} GXPixelFmt;\ntypedef enum _GXPrimitive {\n  GX_QUADS = 0x80,\n  GX_TRIANGLES = 0x90,\n  GX_TRIANGLESTRIP = 0x98,\n  GX_TRIANGLEFAN = 0xA0,\n  GX_LINES = 0xA8,\n  GX_LINESTRIP = 0xB0,\n  GX_POINTS = 0xB8,\n} GXPrimitive;\ntypedef enum _GXVtxFmt {\n  GX_VTXFMT0,\n  GX_VTXFMT1,\n  GX_VTXFMT2,\n  GX_VTXFMT3,\n  GX_VTXFMT4,\n  GX_VTXFMT5,\n  GX_VTXFMT6,\n  GX_VTXFMT7,\n  GX_MAX_VTXFMT,\n} GXVtxFmt;\ntypedef enum _GXAttr {\n  GX_VA_PNMTXIDX,\n  GX_VA_TEX0MTXIDX,\n  GX_VA_TEX1MTXIDX,\n  GX_VA_TEX2MTXIDX,\n  GX_VA_TEX3MTXIDX,\n  GX_VA_TEX4MTXIDX,\n  GX_VA_TEX5MTXIDX,\n  GX_VA_TEX6MTXIDX,\n  GX_VA_TEX7MTXIDX,\n  GX_VA_POS,\n  GX_VA_NRM,\n  GX_VA_CLR0,\n  GX_VA_CLR1,\n  GX_VA_TEX0,\n  GX_VA_TEX1,\n  GX_VA_TEX2,\n  GX_VA_TEX3,\n  GX_VA_TEX4,\n  GX_VA_TEX5,\n  GX_VA_TEX6,\n  GX_VA_TEX7,\n  GX_POS_MTX_ARRAY,\n  GX_NRM_MTX_ARRAY,\n  GX_TEX_MTX_ARRAY,\n  GX_LIGHT_ARRAY,\n  GX_VA_NBT,\n  GX_VA_MAX_ATTR,\n  GX_VA_NULL = 0xFF,\n} GXAttr;\ntypedef enum _GXAttrType {\n  GX_NONE,\n  GX_DIRECT,\n  GX_INDEX8,\n  GX_INDEX16,\n} GXAttrType;\ntypedef enum _GXTexFmt {\n  GX_TF_I4 = 0x0,\n  GX_TF_I8 = 0x1,\n  GX_TF_IA4 = 0x2,\n  GX_TF_IA8 = 0x3,\n  GX_TF_RGB565 = 0x4,\n  GX_TF_RGB5A3 = 0x5,\n  GX_TF_RGBA8 = 0x6,\n  GX_TF_CMPR = 0xE,\n  GX_CTF_R4 = 0x0 | 0x20,\n  GX_CTF_RA4 = 0x2 | 0x20,\n  GX_CTF_RA8 = 0x3 | 0x20,\n  GX_CTF_YUVA8 = 0x6 | 0x20,\n  GX_CTF_A8 = 0x7 | 0x20,\n  GX_CTF_R8 = 0x8 | 0x20,\n  GX_CTF_G8 = 0x9 | 0x20,\n  GX_CTF_B8 = 0xA | 0x20,\n  GX_CTF_RG8 = 0xB | 0x20,\n  GX_CTF_GB8 = 0xC | 0x20,\n  GX_TF_Z8 = 0x1 | 0x10,\n  GX_TF_Z16 = 0x3 | 0x10,\n  GX_TF_Z24X8 = 0x6 | 0x10,\n  GX_CTF_Z4 = 0x0 | 0x10 | 0x20,\n  GX_CTF_Z8M = 0x9 | 0x10 | 0x20,\n  GX_CTF_Z8L = 0xA | 0x10 | 0x20,\n  GX_CTF_Z16L = 0xC | 0x10 | 0x20,\n  GX_TF_A8 = GX_CTF_A8,\n} GXTexFmt;\ntypedef enum _GXCITexFmt {\n  GX_TF_C4 = 0x8,\n  GX_TF_C8 = 0x9,\n  GX_TF_C14X2 = 0xa,\n} GXCITexFmt;\ntypedef enum _GXTexWrapMode {\n  GX_CLAMP,\n  GX_REPEAT,\n  GX_MIRROR,\n  GX_MAX_TEXWRAPMODE,\n} GXTexWrapMode;\ntypedef enum _GXTexFilter {\n  GX_NEAR,\n  GX_LINEAR,\n  GX_NEAR_MIP_NEAR,\n  GX_LIN_MIP_NEAR,\n  GX_NEAR_MIP_LIN,\n  GX_LIN_MIP_LIN,\n} GXTexFilter;\ntypedef enum _GXAnisotropy {\n  GX_ANISO_1,\n  GX_ANISO_2,\n  GX_ANISO_4,\n  GX_MAX_ANISOTROPY,\n} GXAnisotropy;\ntypedef enum _GXTexMapID {\n  GX_TEXMAP0,\n  GX_TEXMAP1,\n  GX_TEXMAP2,\n  GX_TEXMAP3,\n  GX_TEXMAP4,\n  GX_TEXMAP5,\n  GX_TEXMAP6,\n  GX_TEXMAP7,\n  GX_MAX_TEXMAP,\n  GX_TEXMAP_NULL = 0xFF,\n  GX_TEX_DISABLE = 0x100,\n} GXTexMapID;\ntypedef enum _GXTexCoordID {\n  GX_TEXCOORD0,\n  GX_TEXCOORD1,\n  GX_TEXCOORD2,\n  GX_TEXCOORD3,\n  GX_TEXCOORD4,\n  GX_TEXCOORD5,\n  GX_TEXCOORD6,\n  GX_TEXCOORD7,\n  GX_MAX_TEXCOORD,\n  GX_TEXCOORD_NULL = 0xFF,\n} GXTexCoordID;\ntypedef enum _GXTevStageID {\n  GX_TEVSTAGE0,\n  GX_TEVSTAGE1,\n  GX_TEVSTAGE2,\n  GX_TEVSTAGE3,\n  GX_TEVSTAGE4,\n  GX_TEVSTAGE5,\n  GX_TEVSTAGE6,\n  GX_TEVSTAGE7,\n  GX_TEVSTAGE8,\n  GX_TEVSTAGE9,\n  GX_TEVSTAGE10,\n  GX_TEVSTAGE11,\n  GX_TEVSTAGE12,\n  GX_TEVSTAGE13,\n  GX_TEVSTAGE14,\n  GX_TEVSTAGE15,\n  GX_MAX_TEVSTAGE,\n} GXTevStageID;\ntypedef enum _GXTevMode {\n  GX_MODULATE,\n  GX_DECAL,\n  GX_BLEND,\n  GX_REPLACE,\n  GX_PASSCLR,\n} GXTevMode;\ntypedef enum _GXTexMtxType {\n  GX_MTX3x4,\n  GX_MTX2x4,\n} GXTexMtxType;\ntypedef enum _GXTexGenType {\n  GX_TG_MTX3x4,\n  GX_TG_MTX2x4,\n  GX_TG_BUMP0,\n  GX_TG_BUMP1,\n  GX_TG_BUMP2,\n  GX_TG_BUMP3,\n  GX_TG_BUMP4,\n  GX_TG_BUMP5,\n  GX_TG_BUMP6,\n  GX_TG_BUMP7,\n  GX_TG_SRTG,\n} GXTexGenType;\ntypedef enum _GXPosNrmMtx {\n  GX_PNMTX0 = 0,\n  GX_PNMTX1 = 3,\n  GX_PNMTX2 = 6,\n  GX_PNMTX3 = 9,\n  GX_PNMTX4 = 12,\n  GX_PNMTX5 = 15,\n  GX_PNMTX6 = 18,\n  GX_PNMTX7 = 21,\n  GX_PNMTX8 = 24,\n  GX_PNMTX9 = 27,\n} GXPosNrmMtx;\ntypedef enum _GXTexMtx {\n  GX_TEXMTX0 = 30,\n  GX_TEXMTX1 = 33,\n  GX_TEXMTX2 = 36,\n  GX_TEXMTX3 = 39,\n  GX_TEXMTX4 = 42,\n  GX_TEXMTX5 = 45,\n  GX_TEXMTX6 = 48,\n  GX_TEXMTX7 = 51,\n  GX_TEXMTX8 = 54,\n  GX_TEXMTX9 = 57,\n  GX_IDENTITY = 60,\n} GXTexMtx;\ntypedef enum _GXChannelID {\n  GX_COLOR0,\n  GX_COLOR1,\n  GX_ALPHA0,\n  GX_ALPHA1,\n  GX_COLOR0A0,\n  GX_COLOR1A1,\n  GX_COLOR_ZERO,\n  GX_ALPHA_BUMP,\n  GX_ALPHA_BUMPN,\n  GX_COLOR_NULL = 0xFF,\n} GXChannelID;\ntypedef enum _GXTexGenSrc {\n  GX_TG_POS,\n  GX_TG_NRM,\n  GX_TG_BINRM,\n  GX_TG_TANGENT,\n  GX_TG_TEX0,\n  GX_TG_TEX1,\n  GX_TG_TEX2,\n  GX_TG_TEX3,\n  GX_TG_TEX4,\n  GX_TG_TEX5,\n  GX_TG_TEX6,\n  GX_TG_TEX7,\n  GX_TG_TEXCOORD0,\n  GX_TG_TEXCOORD1,\n  GX_TG_TEXCOORD2,\n  GX_TG_TEXCOORD3,\n  GX_TG_TEXCOORD4,\n  GX_TG_TEXCOORD5,\n  GX_TG_TEXCOORD6,\n  GX_TG_COLOR0,\n  GX_TG_COLOR1,\n  GX_MAX_TEXGENSRC,\n} GXTexGenSrc;\ntypedef enum _GXBlendMode {\n  GX_BM_NONE,\n  GX_BM_BLEND,\n  GX_BM_LOGIC,\n  GX_BM_SUBTRACT,\n  GX_MAX_BLENDMODE,\n} GXBlendMode;\ntypedef enum _GXBlendFactor {\n  GX_BL_ZERO,\n  GX_BL_ONE,\n  GX_BL_SRCCLR,\n  GX_BL_INVSRCCLR,\n  GX_BL_SRCALPHA,\n  GX_BL_INVSRCALPHA,\n  GX_BL_DSTALPHA,\n  GX_BL_INVDSTALPHA,\n  GX_BL_DSTCLR = GX_BL_SRCCLR,\n  GX_BL_INVDSTCLR = GX_BL_INVSRCCLR,\n} GXBlendFactor;\ntypedef enum _GXLogicOp {\n  GX_LO_CLEAR,\n  GX_LO_AND,\n  GX_LO_REVAND,\n  GX_LO_COPY,\n  GX_LO_INVAND,\n  GX_LO_NOOP,\n  GX_LO_XOR,\n  GX_LO_OR,\n  GX_LO_NOR,\n  GX_LO_EQUIV,\n  GX_LO_INV,\n  GX_LO_REVOR,\n  GX_LO_INVCOPY,\n  GX_LO_INVOR,\n  GX_LO_NAND,\n  GX_LO_SET,\n} GXLogicOp;\ntypedef enum _GXCompCnt {\n  GX_POS_XY = 0,\n  GX_POS_XYZ = 1,\n  GX_NRM_XYZ = 0,\n  GX_NRM_NBT = 1,\n  GX_NRM_NBT3 = 2,\n  GX_CLR_RGB = 0,\n  GX_CLR_RGBA = 1,\n  GX_TEX_S = 0,\n  GX_TEX_ST = 1,\n} GXCompCnt;\ntypedef enum _GXCompType {\n  GX_U8 = 0,\n  GX_S8 = 1,\n  GX_U16 = 2,\n  GX_S16 = 3,\n  GX_F32 = 4,\n  GX_RGB565 = 0,\n  GX_RGB8 = 1,\n  GX_RGBX8 = 2,\n  GX_RGBA4 = 3,\n  GX_RGBA6 = 4,\n  GX_RGBA8 = 5,\n} GXCompType;\ntypedef enum _GXPTTexMtx {\n  GX_PTTEXMTX0 = 64,\n  GX_PTTEXMTX1 = 67,\n  GX_PTTEXMTX2 = 70,\n  GX_PTTEXMTX3 = 73,\n  GX_PTTEXMTX4 = 76,\n  GX_PTTEXMTX5 = 79,\n  GX_PTTEXMTX6 = 82,\n  GX_PTTEXMTX7 = 85,\n  GX_PTTEXMTX8 = 88,\n  GX_PTTEXMTX9 = 91,\n  GX_PTTEXMTX10 = 94,\n  GX_PTTEXMTX11 = 97,\n  GX_PTTEXMTX12 = 100,\n  GX_PTTEXMTX13 = 103,\n  GX_PTTEXMTX14 = 106,\n  GX_PTTEXMTX15 = 109,\n  GX_PTTEXMTX16 = 112,\n  GX_PTTEXMTX17 = 115,\n  GX_PTTEXMTX18 = 118,\n  GX_PTTEXMTX19 = 121,\n  GX_PTIDENTITY = 125,\n} GXPTTexMtx;\ntypedef enum _GXTevRegID {\n  GX_TEVPREV,\n  GX_TEVREG0,\n  GX_TEVREG1,\n  GX_TEVREG2,\n  GX_MAX_TEVREG,\n} GXTevRegID;\ntypedef enum _GXDiffuseFn {\n  GX_DF_NONE,\n  GX_DF_SIGN,\n  GX_DF_CLAMP,\n} GXDiffuseFn;\ntypedef enum _GXColorSrc {\n  GX_SRC_REG,\n  GX_SRC_VTX,\n} GXColorSrc;\ntypedef enum _GXAttnFn {\n  GX_AF_SPEC,\n  GX_AF_SPOT,\n  GX_AF_NONE,\n} GXAttnFn;\ntypedef enum _GXLightID {\n  GX_LIGHT0 = 0x001,\n  GX_LIGHT1 = 0x002,\n  GX_LIGHT2 = 0x004,\n  GX_LIGHT3 = 0x008,\n  GX_LIGHT4 = 0x010,\n  GX_LIGHT5 = 0x020,\n  GX_LIGHT6 = 0x040,\n  GX_LIGHT7 = 0x080,\n  GX_MAX_LIGHT = 0x100,\n  GX_LIGHT_NULL = 0,\n} GXLightID;\ntypedef enum _GXTexOffset {\n  GX_TO_ZERO,\n  GX_TO_SIXTEENTH,\n  GX_TO_EIGHTH,\n  GX_TO_FOURTH,\n  GX_TO_HALF,\n  GX_TO_ONE,\n  GX_MAX_TEXOFFSET,\n} GXTexOffset;\ntypedef enum _GXSpotFn {\n  GX_SP_OFF,\n  GX_SP_FLAT,\n  GX_SP_COS,\n  GX_SP_COS2,\n  GX_SP_SHARP,\n  GX_SP_RING1,\n  GX_SP_RING2,\n} GXSpotFn;\ntypedef enum _GXDistAttnFn {\n  GX_DA_OFF,\n  GX_DA_GENTLE,\n  GX_DA_MEDIUM,\n  GX_DA_STEEP,\n} GXDistAttnFn;\ntypedef enum _GXCullMode {\n  GX_CULL_NONE,\n  GX_CULL_FRONT,\n  GX_CULL_BACK,\n  GX_CULL_ALL,\n} GXCullMode;\ntypedef enum _GXTevSwapSel {\n  GX_TEV_SWAP0 = 0,\n  GX_TEV_SWAP1,\n  GX_TEV_SWAP2,\n  GX_TEV_SWAP3,\n  GX_MAX_TEVSWAP,\n} GXTevSwapSel;\ntypedef enum _GXTevColorChan {\n  GX_CH_RED = 0,\n  GX_CH_GREEN,\n  GX_CH_BLUE,\n  GX_CH_ALPHA,\n} GXTevColorChan;\ntypedef enum _GXFogType {\n  GX_FOG_NONE = 0,\n  GX_FOG_PERSP_LIN = 2,\n  GX_FOG_PERSP_EXP = 4,\n  GX_FOG_PERSP_EXP2 = 5,\n  GX_FOG_PERSP_REVEXP = 6,\n  GX_FOG_PERSP_REVEXP2 = 7,\n  GX_FOG_ORTHO_LIN = 10,\n  GX_FOG_ORTHO_EXP = 12,\n  GX_FOG_ORTHO_EXP2 = 13,\n  GX_FOG_ORTHO_REVEXP = 14,\n  GX_FOG_ORTHO_REVEXP2 = 15,\n  GX_FOG_LIN = GX_FOG_PERSP_LIN,\n  GX_FOG_EXP = GX_FOG_PERSP_EXP,\n  GX_FOG_EXP2 = GX_FOG_PERSP_EXP2,\n  GX_FOG_REVEXP = GX_FOG_PERSP_REVEXP,\n  GX_FOG_REVEXP2 = GX_FOG_PERSP_REVEXP2,\n} GXFogType;\ntypedef enum _GXTevColorArg {\n  GX_CC_CPREV,\n  GX_CC_APREV,\n  GX_CC_C0,\n  GX_CC_A0,\n  GX_CC_C1,\n  GX_CC_A1,\n  GX_CC_C2,\n  GX_CC_A2,\n  GX_CC_TEXC,\n  GX_CC_TEXA,\n  GX_CC_RASC,\n  GX_CC_RASA,\n  GX_CC_ONE,\n  GX_CC_HALF,\n  GX_CC_KONST,\n  GX_CC_ZERO,\n} GXTevColorArg;\ntypedef enum _GXTevAlphaArg {\n  GX_CA_APREV,\n  GX_CA_A0,\n  GX_CA_A1,\n  GX_CA_A2,\n  GX_CA_TEXA,\n  GX_CA_RASA,\n  GX_CA_KONST,\n  GX_CA_ZERO,\n} GXTevAlphaArg;\ntypedef enum _GXTevOp {\n  GX_TEV_ADD = 0,\n  GX_TEV_SUB = 1,\n  GX_TEV_COMP_R8_GT = 8,\n  GX_TEV_COMP_R8_EQ = 9,\n  GX_TEV_COMP_GR16_GT = 10,\n  GX_TEV_COMP_GR16_EQ = 11,\n  GX_TEV_COMP_BGR24_GT = 12,\n  GX_TEV_COMP_BGR24_EQ = 13,\n  GX_TEV_COMP_RGB8_GT = 14,\n  GX_TEV_COMP_RGB8_EQ = 15,\n  GX_TEV_COMP_A8_GT = GX_TEV_COMP_RGB8_GT,\n  GX_TEV_COMP_A8_EQ = GX_TEV_COMP_RGB8_EQ,\n} GXTevOp;\ntypedef enum _GXTevBias {\n  GX_TB_ZERO,\n  GX_TB_ADDHALF,\n  GX_TB_SUBHALF,\n  GX_MAX_TEVBIAS,\n} GXTevBias;\ntypedef enum _GXTevScale {\n  GX_CS_SCALE_1,\n  GX_CS_SCALE_2,\n  GX_CS_SCALE_4,\n  GX_CS_DIVIDE_2,\n  GX_MAX_TEVSCALE,\n} GXTevScale;\ntypedef enum _GXTevKColorSel {\n  GX_TEV_KCSEL_8_8 = 0x00,\n  GX_TEV_KCSEL_7_8 = 0x01,\n  GX_TEV_KCSEL_6_8 = 0x02,\n  GX_TEV_KCSEL_5_8 = 0x03,\n  GX_TEV_KCSEL_4_8 = 0x04,\n  GX_TEV_KCSEL_3_8 = 0x05,\n  GX_TEV_KCSEL_2_8 = 0x06,\n  GX_TEV_KCSEL_1_8 = 0x07,\n  GX_TEV_KCSEL_1 = GX_TEV_KCSEL_8_8,\n  GX_TEV_KCSEL_3_4 = GX_TEV_KCSEL_6_8,\n  GX_TEV_KCSEL_1_2 = GX_TEV_KCSEL_4_8,\n  GX_TEV_KCSEL_1_4 = GX_TEV_KCSEL_2_8,\n  GX_TEV_KCSEL_K0 = 0x0C,\n  GX_TEV_KCSEL_K1 = 0x0D,\n  GX_TEV_KCSEL_K2 = 0x0E,\n  GX_TEV_KCSEL_K3 = 0x0F,\n  GX_TEV_KCSEL_K0_R = 0x10,\n  GX_TEV_KCSEL_K1_R = 0x11,\n  GX_TEV_KCSEL_K2_R = 0x12,\n  GX_TEV_KCSEL_K3_R = 0x13,\n  GX_TEV_KCSEL_K0_G = 0x14,\n  GX_TEV_KCSEL_K1_G = 0x15,\n  GX_TEV_KCSEL_K2_G = 0x16,\n  GX_TEV_KCSEL_K3_G = 0x17,\n  GX_TEV_KCSEL_K0_B = 0x18,\n  GX_TEV_KCSEL_K1_B = 0x19,\n  GX_TEV_KCSEL_K2_B = 0x1A,\n  GX_TEV_KCSEL_K3_B = 0x1B,\n  GX_TEV_KCSEL_K0_A = 0x1C,\n  GX_TEV_KCSEL_K1_A = 0x1D,\n  GX_TEV_KCSEL_K2_A = 0x1E,\n  GX_TEV_KCSEL_K3_A = 0x1F,\n} GXTevKColorSel;\ntypedef enum _GXTevKAlphaSel {\n  GX_TEV_KASEL_8_8 = 0x00,\n  GX_TEV_KASEL_7_8 = 0x01,\n  GX_TEV_KASEL_6_8 = 0x02,\n  GX_TEV_KASEL_5_8 = 0x03,\n  GX_TEV_KASEL_4_8 = 0x04,\n  GX_TEV_KASEL_3_8 = 0x05,\n  GX_TEV_KASEL_2_8 = 0x06,\n  GX_TEV_KASEL_1_8 = 0x07,\n  GX_TEV_KASEL_1 = GX_TEV_KASEL_8_8,\n  GX_TEV_KASEL_3_4 = GX_TEV_KASEL_6_8,\n  GX_TEV_KASEL_1_2 = GX_TEV_KASEL_4_8,\n  GX_TEV_KASEL_1_4 = GX_TEV_KASEL_2_8,\n  GX_TEV_KASEL_K0_R = 0x10,\n  GX_TEV_KASEL_K1_R = 0x11,\n  GX_TEV_KASEL_K2_R = 0x12,\n  GX_TEV_KASEL_K3_R = 0x13,\n  GX_TEV_KASEL_K0_G = 0x14,\n  GX_TEV_KASEL_K1_G = 0x15,\n  GX_TEV_KASEL_K2_G = 0x16,\n  GX_TEV_KASEL_K3_G = 0x17,\n  GX_TEV_KASEL_K0_B = 0x18,\n  GX_TEV_KASEL_K1_B = 0x19,\n  GX_TEV_KASEL_K2_B = 0x1A,\n  GX_TEV_KASEL_K3_B = 0x1B,\n  GX_TEV_KASEL_K0_A = 0x1C,\n  GX_TEV_KASEL_K1_A = 0x1D,\n  GX_TEV_KASEL_K2_A = 0x1E,\n  GX_TEV_KASEL_K3_A = 0x1F,\n} GXTevKAlphaSel;\ntypedef enum _GXTevKColorID {\n  GX_KCOLOR0 = 0,\n  GX_KCOLOR1,\n  GX_KCOLOR2,\n  GX_KCOLOR3,\n  GX_MAX_KCOLOR,\n} GXTevKColorID;\ntypedef enum _GXZTexOp {\n  GX_ZT_DISABLE,\n  GX_ZT_ADD,\n  GX_ZT_REPLACE,\n  GX_MAX_ZTEXOP,\n} GXZTexOp;\ntypedef enum _GXIndTexFormat {\n  GX_ITF_8,\n  GX_ITF_5,\n  GX_ITF_4,\n  GX_ITF_3,\n  GX_MAX_ITFORMAT,\n} GXIndTexFormat;\ntypedef enum _GXIndTexBiasSel {\n  GX_ITB_NONE,\n  GX_ITB_S,\n  GX_ITB_T,\n  GX_ITB_ST,\n  GX_ITB_U,\n  GX_ITB_SU,\n  GX_ITB_TU,\n  GX_ITB_STU,\n  GX_MAX_ITBIAS,\n} GXIndTexBiasSel;\ntypedef enum _GXIndTexAlphaSel {\n  GX_ITBA_OFF,\n  GX_ITBA_S,\n  GX_ITBA_T,\n  GX_ITBA_U,\n  GX_MAX_ITBALPHA,\n} GXIndTexAlphaSel;\ntypedef enum _GXIndTexMtxID {\n  GX_ITM_OFF,\n  GX_ITM_0,\n  GX_ITM_1,\n  GX_ITM_2,\n  GX_ITM_S0 = 5,\n  GX_ITM_S1,\n  GX_ITM_S2,\n  GX_ITM_T0 = 9,\n  GX_ITM_T1,\n  GX_ITM_T2,\n} GXIndTexMtxID;\ntypedef enum _GXIndTexWrap {\n  GX_ITW_OFF,\n  GX_ITW_256,\n  GX_ITW_128,\n  GX_ITW_64,\n  GX_ITW_32,\n  GX_ITW_16,\n  GX_ITW_0,\n  GX_MAX_ITWRAP,\n} GXIndTexWrap;\ntypedef enum _GXIndTexStageID {\n  GX_INDTEXSTAGE0,\n  GX_INDTEXSTAGE1,\n  GX_INDTEXSTAGE2,\n  GX_INDTEXSTAGE3,\n  GX_MAX_INDTEXSTAGE,\n} GXIndTexStageID;\ntypedef enum _GXIndTexScale {\n  GX_ITS_1,\n  GX_ITS_2,\n  GX_ITS_4,\n  GX_ITS_8,\n  GX_ITS_16,\n  GX_ITS_32,\n  GX_ITS_64,\n  GX_ITS_128,\n  GX_ITS_256,\n  GX_MAX_ITSCALE,\n} GXIndTexScale;\ntypedef enum _GXClipMode {\n  GX_CLIP_ENABLE = 0,\n  GX_CLIP_DISABLE = 1,\n} GXClipMode;\ntypedef enum _GXTlut {\n  GX_TLUT0 = 0,\n  GX_TLUT1 = 1,\n  GX_TLUT2 = 2,\n  GX_TLUT3 = 3,\n  GX_TLUT4 = 4,\n  GX_TLUT5 = 5,\n  GX_TLUT6 = 6,\n  GX_TLUT7 = 7,\n  GX_TLUT8 = 8,\n  GX_TLUT9 = 9,\n  GX_TLUT10 = 10,\n  GX_TLUT11 = 11,\n  GX_TLUT12 = 12,\n  GX_TLUT13 = 13,\n  GX_TLUT14 = 14,\n  GX_TLUT15 = 15,\n  GX_BIGTLUT0 = 16,\n  GX_BIGTLUT1 = 17,\n  GX_BIGTLUT2 = 18,\n  GX_BIGTLUT3 = 19,\n} GXTlut;\ntypedef enum _GXTlutFmt {\n  GX_TL_IA8,\n  GX_TL_RGB565,\n  GX_TL_RGB5A3,\n  GX_MAX_TLUTFMT,\n} GXTlutFmt;\ntypedef enum _GXMiscToken {\n  GX_MT_NULL = 0,\n  GX_MT_XF_FLUSH = 1,\n  GX_MT_DL_SAVE_CONTEXT = 2,\n  GX_MT_ABORT_WAIT_COPYOUT = 3,\n} GXMiscToken;\ntypedef enum _GXTexCacheSize {\n  GX_TEXCACHE_32K,\n  GX_TEXCACHE_128K,\n  GX_TEXCACHE_512K,\n  GX_TEXCACHE_NONE\n} GXTexCacheSize;\ntypedef enum _GXPerf0 {\n  GX_PERF0_VERTICES,\n  GX_PERF0_CLIP_VTX,\n  GX_PERF0_CLIP_CLKS,\n  GX_PERF0_XF_WAIT_IN,\n  GX_PERF0_XF_WAIT_OUT,\n  GX_PERF0_XF_XFRM_CLKS,\n  GX_PERF0_XF_LIT_CLKS,\n  GX_PERF0_XF_BOT_CLKS,\n  GX_PERF0_XF_REGLD_CLKS,\n  GX_PERF0_XF_REGRD_CLKS,\n  GX_PERF0_CLIP_RATIO,\n  GX_PERF0_TRIANGLES,\n  GX_PERF0_TRIANGLES_CULLED,\n  GX_PERF0_TRIANGLES_PASSED,\n  GX_PERF0_TRIANGLES_SCISSORED,\n  GX_PERF0_TRIANGLES_0TEX,\n  GX_PERF0_TRIANGLES_1TEX,\n  GX_PERF0_TRIANGLES_2TEX,\n  GX_PERF0_TRIANGLES_3TEX,\n  GX_PERF0_TRIANGLES_4TEX,\n  GX_PERF0_TRIANGLES_5TEX,\n  GX_PERF0_TRIANGLES_6TEX,\n  GX_PERF0_TRIANGLES_7TEX,\n  GX_PERF0_TRIANGLES_8TEX,\n  GX_PERF0_TRIANGLES_0CLR,\n  GX_PERF0_TRIANGLES_1CLR,\n  GX_PERF0_TRIANGLES_2CLR,\n  GX_PERF0_QUAD_0CVG,\n  GX_PERF0_QUAD_NON0CVG,\n  GX_PERF0_QUAD_1CVG,\n  GX_PERF0_QUAD_2CVG,\n  GX_PERF0_QUAD_3CVG,\n  GX_PERF0_QUAD_4CVG,\n  GX_PERF0_AVG_QUAD_CNT,\n  GX_PERF0_CLOCKS,\n  GX_PERF0_NONE\n} GXPerf0;\ntypedef enum _GXPerf1 {\n  GX_PERF1_TEXELS,\n  GX_PERF1_TX_IDLE,\n  GX_PERF1_TX_REGS,\n  GX_PERF1_TX_MEMSTALL,\n  GX_PERF1_TC_CHECK1_2,\n  GX_PERF1_TC_CHECK3_4,\n  GX_PERF1_TC_CHECK5_6,\n  GX_PERF1_TC_CHECK7_8,\n  GX_PERF1_TC_MISS,\n  GX_PERF1_VC_ELEMQ_FULL,\n  GX_PERF1_VC_MISSQ_FULL,\n  GX_PERF1_VC_MEMREQ_FULL,\n  GX_PERF1_VC_STATUS7,\n  GX_PERF1_VC_MISSREP_FULL,\n  GX_PERF1_VC_STREAMBUF_LOW,\n  GX_PERF1_VC_ALL_STALLS,\n  GX_PERF1_VERTICES,\n  GX_PERF1_FIFO_REQ,\n  GX_PERF1_CALL_REQ,\n  GX_PERF1_VC_MISS_REQ,\n  GX_PERF1_CP_ALL_REQ,\n  GX_PERF1_CLOCKS,\n  GX_PERF1_NONE\n} GXPerf1;\ntypedef enum _GXVCachePerf {\n  GX_VC_POS,\n  GX_VC_NRM,\n  GX_VC_CLR0,\n  GX_VC_CLR1,\n  GX_VC_TEX0,\n  GX_VC_TEX1,\n  GX_VC_TEX2,\n  GX_VC_TEX3,\n  GX_VC_TEX4,\n  GX_VC_TEX5,\n  GX_VC_TEX6,\n  GX_VC_TEX7,\n  GX_VC_ALL = 0xf\n} GXVCachePerf;\ntypedef enum _GXFBClamp {\n  GX_CLAMP_NONE = 0,\n  GX_CLAMP_TOP = 1,\n  GX_CLAMP_BOTTOM = 2,\n} GXFBClamp;\ntypedef enum _GXCopyMode {\n  GX_COPY_PROGRESSIVE = 0,\n  GX_COPY_INTLC_EVEN = 2,\n  GX_COPY_INTLC_ODD = 3,\n} GXCopyMode;\ntypedef enum _GXAlphaReadMode {\n  GX_READ_00 = 0,\n  GX_READ_FF = 1,\n  GX_READ_NONE = 2,\n} _GXAlphaReadMode;\ntypedef enum {\n  VI_TVMODE_NTSC_INT = (((0) << 2) + (0)),\n  VI_TVMODE_NTSC_DS = (((0) << 2) + (1)),\n  VI_TVMODE_NTSC_PROG = (((0) << 2) + (2)),\n  VI_TVMODE_NTSC_3D = (((0) << 2) + (3)),\n  VI_TVMODE_PAL_INT = (((1) << 2) + (0)),\n  VI_TVMODE_PAL_DS = (((1) << 2) + (1)),\n  VI_TVMODE_MPAL_INT = (((2) << 2) + (0)),\n  VI_TVMODE_MPAL_DS = (((2) << 2) + (1)),\n  VI_TVMODE_DEBUG_INT = (((3) << 2) + (0)),\n  VI_TVMODE_DEBUG_PAL_INT = (((4) << 2) + (0)),\n  VI_TVMODE_DEBUG_PAL_DS = (((4) << 2) + (1)),\n  VI_TVMODE_EURGB60_INT = (((5) << 2) + (0)),\n  VI_TVMODE_EURGB60_DS = (((5) << 2) + (1)),\n  VI_TVMODE_GCA_INT = (((6) << 2) + (0)),\n  VI_TVMODE_GCA_DS = (((6) << 2) + (1)),\n  VI_TVMODE_GCA_PROG = (((6) << 2) + (2)),\n} VITVMode;\ntypedef enum {\n  VI_XFBMODE_SF = 0,\n  VI_XFBMODE_DF = 1,\n} VIXFBMode;\ntypedef void (*VIPositionCallback)(s16 x, s16 y);\ntypedef void (*VIRetraceCallback)(u32 retraceCount);\ntypedef struct VITimingInfo {\n  u8 equ;\n  u16 acv;\n  u16 prbOdd;\n  u16 prbEven;\n  u16 psbOdd;\n  u16 psbEven;\n  u8 bs1;\n  u8 bs2;\n  u8 bs3;\n  u8 bs4;\n  u16 be1;\n  u16 be2;\n  u16 be3;\n  u16 be4;\n  u16 numHalfLines;\n  u16 hlw;\n  u8 hsy;\n  u8 hcs;\n  u8 hce;\n  u8 hbe640;\n  u16 hbs640;\n  u8 hbeCCIR656;\n  u16 hbsCCIR656;\n} VITimingInfo;\ntypedef struct VIPositionInfo {\n  u16 dispPosX;\n  u16 dispPosY;\n  u16 dispSizeX;\n  u16 dispSizeY;\n  u16 adjDispPosX;\n  u16 adjDispPosY;\n  u16 adjDispSizeY;\n  u16 adjPanPosY;\n  u16 adjPanSizeY;\n  u16 fbSizeX;\n  u16 fbSizeY;\n  u16 panPosX;\n  u16 panPosY;\n  u16 panSizeX;\n  u16 panSizeY;\n  VIXFBMode xfbMode;\n  u32 nonInter;\n  u32 tv;\n  u8 wordPerLine;\n  u8 std;\n  u8 wpl;\n  u32 bufAddr;\n  u32 tfbb;\n  u32 bfbb;\n  u8 xof;\n  BOOL isBlack;\n  BOOL is3D;\n  u32 rbufAddr;\n  u32 rtfbb;\n  u32 rbfbb;\n  VITimingInfo* timing;\n} VIPositionInfo;\ntypedef struct _GXRenderModeObj {\n           VITVMode viTVmode;\n           u16 fbWidth;\n           u16 efbHeight;\n           u16 xfbHeight;\n           u16 viXOrigin;\n           u16 viYOrigin;\n           u16 viWidth;\n           u16 viHeight;\n           VIXFBMode xFBmode;\n           u8 field_rendering;\n  u8 aa;\n  u8 sample_pattern[12][2];\n  u8 vfilter[7];\n} GXRenderModeObj;\ntypedef struct _GXColor {\n  u8 r;\n  u8 g;\n  u8 b;\n  u8 a;\n} GXColor;\ntypedef struct _GXTexObj {\n  u32 dummy[8];\n} GXTexObj;\ntypedef struct _GXTlutObj {\n  u32 dummy[3];\n} GXTlutObj;\ntypedef struct _GXLightObj {\n  u32 dummy[16];\n} GXLightObj;\ntypedef struct _GXVtxDescList {\n  GXAttr attr;\n  GXAttrType type;\n} GXVtxDescList;\ntypedef struct _GXColorS10 {\n  s16 r;\n  s16 g;\n  s16 b;\n  s16 a;\n} GXColorS10;\ntypedef struct _GXTexRegion {\n  u32 dummy[4];\n} GXTexRegion;\ntypedef struct _GXTlutRegion {\n  u32 dummy[4];\n} GXTlutRegion;\ntypedef struct _GXVtxAttrFmtList {\n  GXAttr attr;\n  GXCompCnt cnt;\n  GXCompType type;\n  u8 frac;\n} GXVtxAttrFmtList;\nvoid GXSetTevDirect(GXTevStageID tev_stage);\nvoid GXSetNumIndStages(u8 nIndStages);\nvoid GXSetIndTexMtx(GXIndTexMtxID mtx_sel, f32 offset[2][3], s8 scale_exp);\nvoid GXSetIndTexOrder(GXIndTexStageID ind_stage, GXTexCoordID tex_coord, GXTexMapID tex_map);\nvoid GXSetTevIndirect(GXTevStageID tev_stage, GXIndTexStageID ind_stage, GXIndTexFormat format,\n                      GXIndTexBiasSel bias_sel, GXIndTexMtxID matrix_sel, GXIndTexWrap wrap_s,\n                      GXIndTexWrap wrap_t, GXBool add_prev, GXBool ind_lod,\n                      GXIndTexAlphaSel alpha_sel);\nvoid GXSetTevIndWarp(GXTevStageID tev_stage, GXIndTexStageID ind_stage, GXBool signed_offsets,\n                     GXBool replace_mode, GXIndTexMtxID matrix_sel);\nvoid GXSetTevIndTile (GXTevStageID tev_stage, GXIndTexStageID ind_stage,\n        u16 tilesize_s, u16 tilesize_t,\n        u16 tilespacing_s, u16 tilespacing_t,\n        GXIndTexFormat format, GXIndTexMtxID matrix_sel,\n        GXIndTexBiasSel bias_sel, GXIndTexAlphaSel alpha_sel);\nvoid GXSetIndTexCoordScale(GXIndTexStageID ind_state, GXIndTexScale scale_s, GXIndTexScale scale_t);\nvoid GXSetScissor(u32 left, u32 top, u32 wd, u32 ht);\nvoid GXSetCullMode(GXCullMode mode);\nvoid GXSetCoPlanar(GXBool enable);\nvoid GXBeginDisplayList(void* list, u32 size);\nu32 GXEndDisplayList(void);\nvoid GXCallDisplayList(const void* list, u32 nbytes);\nvoid GXDrawSphere(u8 numMajor, u8 numMinor);\ntypedef struct {\n  u8 pad[128];\n} GXFifoObj;\ntypedef void (*GXBreakPtCallback)(void);\nvoid GXInitFifoBase(GXFifoObj* fifo, void* base, u32 size);\nvoid GXInitFifoPtrs(GXFifoObj* fifo, void* readPtr, void* writePtr);\nvoid GXGetFifoPtrs(GXFifoObj* fifo, void** readPtr, void** writePtr);\nGXFifoObj* GXGetCPUFifo(void);\nGXFifoObj* GXGetGPFifo(void);\nvoid GXSetCPUFifo(GXFifoObj* fifo);\nvoid GXSetGPFifo(GXFifoObj* fifo);\nvoid GXSaveCPUFifo(GXFifoObj* fifo);\nvoid GXGetFifoStatus(GXFifoObj* fifo, GXBool* overhi, GXBool* underlow, u32* fifoCount,\n                     GXBool* cpu_write, GXBool* gp_read, GXBool* fifowrap);\nvoid GXGetGPStatus(GXBool* overhi, GXBool* underlow, GXBool* readIdle, GXBool* cmdIdle,\n                   GXBool* brkpt);\nvoid GXInitFifoLimits(GXFifoObj* fifo, u32 hiWaterMark, u32 loWaterMark);\nGXBreakPtCallback GXSetBreakPtCallback(GXBreakPtCallback cb);\nvoid GXEnableBreakPt(void* breakPt);\nvoid GXDisableBreakPt(void);\nextern GXRenderModeObj GXNtsc240Ds;\nextern GXRenderModeObj GXNtsc240DsAa;\nextern GXRenderModeObj GXNtsc240Int;\nextern GXRenderModeObj GXNtsc240IntAa;\nextern GXRenderModeObj GXNtsc480IntDf;\nextern GXRenderModeObj GXNtsc480Int;\nextern GXRenderModeObj GXNtsc480IntAa;\nextern GXRenderModeObj GXNtsc480Prog;\nextern GXRenderModeObj GXNtsc480ProgAa;\nextern GXRenderModeObj GXMpal240Ds;\nextern GXRenderModeObj GXMpal240DsAa;\nextern GXRenderModeObj GXMpal240Int;\nextern GXRenderModeObj GXMpal240IntAa;\nextern GXRenderModeObj GXMpal480IntDf;\nextern GXRenderModeObj GXMpal480Int;\nextern GXRenderModeObj GXMpal480IntAa;\nextern GXRenderModeObj GXPal264Ds;\nextern GXRenderModeObj GXPal264DsAa;\nextern GXRenderModeObj GXPal264Int;\nextern GXRenderModeObj GXPal264IntAa;\nextern GXRenderModeObj GXPal528IntDf;\nextern GXRenderModeObj GXPal528Int;\nextern GXRenderModeObj GXPal524IntAa;\nextern GXRenderModeObj GXEurgb60Hz240Ds;\nextern GXRenderModeObj GXEurgb60Hz240DsAa;\nextern GXRenderModeObj GXEurgb60Hz240Int;\nextern GXRenderModeObj GXEurgb60Hz240IntAa;\nextern GXRenderModeObj GXEurgb60Hz480IntDf;\nextern GXRenderModeObj GXEurgb60Hz480Int;\nextern GXRenderModeObj GXEurgb60Hz480IntAa;\nvoid GXSetCopyClear(GXColor clear_clr, u32 clear_z);\nvoid GXAdjustForOverscan(GXRenderModeObj* rmin, GXRenderModeObj* rmout, u16 hor, u16 ver);\nvoid GXCopyDisp(void* dest, GXBool clear);\nvoid GXSetDispCopyGamma(GXGamma gamma);\nvoid GXSetDispCopySrc(u16 left, u16 top, u16 wd, u16 ht);\nvoid GXSetDispCopyDst(u16 wd, u16 ht);\nu32 GXSetDispCopyYScale(f32 vscale);\nvoid GXSetCopyFilter(GXBool aa, u8 sample_pattern[12][2], GXBool vf, u8 vfilter[7]);\nvoid GXSetPixelFmt(GXPixelFmt pix_fmt, GXZFmt16 z_fmt);\nvoid GXSetTexCopySrc(u16 left, u16 top, u16 wd, u16 ht);\nvoid GXSetTexCopyDst(u16 wd, u16 ht, GXTexFmt fmt, GXBool mipmap);\nvoid GXCopyTex(void* dest, GXBool clear);\nvoid GXSetVtxDesc(GXAttr attr, GXAttrType type);\nvoid GXSetVtxDescv(GXVtxDescList* list);\nvoid GXClearVtxDesc(void);\nvoid GXSetVtxAttrFmt(GXVtxFmt vtxfmt, GXAttr attr, GXCompCnt cnt, GXCompType type, u8 frac);\nvoid GXSetNumTexGens(u8 nTexGens);\nvoid GXBegin(GXPrimitive type, GXVtxFmt vtxfmt, u16 nverts);\nvoid GXSetTexCoordGen2(GXTexCoordID dst_coord, GXTexGenType func, GXTexGenSrc src_param, u32 mtx,\n                       GXBool normalize, u32 postmtx);\nvoid GXSetLineWidth(u8 width, GXTexOffset texOffsets);\nvoid GXSetPointSize(u8 pointSize, GXTexOffset texOffsets);\nvoid GXEnableTexOffsets(GXTexCoordID coord, GXBool line_enable, GXBool point_enable);\nvoid GXSetArray(GXAttr attr, const void* data, u8 stride);\nvoid GXInvalidateVtxCache(void);\nstatic inline void GXSetTexCoordGen(GXTexCoordID dst_coord, GXTexGenType func,\n                                    GXTexGenSrc src_param, u32 mtx) {\n  GXSetTexCoordGen2(dst_coord, func, src_param, mtx, ((GXBool)0), GX_PTIDENTITY);\n}\nGXBool GXGetTexObjMipMap(const GXTexObj* obj);\nGXTexFmt GXGetTexObjFmt(const GXTexObj* obj);\nu16 GXGetTexObjHeight(const GXTexObj* obj);\nu16 GXGetTexObjWidth(const GXTexObj* obj);\nGXTexWrapMode GXGetTexObjWrapS(const GXTexObj* obj);\nGXTexWrapMode GXGetTexObjWrapT(const GXTexObj* obj);\nvoid* GXGetTexObjData(const GXTexObj* obj);\nvoid GXGetProjectionv(f32* p);\nvoid GXGetLightPos(const GXLightObj* lt_obj, f32* x, f32* y, f32* z);\nvoid GXGetLightColor(const GXLightObj* lt_obj, GXColor* color);\nvoid GXGetVtxAttrFmt(GXVtxFmt idx, GXAttr attr, GXCompCnt* compCnt, GXCompType* compType,\n                     u8* shift);\nvoid GXSetNumChans(u8 nChans);\nvoid GXSetChanCtrl(GXChannelID chan, GXBool enable, GXColorSrc amb_src, GXColorSrc mat_src,\n                   u32 light_mask, GXDiffuseFn diff_fn, GXAttnFn attn_fn);\nvoid GXSetChanAmbColor(GXChannelID chan, GXColor amb_color);\nvoid GXSetChanMatColor(GXChannelID chan, GXColor mat_color);\nvoid GXInitLightSpot(GXLightObj* lt_obj, f32 cutoff, GXSpotFn spot_func);\nvoid GXInitLightDistAttn(GXLightObj* lt_obj, f32 ref_distance, f32 ref_brightness,\n                         GXDistAttnFn dist_func);\nvoid GXInitLightPos(GXLightObj* lt_obj, f32 x, f32 y, f32 z);\nvoid GXInitLightDir(GXLightObj* lt_obj, f32 nx, f32 ny, f32 nz);\nvoid GXInitLightColor(GXLightObj* lt_obj, GXColor color);\nvoid GXInitLightAttn(GXLightObj* lt_obj, f32 a0, f32 a1, f32 a2, f32 k0, f32 k1, f32 k2);\nvoid GXInitLightAttnA(GXLightObj* lt_obj, f32 a0, f32 a1, f32 a2);\nvoid GXInitLightAttnK(GXLightObj* lt_obj, f32 k0, f32 k1, f32 k2);\nvoid GXLoadLightObjImm(GXLightObj* lt_obj, GXLightID light);\ntypedef void (*GXDrawDoneCallback)(void);\nGXFifoObj* GXInit(void* base, u32 size);\nGXDrawDoneCallback GXSetDrawDoneCallback(GXDrawDoneCallback cb);\nvoid GXDrawDone(void);\nvoid GXSetDrawDone(void);\nvoid GXFlush(void);\nvoid GXPixModeSync(void);\nvoid GXSetMisc(GXMiscToken token, u32 val);\nvoid GXReadXfRasMetric(u32* xf_wait_in, u32* xf_wait_out, u32* ras_busy, u32* clocks);\nvoid GXSetFog(GXFogType type, f32 startz, f32 endz, f32 nearz, f32 farz, GXColor color);\nvoid GXSetFogColor(GXColor color);\nvoid GXSetBlendMode(GXBlendMode type, GXBlendFactor src_factor, GXBlendFactor dst_factor,\n                    GXLogicOp op);\nvoid GXSetColorUpdate(GXBool update_enable);\nvoid GXSetAlphaUpdate(GXBool update_enable);\nvoid GXSetZMode(GXBool compare_enable, GXCompare func, GXBool update_enable);\nvoid GXSetZCompLoc(GXBool before_tex);\nvoid GXSetPixelFmt(GXPixelFmt pix_fmt, GXZFmt16 z_fmt);\nvoid GXSetDither(GXBool dither);\nvoid GXSetDstAlpha(GXBool enable, u8 alpha);\nvoid GXSetFieldMode(u8 field_mode, u8 half_aspect_ratio);\nvoid GXSetTevOp(GXTevStageID id, GXTevMode mode);\nvoid GXSetTevColorIn(GXTevStageID stage, GXTevColorArg a, GXTevColorArg b, GXTevColorArg c,\n                     GXTevColorArg d);\nvoid GXSetTevAlphaIn(GXTevStageID stage, GXTevAlphaArg a, GXTevAlphaArg b, GXTevAlphaArg c,\n                     GXTevAlphaArg d);\nvoid GXSetTevColorOp(GXTevStageID stage, GXTevOp op, GXTevBias bias, GXTevScale scale, GXBool clamp,\n                     GXTevRegID out_reg);\nvoid GXSetTevAlphaOp(GXTevStageID stage, GXTevOp op, GXTevBias bias, GXTevScale scale, GXBool clamp,\n                     GXTevRegID out_reg);\nvoid GXSetTevColor(GXTevRegID id, GXColor color);\nvoid GXSetTevColorS10(GXTevRegID id, GXColorS10 color);\nvoid GXSetTevKColor(GXTevKColorID id, GXColor color);\nvoid GXSetTevKColorSel(GXTevStageID stage, GXTevKColorSel sel);\nvoid GXSetTevKAlphaSel(GXTevStageID stage, GXTevKAlphaSel sel);\nvoid GXSetTevSwapMode(GXTevStageID stage, GXTevSwapSel ras_sel, GXTevSwapSel tex_sel);\nvoid GXSetTevSwapModeTable(GXTevSwapSel table, GXTevColorChan red, GXTevColorChan green,\n                           GXTevColorChan blue, GXTevColorChan alpha);\nvoid GXSetAlphaCompare(GXCompare comp0, u8 ref0, GXAlphaOp op, GXCompare comp1, u8 ref1);\nvoid GXSetZTexture(GXZTexOp op, GXTexFmt fmt, u32 bias);\nvoid GXSetTevOrder(GXTevStageID stage, GXTexCoordID coord, GXTexMapID map, GXChannelID color);\nvoid GXSetNumTevStages(u8 nStages);\ntypedef GXTexRegion* (*GXTexRegionCallback)(const GXTexObj* obj, GXTexMapID id);\nvoid GXInitTexObj(GXTexObj* obj, const void* data, u16 width, u16 height, u32 format,\n                  GXTexWrapMode wrapS, GXTexWrapMode wrapT, GXBool mipmap);\nvoid GXInitTexObjCI(GXTexObj* obj, const void* data, u16 width, u16 height, GXCITexFmt format,\n                    GXTexWrapMode wrapS, GXTexWrapMode wrapT, GXBool mipmap, u32 tlut);\nvoid GXInitTexObjData(GXTexObj* obj, const void* data);\nvoid GXInitTexObjLOD(GXTexObj* obj, GXTexFilter min_filt, GXTexFilter mag_filt, f32 min_lod,\n                     f32 max_lod, f32 lod_bias, GXBool bias_clamp, GXBool do_edge_lod,\n                     GXAnisotropy max_aniso);\nvoid GXLoadTexObj(GXTexObj* obj, GXTexMapID id);\nu32 GXGetTexBufferSize(u16 width, u16 height, u32 format, GXBool mipmap, u8 max_lod);\nvoid GXInvalidateTexAll();\nvoid GXInitTexObjWrapMode(GXTexObj* obj, GXTexWrapMode s, GXTexWrapMode t);\nvoid GXInitTlutObj(GXTlutObj* obj, void* data, GXTlutFmt format, u16 entries);\nvoid GXLoadTlut(const GXTlutObj* obj, GXTlut idx);\nvoid GXSetTexCoordScaleManually(GXTexCoordID coord, GXBool enable, u16 ss, u16 ts);\nvoid GXInitTexCacheRegion(GXTexRegion* region, GXBool is_32b_mipmap, u32 tmem_even,\n                          GXTexCacheSize size_even, u32 tmem_odd, GXTexCacheSize size_odd);\nGXTexRegionCallback GXSetTexRegionCallback(GXTexRegionCallback callback);\nvoid GXInvalidateTexRegion(const GXTexRegion* region);\nvoid GXSetTexCoordScaleManually(GXTexCoordID coord, GXBool enable, u16 ss, u16 ts);\nvoid GXSetProjection(f32 mtx[4][4], GXProjectionType type);\nvoid GXLoadPosMtxImm(f32 mtx[3][4], u32 id);\nvoid GXLoadNrmMtxImm(f32 mtx[3][4], u32 id);\nvoid GXLoadTexMtxImm(f32 mtx[][4], u32 id, GXTexMtxType type);\nvoid GXSetViewport(f32 left, f32 top, f32 wd, f32 ht, f32 nearz, f32 farz);\nvoid GXSetCurrentMtx(u32 id);\nvoid GXSetViewportJitter(f32 left, f32 top, f32 wd, f32 ht, f32 nearz, f32 farz, u32 field);\nvoid GXSetScissorBoxOffset(s32 x_off, s32 y_off);\nvoid GXSetClipMode(GXClipMode mode);\ntypedef union {\n  u8 u8;\n  u16 u16;\n  u32 u32;\n  u64 u64;\n  s8 s8;\n  s16 s16;\n  s32 s32;\n  s64 s64;\n  f32 f32;\n  f64 f64;\n} PPCWGPipe;\nstatic inline void GXPosition2f32(const f32 x, const f32 y) {\n  (*(volatile PPCWGPipe*)0xCC008000).f32 = x;\n  (*(volatile PPCWGPipe*)0xCC008000).f32 = y;\n}\nstatic inline void GXPosition2s16(const s16 x, const s16 y) {\n  (*(volatile PPCWGPipe*)0xCC008000).s16 = x;\n  (*(volatile PPCWGPipe*)0xCC008000).s16 = y;\n}\nstatic inline void GXPosition3s16(const s16 x, const s16 y, const s16 z) {\n  (*(volatile PPCWGPipe*)0xCC008000).s16 = x;\n  (*(volatile PPCWGPipe*)0xCC008000).s16 = y;\n  (*(volatile PPCWGPipe*)0xCC008000).s16 = z;\n}\nstatic inline void GXPosition3f32(const f32 x, const f32 y, const f32 z) {\n  (*(volatile PPCWGPipe*)0xCC008000).f32 = x;\n  (*(volatile PPCWGPipe*)0xCC008000).f32 = y;\n  (*(volatile PPCWGPipe*)0xCC008000).f32 = z;\n}\nstatic inline void GXNormal3f32(const f32 x, const f32 y, const f32 z) {\n  (*(volatile PPCWGPipe*)0xCC008000).f32 = x;\n  (*(volatile PPCWGPipe*)0xCC008000).f32 = y;\n  (*(volatile PPCWGPipe*)0xCC008000).f32 = z;\n}\nstatic inline void GXColor1u32(const u32 v) {\n  (*(volatile PPCWGPipe*)0xCC008000).u32 = v;\n}\nstatic inline void GXColor3u8(const u8 r, const u8 g, const u8 b) {\n  (*(volatile PPCWGPipe*)0xCC008000).u8 = r;\n  (*(volatile PPCWGPipe*)0xCC008000).u8 = g;\n  (*(volatile PPCWGPipe*)0xCC008000).u8 = b;\n}\nstatic inline void GXColor4u8(const u8 r, const u8 g, const u8 b, const u8 a) {\n  (*(volatile PPCWGPipe*)0xCC008000).u8 = r;\n  (*(volatile PPCWGPipe*)0xCC008000).u8 = g;\n  (*(volatile PPCWGPipe*)0xCC008000).u8 = b;\n  (*(volatile PPCWGPipe*)0xCC008000).u8 = a;\n}\nstatic inline void GXTexCoord2s16(const s16 u, const s16 v) {\n  (*(volatile PPCWGPipe*)0xCC008000).s16 = u;\n  (*(volatile PPCWGPipe*)0xCC008000).s16 = v;\n}\nstatic inline void GXTexCoord2f32(const f32 u, const f32 v) {\n  (*(volatile PPCWGPipe*)0xCC008000).f32 = u;\n  (*(volatile PPCWGPipe*)0xCC008000).f32 = v;\n}\nstatic inline void GXPosition1x8(u8 index) {\n  (*(volatile PPCWGPipe*)0xCC008000).u8 = index;\n}\nstatic inline void GXColor1x8(u8 index) {\n  (*(volatile PPCWGPipe*)0xCC008000).u8 = index;\n}\nstatic inline void GXEnd(void) {}\ntypedef s64 OSTime;\ntypedef u32 OSTick;\nvoid* OSGetArenaHi(void);\nvoid* OSGetArenaLo(void);\nvoid OSSetArenaHi(void* newHi);\nvoid OSSetArenaLo(void* newLo);\nvoid* OSAllocFromArenaLo(u32 size, u32 align);\nvoid* OSAllocFromArenaHi(u32 size, u32 align);\nvoid OSInit();\nOSTime OSGetTime();\nOSTick OSGetTick();\ntypedef struct OSCalendarTime {\n  int sec;\n  int min;\n  int hour;\n  int mday;\n  int mon;\n  int year;\n  int wday;\n  int yday;\n  int msec;\n  int usec;\n} OSCalendarTime;\nOSTime OSCalendarTimeToTicks(OSCalendarTime* td);\nvoid OSTicksToCalendarTime(OSTime ticks, OSCalendarTime* td);\nu32 OSGetConsoleType();\nu32 OSGetSoundMode(void);\nvoid OSSetSoundMode(u32 mode);\nu32 OSGetProgressiveMode(void);\nvoid OSSetProgressiveMode(u32 on);\nu8 OSGetLanguage(void);\nvoid OSSetLanguage(u8 language);\nu32 OSGetEuRgb60Mode(void);\nvoid OSSetEuRgb60Mode(u32 on);\nvoid OSRegisterVersion(const char* id);\nBOOL OSDisableInterrupts(void);\nBOOL OSEnableInterrupts(void);\nBOOL OSRestoreInterrupts(BOOL level);\nvoid OSReport(const char* msg, ...);\nvoid OSPanic(const char* file, int line, const char* msg, ...);\nvoid OSFatal(GXColor fg, GXColor bg, const char* msg);\nu32 OSGetPhysicalMemSize(void);\nu32 OSGetConsoleSimulatedMemSize(void);\ntypedef struct OSContext {\n  u32 gpr[32];\n  u32 cr;\n  u32 lr;\n  u32 ctr;\n  u32 xer;\n  f64 fpr[32];\n  u32 fpscr_pad;\n  u32 fpscr;\n  u32 srr0;\n  u32 srr1;\n  u16 mode;\n  u16 state;\n  u32 gqr[8];\n  u32 psf_pad;\n  f64 psf[32];\n} OSContext;\nu32 OSSaveContext(OSContext* context);\nvoid OSClearContext(OSContext* context);\nOSContext* OSGetCurrentContext();\nvoid OSSetCurrentContext(OSContext* context);\ntypedef struct OSAlarm OSAlarm;\ntypedef void (*OSAlarmHandler)(OSAlarm* alarm, OSContext* context);\nstruct OSAlarm {\n  OSAlarmHandler handler;\n  u32 tag;\n  OSTime fire;\n  OSAlarm* prev;\n  OSAlarm* next;\n  OSTime period;\n  OSTime start;\n};\nvoid OSInitAlarm(void);\nvoid OSSetAlarm(OSAlarm* alarm, OSTime tick, OSAlarmHandler handler);\nvoid OSSetAlarmTag(OSAlarm* alarm, u32 tag);\nvoid OSSetAbsAlarm(OSAlarm* alarm, OSTime time, OSAlarmHandler handler);\nvoid OSSetPeriodicAlarm(OSAlarm* alarm, OSTime start, OSTime period, OSAlarmHandler handler);\nvoid OSCreateAlarm(OSAlarm* alarm);\nvoid OSCancelAlarm(OSAlarm* alarm);\nvoid OSCancelAlarms(u32 tag);\nBOOL OSCheckAlarmQueue(void);\ntypedef int OSHeapHandle;\ntypedef void (*OSAllocVisitor)(void* obj, u32 size);\nvoid* OSInitAlloc(void* arenaStart, void* arenaEnd, int maxHeaps);\nOSHeapHandle OSCreateHeap(void* start, void* end);\nvoid OSDestroyHeap(OSHeapHandle heap);\nvoid OSAddToHeap(OSHeapHandle heap, void* start, void* end);\nOSHeapHandle OSSetCurrentHeap(OSHeapHandle heap);\nvoid* OSAllocFromHeap(OSHeapHandle heap, u32 size);\nvoid* OSAllocFixed(void** rstart, void** rend);\nvoid OSFreeToHeap(OSHeapHandle heap, void* ptr);\nlong OSCheckHeap(OSHeapHandle heap);\nvoid OSDumpHeap(OSHeapHandle heap);\nvoid *OSAllocFixed(void **rstart, void **rend);\nu32 OSReferentSize(void* ptr);\nvoid OSVisitAllocated(OSAllocVisitor visitor);\nextern volatile OSHeapHandle __OSCurrHeap;\nvoid* OSGetArenaHi(void);\nvoid* OSGetArenaLo(void);\nvoid OSSetArenaHi(void* addr);\nvoid OSSetArenaLo(void* addr);\nvoid* OSAllocFromArenaLo(u32 size, u32 align);\nvoid* OSAllocFromArenaLo(u32 size, u32 align);\nvoid DCInvalidateRange(void* addr, u32 nBytes);\nvoid DCFlushRange(void* addr, u32 nBytes);\nvoid DCStoreRange(void* addr, u32 nBytes);\nvoid DCFlushRangeNoSync(void* addr, u32 nBytes);\nvoid DCStoreRangeNoSync(void* addr, u32 nBytes);\nvoid DCZeroRange(void* addr, u32 nBytes);\nvoid DCTouchRange(void* addr, u32 nBytes);\nvoid ICInvalidateRange(void* addr, u32 nBytes);\nvoid LCEnable();\nvoid LCDisable(void);\nvoid LCLoadBlocks(void* destTag, void* srcAddr, u32 numBlocks);\nvoid LCStoreBlocks(void* destAddr, void* srcTag, u32 numBlocks);\nu32 LCLoadData(void* destAddr, void* srcAddr, u32 nBytes);\nu32 LCStoreData(void* destAddr, void* srcAddr, u32 nBytes);\nu32 LCQueueLength(void);\nvoid LCQueueWait(u32 len);\nvoid LCFlushQueue(void);\ntypedef u16 OSError;\ntypedef void (*OSErrorHandler)( OSError error, OSContext* context, ... );\nOSErrorHandler OSSetErrorHandler(OSError code, OSErrorHandler handler);\ntypedef u8 __OSException;\ntypedef void (*__OSExceptionHandler)(__OSException exception, OSContext* context);\nBOOL EXIProbe(s32 chan);\ns32 EXIProbeEx(s32 chan);\ns32 EXIGetType(s32 chan, u32 dev, u32* type);\nchar* EXIGetTypeString(u32 type);\nu32 EXIClearInterrupts(s32 chan, BOOL exi, BOOL tc, BOOL ext);\ns32 EXIGetID(s32 chan, u32 dev, u32* id);\ntypedef void (*EXICallback)(s32 chan, OSContext* context);\nstatic inline void OSInitFastCast(void) {\n}\nu16 OSGetFontEncode(void);\nu16 OSSetFontEncode(u16 encode);\ntypedef s16 __OSInterrupt;\ntypedef void (*__OSInterruptHandler)(__OSInterrupt interrupt, OSContext* context);\ntypedef u32 OSInterruptMask;\nextern volatile __OSInterrupt __OSLastInterrupt;\nextern volatile u32 __OSLastInterruptSrr0;\nextern volatile OSTime __OSLastInterruptTime;\n__OSInterruptHandler __OSSetInterruptHandler(__OSInterrupt interrupt, __OSInterruptHandler handler);\n__OSInterruptHandler __OSGetInterruptHandler(__OSInterrupt interrupt);\nvoid __OSDispatchInterrupt(__OSException exception, OSContext* context);\nOSInterruptMask OSGetInterruptMask(void);\nOSInterruptMask OSSetInterruptMask(OSInterruptMask mask);\nOSInterruptMask __OSMaskInterrupts(OSInterruptMask mask);\nOSInterruptMask __OSUnmaskInterrupts(OSInterruptMask mask);\nvoid OSProtectRange(u32 chan, void* addr, u32 nBytes, u32 control);\ntypedef struct OSThread OSThread;\ntypedef struct OSThreadQueue OSThreadQueue;\ntypedef struct OSThreadLink OSThreadLink;\ntypedef s32 OSPriority;\ntypedef struct OSMutex OSMutex;\ntypedef struct OSMutexQueue OSMutexQueue;\ntypedef struct OSMutexLink OSMutexLink;\ntypedef struct OSCond OSCond;\ntypedef void (*OSIdleFunction)(void* param);\ntypedef void (*OSSwitchThreadCallback)(OSThread* from, OSThread* to);\nstruct OSThreadQueue {\n  OSThread* head;\n  OSThread* tail;\n};\nstruct OSThreadLink {\n  OSThread* next;\n  OSThread* prev;\n};\nstruct OSMutexQueue {\n  OSMutex* head;\n  OSMutex* tail;\n};\nstruct OSMutexLink {\n  OSMutex* next;\n  OSMutex* prev;\n};\nstruct OSThread {\n  OSContext context;\n  u16 state;\n  u16 attr;\n  s32 suspend;\n  OSPriority priority;\n  OSPriority base;\n  void* val;\n  OSThreadQueue* queue;\n  OSThreadLink link;\n  OSThreadQueue queueJoin;\n  OSMutex* mutex;\n  OSMutexQueue queueMutex;\n  OSThreadLink linkActive;\n  u8* stackBase;\n  u32* stackEnd;\n};\nenum OS_THREAD_STATE {\n  OS_THREAD_STATE_READY = 1,\n  OS_THREAD_STATE_RUNNING = 2,\n  OS_THREAD_STATE_WAITING = 4,\n  OS_THREAD_STATE_MORIBUND = 8\n};\nvoid OSInitThreadQueue(OSThreadQueue* queue);\nOSThread* OSGetCurrentThread(void);\nBOOL OSIsThreadSuspended(OSThread* thread);\nBOOL OSIsThreadTerminated(OSThread* thread);\ns32 OSDisableScheduler(void);\ns32 OSEnableScheduler(void);\nvoid OSYieldThread(void);\nBOOL OSCreateThread(OSThread* thread, void* (*func)(void*), void* param, void* stack, u32 stackSize,\n                    OSPriority priority, u16 attr);\nvoid OSExitThread(void* val);\nvoid OSCancelThread(OSThread* thread);\nBOOL OSJoinThread(OSThread* thread, void** val);\nvoid OSDetachThread(OSThread* thread);\ns32 OSResumeThread(OSThread* thread);\ns32 OSSuspendThread(OSThread* thread);\nBOOL OSSetThreadPriority(OSThread* thread, OSPriority priority);\nOSPriority OSGetThreadPriority(OSThread* thread);\nvoid OSSleepThread(OSThreadQueue* queue);\nvoid OSWakeupThread(OSThreadQueue* queue);\nOSThread* OSSetIdleFunction(OSIdleFunction idleFunction, void* param, void* stack, u32 stackSize);\nOSThread* OSGetIdleFunction(void);\nvoid OSClearStack(u8 val);\nlong OSCheckActiveThreads(void);\ntypedef struct OSMessageQueue OSMessageQueue;\ntypedef void* OSMessage;\nstruct OSMessageQueue {\n  OSThreadQueue queueSend;\n  OSThreadQueue queueReceive;\n  OSMessage* msgArray;\n  s32 msgCount;\n  s32 firstIndex;\n  s32 usedCount;\n};\nvoid OSInitMessageQueue(OSMessageQueue* mq, OSMessage* msgArray, s32 msgCount);\nBOOL OSSendMessage(OSMessageQueue* mq, OSMessage msg, s32 flags);\nBOOL OSJamMessage(OSMessageQueue* mq, OSMessage msg, s32 flags);\nBOOL OSReceiveMessage(OSMessageQueue* mq, OSMessage* msg, s32 flags);\ntypedef struct OSModuleHeader OSModuleHeader;\ntypedef u32 OSModuleID;\ntypedef struct OSModuleQueue OSModuleQueue;\ntypedef struct OSModuleLink OSModuleLink;\ntypedef struct OSModuleInfo OSModuleInfo;\ntypedef struct OSSectionInfo OSSectionInfo;\ntypedef struct OSImportInfo OSImportInfo;\ntypedef struct OSRel OSRel;\nstruct OSModuleQueue {\n  OSModuleInfo* head;\n  OSModuleInfo* tail;\n};\nstruct OSModuleLink {\n  OSModuleInfo* next;\n  OSModuleInfo* prev;\n};\nstruct OSModuleInfo {\n  OSModuleID id;\n  OSModuleLink link;\n  u32 numSections;\n  u32 sectionInfoOffset;\n  u32 nameOffset;\n  u32 nameSize;\n  u32 version;\n};\nstruct OSModuleHeader {\n  OSModuleInfo info;\n  u32 bssSize;\n  u32 relOffset;\n  u32 impOffset;\n  u32 impSize;\n  u8 prologSection;\n  u8 epilogSection;\n  u8 unresolvedSection;\n  u8 bssSection;\n  u32 prolog;\n  u32 epilog;\n  u32 unresolved;\n  u32 align;\n  u32 bssAlign;\n};\nstruct OSSectionInfo {\n  u32 offset;\n  u32 size;\n};\nstruct OSImportInfo {\n  OSModuleID id;\n  u32 offset;\n};\nstruct OSRel {\n  u16 offset;\n  u8 type;\n  u8 section;\n  u32 addend;\n};\nvoid OSSetStringTable(const void* stringTable);\nBOOL OSLink(OSModuleInfo* newModule, void* bss);\nBOOL OSUnlink(OSModuleInfo* oldModule);\nOSModuleInfo* OSSearchModule(void* ptr, u32* section, u32* offset);\nvoid OSNotifyLink(OSModuleInfo* module);\nvoid OSNotifyUnlink(OSModuleInfo* module);\nstruct OSMutex {\n  OSThreadQueue queue;\n  OSThread* thread;\n  s32 count;\n  OSMutexLink link;\n};\nstruct OSCond {\n  OSThreadQueue queue;\n};\nvoid OSInitMutex(OSMutex* mutex);\nvoid OSLockMutex(OSMutex* mutex);\nvoid OSUnlockMutex(OSMutex* mutex);\nBOOL OSTryLockMutex(OSMutex* mutex);\nvoid OSInitCond(OSCond* cond);\nvoid OSWaitCond(OSCond* cond, OSMutex* mutex);\nvoid OSSignalCond(OSCond* cond);\ntypedef BOOL (*OSResetFunction)(BOOL final);\ntypedef struct OSResetFunctionInfo OSResetFunctionInfo;\nstruct OSResetFunctionInfo {\n  OSResetFunction func;\n  u32 priority;\n  OSResetFunctionInfo* next;\n  OSResetFunctionInfo* prev;\n};\ntypedef void (*OSResetCallback)(void);\nBOOL OSGetResetButtonState(void);\nBOOL OSGetResetSwitchState(void);\nOSResetCallback OSSetResetCallback(OSResetCallback callback);\nu32 SIProbe(s32 chan);\nchar* SIGetTypeString(u32 type);\nvoid SIRefreshSamplingRate(void);\nvoid SISetSamplingRate(u32 msec);\ntypedef struct DVDDiskID {\n  char gameName[4];\n  char company[2];\n  u8 diskNumber;\n  u8 gameVersion;\n  u8 streaming;\n  u8 streamingBufSize;\n  u8 padding[22];\n} DVDDiskID;\ntypedef struct DVDCommandBlock DVDCommandBlock;\ntypedef void (*DVDCBCallback)(s32 result, DVDCommandBlock* block);\nstruct DVDCommandBlock {\n  DVDCommandBlock* next;\n  DVDCommandBlock* prev;\n  u32 command;\n  s32 state;\n  u32 offset;\n  u32 length;\n  void* addr;\n  u32 currTransferSize;\n  u32 transferredSize;\n  DVDDiskID* id;\n  DVDCBCallback callback;\n  void* userData;\n};\ntypedef struct DVDFileInfo DVDFileInfo;\ntypedef void (*DVDCallback)(s32 result, DVDFileInfo* fileInfo);\nstruct DVDFileInfo {\n  DVDCommandBlock cb;\n  u32 startAddr;\n  u32 length;\n  DVDCallback callback;\n};\ntypedef struct {\n  u32 entryNum;\n  u32 location;\n  u32 next;\n} DVDDir;\ntypedef struct {\n  u32 entryNum;\n  BOOL isDir;\n  char* name;\n} DVDDirEntry;\nvoid DVDInit();\nBOOL DVDClose(DVDFileInfo* f);\nBOOL DVDSetAutoFatalMessaging(BOOL);\nvoid DVDReset();\ns32 DVDCancel(DVDCommandBlock* block);\nBOOL DVDOpen(char* fileName, DVDFileInfo* fileInfo);\nBOOL DVDFastOpen(s32 entrynum, DVDFileInfo* fileInfo);\ns32 DVDGetCommandBlockStatus(const DVDCommandBlock* block);\nBOOL DVDCancelAsync(DVDCommandBlock* block, DVDCBCallback callback);\ns32 DVDCancel(DVDCommandBlock* block);\nBOOL DVDCancelAllAsync(DVDCBCallback callback);\ns32 DVDCancelAll(void);\nBOOL DVDPrepareStreamAsync(DVDFileInfo* fInfo, u32 length, u32 offset, DVDCallback callback);\ns32 DVDPrepareStream(DVDFileInfo* fInfo, u32 length, u32 offset);\nBOOL DVDCancelStreamAsync(DVDCommandBlock* block, DVDCBCallback callback);\ns32 DVDCancelStream(DVDCommandBlock* block);\nBOOL DVDStopStreamAtEndAsync(DVDCommandBlock* block, DVDCBCallback callback);\ns32 DVDStopStreamAtEnd(DVDCommandBlock* block);\nBOOL DVDGetStreamErrorStatusAsync(DVDCommandBlock* block, DVDCBCallback callback);\ns32 DVDGetStreamErrorStatus(DVDCommandBlock* block);\nBOOL DVDGetStreamPlayAddrAsync(DVDCommandBlock* block, DVDCBCallback callback);\ns32 DVDGetStreamPlayAddr(DVDCommandBlock* block);\ns32 DVDGetDriveStatus();\ns32 DVDConvertPathToEntrynum(char* pathPtr);\nBOOL DVDReadAsyncPrio(DVDFileInfo* fileInfo, void* addr, s32 length, s32 offset,\n                      DVDCallback callback, s32 prio);\nextern u32 __PADFixBits;\ntypedef void (*PADSamplingCallback)(void);\ntypedef struct PADStatus {\n  u16 button;\n  s8 stickX;\n  s8 stickY;\n  s8 substickX;\n  s8 substickY;\n  u8 triggerL;\n  u8 triggerR;\n  u8 analogA;\n  u8 analogB;\n  s8 err;\n} PADStatus;\nBOOL PADInit();\nu32 PADRead(PADStatus* status);\nBOOL PADReset(u32 mask);\nBOOL PADRecalibrate(u32 mask);\nvoid PADClamp(PADStatus* status);\nvoid PADClampCircle(PADStatus* status);\nvoid PADControlMotor(s32 chan, u32 cmd);\nvoid PADSetSpec(u32 spec);\nvoid PADControlAllMotors(const u32* cmdArr);\nvoid PADSetAnalogMode(u32 mode);\nPADSamplingCallback PADSetSamplingCallback(PADSamplingCallback);\ntypedef struct {\n  f32 x, y, z;\n} Vec, *VecPtr, Point3d, *Point3dPtr;\ntypedef struct {\n  s16 x;\n  s16 y;\n  s16 z;\n} S16Vec, *S16VecPtr;\ntypedef struct {\n  f32 x, y, z, w;\n} Quaternion, *QuaternionPtr, Qtrn, *QtrnPtr;\ntypedef f32 Mtx[3][4];\ntypedef f32 (*MtxPtr)[4];\ntypedef f32 ROMtx[4][3];\ntypedef f32 (*ROMtxPtr)[3];\ntypedef f32 Mtx44[4][4];\ntypedef f32 (*Mtx44Ptr)[4];\ntypedef struct {\n  u32 numMtx;\n  MtxPtr stackBase;\n  MtxPtr stackPtr;\n} MtxStack, *MtxStackPtr;\nvoid C_MTXIdentity(Mtx m);\nvoid C_MTXCopy(const Mtx src, Mtx dst);\nvoid C_MTXConcat(const Mtx a, const Mtx b, Mtx ab);\nvoid C_MTXConcatArray(const Mtx a, const Mtx* srcBase, Mtx* dstBase, u32 count);\nvoid C_MTXTranspose(const Mtx src, Mtx xPose);\nu32 C_MTXInverse(const Mtx src, Mtx inv);\nu32 C_MTXInvXpose(const Mtx src, Mtx invX);\nvoid PSMTXIdentity(Mtx m);\nvoid PSMTXCopy(const Mtx src, Mtx dst);\nvoid PSMTXConcat(const Mtx a, const Mtx b, Mtx ab);\nvoid PSMTXConcatArray(const Mtx a, const Mtx* srcBase, Mtx* dstBase, u32 count);\nvoid PSMTXTranspose(const Mtx src, Mtx xPose);\nu32 PSMTXInverse(const Mtx src, Mtx inv);\nu32 PSMTXInvXpose(const Mtx src, Mtx invX);\nvoid C_MTXMultVec(const Mtx m, const Vec* src, Vec* dst);\nvoid C_MTXMultVecArray(const Mtx m, const Vec* srcBase, Vec* dstBase, u32 count);\nvoid C_MTXMultVecSR(const Mtx m, const Vec* src, Vec* dst);\nvoid C_MTXMultVecArraySR(const Mtx m, const Vec* srcBase, Vec* dstBase, u32 count);\nvoid PSMTXMultVec(const Mtx m, const Vec* src, Vec* dst);\nvoid PSMTXMultVecArray(const Mtx m, const Vec* srcBase, Vec* dstBase, u32 count);\nvoid PSMTXMultVecSR(const Mtx m, const Vec* src, Vec* dst);\nvoid PSMTXMultVecArraySR(const Mtx m, const Vec* srcBase, Vec* dstBase, u32 count);\nvoid C_MTXQuat(Mtx m, const Quaternion* q);\nvoid C_MTXReflect(Mtx m, const Vec* p, const Vec* n);\nvoid C_MTXTrans(Mtx m, f32 xT, f32 yT, f32 zT);\nvoid C_MTXTransApply(const Mtx src, Mtx dst, f32 xT, f32 yT, f32 zT);\nvoid C_MTXScale(Mtx m, f32 xS, f32 yS, f32 zS);\nvoid C_MTXScaleApply(const Mtx src, Mtx dst, f32 xS, f32 yS, f32 zS);\nvoid C_MTXRotRad(Mtx m, char axis, f32 rad);\nvoid C_MTXRotTrig(Mtx m, char axis, f32 sinA, f32 cosA);\nvoid C_MTXRotAxisRad(Mtx m, const Vec* axis, f32 rad);\nvoid PSMTXQuat(Mtx m, const Quaternion* q);\nvoid PSMTXReflect(Mtx m, const Vec* p, const Vec* n);\nvoid PSMTXTrans(Mtx m, f32 xT, f32 yT, f32 zT);\nvoid PSMTXTransApply(const Mtx src, Mtx dst, f32 xT, f32 yT, f32 zT);\nvoid PSMTXScale(Mtx m, f32 xS, f32 yS, f32 zS);\nvoid PSMTXScaleApply(const Mtx src, Mtx dst, f32 xS, f32 yS, f32 zS);\nvoid PSMTXRotRad(Mtx m, char axis, f32 rad);\nvoid PSMTXRotTrig(Mtx m, char axis, f32 sinA, f32 cosA);\nvoid PSMTXRotAxisRad(Mtx m, const Vec* axis, f32 rad);\nvoid C_MTXLookAt(Mtx m, const Point3d* camPos, const Vec* camUp, const Point3d* target);\nvoid C_MTXFrustum(Mtx44 m, f32 t, f32 b, f32 l, f32 r, f32 n, f32 f);\nvoid C_MTXPerspective(Mtx44 m, f32 fovY, f32 aspect, f32 n, f32 f);\nvoid C_MTXOrtho(Mtx44 m, f32 t, f32 b, f32 l, f32 r, f32 n, f32 f);\nvoid C_MTXLightFrustum(Mtx m, f32 t, f32 b, f32 l, f32 r, f32 n, f32 scaleS, f32 scaleT, f32 transS,\n                       f32 transT);\nvoid C_MTXLightPerspective(Mtx m, f32 fovY, f32 aspect, f32 scaleS, f32 scaleT, f32 transS,\n                           f32 transT);\nvoid C_MTXLightOrtho(Mtx m, f32 t, f32 b, f32 l, f32 r, f32 scaleS, f32 scaleT, f32 transS,\n                     f32 transT);\nvoid C_VECAdd(const Vec* a, const Vec* b, Vec* ab);\nvoid C_VECSubtract(const Vec* a, const Vec* b, Vec* a_b);\nvoid C_VECScale(const Vec* src, Vec* dst, f32 scale);\nvoid C_VECNormalize(const Vec* src, Vec* unit);\nf32 C_VECSquareMag(const Vec* v);\nf32 C_VECMag(const Vec* v);\nf32 C_VECDotProduct(const Vec* a, const Vec* b);\nvoid C_VECCrossProduct(const Vec* a, const Vec* b, Vec* axb);\nf32 C_VECSquareDistance(const Vec* a, const Vec* b);\nf32 C_VECDistance(const Vec* a, const Vec* b);\nvoid C_VECReflect(const Vec* src, const Vec* normal, Vec* dst);\nvoid C_VECHalfAngle(const Vec* a, const Vec* b, Vec* half);\nvoid PSVECAdd(const Vec* a, const Vec* b, Vec* ab);\nvoid PSVECSubtract(const Vec* a, const Vec* b, Vec* a_b);\nvoid PSVECScale(const Vec* src, Vec* dst, f32 scale);\nvoid PSVECNormalize(const Vec* src, Vec* unit);\nf32 PSVECSquareMag(const Vec* v);\nf32 PSVECMag(const Vec* v);\nf32 PSVECDotProduct(const Vec* a, const Vec* b);\nvoid PSVECCrossProduct(const Vec* a, const Vec* b, Vec* axb);\nf32 PSVECSquareDistance(const Vec* a, const Vec* b);\nf32 PSVECDistance(const Vec* a, const Vec* b);\nvoid C_QUATAdd(const Quaternion* p, const Quaternion* q, Quaternion* r);\nvoid C_QUATSubtract(const Quaternion* p, const Quaternion* q, Quaternion* r);\nvoid C_QUATMultiply(const Quaternion* p, const Quaternion* q, Quaternion* pq);\nvoid C_QUATDivide(const Quaternion* p, const Quaternion* q, Quaternion* r);\nvoid C_QUATScale(const Quaternion* q, Quaternion* r, f32 scale);\nf32 C_QUATDotProduct(const Quaternion* p, const Quaternion* q);\nvoid C_QUATNormalize(const Quaternion* src, Quaternion* unit);\nvoid C_QUATInverse(const Quaternion* src, Quaternion* inv);\nvoid C_QUATExp(const Quaternion* q, Quaternion* r);\nvoid C_QUATLogN(const Quaternion* q, Quaternion* r);\nvoid C_QUATMakeClosest(const Quaternion* q, const Quaternion* qto, Quaternion* r);\nvoid C_QUATRotAxisRad(Quaternion* r, const Vec* axis, f32 rad);\nvoid C_QUATMtx(Quaternion* r, const Mtx m);\nvoid C_QUATLerp(const Quaternion* p, const Quaternion* q, Quaternion* r, f32 t);\nvoid C_QUATSlerp(const Quaternion* p, const Quaternion* q, Quaternion* r, f32 t);\nvoid C_QUATSquad(const Quaternion* p, const Quaternion* a, const Quaternion* b, const Quaternion* q,\n                 Quaternion* r, f32 t);\nvoid C_QUATCompA(const Quaternion* qprev, const Quaternion* q, const Quaternion* qnext,\n                 Quaternion* a);\nvoid PSQUATAdd(const Quaternion* p, const Quaternion* q, Quaternion* r);\nvoid PSQUATSubtract(const Quaternion* p, const Quaternion* q, Quaternion* r);\nvoid PSQUATMultiply(const Quaternion* p, const Quaternion* q, Quaternion* pq);\nvoid PSQUATDivide(const Quaternion* p, const Quaternion* q, Quaternion* r);\nvoid PSQUATScale(const Quaternion* q, Quaternion* r, f32 scale);\nf32 PSQUATDotProduct(const Quaternion* p, const Quaternion* q);\nvoid PSQUATNormalize(const Quaternion* src, Quaternion* unit);\nvoid PSQUATInverse(const Quaternion* src, Quaternion* inv);\nvoid PSMTXReorder(const Mtx src, ROMtx dest);\nvoid PSMTXROMultVecArray(const ROMtx m, const Vec* srcBase, Vec* dstBase, u32 count);\nvoid PSMTXROSkin2VecArray(const ROMtx m0, const ROMtx m1, const f32* wtBase, const Vec* srcBase,\n                          Vec* dstBase, u32 count);\nvoid PSMTXMultS16VecArray(const Mtx m, const S16Vec* srcBase, Vec* dstBase, u32 count);\nvoid PSMTXROMultS16VecArray(const ROMtx m, const S16Vec* srcBase, Vec* dstBase, u32 count);\nvoid MTXInitStack(MtxStack* sPtr, u32 numMtx);\nMtxPtr MTXPush(MtxStack* sPtr, const Mtx m);\nMtxPtr MTXPushFwd(MtxStack* sPtr, const Mtx m);\nMtxPtr MTXPushInv(MtxStack* sPtr, const Mtx m);\nMtxPtr MTXPushInvXpose(MtxStack* sPtr, const Mtx m);\nMtxPtr MTXPop(MtxStack* sPtr);\nMtxPtr MTXGetStackPtr(const MtxStack* sPtr);\nu32 VIGetNextField(void);\nVIRetraceCallback VISetPreRetraceCallback(VIRetraceCallback callback);\nVIRetraceCallback VISetPostRetraceCallback(VIRetraceCallback callback);\nvoid __VIGetCurrentPosition(s16* x, s16* y);\nu32 VIGetDTVStatus(void);\nvoid VIInit(void);\nvoid VIConfigure(const GXRenderModeObj* rm);\nvoid VIFlush(void);\nu32 VIGetTvFormat(void);\nvoid VISetNextFrameBuffer(void* fb);\nvoid VIWaitForRetrace(void);\nvoid VISetBlack(BOOL black);\ntypedef void (*AISCallback)(u32 count);\ntypedef void (*AIDCallback)();\nAIDCallback AIRegisterDMACallback(AIDCallback callback);\nvoid AIInitDMA(u32 start_addr, u32 length);\nBOOL AIGetDMAEnableFlag();\nvoid AIStartDMA();\nvoid AIStopDMA();\nu32 AIGetDMABytesLeft();\nu32 AIGetDMAStartAddr();\nu32 AIGetDMALength();\nu32 AIGetDSPSampleRate();\nvoid AISetDSPSampleRate(u32 rate);\nAISCallback AIRegisterStreamCallback(AISCallback callback);\nu32 AIGetStreamSampleCount();\nvoid AIResetStreamSampleCount();\nvoid AISetStreamTrigger(u32 trigger);\nu32 AIGetStreamTrigger();\nvoid AISetStreamPlayState(u32 state);\nu32 AIGetStreamPlayState();\nvoid AISetStreamSampleRate(u32 rate);\nu32 AIGetStreamSampleRate();\nvoid AISetStreamVolLeft(u8 vol);\nvoid AISetStreamVolRight(u8 vol);\nu8 AIGetStreamVolLeft();\nu8 AIGetStreamVolRight();\nvoid AIInit(u8* stack);\nBOOL AICheckInit();\nvoid AIReset();\ntypedef void (*ARCallback)(void);\nARCallback ARRegisterDMACallback(ARCallback callback);\nu32 ARGetDMAStatus(void);\nvoid ARStartDMA(u32 type, u32 mainmem_addr, u32 aram_addr, u32 length);\nu32 ARInit(u32* stack_index_addr, u32 num_entries);\nu32 ARGetBaseAddress(void);\nBOOL ARCheckInit(void);\nvoid ARReset(void);\nu32 ARAlloc(u32 length);\nu32 ARFree(u32* length);\nu32 ARGetSize(void);\nu32 ARGetInternalSize(void);\nvoid ARSetSize(void);\nvoid ARClear(u32 flag);\nvoid __ARClearInterrupt(void);\nu16 __ARGetInterruptStatus(void);\ntypedef void (*ARQCallback)(u32 pointerToARQRequest);\ntypedef struct ARQRequest {\n  struct ARQRequest* next;\n  u32 owner;\n  u32 type;\n  u32 priority;\n  u32 source;\n  u32 dest;\n  u32 length;\n  ARQCallback callback;\n} ARQRequest;\nvoid ARQInit(void);\nvoid ARQReset(void);\nvoid ARQPostRequest(ARQRequest* task, u32 owner, u32 type, u32 priority, u32 source, u32 dest,\n                    u32 length, ARQCallback callback);\nvoid ARQRemoveRequest(ARQRequest* task);\nvoid ARQRemoveOwnerRequest(u32 owner);\nvoid ARQFlushQueue(void);\nvoid ARQSetChunkSize(u32 size);\nu32 ARQGetChunkSize(void);\nBOOL ARQCheckInit(void);\ntypedef void (*DSPCallback)(void* task);\ntypedef struct STRUCT_DSP_TASK {\n  vu32 state;\n  vu32 priority;\n  vu32 flags;\n  u16* iram_mmem_addr;\n  u32 iram_length;\n  u32 iram_addr;\n  u16* dram_mmem_addr;\n  u32 dram_length;\n  u32 dram_addr;\n  u16 dsp_init_vector;\n  u16 dsp_resume_vector;\n  DSPCallback init_cb;\n  DSPCallback res_cb;\n  DSPCallback done_cb;\n  DSPCallback req_cb;\n  struct STRUCT_DSP_TASK* next;\n  struct STRUCT_DSP_TASK* prev;\n  OSTime t_context;\n  OSTime t_task;\n} DSPTaskInfo;\nvoid DSPInit();\nvoid DSPReset();\nvoid DSPHalt();\nvoid DSPSendMailToDSP(u32 mail);\nu32 DSPCheckMailToDSP();\nu32 DSPCheckMailFromDSP();\nu32 DSPGetDMAStatus();\nDSPTaskInfo* DSPAddTask(DSPTaskInfo* task);\nvoid __DSP_exec_task(DSPTaskInfo* curr, DSPTaskInfo* next);\nvoid __DSP_boot_task(DSPTaskInfo* task);\nvoid __DSP_remove_task(DSPTaskInfo* task);\nvoid __DSP_add_task(DSPTaskInfo* task);\nvoid __DSP_debug_printf(const char* fmt, ...);\ntypedef struct CARDFileInfo {\n  s32 chan;\n  s32 fileNo;\n  s32 offset;\n  s32 length;\n  u16 iBlock;\n  u16 __padding;\n} CARDFileInfo;\ntypedef struct CARDStat {\n  char fileName[32];\n  u32 length;\n  u32 time;\n  u8 gameName[4];\n  u8 company[2];\n  u8 bannerFormat;\n  u8 __padding;\n  u32 iconAddr;\n  u16 iconFormat;\n  u16 iconSpeed;\n  u32 commentAddr;\n  u32 offsetBanner;\n  u32 offsetBannerTlut;\n  u32 offsetIcon[8];\n  u32 offsetIconTlut;\n  u32 offsetData;\n} CARDStat;\ntypedef void (*CARDCallback)(s32 chan, s32 result);\nvoid CARDInit(void);\nBOOL CARDGetFastMode(void);\nBOOL CARDSetFastMode(BOOL enable);\ns32 CARDCheck(s32 chan);\ns32 CARDCheckAsync(s32 chan, CARDCallback callback);\ns32 CARDCheckEx(s32 chan, s32* xferBytes);\ns32 CARDCheckExAsync(s32 chan, s32* xferBytes, CARDCallback callback);\ns32 CARDCreate(s32 chan, const char* fileName, u32 size, CARDFileInfo* fileInfo);\ns32 CARDCreateAsync(s32 chan, const char* fileName, u32 size, CARDFileInfo* fileInfo,\n                    CARDCallback callback);\ns32 CARDDelete(s32 chan, const char* fileName);\ns32 CARDDeleteAsync(s32 chan, const char* fileName, CARDCallback callback);\ns32 CARDFastDelete(s32 chan, s32 fileNo);\ns32 CARDFastDeleteAsync(s32 chan, s32 fileNo, CARDCallback callback);\ns32 CARDFastOpen(s32 chan, s32 fileNo, CARDFileInfo* fileInfo);\ns32 CARDFormat(s32 chan);\ns32 CARDFormatAsync(s32 chan, CARDCallback callback);\ns32 CARDFreeBlocks(s32 chan, s32* byteNotUsed, s32* filesNotUsed);\ns32 CARDGetAttributes(s32 chan, s32 fileNo, u8* attr);\ns32 CARDGetEncoding(s32 chan, u16* encode);\ns32 CARDGetMemSize(s32 chan, u16* size);\ns32 CARDGetResultCode(s32 chan);\ns32 CARDGetSectorSize(s32 chan, u32* size);\ns32 CARDGetSerialNo(s32 chan, u64* serialNo);\ns32 CARDGetStatus(s32 chan, s32 fileNo, CARDStat* stat);\ns32 CARDGetXferredBytes(s32 chan);\ns32 CARDMount(s32 chan, void* workArea, CARDCallback detachCallback);\ns32 CARDMountAsync(s32 chan, void* workArea, CARDCallback detachCallback,\n                   CARDCallback attachCallback);\ns32 CARDOpen(s32 chan, const char* fileName, CARDFileInfo* fileInfo);\nBOOL CARDProbe(s32 chan);\ns32 CARDProbeEx(s32 chan, s32* memSize, s32* sectorSize);\ns32 CARDRename(s32 chan, const char* oldName, const char* newName);\ns32 CARDRenameAsync(s32 chan, const char* oldName, const char* newName, CARDCallback callback);\ns32 CARDSetAttributesAsync(s32 chan, s32 fileNo, u8 attr, CARDCallback callback);\ns32 CARDSetAttributes(s32 chan, s32 fileNo, u8 attr);\ns32 CARDSetStatus(s32 chan, s32 fileNo, CARDStat* stat);\ns32 CARDSetStatusAsync(s32 chan, s32 fileNo, CARDStat* stat, CARDCallback callback);\ns32 CARDUnmount(s32 chan);\ns32 CARDGetCurrentMode(s32 chan, u32* mode);\ns32 CARDCancel(CARDFileInfo* fileInfo);\ns32 CARDClose(CARDFileInfo* fileInfo);\ns32 CARDRead(CARDFileInfo* fileInfo, void* addr, s32 length, s32 offset);\ns32 CARDReadAsync(CARDFileInfo* fileInfo, void* addr, s32 length, s32 offset,\n                  CARDCallback callback);\ns32 CARDWrite(CARDFileInfo* fileInfo, const void* addr, s32 length, s32 offset);\ns32 CARDWriteAsync(CARDFileInfo* fileInfo, const void* addr, s32 length, s32 offset,\n                   CARDCallback callback);\ntypedef struct player_config {\n    s16 character;\n    s16 pad_idx;\n    s16 diff;\n    s16 group;\n    s16 iscom;\n} PlayerConfig;\ntypedef struct wipe_state {\n    u8 unk[52];\n    float duration;\n    u8 unk2[20];\n} WipeState;\ntypedef struct w03State {\n           s8 unk0;\n           u8 unk1;\n           u8 unk2;\n           s8 unk3;\n           u16 unk4;\n           u16 unk6;\n           s16 unk8;\n} w03State;\ntypedef struct system_state {\n/* 0x00 */ struct {\n        u8 story : 1;\n        u8 team : 1;\n        u8 : 7;\n    };\n/* 0x02 */ struct {\n        u16 bonus_star : 1;\n        u16 explain_mg : 1;\n        u16 show_com_mg : 1;\n        u16 mg_type : 2;\n        u16 mess_speed : 2;\n        u16 save_mode : 2;\n    };\n/* 0x04 */ s8 turn;\n/* 0x05 */ s8 max_turn;\n/* 0x06 */ u8 star_flag;\n/* 0x07 */ u8 star_total;\n/* 0x08 */ struct {\n    u8 star_pos : 3;\n    u8 board : 5;\n};\n/* 0x09 */ s8 last5_effect;\n/* 0x0A */ s8 player_curr;\n/* 0x0B */ char unk0B[3];\n/* 0x0E */ s16 hidden_block_pos;\n/* 0x10 */ u8 ATTRIBUTE_ALIGN(4) board_data[32];\n/* 0x30 */ u8 mess_delay;\n/* 0x31 */ struct {\n        u8 field31_bit0 : 4;\n    };\n/* 0x32 */ char unk_32[0x2];\n/* 0x34 */ u16 mg_next;\n/* 0x36 */ s16 mg_next_extra;\n/* 0x38 */ s16 flagExtra;\n/* 0x3A */ u8 flag[3][16];\n/* 0x6A */ u8 unk_68[0x72];\n} SystemState; //8018fcf8, sizeof 0xDC\ntypedef struct {\n    u8 unk0 : 2;\n} PlayerFlags;\ntypedef struct player_state {\n    /* 0x00 */ u8 characterID;\n    /* 0x01 */ s8 unk01;\n    /* 0x02 */ s8 unk02;\n    /* 0x03 */ s8 unk03;\n    /* 0x04 */ s8 controllerPort;\n    /* 0x05 */ s8 items[3];\n    /* 0x08 */ PlayerFlags flags;\n    /* 0x09 */ u8 placement;\n    /* 0x0A */ u8 spacesLeftToMove;\n    /* 0x0B */ char padB[1];\n    /* 0x0C */ s16 unkC;                            /* inferred */\n    /* 0x0E */ char padE[2];\n    /* 0x10 */ s16 nextABSSpaceIndex;\n    /* 0x12 */ char pad12[2];\n    /* 0x14 */ s8 blueSpacesLanded;\n    /* 0x15 */ s8 redSpacesLanded;\n    /* 0x16 */ s8 happeningSpacesLanded;\n    /* 0x17 */ s8 chanceSpacesLanded;\n    /* 0x18 */ s8 unk_18;\n    /* 0x19 */ s8 battleSpacesLanded;\n    /* 0x1A */ s8 itemSpacesLanded;\n    /* 0x1B */ s8 springSpacesLanded;\n    /* 0x1C */ s16 coins;\n    /* 0x1E */ char pad1E[2];\n    /* 0x20 */ s16 totalCoinsCollected;\n    /* 0x22 */ s16 coinPeak;\n    /* 0x24 */ char pad24[6];                       /* maybe part of coinPeak[4]? */\n    /* 0x2A */ s16 stars;\n    /* 0x2C */ char pad2C[4];                       /* maybe part of stars[3]? */\n} PlayerState;                                      /* size = 0x30 */\nvoid Hu3DLayerHookSet(short layer, void (*func)(short layer));\nvoid Hu3D2Dto3D(Vec*, s32, Vec*);\nvoid Hu3DModelLightInfoSet(s32, s32);\nvoid Hu3DBGColorSet(u8, u8, u8);\nvoid HuAudFadeOut(int arg0);\nvoid WipeCreate(char dir, char type, short duration);\nu8 WipeStatGet(void);\nvoid Hu3DModelPosSet(s16 index, float x, float y, float z);\nvoid Hu3DModelRotSet(s16 index, float x, float y, float z);\nvoid Hu3DModelScaleSet(s16 index, float x, float y, float z);\nvoid espInit(void);\nvoid espScaleSet(s16, f32, f32);\ns16 espEntry(s32, s32, s32);\nvoid espDispOff(s16);\nvoid espKill(s16);\nvoid espDispOn(s16);\nvoid espPosSet(s16, f32, f32);\nvoid HuWinAllKill(void);\nvoid HuWinMesSet(s16, s32);\nvoid HuWinKill(s16);\nvoid HuWinPriSet(s16, s32);\nvoid HuWinHomeClear(s16);\nvoid HuWinMesPalSet(s16, s32, s32, s32, s32);\nvoid HuWinMesSet(s16, s32);\nvoid HuWinMesSpeedSet(s16, s32);\nvoid HuWinMesMaxSizeGet(s32, f32*, ...);\ns16 HuWinCreate(float x, float y, s16 w, s16 h, s16 frame);\nvoid HuPadRumbleAllStop(void);\ns16 HuPadStatGet(s16);\nvoid HuAudFXListnerKill(void);\nvoid HuAudDllSndGrpSet(u16 ovl);\nvoid HuAudVoiceInit(s16 ovl);\nvoid MGSeqKillAll(void);\nvoid MGSeqPracticeStart(void);\nvoid fn_8004D6F4(s16 arg);\ns32 _CheckFlag(u32 flag);\nvoid BoardWinCreate(s16, s32, s32);\nvoid BoardWinKill(void);\nvoid BoardWinWait(void);\ns32 HuTHPFrameGet(void);\ns32 rand8(void);\nvoid fn_8005D8E8(void);\nvoid fn_8005DB6C(s16, Vec*, s32, f32, f32, s32);\nvoid fn_8005E0C0(void);\nvoid fn_80074210(s32, s32, Vec*);\nvoid fn_8007A360(s32);\nvoid fn_8007F894(void);\nvoid fn_80083F84(void);\nvoid fn_800884F4(s32);\nvoid fn_800A4C88(void);\nvoid fn_800A6B10(void);\nvoid fn_8008853C(s32);\nvoid fn_800B42B4(s32);\nvoid fn_80082AAC(s32);\nvoid fn_800B4264(s32, s32, s32);\nvoid fn_8007500C(s32);\nvoid fn_8006F0D4(s32, f32);\nf32 fn_8006F128(s32);\nvoid fn_8006F61C(s16, s32);\nvoid fn_800B42BC(s16);\ns32 fn_8006DBD4(s16);\nvoid fn_8005B150(void*, void*);\nvoid fn_8006F2E8(s32, Vec*);\nvoid fn_8005D10C(void*, void*);\ns16 fn_8006D9A4(s32, void*, s32);\nvoid fn_8006DB90(s16);\nvoid fn_8006DDE8(s16, f32);\nvoid fn_8006E2B8(s16, s32, s32);\nvoid fn_8006E878(s16, f32);\nvoid fn_8006F158(s16, void*);\nvoid fn_8006F1A8(s16, f32, f32, f32);\ns32 fn_8006F220(s16 arg0, Vec* arg1);\nvoid fn_8006F50C(s16, s32);\nvoid fn_80073FF4(void*);\nvoid fn_80073FFC(void*);\nvoid fn_80074004(void*);\ns32 fn_800745F0(s32, s32);\nvoid fn_800772EC(s32);\nvoid fn_80077A3C(void);\nvoid fn_80077AAC(s16);\nvoid fn_8007A83C(s16);\nvoid fn_80083EDC(s16);\nvoid fn_800A4F6C(s16);\nvoid fn_800B3FD8(void*);\nvoid fn_800B4274(s32, s32);\nvoid fn_8005D5C0(Vec*);\nvoid fn_8006F338(s16, f32, f32, f32);\ns32 fn_8005B6A8(void);\nvoid fn_8006EFBC(s16, Mtx);\nvoid fn_8006F270(s16, f32, f32, f32);\nextern u16 HuPadBtnDown[4];\nextern u8 HuPadDStk[4];\nextern WipeState wipeData;\nextern PlayerConfig GWPlayerCfg[4];\nextern u32 DirDataSize;\nextern u32 totalPolyCnted;\nextern char fadeStat;\nextern PlayerState GWPlayer[4];\nextern SystemState GWSystem;\ntypedef enum {\n    HEAP_SYSTEM,\n    HEAP_MUSIC,\n    HEAP_DATA,\n    HEAP_DVD,\n    HEAP_MISC,\n    HEAP_MAX\n} HeapID;\nvoid HuMemInitAll(void);\nvoid *HuMemInit(void *ptr, s32 size);\nvoid HuMemDCFlushAll();\nvoid HuMemDCFlush(HeapID heap);\nvoid *HuMemDirectMalloc(HeapID heap, s32 size);\nvoid *HuMemDirectMallocNum(HeapID heap, s32 size, u32 num);\nvoid HuMemDirectFree(void *ptr);\nvoid HuMemDirectFreeNum(HeapID heap, u32 num);\ns32 HuMemUsedMallocSizeGet(HeapID heap);\ns32 HuMemUsedMallocBlockGet(HeapID heap);\nu32 HuMemHeapSizeGet(HeapID heap);\nvoid *HuMemHeapPtrGet(HeapID heap);\nvoid *HuMemHeapInit(void *ptr, s32 size);\nvoid *HuMemMemoryAlloc(void *heap_ptr, s32 size, u32 retaddr);\nvoid *HuMemMemoryAllocNum(void *heap_ptr, s32 size, u32 num, u32 retaddr);\nvoid HuMemMemoryFree(void *ptr, u32 retaddr);\nvoid HuMemMemoryFreeNum(void *heap_ptr, u32 num, u32 retaddr);\ns32 HuMemUsedMemorySizeGet(void *heap_ptr);\ns32 HuMemUsedMemoryBlockGet(void *heap_ptr);\ns32 HuMemMemoryAllocSizeGet(s32 size);\nvoid HuMemHeapDump(void *heap_ptr, s16 status);\ntypedef void (*SpriteFunc)(struct sprite_data *);\ntypedef struct anim_frame_data {\n    s16 pat;\n    s16 time;\n    s16 shiftX;\n    s16 shiftY;\n    s16 flip;\n    s16 pad;\n} AnimFrameData;\ntypedef struct anim_bank_data {\n    s16 timeNum;\n    s16 unk;\n    AnimFrameData *frame;\n} AnimBankData;\ntypedef struct anim_layer_data {\n    u8 alpha;\n    u8 flip;\n    s16 bmpNo;\n    s16 startX;\n    s16 startY;\n    s16 sizeX;\n    s16 sizeY;\n    s16 shiftX;\n    s16 shiftY;\n    s16 vtx[8];\n} AnimLayerData;\ntypedef struct anim_pat_data {\n    s16 layerNum;\n    s16 centerX;\n    s16 centerY;\n    s16 sizeX;\n    s16 sizeY;\n    AnimLayerData *layer;\n} AnimPatData;\ntypedef struct anim_bmp_data {\n    u8 pixSize;\n    u8 dataFmt;\n    s16 palNum;\n    s16 sizeX;\n    s16 sizeY;\n    u32 dataSize;\n    void *palData;\n    void *data;\n} AnimBmpData;\ntypedef struct anim_data {\n    s16 bankNum;\n    s16 patNum;\n    s16 bmpNum;\n    s16 useNum;\n    AnimBankData *bank;\n    AnimPatData *pat;\n    AnimBmpData *bmp;\n} AnimData;\ntypedef struct hsf_vector3f {\n    float x;\n    float y;\n    float z;\n} HsfVector3f;\ntypedef struct hsf_vector2f {\n    float x;\n    float y;\n} HsfVector2f;\ntypedef struct hsf_section {\n    s32 ofs;\n    s32 count;\n} HsfSection;\ntypedef struct hsf_header {\n    char magic[8];\n    HsfSection scene;\n    HsfSection color;\n    HsfSection material;\n    HsfSection attribute;\n    HsfSection vertex;\n    HsfSection normal;\n    HsfSection st;\n    HsfSection face;\n    HsfSection object;\n    HsfSection bitmap;\n    HsfSection palette;\n    HsfSection motion;\n    HsfSection cenv;\n    HsfSection skeleton;\n    HsfSection part;\n    HsfSection cluster;\n    HsfSection shape;\n    HsfSection mapAttr;\n    HsfSection matrix;\n    HsfSection symbol;\n    HsfSection string;\n} HsfHeader;\ntypedef struct hsf_scene {\n    GXColor unk0;\n    f32 unk4;\n    f32 unk8;\n    u32 unkC;\n} HsfScene;\ntypedef struct hsf_bitmap {\n    char *name;\n    s32 maxLod;\n    u8 dataFmt;\n    u8 pixSize;\n    s16 sizeX;\n    s16 sizeY;\n    s16 palSize;\n    GXColor tint;\n    void *palData;\n    u32 unk;\n    void *data;\n} HsfBitmap;\ntypedef struct hsf_palette {\n    char *name;\n    s32 unk;\n    u32 palSize;\n    u16 *data;\n} HsfPalette;\ntypedef struct hsf_attribute {\n    char *name;\n    u8 unk4[96];\n    u32 wrap_s;\n    u32 wrap_t;\n    u8 unk6C[16];\n    u32 flag;\n    HsfBitmap *bitmap;\n} HsfAttribute;\ntypedef struct hsf_material {\n    char *name;\n    u8 unk4[4];\n    u16 pass;\n    u8 vtxMode;\n    u8 litColor[3];\n    u8 color[3];\n    u8 shadowColor[3];\n    float hilite_scale;\n    float unk18;\n    float invAlpha;\n    float unk20[2];\n    float refAlpha;\n    float unk2C;\n    u32 flags;\n    u32 numAttrs;\n    HsfAttribute **attrs;\n} HsfMaterial;\ntypedef struct hsf_vertex_buf {\n    char *name;\n    s32 count;\n    void *data;\n} HsfBuffer;\ntypedef struct hsf_tristrip {\n    u16 data[4];\n} HsfTristrip;\ntypedef struct hsf_face {\n    u16 type;\n    u16 mat;\n    u16 indices[12];\n    union {\n        struct {\n            u32 count;\n            HsfTristrip *data;\n        } strip;\n        u16 ext_indices[4];\n    };\n    float nbt[3];\n} HsfFace;\ntypedef struct hsf_const_data {\n    u32 flags;\n    u8 unk4[0x3C];\n    AnimData *hilite_map;\n} HsfConstData;\ntypedef struct hsf_transform {\n    Vec pos;\n    Vec rot;\n    Vec scale;\n} HsfTransform;\ntypedef struct hsf_cenv_single {\n    u32 target;\n    u16 pos;\n    u16 posCnt;\n    u16 normal;\n    u16 normalCnt;\n} HsfCenvSingle;\ntypedef struct hsf_cenv_dual_weight {\n    float weight;\n    u16 pos;\n    u16 posCnt;\n    u16 normal;\n    u16 normalCnt;\n} HsfCenvDualWeight;\ntypedef struct hsf_cenv_dual {\n    u32 target1;\n    u32 target2;\n    u32 weightCnt;\n    HsfCenvDualWeight *weight;\n} HsfCenvDual;\ntypedef struct hsf_cenv_multi_weight {\n    u32 target;\n    float value;\n} HsfCenvMultiWeight;\ntypedef struct hsf_cenv_multi {\n    u32 weightCnt;\n    u16 pos;\n    u16 posCnt;\n    u16 normal;\n    u16 normalCnt;\n    HsfCenvMultiWeight *weight;\n} HsfCenvMulti;\ntypedef struct hsf_cenv {\n    char *name;\n    HsfCenvSingle *singleData;\n    HsfCenvDual *dualData;\n    HsfCenvMulti *multiData;\n    u32 singleCount;\n    u32 dualCount;\n    u32 multiCount;\n    u32 vtxCount;\n    u32 copyCount;\n} HsfCenv;\ntypedef struct hsf_part {\n    char *name;\n    u32 count;\n    u16 *vertex;\n} HsfPart;\ntypedef struct hsf_cluster {\n    char *name[2];\n    union {\n        char *targetName;\n        u32 target;\n    };\n    HsfPart *part;\n    u8 unk10[132];\n    u8 adjusted;\n    u8 unk95;\n    u16 type;\n    u32 vertexCnt;\n    HsfBuffer **vertex;\n} HsfCluster;\ntypedef struct hsf_shape {\n    char *name;\n    union {\n        u16 count16[2];\n        u32 vertexCnt;\n    };\n    HsfBuffer **vertex;\n} HsfShape;\ntypedef struct hsf_object_data {\n    struct hsf_object *parent;\n    u32 childrenCount;\n    struct hsf_object **children;\n    HsfTransform base;\n    HsfTransform curr;\n    union {\n        struct {\n            HsfVector3f min;\n            HsfVector3f max;\n            float baseMorph;\n            float *morphWeight[33];\n        } mesh;\n        struct hsf_object *replica;\n    };\n    HsfBuffer *face;\n    HsfBuffer *vertex;\n    HsfBuffer *normal;\n    HsfBuffer *color;\n    HsfBuffer *st;\n    HsfMaterial *material;\n    HsfAttribute *attribute;\n    u8 unk120[2];\n    u8 shapeType;\n    u32 vertexShapeCnt;\n    HsfBuffer **vertexShape;\n    u32 clusterCnt;\n    HsfCluster **cluster;\n    u32 hook;\n    HsfCenv *cenv;\n    void *file[2];\n} HsfObjectData;\ntypedef struct hsf_camera {\n    HsfVector3f target;\n    HsfVector3f pos;\n    float aspect_dupe;\n    float fov;\n    float near;\n    float far;\n} HsfCamera;\ntypedef struct hsf_object {\n    char *name;\n    u32 type;\n    HsfConstData *constData;\n    u32 flags;\n    union {\n        HsfObjectData data;\n        HsfCamera camera;\n    };\n} HsfObject;\ntypedef struct hsf_skeleton {\n    char *name;\n    HsfTransform transform;\n} HsfSkeleton;\ntypedef struct hsf_bitmap_keyframe {\n    float time;\n    HsfBitmap *data;\n} HsfBitmapKey;\ntypedef struct hsf_track {\n    u8 type;\n    u8 start;\n    u16 target;\n    u16 param;\n    u16 channel;\n    u16 curveType;\n    u16 numKeyframes;\n    union {\n        float value;\n        void *data;\n    };\n} HsfTrack;\ntypedef struct hsf_motion {\n    char *name;\n    u32 numTracks;\n    HsfTrack *track;\n    float len;\n} HsfMotion;\ntypedef struct hsf_map_attr {\n    float minX;\n    float minZ;\n    float maxX;\n    float maxZ;\n    s16 *data;\n    u32 dataLen;\n} HsfMapAttr;\ntypedef struct hsf_matrix {\n    u32 base_idx;\n    u32 count;\n    Mtx *data;\n} HsfMatrix;\ntypedef struct hsf_data {\n    u8 magic[8];\n    HsfScene *scene;\n    HsfAttribute *attribute;\n    HsfMaterial *material;\n    HsfBuffer *vertex;\n    HsfBuffer *normal;\n    HsfBuffer *st;\n    HsfBuffer *color;\n    HsfBuffer *face;\n    HsfBitmap *bitmap;\n    HsfPalette *palette;\n    HsfObject *root;\n    HsfCenv *cenv;\n    HsfSkeleton *skeleton;\n    HsfCluster *cluster;\n    HsfPart *part;\n    HsfShape *shape;\n    HsfMotion *motion;\n    HsfObject *object;\n    HsfMapAttr *mapAttr;\n    HsfMatrix *matrix;\n    s16 sceneCnt;\n    s16 attributeCnt;\n    s16 materialCnt;\n    s16 vertexCnt;\n    s16 normalCnt;\n    s16 stCnt;\n    s16 colorCnt;\n    s16 faceCnt;\n    s16 bitmapCnt;\n    s16 paletteCnt;\n    s16 objectCnt;\n    s16 cenvCnt;\n    s16 skeletonCnt;\n    s16 clusterCnt;\n    s16 partCnt;\n    s16 shapeCnt;\n    s16 mapAttrCnt;\n    s16 motionCnt;\n    s16 matrixCnt;\n} HsfData;\ntypedef struct sprite_data {\n    u8 r;\n    u8 g;\n    u8 b;\n    char draw_no;\n    short frame;\n    short bank;\n    short attr;\n    short dirty_flag;\n    short prio;\n    float time;\n    float x;\n    float y;\n    float z_rot;\n    float scale_x;\n    float scale_y;\n    float speed;\n    float a;\n    GXTexWrapMode wrap_s;\n    GXTexWrapMode wrap_t;\n    short tex_scale_x;\n    short tex_scale_y;\n    Mtx *group_mtx;\n    union {\n        AnimData *data;\n        SpriteFunc func;\n    };\n    AnimPatData *pat_data;\n    AnimFrameData *frame_data;\n    short work[4];\n    AnimData *bg;\n    unsigned short bg_bank;\n    short scissor_x;\n    short scissor_y;\n    short scissor_w;\n    short scissor_h;\n} SpriteData;\ntypedef struct sprite_group_data {\n    short capacity;\n    float x;\n    float y;\n    float z_rot;\n    float scale_x;\n    float scale_y;\n    float center_x;\n    float center_y;\n    short *members;\n    Mtx mtx;\n} SpriteGroupData;\nextern SpriteData HuSprData[384];\nextern SpriteGroupData HuSprGrpData[256];\nvoid HuSprInit(void);\nvoid HuSprClose(void);\nvoid HuSprExec(short draw_no);\nvoid HuSprBegin(void);\nSpriteData *HuSprCall(void);\nvoid HuSprFinish(void);\nvoid HuSprPauseSet(BOOL value);\nAnimData *HuSprAnimRead(void *data);\nvoid HuSprAnimLock(AnimData *anim);\nshort HuSprCreate(AnimData *anim, short prio, short bank);\nshort HuSprFuncCreate(SpriteFunc func, short prio);\nshort HuSprGrpCreate(short capacity);\nshort HuSprGrpCopy(short group);\nvoid HuSprGrpMemberSet(short group, short member, short sprite);\nvoid HuSprGrpMemberKill(short group, short member);\nvoid HuSprGrpKill(short group);\nvoid HuSprKill(short sprite);\nvoid HuSprAnimKill(AnimData *anim);\nvoid HuSprAttrSet(short group, short member, int attr);\nvoid HuSprAttrReset(short group, short member, int attr);\nvoid HuSprPosSet(short group, short member, float x, float y);\nvoid HuSprZRotSet(short group, short member, float z_rot);\nvoid HuSprScaleSet(short group, short member, float x, float y);\nvoid HuSprTPLvlSet(short group, short member, float tp_lvl);\nvoid HuSprColorSet(short group, short member, u8 r, u8 g, u8 b);\nvoid HuSprSpeedSet(short group, short member, float speed);\nvoid HuSprBankSet(short group, short member, short bank);\nvoid HuSprGrpPosSet(short group, float x, float y);\nvoid HuSprGrpCenterSet(short group, float x, float y);\nvoid HuSprGrpZRotSet(short group, float z_rot);\nvoid HuSprGrpScaleSet(short group, float x, float y);\nvoid HuSprGrpTPLvlSet(short group, float tp_lvl);\nvoid HuSprGrpDrawNoSet(short group, int draw_no);\nvoid HuSprDrawNoSet(short group, short member, int draw_no);\nvoid HuSprPriSet(short group, short member, short prio);\nvoid HuSprGrpScissorSet(short group, short x, short y, short w, short h);\nvoid HuSprScissorSet(short group, short member, short x, short y, short w, short h);\nAnimData *HuSprAnimMake(short sizeX, short sizeY, short dataFmt);\nvoid HuSprBGSet(short group, short member, AnimData *bg, short bg_bank);\nvoid HuSprSprBGSet(short sprite, AnimData *bg, short bg_bank);\nvoid AnimDebug(AnimData *anim);\nvoid HuSprDispInit(void);\nvoid HuSprDisp(SpriteData *sprite);\nvoid HuSprTexLoad(AnimData *anim, short bmp, short slot, GXTexWrapMode wrap_s, GXTexWrapMode wrap_t, GXTexFilter filter);\nvoid HuSprExecLayerSet(short draw_no, short layer);\n\nextern GXRenderModeObj *RenderMode;\nextern OSHeapHandle currentHeapHandle;\n\nextern void *DemoFrameBuffer1;\nextern void *DemoFrameBuffer2;\nextern void *DemoCurrentBuffer;\nextern u32 minimumVcount;\nextern float minimumVcountf;\nextern u32 worstVcount;\n\nvoid HuSysInit(GXRenderModeObj *mode);\nvoid HuSysBeforeRender();\nvoid HuSysDoneRender(s32 retrace_count);\n\ntypedef struct particle_data {\n    char unk_00[0x44];\n    AnimData *unk_44;\n    char unk_48[0x10];\n} ParticleData;\n\ntypedef struct model_data {\n    u8 unk_00;\n    u8 unk_01;\n    u8 unk_02;\n    s8 unk_03;\n    s8 unk_04;\n    s8 unk_05;\n    s16 unk_06;\n    s16 unk_08;\n    s16 unk_0A;\n    s16 unk_0C;\n    s16 unk_0E;\n    s16 unk_10[4];\n    s16 unk_18[4];\n    s16 unk_20;\n    u16 unk_22;\n    s16 unk_24;\n    s16 unk_26;\n    char unk_28[0x10];\n    s16 unk_38[8];\n    HsfData *unk_48;\n    HsfData *unk_4C;\n    u32 attr;\n    u32 motion_attr;\n    Point3d unk_58;\n    f32 unk_64;\n    Point3d unk_68;\n    f32 unk_74;\n    char unk_78[0x1C];\n    f32 unk_94;\n    char unk_98[0x2C];\n    HsfData *hsfData;\n    HsfData *unk_C8;\n    Vec pos;\n    Vec rot;\n    Vec scale;\n    Mtx unk_F0;\n    ParticleData *unk_120;\n} ModelData;\ntypedef struct camera_data {\n    f32 fov;\n    f32 near;\n    f32 far;\n    f32 aspect;\n    f32 aspect_dupe;\n    Vec pos;\n    Vec up;\n    Vec target;\n    s16 scissor_x;\n    s16 scissor_y;\n    s16 scissor_w;\n    s16 scissor_h;\n    f32 viewport_x;\n    f32 viewport_y;\n    f32 viewport_w;\n    f32 viewport_h;\n    f32 near_z;\n    f32 far_z;\n} CameraData; // sizeof 0x58\ntypedef struct ThreeDProjectionStruct {\n    u8 unk_00;\n    char unk_01[0x3];\n    void *unk_04;\n    Vec unk_08;\n    Point3d unk_14;\n    Point3d unk_20;\n    Vec unk_2C;\n    Mtx unk_38;\n    Mtx unk_68;\n} ThreeDProjectionStruct;\ntypedef struct ThreeDShadowStruct {\n    char unk_00[0x2];\n    u16 unk_02;\n    void*unk_04;\n    char unk_08[0x90];\n} ThreeDShadowStruct;\ntypedef struct shadow_data {\n    char unk_00[0x2];\n    u16 unk_02;\n    void*unk_04;\n    char unk_08[0x90];\n} ShadowData;\ntypedef struct motion_data {\n    s16 unk_00;\n    s16 unk_02;\n    HsfData *unk_04;\n} MotionData;\ntypedef struct fog_data {\n    GXFogType fogType;\n    f32 start;\n    f32 end;\n    GXColor color;\n} FogStruct;\ntypedef struct light_data {\n    char unk_00[0x44];\n} LightData;\n\nvoid ClusterMotionExec(ModelData*);             /* extern */\nvoid ClusterProc(ModelData*);                   /* extern */\nvoid EnvelopeProc(HsfData*);                           /* extern */\nvoid GXWaitDrawDone();                                 /* extern */\nvoid Hu3DAnimExec();                                   /* extern */\nvoid Hu3DCameraMotionExec(s16);                        /* extern */\nvoid Hu3DDraw(ModelData*, f32*, f32*);          /* extern */\nvoid Hu3DDrawPost();                                   /* extern */\nvoid Hu3DDrawPreInit();                                /* extern */\nvoid Hu3DMotionNext(s16);                              /* extern */\nvoid Hu3DShadowExec();                                 /* extern */\nvoid Hu3DSubMotionExec(s16);                           /* extern */\nvoid HuPerfBegin(s32);                                   /* extern */\nvoid HuPerfEnd(s32);                                     /* extern */\nvoid HuSprBegin(void);                                     /* extern */\nvoid HuSprDispInit(void);                                  /* extern */\nvoid HuSprExec(s16);                                     /* extern */\nvoid HuSprFinish(void);                                    /* extern */\nvoid InitVtxParm(HsfData*);                            /* extern */\nvoid ShapeProc(HsfData*);                              /* extern */\nvoid mtxRot(Mtx, f32, f32, f32);                /* extern */\nvoid mtxScaleCat(Mtx, f32, f32, f32);           /* extern */\nvoid mtxTransCat(Mtx, f32, f32, f32);\nvoid Hu3DAnimInit(void);\nvoid Hu3DFogClear(void);\nvoid Hu3DLighInit(void);\nvoid Hu3DMotionInit(void);\nvoid Hu3DParManInit(void);\nvoid Hu3DFogSet(f32, f32, u8, u8, u8);                 /* extern */\nvoid Hu3DMotionClusterSet(s16, s16);                   /* extern */\nvoid Hu3DMotionExec(s16, s16, f32, s32);\nf32 Hu3DMotionMaxTimeGet(s16);                      /* extern */\ns16 Hu3DMotionModelCreate(s16);                     /* extern */\nvoid Hu3DMotionShapeSet(s16, s16);                     /* extern */\nHsfData* LoadHSF(s32);                              /* extern */\nvoid MakeDisplayList(s16, HsfData*);                   /* extern */\nvoid ClusterAdjustObject(HsfData*, HsfData*);          /* extern */\nHsfObject* Hu3DObjDuplicate(HsfData*, u32);         /* extern */\nvoid Hu3DAnimModelKill(s16);                           /* extern */\nvoid Hu3DGLightKill(s16);                              /* extern */\nvoid Hu3DLLightKill(s16, s16);                         /* extern */\ns32 Hu3DMotionKill(s16);\ns32 MakeObjectName(s32);\n\nvoid Hu3DInit(void);\nvoid Hu3DPreProc(void);\nvoid Hu3DExec(void);\nvoid Hu3DAllKill(void);\nvoid Hu3DBGColorSet(u8, u8, u8);\nvoid Hu3DLayerHookSet(s16, void (*)(s16));\nvoid Hu3DPauseSet(s32);\nvoid Hu3DNoSyncSet(s32);\ns16 Hu3DModelCreate(s32);\ns16 Hu3DModelLink(s16);\ns16 Hu3DHookFuncCreate(HsfData*);\nvoid Hu3DShadowSizeSet(u16);\nvoid Hu3DProjectionKill(s16);\nvoid Hu3DProjectionPosSet(s16, Vec, Vec, Vec);\nvoid Hu3DProjectionTPLvlSet(s16, f32);\nvoid Hu3DMipMapSet(char*, s16, s32, f32);\n\nvoid ClusterMotionExec(ModelData*);             /* extern */\nvoid ClusterProc(ModelData*);                   /* extern */\nvoid EnvelopeProc(HsfData*);                           /* extern */\nvoid GXWaitDrawDone();                                 /* extern */\nvoid Hu3DAnimExec();                                   /* extern */\nvoid Hu3DCameraMotionExec(s16);                        /* extern */\nvoid Hu3DDraw(ModelData*, f32*, f32*);          /* extern */\nvoid Hu3DDrawPost();                                   /* extern */\nvoid Hu3DDrawPreInit();                                /* extern */\nvoid Hu3DMotionNext(s16);                              /* extern */\nvoid Hu3DShadowExec();                                 /* extern */\nvoid Hu3DSubMotionExec(s16);                           /* extern */\nvoid HuPerfBegin(s32);                                   /* extern */\nvoid HuPerfEnd(s32);                                     /* extern */\nvoid HuSprBegin(void);                                     /* extern */\nvoid HuSprDispInit(void);                                  /* extern */\nvoid HuSprExec(s16);                                     /* extern */\nvoid HuSprFinish(void);                                    /* extern */\nvoid InitVtxParm(HsfData*);                            /* extern */\nvoid ShapeProc(HsfData*);                              /* extern */\nvoid mtxRot(Mtx, f32, f32, f32);                /* extern */\nvoid mtxScaleCat(Mtx, f32, f32, f32);           /* extern */\nvoid mtxTransCat(Mtx, f32, f32, f32);\nvoid Hu3DAnimInit(void);\nvoid Hu3DFogClear(void);\nvoid Hu3DLighInit(void);\nvoid Hu3DMotionInit(void);\nvoid Hu3DParManInit(void);\nvoid Hu3DFogSet(f32, f32, u8, u8, u8);                 /* extern */\nvoid Hu3DMotionClusterSet(s16, s16);                   /* extern */\nvoid Hu3DMotionExec(s16, s16, f32, s32);\nf32 Hu3DMotionMaxTimeGet(s16);                      /* extern */\ns16 Hu3DMotionModelCreate(s16);                     /* extern */\nvoid Hu3DMotionShapeSet(s16, s16);                     /* extern */\nHsfData* LoadHSF(s32);                              /* extern */\nvoid MakeDisplayList(s16, HsfData*);                   /* extern */\nvoid ClusterAdjustObject(HsfData*, HsfData*);          /* extern */\nHsfObject* Hu3DObjDuplicate(HsfData*, u32);         /* extern */\nvoid Hu3DAnimModelKill(s16);                           /* extern */\nvoid Hu3DGLightKill(s16);                              /* extern */\nvoid Hu3DLLightKill(s16, s16);                         /* extern */\ns32 Hu3DMotionKill(s16);\nvoid Hu3DModelKill(s16);\nvoid Hu3DParManAllKill(void);\ns32 MakeObjectName(s32);\n\nvoid Hu3DInit(void);\nvoid Hu3DPreProc(void);\nvoid Hu3DExec(void);\nvoid Hu3DAllKill(void);\nvoid Hu3DBGColorSet(u8, u8, u8);\nvoid Hu3DLayerHookSet(s16, void (*)(s16));\nvoid Hu3DPauseSet(s32);\nvoid Hu3DNoSyncSet(s32);\ns16 Hu3DModelCreate(s32);\ns16 Hu3DModelLink(s16);\ns16 Hu3DHookFuncCreate(HsfData*);\nvoid Hu3DModelAllKill(void);\nvoid Hu3DModelPosSet(s16, f32, f32, f32);\nvoid Hu3DModelPosSetV(s16, Vec);\nvoid Hu3DModelRotSet(s16, f32, f32, f32);\nvoid Hu3DModelRotSetV(s16, Vec);\nvoid Hu3DModelScaleSet(s16, f32, f32, f32);\nvoid Hu3DModelScaleSetV(s16, Vec);\nvoid Hu3DModelAttrSet(s16, u32);\nvoid Hu3DModelAttrReset(s16, u32);\nu32 Hu3DModelAttrGet(s16);\nu32 Hu3DModelMotionAttrGet(s16);\nvoid Hu3DModelClusterAttrSet(s16, s16, s32);\nvoid Hu3DModelClusterAttrReset(s16, s16, s32);\nvoid Hu3DModelCameraSet(s16, u16);\nvoid Hu3DModelLayerSet(s16, s16);\nHsfObject* Hu3DModelObjPtrGet(s16, s32);\nvoid Hu3DModelTPLvlSet(s16, f32);\nvoid Hu3DModelHiliteMapSet(s16, AnimData*);\nvoid Hu3DModelShadowSet(s16);\nvoid Hu3DModelShadowReset(s16);\nvoid Hu3DModelShadowDispOn(s16);\nvoid Hu3DModelShadowDispOff(s16);\nvoid Hu3DModelShadowMapSet(s16);\nvoid Hu3DModelShadowMapObjSet(s16, s32);\nvoid Hu3DModelAmbSet(s16, f32, f32, f32);\nvoid Hu3DModelHookSet(s16, s32, s16);\nvoid Hu3DModelHookReset(s16);\nvoid Hu3DModelHookObjReset(s16, s32);\nvoid Hu3DModelProjectionSet(s16, s16);\nvoid Hu3DModelProjectionReset(s16, s16);\nvoid Hu3DModelHiliteTypeSet(s16, s16);\nvoid Hu3DModelReflectTypeSet(s16, s16);\nvoid Hu3DCameraCreate(s32);\nvoid Hu3DCameraPerspectiveSet(s32, f32, f32, f32, f32);\nvoid Hu3DCameraViewportSet(s32, f32, f32, f32, f32, f32, f32);\nvoid Hu3DCameraScissorSet(s32, s32, s32, s32, s32);\nvoid Hu3DCameraPosSet(s32, f32, f32, f32, f32, f32, f32, f32, f32, f32);\nvoid Hu3DCameraPosSetV(s32, Vec, Vec, Vec);\nvoid Hu3DCameraKill(s32);\nvoid Hu3DCameraAllKill(void);\nvoid Hu3DCameraSet(s32, Mtx);\n//...\nvoid Hu3DShadowSizeSet(u16);\nvoid Hu3DProjectionKill(s16);\nvoid Hu3DProjectionPosSet(s16, Vec, Vec, Vec);\nvoid Hu3DProjectionTPLvlSet(s16, f32);\nvoid Hu3DMipMapSet(char*, s16, s32, f32);\n    \nextern MotionData Hu3DMotion[0x100];\nextern CameraData defCamera;\nextern f32 lbl_801D4AB0;\nextern f32 lbl_801D4AB4;\nextern f32 lbl_801D4AB8;\nextern f32 lbl_801D4AFC;\nextern GXColor lbl_801D6BE0;\nextern u32 totalMatCnt;\nextern u32 totalMatCnted;\nextern u32 totalPolyCnt;\nextern u32 totalTexCacheCnt;\nextern u32 totalTexCacheCnted;\nextern u32 totalTexCnt;\nextern u32 totalTexCnted;\n\nModelData Hu3DData[0x200];\nCameraData Hu3DCamera[0x10];\ns16 layerNum[8];\nvoid (*layerHook[8])(s16);\nAnimData *reflectAnim[5];\nAnimData *hiliteAnim[4];\nThreeDProjectionStruct Hu3DProjection[4];\nShadowData Hu3DShadowData;\nHsfScene FogData;\nMtx Hu3DCameraMtx;\nLightData Hu3DGlobalLight[0x8];\nMtx Hu3DCameraMtxXPose;\nLightData Hu3DLocalLight[0x20];\nGXColor BGColor;\ns16 reflectMapNo;\nAnimData *toonAnim;\ns16 Hu3DShadowCamBit;\ns32 Hu3DShadowF;\ns32 shadowModelDrawF;\ns16 Hu3DProjectionNum;\ns16 Hu3DCameraNo;\ns16 Hu3DCameraBit;\nHsfData* Hu3DMallocNo;\ns16 Hu3DPauseF;\ns16 Hu3DCameraExistF;\nu16 NoSyncF;\ns32 modelKillAllF;\n\n\n\n    \ntypedef struct jump_buf {\n    u32 lr;\n    u32 cr;\n    u32 sp;\n    u32 r2;\n    u32 pad;\n    u32 regs[19];\n    double flt_regs[19];\n} jmp_buf;\n\ntypedef struct process {\n    struct process *next;\n    struct process *prev;\n    struct process *child;\n    struct process *parent;\n    struct process *next_child;\n    struct process *first_child;\n    void *heap;\n    u16 exec;\n    u16 stat;\n    u16 prio;\n    int sleep_time;\n    u32 base_sp;\n    jmp_buf jump;\n    void (*dtor)(void);\n    void *user_data;\n} Process;\n\ntypedef void (*omObjFunc)(struct om_obj_data *);\ntypedef enum {\n    OVL_INVALID = -1,\n    OVL_COUNT\n} OverlayID;\ntypedef struct om_ovl_his_data {\n    OverlayID overlay;\n    int event;\n    int stat;\n} omOvlHisData;\n\ntypedef struct om_obj_data {\n    u16 stat;\n    s16 next_idx_alloc;\n    s16 prio;\n    s16 prev;\n    s16 next;\n    s16 next_idx;\n    s16 group;\n    u16 group_idx;\n    int unk10;\n    omObjFunc func;\n    Vec trans;\n    Vec rot;\n    Vec scale;\n    u16 mdlcnt;\n    s16 *model;\n    u16 mtncnt;\n    s16 *motion;\n    int work[4];\n    void *data;\n} omObjData;\n\ns32 HuAudFXEmiterPlay(s32 arg0, Vec *arg1);\nvoid HuAudFXListnerSetEX(Vec* arg0, Vec* arg1, float sndDist, float sndSpeed, float arg4, float arg5, float arg6);\nvoid HuAudFXPauseAll(s32 arg0);\ns32 HuAudFXVolSet(s32 arg0, s16 arg1);\nvoid fn_8005D530(Vec*);                                  /* extern */\nvoid fn_8005D628(Vec*);                                  /* extern */\nomObjData *omAddObjEx(Process *objman_process, s16 prio, u16 mdlcnt, u16 mtncnt, s16 group, void (*func)(omObjData *));\nvoid fn_1_10E4(omObjData*);\nomObjData* lbl_1_bss_4;\nextern s32 lbl_1_bss_8;\nextern s32 lbl_1_data_21C[];\nextern Vec lbl_1_data_22C[];\nextern s32 lbl_1_data_25C[];\nextern s32 lbl_1_data_26C[];\nextern Process* lbl_801D3ED4;\n\ntypedef struct w03UnkStruct2{\n    u8 unk0 : 1;\n} w03UnkStruct2;\n    \nvoid HuAudFXFadeOut(s32 arg0, s32 arg1);\nvoid HuAudFXListnerUpdate(Vec* arg0, Vec* arg1);\nvoid HuAudFXPauseAll(s32 arg0);\ns32 HuAudFXVolSet(s32 arg0, s16 arg1);\nProcess *HuPrcCurrentGet(void);\nvoid fn_8005D578(Vec*);                                  /* extern */\nvoid fn_8005D628(Vec*);                                  /* extern */\nvoid omDelObjEx(Process *objman_process, omObjData *object);\n\nextern s32 lbl_1_bss_8;\nextern s32 lbl_1_data_21C[];\nextern f32 lbl_1_rodata_30;\nvoid fn_1_10E4(omObjData* arg0);\nProcess *HuPrcChildCreate(void (*func)(void), u16 prio, u32 stack_size, s32 extra_size, Process *parent);\nvoid HuPrcDestructorSet2(Process *process, void (*func)(void));\nvoid HuPrcVSleep(void);\ns32 fn_800688E8(s32);\nvoid fn_1_1358(void);\nvoid fn_1_152C(void);\nextern Process* lbl_1_bss_28;\nextern Process* lbl_801D3ED0;\n    ///////////////////////////////////////\n\ntypedef struct w03StructUnk0 {\n/* 0x00 */ Vec unk_00;\n/* 0x0C */ Vec unk_0C;\n/* 0x18 */ Vec unk_18;\n/* 0x24 */ s32 datanum;\n} w03StructUnk0;\n\ntypedef struct w03StructUnk1 {\n    f32 unk_00;\n    f32 unk_04;\n    f32 unk_08;\n    f32 unk_0C;\n    f32 unk_10;\n    f32 unk_14;\n    f32 unk_18;\n    f32 unk_1C;\n} w03StructUnk1;\n\nvoid fn_1_3058(void);\nvoid fn_1_63F4(s32);\nvoid fn_1_6494(void);\nvoid fn_1_785C(void);\nvoid fn_1_7ABC(void);\nvoid fn_1_9A7C(void);\nvoid fn_1_CF4(void);\nvoid fn_1_DEC(void);\nvoid fn_80064338(s32, void*);\nvoid fn_80064D84(s32);\nvoid fn_8006E0B0(s16, s32, s32);\nvoid fn_1_2930(void);\nvoid fn_1_884(void);\nvoid fn_1_8F0(void);\ns32 fn_1_910(void);\nvoid fn_1_A74(void);\nvoid fn_1_AF8(void);\nextern w03State* lbl_1_bss_0;\ns16 lbl_1_bss_C[];\nextern w03StructUnk0 lbl_1_data_0[0x0C];\nextern s16 lbl_1_data_1E0;\nextern s16 lbl_1_data_1E2;\nextern s16 lbl_1_data_1E4;\nextern s16 lbl_1_data_1E6;\nextern s16 lbl_1_data_1E8;\nextern w03StructUnk1 lbl_1_data_1EC;\nextern Vec lbl_1_data_20C;\nextern Vec lbl_1_data_214;\nextern f32 lbl_1_rodata_10;\nextern f32 lbl_1_rodata_14;\n\nvoid fn_1_10B0(void);                                      /* extern */\nvoid fn_1_7B58(void);                                      /* extern */\nvoid fn_1_9A9C(void);                                      /* extern */\n\ns32 fn_1_309C(void);\ns32 fn_1_675C(void);\ns32 fn_8006413C(s32);\nu32 fn_80074138(s32, s32);\n\nvoid fn_1_7BA8(void);\nvoid fn_1_9AA0(void);\nu32 fn_80074138(s32, s32);\n\nvoid HuPrcVSleep(void);\nvoid fn_8006E5C4(s16, s32);\nvoid fn_8006E674(s16, f32);\nf32 fn_8006E6F8(s16);\n\ntypedef struct space_data {\n    /* 0x00 */ float x_pos;\n    /* 0x04 */ float y_pos;\n    /* 0x08 */ float z_pos;\n    /* 0x0C */ s32 flag;\n    /* 0x10 */ float x_scale;\n    /* 0x14 */ float y_scale;\n    /* 0x18 */ float z_scale;\n    /* 0x1C */ float x_rot;\n    /* 0x20 */ float y_rot;\n    /* 0x24 */ float z_rot;\n    /* 0x28 */ u16 type;\n    /* 0x2A */ u16 num_links;\n    /* 0x2C */ u16 links[6];\n} spaceData; //sizeof 0x38\n\nspaceData SpaceData[2][256];\n\nextern s16 lbl_801D3FE4[2];\n\nvoid fn_80064D94(s32);\ns32 fn_800740B4(s32);\nspaceData* fn_800740C4(s32, s32);\nu32 fn_80074138(s32, s32);\n\nProcess *HuPrcChildCreate(void (*func)(void), u16 prio, u32 stack_size, s32 extra_size, Process *parent);\nvoid HuPrcDestructorSet2(Process *process, void (*func)(void));\nvoid HuPrcVSleep(void);\ns32 fn_800688E8(s32);\nvoid fn_1_1358(void);\nvoid fn_1_152C(void);\nextern Process* lbl_1_bss_28;\nextern Process* lbl_801D3ED0;\n\ntypedef struct {\n    char gpr;\n    char fpr;\n    char reserved[2];\n    char* input_arg_area;\n    char* reg_save_area;\n} __va_list[1];\ntypedef __va_list va_list;\n\nvoid* __va_arg(va_list v_list, unsigned char type);\n\n#define va_start(ap, fmt) ((void) fmt, __builtin_va_info(&ap))\n#define va_arg(ap, t) (*((t*) __va_arg(ap, _var_arg_typeof(t))))\n#define va_end(ap) (void) 0\n\nint puts(const char* s);\nint printf(const char*, ...);\n// int sprintf(char* s, const char* format, ...);\nint vprintf(const char* format, va_list arg);\nint vsprintf(char* s, const char* format, va_list arg);\n\nvoid HuPrcEnd(void);                                       /* extern */\ns32 fn_1_1650(s32);                                  /* extern */\ns32 fn_1_1D1C(void);                                    /* extern */\nvoid fn_1_1ED4(s32);                                    /* extern */\nvoid fn_1_20E0(s32);                                    /* extern */\nvoid fn_1_26E0(s32);                                    /* extern */\nvoid fn_80064350(s32, void*);                              /* extern */\nvoid fn_800706D0(char*, s32);                               /* extern */\nvoid fn_1_15E8(void);\nextern s8 lbl_1_bss_2C;\nchar lbl_1_bss_44[4];\nextern s16 lbl_1_bss_6C;\nextern s8 lbl_1_bss_6E;\ns32 fn_1_12C8(void);", "diff_flags": [], "diff_label": "ShyGuyBoard", "libraries": []}