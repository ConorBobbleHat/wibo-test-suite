{"compiler": "prodg_393", "compiler_flags": "-O2 -gdwarf -mps-float", "source_code": "/*\nDecompilation failure:\n\nunsupported non-nop instruction outside of function (psq_l $f13, ($r6), 0x1, qr0)\n*/\n\n\n\ntypedef struct nuvec_s {\n    float x, y, z;\n} nuvec_s;\n\ntypedef struct Matrix {\n    sn_ps m00m01;\n    sn_ps m02m03;\n    sn_ps m10m11;\n    sn_ps m12m13;\n    sn_ps m20m21;\n    sn_ps m22m23;\n} Matrix;\n\nvoid VecMatMulAndWeight(nuvec_s* r3, nuvec_s* r4, Matrix* r5, nuvec_s* r6) {\n    // ps0 = ps_l(r6, 1, 0);\n    r3->x = ps_l(r6, 1, 0) + ps_l(r4, 0, 0) * r5->m00m01;\n    // ps_st(ps_l(r6, 1, 0), 0, r3, 0);\n}\n", "context": "\n\n// \n// Some basic Paired Single (PS) definitions\n//\n\n\n// simple PS type\ntypedef float sn_ps __attribute__((mode(PS))) ; \n\n// unioned ps with float type\n\ntypedef union SN_PS_type\n{\n  sn_ps ps ;\n  struct tflt\n  {\n    float hi, lo ;\n#ifndef __cplusplus\n  } flt ;\n#else\n} ;\n  tflt flt ;\n#endif\n} ;\n\n// Quantization Registers and handling\n\n// the registers\n#define GQR0 912\n#define GQR1 913\n#define GQR2 914\n#define GQR3 915\n#define GQR4 916\n#define GQR5 917\n#define GQR6 918\n#define GQR7 919\n\n// the type field\n#define GQR_SCALE_F32 0x0\n#define GQR_SCALE_U8  0x4\n#define GQR_SCALE_U16 0x5\n#define GQR_SCALE_S8  0x6\n#define GQR_SCALE_S16 0x7\n\n// some ps operations\n\n// Build two floats into a PS variable. \n// e.g.  ps = PS_BUILD(0.0f,1.0f) ;\n#define PS_BUILD(hi,lo) *(sn_ps*)(float[]){(lo),(hi)}\n\n\n// =============================================================\n// SNAPS - The SN API for PS definitions\n//\n\n// 1 result, 1 argument opcodes\n#define ps_neg(x)     __builtin_ps_neg(x)\n#define ps_abs(x)     __builtin_ps_abs(x)\n#define ps_nabs(x)    __builtin_ps_nabs(x)\n#define ps_res(x)     __builtin_ps_res(x)\n#define ps_rsqrte(x)  __builtin_ps_rsqrte(x)\n\n// 1 result, 2 argument opcodes\n#define ps_add(x,y)         __builtin_ps_add(x,y)\n#define ps_sub(x,y)         __builtin_ps_sub(x,y)\n#define ps_div(x,y)         __builtin_ps_div(x,y)\n#define ps_mul(x,y)         __builtin_ps_mul(x,y)\n#define ps_merge00(x,y)     __builtin_ps_merge00(x,y)\n#define ps_merge01(x,y)     __builtin_ps_merge01(x,y)\n#define ps_merge10(x,y)     __builtin_ps_merge10(x,y)\n#define ps_merge11(x,y)     __builtin_ps_merge11(x,y)\n#define ps_muls0(x,y)       __builtin_ps_muls0(x,y)\n#define ps_muls1(x,y)       __builtin_ps_muls1(x,y)\n\n// 1 result, 3 argument opcodes\n#define ps_madd(x,y,z)      __builtin_ps_madd(x,y,z)\n#define ps_msub(x,y,z)      __builtin_ps_msub(x,y,z)\n#define ps_nmadd(x,y,z)     __builtin_ps_nmadd(x,y,z)\n#define ps_nmsub(x,y,z)     __builtin_ps_nmsub(x,y,z)\n#define ps_sum0(x,y,z)      __builtin_ps_sum0(x,y,z)\n#define ps_sum1(x,y,z)      __builtin_ps_sum1(x,y,z)\n#define ps_madds0(x,y,z)    __builtin_ps_madds0(x,y,z)\n#define ps_madds1(x,y,z)    __builtin_ps_madds1(x,y,z)\n#define ps_sel(x,y,z)       __builtin_ps_sel(x,y,z)\n\n// load and stores \n// (NB. Should normally only be used for scaled and/or conversion load/stores. The compiler\n//  will generate non-scaled/converted loads and stores for you.)\n\n#define ps_l(v,w,i)         __builtin_psq_l(v,w,i)\n#define ps_lu(v,w,i)        __builtin_psq_lu(v,w,i)\n#define ps_lx(v,o,w,i)      __builtin_psq_lx(v,o,w,i)\n#define ps_lux(v,o,w,i)     __builtin_psq_lux(v,o,w,i)\n\n#define ps_st(d,v,w,i)      __builtin_psq_st(d,v,w,i) \n#define ps_stu(d,v,w,i)     __builtin_psq_stu(d,v,w,i)\n#define ps_stx(d,v,o,w,i)   __builtin_psq_stx(d,v,o,w,i)\n#define ps_stux(d,v,o,w,i)  __builtin_psq_stux(d,v,o,w,i)\n\n", "diff_flags": [], "diff_label": "VecMatMulAndWeight", "libraries": []}