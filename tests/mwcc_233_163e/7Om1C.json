{"compiler": "mwcc_233_163e", "compiler_flags": "-lang=c -Cpp_exceptions off -nodefaults -O4,p -fp hard -str reuse -maxerrors 1 -enum int", "source_code": "static void __GXXfVtxSpecs(void)\n{\n\tu32 colorCount, normCount, texCount;\n\n\tnormCount = gx->hasBiNrms ? 2 : (gx->hasNrms ? 1 : 0);\n\n\t// Both fields in one access\n\tcolorCount = 33 - __cntlzw(GX_GET_REG(gx->vcdLo, GX_CP_VCD_LO_CLRSPEC_ST, GX_CP_VCD_LO_CLRDIF_END));\n\tcolorCount /= 2; // equivalent to /=2 and >>= 1\n\n\t// All 16 assigned bits in VCD_Hi\n\t// regswap here\n    texCount = 33 - __cntlzw(GX_GET_REG(gx->vcdHi, GX_CP_VCD_HI_TEX7COORD_ST, GX_CP_VCD_HI_TEX0COORD_END));\n\ttexCount /= 2; // equivalent to /=2 and >>= 1\n\n\tGX_XF_LOAD_REG(GX_XF_REG_INVERTEXSPEC, colorCount | normCount << 2 | texCount << 4);\n\tgx->bpSentNot = GX_TRUE;\n}", "context": "/* \"src\\Dolphin\\gx\\GXAttr.c\" line 0 \"Dolphin/gx.h\" */\n#ifndef _DOLPHIN_GX_H\n#define _DOLPHIN_GX_H\n\n/* \"include\\Dolphin\\gx.h\" line 3 \"types.h\" */\n#ifndef _TYPES_H\n#define _TYPES_H\n\n/* \"include\\types.h\" line 3 \"BuildSettings.h\" */\n#ifndef _BUILDSETTINGS_H\n#define _BUILDSETTINGS_H\n\n// TODO: These should probably go into a precompiled header or build flags or\n// something.\n#define LOCALIZED true\n#define MATCHING  true\n\n#define USADEMO1 1\n#define USAFINAL 2\n\n#if VERNUM == USAFINAL\n#define BUILDTARGET USAFINAL\n#elif VERNUM == USADEMO1\n#define BUILDTARGET USADEMO1\n#endif\n\n// The following are constants that mods might be interested in tweaking.\n#define GENERATOR_CACHE_HEAP_SIZE 0xA000\n#define CHALLENGE_COURSE_COUNT    30\n\n#endif\n/* end \"BuildSettings.h\" */\n\n// r2 is  8051E360\n// r13 is 8051C680\n\ntypedef int BOOL;\n\ntypedef signed char s8;\ntypedef signed short s16;\ntypedef signed long s32;\ntypedef signed long long s64;\ntypedef unsigned char u8;\ntypedef unsigned short u16;\ntypedef unsigned int uint;\ntypedef unsigned long u32;\ntypedef unsigned long size_t;\ntypedef unsigned long long u64;\n\ntypedef volatile u8 vu8;\ntypedef volatile u16 vu16;\ntypedef volatile u32 vu32;\ntypedef volatile u64 vu64;\ntypedef volatile s8 vs8;\ntypedef volatile s16 vs16;\ntypedef volatile s32 vs32;\ntypedef volatile s64 vs64;\n\ntypedef float f32;\ntypedef double f64;\ntypedef volatile f32 vf32;\ntypedef volatile f64 vf64;\n\ntypedef u32 unknown;\n\n#ifndef __cplusplus\ntypedef unsigned short wchar_t;\n#endif\n\n// Basic defines to allow newer-like C++ code to be written\n#define TRUE  1\n#define FALSE 0\n#define NULL  ((void*)0)\n#define nullptr 0\n\n// Sets specific flag to 1\n#define SET_FLAG(x, val) (x |= (val))\n\n// Resets specific flag from (val) back to 0\n#define RESET_FLAG(x, val) (x &= ~(val))\n\n// Return 1 if flag is set, 0 if flag is not set\n#define IS_FLAG(x, val) (x & val)\n\n// Array size define\n#define ARRAY_SIZE(o) (sizeof((o)) / sizeof(*(o)))\n\n// Align X to the previous N bytes (N must be power of two)\n#define ALIGN_PREV(X, N) ((X) & ~((N)-1))\n\n// Align X to the next N bytes (N must be power of two)\n#define ALIGN_NEXT(X, N) ALIGN_PREV(((X) + (N)-1), N)\n\n// True if X is aligned to N bytes, else false\n#define IS_ALIGNED(X, N) ((X & ((N)-1)) == 0)\n\n// True if X is not aligned to N bytes, else false\n#define IS_NOT_ALIGNED(X, N) (((X) & ((N)-1)) != 0)\n\n// Align object to num bytes (num should be power of two)\n#define ATTRIBUTE_ALIGN(num) __attribute__((aligned(num)))\n\n// Checks if a flag is set in a bitfield\n#define IS_FLAG_SET(flags, bitsFromLSB) (((flags) >> (bitsFromLSB)&1))\n\n// For functions that return 0 on a success and -1 on failure\n#define EXIT_SUCCESS 0\n#define EXIT_FAILURE -1\n\n#define ASSERT_HANG(cond) \\\n\tif (!(cond)) {        \\\n\t\twhile (true) { }  \\\n\t}\n\n// Get the maximum of two values\n#define MAX(a, b) (((a) > (b)) ? (a) : (b))\n\n// Get the minimum of two values\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n\n// Rounds a float to a u8\n#define ROUND_F32_TO_U8(a) a >= 0.0f ? a + 0.5f : a - 0.5f\n\n// Number of bytes in a kilobyte\n#define KILOBYTE_BYTECOUNT 1024\n\n#ifdef __MWERKS__\n#define WEAKFUNC __declspec(weak)\n#else\n#define WEAKFUNC ;\n#endif\n\n#endif\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\gx.h\" line 9 \"Dolphin/vi.h\" */\n#ifndef _DOLPHIN_VI_H\n#define _DOLPHIN_VI_H\n\n/* \"include\\Dolphin\\vi.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n////// VIDEO INTERFACE DEFINES /////\n// Display pixel size.\n#define VI_DISPLAY_PIX_SZ (2)\n\n// Interlacing types\n#define VI_INTERLACE     (0)\n#define VI_NON_INTERLACE (1)\n#define VI_PROGRESSIVE   (2)\n#define VI_3D            (3)\n\n// Video output formats\n#define VI_NTSC      (0)\n#define VI_PAL       (1)\n#define VI_MPAL      (2)\n#define VI_DEBUG     (3)\n#define VI_DEBUG_PAL (4)\n#define VI_EURGB60   (5)\n#define VI_GCA       (6)\n\n// Conversion to TVMode used in enums\n#define VI_TVMODE(FMT, INT) (((FMT) << 2) + (INT))\n\n// Fields\n#define VI_FIELD_ABOVE (1)\n#define VI_FIELD_BELOW (0)\n\n// Max screen dimensions\n// NTSC\n#define VI_MAX_WIDTH_NTSC  (720)\n#define VI_MAX_HEIGHT_NTSC (480)\n\n// PAL\n#define VI_MAX_WIDTH_PAL  (720)\n#define VI_MAX_HEIGHT_PAL (574)\n\n// MPAL\n#define VI_MAX_WIDTH_MPAL  (720)\n#define VI_MAX_HEIGHT_MPAL (480)\n\n// EU RGB60 (same as NTSC)\n#define VI_MAX_WIDTH_EURGB60  VI_MAX_WIDTH_NTSC\n#define VI_MAX_HEIGHT_EURGB60 VI_MAX_HEIGHT_NTSC\n\n// Conversion to padded FB width from screen width\n#define VIPadFrameBufferWidth(width) ((u16)(((u16)(width) + 15) & ~15))\n\n////////////////////////////////////\n\n/////// VIDEO INTERFACE TYPES //////\n// Retrace callback function type.\ntypedef void (*VIRetraceCallback)(u32 retraceCount);\n\n// Position callback function type.\ntypedef void (*VIPositionCallback)(s16 x, s16 y);\n\n// TV Modes\ntypedef enum {\n\t// NTSC\n\tVI_TVMODE_NTSC_INT  = VI_TVMODE(VI_NTSC, VI_INTERLACE),     // 0\n\tVI_TVMODE_NTSC_DS   = VI_TVMODE(VI_NTSC, VI_NON_INTERLACE), // 1\n\tVI_TVMODE_NTSC_PROG = VI_TVMODE(VI_NTSC, VI_PROGRESSIVE),   // 2\n\tVI_TVMODE_NTSC_3D   = VI_TVMODE(VI_NTSC, VI_3D),            // 3\n\n\t// PAL\n\tVI_TVMODE_PAL_INT = VI_TVMODE(VI_PAL, VI_INTERLACE),     // 4\n\tVI_TVMODE_PAL_DS  = VI_TVMODE(VI_PAL, VI_NON_INTERLACE), // 5\n\n\t// MPAL\n\tVI_TVMODE_MPAL_INT = VI_TVMODE(VI_MPAL, VI_INTERLACE),     // 8\n\tVI_TVMODE_MPAL_DS  = VI_TVMODE(VI_MPAL, VI_NON_INTERLACE), // 9\n\n\t// Debug\n\tVI_TVMODE_DEBUG_INT = VI_TVMODE(VI_DEBUG, VI_INTERLACE), // 12\n\n\t// Debug PAL\n\tVI_TVMODE_DEBUG_PAL_INT = VI_TVMODE(VI_DEBUG_PAL, VI_INTERLACE),     // 16\n\tVI_TVMODE_DEBUG_PAL_DS  = VI_TVMODE(VI_DEBUG_PAL, VI_NON_INTERLACE), // 17\n\n\t// EU RGB60\n\tVI_TVMODE_EURGB60_INT = VI_TVMODE(VI_EURGB60, VI_INTERLACE),     // 20\n\tVI_TVMODE_EURGB60_DS  = VI_TVMODE(VI_EURGB60, VI_NON_INTERLACE), // 21\n\n\t// GCA\n\tVI_TVMODE_GCA_INT  = VI_TVMODE(VI_GCA, VI_INTERLACE),     // 24\n\tVI_TVMODE_GCA_DS   = VI_TVMODE(VI_GCA, VI_NON_INTERLACE), // 25\n\tVI_TVMODE_GCA_PROG = VI_TVMODE(VI_GCA, VI_PROGRESSIVE),   // 26\n} VITVMode;\n\n// External frame buffer modes (single and double?)\ntypedef enum {\n\tVI_XFBMODE_SF = 0,\n\tVI_XFBMODE_DF = 1,\n} VIXFBMode;\n\n// Structure to use with timing in vi.c (size 0x28).\ntypedef struct VITimingInfo {\n\tu8 equ;           // _00\n\tu16 acv;          // _02\n\tu16 prbOdd;       // _04\n\tu16 prbEven;      // _06\n\tu16 psbOdd;       // _08\n\tu16 psbEven;      // _0A\n\tu8 bs1;           // _0C\n\tu8 bs2;           // _0D\n\tu8 bs3;           // _0E\n\tu8 bs4;           // _0F\n\tu16 be1;          // _10\n\tu16 be2;          // _12\n\tu16 be3;          // _14\n\tu16 be4;          // _16\n\tu16 numHalfLines; // _18\n\tu16 hlw;          // _1A\n\tu8 hsy;           // _1C\n\tu8 hcs;           // _1D\n\tu8 hce;           // _1E\n\tu8 hbe640;        // _1F\n\tu16 hbs640;       // _20\n\tu8 hbeCCIR656;    // _24\n\tu16 hbsCCIR656;   // _26\n} VITimingInfo;\n\n// Structure to use with HorVer in vi.c (size 0x58).\ntypedef struct VIPositionInfo {\n\tu16 dispPosX;         // _00\n\tu16 dispPosY;         // _02\n\tu16 dispSizeX;        // _04\n\tu16 dispSizeY;        // _06\n\tu16 adjDispPosX;      // _08\n\tu16 adjDispPosY;      // _0A\n\tu16 adjDispSizeY;     // _0C\n\tu16 adjPanPosY;       // _0E\n\tu16 adjPanSizeY;      // _10\n\tu16 fbSizeX;          // _12\n\tu16 fbSizeY;          // _14\n\tu16 panPosX;          // _16\n\tu16 panPosY;          // _18\n\tu16 panSizeX;         // _1A\n\tu16 panSizeY;         // _1C\n\tVIXFBMode xfbMode;    // _20\n\tu32 nonInter;         // _24\n\tu32 tv;               // _28\n\tu8 wordPerLine;       // _2C\n\tu8 std;               // _2D\n\tu8 wpl;               // _2E\n\tu32 bufAddr;          // _30\n\tu32 tfbb;             // _34\n\tu32 bfbb;             // _38\n\tu8 xof;               // _3C\n\tBOOL isBlack;         // _40\n\tBOOL is3D;            // _44\n\tu32 rbufAddr;         // _48\n\tu32 rtfbb;            // _4C\n\tu32 rbfbb;            // _50\n\tVITimingInfo* timing; // _54\n} VIPositionInfo;\n\n////////////////////////////////////\n\n///// VIDEO INTERFACE FUNCTIONS ////\n// Basic VI functions.\nvoid VIInit(void);\nvoid VIFlush(void);\nvoid VIWaitForRetrace(void);\n\n// Configure functions.\nvoid VIConfigure(const struct _GXRenderModeObj* obj);\n\n// Retrace callbacks.\nVIRetraceCallback VISetPreRetraceCallback(VIRetraceCallback callback);\nVIRetraceCallback VISetPostRetraceCallback(VIRetraceCallback callback);\n\n// Getters and setters\nvoid VISetNextFrameBuffer(void* fb);\nvoid* VIGetCurrentFrameBuffer();\n\nvoid __VIGetCurrentPosition(s16* x, s16* y);\n\nvoid VISetBlack(BOOL isBlack);\n\nu32 VIGetRetraceCount(void);\nu32 VIGetNextField(void);\nu32 VIGetCurrentLine(void);\nu32 VIGetTvFormat(void);\n\nu32 VIGetDTVStatus(void);\n\n// Unused/stripped in P2.\nvoid VIConfigurePan(u16 panPosX, u16 panPosY, u16 panSizeX, u16 panSizeY);\nvoid* VIGetNextFrameBuffer();\nvoid VISetNextRightFrameBuffer(void* fb);\nvoid VISet3D(); // unsure on arguments\n\n////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/vi.h\" */\n/* \"include\\Dolphin\\gx.h\" line 10 \"Dolphin/mtx.h\" */\n#ifndef _DOLPHIN_MTX_H\n#define _DOLPHIN_MTX_H\n\n/* \"include\\Dolphin\\mtx.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\mtx.h\" line 9 \"Dolphin/vec.h\" */\n#ifndef _DOLPHIN_VEC_H\n#define _DOLPHIN_VEC_H\n\n/* \"include\\Dolphin\\vec.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\ntypedef struct Vec {\n\tf32 x;\n\tf32 y;\n\tf32 z;\n} Vec;\n\nvoid PSVECAdd(const Vec*, const Vec*, Vec*);\nvoid PSVECSubtract(const Vec*, const Vec*, Vec*);\nvoid PSVECNormalize(const Vec*, Vec*);\nf32 PSVECMag(const Vec*);\nvoid PSVECCrossProduct(const Vec*, const Vec*, Vec*);\n\n#ifdef __cplusplus\n}\n#endif\n\n//  lfs     f1,0(r3)\n//  lfs     f0,4(r3)\n//  fmuls   f1,f1,f1\n//  lfs     f2,8(r3)\n//  fmuls   f0,f0,f0\n//  fmuls   f2,f2,f2\n//  fadds   f0,f1,f0\n//  fadds   f1,f2,f0\n//  blr\n\n#endif\n/* end \"Dolphin/vec.h\" */\n\n/////////////// TYPE DEFINES ///////////////\n#define MTXDegToRad(a) ((a)*0.01745329252f)\n\ntypedef f32 Mtx[3][4];\ntypedef f32 Mtx23[2][3];\ntypedef f32 Mtx33[3][3];\ntypedef f32 Mtx44[4][4];\ntypedef f32 (*MtxP)[4];\ntypedef f32 PSQuaternion[4];\n\ntypedef struct Quaternion {\n\tf32 x, y, z, w;\n} Quaternion;\n\n////////////////////////////////////////////\n\n////// PAIRED SINGLE MATRIX FUNCTIONS //////\nvoid PSMTXIdentity(Mtx mtx);\nvoid PSMTXCopy(const Mtx src, Mtx dest);\nvoid PSMTXConcat(const Mtx A, const Mtx B, Mtx concat);\n\nvoid PSMTXTranspose(const Mtx src, Mtx xPose);\nu32 PSMTXInverse(const Mtx src, Mtx inv);\n\nvoid __PSMTXRotAxisRadInternal(Mtx mtx, const Vec* axis, f32 sinA, f32 cosA);\nvoid PSMTXRotRad(Mtx mtx, char axis, f32 angle);\nvoid PSMTXRotTrig(Mtx mtx, char axis, f32 sinA, f32 cosA);\nvoid PSMTXRotAxisRad(Mtx mtx, const Vec* axis, f32 angle);\n\nvoid PSMTXTrans(Mtx mtx, f32 xT, f32 yT, f32 zT);\nvoid PSMTXTransApply(const Mtx src, Mtx dest, f32 xT, f32 yT, f32 zT);\n\nvoid PSMTXScale(Mtx mtx, f32 xS, f32 yS, f32 zS);\nvoid PSMTXScaleApply(const Mtx src, Mtx dest, f32 xS, f32 yS, f32 zS);\nvoid PSMTXQuat(Mtx mtx, const PSQuaternion* quat);\n\n////////////////////////////////////////////\n\n//// PAIRED SINGLE MATRIX VEC FUNCTIONS ////\nvoid PSMTXMultVec(const Mtx, const Vec*, Vec*);\nvoid PSMTXMultVecSR(const Mtx, const Vec*, Vec*);\nvoid PSMTXMultVecArraySR(const Mtx, f32*, f32*, f32*);\n\n////////////////////////////////////////////\n\n///////////  MATRIX44 FUNCTIONS ////////////\nvoid PSMTX44Copy(Mtx44 src, Mtx44 dest);\nvoid C_MTXPerspective(Mtx44 mtx, f32 fovY, f32 aspect, f32 n, f32 f);\nvoid C_MTXOrtho(Mtx44 mtx, f32 t, f32 b, f32 l, f32 r, f32 n, f32 f);\n////////////////////////////////////////////\n\n///////// CODED C MATRIX FUNCTIONS /////////\nvoid C_MTXLookAt(Mtx, const Vec*, const Vec*, const Vec*);\nvoid C_MTXLightPerspective(Mtx mtx, f32 fovY, f32 aspect, f32 scaleS, f32 scaleT, f32 transS, f32 transT);\nvoid C_MTXLightOrtho(Mtx mtx, f32 t, f32 b, f32 l, f32 r, f32 scaleS, f32 scaleT, f32 transS, f32 transT);\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n/* end \"Dolphin/mtx.h\" */\n/* \"include\\Dolphin\\gx.h\" line 11 \"Dolphin/GX/GXEnum.h\" */\n#ifndef _DOLPHIN_GXENUM_H\n#define _DOLPHIN_GXENUM_H\n\n/* \"include\\Dolphin\\GX\\GXEnum.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n////////////////// BASICS //////////////////\n// Set up custom GX bool\ntypedef u8 GXBool;\n\n#define GX_TRUE    ((GXBool)1)\n#define GX_FALSE   ((GXBool)0)\n#define GX_ENABLE  ((GXBool)1)\n#define GX_DISABLE ((GXBool)0)\n\n#define GX_LARGE_NUMBER 1.0e+18f;\n\n// Logical comparison operators.\ntypedef enum _GXCompare {\n\tGX_NEVER   = 0, // never true\n\tGX_LESS    = 1, // <\n\tGX_EQUAL   = 2, // ==\n\tGX_LEQUAL  = 3, // <=\n\tGX_GREATER = 4, // >\n\tGX_NEQUAL  = 5, // !=\n\tGX_GEQUAL  = 6, // >=\n\tGX_ALWAYS  = 7, // always true\n} GXCompare;\ntypedef GXCompare _SDK_GXCompare;\n\n// Logical operation types.\n// Source is the input coefficient and Destination is the output coefficient.\ntypedef enum _GXLogicOp {\n\tGX_LO_CLEAR   = 0,  // 0x00\n\tGX_LO_AND     = 1,  // Source & Destination\n\tGX_LO_REVAND  = 2,  // Source & ~Destination\n\tGX_LO_COPY    = 3,  // Source\n\tGX_LO_INVAND  = 4,  //~Source & Destination\n\tGX_LO_NOOP    = 5,  // Destination\n\tGX_LO_XOR     = 6,  // Source ^ Destination\n\tGX_LO_OR      = 7,  // Source | Destination\n\tGX_LO_NOR     = 8,  //~(Source | Destination)\n\tGX_LO_EQUIV   = 9,  //~(Source ^ Destination)\n\tGX_LO_INV     = 10, //~Destination\n\tGX_LO_REVOR   = 11, // Source | ~Destination\n\tGX_LO_INVCOPY = 12, //~Source\n\tGX_LO_INVOR   = 13, //~Source | Destination\n\tGX_LO_NAND    = 14, //~(Source & Destination)\n\tGX_LO_SET     = 15, // 0xff\n} GXLogicOp;\n\ntypedef GXLogicOp _SDK_GXLogicOp;\n\n// Primitive types.\ntypedef enum _GXPrimitive {\n\tGX_POINTS        = 0xB8,\n\tGX_LINES         = 0xA8,\n\tGX_LINESTRIP     = 0xB0,\n\tGX_TRIANGLES     = 0x90,\n\tGX_TRIANGLESTRIP = 0x98,\n\tGX_TRIANGLEFAN   = 0xa0,\n\tGX_QUADS         = 0x80,\n} GXPrimitive;\n\n// Position-normal matrix sizes/types.\ntypedef enum _GXPosNrmMtx {\n\tGX_PNMTX0 = 3 * 0, // 0\n\tGX_PNMTX1 = 3 * 1, // 3\n\tGX_PNMTX2 = 3 * 2, // 6\n\tGX_PNMTX3 = 3 * 3, // 9\n\tGX_PNMTX4 = 3 * 4, // 12\n\tGX_PNMTX5 = 3 * 5, // 15\n\tGX_PNMTX6 = 3 * 6, // 18\n\tGX_PNMTX7 = 3 * 7, // 21\n\tGX_PNMTX8 = 3 * 8, // 24\n\tGX_PNMTX9 = 3 * 9, // 27\n} GXPosNrmMtx;\n\n// Command display list opcodes.\ntypedef enum _GXCommand {\n\tGX_CMD_LOAD_INDX_A = 0x20,\n\tGX_CMD_LOAD_INDX_B = 0x28,\n\tGX_CMD_LOAD_INDX_C = 0x30,\n\tGX_CMD_LOAD_INDX_D = 0x38,\n\n\tGX_CMD_LOAD_BP_REG = 0x61,\n\tGX_CMD_LOAD_CP_REG = 0x08,\n\tGX_CMD_LOAD_XF_REG = 0x10,\n\n\tGX_CMD_CALL_DL = 0x40,\n\tGX_CMD_INVL_VC = 0x48,\n\n\tGX_CMD_NOP                 = 0x00,\n\tGX_CMD_DRAW_QUADS          = 0x80,\n\tGX_CMD_DRAW_TRIANGLES      = 0x90,\n\tGX_CMD_DRAW_TRIANGLE_STRIP = 0x98,\n\tGX_CMD_DRAW_TRIANGLE_FAN   = 0xA0,\n\tGX_CMD_DRAW_LINES          = 0xA8,\n\tGX_CMD_DRAW_LINE_STRIP     = 0xB0,\n\tGX_CMD_DRAW_POINTS         = 0xB8,\n} GXCommand;\n\n#define GX_OPCODE_MASK 0xF8\n#define GX_VAT_MASK    0x07\n\n////////////////////////////////////////////\n\n//////////////// ATTRIBUTES ////////////////\n// Name of the vertex attribute or array. Attributes are listed in the ascending\n// order vertex data is required to be sent to the GP.\ntypedef enum _GXAttr {\n\tGX_VA_PNMTXIDX   = 0, // Position coordinate/normal matrix index.\n\tGX_VA_TEX0MTXIDX = 1, // GX_TXCOORD0 matrix index.\n\tGX_VA_TEX1MTXIDX = 2, // GX_TXCOORD1 matrix index.\n\tGX_VA_TEX2MTXIDX = 3, // GX_TXCOORD2 matrix index.\n\tGX_VA_TEX3MTXIDX = 4, // GX_TXCOORD3 matrix index.\n\tGX_VA_TEX4MTXIDX = 5, // GX_TXCOORD4 matrix index.\n\tGX_VA_TEX5MTXIDX = 6, // GX_TXCOORD5 matrix index.\n\tGX_VA_TEX6MTXIDX = 7, // GX_TXCOORD6 matrix index.\n\tGX_VA_TEX7MTXIDX = 8, // GX_TXCOORD7 matrix index.\n\n\tGX_VA_POS  = 9,  // Position coordinates.\n\tGX_VA_NRM  = 10, // Normal.\n\tGX_VA_CLR0 = 11, // Color 0.\n\tGX_VA_CLR1 = 12, // Color 1.\n\tGX_VA_TEX0 = 13, // Texture coordinate 0.\n\tGX_VA_TEX1 = 14, // Texture coordinate 1.\n\tGX_VA_TEX2 = 15, // Texture coordinate 2.\n\tGX_VA_TEX3 = 16, // Texture coordinate 3.\n\tGX_VA_TEX4 = 17, // Texture coordinate 4.\n\tGX_VA_TEX5 = 18, // Texture coordinate 5.\n\tGX_VA_TEX6 = 19, // Texture coordinate 6.\n\tGX_VA_TEX7 = 20, // Texture coordinate 7.\n\n\tGX_POS_MTX_ARRAY = 21, // Position coordinates matrix array.\n\tGX_NRM_MTX_ARRAY = 22, // Normal matrix array.\n\tGX_TEX_MTX_ARRAY = 23, // Texture matrix array.\n\tGX_LIGHT_ARRAY   = 24, // Light structure array.\n\tGX_VA_NBT        = 25, // Normal/bi-normal/tangent.\n\n\tGX_VA_MAX_ATTR, // Max number of attributes (26).\n\n\tGX_VA_NULL = 0xFF, // Indicates that it is none of these data types.\n} GXAttr;\n\n#define GX_MAX_VTXARRAY 16\n\n// Type of vertex attribute reference.\n// NB: havent confirmed the GX docs match pikmin 2 here\ntypedef enum _GXAttrType {\n\tGX_NONE    = 0, // No data to be sent.\n\tGX_DIRECT  = 1, // Value sent is value of data.\n\tGX_INDEX8  = 2, // Value sent is INDEX value of data array (8-bit).\n\tGX_INDEX16 = 3, // Value sent is INDEX value of data array (16-bit).\n} GXAttrType;\n\n// Vertex format IDs.\n// NB: havent confirmed the GX docs match pikmin 2 here\ntypedef enum _GXVtxFmt {\n\tGX_VTXFMT0 = 0, // Vertex attribute format ID 0.\n\tGX_VTXFMT1 = 1, // Vertex attribute format ID 1.\n\tGX_VTXFMT2 = 2, // Vertex attribute format ID 2.\n\tGX_VTXFMT3 = 3, // Vertex attribute format ID 3.\n\tGX_VTXFMT4 = 4, // Vertex attribute format ID 4.\n\tGX_VTXFMT5 = 5, // Vertex attribute format ID 5.\n\tGX_VTXFMT6 = 6, // Vertex attribute format ID 6.\n\tGX_VTXFMT7 = 7, // Vertex attribute format ID 7.\n\n\tGX_MAX_VTXFMT, // Max vertex formats (8)\n} GXVtxFmt;\n\n// Number of components in an attribute.\n// NB: havent confirmed the GX docs match pikmin 2 here\ntypedef enum _GXCompCnt {\n\tGX_POS_XY  = 0, // Position X, Y (two components).\n\tGX_POS_XYZ = 1, // Position X, Y, Z (three components).\n\n\tGX_NRM_XYZ  = 0, // Normal X, Y, Z (three components).\n\tGX_NRM_NBT  = 1, // Normal, binormal, tangent (three components).\n\tGX_NRM_NBT3 = 2, // Normal, binormal, tangent (three components). Use when NBT\n\t                 // normal is indexed independently.\n\n\tGX_CLR_RGB  = 0, // RGB (three components).\n\tGX_CLR_RGBA = 1, // RGBA (four components).\n\n\tGX_TEX_S  = 0, // Texture coordinate S (one component).\n\tGX_TEX_ST = 1, // Texture coordinates S, T (two components).\n\n\tGX_COMPCNT_NULL = 0, // Null count.\n} GXCompCnt;\n\n// Type of components in an attribute.\n// NB: havent confirmed the GX docs match pikmin 2 here\ntypedef enum _GXCompType {\n\tGX_U8  = 0, // Unsigned 8-bit.\n\tGX_S8  = 1, // Signed 8-bit.\n\tGX_U16 = 2, // Unsigned 16-bit.\n\tGX_S16 = 3, // Signed 16-bit.\n\tGX_F32 = 4, // Floating-point 32-bit.\n\n\tGX_RGB565 = 0, // RGB565 16-bit.\n\tGX_RGB8   = 1, // RGB888 24-bit.\n\tGX_RGBX8  = 2, // RGB888x 32-bit.\n\tGX_RGBA4  = 3, // RGBA4444 16-bit.\n\tGX_RGBA6  = 4, // RGBA6666 24-bit.\n\tGX_RGBA8  = 5, // RGBA8888 32-bit.\n\n\tGX_COMP_NULL = 0, // Null type.\n} GXCompType;\n\n// Anisotropy (direction-dependent) types.\n// NB: unsure what each type means.\ntypedef enum _GXAnisotropy {\n\tGX_ANISO_1 = 0,\n\tGX_ANISO_2 = 1,\n\tGX_ANISO_4 = 2,\n\n\tGX_MAX_ANISOTROPY, // Max types (3).\n} GXAnisotropy;\n\n////////////////////////////////////////////\n\n///////////// LIGHT/FOG/BLEND //////////////\n// Light levels.\ntypedef enum _GXLightID {\n\tGX_LIGHT_NULL = 0x0,\n\tGX_LIGHT0     = 0x1,\n\tGX_LIGHT1     = 0x2,\n\tGX_LIGHT2     = 0x4,\n\tGX_LIGHT3     = 0x8,\n\tGX_LIGHT4     = 0x10,\n\tGX_LIGHT5     = 0x20,\n\tGX_LIGHT6     = 0x40,\n\tGX_LIGHT7     = 0x80,\n\tGX_MAX_LIGHT  = 0x100,\n} GXLightID;\n\n// Diffuse light functions.\ntypedef enum _GXDiffuseFn {\n\tGX_DF_NONE  = 0,\n\tGX_DF_SIGN  = 1,\n\tGX_DF_CLAMP = 2,\n} GXDiffuseFn;\n\n// Light attenuation functions.\ntypedef enum _GXAttnFn {\n\tGX_AF_SPEC = 0, // Specular attenuation.\n\tGX_AF_SPOT = 1, // Spotlight/distance attenuation.\n\tGX_AF_NONE = 2, // Attenuation off.\n} GXAttnFn;\n\n// Spotlight attenuation functions.\ntypedef enum _GXSpotFn {\n\tGX_SP_OFF   = 0,\n\tGX_SP_FLAT  = 1,\n\tGX_SP_COS   = 2,\n\tGX_SP_COS2  = 3,\n\tGX_SP_SHARP = 4,\n\tGX_SP_RING1 = 5,\n\tGX_SP_RING2 = 6,\n} GXSpotFn;\n\n// Distance attentuation functions.\ntypedef enum _GXDistAttnFn {\n\tGX_DA_OFF    = 0,\n\tGX_DA_GENTLE = 1,\n\tGX_DA_MEDIUM = 2,\n\tGX_DA_STEEP  = 3,\n} GXDistAttnFn;\n\n// Fog density functions for perspective projection mode.\ntypedef enum _GXFogType {\n\tGX_FOG_NONE       = 0, // No fog.\n\tGX_FOG_LINEAR     = 2, // Linear density.\n\tGX_FOG_EXPONENT   = 4, // Exponential density.\n\tGX_FOG_EXPONENT2  = 5, // Exponential-squared density.\n\tGX_FOG_REVERSEEXP = 6, // Inverse exponential density.\n\tGX_FOG_REVERSEXP2 = 7  // Inverse exponential-squared density.\n} GXFogType;\n\ntypedef GXFogType _SDK_GXFogType;\n\n// Blending type.\ntypedef enum _GXBlendMode {\n\tGX_BM_NONE     = 0, // No blending.\n\tGX_BM_BLEND    = 1, // Blending.\n\tGX_BM_LOGIC    = 2, // Logic operations.\n\tGX_BM_SUBTRACT = 3, // Subtractive blending.\n\tGX_MAX_BLENDMODE,   // Max blend modes (4).\n} GXBlendMode;\n\ntypedef GXBlendMode _SDK_GXBlendMode;\n\n// Blending controls. Dest = frame buffer, src = current/source.\ntypedef enum _GXBlendFactor {\n\tGX_BL_ZERO        = 0, // 0.0\n\tGX_BL_ONE         = 1, // 1.0\n\tGX_BL_SRCCOL      = 2,\n\tGX_BL_DSTCOL      = GX_BL_SRCCOL, // Frame buffer color, Source color\n\tGX_BL_INVSRCCOL   = 3,\n\tGX_BL_INVDSTCOL   = GX_BL_INVSRCCOL, // 1.0 - (Frame buffer color), 1.0 - (Source color)\n\tGX_BL_SRCALPHA    = 4,               // Source alpha\n\tGX_BL_INVSRCALPHA = 5,               // 1.0 - (Source alpha)\n\tGX_BL_DSTALPHA    = 6,               // Frame buffer alpha\n\tGX_BL_INVDSTALPHA = 7,               // 1.0 - (Frame buffer alpha)\n} GXBlendFactor;\n\ntypedef GXBlendFactor _SDK_GXBlendFactor;\n\n////////////////////////////////////////////\n\n/////////////// MANIP MODES ////////////////\n// Culling modes.\ntypedef enum _GXCullMode {\n\tGX_CULL_NONE  = 0,\n\tGX_CULL_FRONT = 1,\n\tGX_CULL_BACK  = 2,\n\tGX_CULL_ALL   = 3,\n} GXCullMode;\n\n// Clipping modes.\n// NB: These are deliberately reversed from normal on/off.\ntypedef enum _GXClipMode {\n\tGX_CLIP_ENABLE  = 0,\n\tGX_CLIP_DISABLE = 1,\n} GXClipMode;\n\n// Copy modes.\ntypedef enum _GXCopyMode {\n\tGX_COPY_PROGRESSIVE = 0,\n\tGX_COPY_INTLC_EVEN  = 2,\n\tGX_COPY_INTLC_ODD   = 3,\n} GXCopyMode;\n\n////////////////////////////////////////////\n\n/////////////// COLOR MANIP ////////////////\n// Color Channel IDs.\ntypedef enum _GXChannelID {\n\tGX_COLOR0      = 0, // Color 0.\n\tGX_COLOR1      = 1, // Color 1.\n\tGX_ALPHA0      = 2, // Alpha 0.\n\tGX_ALPHA1      = 3, // Alpha 1.\n\tGX_COLOR0A0    = 4, // Color 0 + Alpha 0.\n\tGX_COLOR1A1    = 5, // Color 1 + Alpha 1.\n\tGX_COLOR_ZERO  = 6, // RGBA = 0.\n\tGX_ALPHA_BUMP  = 7, // Bump alpha 0-248, RGB = 0.\n\tGX_ALPHA_BUMPN = 8, // Norm bump alpha 0-255, RGB = 0.\n\n\tGX_COLOR_NULL = 0xFF, // Null channel.\n} GXChannelID;\n\n// Color sources.\ntypedef enum _GXColorSrc {\n\tGX_SRC_REG = 0, // Source from register (?).\n\tGX_SRC_VTX = 1, // Source from vertex.\n} GXColorSrc;\n\n// Alpha operators.\ntypedef enum _GXAlphaOp {\n\tGX_AOP_AND  = 0,\n\tGX_AOP_OR   = 1,\n\tGX_AOP_XOR  = 2,\n\tGX_AOP_XNOR = 3,\n\n\tGX_MAX_ALPHAOP, // Max num alpha operators (4).\n} GXAlphaOp;\n\n// Alpha read mode.\ntypedef enum _GXAlphaReadMode {\n\tGX_READ_00   = 0,\n\tGX_READ_FF   = 1,\n\tGX_READ_NONE = 2,\n} GXAlphaReadMode;\n\n// Gamma modes.\n// NB: not sure what these modes are.\ntypedef enum _GXGamma {\n\tGX_GM_1_0 = 0,\n\tGX_GM_1_7 = 1,\n\tGX_GM_2_2 = 2,\n} GXGamma;\n\n////////////////////////////////////////////\n\n///////////////// TEXTURES /////////////////\n// Texture Coordinate IDs\ntypedef enum _GXTexCoordID {\n\tGX_TEXCOORD0 = 0, // Generated tex coord 0.\n\tGX_TEXCOORD1 = 1, // Generated tex coord 1.\n\tGX_TEXCOORD2 = 2, // Generated tex coord 2.\n\tGX_TEXCOORD3 = 3, // Generated tex coord 3.\n\tGX_TEXCOORD4 = 4, // Generated tex coord 4.\n\tGX_TEXCOORD5 = 5, // Generated tex coord 5.\n\tGX_TEXCOORD6 = 6, // Generated tex coord 6.\n\tGX_TEXCOORD7 = 7, // Generated tex coord 7.\n\n\tGX_MAX_TEXCOORD, // Max num texture coords (8).\n\n\tGX_TEXCOORD_NULL = 0xFF, // Null coordinate.\n} GXTexCoordID;\n\n// Texture generation types.\ntypedef enum _GXTexGenType {\n\tGX_TG_MTX2X4 = 0,\n\tGX_TG_MTX3X4 = 1,\n\n\tGX_TG_BUMP0 = 2,\n\tGX_TG_BUMP1 = 3,\n\tGX_TG_BUMP2 = 4,\n\tGX_TG_BUMP3 = 5,\n\tGX_TG_BUMP4 = 6,\n\tGX_TG_BUMP5 = 7,\n\tGX_TG_BUMP6 = 8,\n\tGX_TG_BUMP7 = 9,\n\n\tGX_TG_SRTG = 10,\n} GXTexGenType;\n\n// Texture generation sources.\ntypedef enum _GXTexGenSrc {\n\tGX_TG_POS     = 0, // Position.\n\tGX_TG_NRM     = 1, // Normal.\n\tGX_TG_BINRM   = 2, // Bi-normal.\n\tGX_TG_TANGENT = 3, // Tangent.\n\n\tGX_TG_TEX0 = 4,  // Texture 0.\n\tGX_TG_TEX1 = 5,  // Texture 1.\n\tGX_TG_TEX2 = 6,  // Texture 2.\n\tGX_TG_TEX3 = 7,  // Texture 3.\n\tGX_TG_TEX4 = 8,  // Texture 4.\n\tGX_TG_TEX5 = 9,  // Texture 5.\n\tGX_TG_TEX6 = 10, // Texture 6.\n\tGX_TG_TEX7 = 11, // Texture 7.\n\n\tGX_TG_TEXCOORD0 = 12, // Tex coord 0.\n\tGX_TG_TEXCOORD1 = 13, // Tex coord 1.\n\tGX_TG_TEXCOORD2 = 14, // Tex coord 2.\n\tGX_TG_TEXCOORD3 = 15, // Tex coord 3.\n\tGX_TG_TEXCOORD4 = 16, // Tex coord 4.\n\tGX_TG_TEXCOORD5 = 17, // Tex coord 5.\n\tGX_TG_TEXCOORD6 = 18, // Tex coord 6. No 7?\n\n\tGX_TG_COLOR0 = 19, // Color 0.\n\tGX_TG_COLOR1 = 20, // Color 1.\n} GXTexGenSrc;\n\n// Texture map names.\n// NB: havent confirmed the GX docs match pikmin 2 here\ntypedef enum _GXTexMapID {\n\tGX_TEXMAP0 = 0, // Texture map ID 0.\n\tGX_TEXMAP1 = 1, // Texture map ID 1.\n\tGX_TEXMAP2 = 2, // Texture map ID 2.\n\tGX_TEXMAP3 = 3, // Texture map ID 3.\n\tGX_TEXMAP4 = 4, // Texture map ID 4.\n\tGX_TEXMAP5 = 5, // Texture map ID 5.\n\tGX_TEXMAP6 = 6, // Texture map ID 6.\n\tGX_TEXMAP7 = 7, // Texture map ID 7.\n\n\tGX_MAX_TEXMAP, // Max num texture map IDs (8).\n\n\tGX_TEXMAP_NULL = 0xFF,  // No textures used.\n\tGX_TEX_DISABLE = 0x100, // No texture map look-up.\n} GXTexMapID;\n\n// Texture format types.\n/*\n * RGB, RGBA, Intensity, Intensity/Alpha, Compressed, and Z texture format\n * types. See GXCITexFmt for information on color index formats. The CTF format\n * is used only by the GXSetTexCopyDst function to specify how data is copied\n * out of the EFB into a texture in main memory. In order to actually use that\n * texture, you must specify a non-copy format of matching size. For example, if\n * copying using GX_CTF_RG8, you would apply the resulting texture using\n * GX_TF_IA8.\n */\n// clang-format off\ntypedef enum _GXTexFmt {\n    // Intensities (I) and RGB/RGBA.\n\tGX_TF_I4     = 0x0, // 4-bit I\n\tGX_TF_I8     = 0x1, // 8-bit I\n\tGX_TF_IA4    = 0x2, // 8-bit I + alpha (4+4).\n\tGX_TF_IA8    = 0x3, // 16-bit I + alpha (8+8).\n\tGX_TF_RGB565 = 0x4, // 16-bit RGB.\n\tGX_TF_RGB5A3 = 0x5, // MSB=1, RGB555 (opaque). MSB=0, RGBA4443 (transparent).\n\tGX_TF_RGBA8  = 0x6, // 32-bit RGB.\n\tGX_TF_CMPR   = 0xE, // Compressed 4-bit texel.\n\n    // Z-texture format.\n\tGX_TF_Z8    = 0x11, // Unsigned 8-bit Z. For texture copies, specify the upper 8 bits of Z.\n\tGX_TF_Z16   = 0x13, // Unsigned 16-bit Z. For texture copies, specify the upper 16 bits of Z.\n\tGX_TF_Z24X8 = 0x16, // Unsigned 24-bit (32-bit texture) Z. For texture copies, copy the 24-bit Z and 0xff.\n\n    // Copy-texture format.\n\tGX_CTF_R4    = 0x20, // 4-bit red. For copying 4 bits from red.\n\tGX_CTF_RA4   = 0x22, // 4-bit red + 4-bit alpha. For copying 4 bits from red, 4 bits from alpha.\n\tGX_CTF_RA8   = 0x23, // 8-bit red + 8-bit alpha. For copying 8 bits from red, 8 bits from alpha.\n    GX_CTF_YUVA8 = 0x26, // 8-bit YUV + alpha. For copying 8 bits from YUV, 8 bits from alpha.\n\tGX_CTF_A8    = 0x26, // 8-bit alpha. For copying 8 bits from alpha.\n\tGX_CTF_R8    = 0x27, // 8-bit red. For copying 8 bits from red.\n\tGX_CTF_G8    = 0x28, // 8-bit green. For copying 8 bits from green.\n\tGX_CTF_B8    = 0x29, // 8-bit blue. For copying 8 bits from blue.\n\tGX_CTF_RG8   = 0x2A, // 8-bit red +8-bit green. For copying 8 bits from red, 8 bits from green.\n\tGX_CTF_GB8   = 0x2B, // 8-bit green +8-bit blue. For copying 8 bits from green, 8 bits from blue.\n\n    // Copy-Z-texture format.\n\tGX_CTF_Z4   = 0x30, // 4-bit Z. For copying the 4 upper bits from Z.\n\tGX_CTF_Z8M  = 0x39, // 8-bit Z (median byte). For copying the middle 8 bits of Z.\n\tGX_CTF_Z8L  = 0x3A, // 8-bit Z (lower byte). For copying the lower 8 bits of Z.\n\tGX_CTF_Z16L = 0x3C, // 16-bit Z (lower portion). For copying the lower 16 bits of Z.\n} GXTexFmt;\n// clang-format on\n\n// Color index formats.\ntypedef enum _GXCITexFmt {\n\tGX_TF_C4    = 0x8,\n\tGX_TF_C8    = 0x9,\n\tGX_TF_C14X2 = 0xA,\n} GXCITexFmt;\n\n// Texture matrix ID.\ntypedef enum _GXTexMtx {\n\tGX_TEXMTX0 = 30 + 0 * 3, // 30, Mtx0\n\tGX_TEXMTX1 = 30 + 1 * 3, // 33, Mtx1\n\tGX_TEXMTX2 = 30 + 2 * 3, // 36, Mtx2\n\tGX_TEXMTX3 = 30 + 3 * 3, // 39, Mtx3\n\tGX_TEXMTX4 = 30 + 4 * 3, // 42, Mtx4\n\tGX_TEXMTX5 = 30 + 5 * 3, // 45, Mtx5\n\tGX_TEXMTX6 = 30 + 6 * 3, // 48, Mtx6\n\tGX_TEXMTX7 = 30 + 7 * 3, // 51, Mtx7\n\tGX_TEXMTX8 = 30 + 8 * 3, // 54, Mtx8\n\tGX_TEXMTX9 = 30 + 9 * 3, // 57, Mtx9\n\n\tGX_IDENTITY = 60, // 60, Identity mtx\n} GXTexMtx;\n\n// Texture matrix type.\ntypedef enum _GXTexMtxType {\n\tGX_MTX3x4 = 0,\n\tGX_MTX2x4 = 1,\n} GXTexMtxType;\n\n// PT Texture matrix ID (?).\ntypedef enum _GXPTTexMtx {\n\tGX_PTTEXMTX0  = 64 + 0 * 3,  // 64, Mtx0\n\tGX_PTTEXMTX1  = 64 + 1 * 3,  // 67, Mtx1\n\tGX_PTTEXMTX2  = 64 + 2 * 3,  // 70, Mtx2\n\tGX_PTTEXMTX3  = 64 + 3 * 3,  // 73, Mtx3\n\tGX_PTTEXMTX4  = 64 + 4 * 3,  // 76, Mtx4\n\tGX_PTTEXMTX5  = 64 + 5 * 3,  // 79, Mtx5\n\tGX_PTTEXMTX6  = 64 + 6 * 3,  // 82, Mtx6\n\tGX_PTTEXMTX7  = 64 + 7 * 3,  // 85, Mtx7\n\tGX_PTTEXMTX8  = 64 + 8 * 3,  // 88, Mtx8\n\tGX_PTTEXMTX9  = 64 + 9 * 3,  // 91, Mtx9\n\tGX_PTTEXMTX10 = 64 + 10 * 3, // 94, Mtx10\n\tGX_PTTEXMTX11 = 64 + 11 * 3, // 97, Mtx11\n\tGX_PTTEXMTX12 = 64 + 12 * 3, // 100, Mtx12\n\tGX_PTTEXMTX13 = 64 + 13 * 3, // 103, Mtx13\n\tGX_PTTEXMTX14 = 64 + 14 * 3, // 106, Mtx14\n\tGX_PTTEXMTX15 = 64 + 15 * 3, // 109, Mtx15\n\tGX_PTTEXMTX16 = 64 + 16 * 3, // 112, Mtx16\n\tGX_PTTEXMTX17 = 64 + 17 * 3, // 115, Mtx17\n\tGX_PTTEXMTX18 = 64 + 18 * 3, // 118, Mtx18\n\tGX_PTTEXMTX19 = 64 + 19 * 3, // 121, Mtx19\n\n\tGX_PTIDENTITY = 125, // 125, Identity mtx\n} GXPTTexMtx;\n\n// Texture offset types.\ntypedef enum _GXTexOffset {\n\tGX_TO_ZERO      = 0,\n\tGX_TO_SIXTEENTH = 1,\n\tGX_TO_EIGHTH    = 2,\n\tGX_TO_FOURTH    = 3,\n\tGX_TO_HALF      = 4,\n\tGX_TO_ONE       = 5,\n\n\tGX_MAX_TEXOFFSET, // Max num texture offset types (6).\n} GXTexOffset;\n\n// Texture wrap modes.\ntypedef enum _GXTexWrapMode {\n\tGX_CLAMP  = 0, // Clamp/cut off at wrap.\n\tGX_REPEAT = 1, // Repeat past wrap.\n\tGX_MIRROR = 2, // Mirror past wrap.\n} GXTexWrapMode;\n\n// Texture filtering types.\ntypedef enum _GXTexFilter {\n\tGX_NEAR          = 0, // Filter near.\n\tGX_LINEAR        = 1, // Filter linear.\n\tGX_NEAR_MIP_NEAR = 2, // Near + MIPmap near.\n\tGX_LIN_MIP_NEAR  = 3, // Linear + MIPmap near.\n\tGX_NEAR_MIP_LIN  = 4, // Near + MIPmap linear.\n\tGX_LIN_MIP_LIN   = 5, // Linear + MIPmap linear.\n} GXTexFilter;\n\n// Texture cache sizes.\ntypedef enum _GXTexCacheSize {\n\tGX_TEXCACHE_32K  = 0, // Small.\n\tGX_TEXCACHE_128K = 1, // Medium.\n\tGX_TEXCACHE_512K = 2, // Large.\n\tGX_TEXCACHE_NONE = 3, // No cache.\n} GXTexCacheSize;\n\n////////////////////////////////////////////\n\n////////// TEXTURE LOOK-UP TABLES //////////\n// Texture look-up table (Tlut) names.\n/*\n * Names of texture lookup tables (TLUTs) in texture memory.\n * Each table GX_TLUT0 through GX_TLUT15 contains 256 entries, at 16 bits per\n * entry. Each table GX_BIGTLUT0 through BIGTLUT3 contains 1024 entries, at 16\n * bits per entry. Used for setting texture memory in the GXInit function.\n */\ntypedef enum _GXTlut {\n\tGX_TLUT0  = 0, // TLUT (256 16-bit entries) ID 0.\n\tGX_TLUT1  = 1,\n\tGX_TLUT2  = 2,\n\tGX_TLUT3  = 3,\n\tGX_TLUT4  = 4,\n\tGX_TLUT5  = 5,\n\tGX_TLUT6  = 6,\n\tGX_TLUT7  = 7,\n\tGX_TLUT8  = 8,\n\tGX_TLUT9  = 9,\n\tGX_TLUT10 = 10,\n\tGX_TLUT11 = 11,\n\tGX_TLUT12 = 12,\n\tGX_TLUT13 = 13,\n\tGX_TLUT14 = 14,\n\tGX_TLUT15 = 15,\n\n\tGX_MAX_TLUT = 16,\n\n\tGX_BIGTLUT0 = 16, // BIGTLUT (1024 16-bit entries) ID 0.\n\tGX_BIGTLUT1 = 17,\n\tGX_BIGTLUT2 = 18,\n\tGX_BIGTLUT3 = 19,\n\n\tGX_MAX_BIGTLUT = 4,\n\n\tGX_MAX_TLUT_ALL = GX_MAX_TLUT + GX_MAX_BIGTLUT, // 20\n} GXTlut;\n\n// Texture look-up (Tlut) formats.\ntypedef enum _GXTlutFmt {\n\tGX_TL_IA8    = 0, // 16-bit intensity + alpha (8I+8A).\n\tGX_TL_RGB565 = 1, // 16-bit RGB (R5+G6+B5).\n\tGX_TL_RGB5A3 = 2, // MSB=1, RGB555 (opaque); MSB=0, RGBA4443 (transparent).\n\n\tGX_MAX_TLUTFMT, // Max number of formats (3).\n} GXTlutFmt;\n\n// Texture look-up (Tlut) sizes.\ntypedef enum _GXTlutSize {\n\tGX_TLUT_16  = 1, // Number of 16 entry blocks.\n\tGX_TLUT_32  = 2,\n\tGX_TLUT_64  = 4,\n\tGX_TLUT_128 = 8,\n\tGX_TLUT_256 = 16,\n\tGX_TLUT_512 = 32,\n\tGX_TLUT_1K  = 64,\n\tGX_TLUT_2K  = 128,\n\tGX_TLUT_4K  = 256,\n\tGX_TLUT_8K  = 512,\n\tGX_TLUT_16K = 1024,\n} GXTlutSize;\n\n////////////////////////////////////////////\n\n//////////// INDIRECT TEXTURES /////////////\n// Indirect texture formats.\ntypedef enum _GXIndTexFormat {\n\tGX_ITF_8 = 0, // 8-bit texture offsets.\n\tGX_ITF_5 = 1, // 5-bit texture offsets.\n\tGX_ITF_4 = 2, // 4-bit texture offsets.\n\tGX_ITF_3 = 3, // 3-bit texture offsets.\n\n\tGX_MAX_ITFORMAT, // Max num formats (4).\n} GXIndTexFormat;\n\n// Indirect texture stage names.\ntypedef enum _GXIndTexStageID {\n\tGX_IND_TEX_STAGE_0 = 0,\n\tGX_IND_TEX_STAGE_1 = 1,\n\tGX_IND_TEX_STAGE_2 = 2,\n\tGX_IND_TEX_STAGE_3 = 3,\n\n\tGX_IND_MAX_TEX_STAGE_ID, // Max num stages (4).\n} GXIndTexStageID;\n\n// Indirect texture matrix IDs.\ntypedef enum _GXIndTexMtxID {\n\tGX_ITM_OFF = 0,\n\tGX_ITM_0   = 1,\n\tGX_ITM_1   = 2,\n\tGX_ITM_2   = 3,\n\n\tGX_ITM_S0 = 5,\n\tGX_ITM_S1 = 6,\n\tGX_ITM_S2 = 7,\n\n\tGX_ITM_T0 = 9,\n\tGX_ITM_T1 = 10,\n\tGX_ITM_T2 = 11,\n} GXIndTexMtxID;\n\n// Indirect texture scaling amounts.\ntypedef enum _GXIndTexScale {\n\tGX_ITS_1   = 0, // Scale by 1.\n\tGX_ITS_2   = 1, // Scale by 1/2.\n\tGX_ITS_4   = 2, // Scale by 1/4.\n\tGX_ITS_8   = 3, // Scale by 1/8.\n\tGX_ITS_16  = 4, // Scale by 1/16.\n\tGX_ITS_32  = 5, // Scale by 1/32.\n\tGX_ITS_64  = 6, // Scale by 1/64.\n\tGX_ITS_128 = 7, // Scale by 1/128.\n\tGX_ITS_256 = 8, // Scale by 1/256.\n\n\tGX_MAX_ITSCALE, // Max scaling types (9)\n} GXIndTexScale;\n\n// Indirect texture wrapping amounts.\ntypedef enum _GXIndTexWrap {\n\tGX_ITW_OFF = 0, // No wrapping.\n\tGX_ITW_256 = 1, // Wrap 256.\n\tGX_ITW_128 = 2, // Wrap 128.\n\tGX_ITW_64  = 3, // Wrap 64.\n\tGX_ITW_32  = 4, // Wrap 32.\n\tGX_ITW_16  = 5, // Wrap 16.\n\tGX_ITW_0   = 6, // Wrap 0.\n\n\tGX_MAX_ITWRAP, // Max wrapping types (7)\n} GXIndTexWrap;\n\n// Indirect texture bias selections.\n// STU = surface coordinate system (s,t,u) with u normal to surface.\ntypedef enum _GXIndTexBiasSel {\n\tGX_ITB_NONE = 0,\n\tGX_ITB_S    = 1,\n\tGX_ITB_T    = 2,\n\tGX_ITB_ST   = 3,\n\tGX_ITB_U    = 4,\n\tGX_ITB_SU   = 5,\n\tGX_ITB_TU   = 6,\n\tGX_ITB_STU  = 7,\n\n\tGX_MAX_ITBIAS, // Max num bias types (8).\n} GXIndTexBiasSel;\n\n// Indirect texture alpha selections.\n// STU = surface coordinate system (s,t,u) with u normal to surface.\ntypedef enum _GXIndTexAlphaSel {\n\tGX_ITBA_OFF = 0,\n\tGX_ITBA_S   = 1,\n\tGX_ITBA_T   = 2,\n\tGX_ITBA_U   = 3,\n\n\tGX_MAX_ITBALPHA, // Max num alpha types (4).\n} GXIndTexAlphaSel;\n\n////////////////////////////////////////////\n\n/////// TEXTURE ENVIRONMENTS (TEV) /////////\n// TEV stage names.\ntypedef enum _GXTevStageID {\n\tGX_TEVSTAGE0  = 0,  // TEV Stage 0.\n\tGX_TEVSTAGE1  = 1,  // TEV Stage 1.\n\tGX_TEVSTAGE2  = 2,  // TEV Stage 2.\n\tGX_TEVSTAGE3  = 3,  // TEV Stage 3.\n\tGX_TEVSTAGE4  = 4,  // TEV Stage 4.\n\tGX_TEVSTAGE5  = 5,  // TEV Stage 5.\n\tGX_TEVSTAGE6  = 6,  // TEV Stage 6.\n\tGX_TEVSTAGE7  = 7,  // TEV Stage 7.\n\tGX_TEVSTAGE8  = 8,  // TEV Stage 8.\n\tGX_TEVSTAGE9  = 9,  // TEV Stage 9.\n\tGX_TEVSTAGE10 = 10, // TEV Stage 10.\n\tGX_TEVSTAGE11 = 11, // TEV Stage 11.\n\tGX_TEVSTAGE12 = 12, // TEV Stage 12.\n\tGX_TEVSTAGE13 = 13, // TEV Stage 13.\n\tGX_TEVSTAGE14 = 14, // TEV Stage 14.\n\tGX_TEVSTAGE15 = 15, // TEV Stage 15.\n\n\tGX_MAXTEVSTAGE, // Max num TEV stages (16).\n} GXTevStageID;\n\n// TEV register names.\ntypedef enum _GXTevRegID {\n\tGX_TEVPREV = 0,\n\tGX_TEVREG0 = 1,\n\tGX_TEVREG1 = 2,\n\tGX_TEVREG2 = 3,\n\n\tGX_MAX_TEVREG, // Max num TEV registers (4).\n} GXTevRegID;\n\n// TEV operations.\ntypedef enum _GXTevOp {\n\tGX_TEV_ADD = 0,\n\tGX_TEV_SUB = 1,\n\n\tGX_TEV_COMP_R8_GT    = 8,\n\tGX_TEV_COMP_R8_EQ    = 9,\n\tGX_TEV_COMP_GR16_GT  = 10,\n\tGX_TEV_COMP_GR16_EQ  = 11,\n\tGX_TEV_COMP_BGR24_GT = 12,\n\tGX_TEV_COMP_BGR24_EQ = 13,\n\n\tGX_TEV_COMP_RGB8_GT = 14,\n\tGX_TEV_COMP_RGB8_EQ = 15,\n\n\tGX_TEV_COMP_A8_GT = GX_TEV_COMP_RGB8_GT, // Alpha channel (14)\n\tGX_TEV_COMP_A8_EQ = GX_TEV_COMP_RGB8_EQ  // Alpha channel (15)\n} GXTevOp;\n\n// TEV mode.\ntypedef enum _GXTevMode {\n\tGX_MODULATE = 0,\n\tGX_DECAL    = 1,\n\tGX_BLEND    = 2,\n\tGX_REPLACE  = 3,\n\tGX_PASSCLR  = 4,\n} GXTevMode;\n\n// TEV color channels.\n// NB: we used to have this called GXTevColor (like TP).\ntypedef enum _GXTevColorChan {\n\tGX_CH_RED   = 0,\n\tGX_CH_GREEN = 1,\n\tGX_CH_BLUE  = 2,\n\tGX_CH_ALPHA = 3,\n} GXTevColorChan;\n\n// TEV color arguments.\ntypedef enum _GXTevColorArg {\n\tGX_CC_CPREV = 0,\n\tGX_CC_APREV = 1,\n\tGX_CC_C0    = 2,\n\tGX_CC_C1    = 3,\n\tGX_CC_C2    = 4,\n\tGX_CC_A0    = 5,\n\tGX_CC_A1    = 6,\n\tGX_CC_A2    = 7,\n\tGX_CC_TEXC  = 8,\n\tGX_CC_TEXA  = 9,\n\tGX_CC_RASC  = 10,\n\tGX_CC_RASA  = 11,\n\tGX_CC_ONE   = 12,\n\tGX_CC_HALF  = 13,\n\tGX_CC_KONST = 14,\n\tGX_CC_ZERO  = 15,\n} GXTevColorArg;\n\n// TEV alpha-specific arguments.\ntypedef enum _GXTevAlphaArg {\n\tGX_CA_APREV = 0,\n\tGX_CA_A0    = 1,\n\tGX_CA_A1    = 2,\n\tGX_CA_A2    = 3,\n\tGX_CA_TEXA  = 4,\n\tGX_CA_RASA  = 5,\n\tGX_KONST    = 6,\n\tGX_ZERO     = 7,\n} GXTevAlphaArg;\n\n// TEV bias.\ntypedef enum _GXTevBias {\n\tGX_TB_ZERO    = 0,\n\tGX_TB_ADDHALF = 1,\n\tGX_TB_SUBHALF = 2,\n\n\tGX_MAX_TEVBIAS, // Max num bias types (3).\n} GXTevBias;\n\n// TEV clamp modes.\ntypedef enum _GXTevClampMode {\n\tGX_TC_LINEAR = 0,\n\tGX_TC_GE     = 1,\n\tGX_TC_EQ     = 2,\n\tGX_TC_LE     = 3,\n\n\tGX_MAX_TEVCLAMPMODE, // Max num clamp modes (4).\n} GXTevClampMode;\n\n// TEV scale types.\ntypedef enum _GXTevScale {\n\tGX_CS_SCALE_1  = 0,\n\tGX_CS_SCALE_2  = 1,\n\tGX_CS_SCALE_4  = 2,\n\tGX_CS_DIVIDE_2 = 3,\n\tGX_MAX_TEVSCALE, // Max num scale types (4).\n} GXTevScale;\n\n// TEV swap selections.\ntypedef enum _GXTevSwapSel {\n\tGX_TEV_SWAP0 = 0,\n\tGX_TEV_SWAP1 = 1,\n\tGX_TEV_SWAP2 = 2,\n\tGX_TEV_SWAP3 = 3,\n\tGX_MAX_TEVSWAP, // Max num swap selections (4).\n} GXTevSwapSel;\n\n// TEV const (konst) color IDs.\ntypedef enum _GXTevKColorID {\n\tGX_KCOLOR0 = 0, // kColor 0.\n\tGX_KCOLOR1 = 1, // kColor 1.\n\tGX_KCOLOR2 = 2, // kColor 2.\n\tGX_KCOLOR3 = 3, // kColor 3.\n\tGX_MAX_KCOLOR,  // Max num kColors (4).\n} GXTevKColorID;\n\n// TEV const (konst) color selections.\ntypedef enum _GXTevKColorSel {\n\tGX_TEV_KCSEL_1   = 0,\n\tGX_TEV_KCSEL_7_8 = 1,\n\tGX_TEV_KCSEL_3_4 = 2,\n\tGX_TEV_KCSEL_5_8 = 3,\n\tGX_TEV_KCSEL_1_2 = 4,\n\tGX_TEV_KCSEL_3_8 = 5,\n\tGX_TEV_KCSEL_1_4 = 6,\n\tGX_TEV_KCSEL_1_8 = 7,\n\n\tGX_TEV_KCSEL_K0 = 12,\n\tGX_TEV_KCSEL_K1 = 13,\n\tGX_TEV_KCSEL_K2 = 14,\n\tGX_TEV_KCSEL_K3 = 15,\n\n\tGX_TEV_KCSEL_K0_R = 16,\n\tGX_TEV_KCSEL_K1_R = 17,\n\tGX_TEV_KCSEL_K2_R = 18,\n\tGX_TEV_KCSEL_K3_R = 19,\n\n\tGX_TEV_KCSEL_K0_G = 20,\n\tGX_TEV_KCSEL_K1_G = 21,\n\tGX_TEV_KCSEL_K2_G = 22,\n\tGX_TEV_KCSEL_K3_G = 23,\n\n\tGX_TEV_KCSEL_K0_B = 24,\n\tGX_TEV_KCSEL_K1_B = 25,\n\tGX_TEV_KCSEL_K2_B = 26,\n\tGX_TEV_KCSEL_K3_B = 27,\n\n\tGX_TEV_KCSEL_K0_A = 28,\n\tGX_TEV_KCSEL_K1_A = 29,\n\tGX_TEV_KCSEL_K2_A = 30,\n\tGX_TEV_KCSEL_K3_A = 31,\n} GXTevKColorSel;\n\n// TEV const (konst) alpha selectors.\ntypedef enum _GXTevKAlphaSel {\n\tGX_TEV_KASEL_1   = 0,\n\tGX_TEV_KASEL_7_8 = 1,\n\tGX_TEV_KASEL_3_4 = 2,\n\tGX_TEV_KASEL_5_8 = 3,\n\tGX_TEV_KASEL_1_2 = 4,\n\tGX_TEV_KASEL_3_8 = 5,\n\tGX_TEV_KASEL_1_4 = 6,\n\tGX_TEV_KASEL_1_8 = 7,\n\n\tGX_TEV_KASEL_K0_R = 16,\n\tGX_TEV_KASEL_K1_R = 17,\n\tGX_TEV_KASEL_K2_R = 18,\n\tGX_TEV_KASEL_K3_R = 19,\n\n\tGX_TEV_KASEL_K0_G = 20,\n\tGX_TEV_KASEL_K1_G = 21,\n\tGX_TEV_KASEL_K2_G = 22,\n\tGX_TEV_KASEL_K3_G = 23,\n\n\tGX_TEV_KASEL_K0_B = 24,\n\tGX_TEV_KASEL_K1_B = 25,\n\tGX_TEV_KASEL_K2_B = 26,\n\tGX_TEV_KASEL_K3_B = 27,\n\n\tGX_TEV_KASEL_K0_A = 28,\n\tGX_TEV_KASEL_K1_A = 29,\n\tGX_TEV_KASEL_K2_A = 30,\n\tGX_TEV_KASEL_K3_A = 31,\n} GXTevKAlphaSel;\n\n////////////////////////////////////////////\n\n/////////// OTHER FORMATS/MODES ////////////\n// Frame buffer pixel formats.\ntypedef enum _GXPixelFmt {\n\tGX_PF_RGB8_Z24   = 0, // Non-antialiased (RGB 888).\n\tGX_PF_RGBA6_Z24  = 1, // Non-antialiased (RGBA 6666).\n\tGX_PF_RGB565_Z16 = 2, // Anti-aliasing.\n\tGX_PF_Z24        = 3,\n\tGX_PF_Y8         = 4,\n\tGX_PF_U8         = 5,\n\tGX_PF_V8         = 6,\n\tGX_PF_YUV420     = 7,\n\tGX_MAX_PIXELFMT, // 8\n} GXPixelFmt;\n\ntypedef GXPixelFmt _SDK_GXPixelFmt;\n\n// Compressed Z format.\ntypedef enum _GXZFmt16 {\n\tGX_ZC_LINEAR = 0, // 16-bit linear.\n\tGX_ZC_NEAR   = 1, // Compressed format (14e2) for smaller far/near ratio.\n\tGX_ZC_MID    = 2, // Compressed format (13e3) for medium far/near ratio.\n\tGX_ZC_FAR    = 3, // Compressed format (12e4) for large far/near ratio.\n} GXZFmt16;\n\ntypedef GXZFmt16 _SDK_GXZFmt16;\n\n// Projection types.\ntypedef enum _GXProjectionType {\n\tGX_PERSPECTIVE  = 0,\n\tGX_ORTHOGRAPHIC = 1,\n} GXProjectionType;\n\n// FB clamp types.\ntypedef enum _GXFBClamp {\n\tGX_CLAMP_NONE   = 0,\n\tGX_CLAMP_TOP    = 1,\n\tGX_CLAMP_BOTTOM = 2,\n\tGX_CLAMP_BOTH   = GX_CLAMP_TOP | GX_CLAMP_BOTTOM,\n} GXFBClamp;\n\n// Z-Texture operations.\ntypedef enum _GXZTexOp {\n\tGX_ZT_DISABLE = 0,\n\tGX_ZT_ADD     = 1,\n\tGX_ZT_REPLACE = 2,\n\n\tGX_MAX_ZTEXOP, // Max num operations (3).\n} GXZTexOp;\n\n// Perf-0 types.\ntypedef enum _GXPerf0 {\n\tGX_PERF0_VERTICES      = 0,\n\tGX_PERF0_CLIP_VTX      = 1,\n\tGX_PERF0_CLIP_CLKS     = 2,\n\tGX_PERF0_XF_WAIT_IN    = 3,\n\tGX_PERF0_XF_WAIT_OUT   = 4,\n\tGX_PERF0_XF_XFRM_CLKS  = 5,\n\tGX_PERF0_XF_LIT_CLKS   = 6,\n\tGX_PERF0_XF_BOT_CLKS   = 7,\n\tGX_PERF0_XF_REGLD_CLKS = 8,\n\tGX_PERF0_XF_REGRD_CLKS = 9,\n\tGX_PERF0_CLIP_RATIO    = 10,\n\n\tGX_PERF0_TRIANGLES           = 11,\n\tGX_PERF0_TRIANGLES_CULLED    = 12,\n\tGX_PERF0_TRIANGLES_PASSED    = 13,\n\tGX_PERF0_TRIANGLES_SCISSORED = 14,\n\tGX_PERF0_TRIANGLES_0TEX      = 15,\n\tGX_PERF0_TRIANGLES_1TEX      = 16,\n\tGX_PERF0_TRIANGLES_2TEX      = 17,\n\tGX_PERF0_TRIANGLES_3TEX      = 18,\n\tGX_PERF0_TRIANGLES_4TEX      = 19,\n\tGX_PERF0_TRIANGLES_5TEX      = 20,\n\tGX_PERF0_TRIANGLES_6TEX      = 21,\n\tGX_PERF0_TRIANGLES_7TEX      = 22,\n\tGX_PERF0_TRIANGLES_8TEX      = 23,\n\tGX_PERF0_TRIANGLES_0CLR      = 24,\n\tGX_PERF0_TRIANGLES_1CLR      = 25,\n\tGX_PERF0_TRIANGLES_2CLR      = 26,\n\n\tGX_PERF0_QUAD_0CVG    = 27,\n\tGX_PERF0_QUAD_NON0CVG = 28,\n\tGX_PERF0_QUAD_1CVG    = 29,\n\tGX_PERF0_QUAD_2CVG    = 30,\n\tGX_PERF0_QUAD_3CVG    = 31,\n\tGX_PERF0_QUAD_4CVG    = 32,\n\tGX_PERF0_AVG_QUAD_CNT = 33,\n\n\tGX_PERF0_CLOCKS = 34,\n\tGX_PERF0_NONE   = 35,\n} GXPerf0;\n\n// Perf-1 types.\ntypedef enum _GXPerf1 {\n\tGX_PERF1_TEXELS      = 0,\n\tGX_PERF1_TX_IDLE     = 1,\n\tGX_PERF1_TX_REGS     = 2,\n\tGX_PERF1_TX_MEMSTALL = 3,\n\tGX_PERF1_TC_CHECK1_2 = 4,\n\tGX_PERF1_TC_CHECK3_4 = 5,\n\tGX_PERF1_TC_CHECK5_6 = 6,\n\tGX_PERF1_TC_CHECK7_8 = 7,\n\tGX_PERF1_TC_MISS     = 8,\n\n\tGX_PERF1_VC_ELEMQ_FULL    = 9,\n\tGX_PERF1_VC_MISSQ_FULL    = 10,\n\tGX_PERF1_VC_MEMREQ_FULL   = 11,\n\tGX_PERF1_VC_STATUS7       = 12,\n\tGX_PERF1_VC_MISSREP_FULL  = 13,\n\tGX_PERF1_VC_STREAMBUF_LOW = 14,\n\tGX_PERF1_VC_ALL_STALLS    = 15,\n\tGX_PERF1_VERTICES         = 16,\n\n\tGX_PERF1_FIFO_REQ    = 17,\n\tGX_PERF1_CALL_REQ    = 18,\n\tGX_PERF1_VC_MISS_REQ = 19,\n\tGX_PERF1_CP_ALL_REQ  = 20,\n\n\tGX_PERF1_CLOCKS = 21,\n\tGX_PERF1_NONE   = 22,\n} GXPerf1;\n\n// Vertex cache perf types.\ntypedef enum _GXVCachePerf {\n\tGX_VC_POS  = 0,\n\tGX_VC_NRM  = 1,\n\tGX_VC_CLR0 = 2,\n\tGX_VC_CLR1 = 3,\n\tGX_VC_TEX0 = 4,\n\tGX_VC_TEX1 = 5,\n\tGX_VC_TEX2 = 6,\n\tGX_VC_TEX3 = 7,\n\tGX_VC_TEX4 = 8,\n\tGX_VC_TEX5 = 9,\n\tGX_VC_TEX6 = 10,\n\tGX_VC_TEX7 = 11,\n\n\tGX_VC_ALL = 15\n} GXVCachePerf;\n\n// Miscellaneous token types.\ntypedef enum _GXMiscToken {\n\tGX_MT_NULL               = 0,\n\tGX_MT_XF_FLUSH           = 1,\n\tGX_MT_DL_SAVE_CONTEXT    = 2,\n\tGX_MT_ABORT_WAIT_COPYOUT = 3,\n} GXMiscToken;\n\n////////////////////////////////////////////\n\n//////////// HARDWARE REGISTERS ////////////\n\n// Flags for setting GXData dirtyState.\ntypedef enum _GXDirtyFlag {\n\tGX_DIRTY_SU_TEX   = (1 << 0), // 0x1\n\tGX_DIRTY_BP_MASK  = (1 << 1), // 0x2\n\tGX_DIRTY_GEN_MODE = (1 << 2), // 0x4\n\tGX_DIRTY_VCD      = (1 << 3), // 0x8\n\tGX_DIRTY_VAT      = (1 << 4), // 0x10\n\t// . . .\n\tGX_DIRTY_AMB_COLOR0  = (1 << 8),  // 0x100\n\tGX_DIRTY_AMB_COLOR1  = (1 << 9),  // 0x200\n\tGX_DIRTY_MAT_COLOR0  = (1 << 10), // 0x400\n\tGX_DIRTY_MAT_COLOR1  = (1 << 11), // 0x800\n\tGX_DIRTY_CHAN_COLOR0 = (1 << 12), // 0x1000\n\tGX_DIRTY_CHAN_COLOR1 = (1 << 13), // 0x2000\n\tGX_DIRTY_CHAN_ALPHA0 = (1 << 14), // 0x4000\n\tGX_DIRTY_CHAN_ALPHA1 = (1 << 15), // 0x8000\n\tGX_DIRTY_TEX0        = (1 << 16), // 0x10000\n\tGX_DIRTY_TEX1        = (1 << 17), // 0x20000\n\tGX_DIRTY_TEX2        = (1 << 18), // 0x40000\n\tGX_DIRTY_TEX3        = (1 << 19), // 0x80000\n\tGX_DIRTY_TEX4        = (1 << 20), // 0x100000\n\tGX_DIRTY_TEX5        = (1 << 21), // 0x200000\n\tGX_DIRTY_TEX6        = (1 << 22), // 0x400000\n\tGX_DIRTY_TEX7        = (1 << 23), // 0x800000\n\tGX_DIRTY_NUM_COLORS  = (1 << 24), // 0x1000000\n\tGX_DIRTY_NUM_TEX     = (1 << 25), // 0x2000000\n\tGX_DIRTY_MTX_IDX     = (1 << 26), // 0x4000000\n\tGX_DIRTY_PROJECTION  = (1 << 27), // 0x8000000\n\tGX_DIRTY_VIEWPORT    = (1 << 28), // 0x10000000\n\n\tGX_AMB_MAT_MASK = GX_DIRTY_AMB_COLOR0 | GX_DIRTY_AMB_COLOR1 | GX_DIRTY_MAT_COLOR0 | GX_DIRTY_MAT_COLOR1, // 0xF00\n\n\tGX_LIGHT_CHAN_MASK\n\t= GX_DIRTY_CHAN_COLOR0 | GX_DIRTY_CHAN_COLOR1 | GX_DIRTY_CHAN_ALPHA0 | GX_DIRTY_CHAN_ALPHA1 | GX_DIRTY_NUM_COLORS, // 0x100F000\n\n\tGX_TEX_GEN_MASK = 0x2FF0000, // all GX_DIRTY_TEXs | GX_DIRTY_NUM_TEX\n} GXDirtyFlag;\n\n// Commands for interacting with the GXFifo pipe.\ntypedef enum _GXFifoCmd {\n\tGX_FIFO_CMD_NOOP = 0x00, // no operation\n\n\tGX_FIFO_CMD_LOAD_BP_REG = 0x61, // load blitting processor reg\n\tGX_FIFO_CMD_LOAD_CP_REG = 0x08, // load command processor reg\n\tGX_FIFO_CMD_LOAD_XF_REG = 0x10, // load transform unit reg\n\n\tGX_FIFO_CMD_LOAD_INDX_A = 0x20, // load index A\n\tGX_FIFO_CMD_LOAD_INDX_B = 0x28, // load index B\n\tGX_FIFO_CMD_LOAD_INDX_C = 0x30, // load index C\n\tGX_FIFO_CMD_LOAD_INDX_D = 0x38, // load index D\n\n\tGX_FIFO_CMD_CALL_DL   = 0x40, // call displaylist\n\tGX_FIFO_CMD_INVAL_VTX = 0x48, // invalid vertex\n\n} GXFifoCmd;\n\n// Texture register fields for XF (transform) unit.\ntypedef enum _GXXfTexReg {\n\tGX_XF_TEX_PROJ_ST  = 0, // (s,t) (2x4)\n\tGX_XF_TEX_PROJ_STQ = 1, // (s,t,q) (3x4)\n\n\tGX_XF_TEX_FORM_AB11 = 0, // (A, B, 1.0f, 1.0f), used for regular tex src\n\tGX_XF_TEX_FORM_ABC1 = 1, // (A, B, C, 1.0f), used for geometry/normal src\n} GXXfTexReg;\n\n// General texture commands.\ntypedef enum _GXXfTexGen {\n\tGX_XF_TG_REGULAR = 0, // Regular; transform incoming data.\n\tGX_XF_TG_BUMP    = 1, // Texgen bump mapping.\n\tGX_XF_TG_CLR0    = 2, // Color texgen for color 0 (s,t) = (r, g:b)\n\tGX_XF_TG_CLR1    = 3, // Color texgen for color 1 (s,t) = (r, g:b)\n} GXXfTexGen;\n\n// Transform memory types.\ntypedef enum _GXXfMem {\n\tGX_XF_MEM_POSMTX     = 0x000, // position coord matrix\n\tGX_XF_MEM_NRMMTX     = 0x400, // normal coord matrix\n\tGX_XF_MEM_DUALTEXMTX = 0x500, // dual texture matrix\n\tGX_XF_MEM_LIGHTOBJ   = 0x600, // light object\n} GXXfMem;\n\n// Blitting processor registers.\ntypedef enum _GXBPRegs {\n\t// gen mode\n\tGX_BP_REG_GENMODE = 0x0, // gen mode\n\n\t// display copy filters\n\tGX_BP_REG_DISPCOPYFILTER0 = 0x1, // display copy filter 0\n\tGX_BP_REG_DISPCOPYFILTER1 = 0x2, // display copy filter 1\n\tGX_BP_REG_DISPCOPYFILTER2 = 0x3, // display copy filter 2\n\tGX_BP_REG_DISPCOPYFILTER3 = 0x4, // display copy filter 3\n\n\t// indirect matrices\n\tGX_BP_REG_INDMTX0A = 0x6, // indirect matrix 0A\n\tGX_BP_REG_INDMTX0B = 0x7, // indirect matrix 0B\n\tGX_BP_REG_INDMTX0C = 0x8, // indirect matrix 0C\n\tGX_BP_REG_INDMTX1A = 0x9, // indirect matrix 1A\n\tGX_BP_REG_INDMTX1B = 0xA, // indirect matrix 1B\n\tGX_BP_REG_INDMTX1C = 0xB, // indirect matrix 1C\n\tGX_BP_REG_INDMTX2A = 0xC, // indirect matrix 2A\n\tGX_BP_REG_INDMTX2B = 0xD, // indirect matrix 2B\n\tGX_BP_REG_INDMTX2C = 0xE, // indirect matrix 2C\n\tGX_BP_REG_INDIMASK = 0xF, // indirect mask\n\n\t// indirect TEV stages\n\tGX_BP_REG_INDTEVSTAGE0  = 0x10, // indirect TEV stage 0\n\tGX_BP_REG_INDTEVSTAGE1  = 0x11, // indirect TEV stage 1\n\tGX_BP_REG_INDTEVSTAGE2  = 0x12, // indirect TEV stage 2\n\tGX_BP_REG_INDTEVSTAGE3  = 0x13, // indirect TEV stage 3\n\tGX_BP_REG_INDTEVSTAGE4  = 0x14, // indirect TEV stage 4\n\tGX_BP_REG_INDTEVSTAGE5  = 0x15, // indirect TEV stage 5\n\tGX_BP_REG_INDTEVSTAGE6  = 0x16, // indirect TEV stage 6\n\tGX_BP_REG_INDTEVSTAGE7  = 0x17, // indirect TEV stage 7\n\tGX_BP_REG_INDTEVSTAGE8  = 0x18, // indirect TEV stage 8\n\tGX_BP_REG_INDTEVSTAGE9  = 0x19, // indirect TEV stage 9\n\tGX_BP_REG_INDTEVSTAGE10 = 0x1A, // indirect TEV stage 10\n\tGX_BP_REG_INDTEVSTAGE11 = 0x1B, // indirect TEV stage 11\n\tGX_BP_REG_INDTEVSTAGE12 = 0x1C, // indirect TEV stage 12\n\tGX_BP_REG_INDTEVSTAGE13 = 0x1D, // indirect TEV stage 13\n\tGX_BP_REG_INDTEVSTAGE14 = 0x1E, // indirect TEV stage 14\n\tGX_BP_REG_INDTEVSTAGE15 = 0x1F, // indirect TEV stage 15\n\n\t// performance manips\n\tGX_BP_REG_SCISSORTL   = 0x20, // scissor top left\n\tGX_BP_REG_SCISSORBR   = 0x21, // scissor bottom right\n\tGX_BP_REG_LINEPTWIDTH = 0x22, // line point width\n\tGX_BP_REG_PERF0TRI    = 0x23, // performance 0 (triangle)\n\tGX_BP_REG_PERF0QUAD   = 0x24, // performance 0 (quad)\n\n\t// rasters\n\tGX_BP_REG_RAS1_SS0   = 0x25,\n\tGX_BP_REG_RAS1_SS1   = 0x26,\n\tGX_BP_REG_RAS1_IREF  = 0x27,\n\tGX_BP_REG_RAS1_TREF0 = 0x28,\n\tGX_BP_REG_RAS1_TREF1 = 0x29,\n\tGX_BP_REG_RAS1_TREF2 = 0x2A,\n\tGX_BP_REG_RAS1_TREF3 = 0x2B,\n\tGX_BP_REG_RAS1_TREF4 = 0x2C,\n\tGX_BP_REG_RAS1_TREF5 = 0x2D,\n\tGX_BP_REG_RAS1_TREF6 = 0x2E,\n\tGX_BP_REG_RAS1_TREF7 = 0x2F,\n\n\t// setup sizes\n\tGX_BP_REG_SU_SSIZE0 = 0x30,\n\tGX_BP_REG_SU_TSIZE0 = 0x31,\n\tGX_BP_REG_SU_SSIZE1 = 0x32,\n\tGX_BP_REG_SU_TSIZE1 = 0x33,\n\tGX_BP_REG_SU_SSIZE2 = 0x34,\n\tGX_BP_REG_SU_TSIZE2 = 0x35,\n\tGX_BP_REG_SU_SSIZE3 = 0x36,\n\tGX_BP_REG_SU_TSIZE3 = 0x37,\n\tGX_BP_REG_SU_SSIZE4 = 0x38,\n\tGX_BP_REG_SU_TSIZE4 = 0x39,\n\tGX_BP_REG_SU_SSIZE5 = 0x3A,\n\tGX_BP_REG_SU_TSIZE5 = 0x3B,\n\tGX_BP_REG_SU_SSIZE6 = 0x3C,\n\tGX_BP_REG_SU_TSIZE6 = 0x3D,\n\tGX_BP_REG_SU_SSIZE7 = 0x3E,\n\tGX_BP_REG_SU_TSIZE7 = 0x3F,\n\n\t// Z and blend controls\n\tGX_BP_REG_ZMODE      = 0x40,\n\tGX_BP_REG_BLENDMODE  = 0x41,\n\tGX_BP_REG_DSTALPHA   = 0x42,\n\tGX_BP_REG_ZCONTROL   = 0x43,\n\tGX_BP_REG_FIELDMASK  = 0x44,\n\tGX_BP_REG_DRAWDONE   = 0x45,\n\tGX_BP_REG_PETOKEN    = 0x47,\n\tGX_BP_REG_PETOKENINT = 0x48,\n\n\t// copying\n\tGX_BP_REG_TEXCOPYSRCXY   = 0x49,\n\tGX_BP_REG_TEXCOPYSRCWH   = 0x4A,\n\tGX_BP_REG_TEXCOPYDST     = 0x4B,\n\tGX_BP_REG_DISPCOPYSTRIDE = 0x4D,\n\tGX_BP_REG_DISPCOPYSCALEY = 0x4E,\n\tGX_BP_REG_COPYCLEARAR    = 0x4F,\n\tGX_BP_REG_COPYCLEARGB    = 0x50,\n\tGX_BP_REG_COPYCLEARZ     = 0x51,\n\tGX_BP_REG_COPYFILTER0    = 0x53,\n\tGX_BP_REG_COPYFILTER1    = 0x54,\n\n\t//\n\tGX_BP_REG_BOUNDINGBOX0 = 0x55,\n\tGX_BP_REG_BOUNDINGBOX1 = 0x56,\n\n\tGX_BP_REG_SCISSOROFFSET = 0x59,\n\n\t// texture memory\n\tGX_BP_REG_TMEMPRELOADADDR   = 0x60,\n\tGX_BP_REG_TMEMPRELOADEVEN   = 0x61,\n\tGX_BP_REG_TMEMPRELOADODD    = 0x62,\n\tGX_BP_REG_TMEMPRELOADMODE   = 0x63,\n\tGX_BP_REG_TMEMTLUTSRC       = 0x64,\n\tGX_BP_REG_TMEMTLUTDST       = 0x65,\n\tGX_BP_REG_TMEMTEXINVALIDATE = 0x66,\n\n\t// performance 1\n\tGX_BP_REG_PERF1     = 0x67,\n\tGX_BP_REG_FIELDMODE = 0x68,\n\n\t// set modes\n\tGX_BP_REG_SETMODE0_TEX0 = 0x80,\n\tGX_BP_REG_SETMODE0_TEX1 = 0x81,\n\tGX_BP_REG_SETMODE0_TEX2 = 0x82,\n\tGX_BP_REG_SETMODE0_TEX3 = 0x83,\n\tGX_BP_REG_SETMODE1_TEX0 = 0x84,\n\tGX_BP_REG_SETMODE1_TEX1 = 0x85,\n\tGX_BP_REG_SETMODE1_TEX2 = 0x86,\n\tGX_BP_REG_SETMODE1_TEX3 = 0x87,\n\n\t// set images\n\tGX_BP_REG_SETIMAGE0_TEX0 = 0x88,\n\tGX_BP_REG_SETIMAGE0_TEX1 = 0x89,\n\tGX_BP_REG_SETIMAGE0_TEX2 = 0x8A,\n\tGX_BP_REG_SETIMAGE0_TEX3 = 0x8B,\n\tGX_BP_REG_SETIMAGE1_TEX0 = 0x8C,\n\tGX_BP_REG_SETIMAGE1_TEX1 = 0x8D,\n\tGX_BP_REG_SETIMAGE1_TEX2 = 0x8E,\n\tGX_BP_REG_SETIMAGE1_TEX3 = 0x8F,\n\tGX_BP_REG_SETIMAGE2_TEX0 = 0x90,\n\tGX_BP_REG_SETIMAGE2_TEX1 = 0x91,\n\tGX_BP_REG_SETIMAGE2_TEX2 = 0x92,\n\tGX_BP_REG_SETIMAGE2_TEX3 = 0x93,\n\tGX_BP_REG_SETIMAGE3_TEX0 = 0x94,\n\tGX_BP_REG_SETIMAGE3_TEX1 = 0x95,\n\tGX_BP_REG_SETIMAGE3_TEX2 = 0x96,\n\tGX_BP_REG_SETIMAGE3_TEX3 = 0x97,\n\n\t// set texture lookups\n\tGX_BP_REG_SETTLUT_TEX0 = 0x98,\n\tGX_BP_REG_SETTLUT_TEX1 = 0x99,\n\tGX_BP_REG_SETTLUT_TEX2 = 0x9A,\n\tGX_BP_REG_SETTLUT_TEX3 = 0x9B,\n\n\t// set modes continued\n\tGX_BP_REG_SETMODE0_TEX4 = 0xA0,\n\tGX_BP_REG_SETMODE0_TEX5 = 0xA1,\n\tGX_BP_REG_SETMODE0_TEX6 = 0xA2,\n\tGX_BP_REG_SETMODE0_TEX7 = 0xA3,\n\tGX_BP_REG_SETMODE1_TEX4 = 0xA4,\n\tGX_BP_REG_SETMODE1_TEX5 = 0xA5,\n\tGX_BP_REG_SETMODE1_TEX6 = 0xA6,\n\tGX_BP_REG_SETMODE1_TEX7 = 0xA7,\n\n\t// set images continued\n\tGX_BP_REG_SETIMAGE0_TEX4 = 0xA8,\n\tGX_BP_REG_SETIMAGE0_TEX5 = 0xA9,\n\tGX_BP_REG_SETIMAGE0_TEX6 = 0xAA,\n\tGX_BP_REG_SETIMAGE0_TEX7 = 0xAB,\n\tGX_BP_REG_SETIMAGE1_TEX4 = 0xAC,\n\tGX_BP_REG_SETIMAGE1_TEX5 = 0xAD,\n\tGX_BP_REG_SETIMAGE1_TEX6 = 0xAE,\n\tGX_BP_REG_SETIMAGE1_TEX7 = 0xAF,\n\tGX_BP_REG_SETIMAGE2_TEX4 = 0xB0,\n\tGX_BP_REG_SETIMAGE2_TEX5 = 0xB1,\n\tGX_BP_REG_SETIMAGE2_TEX6 = 0xB2,\n\tGX_BP_REG_SETIMAGE2_TEX7 = 0xB3,\n\tGX_BP_REG_SETIMAGE3_TEX4 = 0xB4,\n\tGX_BP_REG_SETIMAGE3_TEX5 = 0xB5,\n\tGX_BP_REG_SETIMAGE3_TEX6 = 0xB6,\n\tGX_BP_REG_SETIMAGE3_TEX7 = 0xB7,\n\n\t// set texture lookups continued\n\tGX_BP_REG_SETTLUT_TEX4 = 0xB8,\n\tGX_BP_REG_SETTLUT_TEX5 = 0xB9,\n\tGX_BP_REG_SETTLUT_TEX6 = 0xBA,\n\tGX_BP_REG_SETTLUT_TEX7 = 0xBB,\n\n\t// TEV color manips\n\tGX_BP_REG_TEVCOLORCOMBINER0  = 0xC0,\n\tGX_BP_REG_TEVALPHACOMBINER0  = 0xC1,\n\tGX_BP_REG_TEVCOLORCOMBINER1  = 0xC2,\n\tGX_BP_REG_TEVALPHACOMBINER1  = 0xC3,\n\tGX_BP_REG_TEVCOLORCOMBINER2  = 0xC4,\n\tGX_BP_REG_TEVALPHACOMBINER2  = 0xC5,\n\tGX_BP_REG_TEVCOLORCOMBINER3  = 0xC6,\n\tGX_BP_REG_TEVALPHACOMBINER3  = 0xC7,\n\tGX_BP_REG_TEVCOLORCOMBINER4  = 0xC8,\n\tGX_BP_REG_TEVALPHACOMBINER4  = 0xC9,\n\tGX_BP_REG_TEVCOLORCOMBINER5  = 0xCA,\n\tGX_BP_REG_TEVALPHACOMBINER5  = 0xCB,\n\tGX_BP_REG_TEVCOLORCOMBINER6  = 0xCC,\n\tGX_BP_REG_TEVALPHACOMBINER6  = 0xCD,\n\tGX_BP_REG_TEVCOLORCOMBINER7  = 0xCE,\n\tGX_BP_REG_TEVALPHACOMBINER7  = 0xCF,\n\tGX_BP_REG_TEVCOLORCOMBINER8  = 0xD0,\n\tGX_BP_REG_TEVALPHACOMBINER8  = 0xD1,\n\tGX_BP_REG_TEVCOLORCOMBINER9  = 0xD2,\n\tGX_BP_REG_TEVALPHACOMBINER9  = 0xD3,\n\tGX_BP_REG_TEVCOLORCOMBINER10 = 0xD4,\n\tGX_BP_REG_TEVALPHACOMBINER10 = 0xD5,\n\tGX_BP_REG_TEVCOLORCOMBINER11 = 0xD6,\n\tGX_BP_REG_TEVALPHACOMBINER11 = 0xD7,\n\tGX_BP_REG_TEVCOLORCOMBINER12 = 0xD8,\n\tGX_BP_REG_TEVALPHACOMBINER12 = 0xD9,\n\tGX_BP_REG_TEVCOLORCOMBINER13 = 0xDA,\n\tGX_BP_REG_TEVALPHACOMBINER13 = 0xDB,\n\tGX_BP_REG_TEVCOLORCOMBINER14 = 0xDC,\n\tGX_BP_REG_TEVALPHACOMBINER14 = 0xDD,\n\tGX_BP_REG_TEVCOLORCOMBINER15 = 0xDE,\n\tGX_BP_REG_TEVALPHACOMBINER15 = 0xDF,\n\n\t// TEV registers\n\tGX_BP_REG_TEVREG0LO = 0xE0,\n\tGX_BP_REG_TEVREG0HI = 0xE1,\n\tGX_BP_REG_TEVREG1LO = 0xE2,\n\tGX_BP_REG_TEVREG1HI = 0xE3,\n\tGX_BP_REG_TEVREG2LO = 0xE4,\n\tGX_BP_REG_TEVREG2HI = 0xE5,\n\tGX_BP_REG_TEVREG3LO = 0xE6,\n\tGX_BP_REG_TEVREG3HI = 0xE7,\n\n\t// fog registers\n\tGX_BP_REG_FOGRANGE   = 0xE8,\n\tGX_BP_REG_FOGRANGEK0 = 0xE9,\n\tGX_BP_REG_FOGRANGEK1 = 0xEA,\n\tGX_BP_REG_FOGRANGEK2 = 0xEB,\n\tGX_BP_REG_FOGRANGEK3 = 0xEC,\n\tGX_BP_REG_FOGRANGEK4 = 0xED,\n\tGX_BP_REG_FOGPARAM0  = 0xEE,\n\tGX_BP_REG_FOGPARAM1  = 0xEF,\n\tGX_BP_REG_FOGPARAM2  = 0xF0,\n\tGX_BP_REG_FOGPARAM3  = 0xF1,\n\tGX_BP_REG_FOGCOLOR   = 0xF2,\n\n\t// performance manip registers\n\tGX_BP_REG_ALPHACOMPARE = 0xF3,\n\tGX_BP_REG_ZTEXTURE0    = 0xF4,\n\tGX_BP_REG_ZTEXTURE1    = 0xF5,\n\n\t// TEV K selectors\n\tGX_BP_REG_TEVKSEL0 = 0xF6,\n\tGX_BP_REG_TEVKSEL1 = 0xF7,\n\tGX_BP_REG_TEVKSEL2 = 0xF8,\n\tGX_BP_REG_TEVKSEL3 = 0xF9,\n\tGX_BP_REG_TEVKSEL4 = 0xFA,\n\tGX_BP_REG_TEVKSEL5 = 0xFB,\n\tGX_BP_REG_TEVKSEL6 = 0xFC,\n\tGX_BP_REG_TEVKSEL7 = 0xFD,\n\n\t// SS mask\n\tGX_BP_REG_SSMASK = 0xFE,\n} GXBPRegs;\n\n// Command processor registers.\ntypedef enum _GXCPRegs {\n\tGX_CP_REG_MTXIDXA     = 0x30, // Matrix index A\n\tGX_CP_REG_MTXIDXB     = 0x40, // Matrix index B\n\tGX_CP_REG_VCD_LO      = 0x50, // Vertex descriptor (lo)\n\tGX_CP_REG_VCD_HI      = 0x60, // Vertex descriptor (hi)\n\tGX_CP_REG_VAT_GRP0    = 0x70, // Vertex attribute table (group 0)\n\tGX_CP_REG_VAT_GRP1    = 0x80, // Vertex attribute table (group 1)\n\tGX_CP_REG_VAT_GRP2    = 0x90, // Vertex attribute table (group 2)\n\tGX_CP_REG_ARRAYBASE   = 0xA0, // Vertex array start/base\n\tGX_CP_REG_ARRAYSTRIDE = 0xB0, // Vertex array stride\n} GXCPRegs;\n\n// Transform unit registers.\ntypedef enum _GXXFRegs {\n\tGX_XF_REG_ERROR        = 0x1000,\n\tGX_XF_REG_DIAGNOSTICS  = 0x1001,\n\tGX_XF_REG_STATE0       = 0x1002,\n\tGX_XF_REG_STATE1       = 0x1003,\n\tGX_XF_REG_CLOCK        = 0x1004,\n\tGX_XF_REG_CLIPDISABLE  = 0x1005,\n\tGX_XF_REG_PERF0        = 0x1006,\n\tGX_XF_REG_PERF1        = 0x1007,\n\tGX_XF_REG_INVERTEXSPEC = 0x1008,\n\tGX_XF_REG_NUMCOLORS    = 0x1009,\n\tGX_XF_REG_AMBIENT0     = 0x100A,\n\tGX_XF_REG_AMBIENT1     = 0x100B,\n\tGX_XF_REG_MATERIAL0    = 0x100C,\n\tGX_XF_REG_MATERIAL1    = 0x100D,\n\tGX_XF_REG_COLOR0CNTRL  = 0x100E,\n\tGX_XF_REG_COLOR1CNTRL  = 0x100F,\n\tGX_XF_REG_ALPHA0CNTRL  = 0x1010,\n\tGX_XF_REG_ALPHA1CNTRL  = 0x1011,\n\tGX_XF_REG_DUALTEXTRAN  = 0x1012,\n\tGX_XF_REG_MATRIXINDEX0 = 0x1018,\n\tGX_XF_REG_MATRIXINDEX1 = 0x1019,\n\tGX_XF_REG_SCALEX       = 0x101A,\n\tGX_XF_REG_SCALEY       = 0x101B,\n\tGX_XF_REG_SCALEZ       = 0x101C,\n\tGX_XF_REG_OFFSETX      = 0x101D,\n\tGX_XF_REG_OFFSETY      = 0x101E,\n\tGX_XF_REG_OFFSETZ      = 0x101F,\n\tGX_XF_REG_PROJECTIONA  = 0x1020,\n\tGX_XF_REG_PROJECTIONB  = 0x1021,\n\tGX_XF_REG_PROJECTIONC  = 0x1022,\n\tGX_XF_REG_PROJECTIOND  = 0x1023,\n\tGX_XF_REG_PROJECTIONE  = 0x1024,\n\tGX_XF_REG_PROJECTIONF  = 0x1025,\n\tGX_XF_REG_PROJECTORTHO = 0x1026,\n\tGX_XF_REG_NUMTEX       = 0x103F,\n\tGX_XF_REG_TEX0         = 0x1040,\n\tGX_XF_REG_TEX1         = 0x1041,\n\tGX_XF_REG_TEX2         = 0x1042,\n\tGX_XF_REG_TEX3         = 0x1043,\n\tGX_XF_REG_TEX4         = 0x1044,\n\tGX_XF_REG_TEX5         = 0x1045,\n\tGX_XF_REG_TEX6         = 0x1046,\n\tGX_XF_REG_TEX7         = 0x1047,\n\tGX_XF_REG_DUALTEX0     = 0x1050,\n\tGX_XF_REG_DUALTEX1     = 0x1051,\n\tGX_XF_REG_DUALTEX2     = 0x1052,\n\tGX_XF_REG_DUALTEX3     = 0x1053,\n\tGX_XF_REG_DUALTEX4     = 0x1054,\n\tGX_XF_REG_DUALTEX5     = 0x1055,\n\tGX_XF_REG_DUALTEX6     = 0x1056,\n\tGX_XF_REG_DUALTEX7     = 0x1057,\n} GXXFRegs;\n\n// BP GenMode locators.\ntypedef enum _GXBPGenMode {\n\t// Active texture counts [28-31]\n\tGX_BP_GENMODE_NUMTEX_ST  = 28,\n\tGX_BP_GENMODE_NUMTEX_END = 31,\n\n\t// Color/channel counts [25-27]\n\tGX_BP_GENMODE_NUMCOLORS_ST  = 25,\n\tGX_BP_GENMODE_NUMCOLORS_END = 27,\n\n\t// Multisample mode [22-22]\n\tGX_BP_GENMODE_MULTISAMPLE_ST  = 22,\n\tGX_BP_GENMODE_MULTISAMPLE_END = 22,\n\n\t// Cull mode [16-17]\n\tGX_BP_GENMODE_CULLMODE_ST  = 16,\n\tGX_BP_GENMODE_CULLMODE_END = 17,\n\n\t// Indirect stage counts [13-15]\n\tGX_BP_GENMODE_NUMINDSTAGES_ST  = 13,\n\tGX_BP_GENMODE_NUMINDSTAGES_END = 15,\n\n\t// Toggle co-planar/Z-freeze [12-12]\n\tGX_BP_GENMODE_COPLANAR_ST  = 12,\n\tGX_BP_GENMODE_COPLANAR_END = 12,\n} GXBPGenMode;\n\n// BP locators for indirect texture matrices (same for A, B, and C).\ntypedef enum _GXBPIndMtx {\n\t// Texture offset matrix [0][0] [21-31]\n\tGX_BP_INDMTX_M00_ST  = 21,\n\tGX_BP_INDMTX_M00_END = 31,\n\n\t// Texture offset matrix [1][0] [10-20]\n\tGX_BP_INDMTX_M10_ST  = 10,\n\tGX_BP_INDMTX_M10_END = 20,\n\n\t// Texture scaling exponent (2^x) [8-9]\n\tGX_BP_INDMTX_EXP_ST  = 8,\n\tGX_BP_INDMTX_EXP_END = 9,\n} GXBPIndMtx;\n\n// BP locators for indirect texture masks.\ntypedef enum _GXBPIndIMask {\n\t// Indirect mask [24-31]\n\tGX_BP_INDIMASK_ST  = 24,\n\tGX_BP_INDIMASK_END = 31,\n} GXBPIndIMask;\n\n// BP locators for indirect texture environment details.\ntypedef enum _GXBPIndTevStage {\n\t// Indirect texture stage ID [30-31]\n\tGX_BP_INDTEV_STAGE_ST  = 30,\n\tGX_BP_INDTEV_STAGE_END = 31,\n\n\t// Indirect texture format [28-29]\n\tGX_BP_INDTEV_FMT_ST  = 28,\n\tGX_BP_INDTEV_FMT_END = 29,\n\n\t// Indirect texture bias [25-27]\n\tGX_BP_INDTEV_BIAS_ST  = 25,\n\tGX_BP_INDTEV_BIAS_END = 27,\n\n\t// Indirect texture alpha [23-24]\n\tGX_BP_INDTEV_ALPHA_ST  = 23,\n\tGX_BP_INDTEV_ALPHA_END = 24,\n\n\t// Indirect texture matrices [19-22]\n\tGX_BP_INDTEV_MTX_ST  = 19,\n\tGX_BP_INDTEV_MTX_END = 22,\n\n\t// Indirect texture S component wrap factor [16-18]\n\tGX_BP_INDTEV_WRAPS_ST  = 16,\n\tGX_BP_INDTEV_WRAPS_END = 18,\n\n\t// Indirect texture T component wrap factor [13-15]\n\tGX_BP_INDTEV_WRAPT_ST  = 13,\n\tGX_BP_INDTEV_WRAPT_END = 15,\n\n\t// Indirect texture unmodified texcoord setting (for mipmaps) [12-12]\n\tGX_BP_INDTEV_UNMODTEXCOORD_ST  = 12,\n\tGX_BP_INDTEV_UNMODTEXCOORD_END = 12,\n\n\t// Indiret texture add previous results setting [11-11]\n\tGX_BP_INDTEV_ADDPREV_ST  = 11,\n\tGX_BP_INDTEV_ADDPREV_END = 11,\n} GXBPIndTevStage;\n\n// BP locators for top-left scissor.\ntypedef enum _GXBPScissorTL {\n\t// Top component [21-31]\n\tGX_BP_SCISSORTL_TOP_ST  = 21,\n\tGX_BP_SCISSORTL_TOP_END = 31,\n\n\t// Left component [9-19]\n\tGX_BP_SCISSORTL_LEFT_ST  = 9,\n\tGX_BP_SCISSORTL_LEFT_END = 19,\n} GXBPScissorTL;\n\n// BP locators for bottom-right scissor.\ntypedef enum _GXBPScissorBR {\n\t// Bottom component [21-31]\n\tGX_BP_SCISSORBR_BOT_ST  = 21,\n\tGX_BP_SCISSORBR_BOT_END = 31,\n\n\t// Right component [9-19]\n\tGX_BP_SCISSORBR_RIGHT_ST  = 9,\n\tGX_BP_SCISSORBR_RIGHT_END = 19,\n} GXBPScissorBR;\n\n// BP locators for line and point settings.\ntypedef enum _GXBPLinePtWidth {\n\t// Line size/width [24-31]\n\tGX_BP_LINEPTWIDTH_LINESZ_ST  = 24,\n\tGX_BP_LINEPTWIDTH_LINESZ_END = 31,\n\n\t// Point size [16-23]\n\tGX_BP_LINEPTWIDTH_POINTSZ_ST  = 16,\n\tGX_BP_LINEPTWIDTH_POINTSZ_END = 23,\n\n\t// Line offset [13-15]\n\tGX_BP_LINEPTWIDTH_LINEOFS_ST  = 13,\n\tGX_BP_LINEPTWIDTH_LINEOFS_END = 15,\n\n\t// Point offset [10-12]\n\tGX_BP_LINEPTWIDTH_POINTOFS_ST  = 10,\n\tGX_BP_LINEPTWIDTH_POINTOFS_END = 12,\n\n\t// Interlacing adjustment for aspect ratio [9-9]\n\tGX_BP_LINEPTWIDTH_ADJUST_ST  = 9,\n\tGX_BP_LINEPTWIDTH_ADJUST_END = 9,\n} GXBPLinePtWidth;\n\n// BP locators for raster 1 SS0.\ntypedef enum _GXBPRas1SS0 {\n\t// S-component scale (stage 0) [28-31]\n\tGX_BP_RAS1_SS0_S0_ST  = 28,\n\tGX_BP_RAS1_SS0_S0_END = 31,\n\n\t// T-component scale (stage 0) [24-27]\n\tGX_BP_RAS1_SS0_T0_ST  = 24,\n\tGX_BP_RAS1_SS0_T0_END = 27,\n\n\t// S-component scale (stage 1) [20-23]\n\tGX_BP_RAS1_SS0_S1_ST  = 20,\n\tGX_BP_RAS1_SS0_S1_END = 23,\n\n\t// T-component scale (stage 1) [16-19]\n\tGX_BP_RAS1_SS0_T1_ST  = 16,\n\tGX_BP_RAS1_SS0_T1_END = 19,\n} GXBPRas1SS0;\n\n// BP locators for raster 1 SS1.\ntypedef enum _GXBPRas1SS1 {\n\t// S-component scale (stage 2) [28-31]\n\tGX_BP_RAS1_SS1_S2_ST  = 28,\n\tGX_BP_RAS1_SS1_S2_END = 31,\n\n\t// T-component scale (stage 2) [24-27]\n\tGX_BP_RAS1_SS1_T2_ST  = 24,\n\tGX_BP_RAS1_SS1_T2_END = 27,\n\n\t// S-component scale (stage 3) [20-23]\n\tGX_BP_RAS1_SS1_S3_ST  = 20,\n\tGX_BP_RAS1_SS1_S3_END = 23,\n\n\t// T-component scale (stage 3) [16-19]\n\tGX_BP_RAS1_SS1_T3_ST  = 16,\n\tGX_BP_RAS1_SS1_T3_END = 19,\n} GXBPRas1SS1;\n\n// BP locators for raster 1 ID-reference.\ntypedef enum _GXBPRasIRef {\n\t// Texmap ID (stage 0) [29-31]\n\tGX_BP_RAS1_IREF_MAP0_ST  = 29,\n\tGX_BP_RAS1_IREF_MAP0_END = 31,\n\n\t// Texcoord ID (stage 0) [26-28]\n\tGX_BP_RAS1_IREF_TXC0_ST  = 26,\n\tGX_BP_RAS1_IREF_TXC0_END = 28,\n\n\t// Texmap ID (stage 1) [23-25]\n\tGX_BP_RAS1_IREF_MAP1_ST  = 23,\n\tGX_BP_RAS1_IREF_MAP1_END = 25,\n\n\t// Texcoord ID (stage 1) [20-22]\n\tGX_BP_RAS1_IREF_TXC1_ST  = 20,\n\tGX_BP_RAS1_IREF_TXC1_END = 22,\n\n\t// Texmap ID (stage 2) [17-19]\n\tGX_BP_RAS1_IREF_MAP2_ST  = 17,\n\tGX_BP_RAS1_IREF_MAP2_END = 19,\n\n\t// Texcoord ID (stage 2) [14-16]\n\tGX_BP_RAS1_IREF_TXC2_ST  = 14,\n\tGX_BP_RAS1_IREF_TXC2_END = 16,\n\n\t// Texmap ID (stage 3) [11-13]\n\tGX_BP_RAS1_IREF_MAP3_ST  = 11,\n\tGX_BP_RAS1_IREF_MAP3_END = 13,\n\n\t// Texcoord ID (stage 3) [8-10]\n\tGX_BP_RAS1_IREF_TXC3_ST  = 8,\n\tGX_BP_RAS1_IREF_TXC3_END = 10,\n} GXBPRasIRef;\n\n// BP locators for setup size.\ntypedef enum _GXBPSUSSize {\n\t// Use line offsets [13-13]\n\tGX_BP_SU_SSIZE_USELINEOFS_ST  = 13,\n\tGX_BP_SU_SSIZE_USELINEOFS_END = 13,\n\n\t// Use point offsets [12-12]\n\tGX_BP_SU_SSIZE_USEPTOFS_ST  = 12,\n\tGX_BP_SU_SSIZE_USEPTOFS_END = 12,\n} GXBPSUSSize;\n\n// BP locators for Z mode.\ntypedef enum _GXBPZMode {\n\t// Test enable [31-31]\n\tGX_BP_ZMODE_TEST_ENABLE_ST  = 31,\n\tGX_BP_ZMODE_TEST_ENABLE_END = 31,\n\n\t// Compare [28-30]\n\tGX_BP_ZMODE_COMPARE_ST  = 28,\n\tGX_BP_ZMODE_COMPARE_END = 30,\n\n\t// Update enable [27-27]\n\tGX_BP_ZMODE_UPDATE_ENABLE_ST  = 27,\n\tGX_BP_ZMODE_UPDATE_ENABLE_END = 27,\n} GXBPZMode;\n\n// BP locators for blend mode.\ntypedef enum _GXBPBlendMode {\n\t// Blend enable [31-31]\n\tGX_BP_BLENDMODE_ENABLE_ST  = 31,\n\tGX_BP_BLENDMODE_ENABLE_END = 31,\n\n\t// Logic operation enable [30-30]\n\tGX_BP_BLENDMODE_LOGIC_OP_ST  = 30,\n\tGX_BP_BLENDMODE_LOGIC_OP_END = 30,\n\n\t// Dither [29-29]\n\tGX_BP_BLENDMODE_DITHER_ST  = 29,\n\tGX_BP_BLENDMODE_DITHER_END = 29,\n\n\t// Color update [28-28]\n\tGX_BP_BLENDMODE_COLOR_UPDATE_ST  = 28,\n\tGX_BP_BLENDMODE_COLOR_UPDATE_END = 28,\n\n\t// Alpha update [27-27]\n\tGX_BP_BLENDMODE_ALPHA_UPDATE_ST  = 27,\n\tGX_BP_BLENDMODE_ALPHA_UPDATE_END = 27,\n\n\t// Destination factor [24-26]\n\tGX_BP_BLENDMODE_DSTFACTOR_ST  = 24,\n\tGX_BP_BLENDMODE_DSTFACTOR_END = 26,\n\n\t// Source factor [21-23]\n\tGX_BP_BLENDMODE_SRCFACTOR_ST  = 21,\n\tGX_BP_BLENDMODE_SRCFACTOR_END = 23,\n\n\t// Subtract [20-20]\n\tGX_BP_BLENDMODE_SUBTRACT_ST  = 20,\n\tGX_BP_BLENDMODE_SUBTRACT_END = 20,\n\n\t// Logic mode [16-19]\n\tGX_BP_BLENDMODE_LOGICMODE_ST  = 16,\n\tGX_BP_BLENDMODE_LOGICMODE_END = 19,\n} GXBPBlendMode;\n\n// BP locators for destination alpha.\ntypedef enum _GXBPDstAlpha {\n\t// Alpha [24-31]\n\tGX_BP_DSTALPHA_ALPHA_ST  = 24,\n\tGX_BP_DSTALPHA_ALPHA_END = 31,\n\n\t// Enable [23-23]\n\tGX_BP_DSTALPHA_ENABLE_ST  = 23,\n\tGX_BP_DSTALPHA_ENABLE_END = 23,\n\n\t// YUV format [21-22]\n\tGX_BP_DSTALPHA_YUV_FMT_ST  = 21,\n\tGX_BP_DSTALPHA_YUV_FMT_END = 22,\n} GXBPDstAlpha;\n\n// BP locators for Z control.\ntypedef enum _GXBPZControl {\n\t// Pixel format [29-31]\n\tGX_BP_ZCONTROL_PIXEL_FMT_ST  = 29,\n\tGX_BP_ZCONTROL_PIXEL_FMT_END = 31,\n\n\t// Z format [26-28]\n\tGX_BP_ZCONTROL_Z_FMT_ST  = 26,\n\tGX_BP_ZCONTROL_Z_FMT_END = 28,\n\n\t// Whether to do Z-buffering before or after texturing [25-25]\n\tGX_BP_ZCONTROL_BEFORE_TEX_ST  = 25,\n\tGX_BP_ZCONTROL_BEFORE_TEX_END = 25,\n} GXBPZControl;\n\n// BP locators for field mask.\ntypedef enum _GXBPFieldMask {\n\t// Whether to write odd fields to the EFB [31-31]\n\tGX_BP_FIELDMASK_ODD_ST  = 31,\n\tGX_BP_FIELDMASK_ODD_END = 31,\n\n\t// Whether to write even fields to the EFB [30-30]\n\tGX_BP_FIELDMASK_EVEN_ST  = 30,\n\tGX_BP_FIELDMASK_EVEN_END = 30,\n} GXBPFieldMask;\n\n// BP locators for scissor offset.\ntypedef enum _GXBPScissorOffset {\n\t// X offset [22-31]\n\tGX_BP_SCISSOROFS_OX_ST  = 22,\n\tGX_BP_SCISSOROFS_OX_END = 31,\n\n\t// Y offset [12-21]\n\tGX_BP_SCISSOROFS_OY_ST  = 12,\n\tGX_BP_SCISSOROFS_OY_END = 21,\n} GXBPScissorOffset;\n\n// BP locators for field mode.\ntypedef enum _GXBPFieldMode {\n\t// Adjust vertex tex LOD computation to account for interlacing\n\tGX_BP_FIELDMODE_TEX_LOD_ST  = 31,\n\tGX_BP_FIELDMODE_TEX_LOD_END = 31,\n} GXBPFieldMode;\n\n// BP locators for fog range.\ntypedef enum _GXBPFogRange {\n\t// Center [22-31]\n\tGX_BP_FOGRANGE_CENTER_ST  = 22,\n\tGX_BP_FOGRANGE_CENTER_END = 31,\n\n\t// Enabled [21-21]\n\tGX_BP_FOGRANGE_ENABLED_ST  = 21,\n\tGX_BP_FOGRANGE_ENABLED_END = 21,\n} GXBPFogRange;\n\n// BP locators for fog range K.\ntypedef enum _GXBPFogRangeK {\n\t// Hi [20-31]\n\tGX_BP_FOGRANGEK_HI_ST  = 20,\n\tGX_BP_FOGRANGEK_HI_END = 31,\n\n\t// Lo [8-19]\n\tGX_BP_FOGRANGEK_LO_ST  = 8,\n\tGX_BP_FOGRANGEK_LO_END = 19,\n} GXBPFogRangeK;\n\n// BP locators for fog parameter 0.\ntypedef enum _GXBPFogParam0 {\n\t// A mantissa [21-31]\n\tGX_BP_FOGPARAM0_A_MANT_ST  = 21,\n\tGX_BP_FOGPARAM0_A_MANT_END = 31,\n\n\t// A exponent [13-20]\n\tGX_BP_FOGPARAM0_A_EXP_ST  = 13,\n\tGX_BP_FOGPARAM0_A_EXP_END = 20,\n\n\t// A sign [12-12]\n\tGX_BP_FOGPARAM0_A_SIGN_ST  = 12,\n\tGX_BP_FOGPARAM0_A_SIGN_END = 12,\n} GXBPFogParam0;\n\n// BP locators for fog parameter 1.\ntypedef enum _GXBPFogParam1 {\n\t// B magnitude [8-31]\n\tGX_BP_FOGPARAM1_B_MAG_ST  = 8,\n\tGX_BP_FOGPARAM1_B_MAG_END = 31,\n} GXBPFogParam1;\n\n// BP locators for fog parameter 2.\ntypedef enum _GXBPFogParam2 {\n\t// B shift [27-31]\n\tGX_BP_FOGPARAM2_B_SHIFT_ST  = 27,\n\tGX_BP_FOGPARAM2_B_SHIFT_END = 31,\n} GXBPFogParam2;\n\n// BP locators for fog parameter 3.\ntypedef enum _GXBPFogParam3 {\n\t// C mantissa [21-31]\n\tGX_BP_FOGPARAM3_C_MANT_ST  = 21,\n\tGX_BP_FOGPARAM3_C_MANT_END = 31,\n\n\t// C exponent [13-20]\n\tGX_BP_FOGPARAM3_C_EXP_ST  = 13,\n\tGX_BP_FOGPARAM3_C_EXP_END = 20,\n\n\t// C sign [12-12]\n\tGX_BP_FOGPARAM3_C_SIGN_ST  = 12,\n\tGX_BP_FOGPARAM3_C_SIGN_END = 12,\n\n\t// Projection [11]\n\tGX_BP_FOGPARAM3_PROJ_ST  = 11,\n\tGX_BP_FOGPARAM3_PROJ_END = 11,\n\n\t// F select [8-10]\n\tGX_BP_FOGPARAM3_FSEL_ST  = 8,\n\tGX_BP_FOGPARAM3_FSEL_END = 10,\n} GXBPFogParam3;\n\n// BP locators for fog color.\ntypedef enum _GXBPFogColor {\n\t// RGB components of color [8-31]\n\tGX_BP_FOGCOLOR_RGB_ST  = 8,\n\tGX_BP_FOGCOLOR_RGB_END = 31,\n} GXBPFogColor;\n\n// CP locator for matrix index A.\ntypedef enum _GXCPMtxIdxA {\n\t// Geometry [26-31]\n\tGX_CP_MTXIDXA_GEOM_ST  = 26,\n\tGX_CP_MTXIDXA_GEOM_END = 31,\n\n\t// Tex0 [20-25]\n\tGX_CP_MTXIDXA_TEX0_ST  = 20,\n\tGX_CP_MTXIDXA_TEX0_END = 25,\n\n\t// Tex1 [14-19]\n\tGX_CP_MTXIDXA_TEX1_ST  = 14,\n\tGX_CP_MTXIDXA_TEX1_END = 19,\n\n\t// Tex2 [8-13]\n\tGX_CP_MTXIDXA_TEX2_ST  = 8,\n\tGX_CP_MTXIDXA_TEX2_END = 13,\n\n\t// Tex3 [2-7]\n\tGX_CP_MTXIDXA_TEX3_ST  = 2,\n\tGX_CP_MTXIDXA_TEX3_END = 7,\n} GXCPMtxIdxA;\n\n// CP locator for matrix index B.\ntypedef enum _GXCPMtxIdxB {\n\t// Tex4 [26-31]\n\tGX_CP_MTXIDXB_TEX4_ST  = 26,\n\tGX_CP_MTXIDXB_TEX4_END = 31,\n\n\t// Tex5 [20-25]\n\tGX_CP_MTXIDXB_TEX5_ST  = 20,\n\tGX_CP_MTXIDXB_TEX5_END = 25,\n\n\t// Tex6 [14-19]\n\tGX_CP_MTXIDXB_TEX6_ST  = 14,\n\tGX_CP_MTXIDXB_TEX6_END = 19,\n\n\t// Tex7 [8-13]\n\tGX_CP_MTXIDXB_TEX7_ST  = 8,\n\tGX_CP_MTXIDXB_TEX7_END = 13,\n} GXCPMtxIdxB;\n\n// CP locator for vertex descriptor (lo).\ntypedef enum _GXCPVCDLo {\n\t// Position matrix idx [31]\n\tGX_CP_VCD_LO_POSMTXIDX_ST  = 31,\n\tGX_CP_VCD_LO_POSMTXIDX_END = 31,\n\n\t// Tex 0 matrix idx [30]\n\tGX_CP_VCD_LO_TEX0MTXIDX_ST  = 30,\n\tGX_CP_VCD_LO_TEX0MTXIDX_END = 30,\n\n\t// Tex 1 matrix idx [29]\n\tGX_CP_VCD_LO_TEX1MTXIDX_ST  = 29,\n\tGX_CP_VCD_LO_TEX1MTXIDX_END = 29,\n\n\t// Tex 2 matrix idx [28]\n\tGX_CP_VCD_LO_TEX2MTXIDX_ST  = 28,\n\tGX_CP_VCD_LO_TEX2MTXIDX_END = 28,\n\n\t// Tex 3 matrix idx [27]\n\tGX_CP_VCD_LO_TEX3MTXIDX_ST  = 27,\n\tGX_CP_VCD_LO_TEX3MTXIDX_END = 27,\n\n\t// Tex 4 matrix idx [26]\n\tGX_CP_VCD_LO_TEX4MTXIDX_ST  = 26,\n\tGX_CP_VCD_LO_TEX4MTXIDX_END = 26,\n\n\t// Tex 5 matrix idx [25]\n\tGX_CP_VCD_LO_TEX5MTXIDX_ST  = 25,\n\tGX_CP_VCD_LO_TEX5MTXIDX_END = 25,\n\n\t// Tex 6 matrix idx [24]\n\tGX_CP_VCD_LO_TEX6MTXIDX_ST  = 24,\n\tGX_CP_VCD_LO_TEX6MTXIDX_END = 24,\n\n\t// Tex 7 matrix idx [23]\n\tGX_CP_VCD_LO_TEX7MTXIDX_ST  = 23,\n\tGX_CP_VCD_LO_TEX7MTXIDX_END = 23,\n\n\t// Position [21-22]\n\tGX_CP_VCD_LO_POS_ST  = 21,\n\tGX_CP_VCD_LO_POS_END = 22,\n\n\t// Normal [19-20]\n\tGX_CP_VCD_LO_NRM_ST  = 19,\n\tGX_CP_VCD_LO_NRM_END = 20,\n\n\t// Color diffused [17-18]\n\tGX_CP_VCD_LO_CLRDIF_ST  = 17,\n\tGX_CP_VCD_LO_CLRDIF_END = 18,\n\n\t// Color specular [15-16]\n\tGX_CP_VCD_LO_CLRSPEC_ST  = 15,\n\tGX_CP_VCD_LO_CLRSPEC_END = 16,\n} GXCPVCDLo;\n\n// CP locators for vertex descriptor (hi).\ntypedef enum _GXCPVCDHi {\n\t// Tex0 coordinates [30-31]\n\tGX_CP_VCD_HI_TEX0COORD_ST  = 30,\n\tGX_CP_VCD_HI_TEX0COORD_END = 31,\n\n\t// Tex1 coordinates [28-29]\n\tGX_CP_VCD_HI_TEX1COORD_ST  = 28,\n\tGX_CP_VCD_HI_TEX1COORD_END = 29,\n\n\t// Tex2 coordinates [26-27]\n\tGX_CP_VCD_HI_TEX2COORD_ST  = 26,\n\tGX_CP_VCD_HI_TEX2COORD_END = 27,\n\n\t// Tex3 coordinates [24-25]\n\tGX_CP_VCD_HI_TEX3COORD_ST  = 24,\n\tGX_CP_VCD_HI_TEX3COORD_END = 25,\n\n\t// Tex4 coordinates [22-23]\n\tGX_CP_VCD_HI_TEX4COORD_ST  = 22,\n\tGX_CP_VCD_HI_TEX4COORD_END = 23,\n\n\t// Tex5 coordinates [20-21]\n\tGX_CP_VCD_HI_TEX5COORD_ST  = 20,\n\tGX_CP_VCD_HI_TEX5COORD_END = 21,\n\n\t// Tex6 coordinates [18-19]\n\tGX_CP_VCD_HI_TEX6COORD_ST  = 18,\n\tGX_CP_VCD_HI_TEX6COORD_END = 19,\n\n\t// Tex7 coordinates [16-17]\n\tGX_CP_VCD_HI_TEX7COORD_ST  = 16,\n\tGX_CP_VCD_HI_TEX7COORD_END = 17,\n} GXCPVCDHi;\n\n// CP locator for vertex attribute table (group 0).\ntypedef enum _GXCPVATGrp0 {\n\t// Position count [31-31]\n\tGX_CP_VAT_GRP0_POS_CNT_ST  = 31,\n\tGX_CP_VAT_GRP0_POS_CNT_END = 31,\n\n\t// Position type [28-30]\n\tGX_CP_VAT_GRP0_POS_TYPE_ST  = 28,\n\tGX_CP_VAT_GRP0_POS_TYPE_END = 30,\n\n\t// Position shift [23-27]\n\tGX_CP_VAT_GRP0_POS_SHIFT_ST  = 23,\n\tGX_CP_VAT_GRP0_POS_SHIFT_END = 27,\n\n\t// Normal count [22-22]\n\tGX_CP_VAT_GRP0_NRM_CNT_ST  = 22,\n\tGX_CP_VAT_GRP0_NRM_CNT_END = 22,\n\n\t// Normal type [19-21]\n\tGX_CP_VAT_GRP0_NRM_TYPE_ST  = 19,\n\tGX_CP_VAT_GRP0_NRM_TYPE_END = 21,\n\n\t// Color diffused count [18-18]\n\tGX_CP_VAT_GRP0_CLRDIFF_CNT_ST  = 18,\n\tGX_CP_VAT_GRP0_CLRDIFF_CNT_END = 18,\n\n\t// Color diffused type [15-17]\n\tGX_CP_VAT_GRP0_CLRDIFF_TYPE_ST  = 15,\n\tGX_CP_VAT_GRP0_CLRDIFF_TYPE_END = 17,\n\n\t// Color specular count [14-14]\n\tGX_CP_VAT_GRP0_CLRSPEC_CNT_ST  = 14,\n\tGX_CP_VAT_GRP0_CLRSPEC_CNT_END = 14,\n\n\t// Color specular type [11-13]\n\tGX_CP_VAT_GRP0_CLRSPEC_TYPE_ST  = 11,\n\tGX_CP_VAT_GRP0_CLRSPEC_TYPE_END = 13,\n\n\t// Tex0 coord count [10-10]\n\tGX_CP_VAT_GRP0_TXC0_CNT_ST  = 10,\n\tGX_CP_VAT_GRP0_TXC0_CNT_END = 10,\n\n\t// Tex0 coord type [7-9]\n\tGX_CP_VAT_GRP0_TXC0_TYPE_ST  = 7,\n\tGX_CP_VAT_GRP0_TXC0_TYPE_END = 9,\n\n\t// Tex0 coord shift [2-6]\n\tGX_CP_VAT_GRP0_TXC0_SHIFT_ST  = 2,\n\tGX_CP_VAT_GRP0_TXC0_SHIFT_END = 6,\n\n\t// Byte dequantised [1-1]\n\tGX_CP_VAT_GRP0_BYTEDEQ_ST  = 1,\n\tGX_CP_VAT_GRP0_BYTEDEQ_END = 1,\n\n\t// Normal index 3 [0-0] (Input will be treated as three staggered indices (one per triple biased by component size) into normal table))\n\tGX_CP_VAT_GRP0_NRMIDX3_ST  = 0,\n\tGX_CP_VAT_GRP0_NRMIDX3_END = 0,\n} GXCPVATGrp0;\n\n// CP locators for vertex attribute table (group 1).\ntypedef enum _GXCPVATGrp1 {\n\t// Tex1 coord count [31-31]\n\tGX_CP_VAT_GRP1_TXC1_CNT_ST  = 31,\n\tGX_CP_VAT_GRP1_TXC1_CNT_END = 31,\n\n\t// Tex1 coord type [28-30]\n\tGX_CP_VAT_GRP1_TXC1_TYPE_ST  = 28,\n\tGX_CP_VAT_GRP1_TXC1_TYPE_END = 30,\n\n\t// Tex1 coord shift [23-27]\n\tGX_CP_VAT_GRP1_TXC1_SHIFT_ST  = 23,\n\tGX_CP_VAT_GRP1_TXC1_SHIFT_END = 27,\n\n\t// Tex2 coord count [22-22]\n\tGX_CP_VAT_GRP1_TXC2_CNT_ST  = 22,\n\tGX_CP_VAT_GRP1_TXC2_CNT_END = 22,\n\n\t// Tex2 coord type [19-21]\n\tGX_CP_VAT_GRP1_TXC2_TYPE_ST  = 19,\n\tGX_CP_VAT_GRP1_TXC2_TYPE_END = 21,\n\n\t// Tex2 coord shift [14-18]\n\tGX_CP_VAT_GRP1_TXC2_SHIFT_ST  = 14,\n\tGX_CP_VAT_GRP1_TXC2_SHIFT_END = 18,\n\n\t// Tex3 coord count [13-13]\n\tGX_CP_VAT_GRP1_TXC3_CNT_ST  = 13,\n\tGX_CP_VAT_GRP1_TXC3_CNT_END = 13,\n\n\t// Tex3 coord type [10-12]\n\tGX_CP_VAT_GRP1_TXC3_TYPE_ST  = 10,\n\tGX_CP_VAT_GRP1_TXC3_TYPE_END = 12,\n\n\t// Tex3 coord shift [5-9]\n\tGX_CP_VAT_GRP1_TXC3_SHIFT_ST  = 5,\n\tGX_CP_VAT_GRP1_TXC3_SHIFT_END = 9,\n\n\t// Tex4 coord count [4-4]\n\tGX_CP_VAT_GRP1_TXC4_CNT_ST  = 4,\n\tGX_CP_VAT_GRP1_TXC4_CNT_END = 4,\n\n\t// Tex4 coord type [1-3]\n\tGX_CP_VAT_GRP1_TXC4_TYPE_ST  = 1,\n\tGX_CP_VAT_GRP1_TXC4_TYPE_END = 3,\n\n} GXCPVATGrp1;\n\n// CP locators for vertex attribute table (group 2).\ntypedef enum _GXCPVATGrp2 {\n\t// Tex4 coord shift [27-31]\n\tGX_CP_VAT_GRP2_TXC4_SHIFT_ST  = 27,\n\tGX_CP_VAT_GRP2_TXC4_SHIFT_END = 31,\n\n\t// Tex5 coord count [26-26]\n\tGX_CP_VAT_GRP2_TXC5_CNT_ST  = 26,\n\tGX_CP_VAT_GRP2_TXC5_CNT_END = 26,\n\n\t// Tex5 coord type [23-25]\n\tGX_CP_VAT_GRP2_TXC5_TYPE_ST  = 23,\n\tGX_CP_VAT_GRP2_TXC5_TYPE_END = 25,\n\n\t// Tex5 coord shift [18-22]\n\tGX_CP_VAT_GRP2_TXC5_SHIFT_ST  = 18,\n\tGX_CP_VAT_GRP2_TXC5_SHIFT_END = 22,\n\n\t// Tex6 coord count [17-17]\n\tGX_CP_VAT_GRP2_TXC6_CNT_ST  = 17,\n\tGX_CP_VAT_GRP2_TXC6_CNT_END = 17,\n\n\t// Tex6 coord type [14-16]\n\tGX_CP_VAT_GRP2_TXC6_TYPE_ST  = 14,\n\tGX_CP_VAT_GRP2_TXC6_TYPE_END = 16,\n\n\t// Tex6 coord shift [9-13]\n\tGX_CP_VAT_GRP2_TXC6_SHIFT_ST  = 9,\n\tGX_CP_VAT_GRP2_TXC6_SHIFT_END = 13,\n\n\t// Tex7 coord count [8-8]\n\tGX_CP_VAT_GRP2_TXC7_CNT_ST  = 8,\n\tGX_CP_VAT_GRP2_TXC7_CNT_END = 8,\n\n\t// Tex7 coord type [5-7]\n\tGX_CP_VAT_GRP2_TXC7_TYPE_ST  = 5,\n\tGX_CP_VAT_GRP2_TXC7_TYPE_END = 7,\n\n\t// Tex7 coord shift [0-4]\n\tGX_CP_VAT_GRP2_TXC7_SHIFT_ST  = 0,\n\tGX_CP_VAT_GRP2_TXC7_SHIFT_END = 4,\n} GXCPVATGrp2;\n\n// CP locators for array base.\ntypedef enum _GXCPArrayBase {\n\t// Base [6-31]\n\tGX_CP_ARRAYBASE_BASE_ST  = 6,\n\tGX_CP_ARRAYBASE_BASE_END = 31,\n} GXCPArrayBase;\n\n// CP locators for array stride.\ntypedef enum _GXCPArrayStride {\n\t// Stride [24-31]\n\tGX_CP_ARRAYSTRIDE_STRIDE_ST  = 24,\n\tGX_CP_ARRAYSTRIDE_STRIDE_END = 31,\n} GXCPArrayStride;\n\n// XF locators for clip disabling.\ntypedef enum _GXXFClipDisable {\n\t// Disable detection [31-31]\n\tGX_XF_CLIPDISABLE_DETECT_ST  = 31,\n\tGX_XF_CLIPDISABLE_DETECT_END = 31,\n\n\t// Disable trivial rejection [30-30]\n\tGX_XF_CLIPDISABLE_REJECT_ST  = 30,\n\tGX_XF_CLIPDISABLE_REJECT_END = 30,\n\n\t// Disable cpoly clipping acceleration [29-29]\n\tGX_XF_CLIPDISABLE_ACCEL_ST  = 29,\n\tGX_XF_CLIPDISABLE_ACCEL_END = 29,\n} GXXFClipDisable;\n\n// XF locators for InVertexSpec.\ntypedef enum _GXXFInVertexSpec {\n\t// Color [30-31]\n\tGX_XF_INVERTEXSPEC_CLR_ST  = 30,\n\tGX_XF_INVERTEXSPEC_CLR_END = 31,\n\n\t// Normal [28-29]\n\tGX_XF_INVERTEXSPEC_NRM_ST  = 28,\n\tGX_XF_INVERTEXSPEC_NRM_END = 29,\n\n\t// Tex coords [24-27]\n\tGX_XF_INVERTEXSPEC_TEX_ST  = 24,\n\tGX_XF_INVERTEXSPEC_TEX_END = 27,\n} GXXFInVertexSpec;\n\n// XF locators for Color 0 control.\ntypedef enum _GXXFClr0Ctrl {\n\t// Matrix source [31-31]\n\tGX_XF_CLR0CTRL_MTXSRC_ST  = 31,\n\tGX_XF_CLR0CTRL_MTXSRC_END = 31,\n\n\t// Light [30-30]\n\tGX_XF_CLR0CTRL_LIGHT_ST  = 30,\n\tGX_XF_CLR0CTRL_LIGHT_END = 30,\n\n\t// Light mask (hi) [26-29]\n\tGX_XF_CLR0CTRL_LMASKHI_ST  = 26,\n\tGX_XF_CLR0CTRL_LMASKHI_END = 29,\n\n\t// Ambient source [25-25]\n\tGX_XF_CLR0CTRL_AMBSRC_ST  = 25,\n\tGX_XF_CLR0CTRL_AMBSRC_END = 25,\n\n\t// Diffuse attenuation [23-24]\n\tGX_XF_CLR0CTRL_DIFATTN_ST  = 23,\n\tGX_XF_CLR0CTRL_DIFATTN_END = 24,\n\n\t// Enable attentuation [22-22]\n\tGX_XF_CLR0CTRL_ATTNENABLE_ST  = 22,\n\tGX_XF_CLR0CTRL_ATTNENABLE_END = 22,\n\n\t// Select attentuation [21-21]\n\tGX_XF_CLR0CTRL_ATTNSEL_ST  = 21,\n\tGX_XF_CLR0CTRL_ATTNSEL_END = 21,\n\n\t// Light mask (lo) [17-20]\n\tGX_XF_CLR0CTRL_LMASKLO_ST  = 17,\n\tGX_XF_CLR0CTRL_LMASKLO_END = 20,\n} GXXFClr0Ctrl;\n\n// XF locators for matrix index 0.\ntypedef enum _GXXFMtxIdx0 {\n\t// Geometry [26-31]\n\tGX_XF_MTXIDX0_GEOM_ST  = 26,\n\tGX_XF_MTXIDX0_GEOM_END = 31,\n\n\t// Tex 0 [20-25]\n\tGX_XF_MTXIDX0_TEX0_ST  = 20,\n\tGX_XF_MTXIDX0_TEX0_END = 25,\n\n\t// Tex 1 [14-19]\n\tGX_XF_MTXIDX0_TEX1_ST  = 14,\n\tGX_XF_MTXIDX0_TEX1_END = 19,\n\n\t// Tex 2 [8-13]\n\tGX_XF_MTXIDX0_TEX2_ST  = 8,\n\tGX_XF_MTXIDX0_TEX2_END = 13,\n\n\t// Tex 3 [2-7]\n\tGX_XF_MTXIDX0_TEX3_ST  = 2,\n\tGX_XF_MTXIDX0_TEX3_END = 7,\n} GXXFMtxIdx0;\n\n// XF locators for matrix index 1.\ntypedef enum _GXXFMtxIdx1 {\n\t// Tex 4 [26-31]\n\tGX_XF_MTXIDX1_TEX4_ST  = 26,\n\tGX_XF_MTXIDX1_TEX4_END = 31,\n\n\t// Tex 5 [20-25]\n\tGX_XF_MTXIDX1_TEX5_ST  = 20,\n\tGX_XF_MTXIDX1_TEX5_END = 25,\n\n\t// Tex 6 [14-19]\n\tGX_XF_MTXIDX1_TEX6_ST  = 14,\n\tGX_XF_MTXIDX1_TEX6_END = 19,\n\n\t// Tex 7 [8-13]\n\tGX_XF_MTXIDX1_TEX7_ST  = 8,\n\tGX_XF_MTXIDX1_TEX7_END = 13,\n} GXXFMtxIdx1;\n\n// XF locators for textures.\ntypedef enum _GXXFTex {\n\t// Projection type [30-30]\n\tGX_XF_TEX_PROJTYPE_ST  = 30,\n\tGX_XF_TEX_PROJTYPE_END = 30,\n\n\t// Input format [29-29]\n\tGX_XF_TEX_INPUTFORM_ST  = 29,\n\tGX_XF_TEX_INPUTFORM_END = 29,\n\n\t// Texture gen type [25-27]\n\tGX_XF_TEX_TEXGENTYPE_ST  = 25,\n\tGX_XF_TEX_TEXGENTYPE_END = 27,\n\n\t// Source row [20-24]\n\tGX_XF_TEX_SRCROW_ST  = 20,\n\tGX_XF_TEX_SRCROW_END = 24,\n\n\t// Bump source texture [17-19]\n\tGX_XF_TEX_BUMPSRCTEX_ST  = 17,\n\tGX_XF_TEX_BUMPSRCTEX_END = 19,\n\n\t// Bump source light [14-16]\n\tGX_XF_TEX_BUMPSRCLIGHT_ST  = 14,\n\tGX_XF_TEX_BUMPSRCLIGHT_END = 16,\n} GXXFTex;\n\n// XF locators for dual textures.\ntypedef enum _GXXFDualTex {\n\t// Base row of the transform matrix [26-31]\n\tGX_XF_DUALTEX_BASEROW_ST  = 26,\n\tGX_XF_DUALTEX_BASEROW_END = 31,\n\n\t// Normalise texcoord before sending transform [23-23]\n\tGX_XF_DUALTEX_NORMALISE_ST  = 23,\n\tGX_XF_DUALTEX_NORMALISE_END = 23,\n} GXXFDualTex;\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\gx.h\" line 12 \"Dolphin/GX/GXTypes.h\" */\n#ifndef _DOLPHIN_GXTYPES_H\n#define _DOLPHIN_GXTYPES_H\n\n/* \"include\\Dolphin\\GX\\GXTypes.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXTypes.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXTypes.h\" line 10 \"Dolphin/vi.h\" */\n/* end \"Dolphin/vi.h\" */\n\n///////////// USEFUL HELPERS ///////////////\n// Set bitfields manually.\n#define GX_BITFIELD(field, pos, size, value)       (__rlwimi((field), (value), 31 - (pos) - (size) + 1, (pos), (pos) + (size)-1))\n#define GX_BITFIELD_SET(field, pos, size, value)   ((field) = GX_BITFIELD(field, pos, size, value))\n#define GX_BITFIELD_TRUNC(field, pos, size, value) (__rlwimi((field), (value), 0, (pos), (pos) + (size)-1))\n#define GX_BITGET(field, pos, size)                ((field) >> (31 - (pos) - (size) + 1) & ((1 << (size)) - 1))\n////////////////////////////////////////////\n\n////////////////// COLORS //////////////////\n// Generic 8-bit-component colors.\ntypedef struct _GXColor {\n\tu8 r, g, b, a; // _00, _01, _02, _03\n} GXColor;\n\n#define GXCOLOR_AS_U32(color) (*((u32*)&(color)))\n\n// Signed 10-bit-component colors for TEV const (konst) colors.\ntypedef struct _GXColorS10 {\n\ts16 r, g, b, a; // _00, _02, _04, _06\n} GXColorS10;\n\n////////////////////////////////////////////\n\n///////////////// TEXTURES /////////////////\n// NB: these are all generic structs. Members aren't\n// referenced directly, they only exist for size.\n\n// Generic struct for texture objects.\ntypedef struct _GXTexObj {\n\tu8 pad[0x20]; // _00\n} GXTexObj;       // size 0x20\n\n// Internal struct for texture objects.\ntypedef struct _GXTexObjPriv {\n\tu32 mode0;       // _00\n\tu32 mode1;       // _04\n\tu32 image0;      // _08\n\tu32 image3;      // _0C\n\tvoid* userData;  // _10\n\tGXTexFmt format; // _14\n\tu32 tlutName;    // _18\n\tu16 loadCount;   // _1C\n\tu8 loadFormat;   // _1E\n\tu8 flags;        // _1F\n} GXTexObjPriv;\n\n// Generic struct for texture memory storage.\ntypedef struct _GXTexRegion {\n\tu8 padding[0x10]; // _00\n} GXTexRegion;\n\ntypedef struct _GXTexRegionPriv {\n\tu32 unk0;      // _00\n\tu32 unk4;      // _04\n\tu32 unk8;      // _08\n\tu8 unkC;       // _0C\n\tu8 unkD;       // _0D\n\tu8 padding[2]; // _0E\n} GXTexRegionPriv;\n\n// Generic struct for texture look-up table objects.\ntypedef struct _GXTlutObj {\n\tu8 padding[0xc]; // _00\n} GXTlutObj;\n\ntypedef struct _GXTlutObjPriv {\n\tu32 unk0;        // _00\n\tu32 unk4;        // _04\n\tu16 numEntries;  // _08\n\tu8 padding[0x2]; // _0A\n} GXTlutObjPriv;\n\n// Generic struct for texture look-up table memory storage.\ntypedef struct _GXTlutRegion {\n\tu8 padding[0x10]; // _00\n} GXTlutRegion;\n\ntypedef struct _GXTlutRegionPriv {\n\tu32 unk0;              // _00\n\tGXTlutObjPriv tlutObj; // _04\n} GXTlutRegionPriv;\n\n// Generic struct for light information.\ntypedef struct _GXLightObj {\n\tu8 padding[0x40]; // _00\n} GXLightObj;         // size 0x40\n\ntypedef struct __GXLightObjPriv {\n\tu32 reserved[3]; // _00\n\tGXColor color;   // _0C, light color\n\tf32 a[3];        // _10, angle-attenuation coefficients\n\tf32 k[3];        // _1C, distance-attenuation coefficients\n\tf32 lpos[3];     // _28, diffuse: position;  specular: direction\n\tf32 ldir[3];     // _34, diffuse: direction; specular: half-angle\n} GXLightObjPriv;\n\n////////////////////////////////////////////\n\n/////////////// VERTEX INFO ////////////////\n// Struct for vertex descriptive info.\ntypedef struct _GXVtxDescList {\n\tGXAttr mAttr;     // _00\n\tGXAttrType mType; // _04\n} GXVtxDescList;\n\n// Struct for vertex attribute formats.\ntypedef struct _GXVtxAttrFmtList {\n\tGXAttr mAttr;     // _00\n\tGXCompCnt mCount; // _04\n\tGXCompType mType; // _08\n\tu8 mFrac;         // _0C\n} GXVtxAttrFmtList;\n\n////////////////////////////////////////////\n\n///////////// OTHER RENDERING //////////////\n// Struct for rendering modes.\ntypedef struct _GXRenderModeObj {\n\tVITVMode viTVmode;        // _00\n\tu16 fbWidth;              // _04, frame buffer width (same for emb. and ext.)\n\tu16 efbHeight;            // _06, embedded frame buffer height\n\tu16 xfbHeight;            // _08, external frame buffer height (may scale emb.)\n\tu16 viXOrigin;            // _0A\n\tu16 viYOrigin;            // _0C\n\tu16 viWidth;              // _0E\n\tu16 viHeight;             // _10\n\tVIXFBMode xFBmode;        // _14, single or double field for external frame buffer\n\tu8 field_rendering;       // _18, rendering fields/frames\n\tu8 aa;                    // _19, is anti-aliasing on\n\tu8 sample_pattern[12][2]; // _1C, anti-aliasing sample pattern\n\tu8 vfilter[7];            // _34, vertical filter coeffs\n} GXRenderModeObj;\n\n// Struct for storing fog adjustment values.\ntypedef struct _GXFogAdjTable {\n\tu16 fogVals[10]; // _00\n} GXFogAdjTable;\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXTypes.h\" */\n/* \"include\\Dolphin\\gx.h\" line 13 \"Dolphin/GX/GXBump.h\" */\n#ifndef _DOLPHIN_GXBUMP_H\n#define _DOLPHIN_GXBUMP_H\n\n/* \"include\\Dolphin\\GX\\GXBump.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXBump.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXBump.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n/* \"include\\Dolphin\\GX\\GXBump.h\" line 11 \"Dolphin/mtx.h\" */\n/* end \"Dolphin/mtx.h\" */\n\n////////////// BUMP FUNCTIONS //////////////\n// Flush functions.\nextern void __GXFlushTextureState();\n\n// Indirect texture functions.\nextern void GXSetTevIndirect(GXTevStageID tevStage, GXIndTexStageID indStage, GXIndTexFormat format, GXIndTexBiasSel bias,\n                             GXIndTexMtxID mtx, GXIndTexWrap sWrap, GXIndTexWrap tWrap, GXBool doAddPrev, GXBool isIndLOD,\n                             GXIndTexAlphaSel alpha);\nextern void GXSetIndTexMtx(GXIndTexMtxID mtx, const Mtx23 offsets, s8 scale);\nextern void GXSetIndTexCoordScale(GXIndTexStageID stage, GXIndTexScale sScale, GXIndTexScale tScale);\nextern void GXSetIndTexOrder(GXIndTexStageID stage, GXTexCoordID texCoord, GXTexMapID texMap);\nextern void GXSetNumIndStages(u8 stageCount);\nextern void __GXSetIndirectMask(u32 mask);\n\n// Convenience functions.\nextern void GXSetTevDirect(GXTevStageID stage);\nextern void GXSetTevIndWarp(GXTevStageID tevStage, GXIndTexStageID indStage, GXBool isSignedOffset, GXBool isReplaceMode,\n                            GXIndTexMtxID mtx);\n\n// Unused/inlined in P2.\nextern void GXSetTevIndTile(GXTevStageID tevStage, GXIndTexStageID indStage, u16 sTileSize, u16 tTileSize, u16 sTileSpacing,\n                            u16 tTileSpacing, GXIndTexFormat format, GXIndTexMtxID mtx, GXIndTexBiasSel bias, GXIndTexAlphaSel alpha);\nextern void GXSetTevIndBumpST(GXTevStageID tevStage, GXIndTexStageID indStage, GXIndTexMtxID mtx);\nextern void GXSetTevIndBumpXYZ(GXTevStageID tevStage, GXIndTexStageID indStage, GXIndTexMtxID mtx);\nextern void GXSetTevIndRepeat(GXTevStageID stage);\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXBump.h\" */\n/* \"include\\Dolphin\\gx.h\" line 14 \"Dolphin/GX/GXLight.h\" */\n#ifndef _DOLPHIN_GXLIGHT_H\n#define _DOLPHIN_GXLIGHT_H\n\n/* \"include\\Dolphin\\GX\\GXLight.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXLight.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXLight.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n\n///////////// LIGHT FUNCTIONS //////////////\n// Init functions.\nextern void GXInitLightAttn(GXLightObj* obj, f32 a0, f32 a1, f32 a2, f32 k0, f32 k1, f32 k2);\n\nextern void GXInitLightSpot(GXLightObj* obj, f32 cutoff, GXSpotFn spotFunc);\nextern void GXInitLightDistAttn(GXLightObj* obj, f32 refDist, f32 refBrightness, GXDistAttnFn distFunc);\n\nextern void GXInitLightPos(GXLightObj* obj, f32 x, f32 y, f32 z);\nextern void GXInitLightDir(GXLightObj* obj, f32 nX, f32 nY, f32 nZ);\nextern void GXInitSpecularDir(GXLightObj* obj, f32 nX, f32 nY, f32 nZ);\nextern void GXInitLightColor(GXLightObj* obj, GXColor color);\n\n// Load functions.\nextern void GXLoadLightObjImm(GXLightObj* obj, GXLightID light);\n\n// Set functions.\nextern void GXSetChanAmbColor(GXChannelID channel, GXColor color);\nextern void GXSetChanMatColor(GXChannelID channel, GXColor color);\nextern void GXSetNumChans(u8 count);\nextern void GXSetChanCtrl(GXChannelID channel, GXBool doEnable, GXColorSrc ambSrc, GXColorSrc matSrc, u32 mask, GXDiffuseFn diffFunc,\n                          GXAttnFn attnFunc);\n\n// Unused/inlined in P2.\nextern void GXInitLightAttnA(GXLightObj* obj, f32 a0, f32 a1, f32 a2);\nextern void GXGetLightAttnA(GXLightObj* obj, f32* a0, f32* a1, f32* a2);\nextern void GXInitLightAttnK(GXLightObj* obj, f32 k0, f32 k1, f32 k2);\nextern void GXGetLightAttnK(GXLightObj* obj, f32* k0, f32* k1, f32* k2);\n\nextern void GXGetLightPos(GXLightObj* obj, f32* x, f32* y, f32* z);\nextern void GXGetLightDir(GXLightObj* obj, f32* nX, f32* nY, f32* nZ);\n\nextern void GXInitSpecularDirHA(GXLightObj* obj, f32 nX, f32 nY, f32 nZ, f32 hX, f32 hY, f32 hZ);\n\nextern void GXGetLightColor(GXLightObj* obj, GXColor* color);\n\nextern void GXLoadLightObjIndx(u32 objIndex, GXLightID light);\n\n////////////////////////////////////////////\n\n/////////////// LIGHT MACROS ///////////////\n#define GXInitLightPosVec(obj, vec) (GXInitLightPos((obj), *(f32*)(vec), *((f32*)(vec) + 1), *((f32*)(vec) + 2)))\n\n#define GXInitLightDirVec(obj, vec) (GXInitLightDir((obj), *(f32*)(vec), *((f32*)(vec) + 1), *((f32*)(vec) + 2)))\n\n#define GXInitSpecularDirVec(obj, vec) (GXInitSpecularDir((obj), *(f32*)(vec), *((f32*)(vec) + 1), *((f32*)(vec) + 2)))\n\n#define GXInitLightShininess(obj, shine) (GXInitLightAttn((obj), 0.0f, 0.0f, 1.0f, (shine) / 2.0f, 0.0f, 1.0f - (shine) / 2.0f))\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXLight.h\" */\n/* \"include\\Dolphin\\gx.h\" line 15 \"Dolphin/GX/GXFrameBuffer.h\" */\n#ifndef _DOLPHIN_GXFRAMEBUFFER_H\n#define _DOLPHIN_GXFRAMEBUFFER_H\n\n/* \"include\\Dolphin\\GX\\GXFrameBuffer.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXFrameBuffer.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXFrameBuffer.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n\n///////////// RENDER MODE OBJS /////////////\n// NB: commented out objects are unused in P2.\n// extern GXRenderModeObj GXNtsc240Ds;\n// extern GXRenderModeObj GXNtsc240DsAa;\n// extern GXRenderModeObj GXNtsc240Int;\n// extern GXRenderModeObj GXNtsc240IntAa;\nextern GXRenderModeObj GXNtsc480IntDf;\nextern GXRenderModeObj GXNtsc480Int;\n// extern GXRenderModeObj GXNtsc480IntAa;\n// extern GXRenderModeObj GXNtsc480Prog;\n// extern GXRenderModeObj GXNtsc480ProgAa;\n// extern GXRenderModeObj GXMpal240Ds;\n// extern GXRenderModeObj GXMpal240DsAa;\n// extern GXRenderModeObj GXMpal240Int;\n// extern GXRenderModeObj GXMpal240IntAa;\nextern GXRenderModeObj GXMpal480IntDf;\nextern GXRenderModeObj GXMpal480Int;\n// extern GXRenderModeObj GXMpal480IntAa;\n// extern GXRenderModeObj GXPal264Ds;\n// extern GXRenderModeObj GXPal264DsAa;\n// extern GXRenderModeObj GXPal264Int;\n// extern GXRenderModeObj GXPal264IntAa;\nextern GXRenderModeObj GXPal528IntDf;\n// extern GXRenderModeObj GXPal528Int;\n// extern GXRenderModeObj GXPal524IntAa;\n// extern GXRenderModeObj GXEurgb60Hz240Ds;\n// extern GXRenderModeObj GXEurgb60Hz240DsAa;\n// extern GXRenderModeObj GXEurgb60Hz240Int;\n// extern GXRenderModeObj GXEurgb60Hz240IntAa;\nextern GXRenderModeObj GXEurgb60Hz480IntDf;\n// extern GXRenderModeObj GXEurgb60Hz480Int;\n// extern GXRenderModeObj GXEurgb60Hz480IntAa;\n// extern GXRenderModeObj GXRmHW;\n\n////////////////////////////////////////////\n\n///////////// BUFFER FUNCTIONS /////////////\n// Source/dest copy-set functions.\nextern void GXSetDispCopySrc(u16 left, u16 top, u16 width, u16 height);\nextern void GXSetTexCopySrc(u16 left, u16 top, u16 width, u16 height);\nextern void GXSetDispCopyDst(u16 width, u16 height);\nextern void GXSetTexCopyDst(u16 width, u16 height, GXTexFmt format, GXBool useMIPmap);\n\n// Other copy-set functions.\nextern void GXSetDispCopyFrame2Field(GXCopyMode mode);\nextern void GXSetCopyClamp(GXFBClamp clamp);\nextern u32 GXSetDispCopyYScale(f32 vertScale);\nextern void GXSetCopyClear(GXColor clearColor, u32 clearZ);\nextern void GXSetCopyFilter(GXBool useAA, u8 samplePattern[12][2], GXBool doVertFilt, u8 vFilt[7]);\nextern void GXSetDispCopyGamma(GXGamma gamma);\n\n// Copy data functions.\nextern void GXCopyDisp(void* dest, GXBool doClear);\nextern void GXCopyTex(void* dest, GXBool doClear);\n\n// Get functions.\nextern u16 GXGetNumXfbLines(u16 efbHeight, f32 yScale);\nextern f32 GXGetYScaleFactor(u16 efbHeight, u16 xfbHeight);\n\n// Clear functions.\nextern void GXClearBoundingBox();\n\n// Unused/inlined in P2.\nextern void GXAdjustForOverscan(GXRenderModeObj* rIn, GXRenderModeObj* rOut, u16 horiz, u16 vert);\nextern void GXReadBoundingBox(u16* left, u16* top, u16* right, u16* bottom);\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXFrameBuffer.h\" */\n/* \"include\\Dolphin\\gx.h\" line 16 \"Dolphin/GX/GXPerf.h\" */\n#ifndef _DOLPHIN_GXPERF_H\n#define _DOLPHIN_GXPERF_H\n\n/* \"include\\Dolphin\\GX\\GXPerf.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXPerf.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXPerf.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n\n///////////// METRIC FUNCTIONS /////////////\nextern void GXSetGPMetric(GXPerf0 perf0, GXPerf1 perf1);\nextern void GXClearGPMetric();\nextern void GXReadXfRasMetric(u32* xfWaitIn, u32* xfWaitOut, u32* rasBusy, u32* clocks);\n\n// Unused/inlined in P2.\nextern void GXReadGPMetric(u32* count0, u32* count1);\nextern u32 GXReadGP0Metric();\nextern u32 GXReadGP1Metric();\nextern void GXReadMemMetric(u32* cpReq, u32* tcReq, u32* cpuReadReq, u32* cpuWriteReq, u32* dspReq, u32* ioReq, u32* viReq, u32* peReq,\n                            u32* rfReq, u32* fiReq);\nextern void GXClearMemMetric();\nextern void GXReadPixMetric(u32* topIn, u32* topOut, u32* bottomIn, u32* bottomOut, u32* clearIn, u32* copyClocks);\nextern void GXClearPixMetric();\nextern void GXSetVCacheMetric(GXVCachePerf attr);\nextern void GXReadVCacheMetric(u32* check, u32* miss, u32* stall);\nextern void GXClearVCacheMetric();\nextern void GXInitXfRasMetric();\nextern u32 GXReadClksPerVtx();\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXPerf.h\" */\n/* \"include\\Dolphin\\gx.h\" line 17 \"Dolphin/GX/GXPixel.h\" */\n#ifndef _DOLPHIN_GXPIXEL_H\n#define _DOLPHIN_GXPIXEL_H\n\n/* \"include\\Dolphin\\GX\\GXPixel.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXPixel.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXPixel.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n/* \"include\\Dolphin\\GX\\GXPixel.h\" line 11 \"Dolphin/mtx.h\" */\n/* end \"Dolphin/mtx.h\" */\n\n///////////// PIXEL FUNCTIONS //////////////\n// Fog functions.\nextern void GXSetFog(GXFogType type, f32 startZ, f32 endZ, f32 nearZ, f32 farZ, GXColor color);\nextern void GXInitFogAdjTable(GXFogAdjTable* table, u16 width, const Mtx44 projMtx);\nextern void GXSetFogRangeAdj(GXBool doEnable, u16 center, GXFogAdjTable* table);\n\n// Blend functions.\nextern void GXSetBlendMode(GXBlendMode type, GXBlendFactor srcFactor, GXBlendFactor destFactor, GXLogicOp op);\n\n// Color update functions.\nextern void GXSetColorUpdate(GXBool enableUpdate);\nextern void GXSetAlphaUpdate(GXBool enableUpdate);\n\n// Other setter functions.\nextern void GXSetZMode(GXBool enableCompare, GXCompare func, GXBool enableUpdate);\nextern void GXSetZCompLoc(GXBool isBeforeTex);\nextern void GXSetPixelFmt(GXPixelFmt pixelFormat, GXZFmt16 zFormat);\nextern void GXSetDither(GXBool doDither);\nextern void GXSetDstAlpha(GXBool doEnable, u8 alpha);\nextern void GXSetFieldMask(GXBool doOddMask, GXBool doEvenMask);\nextern void GXSetFieldMode(GXBool doFieldMode, GXBool doHalfAspectRatio);\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXPixel.h\" */\n/* \"include\\Dolphin\\gx.h\" line 18 \"Dolphin/GX/GXTev.h\" */\n#ifndef _DOLPHIN_GXTEV_H\n#define _DOLPHIN_GXTEV_H\n\n/* \"include\\Dolphin\\GX\\GXTev.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXTev.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXTev.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n\n////// TEXTURE ENVIRONMENT FUNCTIONS ///////\nextern void GXSetTevOp(GXTevStageID stage, GXTevMode mode);\nextern void GXSetTevColorIn(GXTevStageID stage, GXTevColorArg a, GXTevColorArg b, GXTevColorArg c, GXTevColorArg d);\nextern void GXSetTevAlphaIn(GXTevStageID stage, GXTevAlphaArg a, GXTevAlphaArg b, GXTevAlphaArg c, GXTevAlphaArg d);\nextern void GXSetTevColorOp(GXTevStageID stage, GXTevOp op, GXTevBias bias, GXTevScale scale, GXBool doClamp, GXTevRegID outReg);\nextern void GXSetTevAlphaOp(GXTevStageID stage, GXTevOp op, GXTevBias bias, GXTevScale scale, GXBool doClamp, GXTevRegID outReg);\n\nextern void GXSetTevColor(GXTevRegID reg, GXColor color);\nextern void GXSetTevColorS10(GXTevRegID reg, GXColorS10 color);\n\nextern void GXSetTevKColor(GXTevKColorID id, GXColor color);\nextern void GXSetTevKColorSel(GXTevStageID stage, GXTevKColorSel sel);\nextern void GXSetTevKAlphaSel(GXTevStageID stage, GXTevKAlphaSel sel);\n\nextern void GXSetTevSwapMode(GXTevStageID stage, GXTevSwapSel rasSel, GXTevSwapSel texSel);\nextern void GXSetTevSwapModeTable(GXTevSwapSel table, GXTevColorChan red, GXTevColorChan green, GXTevColorChan blue, GXTevColorChan alpha);\n\nextern void GXSetAlphaCompare(GXCompare comp0, u8 ref0, GXAlphaOp op, GXCompare comp1, u8 ref1);\nextern void GXSetTevOrder(GXTevStageID stage, GXTexCoordID coord, GXTexMapID map, GXChannelID color);\nextern void GXSetZTexture(GXZTexOp op, GXTexFmt format, u32 bias);\nextern void GXSetNumTevStages(u8 count);\n\n// Unused/inlined in P2.\nextern void GXSetTevClampMode(GXTevStageID stage, GXTevClampMode mode);\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXTev.h\" */\n/* \"include\\Dolphin\\gx.h\" line 19 \"Dolphin/GX/GXTexture.h\" */\n#ifndef _DOLPHIN_GXTEXTURE_H\n#define _DOLPHIN_GXTEXTURE_H\n\n/* \"include\\Dolphin\\GX\\GXTexture.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXTexture.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXTexture.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n\n//////////// TEXTURE CALLBACKS /////////////\n\ntypedef GXTexRegion* (*GXTexRegionCallback)(const GXTexObj* t_obj, GXTexMapID id);\ntypedef GXTlutRegion* (*GXTlutRegionCallback)(u32 idx);\n\n////////////////////////////////////////////\n\n////////////// TEXTURE MODES ///////////////\n// Texture mode IDs.\nextern u8 GXTexMode0Ids[8];\nextern u8 GXTexMode1Ids[8];\nextern u8 GXTexImage0Ids[8];\nextern u8 GXTexImage1Ids[8];\nextern u8 GXTexImage2Ids[8];\nextern u8 GXTexImage3Ids[8];\nextern u8 GXTexTlutIds[8];\n\n// Filter conversion arrays (HW2GX unused in P2).\nextern u8 GX2HWFiltConv[6];\n// extern u8 HW2GXFiltConv[8];\n\n////////////////////////////////////////////\n\n//////////// TEXTURE FUNCTIONS /////////////\n// Init functions.\nextern void GXInitTexObj(GXTexObj* obj, void* imagePtr, u16 width, u16 height, GXTexFmt format, GXTexWrapMode sWrap, GXTexWrapMode tWrap,\n                         GXBool useMIPmap);\nextern void GXInitTexObjCI(GXTexObj* obj, void* imagePtr, u16 width, u16 height, GXCITexFmt format, GXTexWrapMode sWrap,\n                           GXTexWrapMode tWrap, GXBool useMIPmap, u32 tlutName);\nextern void GXInitTexObjLOD(GXTexObj* obj, GXTexFilter minFilter, GXTexFilter maxFilter, f32 minLOD, f32 maxLOD, f32 lodBias,\n                            GXBool doBiasClamp, GXBool doEdgeLOD, GXAnisotropy maxAniso);\n\n// Get functions.\nextern GXTexFmt GXGetTexObjFmt(GXTexObj* obj);\nextern GXBool GXGetTexObjMipMap(GXTexObj* obj);\nextern u32 GXGetTexBufferSize(u16 width, u16 height, u32 format, GXBool mipmap, u8 max_lod);\n\n// Load functions.\nextern void GXLoadTexObjPreLoaded(GXTexObj* obj, GXTexRegion* region, GXTexMapID map);\nextern void GXLoadTexObj(GXTexObj* obj, GXTexMapID map);\n\n// Tlut functions.\nextern void GXInitTlutObj(GXTlutObj* obj, void* table, GXTlutFmt format, u16 numEntries);\nextern void GXLoadTlut(GXTlutObj* obj, u32 tlutName);\n\n// Region functions.\nextern void GXInitTexCacheRegion(GXTexRegion* region, GXBool is32bMIPmap, u32 memEven, GXTexCacheSize sizeEven, u32 memOdd,\n                                 GXTexCacheSize sizeOdd);\nextern void GXInitTlutRegion(GXTlutRegion* region, u32 memAddr, GXTlutSize tlutSize);\n\n// Other functions.\nextern void GXInvalidateTexAll();\nextern GXTexRegionCallback GXSetTexRegionCallback(GXTexRegionCallback func);\nextern GXTlutRegionCallback GXSetTlutRegionCallback(GXTlutRegionCallback func);\n\n// Unknown arg functions.\n// TODO: work these out.\nextern void __SetSURegs();\nextern void __GXSetSUTexRegs();\nextern void __GXSetTmemConfig(u32 config);\n\n// Unused/inlined in P2.\nextern void GXInitTexObjData(GXTexObj* obj, void* imagePtr);\nextern void GXInitTexObjWrapMode(GXTexObj* obj, GXTexWrapMode sWrap, GXTexWrapMode tWrap);\nextern void GXInitTexObjTlut(GXTexObj* obj, u32 tlutName);\n// TODO: finish filling these out for reference purposes.\n\nextern void __GetImageTileCount(GXTexFmt format, u16 width, u16 height, u32* a, u32* b, u32* c);\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXTexture.h\" */\n/* \"include\\Dolphin\\gx.h\" line 20 \"Dolphin/GX/GXGeometry.h\" */\n#ifndef _DOLPHIN_GXGEOMETRY_H\n#define _DOLPHIN_GXGEOMETRY_H\n\n/* \"include\\Dolphin\\GX\\GXGeometry.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXGeometry.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXGeometry.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n\n//////////// GEOMETRY FUNCTIONS ////////////\n// Basic GX functions.\nextern void __GXSetDirtyState();\nextern void GXBegin(GXPrimitive type, GXVtxFmt format, u16 numVertices);\nextern void __GXSendFlushPrim();\n\n// Attr functions.\nextern void GXSetVtxDesc(GXAttr attr, GXAttrType type);\nextern void GXClearVtxDesc();\n\nextern void GXSetVtxAttrFmt(GXVtxFmt format, GXAttr attr, GXCompCnt count, GXCompType type, u8 frac);\nextern void GXSetVtxAttrFmtv(GXVtxFmt format, GXVtxAttrFmtList* list);\n\nextern void GXSetArray(GXAttr attr, void* basePtr, u8 stride);\nextern void GXInvalidateVtxCache();\nextern void GXSetTexCoordGen2(GXTexCoordID coord, GXTexGenType genType, GXTexGenSrc srcParam, u32 mtx, GXBool doNormalise, u32 postMtx);\nextern void GXSetNumTexGens(u8 count);\n\n// Geometry functions.\nextern void GXSetLineWidth(u8 width, GXTexOffset offset);\nextern void GXSetPointSize(u8 pointSize, GXTexOffset offset);\nextern void GXEnableTexOffsets(GXTexCoordID coord, GXBool enableLine, GXBool enablePoint);\nextern void __GXSetGenMode();\n\n// Cull and manip functions.\nextern void GXSetCullMode(GXCullMode mode);\nextern void GXSetCoPlanar(GXBool doEnable);\n\n// Unused/inlined in P2.\nextern void GXSetVtxDescv(GXVtxDescList* attrList);\nextern void GXGetVtxDesc(GXAttr attr, GXAttrType* type);\nextern void GXGetVtxDescv(GXVtxDescList* list);\nextern void GXGetVtxAttrFmtv(GXVtxFmt format, GXVtxAttrFmtList* list);\nextern void GXGetLineWidth(u8* width, GXTexOffset* offset);\nextern void GXGetPointSize(u8* pointSize, GXTexOffset* offset);\nextern void GXGetCullMode(GXCullMode* mode);\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXGeometry.h\" */\n/* \"include\\Dolphin\\gx.h\" line 21 \"Dolphin/GX/GXTransform.h\" */\n#ifndef _DOLPHIN_GXTRANSFORM_H\n#define _DOLPHIN_GXTRANSFORM_H\n\n/* \"include\\Dolphin\\GX\\GXTransform.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXTransform.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXTransform.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n/* \"include\\Dolphin\\GX\\GXTransform.h\" line 11 \"Dolphin/mtx.h\" */\n/* end \"Dolphin/mtx.h\" */\n\n/////////// TRANSFORM FUNCTIONS ////////////\n// Matrix and projection functions.\nextern void GXSetProjection(const Mtx44 mtx, GXProjectionType type);\nextern void GXSetProjectionv(const f32* ptr);\nextern void GXLoadPosMtxImm(Mtx mtx, u32 id);\nextern void GXLoadNrmMtxImm(Mtx mtx, u32 id);\nextern void GXSetCurrentMtx(u32 id);\nextern void GXLoadTexMtxImm(const Mtx mtx, u32 id, GXTexMtxType type);\nextern void __GXSetMatrixIndex(GXAttr index);\n\n// Viewport functions.\nextern void __GXSetViewport(); // confirm types\nextern void GXSetViewport(f32 left, f32 top, f32 width, f32 height, f32 nearZ, f32 farZ);\n\n// Scissor/clip functions.\nextern void GXSetScissor(u32 left, u32 top, u32 width, u32 height);\nextern void GXSetScissorBoxOffset(s32 x, s32 y);\nextern void GXGetScissor(u32* left, u32* top, u32* width, u32* height);\nextern void GXGetScissorBoxOffset(int xOffset, int yOffset);\nextern void GXSetClipMode(GXClipMode mode);\n\n// Unused/inlined in P2.\nextern void GXProject(f32 x, f32 y, f32 z, Mtx viewMtx, f32* projMtx, f32* viewport, f32* screenX, f32* screenY, f32* screenZ);\nextern void GXGetProjectionv(f32* ptr);\nextern void GXLoadPosMtxIndx(u16 index, u32 id);\nextern void GXLoadNrmMtxImm3x3(Mtx33, u32 id);\nextern void GXLoadNrmMtxIndx3x3(u16 index, u32 id);\nextern void GXLoadTexMtxIndx(u16 index, u32 id, GXTexMtxType type);\nextern void GXSetViewportJitter(f32 left, f32 top, f32 width, f32 height, f32 nearZ, f32 farZ, u32 field);\nextern void GXGetViewportv(f32* viewport);\n\n////////////////////////////////////////////\n\n////////////// USEFUL EXTRAS ///////////////\n#define GX_PROJECTION_SZ 7\n#define GX_VIEWPORT_SZ   6\n\nstatic inline void GXSetViewportv(f32* port) { GXSetViewport(port[0], port[1], port[2], port[3], port[4], port[5]); }\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXTransform.h\" */\n/* \"include\\Dolphin\\gx.h\" line 22 \"Dolphin/GX/GXMisc.h\" */\n#ifndef _DOLPHIN_GXMISC_H\n#define _DOLPHIN_GXMISC_H\n\n/* \"include\\Dolphin\\GX\\GXMisc.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXMisc.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXMisc.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n/* \"include\\Dolphin\\GX\\GXMisc.h\" line 11 \"Dolphin/GX/GXFifo.h\" */\n#ifndef _DOLPHIN_GXFIFO_H\n#define _DOLPHIN_GXFIFO_H\n\n/* \"include\\Dolphin\\GX\\GXFifo.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXFifo.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXFifo.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n\n/////////////// FIFO STRUCTS ///////////////\n#define GX_FIFO_MINSIZE  (64 * 1024)\n#define GX_FIFO_OBJ_SIZE (128)\n\n#define GXFIFO_ADDR 0xCC008000\n\n// Generic struct for FIFO access (size 0x80).\ntypedef struct _GXFifoObj {\n\tu8 padding[GX_FIFO_OBJ_SIZE]; // _00\n} GXFifoObj;\n\n// Internal struct for FIFO access.\ntypedef struct _GXFifoObjPriv {\n\tvoid* base;        // _00\n\tvoid* end;         // _04\n\tu32 size;          // _08\n\tu32 highWatermark; // _0C\n\tu32 lowWatermark;  // _10\n\tvoid* readPtr;     // _14\n\tvoid* writePtr;    // _18\n\ts32 rwDistance;    // _1C\n\tu8 _20[0x60];      // _20\n} GXFifoObjPriv;\n\ntypedef void (*GXBreakPtCallback)(void);\n\n// PPC Write Gather Pipe\ntypedef union {\n\tu8 u8;\n\tu16 u16;\n\tu32 u32;\n\tu64 u64;\n\ts8 s8;\n\ts16 s16;\n\ts32 s32;\n\ts64 s64;\n\tf32 f32;\n\tf64 f64;\n} PPCWGPipe;\n\n#ifdef __MWERKS__\nvolatile PPCWGPipe GXWGFifo : GXFIFO_ADDR;\n#else\n#define GXWGFifo (*(volatile PPCWGPipe*)GXFIFO_ADDR)\n#endif\n\n////////////////////////////////////////////\n\n//////////// FIFO MACROS/INLINES ///////////\n#define GX_WRITE_U8(val)  (GXWGFifo.u8 = val)\n#define GX_WRITE_U16(val) (GXWGFifo.u16 = val)\n#define GX_WRITE_U32(val) (GXWGFifo.u32 = (u32)val)\n#define GX_WRITE_F32(val) (GXWGFifo.f32 = (f32)val)\n\nstatic inline void GXPosition2f32(const f32 x, const f32 y)\n{\n\tGXWGFifo.f32 = x;\n\tGXWGFifo.f32 = y;\n}\n\nstatic inline void GXPosition3s16(const s16 x, const s16 y, const s16 z)\n{\n\tGXWGFifo.s16 = x;\n\tGXWGFifo.s16 = y;\n\tGXWGFifo.s16 = z;\n}\n\nstatic inline void GXPosition3u16(const u16 x, const u16 y, const u16 z)\n{\n\tGXWGFifo.u16 = x;\n\tGXWGFifo.u16 = y;\n\tGXWGFifo.u16 = z;\n}\n\nstatic inline void GXPosition3f32(f32 x, f32 y, f32 z)\n{\n\tGXWGFifo.f32 = x;\n\tGXWGFifo.f32 = y;\n\tGXWGFifo.f32 = z;\n}\n\nstatic inline void GXNormal3f32(const f32 x, const f32 y, const f32 z)\n{\n\tGXWGFifo.f32 = x;\n\tGXWGFifo.f32 = y;\n\tGXWGFifo.f32 = z;\n}\n\nstatic inline void GXColor1u32(u32 c) { GXWGFifo.u32 = c; }\n\nstatic inline void GXColor4u8(const u8 r, const u8 g, const u8 b, const u8 a)\n{\n\tGXWGFifo.u8 = r;\n\tGXWGFifo.u8 = g;\n\tGXWGFifo.u8 = b;\n\tGXWGFifo.u8 = a;\n}\n\nstatic inline void GXTexCoord2s8(const s8 u, const s8 v)\n{\n\tGXWGFifo.s8 = u;\n\tGXWGFifo.s8 = v;\n}\n\nstatic inline void GXTexCoord2u8(u8 s, u8 t)\n{\n\tGXWGFifo.u8 = s;\n\tGXWGFifo.u8 = t;\n}\n\nstatic inline void GXPosition2u16(u16 x, u16 y)\n{\n\tGXWGFifo.u16 = x;\n\tGXWGFifo.u16 = y;\n}\n\nstatic inline void GXTexCoord2s16(const s16 u, const s16 v)\n{\n\tGXWGFifo.s16 = u;\n\tGXWGFifo.s16 = v;\n}\n\nstatic inline void GXTexCoord2u16(const u16 u, const u16 v)\n{\n\tGXWGFifo.u16 = u;\n\tGXWGFifo.u16 = v;\n}\n\nstatic inline void GXTexCoord2f32(const f32 u, const f32 v)\n{\n\tGXWGFifo.f32 = u;\n\tGXWGFifo.f32 = v;\n}\n\nstatic inline void GXEnd(void) { }\n\n////////////////////////////////////////////\n\n//////////// FIFO INIT/SET/SAVE ////////////\n// Init.\nextern void __GXFifoInit();\nextern void GXInitFifoBase(GXFifoObj* obj, void* base, u32 size);\nextern void GXInitFifoPtrs(GXFifoObj* obj, void* readPtr, void* writePtr);\nextern void GXInitFifoLimits(GXFifoObj* obj, u32 hiWaterMark, u32 loWaterMark);\n\n// Set.\nextern void GXSetCPUFifo(GXFifoObj* obj);\nextern void GXSetGPFifo(GXFifoObj* obj);\nextern void GXSaveCPUFifo(GXFifoObj* obj);\n\n////////////////////////////////////////////\n\n/////////////// FIFO GETTERS ///////////////\nextern void GXGetGPStatus(GXBool* isOverHi, GXBool* isUnderLo, GXBool* isReadIdle, GXBool* isCmdIdle, GXBool* isHitBrkPt);\nextern GXFifoObj* GXGetCPUFifo();\nextern GXFifoObj* GXGetGPFifo();\n\n////////////////////////////////////////////\n\n//////////// DISPLAY LIST FUNCS ////////////\nextern void GXBeginDisplayList(void* list, u32 size);\nextern u32 GXEndDisplayList();\nextern void GXCallDisplayList(void* list, u32 numBytes);\n\n////////////////////////////////////////////\n\n///////////// BREAKPOINT FUNCS /////////////\nextern GXBreakPtCallback GXSetBreakPtCallback(GXBreakPtCallback callback);\n\n////////////////////////////////////////////\n\n/////////////// OTHER FUNCS ////////////////\nvoid __GXSaveCPUFifoAux(GXFifoObj* obj);\nvoid __GXFifoReadEnable();\nvoid __GXFifoReadDisable();\nvoid __GXFifoLink(u8);\nvoid __GXWriteFifoIntEnable(u32, u32);\nvoid __GXWriteFifoIntReset(u32, u32);\n\n// Unused/inlined in P2.\nextern void GXSaveGPFifo(GXFifoObj* obj);\n\nextern void GXGetFifoStatus(GXFifoObj* obj, GXBool* isOverHi, GXBool* isUnderLo, u32* fifoCount, GXBool* isCpuWrite, GXBool* isGPRead,\n                            GXBool* isFifoWrap);\nextern void GXGetFifoPtrs(GXFifoObj* obj, void** readPtr, void** writePtr);\nextern void* GXGetFifoBase(GXFifoObj* obj);\nextern u32 GXGetFifoSize(GXFifoObj* obj);\nextern void GXGetFifoLimits(GXFifoObj* obj, u32* hi, u32* lo);\n\nextern void GXEnableBreakPt(void* breakPtr);\nextern void GXDisableBreakPt();\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXFifo.h\" */\n/* \"include\\Dolphin\\GX\\GXMisc.h\" line 12 \"Dolphin/OS/OSInterrupt.h\" */\n#ifndef _DOLPHIN_OS_OSINTERRUPT_H\n#define _DOLPHIN_OS_OSINTERRUPT_H\n\n/* \"include\\Dolphin\\OS\\OSInterrupt.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n/* \"include\\Dolphin\\OS\\OSInterrupt.h\" line 4 \"Dolphin/OS/OSContext.h\" */\n#ifndef _DOLPHIN_OS_OSCONTEXT_H\n#define _DOLPHIN_OS_OSCONTEXT_H\n\n/* \"include\\Dolphin\\OS\\OSContext.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n////////// CONTEXT TYPES /////////\n// Struct for holding register context info (size 0x2C8).\ntypedef struct OSContext {\n\tu32 gpr[32];   // _00, general purpose registers.\n\tu32 cr;        // _80\n\tu32 lr;        // _84\n\tu32 ctr;       // _88\n\tu32 xer;       // _8C\n\tf64 fpr[32];   // _90, floating point registers.\n\tu32 fpscr_pad; // _190\n\tu32 fpscr;     // _194\n\tu32 srr0;      // _198, exception handling 0.\n\tu32 srr1;      // _19C, exception handling 1.\n\tu16 mode;      // _1A0, context mode.\n\tu16 state;     // _1A2, |'d OS_CONTEXT_STATE_*\n\tu32 gqr[8];    // _1A4, Gekko additional registers.\n\tf64 psf[32];   // _1C8, Gekko additional registers.\n} OSContext;\n\n// Size of context frame.\n// NB: size of context + padding for stack frame header.\n#define __OS_CONTEXT_FRAME 768\n\n// Current context address (for asm functions).\n#define OS_CURRENTCONTEXT_PADDR 0xC0\n\n//////////////////////////////////\n\n/////// CONTEXT FUNCTIONS ////////\n// Context functions.\nvoid OSLoadContext(OSContext* context);\nvoid OSClearContext(OSContext* context);\nvoid OSInitContext(OSContext* context, u32 pc, u32 stackPtr);\nvoid OSDumpContext(OSContext* context);\nu32 OSSaveContext(OSContext* context);\n\nu32 OSGetStackPointer();\n\n// Current context functions.\nOSContext* OSGetCurrentContext();\nvoid OSSetCurrentContext(OSContext* context);\n\n// FPU functions.\nvoid OSSaveFPUContext(OSContext* context);\nvoid OSFillFPUContext(OSContext* context);\n\n// Unused/inlined in P2.\nu32 OSSwitchStack(u32 newStackPtr);\nint OSSwitchFiber(u32 pc, u32 newStackPtr);\n\nvoid OSLoadFPUContext(OSContext* context);\n\n//////////////////////////////////\n\n//////// REGISTER DEFINES ////////\n// Floating point modes.\n#define OS_CONTEXT_MODE_FPU  (0x01U)\n#define OS_CONTEXT_MODE_PSFP (0x02U)\n\n// Context states.\n#define OS_CONTEXT_STATE_FPSAVED (0x01U)\n#define OS_CONTEXT_STATE_EXC     (0x02U)\n\n// General purpose registers.\n#define OS_CONTEXT_R0  0\n#define OS_CONTEXT_R1  4\n#define OS_CONTEXT_R2  8\n#define OS_CONTEXT_R3  12\n#define OS_CONTEXT_R4  16\n#define OS_CONTEXT_R5  20\n#define OS_CONTEXT_R6  24\n#define OS_CONTEXT_R7  28\n#define OS_CONTEXT_R8  32\n#define OS_CONTEXT_R9  36\n#define OS_CONTEXT_R10 40\n#define OS_CONTEXT_R11 44\n#define OS_CONTEXT_R12 48\n#define OS_CONTEXT_R13 52\n#define OS_CONTEXT_R14 56\n#define OS_CONTEXT_R15 60\n#define OS_CONTEXT_R16 64\n#define OS_CONTEXT_R17 68\n#define OS_CONTEXT_R18 72\n#define OS_CONTEXT_R19 76\n#define OS_CONTEXT_R20 80\n#define OS_CONTEXT_R21 84\n#define OS_CONTEXT_R22 88\n#define OS_CONTEXT_R23 92\n#define OS_CONTEXT_R24 96\n#define OS_CONTEXT_R25 100\n#define OS_CONTEXT_R26 104\n#define OS_CONTEXT_R27 108\n#define OS_CONTEXT_R28 112\n#define OS_CONTEXT_R29 116\n#define OS_CONTEXT_R30 120\n#define OS_CONTEXT_R31 124\n\n// Other registers.\n#define OS_CONTEXT_CR  128\n#define OS_CONTEXT_LR  132\n#define OS_CONTEXT_CTR 136\n#define OS_CONTEXT_XER 140\n\n// Floating point registers.\n#define OS_CONTEXT_FPR0  144\n#define OS_CONTEXT_FPR1  152\n#define OS_CONTEXT_FPR2  160\n#define OS_CONTEXT_FPR3  168\n#define OS_CONTEXT_FPR4  176\n#define OS_CONTEXT_FPR5  184\n#define OS_CONTEXT_FPR6  192\n#define OS_CONTEXT_FPR7  200\n#define OS_CONTEXT_FPR8  208\n#define OS_CONTEXT_FPR9  216\n#define OS_CONTEXT_FPR10 224\n#define OS_CONTEXT_FPR11 232\n#define OS_CONTEXT_FPR12 240\n#define OS_CONTEXT_FPR13 248\n#define OS_CONTEXT_FPR14 256\n#define OS_CONTEXT_FPR15 264\n#define OS_CONTEXT_FPR16 272\n#define OS_CONTEXT_FPR17 280\n#define OS_CONTEXT_FPR18 288\n#define OS_CONTEXT_FPR19 296\n#define OS_CONTEXT_FPR20 304\n#define OS_CONTEXT_FPR21 312\n#define OS_CONTEXT_FPR22 320\n#define OS_CONTEXT_FPR23 328\n#define OS_CONTEXT_FPR24 336\n#define OS_CONTEXT_FPR25 344\n#define OS_CONTEXT_FPR26 352\n#define OS_CONTEXT_FPR27 360\n#define OS_CONTEXT_FPR28 368\n#define OS_CONTEXT_FPR29 376\n#define OS_CONTEXT_FPR30 384\n#define OS_CONTEXT_FPR31 392\n\n// Floating point scratch (0x8 incl. padding)\n#define OS_CONTEXT_FPSCR 400\n\n// Exception handling registers.\n#define OS_CONTEXT_SRR0 408\n#define OS_CONTEXT_SRR1 412\n\n// Context mode registers (0x2 each).\n#define OS_CONTEXT_MODE  416\n#define OS_CONTEXT_STATE 418\n\n// Gekko-specific GQR registers.\n#define OS_CONTEXT_GQR0     420\n#define OS_CONTEXT_GQR1     424\n#define OS_CONTEXT_GQR2     428\n#define OS_CONTEXT_GQR3     432\n#define OS_CONTEXT_GQR4     436\n#define OS_CONTEXT_GQR5     440\n#define OS_CONTEXT_GQR6     444\n#define OS_CONTEXT_GQR7     448\n#define __OSCONTEXT_PADDING 452 // padding for double-word alignment of PSFs.\n\n// Gekko-specific PSF registers.\n#define OS_CONTEXT_PSF0  456\n#define OS_CONTEXT_PSF1  464\n#define OS_CONTEXT_PSF2  472\n#define OS_CONTEXT_PSF3  480\n#define OS_CONTEXT_PSF4  488\n#define OS_CONTEXT_PSF5  496\n#define OS_CONTEXT_PSF6  504\n#define OS_CONTEXT_PSF7  512\n#define OS_CONTEXT_PSF8  520\n#define OS_CONTEXT_PSF9  528\n#define OS_CONTEXT_PSF10 536\n#define OS_CONTEXT_PSF11 544\n#define OS_CONTEXT_PSF12 552\n#define OS_CONTEXT_PSF13 560\n#define OS_CONTEXT_PSF14 568\n#define OS_CONTEXT_PSF15 576\n#define OS_CONTEXT_PSF16 584\n#define OS_CONTEXT_PSF17 592\n#define OS_CONTEXT_PSF18 600\n#define OS_CONTEXT_PSF19 608\n#define OS_CONTEXT_PSF20 616\n#define OS_CONTEXT_PSF21 624\n#define OS_CONTEXT_PSF22 632\n#define OS_CONTEXT_PSF23 640\n#define OS_CONTEXT_PSF24 648\n#define OS_CONTEXT_PSF25 656\n#define OS_CONTEXT_PSF26 664\n#define OS_CONTEXT_PSF27 672\n#define OS_CONTEXT_PSF28 680\n#define OS_CONTEXT_PSF29 688\n#define OS_CONTEXT_PSF30 696\n#define OS_CONTEXT_PSF31 704\n\n//////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/OS/OSContext.h\" */\n/* \"include\\Dolphin\\OS\\OSInterrupt.h\" line 5 \"Dolphin/OS/OSException.h\" */\n#ifndef _DOLPHIN_OS_OSEXCEPTION_H\n#define _DOLPHIN_OS_OSEXCEPTION_H\n\n/* \"include\\Dolphin\\OS\\OSException.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n/* \"include\\Dolphin\\OS\\OSException.h\" line 4 \"Dolphin/OS/OSContext.h\" */\n/* end \"Dolphin/OS/OSContext.h\" */\n/* \"include\\Dolphin\\OS\\OSException.h\" line 5 \"Dolphin/OS/OSUtil.h\" */\n#ifndef _DOLPHIN_OS_OSUTIL_H\n#define _DOLPHIN_OS_OSUTIL_H\n\n/* \"include\\Dolphin\\OS\\OSUtil.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n///// USEFUL MACROS/DEFINES //////\n// Macro for making clear things are addresses.\n// if-def for future proofing and so VSCode doesn't yell.\n#ifdef __MWERKS__\n#define AT_ADDRESS(addr) : (addr)\n#else\n#define AT_ADDRESS(addr)\n#endif\n\n// Defines for cached and uncached memory.\n#define OS_BASE_CACHED   (0x80000000)\n#define OS_BASE_UNCACHED (0xC0000000)\n\n// Necessary for inline asm functions.\n#define OS_CACHED_REGION_PREFIX   (0x8000)\n#define OS_UNCACHED_REGION_PREFIX (0xC000)\n#define OS_PHYSICAL_MASK          (0x3FFF)\n\n//////////////////////////////////\n\n////////// CLOCK UTILS ///////////\n// Time and tick typedefs for convenience.\ntypedef s64 OSTime;\ntypedef u32 OSTick;\n\nextern OSTime __OSStartTime;\n\n// Clock speeds.\nu32 __OSBusClock AT_ADDRESS(OS_BASE_CACHED | 0x00F8);\nu32 __OSCoreClock AT_ADDRESS(OS_BASE_CACHED | 0x00FC);\n\nOSTime __OSGetSystemTime();\n\n#define OS_BUS_CLOCK   __OSBusClock\n#define OS_CORE_CLOCK  __OSCoreClock\n#define OS_TIMER_CLOCK (OS_BUS_CLOCK / 4)\n\n// Tick conversions.\n#define OSTicksToCycles(ticks)       (((ticks) * ((OS_CORE_CLOCK * 2) / OS_TIMER_CLOCK)) / 2)\n#define OSTicksToSeconds(ticks)      ((ticks) / OS_TIMER_CLOCK)\n#define OSTicksToMilliseconds(ticks) ((ticks) / (OS_TIMER_CLOCK / 1000))\n#define OSTicksToMicroseconds(ticks) (((ticks)*8) / (OS_TIMER_CLOCK / 125000))\n#define OSTicksToNanoseconds(ticks)  (((ticks)*8000) / (OS_TIMER_CLOCK / 125000))\n#define OSSecondsToTicks(sec)        ((sec)*OS_TIMER_CLOCK)\n#define OSMillisecondsToTicks(msec)  ((msec) * (OS_TIMER_CLOCK / 1000))\n#define OSMicrosecondsToTicks(usec)  (((usec) * (OS_TIMER_CLOCK / 125000)) / 8)\n#define OSNanosecondsToTicks(nsec)   (((nsec) * (OS_TIMER_CLOCK / 125000)) / 8000)\n\n#define OSDiffTick(tick1, tick0) ((s32)(tick1) - (s32)(tick0))\n\n// Time-related getters.\nOSTick OSGetTick();\nOSTime OSGetTime();\n\n// Struct for 'calendar time'.\ntypedef struct OSCalendarTime {\n\tint sec;  // _00, secs after minute\n\tint min;  // _04, mins after hour\n\tint hour; // _08, hours since midnight\n\tint mday; // _0C, day of month\n\tint mon;  // _10, month since Jan\n\tint year; // _14, years since 0000\n\tint wday; // _18, days since Sunday\n\tint yday; // _1C, days since Jan 1\n\tint msec; // _20, millisecs after sec\n\tint usec; // _24, microsecs after millisec\n} OSCalendarTime;\n\n// Calendar time functions.\nOSTime OSCalendarTimeToTicks(OSCalendarTime* timeDate);\nvoid OSTicksToCalendarTime(OSTime ticks, OSCalendarTime* timeDate);\n\n// Macros for rounding to 32-alignment.\n#define OSRoundUp32B(x)   (((u32)(x) + 0x1F) & ~(0x1F))\n#define OSRoundDown32B(x) (((u32)(x)) & ~(0x1F))\n\n// Address conversions.\n#define OSPhysicalToCached(paddr)    ((void*)((u32)(paddr) + OS_BASE_CACHED))\n#define OSPhysicalToUncached(paddr)  ((void*)((u32)(paddr) + OS_BASE_UNCACHED))\n#define OSCachedToPhysical(caddr)    ((u32)((u8*)(caddr)-OS_BASE_CACHED))\n#define OSUncachedToPhysical(ucaddr) ((u32)((u8*)(ucaddr)-OS_BASE_UNCACHED))\n#define OSCachedToUncached(caddr)    ((void*)((u8*)(caddr) + (OS_BASE_UNCACHED - OS_BASE_CACHED)))\n#define OSUncachedToCached(ucaddr)   ((void*)((u8*)(ucaddr) - (OS_BASE_UNCACHED - OS_BASE_CACHED)))\n\n// Other useful addresses.\nvu16 __OSDeviceCode AT_ADDRESS(OS_BASE_CACHED | 0x30E6);\n\n//////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/OS/OSUtil.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n//////// EXCEPTION TYPES /////////\n// Useful typedef for exceptions.\ntypedef u8 __OSException;\n\n// Exception handler function type.\ntypedef void (*__OSExceptionHandler)(__OSException exception, OSContext* context);\n\n// Exception handling functions.\n__OSExceptionHandler __OSSetExceptionHandler(__OSException exception, __OSExceptionHandler handler);\n__OSExceptionHandler __OSGetExceptionHandler(__OSException exception);\n\n//////////////////////////////////\n\n/////////// EXCEPTIONS ///////////\n// Exception codes.\n#define __OS_EXCEPTION_SYSTEM_RESET       0\n#define __OS_EXCEPTION_MACHINE_CHECK      1\n#define __OS_EXCEPTION_DSI                2\n#define __OS_EXCEPTION_ISI                3\n#define __OS_EXCEPTION_EXTERNAL_INTERRUPT 4\n#define __OS_EXCEPTION_ALIGNMENT          5\n#define __OS_EXCEPTION_PROGRAM            6\n#define __OS_EXCEPTION_FLOATING_POINT     7\n#define __OS_EXCEPTION_DECREMENTER        8\n#define __OS_EXCEPTION_SYSTEM_CALL        9\n#define __OS_EXCEPTION_TRACE              10\n#define __OS_EXCEPTION_PERFORMACE_MONITOR 11\n#define __OS_EXCEPTION_BREAKPOINT         12\n#define __OS_EXCEPTION_SYSTEM_INTERRUPT   13\n#define __OS_EXCEPTION_THERMAL_INTERRUPT  14\n#define __OS_EXCEPTION_MAX                (__OS_EXCEPTION_THERMAL_INTERRUPT + 1)\n\n//////////////////////////////////\n\n///////// CONTEXT SAVING /////////\n// Macro for saving context on exception (for asm functions).\n#define OS_EXCEPTION_SAVE_GPRS(context)               \\\n\tstw r0, OS_CONTEXT_R0(context);                   \\\n\tstw r1, OS_CONTEXT_R1(context);                   \\\n\tstw r2, OS_CONTEXT_R2(context);                   \\\n\tstmw r6, OS_CONTEXT_R6(context);                  \\\n\t/* Save GQR1 to GQR7. GQR0 must always be zero */ \\\n\tmfspr r0, GQR1;                                   \\\n\tstw r0, OS_CONTEXT_GQR1(context);                 \\\n\tmfspr r0, GQR2;                                   \\\n\tstw r0, OS_CONTEXT_GQR2(context);                 \\\n\tmfspr r0, GQR3;                                   \\\n\tstw r0, OS_CONTEXT_GQR3(context);                 \\\n\tmfspr r0, GQR4;                                   \\\n\tstw r0, OS_CONTEXT_GQR4(context);                 \\\n\tmfspr r0, GQR5;                                   \\\n\tstw r0, OS_CONTEXT_GQR5(context);                 \\\n\tmfspr r0, GQR6;                                   \\\n\tstw r0, OS_CONTEXT_GQR6(context);                 \\\n\tmfspr r0, GQR7;                                   \\\n\tstw r0, OS_CONTEXT_GQR7(context);\n\n// Moved from OSContext.h due to include looping.\nvoid OSSwitchFPUContext(__OSException exception, OSContext* context);\n\n//////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/OS/OSException.h\" */\n/* \"include\\Dolphin\\OS\\OSInterrupt.h\" line 6 \"Dolphin/OS/OSUtil.h\" */\n/* end \"Dolphin/OS/OSUtil.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n//////// INTERRUPT TYPES /////////\n// Useful typedef for interrupts.\ntypedef s16 __OSInterrupt;\n\n// Interrupt handler function type.\ntypedef void (*__OSInterruptHandler)(__OSInterrupt interrupt, OSContext* context);\n\n// Mask type for interrupts, to use with defines.\ntypedef u32 OSInterruptMask;\n\n// Last interrupts.\nextern volatile __OSInterrupt __OSLastInterrupt; // one of the Interrupt Codes below.\nextern volatile u32 __OSLastInterruptSrr0;       // SRR0 value at time of interrupt.\nextern volatile OSTime __OSLastInterruptTime;    // time of interrupt (from OSGetTime()).\n\n// Interrupt global addresses.\nvolatile OSInterruptMask __OSPriorInterruptMask AT_ADDRESS((u32)OSPhysicalToCached(0x00C4));\nvolatile OSInterruptMask __OSCurrentInterruptMask AT_ADDRESS((u32)OSPhysicalToCached(0x00C8));\n\n//////////////////////////////////\n\n////// INTERRUPT FUNCTIONS ///////\n// Handler functions.\n__OSInterruptHandler __OSSetInterruptHandler(__OSInterrupt interrupt, __OSInterruptHandler handler);\n__OSInterruptHandler __OSGetInterruptHandler(__OSInterrupt interrupt);\n\n// Interrupt functions.\nvoid __OSDispatchInterrupt(__OSException exception, OSContext* context);\nBOOL OSEnableInterrupts();\nBOOL OSDisableInterrupts();\nBOOL OSRestoreInterrupts(BOOL level);\n\n// Mask functions.\nOSInterruptMask __OSMaskInterrupts(OSInterruptMask mask);\nOSInterruptMask __OSUnmaskInterrupts(OSInterruptMask mask);\n\n// Unused/inlined in P2.\nOSInterruptMask OSGetInterruptMask();\nOSInterruptMask OSSetInterruptMask(OSInterruptMask mask);\n\n//////////////////////////////////\n\n//////// INTERRUPT CODES /////////\n// Interrupt codes.\n#define __OS_INTERRUPT_MEM_0        0 // Memory-related interrupts.\n#define __OS_INTERRUPT_MEM_1        1\n#define __OS_INTERRUPT_MEM_2        2\n#define __OS_INTERRUPT_MEM_3        3\n#define __OS_INTERRUPT_MEM_ADDRESS  4\n#define __OS_INTERRUPT_DSP_AI       5 // Audio-related interrupts.\n#define __OS_INTERRUPT_DSP_ARAM     6\n#define __OS_INTERRUPT_DSP_DSP      7\n#define __OS_INTERRUPT_AI_AI        8\n#define __OS_INTERRUPT_EXI_0_EXI    9 // Expanded-mem-related interrupts.\n#define __OS_INTERRUPT_EXI_0_TC     10\n#define __OS_INTERRUPT_EXI_0_EXT    11\n#define __OS_INTERRUPT_EXI_1_EXI    12\n#define __OS_INTERRUPT_EXI_1_TC     13\n#define __OS_INTERRUPT_EXI_1_EXT    14\n#define __OS_INTERRUPT_EXI_2_EXI    15\n#define __OS_INTERRUPT_EXI_2_TC     16\n#define __OS_INTERRUPT_PI_CP        17 // Processor-related interrupts.\n#define __OS_INTERRUPT_PI_PE_TOKEN  18\n#define __OS_INTERRUPT_PI_PE_FINISH 19\n#define __OS_INTERRUPT_PI_SI        20\n#define __OS_INTERRUPT_PI_DI        21\n#define __OS_INTERRUPT_PI_RSW       22\n#define __OS_INTERRUPT_PI_ERROR     23\n#define __OS_INTERRUPT_PI_VI        24\n#define __OS_INTERRUPT_PI_DEBUG     25\n#define __OS_INTERRUPT_PI_HSP       26\n#define __OS_INTERRUPT_MAX          32\n\n//////////////////////////////////\n\n//////// INTERRUPT MASKS /////////\n// Macro for masking interrupts.\n#define OS_INTERRUPTMASK(interrupt) (0x80000000u >> (interrupt))\n\n// Masks for memory-related interrupts.\n#define OS_INTERRUPTMASK_MEM_0       OS_INTERRUPTMASK(__OS_INTERRUPT_MEM_0)\n#define OS_INTERRUPTMASK_MEM_1       OS_INTERRUPTMASK(__OS_INTERRUPT_MEM_1)\n#define OS_INTERRUPTMASK_MEM_2       OS_INTERRUPTMASK(__OS_INTERRUPT_MEM_2)\n#define OS_INTERRUPTMASK_MEM_3       OS_INTERRUPTMASK(__OS_INTERRUPT_MEM_3)\n#define OS_INTERRUPTMASK_MEM_ADDRESS OS_INTERRUPTMASK(__OS_INTERRUPT_MEM_ADDRESS)\n#define OS_INTERRUPTMASK_MEM_RESET   (OS_INTERRUPTMASK_MEM_0 | OS_INTERRUPTMASK_MEM_1 | OS_INTERRUPTMASK_MEM_2 | OS_INTERRUPTMASK_MEM_3)\n\n#define OS_INTERRUPTMASK_MEM \\\n\t(OS_INTERRUPTMASK_MEM_0 | OS_INTERRUPTMASK_MEM_1 | OS_INTERRUPTMASK_MEM_2 | OS_INTERRUPTMASK_MEM_3 | OS_INTERRUPTMASK_MEM_ADDRESS)\n\n// Masks for audio-related interrupts.\n#define OS_INTERRUPTMASK_DSP_AI   OS_INTERRUPTMASK(__OS_INTERRUPT_DSP_AI)\n#define OS_INTERRUPTMASK_DSP_ARAM OS_INTERRUPTMASK(__OS_INTERRUPT_DSP_ARAM)\n#define OS_INTERRUPTMASK_DSP_DSP  OS_INTERRUPTMASK(__OS_INTERRUPT_DSP_DSP)\n\n#define OS_INTERRUPTMASK_DSP (OS_INTERRUPTMASK_DSP_AI | OS_INTERRUPTMASK_DSP_ARAM | OS_INTERRUPTMASK_DSP_DSP)\n\n#define OS_INTERRUPTMASK_AI_AI OS_INTERRUPTMASK(__OS_INTERRUPT_AI_AI)\n#define OS_INTERRUPTMASK_AI    (OS_INTERRUPTMASK_AI_AI)\n\n// Masks for expanded-mem-related interrupts.\n#define OS_INTERRUPTMASK_EXI_0_EXI OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_0_EXI)\n#define OS_INTERRUPTMASK_EXI_0_TC  OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_0_TC)\n#define OS_INTERRUPTMASK_EXI_0_EXT OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_0_EXT)\n\n#define OS_INTERRUPTMASK_EXI_0 (OS_INTERRUPTMASK_EXI_0_EXI | OS_INTERRUPTMASK_EXI_0_TC | OS_INTERRUPTMASK_EXI_0_EXT)\n\n#define OS_INTERRUPTMASK_EXI_1_EXI OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_1_EXI)\n#define OS_INTERRUPTMASK_EXI_1_TC  OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_1_TC)\n#define OS_INTERRUPTMASK_EXI_1_EXT OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_1_EXT)\n\n#define OS_INTERRUPTMASK_EXI_1 (OS_INTERRUPTMASK_EXI_1_EXI | OS_INTERRUPTMASK_EXI_1_TC | OS_INTERRUPTMASK_EXI_1_EXT)\n\n#define OS_INTERRUPTMASK_EXI_2_EXI OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_2_EXI)\n#define OS_INTERRUPTMASK_EXI_2_TC  OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_2_TC)\n#define OS_INTERRUPTMASK_EXI_2     (OS_INTERRUPTMASK_EXI_2_EXI | OS_INTERRUPTMASK_EXI_2_TC)\n\n#define OS_INTERRUPTMASK_EXI                                                                                          \\\n\t(OS_INTERRUPTMASK_EXI_0_EXI | OS_INTERRUPTMASK_EXI_0_TC | OS_INTERRUPTMASK_EXI_0_EXT | OS_INTERRUPTMASK_EXI_1_EXI \\\n\t | OS_INTERRUPTMASK_EXI_1_TC | OS_INTERRUPTMASK_EXI_1_EXT | OS_INTERRUPTMASK_EXI_2_EXI | OS_INTERRUPTMASK_EXI_2_TC)\n\n// Masks for processor-related interrupts.\n#define OS_INTERRUPTMASK_PI_PE_TOKEN  OS_INTERRUPTMASK(__OS_INTERRUPT_PI_PE_TOKEN)\n#define OS_INTERRUPTMASK_PI_PE_FINISH OS_INTERRUPTMASK(__OS_INTERRUPT_PI_PE_FINISH)\n\n#define OS_INTERRUPTMASK_PI_PE (OS_INTERRUPTMASK_PI_PE_TOKEN | OS_INTERRUPTMASK_PI_PE_FINISH)\n\n#define OS_INTERRUPTMASK_PI_CP    OS_INTERRUPTMASK(__OS_INTERRUPT_PI_CP)\n#define OS_INTERRUPTMASK_PI_SI    OS_INTERRUPTMASK(__OS_INTERRUPT_PI_SI)\n#define OS_INTERRUPTMASK_PI_DI    OS_INTERRUPTMASK(__OS_INTERRUPT_PI_DI)\n#define OS_INTERRUPTMASK_PI_RSW   OS_INTERRUPTMASK(__OS_INTERRUPT_PI_RSW)\n#define OS_INTERRUPTMASK_PI_ERROR OS_INTERRUPTMASK(__OS_INTERRUPT_PI_ERROR)\n#define OS_INTERRUPTMASK_PI_VI    OS_INTERRUPTMASK(__OS_INTERRUPT_PI_VI)\n#define OS_INTERRUPTMASK_PI_DEBUG OS_INTERRUPTMASK(__OS_INTERRUPT_PI_DEBUG)\n#define OS_INTERRUPTMASK_PI_HSP   OS_INTERRUPTMASK(__OS_INTERRUPT_PI_HSP)\n\n#define OS_INTERRUPTMASK_PI                                                                                                         \\\n\t(OS_INTERRUPTMASK_PI_CP | OS_INTERRUPTMASK_PI_SI | OS_INTERRUPTMASK_PI_DI | OS_INTERRUPTMASK_PI_RSW | OS_INTERRUPTMASK_PI_ERROR \\\n\t | OS_INTERRUPTMASK_PI_VI | OS_INTERRUPTMASK_PI_PE_TOKEN | OS_INTERRUPTMASK_PI_PE_FINISH | OS_INTERRUPTMASK_PI_DEBUG            \\\n\t | OS_INTERRUPTMASK_PI_HSP)\n\n//////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/OS/OSInterrupt.h\" */\n\n//////////////// CALLBACKS /////////////////\ntypedef void (*GXDrawSyncCallback)(u16 token);\ntypedef void (*GXDrawDoneCallback)(void);\n\n////////////////////////////////////////////\n\n///////////// BASIC FUNCTIONS //////////////\nstatic GXTexRegion* __GXDefaultTexRegionCallback(const GXTexObj* obj, GXTexMapID id);\nstatic GXTlutRegion* __GXDefaultTlutRegionCallback(u32 tlut);\nstatic BOOL __GXShutdown(BOOL final); // need to check types\n\n////////////////////////////////////////////\n\n////////////// INIT FUNCTIONS //////////////\nextern GXFifoObj* GXInit(void* base, u32 size);\nextern void __GXInitGX(); // need to check types\nextern void __GXPEInit();\n\n////////////////////////////////////////////\n\n////////////// MISC FUNCTIONS //////////////\n// Basic functions.\nextern void GXSetMisc(GXMiscToken token, u32 val);\nextern void GXFlush();\nextern void __GXAbort(); // need to check types\nextern void GXAbortFrame();\n\n// Draw functions.\nextern void GXSetDrawSync(u16 token);\nextern void GXSetDrawDone();\nextern void GXWaitDrawDone();\nextern void GXDrawDone();\n\n// Other syncs/interrupts.\nextern void GXPixModeSync();\nextern GXDrawSyncCallback GXSetDrawSyncCallback(GXDrawSyncCallback callback);\nextern void GXTokenInterruptHandler(__OSInterrupt interrupt, OSContext* context);\nextern GXDrawDoneCallback GXSetDrawDoneCallback(GXDrawDoneCallback callback);\nextern void GXFinishInterruptHandler(__OSInterrupt interrupt, OSContext* context);\n\n// Poke functions.\nextern void GXPokeAlphaMode(GXCompare func, u8 threshold);\nextern void GXPokeAlphaRead(GXAlphaReadMode mode);\nextern void GXPokeAlphaUpdate(GXBool doUpdate);\nextern void GXPokeBlendMode(GXBlendMode mode, GXBlendFactor srcFactor, GXBlendFactor destFactor, GXLogicOp op);\nextern void GXPokeColorUpdate(GXBool doUpdate);\nextern void GXPokeDstAlpha(GXBool doEnable, u8 alpha);\nextern void GXPokeDither(GXBool doDither);\nextern void GXPokeZMode(GXBool doCompare, GXCompare func, GXBool doUpdate);\n\n// Unused/inlined in P2.\nextern BOOL IsWriteGatherBufferEmpty();\nextern void EnableWriteGatherPipe();\nextern void DisableWriteGatherPipe();\nextern void GXResetWriteGatherPipe();\n\nextern void GXReadDrawSync();\nextern void GXTexModeSync();\n\nextern void GXPeekARGB(u16 x, u16 y, u32* color);\nextern void GXPokeARGB(u16 x, u16 y, u32 color);\nextern void GXPeekZ(u16 x, u16 y, u32* z);\nextern void GXPokeZ(u16 x, u16 y, u32 z);\n\nextern u32 GXCompressZ16(u32 z24, GXZFmt16 zFormat);\nextern u32 GXDecompressZ16(u32 z16, GXZFmt16 zFormat);\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXMisc.h\" */\n/* \"include\\Dolphin\\gx.h\" line 23 \"Dolphin/GX/GXData.h\" */\n#ifndef _DOLPHIN_GXDATA_H\n#define _DOLPHIN_GXDATA_H\n\n/* \"include\\Dolphin\\GX\\GXData.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"include\\Dolphin\\GX\\GXData.h\" line 9 \"Dolphin/GX/GXEnum.h\" */\n/* end \"Dolphin/GX/GXEnum.h\" */\n/* \"include\\Dolphin\\GX\\GXData.h\" line 10 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n/* \"include\\Dolphin\\GX\\GXData.h\" line 11 \"Dolphin/GX/GXTexture.h\" */\n/* end \"Dolphin/GX/GXTexture.h\" */\n\n/////////////// CONTROL ENUMS //////////////\ntypedef enum _CPStatus {\n\tGX_FIFO_OVERFLOW        = 0x1,\n\tGX_FIFO_UNDERFLOW       = 0x2,\n\tGP_IS_IDLE_FOR_READING  = 0x4,\n\tGP_IS_IDLE_FOR_COMMANDS = 0x8,\n\tBP_INTERRUPT            = 0x10,\n} CPStatus;\n\ntypedef enum _CPControl {\n\tGP_FIFO_READ_ENABLE             = 0x1,\n\tCP_IRQ_ENABLE_MAYBE             = 0x2,\n\tFIFO_OVERFLOW_IRQ_ENABLE_MAYBE  = 0x4,\n\tFIFO_UNDERFLOW_IRQ_ENABLE_MAYBE = 0x8,\n\tGP_LINK_ENABLE                  = 0x10,\n\tBP_ENABLE                       = 0x20,\n} CPControl;\n\ntypedef enum _CPClear {\n\tCLEAR_FIFO_OVERFLOW  = 0x1,\n\tCLEAR_FIFO_UNDERFLOW = 0x2,\n} CPClear;\n\n////////////////////////////////////////////\n\n////////////// GXDATA STRUCTS //////////////\n// size: 0x5B0\ntypedef struct _GXData {\n\t// Bypass and vertex info\n\tu16 vNumNot;   // _000, !(# flush verts to send)\n\tu16 bpSentNot; // _002, !(bypass reg sent last?)\n\tu16 vNum;      // _004, # flush verts to send\n\tu16 vLim;      // _006, max vert size\n\n\t// Command process (CP) regs\n\tu32 cpEnable; // _008\n\tu32 cpStatus; // _00C\n\tu32 cpClr;    // _010\n\tu32 vcdLo;    // _014\n\tu32 vcdHi;    // _018\n\tu32 vatA[8];  // _01C\n\tu32 vatB[8];  // _03C\n\tu32 vatC[8];  // _05C\n\tu32 lpSize;   // _07C\n\tu32 matIdxA;  // _080\n\tu32 matIdxB;  // _084\n\n\t// Index loading base/stride regs (pos, nrm, tex, light)\n\tu32 indexBase[4];   // _088\n\tu32 indexStride[4]; // _098\n\n\t// Transform and lighting regs\n\tu32 ambColor[2]; // _0A8\n\tu32 matColor[2]; // _0B0\n\n\t// Setup regs\n\tu32 suTs0[8]; // _0B8\n\tu32 suTs1[8]; // _0D8\n\tu32 suScis0;  // _0F8\n\tu32 suScis1;  // _0FC\n\n\t// Raster regs\n\tu32 tref[8]; // _100\n\tu32 iref;    // _120\n\n\t// Bump/Indirect texture regs\n\tu32 bpMask;       // _124\n\tu32 IndTexScale0; // _128\n\tu32 IndTexScale1; // _12C\n\n\t// Tev regs\n\tu32 tevc[16];   // _130\n\tu32 teva[16];   // _170\n\tu32 tevKsel[8]; // _1B0\n\n\t// Performance regs\n\tu32 cmode0; // _1D0\n\tu32 cmode1; // _1D4\n\tu32 zmode;  // _1D8\n\tu32 peCtrl; // _1DC\n\n\t// Display copy regs\n\tu32 cpDispSrc;    // _1E0\n\tu32 cpDispSize;   // _1E4\n\tu32 cpDispStride; // _1E8\n\tu32 cpDisp;       // _1EC\n\n\t// Texture copy regs\n\tu32 cpTexSrc;    // _1F0\n\tu32 cpTexSize;   // _1F4\n\tu32 cpTexStride; // _1F8\n\tu32 cpTex;       // _1FC\n\tGXBool cpTexZ;   // _200\n\n\t// General raster mode\n\tu32 genMode; // _204\n\n\t// Texture regions\n\tGXTexRegion TexRegions0[GX_MAX_TEXMAP]; // _208\n\tGXTexRegion TexRegions1[GX_MAX_TEXMAP]; // _288\n\tGXTexRegion TexRegions2[GX_MAX_TEXMAP]; // _308\n\n\t// Texture lookup table regions\n\tGXTlutRegion TlutRegions[GX_MAX_TLUT_ALL]; // _388\n\tGXTexRegionCallback texRegionCallback;     // _4C8\n\tGXTlutRegionCallback tlutRegionCallback;   // _4CC\n\n\t// Command processor vars\n\tGXAttrType nrmType; // _4D0\n\tGXBool hasNrms;     // _4D4\n\tGXBool hasBiNrms;   // _4D5\n\tu32 projType;       // _4D8\n\tf32 projMtx[6];     // _4DC\n\n\t// Viewport parms\n\tf32 vpLeft;  // _4F4\n\tf32 vpTop;   // _4F8\n\tf32 vpWd;    // _4FC\n\tf32 vpHt;    // _500\n\tf32 vpNearz; // _504\n\tf32 vpFarz;  // _508\n\tf32 zOffset; // _50C\n\tf32 zScale;  // _510\n\n\t// Texture regs\n\tu32 tImage0[8];   // _514\n\tu32 tMode0[8];    // _534\n\tu32 texmapId[16]; // _554\n\tu32 tcsManEnab;   // _594\n\tu32 tevTcEnab;    // _598\n\n\t// Performance metrics\n\tGXPerf0 perf0; // _59C\n\tGXPerf1 perf1; // _5A0\n\tu32 perfSel;   // _5A4\n\n\t// Flags\n\tGXBool inDispList;    // _5A8\n\tGXBool dlSaveContext; // _5A9\n\tGXBool abtWaitPECopy; // _5AA\n\tu8 dirtyVAT;          // _5AB\n\tu32 dirtyState;       // _5AC\n} GXData;\nextern GXData* const __GXData; // NB: this is const in SMG1 decomp.\n\n#define gx __GXData\n\n////////////////////////////////////////////\n\n///////////// REGISTER DEFINES /////////////\n// Declare registers.\nextern void* __cpReg;\nextern void* __piReg;\nextern void* __memReg;\nextern void* __peReg;\n\n// Define register addresses.\n#define GX_CP_ADDR  (0x0C000000)\n#define GX_PE_ADDR  (0x0C001000)\n#define GX_PI_ADDR  (0x0C003000)\n#define GX_MEM_ADDR (0x0C004000)\n\n// i hate writing out the damn volatile shit so many times\n#define GX_GET_MEM_REG(offset) (*(vu16*)((vu16*)(__memReg) + (offset)))\n#define GX_GET_CP_REG(offset)  (*(vu16*)((vu16*)(__cpReg) + (offset)))\n#define GX_GET_PE_REG(offset)  (*(vu16*)((vu16*)(__peReg) + (offset)))\n#define GX_GET_PI_REG(offset)  (*(vu32*)((vu32*)(__piReg) + (offset)))\n\n#define GX_SET_MEM_REG(offset, val) (*(vu16*)((vu16*)(__memReg) + (offset)) = val)\n#define GX_SET_CP_REG(offset, val)  (*(vu16*)((vu16*)(__cpReg) + (offset)) = val)\n#define GX_SET_PE_REG(offset, val)  (*(vu16*)((vu16*)(__peReg) + (offset)) = val)\n#define GX_SET_PI_REG(offset, val)  (*(vu32*)((vu32*)(__piReg) + (offset)) = val)\n\n// Useful reading register inlines\nstatic inline u32 GXReadMEMReg(u32 addrLo, u32 addrHi)\n{\n\tu32 hiStart, hiNew, lo;\n\thiStart = GX_GET_MEM_REG(addrHi);\n\tdo {\n\t\thiNew   = hiStart;\n\t\tlo      = GX_GET_MEM_REG(addrLo);\n\t\thiStart = GX_GET_MEM_REG(addrHi);\n\t} while (hiStart != hiNew);\n\n\treturn ((hiStart << 16) | lo);\n}\n\nstatic inline u32 GXReadCPReg(u32 addrLo, u32 addrHi)\n{\n\tu32 hiStart, hiNew, lo;\n\thiStart = GX_GET_CP_REG(addrHi);\n\tdo {\n\t\thiNew   = hiStart;\n\t\tlo      = GX_GET_CP_REG(addrLo);\n\t\thiStart = GX_GET_CP_REG(addrHi);\n\t} while (hiStart != hiNew);\n\n\treturn ((hiStart << 16) | lo);\n}\n\nstatic inline u32 GXReadPEReg(u32 addrLo, u32 addrHi)\n{\n\tu32 hiStart, hiNew, lo;\n\thiStart = GX_GET_PE_REG(addrHi);\n\tdo {\n\t\thiNew   = hiStart;\n\t\tlo      = GX_GET_PE_REG(addrLo);\n\t\thiStart = GX_GET_PE_REG(addrHi);\n\t} while (hiStart != hiNew);\n\n\treturn ((hiStart << 16) | lo);\n}\n\nstatic inline u32 GXReadPIReg(u32 addrLo, u32 addrHi)\n{\n\tu32 hiStart, hiNew, lo;\n\thiStart = GX_GET_PI_REG(addrHi);\n\tdo {\n\t\thiNew   = hiStart;\n\t\tlo      = GX_GET_PI_REG(addrLo);\n\t\thiStart = GX_GET_PI_REG(addrHi);\n\t} while (hiStart != hiNew);\n\n\treturn ((hiStart << 16) | lo);\n}\n\n////////////////////////////////////////////\n\n/////////// OTHER USEFUL DEFINES ///////////\n// useful define to check first two GXData members together\n// used in GXDisplayList, saves having a union in the struct\n#define GX_CHECK_FLUSH() (!(*(u32*)(&gx->vNumNot)))\n\n// do the damn rlwimi thing\n#define FAST_FLAG_SET(regOrg, newFlag, shift, size)                                                                \\\n\tdo {                                                                                                           \\\n\t\t(regOrg) = (u32)__rlwimi((int)(regOrg), (int)(newFlag), (shift), (32 - (shift) - (size)), (31 - (shift))); \\\n\t} while (0);\n\n////////////////////////////////////////////\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/GX/GXData.h\" */\n/* \"include\\Dolphin\\gx.h\" line 24 \"Dolphin/GX/GXHardware.h\" */\n#ifndef _DOLPHIN_GXHARDWARE_H\n#define _DOLPHIN_GXHARDWARE_H\n\n/* \"include\\Dolphin\\GX\\GXHardware.h\" line 3 \"Dolphin/GX/GXTypes.h\" */\n/* end \"Dolphin/GX/GXTypes.h\" */\n/* \"include\\Dolphin\\GX\\GXHardware.h\" line 4 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/**\n * Documentation from:\n * https://www.gc-forever.com/yagcd/chap8.html#sec8\n * https://www.gc-forever.com/yagcd/chap5.html#sec5\n * https://github.com/dolphin-emu/dolphin/blob/master/Source/Core/VideoCommon/BPMemory.h\n * https://github.com/dolphin-emu/dolphin/blob/master/Source/Core/VideoCommon/XFMemory.h\n * https://github.com/dolphin-emu/dolphin/blob/master/Source/Core/VideoCommon/OpcodeDecoding.h\n * https://patents.google.com/patent/US6700586B1/en\n * https://patents.google.com/patent/US6639595B1/en\n * https://patents.google.com/patent/US7002591\n * https://patents.google.com/patent/US6697074\n */\n\n#define GX_REG_MASK(st, end)          (((1 << ((end) - (st) + 1)) - 1) << 31 - (end))\n#define GX_GET_REG(reg, st, end)      GX_BITGET((reg), (st), ((end) - (st) + 1))\n#define GX_SET_REG(reg, x, st, end)   GX_BITFIELD_SET((reg), (st), ((end) - (st) + 1), (x))\n#define GX_SET_TRUNC(reg, x, st, end) GX_BITFIELD_TRUNC((reg), (st), ((end) - (st) + 1), (x))\n\n/************************************************************\n *\n *\n * GX FIFO\n *\n *\n ***********************************************************/\n\n#define __GX_FIFO_SET_LOAD_INDX_DST(reg, x)   ((reg) = GX_BITFIELD_SET(reg, 20, 12, x))\n#define __GX_FIFO_SET_LOAD_INDX_NELEM(reg, x) ((reg) = GX_BITFIELD_SET(reg, 16, 4, x))\n#define __GX_FIFO_SET_LOAD_INDX_INDEX(reg, x) ((reg) = GX_BITFIELD_SET(reg, 0, 16, x))\n\n#define __GX_FIFO_LOAD_INDX(reg, dst, nelem, index) \\\n\t{                                               \\\n\t\tu32 cmd = 0;                                \\\n\t\t__GX_FIFO_SET_LOAD_INDX_DST(cmd, dst);      \\\n\t\t__GX_FIFO_SET_LOAD_INDX_NELEM(cmd, nelem);  \\\n\t\t__GX_FIFO_SET_LOAD_INDX_INDEX(cmd, index);  \\\n\t\tGXWGFifo.s8  = reg;                         \\\n\t\tGXWGFifo.s32 = cmd;                         \\\n\t}\n\n#define GX_FIFO_LOAD_INDX_A(dst, nelem, index) __GX_FIFO_LOAD_INDX(GX_FIFO_CMD_LOAD_INDX_A, dst, nelem, index)\n\n#define GX_FIFO_LOAD_INDX_B(dst, nelem, index) __GX_FIFO_LOAD_INDX(GX_FIFO_CMD_LOAD_INDX_B, dst, nelem, index)\n\n#define GX_FIFO_LOAD_INDX_C(dst, nelem, index) __GX_FIFO_LOAD_INDX(GX_FIFO_CMD_LOAD_INDX_C, dst, nelem, index)\n\n#define GX_FIFO_LOAD_INDX_D(dst, nelem, index) __GX_FIFO_LOAD_INDX(GX_FIFO_CMD_LOAD_INDX_D, dst, nelem, index)\n\n/************************************************************\n *\n *\n * GX Blitting Processor (BP)\n *\n *\n ***********************************************************/\n\n/**\n * Load immediate value into BP register\n */\n#define GX_BP_LOAD_REG(data)                \\\n\tGXWGFifo.s8  = GX_FIFO_CMD_LOAD_BP_REG; \\\n\tGXWGFifo.s32 = (data);\n\n/**\n * Set BP command opcode (first 8 bits)\n */\n#define GX_BP_SET_OPCODE(cmd, opcode) (cmd) = GX_BITFIELD_SET(cmd, 0, 8, (opcode))\n\n/************************************************************\n *\n *\n * GX Command Processor (CP)\n *\n *\n ***********************************************************/\n\n/**\n * Load immediate value into CP register\n */\n#define GX_CP_LOAD_REG(addr, data)          \\\n\tGXWGFifo.s8  = GX_FIFO_CMD_LOAD_CP_REG; \\\n\tGXWGFifo.s8  = (addr);                  \\\n\tGXWGFifo.s32 = (data);\n\n/************************************************************\n *\n *\n * GX Transform Unit (XF)\n *\n *\n ***********************************************************/\n\n/**\n * Header for an XF register load\n */\n#define GX_XF_LOAD_REG_HDR(addr)            \\\n\tGXWGFifo.s8  = GX_FIFO_CMD_LOAD_XF_REG; \\\n\tGXWGFifo.s32 = (addr);\n\n/**\n * Load immediate value into XF register\n */\n#define GX_XF_LOAD_REG(addr, data) \\\n\tGX_XF_LOAD_REG_HDR(addr);      \\\n\tGXWGFifo.s32 = (data);\n\n/**\n * Load immediate values into multiple XF registers\n */\n#define GX_XF_LOAD_REGS(size, addr)    \\\n\t{                                  \\\n\t\tu32 cmd = (size) << 16 | addr; \\\n\t\tGX_XF_LOAD_REG_HDR(cmd);       \\\n\t}\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n/* end \"Dolphin/GX/GXHardware.h\" */\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"Dolphin/gx.h\" */\n/* \"src\\Dolphin\\gx\\GXAttr.c\" line 1 \"Dolphin/GX/GXHardware.h\" */\n/* end \"Dolphin/GX/GXHardware.h\" */\n", "diff_flags": [], "diff_label": "", "libraries": []}