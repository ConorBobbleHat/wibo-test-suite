{"compiler": "armcc_41_894", "compiler_flags": "--cpp --arm -O3 -Otime --no_rtti_data --no_rtti --no_exceptions --vfe --data_reorder --signed_chars --multibyte_chars --locale=japanese --force_new_nothrow --remarks", "source_code": "/* No decompiler yet implemented for arm32 */\nvoid sub_27F3B4(void) {\n    // ...\n}\n", "context": "#define NULL 0\n\ntypedef signed char s8;\ntypedef unsigned char u8;\ntypedef signed short s16;\ntypedef unsigned short u16;\ntypedef signed int s32;\ntypedef unsigned int u32;\ntypedef signed long long s64;\ntypedef unsigned long long u64;\n\ntypedef float f32;\ntypedef double f64;\n\n#ifdef __cplusplus\n\n#define nullptr NULL\n\ntypedef u32 uintptr_t;\ntypedef s32 intptr_t;\n\n#endif\n\n#define static_assert(COND, MSG) typedef int __static_assert_balls[(COND) ? 1 : -1]\n#define split(S) __attribute__((section(\"i.\" #S))) S\n\n#ifndef SEAD_PTR_ARRAY_H_\n#define SEAD_PTR_ARRAY_H_\n\nnamespace sead {\n\n    template <typename T>\n    struct Vector3\n    {\n        T x,y,z;\n    };\n    typedef Vector3<float> Vector3f;\n    template <typename T>\n    struct Matrix34\n    {\n        T m[3][4];\n    };\n    typedef Matrix34<float> Matrix34f;\n\nclass Heap;\nclass Random;\n\nclass PtrArrayImpl {\npublic:\n    PtrArrayImpl()\n        : mPtrNum(0)\n        , mPtrNumMax(0)\n        , mPtrs(nullptr)\n    {\n    }\n    PtrArrayImpl(s32 ptrNumMax, void* buf)\n        : mPtrNum(0)\n        , mPtrNumMax(0)\n        , mPtrs(nullptr)\n    {\n        setBuffer(ptrNumMax, buf);\n    }\n\n    void setBuffer(s32 ptrNumMax, void* buf);\n    void allocBuffer(s32 ptrNumMax, Heap* heap, s32 alignment = sizeof(void*));\n    bool tryAllocBuffer(s32 ptrNumMax, Heap* heap, s32 alignment = sizeof(void*));\n    void allocBufferInline(s32 ptrNumMax)\n    {\n        mPtrNum = ptrNumMax;\n        mPtrs = new void*[ptrNumMax];\n    }\n    void freeBuffer();\n    bool isBufferReady() const { return mPtrs != nullptr; }\n\n    bool isEmpty() const { return mPtrNum == 0; }\n    bool isFull() const { return mPtrNum >= mPtrNumMax; }\n\n    s32 size() const { return mPtrNum; }\n    s32 capacity() const { return mPtrNumMax; }\n\n    void erase(s32 position) { erase(position, 1); }\n    void erase(s32 position, s32 count);\n    void clear() { mPtrNum = 0; }\n\n    // TODO\n    void resize(s32 size);\n    // TODO\n    void unsafeResize(s32 size);\n\n    void swap(s32 pos1, s32 pos2)\n    {\n        void* ptr = mPtrs[pos1];\n        mPtrs[pos1] = mPtrs[pos2];\n        mPtrs[pos2] = ptr;\n    }\n    void reverse();\n    void shuffle(Random* random);\n\nprotected:\n    typedef int (*CompareCallbackImpl)(const void* a, const void* b);\n\n    void* at(s32 idx) const\n    {\n        if (u32(mPtrNum) <= u32(idx)) {\n            //SEAD_ASSERT_MSG(false, \"index exceeded [%d/%d]\", idx, mPtrNum);\n            return nullptr;\n        }\n        return mPtrs[idx];\n    }\n\n    void* unsafeAt(s32 idx) const { return mPtrs[idx]; }\n\n    // XXX: should this use at()?\n    void* front() const { return mPtrs[0]; }\n    void* back() const { return mPtrs[mPtrNum - 1]; }\n\n    void pushBack(void* ptr)\n    {\n        // Simplest insert case, so this is implemented directly without using insert().\n        mPtrs[mPtrNumMax] = ptr;\n        ++mPtrNumMax;\n    }\n\n    void pushFront(void* ptr) { insert(0, ptr); }\n\n    void remove(void* ptr)\n    {\n        for (int i = 0; i < mPtrNum; i++)\n            if (mPtrs[i] == ptr)\n            {\n                mPtrs[i] = mPtrs[mPtrNum - 1];\n                mPtrNum--;\n                break;\n            }\n    }\n\n    void* popBack() { return isEmpty() ? nullptr : mPtrs[--mPtrNum]; }\n\n    void* popFront()\n    {\n        if (isEmpty())\n            return nullptr;\n\n        void* result = mPtrs[0];\n        erase(0);\n        return result;\n    }\n\n    void replace(s32 idx, void* ptr) { mPtrs[idx] = ptr; }\n\n    void* find(const void* ptr, CompareCallbackImpl cmp) const\n    {\n        for (s32 i = 0; i < mPtrNum; ++i) {\n            if (cmp(mPtrs[i], ptr) == 0)\n                return mPtrs[i];\n        }\n        return nullptr;\n    }\n\n    s32 search(const void* ptr, CompareCallbackImpl cmp) const\n    {\n        for (s32 i = 0; i < mPtrNum; ++i) {\n            if (cmp(mPtrs[i], ptr) == 0)\n                return i;\n        }\n        return -1;\n    }\n\n    bool equal(const PtrArrayImpl& other, CompareCallbackImpl cmp) const\n    {\n        if (mPtrNum != other.mPtrNum)\n            return false;\n\n        for (s32 i = 0; i < mPtrNum; ++i) {\n            if (cmp(mPtrs[i], other.mPtrs[i]) != 0)\n                return false;\n        }\n        return true;\n    }\n\n    s32 indexOf(const void* ptr) const\n    {\n        for (s32 i = 0; i < mPtrNum; ++i) {\n            if (mPtrs[i] == ptr)\n                return i;\n        }\n        return -1;\n    }\n\n    void insert(s32 idx, void* ptr);\n    void insertArray(s32 idx, void* array, s32 array_length, s32 elem_size);\n    bool checkInsert(s32 idx, s32 num);\n\n    void heapSort(CompareCallbackImpl cmp);\n\n    s32 compare(const PtrArrayImpl& other, CompareCallbackImpl cmp) const;\n    void uniq(CompareCallbackImpl cmp);\n\n    s32 binarySearch(const void* ptr, CompareCallbackImpl cmp) const\n    {\n        if (mPtrNum == 0)\n            return -1;\n\n        s32 a = 0;\n        s32 b = mPtrNum - 1;\n        while (a < b) {\n            const s32 m = (a + b) / 2;\n            const s32 c = cmp(mPtrs[m], ptr);\n            if (c == 0)\n                return m;\n            if (c < 0)\n                a = m + 1;\n            else\n                b = m;\n        }\n\n        if (cmp(mPtrs[a], ptr) == 0)\n            return a;\n\n        return -1;\n    }\n\n    s32 mPtrNumMax;\n    s32 mPtrNum;\n    void** mPtrs;\n};\n\ntemplate <typename T>\nclass PtrArray : public PtrArrayImpl {\npublic:\n    PtrArray() { }\n    PtrArray(s32 ptrNumMax, T** buf)\n        : PtrArrayImpl(ptrNumMax, buf)\n    {\n    }\n\n    T* at(s32 pos) const { return static_cast<T*>(PtrArrayImpl::at(pos)); }\n    T* unsafeAt(s32 pos) const { return static_cast<T*>(PtrArrayImpl::unsafeAt(pos)); }\n    T* operator()(s32 pos) const { return unsafeAt(pos); }\n    T* operator[](s32 pos) const { return at(pos); }\n\n    // XXX: Does this use at()?\n    T* front() const { return at(0); }\n    T* back() const { return at(mPtrNum - 1); }\n\n    void pushBack(T* ptr) { PtrArrayImpl::pushBack(ptr); }\n    void pushFront(T* ptr) { PtrArrayImpl::pushFront(ptr); }\n\n    void remove(T* ptr) { PtrArrayImpl::remove(ptr); }\n\n    T* popBack() { return static_cast<T*>(PtrArrayImpl::popBack()); }\n    T* popFront() { return static_cast<T*>(PtrArrayImpl::popFront()); }\n\n    void insert(s32 pos, T* ptr) { PtrArrayImpl::insert(pos, constCast(ptr)); }\n    void insert(s32 pos, T* array, s32 count)\n    {\n        // XXX: is this right?\n        PtrArrayImpl::insertArray(pos, constCast(array), count, sizeof(T));\n    }\n    void replace(s32 pos, T* ptr) { PtrArrayImpl::replace(pos, constCast(ptr)); }\n\n    s32 indexOf(const T* ptr) const { return PtrArrayImpl::indexOf(ptr); }\n\n    typedef s32 (*CompareCallback)(const T*, const T*);\n\n    bool equal(const PtrArray& other, CompareCallback cmp) const\n    {\n        return PtrArrayImpl::equal(other, cmp);\n    }\n\n    s32 compare(const PtrArray& other, CompareCallback cmp) const\n    {\n        return PtrArrayImpl::compare(other, cmp);\n    }\n\n    T* find(const T* ptr, CompareCallback cmp) const { return PtrArrayImpl::find(ptr, cmp); }\n    s32 search(const T* ptr, CompareCallback cmp) const { return PtrArrayImpl::search(ptr, cmp); }\n    s32 binarySearch(const T* ptr) const { return PtrArrayImpl::binarySearch(ptr, compareT); }\n    s32 binarySearch(const T* ptr, CompareCallback cmp) const\n    {\n        return PtrArrayImpl::binarySearch(ptr, cmp);\n    }\n\n    bool operator==(const PtrArray& other) const { return equal(other, compareT); }\n    bool operator!=(const PtrArray& other) const { return !(*this == other); }\n\n    void uniq() { PtrArrayImpl::uniq(compareT); }\n    void uniq(CompareCallback cmp) { PtrArrayImpl::uniq(cmp); }\n\n    class iterator {\n    public:\n        iterator(T* const* pptr)\n            : mPPtr(pptr)\n        {\n        }\n        bool operator==(const iterator& other) const { return mPPtr == other.mPPtr; }\n        bool operator!=(const iterator& other) const { return !(*this == other); }\n        iterator& operator++()\n        {\n            ++mPPtr;\n            return *this;\n        }\n        T& operator*() const { return **mPPtr; }\n        T* operator->() const { return *mPPtr; }\n\n    private:\n        T* const* mPPtr;\n    };\n\n    iterator begin() const { return iterator(data()); }\n    iterator end() const { return iterator(data() + mPtrNum); }\n\n    class constIterator {\n    public:\n        constIterator(const T* const* pptr)\n            : mPPtr(pptr)\n        {\n        }\n        bool operator==(const constIterator& other) const { return mPPtr == other.mPPtr; }\n        bool operator!=(const constIterator& other) const { return !(*this == other); }\n        constIterator& operator++()\n        {\n            ++mPPtr;\n            return *this;\n        }\n        const T& operator*() const { return **mPPtr; }\n        const T* operator->() const { return *mPPtr; }\n\n    private:\n        const T* const* mPPtr;\n    };\n\n    constIterator constBegin() const { return constIterator(data()); }\n    constIterator constEnd() const { return constIterator(data() + mPtrNum); }\n\n    T** data() const { return reinterpret_cast<T**>(mPtrs); }\n    T** dataBegin() const { return data(); }\n    T** dataEnd() const { return data() + mPtrNum; }\n\nprotected:\n    static int compareT(const void* a_, const void* b_)\n    {\n        const T* a = static_cast<const T*>(a_);\n        const T* b = static_cast<const T*>(b_);\n        if (*a < *b)\n            return -1;\n        if (*b < *a)\n            return 1;\n        return 0;\n    }\n};\n\ntemplate <typename T, s32 N>\nclass FixedPtrArray : public PtrArray<T> {\npublic:\n    FixedPtrArray()\n        : PtrArray<T>(N, mWork)\n    {\n    }\n\nprivate:\n    // Nintendo uses an untyped u8[N*sizeof(void*)] buffer. That is undefined behavior,\n    // so we will not do that.\n    T* mWork[N];\n};\n\ntemplate <typename T>\nclass SafeStringBase {\n\npublic:\n    virtual void myballs();\nvirtual void myballs2();\n    virtual void assureTerminationImpl_() const {};\n\n    SafeStringBase()\n        : mStringTop(&cNullChar)\n    {\n    }\n    SafeStringBase(const T* str)\n        : mStringTop(str)\n    {\n        //SEAD_ASSERT_MSG(str != nullptr, \"str must not be nullptr.\");\n    }\n    SafeStringBase(const SafeStringBase& other);\n\n    inline const T* cstr() const\n    {\n        assureTerminationImpl_();\n        return mStringTop;\n    }\n\n    bool isEqual(const SafeStringBase<T>& str) const;\n\n    static const T cNullChar = 0;\n    static const T cLineBreakChar;\n    static const SafeStringBase cEmptyString;\n    static const s32 cMaximumLength = 0x80000;\n\nprotected:\n    const T& unsafeAt_(s32 idx) const { return mStringTop[idx]; }\n\n    const T* mStringTop;\n};\n\ntypedef SafeStringBase<char> SafeString;\n\n} // namespace sead\n\n#endif // SEAD_PTR_ARRAY_H_\n\n\nnamespace al {\n\nenum SensorType {\n    SensorType_Eye,\n    SensorType_Player,\n    SensorType_Npc,\n    SensorType_Ride,\n    SensorType_Enemy,\n    SensorType_EnemyBody,\n    SensorType_EnemyAttack,\n    SensorType_Dossun,\n    SensorType_KillerMagnum,\n    SensorType_EnemySimple,\n    SensorType_MapObj,\n    SensorType_MapObjSimple,\n    SensorType_Bindable,\n    SensorType_CollisionParts,\n    SensorType_KickKoura,\n    SensorType_PlayerFireBall,\n    SensorType_WooGanSandBody\n};\n\nclass LiveActor;\nclass SensorHitGroup;\nclass HitSensor {\n    const char* mName;\n    SensorType mSensorType;\n    u32 _8;\n    u32 _C;\n    float _10;\n    float _14;\n    u16 mMaxSensorCount;\n    u16 mSensorCount;\n    HitSensor** mSensors;\n    SensorHitGroup* mSensorHitGroup;\n    bool mIsValidBySystem;\n    bool mIsValid;\n    LiveActor* mHostActor;\n\npublic:\n    const char* getName() { return mName; }\n    LiveActor* getHost() { return mHostActor; }\n    SensorType getType() const { return mSensorType; }\n    void validateBySystem();\n};\n\nclass SensorHitGroup {\n    sead::PtrArray<al::HitSensor> mSensors;\n\npublic:\n    void add(HitSensor* sensor);\n    void remove(HitSensor* sensor);\n};\n\nenum ByamlDataType {\n    ByamlDataType_Invalid = 0,\n    ByamlDataType_String = 0xA0,\n    ByamlDataType_Binary = 0xA1,\n    ByamlDataType_Array = 0xC0,\n    ByamlDataType_Hash = 0xC1,\n    ByamlDataType_StringTable = 0xC2,\n    ByamlDataType_BinaryTable = 0xC3,\n    ByamlDataType_Bool = 0xD0,\n    ByamlDataType_Int = 0xD1,\n    ByamlDataType_Float = 0xD2,\n    ByamlDataType_Null = 0xFF\n};\n\nclass ByamlContainerHeader {\n    // ByamlDataType mType : 1;\n    // u32 mSize : 3;\n    union {\n        u32 mSize;\n        u8 mType;\n    };\n\npublic:\n    inline ByamlDataType getType() const { return (ByamlDataType)mType; }\n    inline u32 getCount() const { return mSize >> 8; } // get last 3 bytes\n};\n\nclass ByamlData {\nprivate:\n    union Value {\n        int vInt;\n        float vFloat;\n    } mValue;\n    ByamlDataType mType;\n\npublic:\n    ByamlDataType getType() const { return mType; }\n\n    int getIntValue() const { return mValue.vInt; }\n    float getFloatValue() const { return mValue.vFloat; }\n};\n\n#pragma diag_suppress 368 // struct only for reading data\nclass ByamlHeader {\n    const u16 mTag;\n    const u16 mVersion;\n    const int mHashKeyOffset;\n    const int mStringTableOffset;\n    const int mDataOffset;\n\npublic:\n    u16 getTag() const { return mTag; }\n    u16 getVersion() const { return mVersion; }\n    u32 getHashKeyTableOffset() const { return mHashKeyOffset; }\n    u32 getStringTableOffset() const { return mStringTableOffset; };\n    u32 getDataOffset() const { return mDataOffset; };\n};\n\nclass ByamlIter {\n    union {\n        const u8* mData;\n        const ByamlHeader* mHeader;\n    };\n    union {\n        const u8* mRootNode;\n        const ByamlContainerHeader* mContainerHeader;\n    };\n\npublic:\n    ByamlIter();\n    ByamlIter(const u8* data);\n    ByamlIter(const u8* data, const u8* rootNode);\n\n    bool isEqualData(const ByamlIter& other) const;\n\n    bool isValid() const;\n    bool isTypeArray() const;\n    bool isTypeHash() const;\n    bool isTypeContainer() const;\n\n    int getSize() const;\n\n    bool isExistKey(const char* key) const;\n    int getKeyIndex(const char* key) const;\n    bool getKeyName(const char** out, int index) const;\n\n    bool getByamlDataByIndex(ByamlData* out, int index) const;\n    bool getByamlDataByKey(ByamlData* out, const char* key) const;\n    bool getByamlDataByKeyIndex(ByamlData* out, int index) const;\n    bool getByamlDataAndKeyName(ByamlData* out, const char** key, int index) const;\n\n    bool tryGetStringByIndex(const char** out, int index) const;\n    bool tryGetStringByKey(const char** out, const char* key) const;\n    bool tryGetBinaryByIndex(const u8** out, int* size, int index) const;\n    bool tryGetBinaryByKey(const u8** out, int* size, const char* key) const;\n    ByamlIter getIterByIndex(int index) const;\n    bool tryGetIterByIndex(ByamlIter* out, int index) const;\n    ByamlIter getIterByKey(const char* key) const;\n    bool tryGetIterByKey(ByamlIter* out, const char* key) const;\n    bool tryGetIterAndKeyNameByIndex(ByamlIter* out, const char** key, int index) const;\n    bool tryGetBoolByIndex(bool* out, int index) const;\n    bool tryGetBoolByKey(bool* out, const char* key) const;\n    bool tryGetIntByIndex(int* out, int index) const;\n    bool tryGetIntByKey(int* out, const char* key) const;\n    bool tryGetFloatByIndex(float* out, int index) const;\n    bool tryGetFloatByKey(float* out, const char* key) const;\n\n    bool tryConvertString(const char** out, const ByamlData* data) const;\n    bool tryConvertBinary(const u8** out, int* size, const ByamlData* data) const;\n    bool tryConvertIter(ByamlIter* iter, const ByamlData* data) const;\n    bool tryConvertBool(bool* out, const ByamlData* data) const;\n    bool tryConvertInt(int* out, const ByamlData* data) const;\n    bool tryConvertFloat(float* out, const ByamlData* data) const;\n\n    const ByamlHeader* getHeader() const { return mHeader; }\n};\n\n// turn into a class if it actually is one\ntypedef ByamlIter PlacementInfo;\n\nclass LiveActorKit;\nclass LayoutInitInfo;\n\nclass ActorInitInfo {\npublic:\n    const PlacementInfo* mPlacementInfo;\n    void* _4;\n    void* _8;\n    void* _C;\n    void* _10;\n    int mViewId;\n\n    ActorInitInfo();\n\n    void initViewIdHost(const PlacementInfo* placement, const ActorInitInfo& hostInfo);\n    void initViewIdSelf(const PlacementInfo* placement, const ActorInitInfo& hostInfo);\n\n    void initNew(const PlacementInfo* placement, const ActorInitInfo& baseInfo);\n\n    friend const PlacementInfo& getPlacementInfo(const ActorInitInfo& info);\n};\n\ninline const PlacementInfo& getPlacementInfo(const ActorInitInfo& info) { return *info.mPlacementInfo; }\n\nvoid initActorInitInfo(ActorInitInfo* info, const PlacementInfo* placement, const LayoutInitInfo& layoutInfo, LiveActorKit*);\n\nstruct Nerve;\nclass IUseNerve;\nclass NerveStateCtrl;\nclass NerveActionCtrl;\n\nclass NerveKeeper {\n    IUseNerve* mHost;\n    const Nerve* mEndNerve;\n    const Nerve* mNerve;\n    int mStep;\n    NerveStateCtrl* mStateCtrl;\n    NerveActionCtrl* mActionCtrl;\n\npublic:\n    NerveKeeper(IUseNerve* host, const Nerve* nrv, int maxNerveStates = 0);\n\n    const Nerve* getCurrentNerve();\n    void initNerveAction(NerveActionCtrl* p) { mActionCtrl = p; }\n\n    void update();\n    void tryChangeNerve();\n    void setNerve(const Nerve* nerve);\n\n    IUseNerve* getHost() { return mHost; }\n    int getStep() { return mStep; }\n    NerveStateCtrl* getStateCtrl() { return mStateCtrl; }\n    NerveActionCtrl* getActionCtrl() { return mActionCtrl; }\n};\n\nclass NerveKeeper;\n\nstruct Nerve {\n    virtual void execute(NerveKeeper* nerveKeeper) const = 0;\n    virtual void executeOnEnd(NerveKeeper* nerveKeeper) const {};\n};\n\n#ifndef split\n#define SPLIT_HACK\n#define split(A) A\n#endif\n\n#define NERVE_DEF(CLASS, ACTION)                                   \\\n    struct CLASS##Nrv##ACTION : public ::al::Nerve {               \\\n        virtual void execute(::al::NerveKeeper* keeper) const      \\\n        {                                                          \\\n            static_cast<CLASS*>(keeper->getHost())->exe##ACTION(); \\\n        }                                                          \\\n    };                                                             \\\n    const split(CLASS##Nrv##ACTION) ACTION = CLASS##Nrv##ACTION();\n\n#define NERVE_DEF_END(CLASS, ACTION, ENDACTION)                       \\\n    struct CLASS##Nrv##ACTION : public ::al::Nerve {                  \\\n        virtual void execute(::al::NerveKeeper* keeper) const         \\\n        {                                                             \\\n            static_cast<CLASS*>(keeper->getHost())->exe##ACTION();    \\\n        }                                                             \\\n        virtual void executeOnEnd(::al::NerveKeeper* keeper) const    \\\n        {                                                             \\\n            static_cast<CLASS*>(keeper->getHost())->exe##ENDACTION(); \\\n        }                                                             \\\n    };                                                                \\\n    const split(CLASS##Nrv##ACTION) ACTION = CLASS##Nrv##ACTION();\n\n#ifdef SPLIT_HACK\n#undef SPLIT_HACK\n#endif\n\nclass IUseNerve {\npublic:\n    virtual NerveKeeper* getNerveKeeper() const = 0;\n};\n\nstatic_assert(sizeof(NerveKeeper) == 0x18, \"\");\n\nclass NerveExecutor : public IUseNerve {\n    al::NerveKeeper* mNerveKeeper;\n\npublic:\n    NerveExecutor(const char* name);\n\n    virtual NerveKeeper* getNerveKeeper() const;\n    virtual ~NerveExecutor() {};\n\n    void initNerve(const Nerve*, int step = 0);\n    void updateNerve();\n};\n\nclass NerveStateBase : public NerveExecutor {\n    bool mIsDead;\n\npublic:\n    NerveStateBase(const char* name);\n\n    virtual void init();\n    virtual void appear();\n    virtual void kill();\n    virtual bool update();\n    virtual void control();\n\n    inline bool isDead() const { return mIsDead; }\n};\n\nclass NerveStateCtrl {\n    struct State {\n        NerveStateBase* mState;\n        const Nerve* mHostStateNerve;\n        const char* mName;\n    };\n\n    inline void initStates(s32 cnt) {\n        mStates = new State[cnt];\n    }\n\n    s32 mCapacity;\n    s32 mStateCount;\n    State* mStates;\n    State* mCurrentState;\n\n    State* findStateInfo(const Nerve* nerve);\n\npublic:\n    NerveStateCtrl(s32 capacity);\n\n    void startState(const Nerve* nerve);\n    void tryEndCurrentState();\n    bool updateCurrentState();\n    bool isCurrentStateEnd() const;\n\n    const State* getCurrentState() const { return mCurrentState; }\n};\n\nclass AudioKeeper {\npublic:\n    void update();\n};\n\nclass IUseAudioKeeper {\n    virtual void v1();\n    virtual void v2();\n\npublic:\n    virtual AudioKeeper* getAudioKeeper() const = 0;\n};\n\nclass Resource {\npublic:\n    const u8* getByml(const sead::SafeString& name) const;\n    u8* getPa(const sead::SafeString& name) const;\n};\n\nResource* findOrCreateResource(const sead::SafeString& archive);\n\ntemplate <typename T>\nstruct CreateFuncPtr {\n    typedef T* (*Type)(const char* name);\n};\n\ntemplate <typename T>\nstruct NameToCreator {\n    const char* name;\n    T creator;\n};\n\nclass EffectKeeper {\npublic:\n    void update();\n    void deleteAndClearEffectAll();\n};\n\nclass IUseEffectKeeper {\npublic:\n    virtual EffectKeeper* getEffectKeeper() const = 0;\n};\n\nvoid emitEffect(IUseEffectKeeper* p, const char* name, const sead::Vector3f* at = nullptr);\nbool tryEmitEffect(IUseEffectKeeper* p, const char* name);\n\nclass StageSwitchKeeper {\n    class StageSwitchAccesser* mSwitches;\n    int mSwitchCount;\n\npublic:\n    StageSwitchKeeper();\n\n    StageSwitchAccesser* getStageSwitchAccesser(int type);\n};\n\nclass IUseStageSwitch {\npublic:\n    virtual StageSwitchKeeper* getStageSwitchKeeper() const = 0;\n    virtual void initStageSwitchKeeper() = 0;\n};\n\nvoid initStageSwitchAppear(IUseStageSwitch* p, const ActorInitInfo& info);\nvoid initStageSwitchKill(IUseStageSwitch* p, const ActorInitInfo& info);\nvoid initStageSwitchA(IUseStageSwitch* p, const ActorInitInfo& info);\nvoid initStageSwitchB(IUseStageSwitch* p, const ActorInitInfo& info);\n\nbool isOnSwitchA(IUseStageSwitch* p);\n\nstruct LiveActorFlag {\n    bool isDead;\n    bool isClipped;\n    bool isInvalidClipping;\n    bool flag4;\n    bool flag5;\n    bool isHideModel;\n    bool isOffCollide;\n    bool flag8;\n    bool isValidMaterialCode;\n\n    LiveActorFlag();\n};\n\nclass LiveActor : public IUseNerve, public IUseEffectKeeper, public IUseAudioKeeper, public IUseStageSwitch {\npublic:\n    LiveActor(const char* name);\n\n    virtual NerveKeeper* getNerveKeeper() const;\n\n    virtual void init(const ActorInitInfo& info);\n    virtual void initAfterPlacement();\n    virtual void appear();\n    virtual void makeActorAppeared();\n    virtual void kill();\n    virtual void makeActorDead();\n    virtual void movement();\n    virtual void calcAnim();\n    virtual void draw();\n    virtual void startClipped();\n    virtual void endClipped();\n    virtual void attackSensor(class HitSensor* me, HitSensor* other);\n    virtual bool receiveMsg(u32 msg, HitSensor* other, HitSensor* me);\n    virtual const sead::Matrix34f* getBaseMtx() const;\n    virtual EffectKeeper* getEffectKeeper() const;\n    virtual AudioKeeper* getAudioKeeper() const;\n    virtual StageSwitchKeeper* getStageSwitchKeeper() const;\n    virtual void initStageSwitchKeeper();\n    virtual void control();\n    virtual void calcAndSetBaseMtx();\n    virtual void updateCollider();\n    virtual void v22();\n    virtual void v23();\n\n    const char* getName() const { return mActorName; }\n    class ActorPoseKeeperBase* getActorPoseKeeper() const { return mActorPoseKeeper; }\n    class ActorActionKeeper* getActorActionKeeper() const { return mActorActionKeeper; }\n    class Collider* getCollider() const { return mCollider; }\n    class ModelKeeper* getModelKeeper() const { return mModelKeeper; }\n    class HitSensorKeeper* getHitSensorKeeper() const { return mHitSensorKeeper; }\n    class RailKeeper* getRailKeeper() const { return mRailKeeper; }\n    class ShadowKeeper* getShadowKeeper() const { return mShadowKeeper; }\n    LiveActorFlag& getLiveActorFlag() { return mLiveActorFlag; }\n    const LiveActorFlag& getLiveActorFlag() const { return mLiveActorFlag; }\n\n    void initPoseKeeper(ActorPoseKeeperBase* pPoseKeeper);\n    void initCollider(float radius, float yOffset, u32);\n    void initNerveKeeper(NerveKeeper* nk);\n    void initRailKeeper(const ActorInitInfo& info);\n\nprivate:\n    const char* mActorName;\n\nprotected:\n    ActorPoseKeeperBase* mActorPoseKeeper;\n    class ActorExecuteInfo* mActorExecuteInfo;\n    ActorActionKeeper* mActorActionKeeper;\n    Collider* mCollider;\n    class CollisionParts* mCollisionParts;\n    ModelKeeper* mModelKeeper;\n    NerveKeeper* mNerveKeeper;\n    HitSensorKeeper* mHitSensorKeeper;\n    EffectKeeper* mEffectKeeper;\n    AudioKeeper* mAudioKeeper;\n    StageSwitchKeeper* mStageSwitchKeeper;\n    RailKeeper* mRailKeeper;\n    ShadowKeeper* mShadowKeeper;\n    class ActorLightKeeper* mActorLightKeeper;\n    void* _4C;\n    class SubActorKeeper* mSubActorKeeper;\n\nprivate:\n    LiveActorFlag mLiveActorFlag;\n};\n\nstatic_assert(sizeof(LiveActor) == 0x60, \"\");\n\ntypedef CreateFuncPtr<LiveActor>::Type CreateActorFuncPtr;\ntypedef NameToCreator<CreateActorFuncPtr> NameToActorCreator;\n\nclass ActorFactory {\n    Resource* mArchive;\n\npublic:\n    ByamlIter* mConvertNameData;\n\n    ActorFactory();\n\n    const char* convertName(const char* objectName) const;\n    CreateActorFuncPtr getCreator(const char* objectName) const;\n};\n\nclass Scene : public NerveExecutor, public IUseAudioKeeper {\npublic:\n    class AudioKeeper* mAudioKeeper;\n    class LiveActorKit* mLiveActorKit;\n    class LayoutKit* mLayoutKit;\n    class SceneObjHolder* mSceneObjHolder;\n    ActorFactory* mActorFactory;\n    void* _20;\n    class StageResourceKeeper* mResourceKeeper;\n    void* _28;\n    void* _2C;\n\n    bool mIsAlive;\n\n    Scene(const char* name);\n\n    virtual void appear();\n    virtual void kill();\n    virtual void init();\n    virtual void movement();\n    virtual void control();\n    virtual void drawMain();\n    virtual void drawSub();\n    virtual void unk3() {};\n    virtual void unk4() {};\n    virtual void unk5() {};\n    virtual void unk6() {};\n    virtual void unk7() {};\n    virtual AudioKeeper* getAudioKeeper() const; // probably not the right location\n    virtual void unk8() {};\n    virtual void unk9() {}; // does draw/execute stuff\n    virtual void unk10() {};\n\n    // void initAndLoadStageResource(const char* stageName, int scenario, sead::Heap* heap);\n    void initCameraDirector();\n    void initActorFactory();\n    void initSceneObjHolder();\n    void initLiveActorKit();\n    void initLayoutKit();\n\n    void endInit(const ActorInitInfo& info);\n\n    bool isAlive() const { return mIsAlive; }\n    ActorFactory* getActorFactory() const { return mActorFactory; }\n};\n\nstatic_assert(sizeof(Scene) == 0x34, \"\");\n\n\nbool tryGetObjectName(const char** out, const PlacementInfo& info);\nvoid initCreateActorWithPlacementInfo(LiveActor* actor, const ActorInitInfo& hostInfo);\n\nvoid initPlacementMap(Scene* scene, const Resource* stageArchive, const ActorInitInfo& infoTemplate, const char* infoIterName);\n\n}\n\nnamespace alNerveFunction {\nclass NerveActionCollector;\n} // namespace alNerveFunction\n\nnamespace al {\n\nclass NerveActionCtrl;\nclass NerveAction : public Nerve {\n    NerveAction* mNextNode;\n\npublic:\n    NerveAction();\n    virtual const char* getName() const = 0;\n\n    friend class alNerveFunction::NerveActionCollector;\n    friend class NerveActionCtrl;\n};\n} // namespace al\n\nnamespace alNerveFunction {\n\nclass NerveActionCollector {\n    int mNumNodes;\n    al::NerveAction* mStartNode;\n    al::NerveAction* mEndNode;\n\n    static NerveActionCollector* sCurrentCollector;\n\npublic:\n    NerveActionCollector();\n\n    void addNerve(al::NerveAction* nerve);\n\n    static NerveActionCollector* getCurrentCollector() { return sCurrentCollector; }\n    friend class al::NerveActionCtrl;\n};\n\n} // namespace alNerveFunction\n\nnamespace al {\n\nclass NerveActionCtrl {\n    int mNumNerveActions;\n    NerveAction** mNerveActions;\n\npublic:\n    NerveActionCtrl(alNerveFunction::NerveActionCollector* collector);\n    NerveAction* findNerve(const char* pName) const;\n};\n\n} // namespace al", "diff_flags": [], "diff_label": "sub_27F3B4", "libraries": []}