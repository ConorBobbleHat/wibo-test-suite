{"compiler": "mwcc_247_108", "compiler_flags": "-lang=c++ -Cpp_exceptions off -nodefaults -O3 -fp hard -msgstyle gcc -str pool,readonly,reuse -RTTI off -maxerrors 1 -enum int -sym on", "source_code": "/*\nDecompilation failure:\n\nSyntax error when parsing C context.\nDirectives not supported yet at line 7, column 1\n\n#ifndef D_D_ATTENTION_H\n*/\n\nint dAttCatch_c::request(fopAc_ac_c* param_1, u8 param_2, f32 param_3, f32 param_4,\n                              f32 param_5, s16 param_6, int param_7) {\n    fopAc_ac_c* player = dComIfGp_getPlayer(0);\n    \n    if (param_7 > field_0x4) {\n        return 0;\n    } \n    cXyz acStack_48 = param_1->mAttentionInfo.mPosition - player->mAttentionInfo.mPosition;\n    if (acStack_48.y < param_5 || acStack_48.y > param_4) {\n        return 0;\n    }\n    f32 dVar7 = acStack_48.absXZ();\n    if (dVar7 > param_3) {\n        return 0;\n    }\n    if (param_6 != 0) {\n        cSGlobe acStack_50(acStack_48);\n        s16 sVar5 = acStack_50.U() - fopAcM_GetShapeAngle_p(player).y;\n        if (sVar5 < 0) {\n            sVar5 = -sVar5;\n        }\n        if (sVar5 == -0x8000) {\n            sVar5 = 0x7fff;\n        }\n        if (sVar5 > param_6) {\n            return 0;\n        }\n    }\n    if (param_7 < field_0x4 || dVar7 < field_0x8) {\n        field_0x4 = param_7;\n        field_0xc = param_2;\n        field_0x0 = fopAcM_GetID(param_1);\n        field_0x8 = dVar7;\n        return 1;\n    }\n    return 0;\n}\n", "context": "//\n// Generated By: dol2asm\n// Translation Unit: d/d_attention\n//\n\n/* \"src/d/d_attention.cpp\" line 5 \"d/d_attention.h\" */\n#ifndef D_D_ATTENTION_H\n#define D_D_ATTENTION_H\n\n/* \"include/d/d_attention.h\" line 3 \"SSystem/SComponent/c_angle.h\" */\n#ifndef C_ANGLE_H\n#define C_ANGLE_H\n\n/* \"include/SSystem/SComponent/c_angle.h\" line 3 \"SSystem/SComponent/c_xyz.h\" */\n#ifndef C_XYZ_H\n#define C_XYZ_H\n\n/* \"include/SSystem/SComponent/c_xyz.h\" line 3 \"math.h\" */\n#ifndef MSL_MATH_H_\n#define MSL_MATH_H_\n\n/* \"libs/PowerPC_EABI_Support/MSL/MSL_C/MSL_Common/Include/math.h\" line 3 \"float.h\" */\n#ifndef _MSL_COMMON_FLOAT_H\n#define _MSL_COMMON_FLOAT_H\n\n/* \"libs/PowerPC_EABI_Support/MSL/MSL_C/MSL_Common/Include/float.h\" line 3 \"fdlibm.h\" */\n#ifndef FDLIBM_H\n#define FDLIBM_H\n\n/* @(#)fdlibm.h 1.5 04/04/22 */\n/*\n * ====================================================\n * Copyright (C) 2004 by Sun Microsystems, Inc. All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this\n * software is freely granted, provided that this notice\n * is preserved.\n * ====================================================\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Sometimes it's necessary to define __LITTLE_ENDIAN explicitly\n   but these catch some common cases. */\n\n#if defined(i386) || defined(i486) || defined(intel) || defined(x86) || defined(i86pc) ||          \\\n    defined(__alpha) || defined(__osf__)\n#define __LITTLE_ENDIAN\n#endif\n\n#ifdef __LITTLE_ENDIAN\n#define __HI(x) *(1 + (int*)&x)\n#define __LO(x) *(int*)&x\n#define __HIp(x) *(1 + (int*)x)\n#define __LOp(x) *(int*)x\n#else\n#define __HI(x) *(int*)&x\n#define __LO(x) *(1 + (int*)&x)\n#define __HIp(x) *(int*)x\n#define __LOp(x) *(1 + (int*)x)\n#endif\n\n// TODO: should __STDC__ actually be defined?\n//#ifdef __STDC__\n#define __P(p) p\n//#else\n//#define __P(p) ()\n//#endif\n\n/*\n * ANSI/POSIX\n */\n\nextern int signgam;\n\n#define MAXFLOAT ((float)3.40282346638528860e+38)\n\nenum fdversion { fdlibm_ieee = -1, fdlibm_svid, fdlibm_xopen, fdlibm_posix };\n\n#define _LIB_VERSION_TYPE enum fdversion\n#define _LIB_VERSION _fdlib_version\n\n/* if global variable _LIB_VERSION is not desirable, one may\n * change the following to be a constant by:\n *\t#define _LIB_VERSION_TYPE const enum version\n * In that case, after one initializes the value _LIB_VERSION (see\n * s_lib_version.c) during compile time, it cannot be modified\n * in the middle of a program\n */\nextern _LIB_VERSION_TYPE _LIB_VERSION;\n\n#define _IEEE_ fdlibm_ieee\n#define _SVID_ fdlibm_svid\n#define _XOPEN_ fdlibm_xopen\n#define _POSIX_ fdlibm_posix\n\nstruct exception {\n    int type;\n    char* name;\n    double arg1;\n    double arg2;\n    double retval;\n};\n\n#define HUGE MAXFLOAT\n\n/*\n * set X_TLOSS = pi*2**52, which is possibly defined in <values.h\"\n * (one may replace the following line by \"#include \"values.h\"\")\n */\n\n#define X_TLOSS 1.41484755040568800000e+16\n\n#define DOMAIN 1\n#define SING 2\n#define OVERFLOW 3\n#define UNDERFLOW 4\n#define TLOSS 5\n#define PLOSS 6\n\n/*\n * ANSI/POSIX\n */\nextern double acos __P((double));\nextern double asin __P((double));\nextern double atan __P((double));\nextern double atan2 __P((double, double));\nextern double cos __P((double));\nextern double sin __P((double));\nextern double tan __P((double));\n\nextern double cosh __P((double));\nextern double sinh __P((double));\nextern double tanh __P((double));\n\nextern double exp __P((double));\nextern double frexp __P((double, int*));\nextern double ldexp __P((double, int));\nextern double log __P((double));\nextern double log10 __P((double));\nextern double modf __P((double, double*));\n\nextern double pow __P((double, double));\nextern double sqrt __P((double));\n\nextern double ceil __P((double));\nextern double fabs __P((double));\nextern double floor __P((double));\nextern double fmod __P((double, double));\n\nextern double erf __P((double));\nextern double erfc __P((double));\nextern double gamma __P((double));\nextern double hypot __P((double, double));\nextern int isnan __P((double));\nextern int finite __P((double));\nextern double j0 __P((double));\nextern double j1 __P((double));\nextern double jn __P((int, double));\nextern double lgamma __P((double));\nextern double y0 __P((double));\nextern double y1 __P((double));\nextern double yn __P((int, double));\n\nextern double acosh __P((double));\nextern double asinh __P((double));\nextern double atanh __P((double));\nextern double cbrt __P((double));\nextern double logb __P((double));\nextern double nextafter __P((double, double));\nextern double remainder __P((double, double));\n#ifdef _SCALB_INT\nextern double scalb __P((double, int));\n#else\nextern double scalb __P((double, double));\n#endif\n\nextern int matherr __P((struct exception*));\n\n/*\n * IEEE Test Vector\n */\nextern double significand __P((double));\n\n/*\n * Functions callable from C, intended to support IEEE arithmetic.\n */\nextern double copysign __P((double, double));\nextern int ilogb __P((double));\nextern double rint __P((double));\nextern double scalbn __P((double, int));\n\n/*\n * BSD math library entry points\n */\nextern double expm1 __P((double));\nextern double log1p __P((double));\n\n/*\n * Reentrant version of gamma & lgamma; passes signgam back by reference\n * as the second argument; user must allocate space for signgam.\n */\n#ifdef _REENTRANT\nextern double gamma_r __P((double, int*));\nextern double lgamma_r __P((double, int*));\n#endif /* _REENTRANT */\n\n/* ieee style elementary functions */\nextern double __ieee754_sqrt __P((double));\nextern double __ieee754_acos __P((double));\nextern double __ieee754_acosh __P((double));\nextern double __ieee754_log __P((double));\nextern double __ieee754_atanh __P((double));\nextern double __ieee754_asin __P((double));\nextern double __ieee754_atan2 __P((double, double));\nextern double __ieee754_exp __P((double));\nextern double __ieee754_cosh __P((double));\nextern double __ieee754_fmod __P((double, double));\nextern double __ieee754_pow __P((double, double));\nextern double __ieee754_lgamma_r __P((double, int*));\nextern double __ieee754_gamma_r __P((double, int*));\nextern double __ieee754_lgamma __P((double));\nextern double __ieee754_gamma __P((double));\nextern double __ieee754_log10 __P((double));\nextern double __ieee754_sinh __P((double));\nextern double __ieee754_hypot __P((double, double));\nextern double __ieee754_j0 __P((double));\nextern double __ieee754_j1 __P((double));\nextern double __ieee754_y0 __P((double));\nextern double __ieee754_y1 __P((double));\nextern double __ieee754_jn __P((int, double));\nextern double __ieee754_yn __P((int, double));\nextern double __ieee754_remainder __P((double, double));\nextern int __ieee754_rem_pio2 __P((double, double*));\n#ifdef _SCALB_INT\nextern double __ieee754_scalb __P((double, int));\n#else\nextern double __ieee754_scalb __P((double, double));\n#endif\n\n/* fdlibm kernel function */\nextern double __kernel_standard __P((double, double, int));\nextern double __kernel_sin __P((double, double, int));\nextern double __kernel_cos __P((double, double));\nextern double __kernel_tan __P((double, double, int));\nextern int __kernel_rem_pio2 __P((double*, double*, int, int, int, const int*));\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* FDLIBM_H *//* end \"fdlibm.h\" */\n\n#define FP_SNAN 0\n#define FP_QNAN 1\n#define FP_INFINITE 2\n#define FP_ZERO 3\n#define FP_NORMAL 4\n#define FP_SUBNORMAL 5\n\n#define FP_NAN FP_QNAN\n\n#define fpclassify(x) ((sizeof(x) == sizeof(float)) ? __fpclassifyf(x) : __fpclassifyd(x))\n#define signbit(x) ((sizeof(x) == sizeof(float)) ? __signbitf(x) : __signbitd(x))\n#define isfinite(x) ((fpclassify(x) > 2))\n\n#define __signbitf(x) ((int)(__HI(x) & 0x80000000))\n\n// TODO: OK?\n#define __signbitd(x) ((int)(__HI(x) & 0x80000000))\n\nextern unsigned long __float_nan[];\nextern unsigned long __float_huge[];\nextern unsigned long __float_max[];\nextern unsigned long __float_epsilon[];\n\ninline int __fpclassifyf(float __value) {\n    unsigned long integer = *(unsigned long*)&__value;\n\n    switch (integer & 0x7f800000) {\n    case 0x7f800000:\n        if ((integer & 0x7fffff) != 0) {\n            return FP_QNAN;\n        }\n        return FP_INFINITE;\n\n    case 0:\n        if ((integer & 0x7fffff) != 0) {\n            return FP_SUBNORMAL;\n        }\n        return FP_ZERO;\n    }\n\n    return FP_NORMAL;\n}\n\ninline int __fpclassifyd(double __value) {\n    switch (__HI(__value) & 0x7ff00000) {\n\tcase 0x7ff00000: {\n\t\tif ((__HI(__value) & 0x000fffff) || (__LO(__value) & 0xffffffff))\n\t\t\treturn FP_QNAN;\n\t\telse\n\t\t\treturn FP_INFINITE;\n\t\tbreak;\n\t}\n\tcase 0: {\n\t\tif ((__HI(__value) & 0x000fffff) || (__LO(__value) & 0xffffffff))\n\t\t\treturn FP_SUBNORMAL;\n\t\telse\n\t\t\treturn FP_ZERO;\n\t\tbreak;\n\t}\n\t}\n\treturn FP_NORMAL;\n}\n\n#define FLT_MANT_DIG   24\n#define FLT_DIG        6\n#define FLT_MIN_EXP    (-125)\n#define FLT_MIN_10_EXP (-37)\n#define FLT_MAX_EXP    128\n#define FLT_MAX_10_EXP 38\n\n#define FLT_MAX (*(float*) __float_max)\n#define FLT_EPSILON (*(float*) __float_epsilon)\n\n#define DBL_MANT_DIG   53\n#define DBL_DIG        15\n#define DBL_MIN_EXP    (-1021)\n#define DBL_MIN_10_EXP (-308)\n#define DBL_MAX_EXP    1024\n#define DBL_MAX_10_EXP 308\n\n#endif /* _MSL_COMMON_FLOAT_H */\n/* end \"float.h\" */\n\n#define NAN (*(float*) __float_nan)\n#define HUGE_VALF (*(float*) __float_huge)\n\n#define M_PI 3.14159265358979323846f\n#define M_SQRT3 1.73205f\n\n#define DEG_TO_RAD(degrees) (degrees * (M_PI / 180.0f))\n#define RAD_TO_DEG(radians) (radians / (180.0f / M_PI))\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint abs(int);\ndouble acos(double);\nfloat acosf(float);\ndouble asin(double);\ndouble atan(double);\ndouble atan2(double, double);\ndouble ceil(double);\ndouble copysign(double, double);\ndouble cos(double);\nfloat cosf(float);\ndouble exp(double);\n\nextern float __fabsf(float);\ninline double fabs(double f) {\n    return __fabs(f);\n}\ninline double fabsf2(float f) {\n    return __fabsf(f);\n}\ninline float fabsf(float f) {\n    return fabsf2(f);\n}\n\ndouble floor(double);\ndouble fmod(double, double);\ninline float fmodf(float f1, float f2) {\n    return fmod(f1, f2);\n}\n\ndouble frexp(double, int*);\ndouble ldexp(double, int);\ndouble modf(double, double*);\ndouble pow(double, double);\ndouble sin(double);\nfloat sinf(float);\ndouble sqrt(double);\ndouble tan(double);\nfloat tanf(float);\n\ninline double sqrt_step(double tmpd, float mag) {\n    return tmpd * 0.5 * (3.0 - mag * (tmpd * tmpd));\n}\n\ninline float sqrtf(float mag) {\n    if (mag > 0.0f) {\n        double tmpd = __frsqrte(mag);\n        tmpd = sqrt_step(tmpd, mag);\n        tmpd = sqrt_step(tmpd, mag);\n        tmpd = sqrt_step(tmpd, mag);\n        return mag * tmpd;\n    } else if (mag < 0.0) {\n        return NAN;\n    } else if (fpclassify(mag) == 1) {\n        return NAN;\n    } else {\n        return mag;\n    }\n}\n\ninline float atan2f(float y, float x) {\n    return (float)atan2(y, x);\n}\n\ninline float i_sinf(float x) { return sin(x); }\ninline float i_cosf(float x) { return cos(x); }\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif\n/* end \"math.h\" */\n/* \"include/SSystem/SComponent/c_xyz.h\" line 4 \"dolphin/mtx/vec.h\" */\n#ifndef VEC_H\n#define VEC_H\n\n/* \"include/dolphin/mtx/vec.h\" line 3 \"dolphin/types.h\" */\n#ifndef TYPES_H_\n#define TYPES_H_\n\ntypedef signed char s8;\ntypedef signed short s16;\ntypedef signed long s32;\ntypedef signed long long s64;\ntypedef unsigned char u8;\ntypedef unsigned short u16;\ntypedef unsigned long u32;\ntypedef unsigned long long u64;\n\ntypedef volatile u8 vu8;\ntypedef volatile u16 vu16;\ntypedef volatile u32 vu32;\ntypedef volatile u64 vu64;\ntypedef volatile s8 vs8;\ntypedef volatile s16 vs16;\ntypedef volatile s32 vs32;\ntypedef volatile s64 vs64;\n\ntypedef float f32;\ntypedef double f64;\ntypedef volatile f32 vf32;\ntypedef volatile f64 vf64;\n\ntypedef int BOOL;\n\n#define TRUE 1\n#define FALSE 0\n\n#define READU32_BE(ptr, offset) \\\n    (((u32)ptr[offset] << 24) | ((u32)ptr[offset + 1] << 16) | ((u32)ptr[offset + 2] << 8) | (u32)ptr[offset + 3]);\n\n/* \"include/dolphin/types.h\" line 34 \"stddef.h\" */\n#ifndef _STDDEF_H_\n#define _STDDEF_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined __INTELLISENSE__\ntypedef unsigned int size_t;\ntypedef int ptrdiff_t;\n#else\ntypedef unsigned long size_t;\ntypedef long ptrdiff_t;\n#endif\n\n#define offsetof(type, member)\t((size_t)&(((type*)0)->member))\n\n#ifndef NULL\n#define NULL (0)\n#endif\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif/* end \"stddef.h\" */\n\n#define INT32_MAX (0x7fffffff)\n#define UINT32_MAX (0xffffffff)\n\n#define FLOAT_MIN (1.175494351e-38f)\n#define FLOAT_MAX (3.40282346638528860e+38f)\n\n#endif/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct Vec {\n    f32 x, y, z;\n} Vec;\n\ntypedef Vec* VecPtr;\ntypedef Vec Point3d;\ntypedef Vec* Point3dPtr;\n\ntypedef struct SVec {\n    s16 x, y, z;\n} SVec;\n\nvoid PSVECAdd(const Vec* a, const Vec* b, Vec* ab);\nvoid PSVECSubtract(const Vec* a, const Vec* b, Vec* a_b);\nvoid PSVECScale(const Vec* src, Vec* dst, f32 scale);\nvoid PSVECNormalize(const Vec* src, Vec* unit);\nf32 PSVECSquareMag(const Vec* v);\nf32 PSVECMag(const Vec* v);\nf32 PSVECDotProduct(const Vec* a, const Vec* b);\nvoid PSVECCrossProduct(const Vec* a, const Vec* b, Vec* axb);\nf32 PSVECSquareDistance(const Vec* a, const Vec* b);\nf32 PSVECDistance(const Vec* a, const Vec* b);\n\nvoid C_VECHalfAngle(const Vec* a, const Vec* b, Vec* half);\nvoid C_VECReflect(const Vec* src, const Vec* normal, Vec* dst);\n\ninline void C_VECAdd(register const Vec* a, register const Vec* b, register Vec* ab) {\n    register f32 axy;\n    register f32 bxy;\n    register f32 az;\n    register f32 sumz;\n    register f32 bz;\n    asm {\n        psq_l axy, 0(a), 0, 0\n        psq_l bxy, 0(b), 0, 0\n        ps_add axy, axy, bxy\n        psq_st axy, 0(ab), 0, 0\n        psq_l az, 8(a), 1, 0\n        psq_l bz, 8(b), 1, 0\n        ps_add sumz, az, bz\n        psq_st sumz, 8(ab), 1, 0\n    }\n}\n\ninline void C_VECSubtract(register const Vec* a, register const Vec* b, register Vec* ab) {\n    register f32 axy;\n    register f32 bxy;\n    register f32 az;\n    register f32 subz;\n    register f32 bz;\n    asm {\n        psq_l axy, 0(a), 0, 0\n        psq_l bxy, 0(b), 0, 0\n        ps_sub bxy, axy, bxy\n        psq_st bxy, 0(ab), 0, 0\n        psq_l az, 8(a), 1, 0\n        psq_l bz, 8(b), 1, 0\n        ps_sub subz, az, bz\n        psq_st subz, 8(ab), 1, 0\n    }\n}\n\ninline f32 C_VECSquareMag(const Vec* v) {\n    register f32 x_y;\n    register f32 z;\n    register f32 res;\n    register const f32* src = &v->x;\n    asm {\n        psq_l   x_y, 0(src), 0, 0\n        ps_mul  x_y, x_y, x_y\n        lfs     z,   8(src)\n        ps_madd res, z, z, x_y\n        ps_sum0 res, res, x_y, x_y\n    }\n    ;\n    return res;\n}\n\n/* When compiling in debug mode, use C implementations */\n#ifdef DEBUG\n// TODO: Add debug rom C implementations\n/* #define VECAdd C_VECAdd\n#define VECSubtract C_VECSubtract\n#define VECScale C_VECScale\n#define VECNormalize C_VECNormalize\n#define VECSquareMag C_VECSquareMag\n#define VECMag C_VECMag\n#define VECDotProduct C_VECDotProduct\n#define VECCrossProduct C_VECCrossProduct\n#define VECSquareDistance C_VECSquareDistance\n#define VECDistance C_VECDistance */\n\n#define VECAdd PSVECAdd\n#define VECSubtract PSVECSubtract\n#define VECScale PSVECScale\n#define VECNormalize PSVECNormalize\n#define VECSquareMag PSVECSquareMag\n#define VECMag PSVECMag\n#define VECDotProduct PSVECDotProduct\n#define VECCrossProduct PSVECCrossProduct\n#define VECSquareDistance PSVECSquareDistance\n#define VECDistance PSVECDistance\n#else\n#define VECAdd PSVECAdd\n#define VECSubtract PSVECSubtract\n#define VECScale PSVECScale\n#define VECNormalize PSVECNormalize\n#define VECSquareMag PSVECSquareMag\n#define VECMag PSVECMag\n#define VECDotProduct PSVECDotProduct\n#define VECCrossProduct PSVECCrossProduct\n#define VECSquareDistance PSVECSquareDistance\n#define VECDistance PSVECDistance\n#endif\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* VEC_H */\n/* end \"dolphin/mtx/vec.h\" */\n\nstruct cXyz : Vec {\n    static const cXyz Zero;\n    static const cXyz BaseX;\n    static const cXyz BaseY;\n    static const cXyz BaseZ;\n    static const cXyz BaseXY;\n    static const cXyz BaseXZ;\n    static const cXyz BaseYZ;\n    static const cXyz BaseXYZ;\n    /* 80009184 */ ~cXyz() {}\n    /* inlined  */ cXyz() {}\n    cXyz(f32 x, f32 y, f32 z) {\n        this->x = x;\n        this->y = y;\n        this->z = z;\n    }\n    cXyz(const cXyz& vec) {\n        this->x = vec.x;\n        this->y = vec.y;\n        this->z = vec.z;\n    }\n    cXyz(const Vec& vec) {\n        this->x = vec.x;\n        this->y = vec.y;\n        this->z = vec.z;\n    }\n    void operator=(const Vec& vec) {\n        this->x = vec.x;\n        this->y = vec.y;\n        this->z = vec.z;\n    }\n    /* 80266AE4 */ cXyz operator+(Vec const&) const;\n    /* 80266B34 */ cXyz operator-(Vec const&) const;\n    /* 80266B84 */ cXyz operator*(f32) const;\n    /* 80266BD0 */ cXyz operator*(Vec const&) const;\n    /* 80266C18 */ cXyz operator/(f32) const;\n    /* 800977D8 */ // void operator=(cXyz const&);\n\n    void operator+=(f32 f) {\n        x += f;\n        y += f;\n        z += f;\n    }\n    void operator-=(f32 f) {\n        x -= f;\n        y -= f;\n        z -= f;\n    }\n    void operator-=(const Vec& other) { VECSubtract(this, &other, this); }\n    void operator+=(const Vec& other) { VECAdd(this, &other, this); }\n    void operator*=(f32 scale) { VECScale(this, this, scale); }\n    /* 80266C6C */ cXyz getCrossProduct(Vec const&) const;\n    /* 80266CBC */ cXyz outprod(Vec const&) const;\n    /* 80266CE4 */ cXyz norm() const;\n    /* 80266D30 */ cXyz normZP() const;\n    /* 80266DC4 */ cXyz normZC() const;\n    /* 80266EF4 */ cXyz normalize();\n    /* 80266F48 */ cXyz normalizeZP();\n    /* 80266FDC */ bool normalizeRS();\n    /* 8026702C */ bool operator==(Vec const&) const;\n    /* 8026706C */ bool operator!=(Vec const&) const;\n    /* 802670AC */ bool isZero() const;\n    /* 80267128 */ s16 atan2sX_Z() const;\n    /* 80267150 */ s16 atan2sY_XZ() const;\n\n    void set(f32 pX, f32 pY, f32 pZ) {\n        x = pX;\n        y = pY;\n        z = pZ;\n    }\n\n    void set(const Vec& other) {\n        x = other.x;\n        y = other.y;\n        z = other.z;\n    }\n\n    f32 getXDiff(const Vec* other) const { return x - other->x; }\n    f32 getYDiff(const Vec* other) const { return y - other->y; }\n    f32 getZDiff(const Vec* other) const { return z - other->z; }\n\n    void setAll(f32 f) { set(f, f, f); }\n\n    void setMin(const cXyz& other) {\n        if (x > other.x) {\n            x = other.x;\n        }\n        if (y > other.y) {\n            y = other.y;\n        }\n        if (z > other.z) {\n            z = other.z;\n        }\n    }\n\n    void setMax(const cXyz& other) {\n        if (x < other.x) {\n            x = other.x;\n        }\n        if (y < other.y) {\n            y = other.y;\n        }\n        if (z < other.z) {\n            z = other.z;\n        }\n    }\n    void zero() { set(0.0f, 0.0f, 0.0f); }\n\n    float getSquareMag() const { return VECSquareMag(this); }\n    f32 getSquareDistance(const Vec& other) const { return VECSquareDistance(this, &other); }\n\n    static float getNearZeroValue() { return 8e-11f; }\n\n    bool isNearZeroSquare() const { return (this->getSquareMag() < getNearZeroValue()); }\n    f32 abs2() const { return this->getSquareMag(); }\n    f32 abs2(const Vec& other) const { return this->getSquareDistance(other); }\n    f32 abs2XZ() const {\n        cXyz tmp(this->x, 0, this->z);\n        return tmp.abs2();\n    }\n    f32 abs2XZ(const Vec& other) const {\n        cXyz tmp(this->x, 0, this->z);\n        cXyz tmp2(other.x, 0, other.z);\n        return tmp.abs2(tmp2);\n    }\n    f32 abs() const { return sqrtf(this->abs2()); }\n    f32 abs(const Vec& other) const { return sqrtf(this->abs2(other)); }\n    f32 absXZ() const { return sqrtf(this->abs2XZ()); }\n    f32 absXZ(const Vec& other) const { return sqrtf(this->abs2XZ(other)); }\n    f32 getMagXZ() const { return cXyz(this->x, 0, this->z).getSquareMag(); }\n\n    f32 getDotProduct(const Vec& other) const { return VECDotProduct(this, &other); }\n    f32 inprod(const Vec& other) const { return getDotProduct(other); }\n};\n\n#endif /* C_XYZ_H */\n/* end \"SSystem/SComponent/c_xyz.h\" */\n\nclass cSAngle {\nprivate:\n    s16 mAngle;\n\npublic:\n    const static cSAngle _0;\n    const static cSAngle _1;\n    const static cSAngle _90;\n    const static cSAngle _180;\n    const static cSAngle _270;\n    cSAngle() {}\n    ~cSAngle() {}\n    cSAngle(const cSAngle&);\n    cSAngle(s16);\n    cSAngle(float);\n    s16 Val() const { return this->mAngle; }\n    // void Set(s16 angle) { this->mAngle = angle; }\n    void Val(const cSAngle&);\n    void Val(s16);\n    void Val(float);\n    float Degree(void) const;\n    float Radian(void) const;\n    float Norm(void) const;\n    s16 Abs(void) const;\n    s16 Inv(void) const;\n    float Sin(void) const;\n    float Cos(void) const;\n    cSAngle operator-(void) const;\n    cSAngle operator+(const cSAngle&) const;\n    cSAngle operator-(const cSAngle&) const;\n    void operator+=(const cSAngle&);\n    void operator-=(const cSAngle&);\n    cSAngle operator+(short) const;\n    cSAngle operator-(short) const;\n    void operator+=(short);\n    cSAngle operator*(float) const;\n    void operator*=(float);\n    bool operator<(const cSAngle& other) const { return mAngle < other.mAngle; }\n    bool operator>(const cSAngle& other) const { return mAngle > other.mAngle; }\n    operator s16(void) const { return mAngle; }\n    void operator=(const cSAngle& other) { mAngle = other.mAngle; }\n    static inline cSAngle getMaxNegative(void) { return cSAngle((s16)-0x8000); }\n    inline void mirrorAtMaxNeg(void) { *this = cSAngle((s16)-0x8000) - *this; }\n};\n\ncSAngle operator+(short, const cSAngle&);\ncSAngle operator-(short, const cSAngle&);\n\nstruct cAngle {\n    static f32 Radian_to_Degree(f32 rad) { return rad * 57.2957763671875f; }\n    static f32 Degree_to_Radian(f32 deg) { return deg * 0.017453292f; }\n    static s16 Degree_to_SAngle(f32 deg) { return deg * 182.04444885253906f; }\n    static f32 SAngle_to_Degree(s16 angle) { return (360.0f / 65536.0f) * angle; }\n    static f32 SAngle_to_Radian(s16 angle) { return 9.58738E-5f * angle; }\n    static f32 SAngle_to_Normal(s16 angle) { return 3.0517578E-5f * angle; }\n    static s16 Radian_to_SAngle(f32 rad) { return rad * 10430.378f; }\n\n    /* Converts Radian value into Degree value */\n    static f32 r2d(f32 r) { return Radian_to_Degree(r); }\n\n    /* Converts Degree value to s16 angle */\n    static s16 d2s(f32 d) { return Degree_to_SAngle(d); }\n\n    template <typename T>\n    static T Adjust(T f1, T f2, T f3);\n};\n\ntemplate <typename T>\nT cAngle::Adjust(T f1, T f2, T f3) {\n    while (f1 >= f3) {\n        f1 -= f3 - f2;\n    }\n    while (f1 < f2) {\n        f1 += f3 - f2;\n    }\n    return f1;\n}\n\nclass cDegree {\nprivate:\n    float mDegree;\n\npublic:\n    cDegree(float);\n    ~cDegree() {}\n\n    cDegree& Formal(void);\n    void Val(float);\n    float Radian(void) const;\n    float Sin(void) const;\n    float Cos(void) const;\n    float Tan(void) const;\n};\n\nclass cSPolar {\nprivate:\n    float mRadial;\n    cSAngle mAngle1;\n    cSAngle mAngle2;\n\npublic:\n    cSPolar() {}\n    cSPolar(const cXyz&);\n    cSPolar& Formal(void);\n    void Val(float, short, short);\n    void Val(const cXyz&);\n    cXyz Xyz(void) const;\n    void Globe(class cSGlobe*) const;\n};\n\nclass cSGlobe {\nprivate:\n    float mRadius;\n    cSAngle mAzimuth;      // original: V\n    cSAngle mInclination;  // original: U\n\npublic:\n    cSGlobe(const cSGlobe&);\n    cSGlobe(float, short, short);\n    cSGlobe(float, const cSAngle&, const cSAngle&);\n    cSGlobe(const cXyz&);\n    ~cSGlobe() {}\n    cSGlobe& Formal(void);\n    void Val(const cSGlobe&);\n    void Val(float, short, short);\n    void Val(float, const cSAngle&, const cSAngle&);\n    void Val(const cXyz&);\n    float R(void) const { return mRadius; }\n    const cSAngle& V(void) const { return mAzimuth; }\n    const cSAngle& U(void) const { return mInclination; }\n    cXyz Xyz(void) const;\n    void Polar(cSPolar*) const;\n    cXyz Norm(void) const;\n    cSGlobe& Invert(void);\n};\n\n#endif /* C_ANGLE_H */\n/* end \"SSystem/SComponent/c_angle.h\" */\n/* \"include/d/d_attention.h\" line 4 \"m_Do/m_Do_ext.h\" */\n#ifndef M_DO_M_DO_EXT_H\n#define M_DO_M_DO_EXT_H\n\n/* \"include/m_Do/m_Do_ext.h\" line 3 \"JSystem/J3DGraphAnimator/J3DAnimation.h\" */\n#ifndef J3DANIMATION_H\n#define J3DANIMATION_H\n\n/* \"include/JSystem/J3DGraphAnimator/J3DAnimation.h\" line 3 \"JSystem/J3DGraphAnimator/J3DModelData.h\" */\n#ifndef J3DMODELDATA_H\n#define J3DMODELDATA_H\n\n/* \"include/JSystem/J3DGraphAnimator/J3DModelData.h\" line 3 \"JSystem/J3DGraphAnimator/J3DJointTree.h\" */\n#ifndef J3DJOINTTREE_H\n#define J3DJOINTTREE_H\n\n/* \"include/JSystem/J3DGraphAnimator/J3DJointTree.h\" line 3 \"JSystem/J3DGraphAnimator/J3DJoint.h\" */\n#ifndef J3DJOINT_H\n#define J3DJOINT_H\n\n/* \"include/JSystem/J3DGraphAnimator/J3DJoint.h\" line 3 \"JSystem/J3DGraphBase/J3DTransform.h\" */\n#ifndef J3DTRANSFORM_H\n#define J3DTRANSFORM_H\n\n/* \"include/JSystem/J3DGraphBase/J3DTransform.h\" line 3 \"JSystem/JGeometry.h\" */\n#ifndef JGEOMETRY_H\n#define JGEOMETRY_H\n\n/* \"include/JSystem/JGeometry.h\" line 3 \"dolphin/mtx/vec.h\" */\n/* end \"dolphin/mtx/vec.h\" */\n/* \"include/JSystem/JGeometry.h\" line 4 \"math.h\" */\n/* end \"math.h\" */\n\nnamespace JGeometry {\n\ntemplate <typename T>\nstruct TVec3 {\n    T x;\n    T y;\n    T z;\n\n    void set(const TVec3& other) {\n        x = other.x;\n        y = other.y;\n        z = other.z;\n    }\n};\n\ntemplate <>\nstruct TVec3<s16> {\n    s16 x, y, z;\n\n    TVec3& operator=(const TVec3& b) {\n        // Force copies to use lwz/lha\n        *((s32*)this) = *((s32*)&b);\n        z = b.z;\n        return *this;\n    }\n\n    void set(s16 x_, s16 y_, s16 z_) {\n        x = x_;\n        y = y_;\n        z = z_;\n    }\n};\n\ninline void setTVec3f(const f32* vec_a, f32* vec_b) {\n    const register f32* v_a = vec_a;\n    register f32* v_b = vec_b;\n\n    register f32 a_x;\n    register f32 b_x;\n\n    asm {\n        psq_l a_x, 0(v_a), 0, 0\n        lfs b_x, 8(v_a)\n        psq_st a_x, 0(v_b), 0, 0\n        stfs b_x, 8(v_b)\n    };\n}\n\n// Until we figure out TVec3 ctors\ninline void setTVec3f(const Vec& vec_a, Vec& vec_b) {\n    setTVec3f(&vec_a.x, &vec_b.x);\n}\n\ninline float fsqrt_step(float mag) {\n    f32 root = __frsqrte(mag);\n    return 0.5f * root * (3.0f - mag * (root * root));\n}\n\ntemplate <>\nstruct TVec3<f32> {\n    f32 x;\n    f32 y;\n    f32 z;\n\n    // inline TVec3(const Vec& i_vec) {\n    //     setTVec3f(&i_vec.x, &x);\n    // }\n\n    // inline TVec3(const TVec3<f32>& i_vec) {\n    //     setTVec3f(&i_vec.x, &x);\n    // }\n\n    // TVec3() {}\n\n    operator Vec*() { return (Vec*)&x; }\n    operator const Vec*() const { return (Vec*)&x; }\n\n    void set(const TVec3<f32>& other) {\n        x = other.x;\n        y = other.y;\n        z = other.z;\n    }\n\n    void set(f32 x_, f32 y_, f32 z_) {\n        x = x_;\n        y = y_;\n        z = z_;\n    }\n\n    inline void add(const TVec3<f32>& b) {\n        C_VECAdd((Vec*)&x, (Vec*)&b.x, (Vec*)&x);\n    }\n\n    void zero() { x = y = z = 0.0f; }\n\n    void mul(const TVec3<f32>& a, const TVec3<f32>& b) {\n        register f32* dst = &x;\n        const register f32* srca = &a.x;\n        const register f32* srcb = &b.x;\n        register f32 a_x_y;\n        register f32 b_x_y;\n        register f32 x_y;\n        register f32 za;\n        register f32 zb;\n        register f32 z;\n        asm {\n            psq_l  a_x_y, 0(srca), 0, 0\n            psq_l  b_x_y, 0(srcb), 0, 0\n            ps_mul x_y, a_x_y, b_x_y\n            psq_st x_y, 0(dst), 0, 0\n            lfs    za,   8(srca)\n            lfs    zb,   8(srcb)\n            fmuls  z, za, zb\n            stfs   z,   8(dst)\n        };\n    }\n\n    inline TVec3<f32>& operator=(const Vec& b) {\n        setTVec3f(&b.x, &this->x);\n        return *this;\n    }\n\n    // inline TVec3<f32>& operator=(const TVec3<f32>& b) {\n    //     setTVec3f(&b.x, &this->x);\n    //     return *this;\n    // }\n\n    inline TVec3<f32>& operator+=(const TVec3<f32>& b) {\n        add(b);\n        return *this;\n    }\n\n    // inline TVec3<f32> operator+(const TVec3<f32>& b) {\n    //     TVec3<f32> res(*(Vec*)this);\n    //     res += b;\n    //     return res;\n    // }\n\n    inline TVec3<f32>& operator=(const TVec3<f32>& b) {\n        register f32* dst = &x;\n        const register f32* src = &b.x;\n        register f32 x_y;\n        register f32 z;\n        asm {\n            psq_l  x_y, 0(src), 0, 0\n            psq_st x_y, 0(dst), 0, 0\n            lfs    z,   8(src)\n            stfs   z,   8(dst)\n        };\n        return *this;\n    }\n\n    f32 squared() const {\n        return C_VECSquareMag((Vec*)&x);\n    }\n\n    void normalize() {\n        f32 sq = squared();\n        if (sq <= FLT_EPSILON * 32.0f) {\n            return;\n        }\n        f32 norm;\n        if (sq <= 0.0f) {\n            norm = sq;\n        } else {\n            norm = fsqrt_step(sq);\n        }\n        scale(norm);\n    }\n\n    void normalize(const TVec3<f32>& other) {\n        f32 sq = other.squared();\n        if (sq <= FLT_EPSILON * 32.0f) {\n            zero();\n            return;\n        }\n        f32 norm;\n        if (sq <= 0.0f) {\n            norm = sq;\n        } else {\n            norm = fsqrt_step(sq);\n        }\n        scale(norm, other);\n    }\n\n    f32 length() const {\n        return VECMag((Vec*)this);\n    }\n\n    void scale(register f32 sc) {\n        register f32 z;\n        register f32 x_y;\n        register f32* dst = &x;\n        register f32 zres;\n        asm {\n            psq_l    x_y, 0(dst),  0, 0\n            psq_l    z,   8(dst),  1, 0\n            ps_muls0 x_y,    x_y, sc\n            psq_st   x_y, 0(dst),  0, 0\n            ps_muls0 zres,       z, sc\n            psq_st   zres,  8(dst),  1, 0\n        };\n    }\n\n    void scale(register f32 sc, const TVec3<f32>& other) {\n        register const f32* src = &other.x;\n        register f32 z;\n        register f32 x_y;\n        register f32* dst = &x;\n        register f32 zres;\n        asm {\n            psq_l    x_y, 0(src),  0, 0\n            psq_l    z,   8(src),  1, 0\n            ps_muls0 x_y,    x_y, sc\n            psq_st   x_y, 0(dst),  0, 0\n            ps_muls0 zres,       z, sc\n            psq_st   zres,  8(dst),  1, 0\n        };\n    }\n\n    void negateInternal(TVec3<f32>* dst) {\n        register f32* rdst = &dst->x;\n        const register f32* src = &x;\n        register f32 x_y;\n        register f32 z;\n        asm {\n            psq_l  x_y, 0(src), 0, 0\n            ps_neg x_y, x_y\n            psq_st x_y, 0(rdst), 0, 0\n            lfs    z,   8(src)\n            fneg   z,   z\n            stfs   z,   8(rdst)\n        };\n    }\n\n    void negate() {\n        negateInternal(this);\n    }\n\n    void sub(const TVec3<f32>& b) {\n        C_VECSubtract((Vec*)&x, (Vec*)&b.x, (Vec*)&x);\n    }\n\n    void sub(const TVec3<f32>& a, const TVec3<f32>& b) {\n        C_VECSubtract((Vec*)&a.x, (Vec*)&b.x, (Vec*)&x);\n    }\n\n    bool isZero() const {\n        return squared() <= 32.0f * FLT_EPSILON;\n    }\n\n    void cross(const TVec3<f32>& a, const TVec3<f32>& b) {\n        VECCrossProduct(a, b, *this);\n    }\n    \n    void setLength(f32 len) {\n         f32 sq = squared();\n        if (sq <= FLT_EPSILON * 32.0f) {\n            return;\n        }\n        f32 norm;\n        if (sq <= 0.0f) {\n            norm = sq;\n        } else {\n            norm = fsqrt_step(sq);\n        }\n        scale(norm * len);\n    }\n\n    f32 dot(const TVec3<f32>& other) const {\n        register const f32* pThis = &x;\n        register const f32* pOther = &other.x;\n        register f32 otherReg;\n        register f32 thisyz;\n        register f32 res;\n        register f32 thisxy;\n        asm {\n            psq_l thisyz, 4(pThis), 0, 0\n            psq_l otherReg, 4(pOther), 0, 0\n            ps_mul thisyz, thisyz, otherReg\n            psq_l thisxy, 0(pThis), 0, 0\n            psq_l otherReg, 0(pOther), 0, 0\n            ps_madd res, thisxy, otherReg, thisyz\n            ps_sum0 res, res, thisyz, thisyz\n        };\n        return res;\n    }\n};\n\ntemplate <typename T>\nstruct TVec2 {\n    TVec2() {}\n    TVec2(T x, T y) { set(x, y); }\n\n    void set(T x, T y) {\n        this->x = x;\n        this->y = y;\n    }\n\n    void set(const TVec2& other) {\n        x = other.x;\n        y = other.y;\n    }\n\n    void setMin(const TVec2<f32>& min) {\n        if (x >= min.x)\n            x = min.x;\n        if (y >= min.y)\n            y = min.y;\n    }\n\n    void setMax(const TVec2<f32>& max) {\n        if (x <= max.x)\n            x = max.x;\n        if (y <= max.y)\n            y = max.y;\n    }\n\n    void add(const TVec2<T>& other) {\n        x += other.x;\n        y += other.y;\n    }\n\n    bool isAbove(const TVec2<T>& other) const {\n        return (x >= other.x) && (y >= other.y) ? true : false;\n    }\n\n    f32 dot(const TVec2<T>& other) {\n        return x * other.x + y * other.y;\n    }\n\n    f32 squared() {\n        return dot(*this);\n    }\n\n    f32 length() {\n        f32 sqr = squared();\n        if (sqr <= 0.0f) {\n            return sqr;\n        }\n        sqr *= fsqrt_step(sqr);\n        return sqr;\n    }\n\n    T x;\n    T y;\n};\n\ntemplate <class T>\nstruct TBox {\n    TBox() : i(), f() {}\n    TBox(const TBox& other) : i(other.f), f(other.y) {}\n\n    T i, f;\n};\n\n// clang-format off\ntemplate<> struct TBox<TVec2<f32> > {\n    f32 getWidth() const { return f.x - i.x; }\n    f32 getHeight() const { return f.y - i.y; }\n\n    bool isValid() const { return f.isAbove(i); }\n\n    void addPos(f32 x, f32 y) {\n        addPos(TVec2<f32>(x, y));\n    }\n\n    void addPos(const TVec2<f32>& pos) {\n        i.add(pos);\n        f.add(pos);\n    }\n\n    bool intersect(const TBox<TVec2<f32> >& other) {\n        i.setMax(other.i);\n        f.setMin(other.f);\n        return isValid();\n    }\n\n    TVec2<f32> i, f;\n};\n\ntemplate <typename T>\nstruct TBox2 : TBox<TVec2<T> > {\n    TBox2() {}\n    TBox2(const TVec2<f32>& i, const TVec2<f32>& f) { set(i, f); }\n    TBox2(f32 x0, f32 y0, f32 x1, f32 y1) { set(x0, y0, x1, y1); }\n\n    void absolute() {\n        if (!this->isValid()) {\n            TBox2<T> box(*this);\n            this->i.setMin(box.i);\n            this->i.setMin(box.f);\n            this->f.setMax(box.i);\n            this->f.setMax(box.f);\n        }\n    }\n\n    void set(const TBox2& other) { set(other.i, other.f); }\n    void set(const TVec2<f32>& i, const TVec2<f32>& f) { this->i.set(i), this->f.set(f); }\n    void set(f32 x0, f32 y0, f32 x1, f32 y1) { i.set(x0, y0); f.set(x1, y1); }\n};\n\ntemplate<typename T>\nstruct TUtil {\n    static inline T clamp(T v, T min, T max) {\n        if (v < min) {\n            return min;\n        }\n        if (v > max) {\n            return max;\n        }\n        return v;\n    }\n};\n\n// clang-format on\n\n}  // namespace JGeometry\n\n#endif\n/* end \"JSystem/JGeometry.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DTransform.h\" line 4 \"dolphin/mtx/mtxvec.h\" */\n#ifndef MTXVEC_H\n#define MTXVEC_H\n\n/* \"include/dolphin/mtx/mtxvec.h\" line 3 \"dolphin/mtx/mtx.h\" */\n#ifndef MTX_H\n#define MTX_H\n\n/* \"include/dolphin/mtx/mtx.h\" line 3 \"dolphin/mtx/mtx44.h\" */\n#ifndef MTX44_H\n#define MTX44_H\n\n/* \"include/dolphin/mtx/mtx44.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef f32 Mtx44[4][4];\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid C_MTXPerspective(Mtx44 m, f32 fovy, f32 aspect, f32 near, f32 far);\nvoid C_MTXOrtho(Mtx44 m, f32 top, f32 bottom, f32 left, f32 right, f32 near, f32 far);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* MTX44_H */\n/* end \"dolphin/mtx/mtx44.h\" */\n/* \"include/dolphin/mtx/mtx.h\" line 4 \"dolphin/mtx/quat.h\" */\n#ifndef QUAT_H\n#define QUAT_H\n\n/* \"include/dolphin/mtx/quat.h\" line 3 \"dolphin/mtx/vec.h\" */\n/* end \"dolphin/mtx/vec.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct Quaternion {\n    f32 x, y, z, w;\n} Quaternion;\n\nvoid PSQUATMultiply(const Quaternion* a, const Quaternion* b, Quaternion* ab);\nvoid C_QUATRotAxisRad(Quaternion* q, const Vec* axis, f32 rad);\nvoid C_QUATSlerp(const Quaternion* p, const Quaternion* q, Quaternion* r, f32 t);\n\n/* When compiling in debug mode, use C implementations */\n#ifdef DEBUG\n// TODO: Add debug rom C implementations\n/* #define QUATMultiply C_QUATMultiply */\n\n#define QUATMultiply PSQUATMultiply\n#else\n#define QUATMultiply PSQUATMultiply\n#endif\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* QUAT_H */\n/* end \"dolphin/mtx/quat.h\" */\n/* \"include/dolphin/mtx/mtx.h\" line 5 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef f32 Mtx[3][4];\ntypedef f32 Mtx33[3][3];\ntypedef f32 Mtx23[2][3];\ntypedef f32 (*MtxP)[4];\ntypedef f32 (*Mtx3P)[3];\ntypedef const f32 (*CMtxP)[4];  // Change name later?\n\nvoid PSMTXIdentity(Mtx m);\nvoid PSMTXCopy(const Mtx src, Mtx dst);\nvoid PSMTXConcat(const Mtx a, const Mtx b, Mtx ab);\nu32 PSMTXInverse(const Mtx src, Mtx inv);\nvoid PSMTXRotRad(Mtx m, u8 axis, f32 rad);\nvoid PSMTXRotTrig(Mtx m, u8 axis, f32 sin, f32 cos);\nf64 __PSMTXRotAxisRadInternal(f64 param_1, f64 param_2, int param_3, int param_4);\nvoid PSMTXRotAxisRad(Mtx m, const Vec* axis, f32 rad);\nvoid PSMTXTrans(Mtx m, f32 x, f32 y, f32 z);\nvoid PSMTXTransApply(const Mtx src, Mtx dst, f32 x, f32 y, f32 z);\nvoid PSMTXScale(Mtx m, f32 x, f32 y, f32 z);\nvoid PSMTXScaleApply(const Mtx src, Mtx dst, f32 x, f32 y, f32 z);\nvoid PSMTXQuat(Mtx m, const Quaternion* q);\n\nvoid C_MTXLookAt(Mtx m, const Vec* camPos, const Vec* camUp, const Vec* target);\nvoid C_MTXLightPerspective(Mtx m, f32 fovY, f32 aspect, f32 scale_s, f32 scale_t, f32 trans_s,\n                           f32 trans_t);\nvoid C_MTXLightOrtho(Mtx m, f32 top, f32 bottom, f32 left, f32 right, f32 scale_s, f32 scale_t,\n                     f32 trans_s, f32 trans_t);\n\ninline void C_MTXRotAxisRad(Mtx m, const Vec* axis, f32 rad) {\n    PSMTXRotAxisRad(m, axis, rad);\n}\n\n/* When compiling in debug mode, use C implementations */\n#ifdef DEBUG\n// TODO: Add debug rom C implementations\n/* #define MTXIdentity C_MTXIdentity\n#define MTXCopy C_MTXCopy\n#define MTXConcat C_MTXConcat\n#define MTXInverse C_MTXInverse\n#define MTXRotRad C_MTXRotRad\n#define MTXRotTrig C_MTXRotTrig\n#define MTXRotAxisRad C_MTXRotAxisRad\n#define MTXTrans C_MTXTrans\n#define MTXTransApply C_MTXTransApply\n#define MTXScale C_MTXScale\n#define MTXScaleApply C_MTXScaleApply\n#define MTXQuat C_MTXQuat */\n\n#define MTXIdentity PSMTXIdentity\n#define MTXCopy PSMTXCopy\n#define MTXConcat PSMTXConcat\n#define MTXInverse PSMTXInverse\n#define MTXRotRad PSMTXRotRad\n#define MTXRotTrig PSMTXRotTrig\n#define MTXRotAxisRad PSMTXRotAxisRad\n#define MTXTrans PSMTXTrans\n#define MTXTransApply PSMTXTransApply\n#define MTXScale PSMTXScale\n#define MTXScaleApply PSMTXScaleApply\n#define MTXQuat PSMTXQuat\n#else\n#define MTXIdentity PSMTXIdentity\n#define MTXCopy PSMTXCopy\n#define MTXConcat PSMTXConcat\n#define MTXInverse PSMTXInverse\n#define MTXRotRad PSMTXRotRad\n#define MTXRotTrig PSMTXRotTrig\n#define MTXRotAxisRad PSMTXRotAxisRad\n#define MTXTrans PSMTXTrans\n#define MTXTransApply PSMTXTransApply\n#define MTXScale PSMTXScale\n#define MTXScaleApply PSMTXScaleApply\n#define MTXQuat PSMTXQuat\n#endif\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* MTX_H */\n/* end \"dolphin/mtx/mtx.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid PSMTXMultVec(const Mtx m, const Vec* src, Vec* dst);\nvoid PSMTXMultVecSR(const Mtx m, const Vec* src, Vec* dst);\nvoid PSMTXMultVecArray(const Mtx m, const Vec* srcBase, Vec* dstBase, u32 count);\nvoid PSMTXMultVecArraySR(const Mtx m, const Vec* srcBase, Vec* dstBase, u32 count);\n\n/* When compiling in debug mode, use C implementations */\n#ifdef DEBUG\n// TODO: Add debug rom C implementations\n/* #define MTXMultVec C_MTXMultVec\n#define MTXMultVecSR C_MTXMultVecSR\n#define MTXMultVecArray C_MTXMultVecArray\n#define MTXMultVecArraySR C_MTXMultVecArraySR */\n\n#define MTXMultVec PSMTXMultVec\n#define MTXMultVecSR PSMTXMultVecSR\n#define MTXMultVecArray PSMTXMultVecArray\n#define MTXMultVecArraySR PSMTXMultVecArraySR\n#else\n#define MTXMultVec PSMTXMultVec\n#define MTXMultVecSR PSMTXMultVecSR\n#define MTXMultVecArray PSMTXMultVecArray\n#define MTXMultVecArraySR PSMTXMultVecArraySR\n#endif\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* MTXVEC_H */\n/* end \"dolphin/mtx/mtxvec.h\" */\n\nstruct J3DTextureSRTInfo;\n\nstruct J3DTransformInfo {\n    /* 0x00 */ JGeometry::TVec3<f32> mScale;\n    /* 0x0C */ JGeometry::TVec3<s16> mRotation;\n    /* 0x14 */ JGeometry::TVec3<f32> mTranslate;\n};  // Size: 0x20\n\nextern J3DTransformInfo const j3dDefaultTransformInfo;\nextern Vec const j3dDefaultScale;\nextern Mtx const j3dDefaultMtx;\nextern f32 PSMulUnit01[2];\n\nvoid J3DGQRSetup7(u32 param_0, u32 param_1, u32 param_2, u32 param_3);\nvoid J3DCalcBBoardMtx(f32 (*)[4]);\nvoid J3DCalcYBBoardMtx(f32 (*)[4]);\nvoid J3DPSCalcInverseTranspose(f32 (*param_0)[4], f32 (*param_1)[3]);\nvoid J3DGetTranslateRotateMtx(const J3DTransformInfo&, Mtx);\nvoid J3DGetTranslateRotateMtx(s16, s16, s16, f32, f32, f32, Mtx);\nvoid J3DGetTextureMtx(const J3DTextureSRTInfo&, const Vec&, f32 (*)[4]);\nvoid J3DGetTextureMtxOld(const J3DTextureSRTInfo&, const Vec&, f32 (*)[4]);\nvoid J3DGetTextureMtxMaya(const J3DTextureSRTInfo&, f32 (*)[4]);\nvoid J3DGetTextureMtxMayaOld(const J3DTextureSRTInfo& param_0, f32 (*)[4]);\nvoid J3DScaleNrmMtx(f32 (*)[4], const Vec&);\nvoid J3DScaleNrmMtx33(f32 (*)[3], const Vec&);\nvoid J3DMtxProjConcat(f32 (*)[4], f32 (*)[4], f32 (*)[4]);\nvoid J3DPSMtxArrayConcat(f32 (*)[4], f32 (*)[4], f32 (*)[4], u32);\n\ninline void J3DPSMtx33Copy(register Mtx3P src, register Mtx3P dst) {\n    register f32 fr4;\n    register f32 fr3;\n    register f32 fr2;\n    register f32 fr1;\n    register f32 fr0;\n    asm {\n        psq_l fr4, 0(src), 0, 0\n        psq_l fr3, 8(src), 0, 0\n        psq_l fr2, 0x10(src), 0, 0\n        psq_l fr1, 0x18(src), 0, 0\n        lfs fr0, 0x20(src)\n        psq_st fr4, 0(dst), 0, 0\n        psq_st fr3, 8(dst), 0, 0\n        psq_st fr2, 0x10(dst), 0, 0\n        psq_st fr1, 0x18(dst), 0, 0\n        stfs fr0, 0x20(dst)\n    }\n}\n\ninline void J3DPSMtx33CopyFrom34(register MtxP src, register Mtx3P dst) {\n    register f32 x_y1;\n    register f32 z1;\n    register f32 x_y2;\n    register f32 z2;\n    register f32 x_y3;\n    register f32 z3;\n    asm {\n        psq_l x_y1, 0(src), 0, 0\n        lfs z1, 8(src)\n        psq_l x_y2, 16(src), 0, 0\n        lfs z2, 0x18(src)\n        psq_l x_y3, 32(src), 0, 0\n        lfs z3, 0x28(src)\n        psq_st x_y1, 0(dst), 0, 0\n        stfs z1, 8(dst)\n        psq_st x_y2, 12(dst), 0, 0\n        stfs z2, 0x14(dst)\n        psq_st x_y3, 24(dst), 0, 0\n        stfs z3, 0x20(dst)\n    }\n}\n\n// regalloc issues\ninline void J3DPSMulMtxVec(register MtxP mtx, register Vec* vec, register Vec* dst) {\n    register f32 fr12;\n    register f32 fr11;\n    register f32 fr10;\n    register f32 fr9;\n    register f32 fr8;\n    register f32 fr6;\n    register f32 fra6;\n    register f32 fr5;\n    register f32 fra5;\n    register f32 fra4;\n    register f32 fr4;\n    register f32 fr3;\n    register f32 fr2;\n    register f32 fra2;\n    register f32 fr01;\n    register f32 fr00;\n    asm {\n        psq_l fr00, 0(vec), 0, 0\n    \tpsq_l fr2, 0(mtx), 0, 0\n    \tpsq_l fr01, 8(vec), 1, 0\n    \tps_mul fr4, fr2, fr00\n    \tpsq_l fr3, 8(mtx), 0, 0\n    \tps_madd fr5, fr3, fr01, fr4\n    \tpsq_l fr8, 16(mtx), 0, 0\n    \tps_sum0 fr6, fr5, fr6, fr5\n    \tpsq_l fr9, 24(mtx), 0, 0\n    \tps_mul fr10, fr8, fr00\n    \tpsq_st fr6, 0(dst), 1, 0\n    \tps_madd fr11, fr9, fr01, fr10\n    \tpsq_l fra2, 32(mtx), 0, 0\n    \tps_sum0 fr12, fr11, fr12, fr11\n    \tpsq_l fr3, 40(mtx), 0, 0\n    \tps_mul fra4, fra2, fr00\n    \tpsq_st fr12, 4(dst), 1, 0\n    \tps_madd fra5, fr3, fr01, fra4\n    \tps_sum0 fra6, fra5, fra6, fra5\n    \tpsq_st fra6, 8(dst), 1, 0\n    }\n}\n\n// regalloc issues\ninline void J3DPSMulMtxVec(register MtxP mtx, register SVec* vec, register SVec* dst) {\n    register f32 fr12;\n    register f32 fr11;\n    register f32 fr10;\n    register f32 fr9;\n    register f32 fr8;\n    register f32 fr6;\n    register f32 fra6;\n    register f32 fr5;\n    register f32 fra5;\n    register f32 fra4;\n    register f32 fr4;\n    register f32 fr3;\n    register f32 fr2;\n    register f32 fra2;\n    register f32 fr01;\n    register f32 fr00;\n    asm {\n        psq_l fr00, 0(vec), 0, 7\n    \tpsq_l fr2, 0(mtx), 0, 0\n    \tpsq_l fr01, 4(vec), 1, 7\n    \tps_mul fr4, fr2, fr00\n    \tpsq_l fr3, 8(mtx), 0, 0\n    \tps_madd fr5, fr3, fr01, fr4\n    \tpsq_l fr8, 16(mtx), 0, 0\n    \tps_sum0 fr6, fr5, fr6, fr5\n    \tpsq_l fr9, 24(mtx), 0, 0\n    \tps_mul fr10, fr8, fr00\n    \tpsq_st fr6, 0(dst), 1, 7\n    \tps_madd fr11, fr9, fr01, fr10\n    \tpsq_l fra2, 32(mtx), 0, 0\n    \tps_sum0 fr12, fr11, fr12, fr11\n    \tpsq_l fr3, 40(mtx), 0, 0\n    \tps_mul fra4, fra2, fr00\n    \tpsq_st fr12, 2(dst), 1, 7\n    \tps_madd fra5, fr3, fr01, fra4\n    \tps_sum0 fra6, fra5, fra6, fra5\n    \tpsq_st fra6, 4(dst), 1, 7\n    }\n}\n\n// regalloc issues\ninline void J3DPSMulMtxVec(register Mtx3P mtx, register Vec* vec, register Vec* dst) {\n    register f32* punit;\n    register f32 unit;\n    register f32 fr12;\n    register f32 fr11;\n    register f32 fr10;\n    register f32 fr9;\n    register f32 fr8;\n    register f32 fr6;\n    register f32 fr5;\n    register f32 fr4;\n    register f32 fr3;\n    register f32 fr2;\n    register f32 fr01;\n    register f32 fr00;\n    asm {\n        lis punit, PSMulUnit01@ha\n        psq_l fr00, 0(vec), 0, 0\n        addi punit, punit, PSMulUnit01@l\n        psq_l fr2, 0(mtx), 0, 0\n        psq_l unit, 0(punit), 0, 0\n        psq_l fr01, 8(vec), 1, 0\n        ps_add fr01, unit, fr01\n        psq_l fr3, 8(mtx), 1, 0\n        ps_mul fr4, fr2, fr00\n        psq_l fr8, 12(mtx), 0, 0\n        ps_madd fr5, fr3, fr01, fr4\n        ps_sum0 fr6, fr5, fr6, fr5\n        psq_l fr9, 20(mtx), 1, 0\n        ps_mul fr10, fr8, fr00\n        psq_st fr6, 0(dst), 1, 0\n        ps_madd fr11, fr9, fr01, fr10\n        psq_l fr2, 24(mtx), 0, 0\n        ps_sum0 fr12, fr11, fr12, fr11\n        psq_l fr3, 32(mtx), 1, 0\n        ps_mul fr4, fr2, fr00\n        psq_st fr12, 4(dst), 1, 0\n        ps_madd fr5, fr3, fr01, fr4\n        ps_sum0 fr6, fr5, fr6, fr5\n        psq_st fr6, 8(dst), 1, 0\n    }\n}\n\n// regalloc issues\ninline void J3DPSMulMtxVec(register Mtx3P mtx, register SVec* vec, register SVec* dst) {\n    register f32* punit;\n    register f32 unit;\n    register f32 fr6;\n    register f32 fr5;\n    register f32 fr4;\n    register f32 fr3;\n    register f32 fr2;\n    register f32 fr01;\n    register f32 fr00;\n    asm {\n        lis punit, PSMulUnit01@ha\n        psq_l fr00, 0(vec), 0, 7\n        addi punit, punit, PSMulUnit01@l\n        psq_l fr2, 0(mtx), 0, 0\n        psq_l unit, 0(punit), 0, 0\n        psq_l fr01, 4(vec), 1, 7\n        ps_add fr01, unit, fr01\n        psq_l fr3, 8(mtx), 1, 0\n        ps_mul fr4, fr2, fr00\n        psq_l fr2, 12(mtx), 0, 0\n        ps_madd fr5, fr3, fr01, fr4\n        ps_sum0 fr6, fr5, fr6, fr5\n        psq_l fr3, 20(mtx), 1, 0\n        ps_mul fr4, fr2, fr00\n        psq_st fr6, 0(dst), 1, 7\n        ps_madd fr5, fr3, fr01, fr4\n        psq_l fr2, 24(mtx), 0, 0\n        ps_sum0 fr6, fr5, fr6, fr5\n        psq_l fr3, 32(mtx), 1, 0\n        ps_mul fr4, fr2, fr00\n        psq_st fr6, 2(dst), 1, 7\n        ps_madd fr5, fr3, fr01, fr4\n        ps_sum0 fr6, fr5, fr6, fr5\n        psq_st fr6, 4(dst), 1, 7\n    }\n}\n\n#endif /* J3DTRANSFORM_H */\n/* end \"JSystem/J3DGraphBase/J3DTransform.h\" */\n\nclass J3DAnmTransform;\nclass J3DJoint;\nclass J3DMaterial;\nclass J3DMtxBuffer;\n\nclass J3DMtxCalc {\npublic:\n    /* 80325D1C */ static void setMtxBuffer(J3DMtxBuffer*);\n\n    /* 8000D948 */ virtual ~J3DMtxCalc();\n    /* 80014E90 */ virtual void setAnmTransform(J3DAnmTransform*);\n    /* 80014E9C */ virtual J3DAnmTransform* getAnmTransform();\n    /* 80014E8C */ virtual void setAnmTransform(u8, J3DAnmTransform*);\n    /* 80014E94 */ virtual J3DAnmTransform* getAnmTransform(u8);\n    /* 80014EA4 */ virtual void setWeight(u8, f32);\n    /* 80014EA8 */ virtual void getWeight(u8) const;\n    virtual void init(const Vec& param_0, const Mtx&) = 0;\n    virtual void calc() = 0;\n\n    static J3DMtxBuffer* getMtxBuffer() { return mMtxBuffer; }\n    static J3DJoint* getJoint() { return mJoint; }\n    static void setJoint(J3DJoint* joint) { mJoint = joint; }\n\n    static J3DMtxBuffer* mMtxBuffer;\n    static J3DJoint* mJoint;\n};  // Size: 0x4\n\nclass J3DMtxCalcNoAnmBase : public J3DMtxCalc {\npublic:\n    /* 8000FA8C */ virtual ~J3DMtxCalcNoAnmBase();\n};\n\ntemplate <class A, class B>\nclass J3DMtxCalcNoAnm : public J3DMtxCalcNoAnmBase {\npublic:\n    J3DMtxCalcNoAnm() {}\n    virtual ~J3DMtxCalcNoAnm() {}\n    virtual void init(const Vec& param_0, const Mtx& param_1);\n    virtual void calc();\n};\n\nclass J3DJoint;\ntypedef int (*J3DJointCallBack)(J3DJoint*, int);\n\nclass J3DJoint {\npublic:\n    /* 8032F13C */ void appendChild(J3DJoint*);\n    /* 8032F170 */ J3DJoint();\n    /* 8032F254 */ void entryIn();\n    /* 8032F3F8 */ void recursiveCalc();\n\n    J3DMaterial* getMesh() { return mMesh; }\n    u16 getJntNo() const { return mJntNo; }\n    u8 getScaleCompensate() const { return mScaleCompensate; }\n    J3DJoint* getYounger() { return mYounger; }\n    void setYounger(J3DJoint* pYounger) { mYounger = pYounger; }\n    void setCurrentMtxCalc(J3DMtxCalc* pMtxCalc) { mCurrentMtxCalc = pMtxCalc; }\n    J3DTransformInfo& getTransformInfo() { return mTransformInfo; }\n    Vec* getMax() { return &mMax; }\n    Vec* getMin() { return &mMin; }\n    void setCallBack(J3DJointCallBack callback) { mCallBack = callback; }\n    J3DJointCallBack getCallBack() { return mCallBack; }\n    void setMtxCalc(J3DMtxCalc* i_mtxCalc) { mMtxCalc = i_mtxCalc; }\n    J3DMtxCalc* getMtxCalc() { return mMtxCalc; }\n    J3DMtxCalc* getCurrentMtxCalc() { return mCurrentMtxCalc; };\n    J3DJoint* getChild() { return mChild; }\n    void setMtxType(u8 type) { mKind = (mKind & ~0xf0) | (type << 4); }\n\n    static J3DMtxCalc* mCurrentMtxCalc;\n\nprivate:\n    friend struct J3DJointFactory;\n    friend class J3DJointTree;\n\n    /* 0x00 */ void* mCallBackUserData;\n    /* 0x04 */ J3DJointCallBack mCallBack;\n    /* 0x08 */ void* field_0x8;\n    /* 0x0C */ J3DJoint* mChild;\n    /* 0x10 */ J3DJoint* mYounger;\n    /* 0x14 */ u16 mJntNo;\n    /* 0x16 */ u8 mKind;\n    /* 0x17 */ u8 mScaleCompensate;\n    /* 0x18 */ J3DTransformInfo mTransformInfo;\n    /* 0x38 */ f32 mBoundingSphereRadius;\n    /* 0x3C */ Vec mMin;\n    /* 0x48 */ Vec mMax;\n    /* 0x54 */ J3DMtxCalc* mMtxCalc;\n    /* 0x58 */ J3DMaterial* mMesh;\n};  // Size: 0x5C\n\nstruct J3DMtxCalcJ3DSysInitMaya {\n    /* 8032ECAC */ static void init(const Vec&, const Mtx& param_1);\n};\n\nstruct J3DMtxCalcJ3DSysInitBasic {\n    /* 8032EC28 */ static void init(const Vec&, const Mtx& param_1);\n};\n\nstruct J3DMtxCalcCalcTransformSoftimage {\n    /* 8032EE50 */ static void calcTransform(J3DTransformInfo const&);\n};\n\nstruct J3DMtxCalcCalcTransformMaya {\n    /* 8032EFBC */ static void calcTransform(J3DTransformInfo const&);\n};\n\nstruct J3DMtxCalcCalcTransformBasic {\n    /* 8032ED30 */ static void calcTransform(J3DTransformInfo const&);\n};\n\n#endif /* J3DJOINT_H */\n/* end \"JSystem/J3DGraphAnimator/J3DJoint.h\" */\n/* \"include/JSystem/J3DGraphAnimator/J3DJointTree.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass JUTNameTab;\n\nstruct J3DModelHierarchy {\n    /* 0x0 */ u16 mType;\n    /* 0x2 */ u16 mValue;\n};\n\nclass J3DMaterialTable;\n\nstruct J3DDrawMtxData {\n    /* 803115E0 */ J3DDrawMtxData();\n    /* 803115F4 */ ~J3DDrawMtxData();\n\n    /* 0x0 */ u16 mEntryNum;\n    /* 0x2 */ u16 mDrawFullWgtMtxNum;\n    /* 0x4 */ u8* mDrawMtxFlag;\n    /* 0x8 */ u16* mDrawMtxIndex;\n};  // Size: 0xC\n\nclass J3DShapeTable;\n\nclass J3DJointTree {\npublic:\n    /* 80325A18 */ J3DJointTree();\n    /* 80325A9C */ void makeHierarchy(J3DJoint*, J3DModelHierarchy const**, J3DMaterialTable*,\n                                      J3DShapeTable*);\n    /* 80325C00 */ void findImportantMtxIndex();\n\n    /* 80325CAC */ virtual void calc(J3DMtxBuffer*, Vec const&, f32 const (&)[3][4]);\n    /* 80325D24 */ virtual ~J3DJointTree();\n\n    J3DModelHierarchy const* getHierarchy() { return mHierarchy; }\n    void setHierarchy(J3DModelHierarchy* hierarchy) { mHierarchy = hierarchy; }\n    void setBasicMtxCalc(J3DMtxCalc* calc) { mBasicMtxCalc = calc; }\n    u16 getWEvlpMtxNum() const { return mWEvlpMtxNum; }\n    u8 getWEvlpMixMtxNum(u16 idx) const { return mWEvlpMixMtxNum[idx]; }\n    u16 * getWEvlpMixIndex() const { return mWEvlpMixIndex; }\n    f32 * getWEvlpMixWeight() const { return mWEvlpMixWeight; }\n    u16 * getWEvlpImportantMtxIndex() const { return mWEvlpImportantMtxIdx; }\n    u16 getDrawFullWgtMtxNum() const { return mDrawMtxData.mDrawFullWgtMtxNum; }\n    u16 getJointNum() const { return mJointNum; }\n    u16 getDrawMtxNum() const { return mDrawMtxData.mEntryNum; }\n    u8 getDrawMtxFlag(u16 idx) const { return mDrawMtxData.mDrawMtxFlag[idx]; }\n    u16 getDrawMtxIndex(u16 idx) const { return mDrawMtxData.mDrawMtxIndex[idx]; }\n    J3DDrawMtxData* getDrawMtxData() { return &mDrawMtxData; }\n    JUTNameTab* getJointName() const { return mJointName; }\n    J3DJoint* getRootNode() { return mRootNode; }\n    J3DJoint* getJointNodePointer(u16 idx) const { return mJointNodePointer[idx]; }\n    J3DMtxCalc* getBasicMtxCalc() const { return mBasicMtxCalc; }\n    Mtx& getInvJointMtx(s32 idx) const { return mInvJointMtx[idx]; }\n    u32 getModelDataType() const { return mModelDataType; }\n    void setModelDataType(u32 type) { mModelDataType = type; }\n    bool checkFlag(u32 flag) { return mFlags & flag; }\n    void setFlag(u32 flag) { mFlags = flag; }\n\nprivate:\n    friend class J3DModelLoader;\n    \n    /* 0x04 */ J3DModelHierarchy* mHierarchy;\n    /* 0x08 */ u32 mFlags;\n    /* 0x0C */ u32 mModelDataType;\n    /* 0x10 */ J3DJoint* mRootNode;\n    /* 0x14 */ J3DMtxCalc* mBasicMtxCalc;\n    /* 0x18 */ J3DJoint** mJointNodePointer;\n    /* 0x1C */ u16 mJointNum;\n    /* 0x1E */ u16 mWEvlpMtxNum;\n    /* 0x20 */ u8* mWEvlpMixMtxNum;\n    /* 0x24 */ u16* mWEvlpMixIndex;\n    /* 0x28 */ f32* mWEvlpMixWeight;\n    /* 0x2C */ Mtx* mInvJointMtx;\n    /* 0x30 */ u16* mWEvlpImportantMtxIdx;\n    /* 0x34 */ J3DDrawMtxData mDrawMtxData;\n    /* 0x40 */ u32 field_0x40;\n    /* 0x44 */ JUTNameTab* mJointName;\n};  // Size: 0x48\n\n#endif /* J3DJOINTTREE_H */\n/* end \"JSystem/J3DGraphAnimator/J3DJointTree.h\" */\n/* \"include/JSystem/J3DGraphAnimator/J3DModelData.h\" line 4 \"JSystem/J3DGraphAnimator/J3DMaterialAttach.h\" */\n#ifndef J3DMATERIALATTACH_H\n#define J3DMATERIALATTACH_H\n\n/* \"include/JSystem/J3DGraphAnimator/J3DMaterialAttach.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass J3DMaterial;\nclass J3DTexture;\nclass J3DAnmColor;\nclass J3DAnmTexPattern;\nclass J3DAnmTextureSRTKey;\nclass J3DAnmTevRegKey;\nclass JUTNameTab;\n\nclass J3DMaterialTable {\npublic:\n    /* 8032F5A8 */ void clear();\n    /* 8032F5D0 */ J3DMaterialTable();\n    /* 8032F64C */ int removeMatColorAnimator(J3DAnmColor*);\n    /* 8032F6F8 */ int removeTexNoAnimator(J3DAnmTexPattern*);\n    /* 8032F7B4 */ int removeTexMtxAnimator(J3DAnmTextureSRTKey*);\n    /* 8032F880 */ int removeTevRegAnimator(J3DAnmTevRegKey*);\n    /* 8032F9C0 */ void createTexMtxForAnimator(J3DAnmTextureSRTKey*);\n    /* 8032FAF4 */ void entryMatColorAnimator(J3DAnmColor*);\n    /* 8032FBC8 */ void entryTexNoAnimator(J3DAnmTexPattern*);\n    /* 8032FCC4 */ void entryTexMtxAnimator(J3DAnmTextureSRTKey*);\n    /* 8032FE70 */ void entryTevRegAnimator(J3DAnmTevRegKey*);\n\n    /* 8032F604 */ virtual ~J3DMaterialTable();\n\n    J3DMaterial* getMaterialNodePointer(u16 idx) const { return mMaterialNodePointer[idx]; }\n\n    J3DTexture* getTexture() const { return mTexture; }\n    JUTNameTab* getTextureName() const { return mTextureName; }\n\n    JUTNameTab* getMaterialName() const { return mMaterialName; }\n\n    u16 getMaterialNum() const { return mMaterialNum; }\n    bool isLocked() const { return field_0x1c == 1; }\n\nprivate:\n    friend class J3DModelLoader;\n    friend class J3DModelLoader_v26;\n    friend class J3DModelLoader_v21;\n\n    /* 0x04 */ u16 mMaterialNum;\n    /* 0x06 */ u16 mUniqueMatNum;\n    /* 0x08 */ J3DMaterial** mMaterialNodePointer;\n    /* 0x0C */ JUTNameTab* mMaterialName;\n    /* 0x10 */ J3DMaterial* field_0x10;\n    /* 0x14 */ J3DTexture* mTexture;\n    /* 0x18 */ JUTNameTab* mTextureName;\n    /* 0x1C */ u16 field_0x1c;\n};  // Size: 0x20\n\n#endif /* J3DMATERIALATTACH_H */\n/* end \"JSystem/J3DGraphAnimator/J3DMaterialAttach.h\" */\n/* \"include/JSystem/J3DGraphAnimator/J3DModelData.h\" line 5 \"JSystem/J3DGraphAnimator/J3DShapeTable.h\" */\n#ifndef J3DSHAPETABLE_H\n#define J3DSHAPETABLE_H\n\n/* \"include/JSystem/J3DGraphAnimator/J3DShapeTable.h\" line 3 \"JSystem/J3DGraphBase/J3DShape.h\" */\n#ifndef J3DSHAPE_H\n#define J3DSHAPE_H\n\n/* \"include/JSystem/J3DGraphBase/J3DShape.h\" line 3 \"JSystem/J3DGraphBase/J3DShapeDraw.h\" */\n#ifndef J3DSHAPEDRAW_H\n#define J3DSHAPEDRAW_H\n\n/* \"include/JSystem/J3DGraphBase/J3DShapeDraw.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass J3DShapeDraw {\npublic:\n    /* 80314924 */ u32 countVertex(u32);\n    /* 80314974 */ void addTexMtxIndexInDL(u32, u32, u32);\n    /* 80314ABC */ J3DShapeDraw(u8 const*, u32);\n    /* 80314AD4 */ void draw() const;\n\n    /* 80314B00 */ virtual ~J3DShapeDraw();\n\n    u8* getDisplayList() const { return (u8*)mDisplayList; }\n    u32 getDisplayListSize() const { return mDisplayListSize; }\n    void setDisplayListSize(u32 size) { mDisplayListSize = size; }\n\nprivate:\n    /* 0x04 */ u32 mDisplayListSize;\n    /* 0x08 */ void* mDisplayList;\n};\n\n#endif /* J3DSHAPEDRAW_H */\n/* end \"JSystem/J3DGraphBase/J3DShapeDraw.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DShape.h\" line 4 \"JSystem/J3DGraphBase/J3DShapeMtx.h\" */\n#ifndef J3DSHAPEMTX_H\n#define J3DSHAPEMTX_H\n\n/* \"include/JSystem/J3DGraphBase/J3DShapeMtx.h\" line 3 \"dolphin/mtx/mtxvec.h\" */\n/* end \"dolphin/mtx/mtxvec.h\" */\n\nclass J3DTexMtx;\nclass J3DTexGenBlock;\n\nclass J3DTexMtxObj {\npublic:\n    Mtx& getMtx(u16 idx) { return mpTexMtx[idx]; }\n    Mtx44& getEffectMtx(u16 idx) { return mpEffectMtx[idx]; }\n    u16 getNumTexMtx() { return mTexMtxNum; }\n\n    /* 0x00 */ Mtx* mpTexMtx;\n    /* 0x04 */ Mtx44* mpEffectMtx;\n    /* 0x08 */ u16 mTexMtxNum;\n};\n\nclass J3DDifferedTexMtx {\npublic:\n    /* 8031322C */ static void loadExecute(f32 const (*)[4]);\n\n    static inline void load(Mtx m) {\n        if (sTexGenBlock != NULL)\n            loadExecute(m);\n    }\n\n    static J3DTexGenBlock* sTexGenBlock;\n    static J3DTexMtxObj* sTexMtxObj;\n};\n\nclass J3DShapeMtx;\ntypedef void (J3DShapeMtx::*J3DShapeMtx_LoadFunc)(int, u16) const;\n\nclass J3DShapeMtx {\npublic:\n    J3DShapeMtx(u16 useMtxIndex)\n        : mUseMtxIndex(useMtxIndex)\n    {}\n\n    /* 803130E4 */ void loadMtxIndx_PNGP(int, u16) const;\n    /* 80313128 */ void loadMtxIndx_PCPU(int, u16) const;\n    /* 80313188 */ void loadMtxIndx_NCPU(int, u16) const;\n    /* 803131D4 */ void loadMtxIndx_PNCPU(int, u16) const;\n\n    /* 80314798 */ virtual ~J3DShapeMtx() {}\n    /* 803147E0 */ virtual u32 getType() const { return 'SMTX'; }\n    /* 80273E08 */ virtual u32 getUseMtxNum() const { return 1; }\n    /* 8031459C */ virtual u32 getUseMtxIndex(u16) const { return mUseMtxIndex; }\n    /* 80313B94 */ virtual void load() const;\n    /* 80313BF0 */ virtual void calcNBTScale(Vec const&, f32 (*)[3][3], f32 (*)[3][3]);\n\n    static J3DShapeMtx_LoadFunc sMtxLoadPipeline[4];\n    static u16 sMtxLoadCache[10 + 2 /* padding */];\n    static u32 sCurrentPipeline;\n    static u8* sCurrentScaleFlag;\n    static u8 sNBTFlag;\n    static u8 sLODFlag;\n    static u32 sTexMtxLoadType;\n\n    static void setCurrentPipeline(u32 pipeline) { sCurrentPipeline = pipeline; }\n    static void setLODFlag(u8 flag) { sLODFlag = flag; }\n    static u8 getLODFlag() { return sLODFlag; }\n    static void resetMtxLoadCache();\n\nprotected:\n    /* 0x04 */ u16 mUseMtxIndex;\n};\n\nclass J3DShapeMtxConcatView;\ntypedef void (J3DShapeMtxConcatView::*J3DShapeMtxConcatView_LoadFunc)(int, u16) const;\n\nclass J3DShapeMtxConcatView : public J3DShapeMtx {\npublic:\n    J3DShapeMtxConcatView(u16 useMtxIndex)\n        : J3DShapeMtx(useMtxIndex)\n    {}\n\n    /* 80314730 */ virtual ~J3DShapeMtxConcatView() {}\n    /* 803147E0 */ virtual u32 getType() const { return 'SMCV'; }\n    /* 80313C54 */ virtual void load() const;\n    /* 80314598 */ virtual void loadNrmMtx(int, u16) const {}\n    /* 80313D28 */ virtual void loadNrmMtx(int, u16, f32 (*)[4]) const;\n\n    /* 80313828 */ void loadMtxConcatView_PNGP(int, u16) const;\n    /* 803138C8 */ void loadMtxConcatView_PCPU(int, u16) const;\n    /* 8031396C */ void loadMtxConcatView_NCPU(int, u16) const;\n    /* 80313A14 */ void loadMtxConcatView_PNCPU(int, u16) const;\n    /* 80313AC8 */ void loadMtxConcatView_PNGP_LOD(int, u16) const;\n\n    static J3DShapeMtxConcatView_LoadFunc sMtxLoadPipeline[4];\n    static J3DShapeMtxConcatView_LoadFunc sMtxLoadLODPipeline[4];\n    static MtxP sMtxPtrTbl[2];\n};\n\nclass J3DShapeMtxYBBoardConcatView : public J3DShapeMtxConcatView {\npublic:\n    J3DShapeMtxYBBoardConcatView(u16 useMtxIndex)\n        : J3DShapeMtxConcatView(useMtxIndex)\n    {}\n\n    /* 80314520 */ virtual ~J3DShapeMtxYBBoardConcatView() {}\n    /* 803147E0 */ virtual u32 getType() const { return 'SMYB'; }\n    /* 803143E4 */ virtual void load() const;\n};\n\nclass J3DShapeMtxBBoardConcatView : public J3DShapeMtxConcatView {\npublic:\n    J3DShapeMtxBBoardConcatView(u16 useMtxIndex)\n        : J3DShapeMtxConcatView(useMtxIndex)\n    {}\n\n    /* 803145A4 */ virtual ~J3DShapeMtxBBoardConcatView() {}\n    /* 803147E0 */ virtual u32 getType() const { return 'SMBB'; }\n    /* 803142D4 */ virtual void load() const;\n};\n\nclass J3DShapeMtxMulti : public J3DShapeMtx {\npublic:\n    J3DShapeMtxMulti(u16 useMtxIndex, u16 useMtxNum, u16* useMtxIndexTable)\n        : J3DShapeMtx(useMtxIndex)\n        , mUseMtxNum(useMtxNum)\n        , mUseMtxIndexTable(useMtxIndexTable)\n    {}\n\n    /* 803146B0 */ virtual ~J3DShapeMtxMulti() {}\n    /* 803147E0 */ virtual u32 getType() const { return 'SMML'; }\n    /* 80273E08 */ virtual u32 getUseMtxNum() const { return mUseMtxNum; }\n    /* 8031459C */ virtual u32 getUseMtxIndex(u16 no) const { return mUseMtxIndexTable[no]; }\n    /* 80313E4C */ virtual void load() const;\n    /* 80313EEC */ virtual void calcNBTScale(Vec const&, f32 (*)[3][3], f32 (*)[3][3]);\n\nprivate:\n    /* 0x8 */ u16 mUseMtxNum;\n    /* 0xC */ u16* mUseMtxIndexTable;\n};\n\nclass J3DShapeMtxMultiConcatView : public J3DShapeMtxConcatView {\npublic:\n    J3DShapeMtxMultiConcatView(u16 useMtxIndex, u16 useMtxNum, u16* useMtxIndexTable)\n        : J3DShapeMtxConcatView(useMtxIndex)\n        , mUseMtxNum(useMtxNum)\n        , mUseMtxIndexTable(useMtxIndexTable)\n    {}\n\n    /* 8031461C */ virtual ~J3DShapeMtxMultiConcatView() {}\n    /* 803147E0 */ virtual u32 getType() const { return 'SMMC'; }\n    /* 80273E08 */ virtual u32 getUseMtxNum() const { return mUseMtxNum; }\n    /* 8031459C */ virtual u32 getUseMtxIndex(u16 no) const { return mUseMtxIndexTable[no]; }\n    /* 80313FA4 */ virtual void load() const;\n    /* 803146AC */ virtual void loadNrmMtx(int, u16) const {}\n    /* 8031419C */ virtual void loadNrmMtx(int, u16, f32 (*)[4]) const;\n\nprivate:\n    /* 0x8 */ u16 mUseMtxNum;\n    /* 0xC */ u16* mUseMtxIndexTable;\n};\n\n#endif /* J3DSHAPEMTX_H *//* end \"JSystem/J3DGraphBase/J3DShapeMtx.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DShape.h\" line 5 \"dolphin/gx/GX.h\" */\n#ifndef GX_H_\n#define GX_H_\n\n/* \"include/dolphin/gx/GX.h\" line 3 \"dolphin/gx/GXAttr.h\" */\n#ifndef GXATTR_H\n#define GXATTR_H\n\n/* \"include/dolphin/gx/GXAttr.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n#ifndef GXENUM_H\n#define GXENUM_H\n\n/* \"include/dolphin/gx/GXEnum.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef enum _GXPrimitive {\n    /* 0x80 */ GX_QUADS = 0x80,\n    /* 0x90 */ GX_TRIANGLES = 0x90,\n    /* 0x98 */ GX_TRIANGLESTRIP = 0x98,\n    /* 0xA0 */ GX_TRIANGLEFAN = 0xA0,\n    /* 0xA8 */ GX_LINES = 0xA8,\n    /* 0xB0 */ GX_LINESTRIP = 0xB0,\n    /* 0xB8 */ GX_POINTS = 0xB8,\n} GXPrimitive;\n\ntypedef enum _GXCullMode {\n    /* 0x0 */ GX_CULL_NONE,\n    /* 0x1 */ GX_CULL_FRONT,\n    /* 0x2 */ GX_CULL_BACK,\n    /* 0x3 */ GX_CULL_ALL\n} GXCullMode;\n\ntypedef enum _GXBoolVal {\n    /* 0x0 */ GX_FALSE,\n    /* 0x1 */ GX_TRUE,\n    /* 0x0 */ GX_DISABLE = 0,\n    /* 0x1 */ GX_ENABLE\n} GXBoolVal;\n\ntypedef u8 GXBool;\n\ntypedef enum _GXTexMapID {\n    /* 0x000 */ GX_TEXMAP0,\n    /* 0x001 */ GX_TEXMAP1,\n    /* 0x002 */ GX_TEXMAP2,\n    /* 0x003 */ GX_TEXMAP3,\n    /* 0x004 */ GX_TEXMAP4,\n    /* 0x005 */ GX_TEXMAP5,\n    /* 0x006 */ GX_TEXMAP6,\n    /* 0x007 */ GX_TEXMAP7,\n    /* 0x008 */ GX_MAX_TEXMAP,\n    /* 0x0FF */ GX_TEXMAP_NULL = 255,\n    /* 0x100 */ GX_TEXMAP_DISABLE,\n} GXTexMapID;\n\ntypedef enum _GXTevStageID {\n    /* 0x00 */ GX_TEVSTAGE0,\n    /* 0x01 */ GX_TEVSTAGE1,\n    /* 0x02 */ GX_TEVSTAGE2,\n    /* 0x03 */ GX_TEVSTAGE3,\n    /* 0x04 */ GX_TEVSTAGE4,\n    /* 0x05 */ GX_TEVSTAGE5,\n    /* 0x06 */ GX_TEVSTAGE6,\n    /* 0x07 */ GX_TEVSTAGE7,\n    /* 0x08 */ GX_TEVSTAGE8,\n    /* 0x09 */ GX_TEVSTAGE9,\n    /* 0x0A */ GX_TEVSTAGE10,\n    /* 0x0B */ GX_TEVSTAGE11,\n    /* 0x0C */ GX_TEVSTAGE12,\n    /* 0x0D */ GX_TEVSTAGE13,\n    /* 0x0E */ GX_TEVSTAGE14,\n    /* 0x0F */ GX_TEVSTAGE15,\n    /* 0x10 */ GX_MAX_TEVSTAGE,\n} GXTevStageID;\n\ntypedef enum _GXTexCoordID {\n    /* 0x00 */ GX_TEXCOORD0,\n    /* 0x01 */ GX_TEXCOORD1,\n    /* 0x02 */ GX_TEXCOORD2,\n    /* 0x03 */ GX_TEXCOORD3,\n    /* 0x04 */ GX_TEXCOORD4,\n    /* 0x05 */ GX_TEXCOORD5,\n    /* 0x06 */ GX_TEXCOORD6,\n    /* 0x07 */ GX_TEXCOORD7,\n    /* 0x08 */ GX_MAXCOORD,\n    /* 0xFF */ GX_TEXCOORD_NULL = 255,\n} GXTexCoordID;\n\ntypedef enum _GXChannelID {\n    /* 0x00 */ GX_COLOR0,\n    /* 0x01 */ GX_COLOR1,\n    /* 0x02 */ GX_ALPHA0,\n    /* 0x03 */ GX_ALPHA1,\n    /* 0x04 */ GX_COLOR0A0,\n    /* 0x05 */ GX_COLOR1A1,\n    /* 0x06 */ GX_COLOR_ZERO,\n    /* 0x07 */ GX_ALPHA_BUMP,\n    /* 0x08 */ GX_ALPHA_BUMPN,\n    /* 0xFF */ GX_COLOR_NULL = 255,\n} GXChannelID;\n\ntypedef enum _GXColorSrc {\n    /* 0x0 */ GX_SRC_REG,\n    /* 0x1 */ GX_SRC_VTX,\n} GXColorSrc;\n\ntypedef enum _GXLightID {\n    /* 0x000 */ GX_LIGHT_NULL = 0,\n    /* 0x001 */ GX_LIGHT0 = 1 << 0,\n    /* 0x002 */ GX_LIGHT1 = 1 << 1,\n    /* 0x004 */ GX_LIGHT2 = 1 << 2,\n    /* 0x008 */ GX_LIGHT3 = 1 << 3,\n    /* 0x010 */ GX_LIGHT4 = 1 << 4,\n    /* 0x020 */ GX_LIGHT5 = 1 << 5,\n    /* 0x040 */ GX_LIGHT6 = 1 << 6,\n    /* 0x080 */ GX_LIGHT7 = 1 << 7,\n    /* 0x100 */ GX_MAX_LIGHT = 1 << 8,\n} GXLightID;\n\ntypedef enum _GXDiffuseFn {\n    /* 0x0 */ GX_DF_NONE,\n    /* 0x1 */ GX_DF_SIGN,\n    /* 0x2 */ GX_DF_CLAMP,\n} GXDiffuseFn;\n\ntypedef enum _GXAttnFn {\n    /* 0x0 */ GX_AF_SPEC,\n    /* 0x1 */ GX_AF_SPOT,\n    /* 0x2 */ GX_AF_NONE,\n} GXAttnFn;\n\ntypedef enum _GXDistAttnFn {\n    /* 0x0 */ GX_DA_OFF,\n    /* 0x1 */ GX_DA_GENTLE,\n    /* 0x2 */ GX_DA_MEDIUM,\n    /* 0x3 */ GX_DA_STEEP\n} GXDistAttnFn;\n\ntypedef enum _GXSpotFn {\n    /* 0x0 */ GX_SP_OFF,\n    /* 0x1 */ GX_SP_FLAT,\n    /* 0x2 */ GX_SP_COS,\n    /* 0x3 */ GX_SP_COS2,\n    /* 0x4 */ GX_SP_SHARP,\n    /* 0x5 */ GX_SP_RING1,\n    /* 0x6 */ GX_SP_RING2\n} GXSpotFn;\n\ntypedef enum _GXTevMode {\n    /* 0x0 */ GX_MODULATE,\n    /* 0x1 */ GX_DECAL,\n    /* 0x2 */ GX_BLEND,\n    /* 0x3 */ GX_REPLACE,\n    /* 0x4 */ GX_PASSCLR,\n} GXTevMode;\n\ntypedef enum _GXBlendMode {\n    /* 0x0 */ GX_BM_NONE,\n    /* 0x1 */ GX_BM_BLEND,\n    /* 0x2 */ GX_BM_LOGIC,\n    /* 0x3 */ GX_BM_SUBTRACT,\n    /* 0x4 */ GX_MAX_BLENDMODE,\n} GXBlendMode;\n\ntypedef enum _GXBlendFactor {\n    /* 0x0 */ GX_BL_ZERO,\n    /* 0x1 */ GX_BL_ONE,\n    /* 0x2 */ GX_BL_SRC_COLOR,\n    /* 0x2 */ GX_BL_DST_COLOR = 2,\n    /* 0x3 */ GX_BL_INV_SRC_COLOR,\n    /* 0x3 */ GX_BL_INV_DST_COLOR = 3,\n    /* 0x4 */ GX_BL_SRC_ALPHA,\n    /* 0x5 */ GX_BL_INV_SRC_ALPHA,\n    /* 0x6 */ GX_BL_DST_ALPHA,\n    /* 0x7 */ GX_BL_INV_DST_ALPHA,\n} GXBlendFactor;\n\ntypedef enum _GXLogicOp {\n    /* 0x0 */ GX_LO_CLEAR,\n    /* 0x1 */ GX_LO_AND,\n    /* 0x2 */ GX_LO_REV_AND,\n    /* 0x3 */ GX_LO_COPY,\n    /* 0x4 */ GX_LO_INV_AND,\n    /* 0x5 */ GX_LO_NOOP,\n    /* 0x6 */ GX_LO_XOR,\n    /* 0x7 */ GX_LO_OR,\n    /* 0x8 */ GX_LO_NOR,\n    /* 0x9 */ GX_LO_EQUIV,\n    /* 0xA */ GX_LO_INV,\n    /* 0xB */ GX_LO_REV_OR,\n    /* 0xC */ GX_LO_INV_COPY,\n    /* 0xD */ GX_LO_INV_OR,\n    /* 0xE */ GX_LO_NAND,\n    /* 0xF */ GX_LO_SET,\n} GXLogicOp;\n\ntypedef enum _GXVtxFmt {\n    /* 0x0 */ GX_VTXFMT0,\n    /* 0x1 */ GX_VTXFMT1,\n    /* 0x2 */ GX_VTXFMT2,\n    /* 0x3 */ GX_VTXFMT3,\n    /* 0x4 */ GX_VTXFMT4,\n    /* 0x5 */ GX_VTXFMT5,\n    /* 0x6 */ GX_VTXFMT6,\n    /* 0x7 */ GX_VTXFMT7,\n    /* 0x8 */ GX_MAX_VTXFMT,\n} GXVtxFmt;\n\ntypedef enum _GXAttr {\n    /* 0x00 */ GX_VA_PNMTXIDX,\n    /* 0x01 */ GX_VA_TEX0MTXIDX,\n    /* 0x02 */ GX_VA_TEX1MTXIDX,\n    /* 0x03 */ GX_VA_TEX2MTXIDX,\n    /* 0x04 */ GX_VA_TEX3MTXIDX,\n    /* 0x05 */ GX_VA_TEX4MTXIDX,\n    /* 0x06 */ GX_VA_TEX5MTXIDX,\n    /* 0x07 */ GX_VA_TEX6MTXIDX,\n    /* 0x08 */ GX_VA_TEX7MTXIDX,\n    /* 0x09 */ GX_VA_POS,\n    /* 0x0A */ GX_VA_NRM,\n    /* 0x0B */ GX_VA_CLR0,\n    /* 0x0C */ GX_VA_CLR1,\n    /* 0x0D */ GX_VA_TEX0,\n    /* 0x0E */ GX_VA_TEX1,\n    /* 0x0F */ GX_VA_TEX2,\n    /* 0x10 */ GX_VA_TEX3,\n    /* 0x11 */ GX_VA_TEX4,\n    /* 0x12 */ GX_VA_TEX5,\n    /* 0x13 */ GX_VA_TEX6,\n    /* 0x14 */ GX_VA_TEX7,\n    /* 0x15 */ GX_POS_MTX_ARRAY,\n    /* 0x16 */ GX_NRM_MTX_ARRAY,\n    /* 0x17 */ GX_TEX_MTX_ARRAY,\n    /* 0x18 */ GX_LIGHT_ARRAY,\n    /* 0x19 */ GX_VA_NBT,\n    /* 0x1A */ GX_VA_MAX_ATTR,\n    /* 0xFF */ GX_VA_NULL = 255,\n} GXAttr;\n\ntypedef enum _GXCompCnt {\n    /* 0x0 */ GX_POS_XY = 0,\n    /* 0x1 */ GX_POS_XYZ = 1,\n    /* 0x0 */ GX_NRM_XYZ = 0,\n    /* 0x1 */ GX_NRM_NBT = 1,\n    /* 0x2 */ GX_NRM_NBT3 = 2,\n    /* 0x0 */ GX_CLR_RGB = 0,\n    /* 0x1 */ GX_CLR_RGBA = 1,\n    /* 0x0 */ GX_TEX_S = 0,\n    /* 0x1 */ GX_TEX_ST = 1,\n} GXCompCnt;\n\ntypedef enum _GXCompType {\n    /* 0x0 */ GX_U8,\n    /* 0x1 */ GX_S8,\n    /* 0x2 */ GX_U16,\n    /* 0x3 */ GX_S16,\n    /* 0x4 */ GX_F32,\n    /* 0x0 */ GX_RGB565 = 0,\n    /* 0x1 */ GX_RGB8,\n    /* 0x2 */ GX_RGBX8,\n    /* 0x3 */ GX_RGBA4,\n    /* 0x4 */ GX_RGBA6,\n    /* 0x5 */ GX_RGBA8,\n} GXCompType;\n\ntypedef enum _GXAttrType {\n    /* 0x0 */ GX_NONE,\n    /* 0x1 */ GX_DIRECT,\n    /* 0x2 */ GX_INDEX8,\n    /* 0x3 */ GX_INDEX16,\n} GXAttrType;\n\ntypedef enum _GXTevOp {\n    /* 0x0 */ GX_TEV_ADD,\n    /* 0x1 */ GX_TEV_SUB,\n    /* 0x8 */ GX_TEV_COMP_R8_GT = 8,\n    /* 0x9 */ GX_TEV_COMP_R8_EQ,\n    /* 0xA */ GX_TEV_COMP_GR16_GT,\n    /* 0xB */ GX_TEV_COMP_GR16_EQ,\n    /* 0xC */ GX_TEV_COMP_BGR24_GT,\n    /* 0xD */ GX_TEV_COMP_BGR24_EQ,\n    /* 0xE */ GX_TEV_COMP_A8_GT,\n    /* 0xE */ GX_TEV_COMP_RGB8_GT = 14,\n    /* 0xF */ GX_TEV_COMP_RGB8_EQ,\n    /* 0xF */ GX_TEV_COMP_A8_EQ = 15,\n} GXTevOp;\n\ntypedef enum _GXTevBias {\n    /* 0x0 */ GX_TB_ZERO,\n    /* 0x1 */ GX_TB_ADDHALF,\n    /* 0x2 */ GX_TB_SUBHALF,\n    /* 0x3 */ GX_MAX_TEVBIAS,\n} GXTevBias;\n\ntypedef enum _GXTevColorArg {\n    /* 0x0 */ GX_CC_CPREV,\n    /* 0x1 */ GX_CC_APREV,\n    /* 0x2 */ GX_CC_C0,\n    /* 0x3 */ GX_CC_A0,\n    /* 0x4 */ GX_CC_C1,\n    /* 0x5 */ GX_CC_A1,\n    /* 0x6 */ GX_CC_C2,\n    /* 0x7 */ GX_CC_A2,\n    /* 0x8 */ GX_CC_TEXC,\n    /* 0x9 */ GX_CC_TEXA,\n    /* 0xA */ GX_CC_RASC,\n    /* 0xB */ GX_CC_RASA,\n    /* 0xC */ GX_CC_ONE,\n    /* 0xD */ GX_CC_HALF,\n    /* 0xE */ GX_CC_KONST,\n    /* 0xF */ GX_CC_ZERO,\n} GXTevColorArg;\n\ntypedef enum _GXTevColor {\n    /* 0x0 */ GX_CH_RED,\n    /* 0x1 */ GX_CH_GREEN,\n    /* 0x2 */ GX_CH_BLUE,\n    /* 0x3 */ GX_CH_ALPHA,\n} GXTevColor;\n\ntypedef enum _GXTevScale {\n    /* 0x0 */ GX_CS_SCALE_1,\n    /* 0x1 */ GX_CS_SCALE_2,\n    /* 0x2 */ GX_CS_SCALE_4,\n    /* 0x3 */ GX_CS_DIVIDE_2,\n    /* 0x4 */ GX_MAX_TEVSCALE\n} GXTevScale;\n\ntypedef enum _GXTevRegID {\n    /* 0x0 */ GX_TEVPREV,\n    /* 0x1 */ GX_TEVREG0,\n    /* 0x2 */ GX_TEVREG1,\n    /* 0x3 */ GX_TEVREG2,\n    /* 0x4 */ GX_MAX_TEVREG\n} GXTevRegID;\n\ntypedef enum _GXTevAlphaArg {\n    /* 0x0 */ GX_CA_APREV,\n    /* 0x1 */ GX_CA_A0,\n    /* 0x2 */ GX_CA_A1,\n    /* 0x3 */ GX_CA_A2,\n    /* 0x4 */ GX_CA_TEXA,\n    /* 0x5 */ GX_CA_RASA,\n    /* 0x6 */ GX_CA_KONST,\n    /* 0x7 */ GX_CA_ZERO,\n} GXTevAlphaArg;\n\ntypedef enum _GXTexFmt {\n    /* 0x0 */ GX_TF_I4,\n    /* 0x1 */ GX_TF_I8,\n    /* 0x2 */ GX_TF_IA4,\n    /* 0x3 */ GX_TF_IA8,\n    /* 0x4 */ GX_TF_RGB565,\n    /* 0x5 */ GX_TF_TGB5A3,\n    /* 0x6 */ GX_TF_RGBA8,\n    /* 0x7 */ GX_TF_CI4,\n    /* 0x8 */ GX_TF_CI8,\n    /* 0x9 */ GX_TF_CI14,\n    /* 0xE */ GX_TF_CMPR = 14,\n    /* 0x10 */ _GX_TF_ZTF = 0x10,\n    /* 0x11 */ GX_TF_Z8 = (0x1 | _GX_TF_ZTF),\n    /* 0x13 */ GX_TF_Z16 = (0x3 | _GX_TF_ZTF),\n    /* 0x16 */ GX_TF_Z24X8 = (0x6 | _GX_TF_ZTF),\n    /* 0x20 */ _GX_TF_CTF = 0x20,\n    /* 0x28 */ _GX_CTF_R8 = 0x28,\n    /* 0x30 */ GX_CTF_Z4 = (0x0 | _GX_TF_ZTF | _GX_TF_CTF),\n    /* 0x39 */ GX_CTF_Z8M = (0x9 | _GX_TF_ZTF | _GX_TF_CTF),\n    /* 0x3A */ GX_CTF_Z8L = (0xA | _GX_TF_ZTF | _GX_TF_CTF),\n    /* 0x3C */ GX_CTF_Z16L = (0xC | _GX_TF_ZTF | _GX_TF_CTF),\n} GXTexFmt;\n\ntypedef enum _GXGamma {\n    /* 0x0 */ GX_GM_1_0,\n    /* 0x0 */ GX_GM_1_7,\n    /* 0x0 */ GX_GM_2_2,\n} GXGamma;\n\ntypedef enum _GXTlutFmt {\n    /* 0x0 */ GX_TL_IA8,\n    /* 0x1 */ GX_TL_RGB565,\n    /* 0x2 */ GX_TL_RGB5A3,\n} GXTlutFmt;\n\ntypedef enum _GXTlut {\n    /* 0x00 */ GX_TLUT0,\n    /* 0x01 */ GX_TLUT1,\n    /* 0x02 */ GX_TLUT2,\n    /* 0x03 */ GX_TLUT3,\n    /* 0x04 */ GX_TLUT4,\n    /* 0x05 */ GX_TLUT5,\n    /* 0x06 */ GX_TLUT6,\n    /* 0x07 */ GX_TLUT7,\n    /* 0x08 */ GX_TLUT8,\n    /* 0x09 */ GX_TLUT9,\n    /* 0x0A */ GX_TLUT10,\n    /* 0x0B */ GX_TLUT11,\n    /* 0x0C */ GX_TLUT12,\n    /* 0x0D */ GX_TLUT13,\n    /* 0x0E */ GX_TLUT14,\n    /* 0x0F */ GX_TLUT15,\n    /* 0x10 */ GX_MAX_TLUT,\n    /* 0x10 */ GX_BIGTLUT0 = 0x10,\n    /* 0x11 */ GX_BIGTLUT1,\n    /* 0x12 */ GX_BIGTLUT2,\n    /* 0x13 */ GX_BIGTLUT3,\n    /* 0x13 */ GX_MAX_BIGTLUT = 4,\n} GXTlut;\n\n/* 8-bit version of GXTexFmt for use in structures */\ntypedef enum _GXTexFmt8 {\n    /* 0x20 */ GX_CTF_R4 = (0x0 | _GX_TF_CTF),\n    /* 0x22 */ GX_CTF_RA4 = (0x2 | _GX_TF_CTF),\n    /* 0x23 */ GX_CTF_RA8 = (0x3 | _GX_TF_CTF),\n    /* 0x26 */ GX_CTF_YUVA8 = (0x6 | _GX_TF_CTF),\n    /* 0x27 */ GX_CTF_A8 = (0x7 | _GX_TF_CTF),\n    /* 0x28 */ GX_CTF_R8 = (0x8 | _GX_TF_CTF),\n    /* 0x29 */ GX_CTF_G8 = (0x9 | _GX_TF_CTF),\n    /* 0x2A */ GX_CTF_B8 = (0xA | _GX_TF_CTF),\n    /* 0x2B */ GX_CTF_RG8 = (0xB | _GX_TF_CTF),\n    /* 0x2C */ GX_CTF_GB8 = (0xC | _GX_TF_CTF),\n} GXTexFmt8;\n\ntypedef enum _GXTexWrapMode {\n    /* 0x0 */ GX_CLAMP,\n    /* 0x1 */ GX_REPEAT,\n    /* 0x2 */ GX_MIRROR,\n    /* 0x3 */ GX_MAX_TEXWRAP_MODE,\n} GXTexWrapMode;\n\ntypedef enum _GXTexFilter {\n    /* 0x0 */ GX_NEAR,\n    /* 0x1 */ GX_LINEAR,\n    /* 0x2 */ GX_NEAR_MIP_NEAR,\n    /* 0x3 */ GX_LIN_MIP_NEAR,\n    /* 0x4 */ GX_NEAR_MIP_LIN,\n    /* 0x5 */ GX_LIN_MIP_LIN,\n} GXTexFilter;\n\ntypedef enum _GXAnisotropy {\n    /* 0x0 */ GX_ANISO_1,\n    /* 0x1 */ GX_ANISO_2,\n    /* 0x2 */ GX_ANISO_4,\n    /* 0x3 */ GX_MAX_ANISOTROPY,\n} GXAnisotropy;\n\ntypedef enum _GXCITexFmt {\n    /* 0x8 */ GX_TF_C4 = 8,\n    /* 0x8 */ GX_TF_C8,\n    /* 0xA */ GX_TF_C14X2\n} GXCITexFmt;\n\ntypedef enum _GXTexMtxType {\n    /* 0x0 */ GX_MTX3x4,\n    /* 0x1 */ GX_MTX2x4\n} GXTexMtxType;\n\ntypedef enum _GXCompare {\n    /* 0x0 */ GX_NEVER,\n    /* 0x1 */ GX_LESS,\n    /* 0x2 */ GX_EQUAL,\n    /* 0x3 */ GX_LEQUAL,\n    /* 0x4 */ GX_GREATER,\n    /* 0x5 */ GX_NEQUAL,\n    /* 0x6 */ GX_GEQUAL,\n    /* 0x7 */ GX_ALWAYS,\n} GXCompare;\n\ntypedef enum _GXAlphaOp {\n    /* 0x0 */ GX_AOP_AND,\n    /* 0x1 */ GX_AOP_OR,\n    /* 0x2 */ GX_AOP_XOR,\n    /* 0x3 */ GX_AOP_XNOR,\n    /* 0x4 */ GX_MAX_ALPHAOP\n} GXAlphaOp;\n\ntypedef enum _GXFogType {\n    /* 0x0 */ GX_FOG_NONE,\n    /* 0x2 */ GX_FOG_LIN = 2,\n    /* 0x2 */ GX_FOG_PERSP_LIN = 2,\n    /* 0x4 */ GX_FOG_EXP = 4,\n    /* 0x4 */ GX_FOG_PERSP_EXP = 4,\n    /* 0x5 */ GX_FOG_EXP2,\n    /* 0x5 */ GX_FOG_PERSP_EXP2 = 5,\n    /* 0x6 */ GX_FOG_REVEXP,\n    /* 0x6 */ GX_FOG_PERSP_REVEXP = 6,\n    /* 0x7 */ GX_FOG_REVEXP2,\n    /* 0x7 */ GX_FOG_PERSP_REVEXP2 = 7,\n    /* 0xA */ GX_FOG_ORTHO_LIN = 10,\n    /* 0xC */ GX_FOG_ORTHO_EXP = 12,\n    /* 0xD */ GX_FOG_ORTHO_EXP2,\n    /* 0xE */ GX_FOG_ORTHO_REVEXP,\n    /* 0xF */ GX_FOG_ORTHO_REVEXP2,\n} GXFogType;\n\ntypedef enum _GXProjectionType {\n    /* 0x0 */ GX_PERSPECTIVE,\n    /* 0x1 */ GX_ORTHOGRAPHIC\n} GXProjectionType;\n\ntypedef enum _GXTevKAlphaSel {\n    /* 0x00 */ GX_TEV_KASEL_1,\n    /* 0x01 */ GX_TEV_KASEL_7_8,\n    /* 0x02 */ GX_TEV_KASEL_3_4,\n    /* 0x03 */ GX_TEV_KASEL_5_8,\n    /* 0x04 */ GX_TEV_KASEL_1_2,\n    /* 0x05 */ GX_TEV_KASEL_3_8,\n    /* 0x06 */ GX_TEV_KASEL_1_4,\n    /* 0x07 */ GX_TEV_KASEL_1_8,\n\n    /* 0x10 */ GX_TEV_KASEL_K0_R = 0x10,\n    /* 0x11 */ GX_TEV_KASEL_K1_R,\n    /* 0x12 */ GX_TEV_KASEL_K2_R,\n    /* 0x13 */ GX_TEV_KASEL_K3_R,\n    /* 0x14 */ GX_TEV_KASEL_K0_G,\n    /* 0x15 */ GX_TEV_KASEL_K1_G,\n    /* 0x16 */ GX_TEV_KASEL_K2_G,\n    /* 0x17 */ GX_TEV_KASEL_K3_G,\n    /* 0x18 */ GX_TEV_KASEL_K0_B,\n    /* 0x19 */ GX_TEV_KASEL_K1_B,\n    /* 0x1A */ GX_TEV_KASEL_K2_B,\n    /* 0x1B */ GX_TEV_KASEL_K3_B,\n    /* 0x1C */ GX_TEV_KASEL_K0_A,\n    /* 0x1D */ GX_TEV_KASEL_K1_A,\n    /* 0x1E */ GX_TEV_KASEL_K2_A,\n    /* 0x1F */ GX_TEV_KASEL_K3_A,\n} GXTevKAlphaSel;\n\ntypedef enum _GXTevKColorSel {\n    /* 0x00 */ GX_TEV_KCSEL_1,\n    /* 0x01 */ GX_TEV_KCSEL_7_8,\n    /* 0x02 */ GX_TEV_KCSEL_3_4,\n    /* 0x03 */ GX_TEV_KCSEL_5_8,\n    /* 0x04 */ GX_TEV_KCSEL_1_2,\n    /* 0x05 */ GX_TEV_KCSEL_3_8,\n    /* 0x06 */ GX_TEV_KCSEL_1_4,\n    /* 0x07 */ GX_TEV_KCSEL_1_8,\n    /* 0x0C */ GX_TEV_KCSEL_K0 = 0xC,\n    /* 0x0D */ GX_TEV_KCSEL_K1,\n    /* 0x0E */ GX_TEV_KCSEL_K2,\n    /* 0x0F */ GX_TEV_KCSEL_K3,\n    /* 0x10 */ GX_TEV_KCSEL_K0_R,\n    /* 0x11 */ GX_TEV_KCSEL_K1_R,\n    /* 0x12 */ GX_TEV_KCSEL_K2_R,\n    /* 0x13 */ GX_TEV_KCSEL_K3_R,\n    /* 0x14 */ GX_TEV_KCSEL_K0_G,\n    /* 0x15 */ GX_TEV_KCSEL_K1_G,\n    /* 0x16 */ GX_TEV_KCSEL_K2_G,\n    /* 0x17 */ GX_TEV_KCSEL_K3_G,\n    /* 0x18 */ GX_TEV_KCSEL_K0_B,\n    /* 0x19 */ GX_TEV_KCSEL_K1_B,\n    /* 0x1A */ GX_TEV_KCSEL_K2_B,\n    /* 0x1B */ GX_TEV_KCSEL_K3_B,\n    /* 0x1C */ GX_TEV_KCSEL_K0_A,\n    /* 0x1D */ GX_TEV_KCSEL_K1_A,\n    /* 0x1E */ GX_TEV_KCSEL_K2_A,\n    /* 0x1F */ GX_TEV_KCSEL_K3_A,\n} GXTevKColorSel;\n\ntypedef enum _GXTevSwapSel {\n    /* 0x0 */ GX_TEV_SWAP0,\n    /* 0x1 */ GX_TEV_SWAP1,\n    /* 0x2 */ GX_TEV_SWAP2,\n    /* 0x3 */ GX_TEV_SWAP3,\n    /* 0x4 */ GX_MAX_TEVSWAP,\n} GXTevSwapSel;\n\ntypedef enum _GXTexGenType {\n    /* 0x0 */ GX_TG_MTX3x4,\n    /* 0x1 */ GX_TG_MTX2x4,\n    /* 0x2 */ GX_TG_BUMP0,\n    /* 0x3 */ GX_TG_BUMP1,\n    /* 0x4 */ GX_TG_BUMP2,\n    /* 0x5 */ GX_TG_BUMP3,\n    /* 0x6 */ GX_TG_BUMP4,\n    /* 0x7 */ GX_TG_BUMP5,\n    /* 0x8 */ GX_TG_BUMP6,\n    /* 0x9 */ GX_TG_BUMP7,\n    /* 0xA */ GX_TG_SRTG,\n} GXTexGenType;\n\ntypedef enum _GXTexGenSrc {\n    /* 0x00 */ GX_TG_POS,\n    /* 0x01 */ GX_TG_NRM,\n    /* 0x02 */ GX_TG_BINRM,\n    /* 0x03 */ GX_TG_TANGENT,\n    /* 0x04 */ GX_TG_TEX0,\n    /* 0x05 */ GX_TG_TEX1,\n    /* 0x06 */ GX_TG_TEX2,\n    /* 0x07 */ GX_TG_TEX3,\n    /* 0x08 */ GX_TG_TEX4,\n    /* 0x09 */ GX_TG_TEX5,\n    /* 0x0A */ GX_TG_TEX6,\n    /* 0x0B */ GX_TG_TEX7,\n    /* 0x0C */ GX_TG_TEXCOORD0,\n    /* 0x0D */ GX_TG_TEXCOORD1,\n    /* 0x0E */ GX_TG_TEXCOORD2,\n    /* 0x0F */ GX_TG_TEXCOORD3,\n    /* 0x10 */ GX_TG_TEXCOORD4,\n    /* 0x11 */ GX_TG_TEXCOORD5,\n    /* 0x12 */ GX_TG_TEXCOORD6,\n    /* 0x13 */ GX_TG_COLOR0,\n\t/* 0x14 */ GX_TG_COLOR1,\n} GXTexGenSrc;\n\ntypedef enum _GXZTexOp {\n    /* 0x0 */ GX_ZT_DISABLE,\n    /* 0x1 */ GX_ZT_ADD,\n    /* 0x2 */ GX_ZT_REPLACE,\n    /* 0x3 */ GX_MAX_ZTEXOP,\n} GXZTexOp;\n\ntypedef enum _GXIndTexStageID {\n    /* 0x0 */ GX_INDTEXSTAGE0,\n    /* 0x1 */ GX_INDTEXSTAGE1,\n    /* 0x2 */ GX_INDTEXSTAGE2,\n    /* 0x3 */ GX_INDTEXSTAGE3,\n    /* 0x4 */ GX_MAX_INDTEXSTAGE,\n} GXIndTexStageID;\n\ntypedef enum _GXIndTexScale {\n    /* 0x0 */ GX_ITS_1,\n    /* 0x1 */ GX_ITS_2,\n    /* 0x2 */ GX_ITS_4,\n    /* 0x3 */ GX_ITS_8,\n    /* 0x4 */ GX_ITS_16,\n    /* 0x5 */ GX_ITS_32,\n    /* 0x6 */ GX_ITS_64,\n    /* 0x7 */ GX_ITS_128,\n    /* 0x8 */ GX_ITS_256,\n    /* 0x9 */ GX_MAX_ITSCALE,\n} GXIndTexScale;\n\ntypedef enum _GXIndTexMtxID {\n    /* 0x0 */ GX_ITM_OFF,\n    /* 0x1 */ GX_ITM_0,\n    /* 0x2 */ GX_ITM_1,\n    /* 0x3 */ GX_ITM_2,\n    /* 0x4 */ GX_ITM_3,\n    /* 0x5 */ GX_ITM_S0 = 5,\n    /* 0x6 */ GX_ITM_S1,\n    /* 0x7 */ GX_ITM_S2,\n    /* 0x8 */ GX_ITM_S3,\n    /* 0x9 */ GX_ITM_T0 = 9,\n    /* 0xA */ GX_ITM_T1,\n    /* 0xB */ GX_ITM_T2,\n} GXIndTexMtxID;\n\ntypedef enum _GXIndTexFormat {\n    /* 0x0 */ GX_ITF_8,\n    /* 0x1 */ GX_ITF_5,\n    /* 0x2 */ GX_ITF_4,\n    /* 0x3 */ GX_ITF_3,\n} GXIndTexFormat;\n\ntypedef enum _GXIndTexBiasSel {\n    /* 0x0 */ GX_ITB_NONE,\n    /* 0x1 */ GX_ITB_S,\n    /* 0x2 */ GX_ITB_T,\n    /* 0x3 */ GX_ITB_ST,\n    /* 0x4 */ GX_ITB_U,\n    /* 0x5 */ GX_ITB_SU,\n    /* 0x6 */ GX_ITB_TU,\n    /* 0x7 */ GX_ITB_STU,\n} GXIndTexBiasSel;\n\ntypedef enum _GXIndTexAlphaSel {\n    /* 0x0 */ GX_ITBA_OFF,\n    /* 0x1 */ GX_ITBA_S,\n    /* 0x2 */ GX_ITBA_T,\n    /* 0x3 */ GX_ITBA_U,\n} GXIndTexAlphaSel;\n\ntypedef enum _GXIndTexWrap {\n    /* 0x0 */ GX_ITW_OFF,\n    /* 0x1 */ GX_ITW_256,\n    /* 0x2 */ GX_ITW_128,\n    /* 0x3 */ GX_ITW_64,\n    /* 0x4 */ GX_ITW_32,\n    /* 0x5 */ GX_ITW_16,\n    /* 0x6 */ GX_ITW_0,\n} GXIndTexWrap;\n\ntypedef enum _GXTexOffset {\n    /* 0x0 */ GX_TO_ZERO,\n    /* 0x1 */ GX_TO_SIXTEENTH,\n    /* 0x2 */ GX_TO_EIGHTH,\n    /* 0x3 */ GX_TO_FOURTH,\n    /* 0x4 */ GX_TO_HALF,\n    /* 0x5 */ GX_TO_ONE,\n    /* 0x6 */ GX_MAX_TEXOFFSET,\n} GXTexOffset;\n\ntypedef enum _GXTevKColorID {\n    /* 0x0 */ GX_KCOLOR0,\n    /* 0x1 */ GX_KCOLOR1,\n    /* 0x2 */ GX_KCOLOR2,\n    /* 0x3 */ GX_KCOLOR3,\n} GXTevKColorID;\n\ntypedef enum _GXTexCacheSize {\n    /* 0x0 */ GX_TEXCACHE_32K,\n    /* 0x1 */ GX_TEXCACHE_128K,\n    /* 0x2 */ GX_TEXCACHE_512K,\n    /* 0x3 */ GX_TEXCACHE_NONE,\n} GXTexCacheSize;\n\ntypedef enum _GXPosNrmMtx {\n    GX_PNMTX0 = 3 * 0,\n    GX_PNMTX1 = 3 * 1,\n    GX_PNMTX2 = 3 * 2,\n    GX_PNMTX3 = 3 * 3,\n    GX_PNMTX4 = 3 * 4,\n    GX_PNMTX5 = 3 * 5,\n    GX_PNMTX6 = 3 * 6,\n    GX_PNMTX7 = 3 * 7,\n    GX_PNMTX8 = 3 * 8,\n    GX_PNMTX9 = 3 * 9,\n} GXPosNrmMtx;\n\ntypedef enum _GXTexMtx {\n    GX_TEXMTX0 = 30 + 0 * 3,\n    GX_TEXMTX1 = 30 + 1 * 3,\n    GX_TEXMTX2 = 30 + 2 * 3,\n    GX_TEXMTX3 = 30 + 3 * 3,\n    GX_TEXMTX4 = 30 + 4 * 3,\n    GX_TEXMTX5 = 30 + 5 * 3,\n    GX_TEXMTX6 = 30 + 6 * 3,\n    GX_TEXMTX7 = 30 + 7 * 3,\n    GX_TEXMTX8 = 30 + 8 * 3,\n    GX_TEXMTX9 = 30 + 9 * 3,\n    GX_IDENTITY = 60,\n} GXTexMtx;\n\ntypedef enum _GXPTTexMtx {\n    GX_PTTEXMTX0 = 64 + 0 * 3,\n    GX_PTTEXMTX1 = 64 + 1 * 3,\n    GX_PTTEXMTX2 = 64 + 2 * 3,\n    GX_PTTEXMTX3 = 64 + 3 * 3,\n    GX_PTTEXMTX4 = 64 + 4 * 3,\n    GX_PTTEXMTX5 = 64 + 5 * 3,\n    GX_PTTEXMTX6 = 64 + 6 * 3,\n    GX_PTTEXMTX7 = 64 + 7 * 3,\n    GX_PTTEXMTX8 = 64 + 8 * 3,\n    GX_PTTEXMTX9 = 64 + 9 * 3,\n    GX_PTTEXMTX10 = 64 + 10 * 3,\n    GX_PTTEXMTX11 = 64 + 11 * 3,\n    GX_PTTEXMTX12 = 64 + 12 * 3,\n    GX_PTTEXMTX13 = 64 + 13 * 3,\n    GX_PTTEXMTX14 = 64 + 14 * 3,\n    GX_PTTEXMTX15 = 64 + 15 * 3,\n    GX_PTTEXMTX16 = 64 + 16 * 3,\n    GX_PTTEXMTX17 = 64 + 17 * 3,\n    GX_PTTEXMTX18 = 64 + 18 * 3,\n    GX_PTTEXMTX19 = 64 + 19 * 3,\n    GX_PTIDENTITY = 125,\n} GXPTTexMtx;\n\ntypedef enum _GXFBClamp {\n    /* 0x0 */ GX_CLAMP_NONE,\n    /* 0x1 */ GX_CLAMP_TOP,\n    /* 0x2 */ GX_CLAMP_BOTTOM,\n} GXFBClamp;\n\ntypedef enum _GXPixelFmt {\n    /* 0x0 */ GX_PF_RGB8_Z24,\n    /* 0x1 */ GX_PF_RGBA6_Z24,\n    /* 0x2 */ GX_PF_RGB565_Z16,\n    /* 0x3 */ GX_PF_Z24,\n    /* 0x4 */ GX_PF_Y8,\n    /* 0x5 */ GX_PF_U8,\n    /* 0x6 */ GX_PF_V8,\n    /* 0x7 */ GX_PF_YUV420,\n    /* 0x8 */ GX_PF_MAX,\n    g\n} GXPixelFmt;\n\ntypedef enum _GXZFmt16 {\n    /* 0x0 */ GX_ZC_LINEAR,\n    /* 0x1 */ GX_ZC_NEAR,\n    /* 0x2 */ GX_ZC_MID,\n    /* 0x3 */ GX_ZC_FAR,\n} GXZFmt16;\n\ntypedef enum _GXCommand {\n    GX_CMD_LOAD_INDX_A = 0x20,\n    GX_CMD_LOAD_INDX_B = 0x28,\n    GX_CMD_LOAD_INDX_C = 0x30,\n    GX_CMD_LOAD_INDX_D = 0x38,\n\n    GX_CMD_LOAD_CP_REG = 0x08,\n    GX_CMD_LOAD_XF_REG = 0x10,\n} GXCommand;\n\ntypedef enum _GXClipMode {\n    /* 0x0 */ GX_CLIP_ENABLE,\n    /* 0x1 */ GX_CLIP_DISABLE,\n} GXClipMode;\n\ntypedef enum _GXCopyMode {\n    /* 0x0 */ GX_COPY_PROGRESSIVE,\n    /* 0x1 */ GX_COPY_INTLC_EVEN,\n    /* 0x2 */ GX_COPY_INTLC_ODD,\n} GXCopyMode;\n\ntypedef enum _GXAlphaReadMode {\n    /* 0x0 */ GX_READ_00,\n    /* 0x1 */ GX_READ_FF,\n    /* 0x2 */ GX_READ_NONE,\n} GXAlphaReadMode;\n\ntypedef enum _GXTlutSize {\n    /* 0x001 */ GX_TLUT_16 = 1,\n    /* 0x002 */ GX_TLUT_32 = 2,\n    /* 0x004 */ GX_TLUT_64 = 4,\n    /* 0x008 */ GX_TLUT_128 = 8,\n    /* 0x010 */ GX_TLUT_256 = 16,\n    /* 0x020 */ GX_TLUT_512 = 32,\n    /* 0x040 */ GX_TLUT_1K = 64,\n    /* 0x080 */ GX_TLUT_2K = 128,\n    /* 0x100 */ GX_TLUT_4K = 256,\n    /* 0x200 */ GX_TLUT_8K = 512,\n    /* 0x400 */ GX_TLUT_16K = 1024,\n} GXTlutSize;\n\ntypedef enum _GXDirtyFlag {\n    GX_DIRTY_SU_TEX = (1 << 0),\n    GX_DIRTY_BP_MASK = (1 << 1),\n    GX_DIRTY_GEN_MODE = (1 << 2),\n    GX_DIRTY_VCD = (1 << 3),\n    GX_DIRTY_VAT = (1 << 4),\n    GX_DIRTY_AMB_COLOR0 = (1 << 8),\n    GX_DIRTY_AMB_COLOR1 = (1 << 9),\n    GX_DIRTY_MAT_COLOR0 = (1 << 10),\n    GX_DIRTY_MAT_COLOR1 = (1 << 11),\n    GX_DIRTY_MTX_IDX = (1 << 26),\n    GX_DIRTY_PROJECTION = (1 << 27),\n    GX_DIRTY_VIEWPORT = (1 << 28),\n\n    GX_DIRTY_VLIM = GX_DIRTY_VCD | GX_DIRTY_VAT,\n\n    GX_AMB_MAT_MASK = GX_DIRTY_AMB_COLOR0 | GX_DIRTY_AMB_COLOR1 |\n                      GX_DIRTY_MAT_COLOR0 | GX_DIRTY_MAT_COLOR1,\n    GX_LIGHT_CHAN_MASK = 0x100F000,\n    GX_TEX_GEN_MASK = 0x2FF0000,\n} GXDirtyFlag;\n\n// CP locator for vertex descriptor (lo).\ntypedef enum _GXCPVCDLo {\n\t// Position matrix idx [31]\n\tGX_CP_VCD_LO_POSMTXIDX_ST  = 31,\n\tGX_CP_VCD_LO_POSMTXIDX_END = 31,\n\n\t// Tex 0 matrix idx [30]\n\tGX_CP_VCD_LO_TEX0MTXIDX_ST  = 30,\n\tGX_CP_VCD_LO_TEX0MTXIDX_END = 30,\n\n\t// Tex 1 matrix idx [29]\n\tGX_CP_VCD_LO_TEX1MTXIDX_ST  = 29,\n\tGX_CP_VCD_LO_TEX1MTXIDX_END = 29,\n\n\t// Tex 2 matrix idx [28]\n\tGX_CP_VCD_LO_TEX2MTXIDX_ST  = 28,\n\tGX_CP_VCD_LO_TEX2MTXIDX_END = 28,\n\n\t// Tex 3 matrix idx [27]\n\tGX_CP_VCD_LO_TEX3MTXIDX_ST  = 27,\n\tGX_CP_VCD_LO_TEX3MTXIDX_END = 27,\n\n\t// Tex 4 matrix idx [26]\n\tGX_CP_VCD_LO_TEX4MTXIDX_ST  = 26,\n\tGX_CP_VCD_LO_TEX4MTXIDX_END = 26,\n\n\t// Tex 5 matrix idx [25]\n\tGX_CP_VCD_LO_TEX5MTXIDX_ST  = 25,\n\tGX_CP_VCD_LO_TEX5MTXIDX_END = 25,\n\n\t// Tex 6 matrix idx [24]\n\tGX_CP_VCD_LO_TEX6MTXIDX_ST  = 24,\n\tGX_CP_VCD_LO_TEX6MTXIDX_END = 24,\n\n\t// Tex 7 matrix idx [23]\n\tGX_CP_VCD_LO_TEX7MTXIDX_ST  = 23,\n\tGX_CP_VCD_LO_TEX7MTXIDX_END = 23,\n\n\t// Position [21-22]\n\tGX_CP_VCD_LO_POS_ST  = 21,\n\tGX_CP_VCD_LO_POS_END = 22,\n\n\t// Normal [19-20]\n\tGX_CP_VCD_LO_NRM_ST  = 19,\n\tGX_CP_VCD_LO_NRM_END = 20,\n\n\t// Color diffused [17-18]\n\tGX_CP_VCD_LO_CLRDIF_ST  = 17,\n\tGX_CP_VCD_LO_CLRDIF_END = 18,\n\n\t// Color specular [15-16]\n\tGX_CP_VCD_LO_CLRSPEC_ST  = 15,\n\tGX_CP_VCD_LO_CLRSPEC_END = 16,\n} GXCPVCDLo;\n\n// CP locators for vertex descriptor (hi).\ntypedef enum _GXCPVCDHi {\n\t// Tex0 coordinates [30-31]\n\tGX_CP_VCD_HI_TEX0COORD_ST  = 30,\n\tGX_CP_VCD_HI_TEX0COORD_END = 31,\n\n\t// Tex1 coordinates [28-29]\n\tGX_CP_VCD_HI_TEX1COORD_ST  = 28,\n\tGX_CP_VCD_HI_TEX1COORD_END = 29,\n\n\t// Tex2 coordinates [26-27]\n\tGX_CP_VCD_HI_TEX2COORD_ST  = 26,\n\tGX_CP_VCD_HI_TEX2COORD_END = 27,\n\n\t// Tex3 coordinates [24-25]\n\tGX_CP_VCD_HI_TEX3COORD_ST  = 24,\n\tGX_CP_VCD_HI_TEX3COORD_END = 25,\n\n\t// Tex4 coordinates [22-23]\n\tGX_CP_VCD_HI_TEX4COORD_ST  = 22,\n\tGX_CP_VCD_HI_TEX4COORD_END = 23,\n\n\t// Tex5 coordinates [20-21]\n\tGX_CP_VCD_HI_TEX5COORD_ST  = 20,\n\tGX_CP_VCD_HI_TEX5COORD_END = 21,\n\n\t// Tex6 coordinates [18-19]\n\tGX_CP_VCD_HI_TEX6COORD_ST  = 18,\n\tGX_CP_VCD_HI_TEX6COORD_END = 19,\n\n\t// Tex7 coordinates [16-17]\n\tGX_CP_VCD_HI_TEX7COORD_ST  = 16,\n\tGX_CP_VCD_HI_TEX7COORD_END = 17,\n} GXCPVCDHi;\n\n// Command processor registers.\ntypedef enum _GXCPRegs {\n\tGX_CP_REG_MTXIDXA     = 0x30, // Matrix index A\n\tGX_CP_REG_MTXIDXB     = 0x40, // Matrix index B\n\tGX_CP_REG_VCD_LO      = 0x50, // Vertex descriptor (lo)\n\tGX_CP_REG_VCD_HI      = 0x60, // Vertex descriptor (hi)\n\tGX_CP_REG_VAT_GRP0    = 0x70, // Vertex attribute table (group 0)\n\tGX_CP_REG_VAT_GRP1    = 0x80, // Vertex attribute table (group 1)\n\tGX_CP_REG_VAT_GRP2    = 0x90, // Vertex attribute table (group 2)\n\tGX_CP_REG_ARRAYBASE   = 0xA0, // Vertex array start/base\n\tGX_CP_REG_ARRAYSTRIDE = 0xB0, // Vertex array stride\n} GXCPRegs;\n\n// Transform unit registers.\ntypedef enum _GXXFRegs {\n\tGX_XF_REG_ERROR        = 0x1000,\n\tGX_XF_REG_DIAGNOSTICS  = 0x1001,\n\tGX_XF_REG_STATE0       = 0x1002,\n\tGX_XF_REG_STATE1       = 0x1003,\n\tGX_XF_REG_CLOCK        = 0x1004,\n\tGX_XF_REG_CLIPDISABLE  = 0x1005,\n\tGX_XF_REG_PERF0        = 0x1006,\n\tGX_XF_REG_PERF1        = 0x1007,\n\tGX_XF_REG_INVERTEXSPEC = 0x1008,\n\tGX_XF_REG_NUMCOLORS    = 0x1009,\n\tGX_XF_REG_AMBIENT0     = 0x100A,\n\tGX_XF_REG_AMBIENT1     = 0x100B,\n\tGX_XF_REG_MATERIAL0    = 0x100C,\n\tGX_XF_REG_MATERIAL1    = 0x100D,\n\tGX_XF_REG_COLOR0CNTRL  = 0x100E,\n\tGX_XF_REG_COLOR1CNTRL  = 0x100F,\n\tGX_XF_REG_ALPHA0CNTRL  = 0x1010,\n\tGX_XF_REG_ALPHA1CNTRL  = 0x1011,\n\tGX_XF_REG_DUALTEXTRAN  = 0x1012,\n\tGX_XF_REG_MATRIXINDEX0 = 0x1018,\n\tGX_XF_REG_MATRIXINDEX1 = 0x1019,\n\tGX_XF_REG_SCALEX       = 0x101A,\n\tGX_XF_REG_SCALEY       = 0x101B,\n\tGX_XF_REG_SCALEZ       = 0x101C,\n\tGX_XF_REG_OFFSETX      = 0x101D,\n\tGX_XF_REG_OFFSETY      = 0x101E,\n\tGX_XF_REG_OFFSETZ      = 0x101F,\n\tGX_XF_REG_PROJECTIONA  = 0x1020,\n\tGX_XF_REG_PROJECTIONB  = 0x1021,\n\tGX_XF_REG_PROJECTIONC  = 0x1022,\n\tGX_XF_REG_PROJECTIOND  = 0x1023,\n\tGX_XF_REG_PROJECTIONE  = 0x1024,\n\tGX_XF_REG_PROJECTIONF  = 0x1025,\n\tGX_XF_REG_PROJECTORTHO = 0x1026,\n\tGX_XF_REG_NUMTEX       = 0x103F,\n\tGX_XF_REG_TEX0         = 0x1040,\n\tGX_XF_REG_TEX1         = 0x1041,\n\tGX_XF_REG_TEX2         = 0x1042,\n\tGX_XF_REG_TEX3         = 0x1043,\n\tGX_XF_REG_TEX4         = 0x1044,\n\tGX_XF_REG_TEX5         = 0x1045,\n\tGX_XF_REG_TEX6         = 0x1046,\n\tGX_XF_REG_TEX7         = 0x1047,\n\tGX_XF_REG_DUALTEX0     = 0x1050,\n\tGX_XF_REG_DUALTEX1     = 0x1051,\n\tGX_XF_REG_DUALTEX2     = 0x1052,\n\tGX_XF_REG_DUALTEX3     = 0x1053,\n\tGX_XF_REG_DUALTEX4     = 0x1054,\n\tGX_XF_REG_DUALTEX5     = 0x1055,\n\tGX_XF_REG_DUALTEX6     = 0x1056,\n\tGX_XF_REG_DUALTEX7     = 0x1057,\n} GXXFRegs;\n\n// Commands for interacting with the GXFifo pipe.\ntypedef enum _GXFifoCmd {\n\tGX_FIFO_CMD_NOOP = 0x00, // no operation\n\n\tGX_FIFO_CMD_LOAD_BP_REG = 0x61, // load blitting processor reg\n\tGX_FIFO_CMD_LOAD_CP_REG = 0x08, // load command processor reg\n\tGX_FIFO_CMD_LOAD_XF_REG = 0x10, // load transform unit reg\n\n\tGX_FIFO_CMD_LOAD_INDX_A = 0x20, // load index A\n\tGX_FIFO_CMD_LOAD_INDX_B = 0x28, // load index B\n\tGX_FIFO_CMD_LOAD_INDX_C = 0x30, // load index C\n\tGX_FIFO_CMD_LOAD_INDX_D = 0x38, // load index D\n\n\tGX_FIFO_CMD_CALL_DL   = 0x40, // call displaylist\n\tGX_FIFO_CMD_INVAL_VTX = 0x48, // invalid vertex\n\n} GXFifoCmd;\n\n// CP locator for vertex attribute table (group 0).\ntypedef enum _GXCPVATGrp0 {\n\t// Position count [31-31]\n\tGX_CP_VAT_GRP0_POS_CNT_ST  = 31,\n\tGX_CP_VAT_GRP0_POS_CNT_END = 31,\n\n\t// Position type [28-30]\n\tGX_CP_VAT_GRP0_POS_TYPE_ST  = 28,\n\tGX_CP_VAT_GRP0_POS_TYPE_END = 30,\n\n\t// Position shift [23-27]\n\tGX_CP_VAT_GRP0_POS_SHIFT_ST  = 23,\n\tGX_CP_VAT_GRP0_POS_SHIFT_END = 27,\n\n\t// Normal count [22-22]\n\tGX_CP_VAT_GRP0_NRM_CNT_ST  = 22,\n\tGX_CP_VAT_GRP0_NRM_CNT_END = 22,\n\n\t// Normal type [19-21]\n\tGX_CP_VAT_GRP0_NRM_TYPE_ST  = 19,\n\tGX_CP_VAT_GRP0_NRM_TYPE_END = 21,\n\n\t// Color diffused count [18-18]\n\tGX_CP_VAT_GRP0_CLRDIFF_CNT_ST  = 18,\n\tGX_CP_VAT_GRP0_CLRDIFF_CNT_END = 18,\n\n\t// Color diffused type [15-17]\n\tGX_CP_VAT_GRP0_CLRDIFF_TYPE_ST  = 15,\n\tGX_CP_VAT_GRP0_CLRDIFF_TYPE_END = 17,\n\n\t// Color specular count [14-14]\n\tGX_CP_VAT_GRP0_CLRSPEC_CNT_ST  = 14,\n\tGX_CP_VAT_GRP0_CLRSPEC_CNT_END = 14,\n\n\t// Color specular type [11-13]\n\tGX_CP_VAT_GRP0_CLRSPEC_TYPE_ST  = 11,\n\tGX_CP_VAT_GRP0_CLRSPEC_TYPE_END = 13,\n\n\t// Tex0 coord count [10-10]\n\tGX_CP_VAT_GRP0_TXC0_CNT_ST  = 10,\n\tGX_CP_VAT_GRP0_TXC0_CNT_END = 10,\n\n\t// Tex0 coord type [7-9]\n\tGX_CP_VAT_GRP0_TXC0_TYPE_ST  = 7,\n\tGX_CP_VAT_GRP0_TXC0_TYPE_END = 9,\n\n\t// Tex0 coord shift [2-6]\n\tGX_CP_VAT_GRP0_TXC0_SHIFT_ST  = 2,\n\tGX_CP_VAT_GRP0_TXC0_SHIFT_END = 6,\n\n\t// Byte dequantised [1-1]\n\tGX_CP_VAT_GRP0_BYTEDEQ_ST  = 1,\n\tGX_CP_VAT_GRP0_BYTEDEQ_END = 1,\n\n\t// Normal index 3 [0-0] (Input will be treated as three staggered indices (one per triple biased by component size) into normal table))\n\tGX_CP_VAT_GRP0_NRMIDX3_ST  = 0,\n\tGX_CP_VAT_GRP0_NRMIDX3_END = 0,\n} GXCPVATGrp0;\n\n// CP locators for vertex attribute table (group 1).\ntypedef enum _GXCPVATGrp1 {\n\t// Tex1 coord count [31-31]\n\tGX_CP_VAT_GRP1_TXC1_CNT_ST  = 31,\n\tGX_CP_VAT_GRP1_TXC1_CNT_END = 31,\n\n\t// Tex1 coord type [28-30]\n\tGX_CP_VAT_GRP1_TXC1_TYPE_ST  = 28,\n\tGX_CP_VAT_GRP1_TXC1_TYPE_END = 30,\n\n\t// Tex1 coord shift [23-27]\n\tGX_CP_VAT_GRP1_TXC1_SHIFT_ST  = 23,\n\tGX_CP_VAT_GRP1_TXC1_SHIFT_END = 27,\n\n\t// Tex2 coord count [22-22]\n\tGX_CP_VAT_GRP1_TXC2_CNT_ST  = 22,\n\tGX_CP_VAT_GRP1_TXC2_CNT_END = 22,\n\n\t// Tex2 coord type [19-21]\n\tGX_CP_VAT_GRP1_TXC2_TYPE_ST  = 19,\n\tGX_CP_VAT_GRP1_TXC2_TYPE_END = 21,\n\n\t// Tex2 coord shift [14-18]\n\tGX_CP_VAT_GRP1_TXC2_SHIFT_ST  = 14,\n\tGX_CP_VAT_GRP1_TXC2_SHIFT_END = 18,\n\n\t// Tex3 coord count [13-13]\n\tGX_CP_VAT_GRP1_TXC3_CNT_ST  = 13,\n\tGX_CP_VAT_GRP1_TXC3_CNT_END = 13,\n\n\t// Tex3 coord type [10-12]\n\tGX_CP_VAT_GRP1_TXC3_TYPE_ST  = 10,\n\tGX_CP_VAT_GRP1_TXC3_TYPE_END = 12,\n\n\t// Tex3 coord shift [5-9]\n\tGX_CP_VAT_GRP1_TXC3_SHIFT_ST  = 5,\n\tGX_CP_VAT_GRP1_TXC3_SHIFT_END = 9,\n\n\t// Tex4 coord count [4-4]\n\tGX_CP_VAT_GRP1_TXC4_CNT_ST  = 4,\n\tGX_CP_VAT_GRP1_TXC4_CNT_END = 4,\n\n\t// Tex4 coord type [1-3]\n\tGX_CP_VAT_GRP1_TXC4_TYPE_ST  = 1,\n\tGX_CP_VAT_GRP1_TXC4_TYPE_END = 3,\n\n} GXCPVATGrp1;\n\n// CP locators for vertex attribute table (group 2).\ntypedef enum _GXCPVATGrp2 {\n\t// Tex4 coord shift [27-31]\n\tGX_CP_VAT_GRP2_TXC4_SHIFT_ST  = 27,\n\tGX_CP_VAT_GRP2_TXC4_SHIFT_END = 31,\n\n\t// Tex5 coord count [26-26]\n\tGX_CP_VAT_GRP2_TXC5_CNT_ST  = 26,\n\tGX_CP_VAT_GRP2_TXC5_CNT_END = 26,\n\n\t// Tex5 coord type [23-25]\n\tGX_CP_VAT_GRP2_TXC5_TYPE_ST  = 23,\n\tGX_CP_VAT_GRP2_TXC5_TYPE_END = 25,\n\n\t// Tex5 coord shift [18-22]\n\tGX_CP_VAT_GRP2_TXC5_SHIFT_ST  = 18,\n\tGX_CP_VAT_GRP2_TXC5_SHIFT_END = 22,\n\n\t// Tex6 coord count [17-17]\n\tGX_CP_VAT_GRP2_TXC6_CNT_ST  = 17,\n\tGX_CP_VAT_GRP2_TXC6_CNT_END = 17,\n\n\t// Tex6 coord type [14-16]\n\tGX_CP_VAT_GRP2_TXC6_TYPE_ST  = 14,\n\tGX_CP_VAT_GRP2_TXC6_TYPE_END = 16,\n\n\t// Tex6 coord shift [9-13]\n\tGX_CP_VAT_GRP2_TXC6_SHIFT_ST  = 9,\n\tGX_CP_VAT_GRP2_TXC6_SHIFT_END = 13,\n\n\t// Tex7 coord count [8-8]\n\tGX_CP_VAT_GRP2_TXC7_CNT_ST  = 8,\n\tGX_CP_VAT_GRP2_TXC7_CNT_END = 8,\n\n\t// Tex7 coord type [5-7]\n\tGX_CP_VAT_GRP2_TXC7_TYPE_ST  = 5,\n\tGX_CP_VAT_GRP2_TXC7_TYPE_END = 7,\n\n\t// Tex7 coord shift [0-4]\n\tGX_CP_VAT_GRP2_TXC7_SHIFT_ST  = 0,\n\tGX_CP_VAT_GRP2_TXC7_SHIFT_END = 4,\n} GXCPVATGrp2;\n\n// BP GenMode locators.\ntypedef enum _GXBPGenMode {\n\t// Active texture counts [28-31]\n\tGX_BP_GENMODE_NUMTEX_ST  = 28,\n\tGX_BP_GENMODE_NUMTEX_END = 31,\n\n\t// Color/channel counts [25-27]\n\tGX_BP_GENMODE_NUMCOLORS_ST  = 25,\n\tGX_BP_GENMODE_NUMCOLORS_END = 27,\n\n\t// Multisample mode [22-22]\n\tGX_BP_GENMODE_MULTISAMPLE_ST  = 22,\n\tGX_BP_GENMODE_MULTISAMPLE_END = 22,\n\n\t// Cull mode [16-17]\n\tGX_BP_GENMODE_CULLMODE_ST  = 16,\n\tGX_BP_GENMODE_CULLMODE_END = 17,\n\n\t// Indirect stage counts [13-15]\n\tGX_BP_GENMODE_NUMINDSTAGES_ST  = 13,\n\tGX_BP_GENMODE_NUMINDSTAGES_END = 15,\n\n\t// Toggle co-planar/Z-freeze [12-12]\n\tGX_BP_GENMODE_COPLANAR_ST  = 12,\n\tGX_BP_GENMODE_COPLANAR_END = 12,\n} GXBPGenMode;\n\n// Texture register fields for XF (transform) unit.\ntypedef enum _GXXfTexReg {\n\tGX_XF_TEX_PROJ_ST  = 0, // (s,t) (2x4)\n\tGX_XF_TEX_PROJ_STQ = 1, // (s,t,q) (3x4)\n\n\tGX_XF_TEX_FORM_AB11 = 0, // (A, B, 1.0f, 1.0f), used for regular tex src\n\tGX_XF_TEX_FORM_ABC1 = 1, // (A, B, C, 1.0f), used for geometry/normal src\n} GXXfTexReg;\n\n// XF locators for textures.\ntypedef enum _GXXFTex {\n\t// Projection type [30-30]\n\tGX_XF_TEX_PROJTYPE_ST  = 30,\n\tGX_XF_TEX_PROJTYPE_END = 30,\n\n\t// Input format [29-29]\n\tGX_XF_TEX_INPUTFORM_ST  = 29,\n\tGX_XF_TEX_INPUTFORM_END = 29,\n\n\t// Texture gen type [25-27]\n\tGX_XF_TEX_TEXGENTYPE_ST  = 25,\n\tGX_XF_TEX_TEXGENTYPE_END = 27,\n\n\t// Source row [20-24]\n\tGX_XF_TEX_SRCROW_ST  = 20,\n\tGX_XF_TEX_SRCROW_END = 24,\n\n\t// Bump source texture [17-19]\n\tGX_XF_TEX_BUMPSRCTEX_ST  = 17,\n\tGX_XF_TEX_BUMPSRCTEX_END = 19,\n\n\t// Bump source light [14-16]\n\tGX_XF_TEX_BUMPSRCLIGHT_ST  = 14,\n\tGX_XF_TEX_BUMPSRCLIGHT_END = 16,\n} GXXFTex;\n\n// XF locators for dual textures.\ntypedef enum _GXXFDualTex {\n\t// Base row of the transform matrix [26-31]\n\tGX_XF_DUALTEX_BASEROW_ST  = 26,\n\tGX_XF_DUALTEX_BASEROW_END = 31,\n\n\t// Normalise texcoord before sending transform [23-23]\n\tGX_XF_DUALTEX_NORMALISE_ST  = 23,\n\tGX_XF_DUALTEX_NORMALISE_END = 23,\n} GXXFDualTex;\n\n// General texture commands.\ntypedef enum _GXXfTexGen {\n\tGX_XF_TG_REGULAR = 0, // Regular; transform incoming data.\n\tGX_XF_TG_BUMP    = 1, // Texgen bump mapping.\n\tGX_XF_TG_CLR0    = 2, // Color texgen for color 0 (s,t) = (r, g:b)\n\tGX_XF_TG_CLR1    = 3, // Color texgen for color 1 (s,t) = (r, g:b)\n} GXXfTexGen;\n\n// XF locators for matrix index 0.\ntypedef enum _GXXFMtxIdx0 {\n\t// Geometry [26-31]\n\tGX_XF_MTXIDX0_GEOM_ST  = 26,\n\tGX_XF_MTXIDX0_GEOM_END = 31,\n\n\t// Tex 0 [20-25]\n\tGX_XF_MTXIDX0_TEX0_ST  = 20,\n\tGX_XF_MTXIDX0_TEX0_END = 25,\n\n\t// Tex 1 [14-19]\n\tGX_XF_MTXIDX0_TEX1_ST  = 14,\n\tGX_XF_MTXIDX0_TEX1_END = 19,\n\n\t// Tex 2 [8-13]\n\tGX_XF_MTXIDX0_TEX2_ST  = 8,\n\tGX_XF_MTXIDX0_TEX2_END = 13,\n\n\t// Tex 3 [2-7]\n\tGX_XF_MTXIDX0_TEX3_ST  = 2,\n\tGX_XF_MTXIDX0_TEX3_END = 7,\n} GXXFMtxIdx0;\n\n// XF locators for matrix index 1.\ntypedef enum _GXXFMtxIdx1 {\n\t// Tex 4 [26-31]\n\tGX_XF_MTXIDX1_TEX4_ST  = 26,\n\tGX_XF_MTXIDX1_TEX4_END = 31,\n\n\t// Tex 5 [20-25]\n\tGX_XF_MTXIDX1_TEX5_ST  = 20,\n\tGX_XF_MTXIDX1_TEX5_END = 25,\n\n\t// Tex 6 [14-19]\n\tGX_XF_MTXIDX1_TEX6_ST  = 14,\n\tGX_XF_MTXIDX1_TEX6_END = 19,\n\n\t// Tex 7 [8-13]\n\tGX_XF_MTXIDX1_TEX7_ST  = 8,\n\tGX_XF_MTXIDX1_TEX7_END = 13,\n} GXXFMtxIdx1;\n\n// Blitting processor registers.\ntypedef enum _GXBPRegs {\n\t// gen mode\n\tGX_BP_REG_GENMODE = 0x0, // gen mode\n\n\t// display copy filters\n\tGX_BP_REG_DISPCOPYFILTER0 = 0x1, // display copy filter 0\n\tGX_BP_REG_DISPCOPYFILTER1 = 0x2, // display copy filter 1\n\tGX_BP_REG_DISPCOPYFILTER2 = 0x3, // display copy filter 2\n\tGX_BP_REG_DISPCOPYFILTER3 = 0x4, // display copy filter 3\n\n\t// indirect matrices\n\tGX_BP_REG_INDMTX0A = 0x6, // indirect matrix 0A\n\tGX_BP_REG_INDMTX0B = 0x7, // indirect matrix 0B\n\tGX_BP_REG_INDMTX0C = 0x8, // indirect matrix 0C\n\tGX_BP_REG_INDMTX1A = 0x9, // indirect matrix 1A\n\tGX_BP_REG_INDMTX1B = 0xA, // indirect matrix 1B\n\tGX_BP_REG_INDMTX1C = 0xB, // indirect matrix 1C\n\tGX_BP_REG_INDMTX2A = 0xC, // indirect matrix 2A\n\tGX_BP_REG_INDMTX2B = 0xD, // indirect matrix 2B\n\tGX_BP_REG_INDMTX2C = 0xE, // indirect matrix 2C\n\tGX_BP_REG_INDIMASK = 0xF, // indirect mask\n\n\t// indirect TEV stages\n\tGX_BP_REG_INDTEVSTAGE0  = 0x10, // indirect TEV stage 0\n\tGX_BP_REG_INDTEVSTAGE1  = 0x11, // indirect TEV stage 1\n\tGX_BP_REG_INDTEVSTAGE2  = 0x12, // indirect TEV stage 2\n\tGX_BP_REG_INDTEVSTAGE3  = 0x13, // indirect TEV stage 3\n\tGX_BP_REG_INDTEVSTAGE4  = 0x14, // indirect TEV stage 4\n\tGX_BP_REG_INDTEVSTAGE5  = 0x15, // indirect TEV stage 5\n\tGX_BP_REG_INDTEVSTAGE6  = 0x16, // indirect TEV stage 6\n\tGX_BP_REG_INDTEVSTAGE7  = 0x17, // indirect TEV stage 7\n\tGX_BP_REG_INDTEVSTAGE8  = 0x18, // indirect TEV stage 8\n\tGX_BP_REG_INDTEVSTAGE9  = 0x19, // indirect TEV stage 9\n\tGX_BP_REG_INDTEVSTAGE10 = 0x1A, // indirect TEV stage 10\n\tGX_BP_REG_INDTEVSTAGE11 = 0x1B, // indirect TEV stage 11\n\tGX_BP_REG_INDTEVSTAGE12 = 0x1C, // indirect TEV stage 12\n\tGX_BP_REG_INDTEVSTAGE13 = 0x1D, // indirect TEV stage 13\n\tGX_BP_REG_INDTEVSTAGE14 = 0x1E, // indirect TEV stage 14\n\tGX_BP_REG_INDTEVSTAGE15 = 0x1F, // indirect TEV stage 15\n\n\t// performance manips\n\tGX_BP_REG_SCISSORTL   = 0x20, // scissor top left\n\tGX_BP_REG_SCISSORBR   = 0x21, // scissor bottom right\n\tGX_BP_REG_LINEPTWIDTH = 0x22, // line point width\n\tGX_BP_REG_PERF0TRI    = 0x23, // performance 0 (triangle)\n\tGX_BP_REG_PERF0QUAD   = 0x24, // performance 0 (quad)\n\n\t// rasters\n\tGX_BP_REG_RAS1_SS0   = 0x25,\n\tGX_BP_REG_RAS1_SS1   = 0x26,\n\tGX_BP_REG_RAS1_IREF  = 0x27,\n\tGX_BP_REG_RAS1_TREF0 = 0x28,\n\tGX_BP_REG_RAS1_TREF1 = 0x29,\n\tGX_BP_REG_RAS1_TREF2 = 0x2A,\n\tGX_BP_REG_RAS1_TREF3 = 0x2B,\n\tGX_BP_REG_RAS1_TREF4 = 0x2C,\n\tGX_BP_REG_RAS1_TREF5 = 0x2D,\n\tGX_BP_REG_RAS1_TREF6 = 0x2E,\n\tGX_BP_REG_RAS1_TREF7 = 0x2F,\n\n\t// setup sizes\n\tGX_BP_REG_SU_SSIZE0 = 0x30,\n\tGX_BP_REG_SU_TSIZE0 = 0x31,\n\tGX_BP_REG_SU_SSIZE1 = 0x32,\n\tGX_BP_REG_SU_TSIZE1 = 0x33,\n\tGX_BP_REG_SU_SSIZE2 = 0x34,\n\tGX_BP_REG_SU_TSIZE2 = 0x35,\n\tGX_BP_REG_SU_SSIZE3 = 0x36,\n\tGX_BP_REG_SU_TSIZE3 = 0x37,\n\tGX_BP_REG_SU_SSIZE4 = 0x38,\n\tGX_BP_REG_SU_TSIZE4 = 0x39,\n\tGX_BP_REG_SU_SSIZE5 = 0x3A,\n\tGX_BP_REG_SU_TSIZE5 = 0x3B,\n\tGX_BP_REG_SU_SSIZE6 = 0x3C,\n\tGX_BP_REG_SU_TSIZE6 = 0x3D,\n\tGX_BP_REG_SU_SSIZE7 = 0x3E,\n\tGX_BP_REG_SU_TSIZE7 = 0x3F,\n\n\t// Z and blend controls\n\tGX_BP_REG_ZMODE      = 0x40,\n\tGX_BP_REG_BLENDMODE  = 0x41,\n\tGX_BP_REG_DSTALPHA   = 0x42,\n\tGX_BP_REG_ZCONTROL   = 0x43,\n\tGX_BP_REG_FIELDMASK  = 0x44,\n\tGX_BP_REG_DRAWDONE   = 0x45,\n\tGX_BP_REG_PETOKEN    = 0x47,\n\tGX_BP_REG_PETOKENINT = 0x48,\n\n\t// copying\n\tGX_BP_REG_TEXCOPYSRCXY   = 0x49,\n\tGX_BP_REG_TEXCOPYSRCWH   = 0x4A,\n\tGX_BP_REG_TEXCOPYDST     = 0x4B,\n\tGX_BP_REG_DISPCOPYSTRIDE = 0x4D,\n\tGX_BP_REG_DISPCOPYSCALEY = 0x4E,\n\tGX_BP_REG_COPYCLEARAR    = 0x4F,\n\tGX_BP_REG_COPYCLEARGB    = 0x50,\n\tGX_BP_REG_COPYCLEARZ     = 0x51,\n\tGX_BP_REG_COPYFILTER0    = 0x53,\n\tGX_BP_REG_COPYFILTER1    = 0x54,\n\n\t//\n\tGX_BP_REG_BOUNDINGBOX0 = 0x55,\n\tGX_BP_REG_BOUNDINGBOX1 = 0x56,\n\n\tGX_BP_REG_SCISSOROFFSET = 0x59,\n\n\t// texture memory\n\tGX_BP_REG_TMEMPRELOADADDR   = 0x60,\n\tGX_BP_REG_TMEMPRELOADEVEN   = 0x61,\n\tGX_BP_REG_TMEMPRELOADODD    = 0x62,\n\tGX_BP_REG_TMEMPRELOADMODE   = 0x63,\n\tGX_BP_REG_TMEMTLUTSRC       = 0x64,\n\tGX_BP_REG_TMEMTLUTDST       = 0x65,\n\tGX_BP_REG_TMEMTEXINVALIDATE = 0x66,\n\n\t// performance 1\n\tGX_BP_REG_PERF1     = 0x67,\n\tGX_BP_REG_FIELDMODE = 0x68,\n\n\t// set modes\n\tGX_BP_REG_SETMODE0_TEX0 = 0x80,\n\tGX_BP_REG_SETMODE0_TEX1 = 0x81,\n\tGX_BP_REG_SETMODE0_TEX2 = 0x82,\n\tGX_BP_REG_SETMODE0_TEX3 = 0x83,\n\tGX_BP_REG_SETMODE1_TEX0 = 0x84,\n\tGX_BP_REG_SETMODE1_TEX1 = 0x85,\n\tGX_BP_REG_SETMODE1_TEX2 = 0x86,\n\tGX_BP_REG_SETMODE1_TEX3 = 0x87,\n\n\t// set images\n\tGX_BP_REG_SETIMAGE0_TEX0 = 0x88,\n\tGX_BP_REG_SETIMAGE0_TEX1 = 0x89,\n\tGX_BP_REG_SETIMAGE0_TEX2 = 0x8A,\n\tGX_BP_REG_SETIMAGE0_TEX3 = 0x8B,\n\tGX_BP_REG_SETIMAGE1_TEX0 = 0x8C,\n\tGX_BP_REG_SETIMAGE1_TEX1 = 0x8D,\n\tGX_BP_REG_SETIMAGE1_TEX2 = 0x8E,\n\tGX_BP_REG_SETIMAGE1_TEX3 = 0x8F,\n\tGX_BP_REG_SETIMAGE2_TEX0 = 0x90,\n\tGX_BP_REG_SETIMAGE2_TEX1 = 0x91,\n\tGX_BP_REG_SETIMAGE2_TEX2 = 0x92,\n\tGX_BP_REG_SETIMAGE2_TEX3 = 0x93,\n\tGX_BP_REG_SETIMAGE3_TEX0 = 0x94,\n\tGX_BP_REG_SETIMAGE3_TEX1 = 0x95,\n\tGX_BP_REG_SETIMAGE3_TEX2 = 0x96,\n\tGX_BP_REG_SETIMAGE3_TEX3 = 0x97,\n\n\t// set texture lookups\n\tGX_BP_REG_SETTLUT_TEX0 = 0x98,\n\tGX_BP_REG_SETTLUT_TEX1 = 0x99,\n\tGX_BP_REG_SETTLUT_TEX2 = 0x9A,\n\tGX_BP_REG_SETTLUT_TEX3 = 0x9B,\n\n\t// set modes continued\n\tGX_BP_REG_SETMODE0_TEX4 = 0xA0,\n\tGX_BP_REG_SETMODE0_TEX5 = 0xA1,\n\tGX_BP_REG_SETMODE0_TEX6 = 0xA2,\n\tGX_BP_REG_SETMODE0_TEX7 = 0xA3,\n\tGX_BP_REG_SETMODE1_TEX4 = 0xA4,\n\tGX_BP_REG_SETMODE1_TEX5 = 0xA5,\n\tGX_BP_REG_SETMODE1_TEX6 = 0xA6,\n\tGX_BP_REG_SETMODE1_TEX7 = 0xA7,\n\n\t// set images continued\n\tGX_BP_REG_SETIMAGE0_TEX4 = 0xA8,\n\tGX_BP_REG_SETIMAGE0_TEX5 = 0xA9,\n\tGX_BP_REG_SETIMAGE0_TEX6 = 0xAA,\n\tGX_BP_REG_SETIMAGE0_TEX7 = 0xAB,\n\tGX_BP_REG_SETIMAGE1_TEX4 = 0xAC,\n\tGX_BP_REG_SETIMAGE1_TEX5 = 0xAD,\n\tGX_BP_REG_SETIMAGE1_TEX6 = 0xAE,\n\tGX_BP_REG_SETIMAGE1_TEX7 = 0xAF,\n\tGX_BP_REG_SETIMAGE2_TEX4 = 0xB0,\n\tGX_BP_REG_SETIMAGE2_TEX5 = 0xB1,\n\tGX_BP_REG_SETIMAGE2_TEX6 = 0xB2,\n\tGX_BP_REG_SETIMAGE2_TEX7 = 0xB3,\n\tGX_BP_REG_SETIMAGE3_TEX4 = 0xB4,\n\tGX_BP_REG_SETIMAGE3_TEX5 = 0xB5,\n\tGX_BP_REG_SETIMAGE3_TEX6 = 0xB6,\n\tGX_BP_REG_SETIMAGE3_TEX7 = 0xB7,\n\n\t// set texture lookups continued\n\tGX_BP_REG_SETTLUT_TEX4 = 0xB8,\n\tGX_BP_REG_SETTLUT_TEX5 = 0xB9,\n\tGX_BP_REG_SETTLUT_TEX6 = 0xBA,\n\tGX_BP_REG_SETTLUT_TEX7 = 0xBB,\n\n\t// TEV color manips\n\tGX_BP_REG_TEVCOLORCOMBINER0  = 0xC0,\n\tGX_BP_REG_TEVALPHACOMBINER0  = 0xC1,\n\tGX_BP_REG_TEVCOLORCOMBINER1  = 0xC2,\n\tGX_BP_REG_TEVALPHACOMBINER1  = 0xC3,\n\tGX_BP_REG_TEVCOLORCOMBINER2  = 0xC4,\n\tGX_BP_REG_TEVALPHACOMBINER2  = 0xC5,\n\tGX_BP_REG_TEVCOLORCOMBINER3  = 0xC6,\n\tGX_BP_REG_TEVALPHACOMBINER3  = 0xC7,\n\tGX_BP_REG_TEVCOLORCOMBINER4  = 0xC8,\n\tGX_BP_REG_TEVALPHACOMBINER4  = 0xC9,\n\tGX_BP_REG_TEVCOLORCOMBINER5  = 0xCA,\n\tGX_BP_REG_TEVALPHACOMBINER5  = 0xCB,\n\tGX_BP_REG_TEVCOLORCOMBINER6  = 0xCC,\n\tGX_BP_REG_TEVALPHACOMBINER6  = 0xCD,\n\tGX_BP_REG_TEVCOLORCOMBINER7  = 0xCE,\n\tGX_BP_REG_TEVALPHACOMBINER7  = 0xCF,\n\tGX_BP_REG_TEVCOLORCOMBINER8  = 0xD0,\n\tGX_BP_REG_TEVALPHACOMBINER8  = 0xD1,\n\tGX_BP_REG_TEVCOLORCOMBINER9  = 0xD2,\n\tGX_BP_REG_TEVALPHACOMBINER9  = 0xD3,\n\tGX_BP_REG_TEVCOLORCOMBINER10 = 0xD4,\n\tGX_BP_REG_TEVALPHACOMBINER10 = 0xD5,\n\tGX_BP_REG_TEVCOLORCOMBINER11 = 0xD6,\n\tGX_BP_REG_TEVALPHACOMBINER11 = 0xD7,\n\tGX_BP_REG_TEVCOLORCOMBINER12 = 0xD8,\n\tGX_BP_REG_TEVALPHACOMBINER12 = 0xD9,\n\tGX_BP_REG_TEVCOLORCOMBINER13 = 0xDA,\n\tGX_BP_REG_TEVALPHACOMBINER13 = 0xDB,\n\tGX_BP_REG_TEVCOLORCOMBINER14 = 0xDC,\n\tGX_BP_REG_TEVALPHACOMBINER14 = 0xDD,\n\tGX_BP_REG_TEVCOLORCOMBINER15 = 0xDE,\n\tGX_BP_REG_TEVALPHACOMBINER15 = 0xDF,\n\n\t// TEV registers\n\tGX_BP_REG_TEVREG0LO = 0xE0,\n\tGX_BP_REG_TEVREG0HI = 0xE1,\n\tGX_BP_REG_TEVREG1LO = 0xE2,\n\tGX_BP_REG_TEVREG1HI = 0xE3,\n\tGX_BP_REG_TEVREG2LO = 0xE4,\n\tGX_BP_REG_TEVREG2HI = 0xE5,\n\tGX_BP_REG_TEVREG3LO = 0xE6,\n\tGX_BP_REG_TEVREG3HI = 0xE7,\n\n\t// fog registers\n\tGX_BP_REG_FOGRANGE   = 0xE8,\n\tGX_BP_REG_FOGRANGEK0 = 0xE9,\n\tGX_BP_REG_FOGRANGEK1 = 0xEA,\n\tGX_BP_REG_FOGRANGEK2 = 0xEB,\n\tGX_BP_REG_FOGRANGEK3 = 0xEC,\n\tGX_BP_REG_FOGRANGEK4 = 0xED,\n\tGX_BP_REG_FOGPARAM0  = 0xEE,\n\tGX_BP_REG_FOGPARAM1  = 0xEF,\n\tGX_BP_REG_FOGPARAM2  = 0xF0,\n\tGX_BP_REG_FOGPARAM3  = 0xF1,\n\tGX_BP_REG_FOGCOLOR   = 0xF2,\n\n\t// performance manip registers\n\tGX_BP_REG_ALPHACOMPARE = 0xF3,\n\tGX_BP_REG_ZTEXTURE0    = 0xF4,\n\tGX_BP_REG_ZTEXTURE1    = 0xF5,\n\n\t// TEV K selectors\n\tGX_BP_REG_TEVKSEL0 = 0xF6,\n\tGX_BP_REG_TEVKSEL1 = 0xF7,\n\tGX_BP_REG_TEVKSEL2 = 0xF8,\n\tGX_BP_REG_TEVKSEL3 = 0xF9,\n\tGX_BP_REG_TEVKSEL4 = 0xFA,\n\tGX_BP_REG_TEVKSEL5 = 0xFB,\n\tGX_BP_REG_TEVKSEL6 = 0xFC,\n\tGX_BP_REG_TEVKSEL7 = 0xFD,\n\n\t// SS mask\n\tGX_BP_REG_SSMASK = 0xFE,\n} GXBPRegs;\n\n// BP locators for fog parameter 0.\ntypedef enum _GXBPFogParam0 {\n\t// A mantissa [21-31]\n\tGX_BP_FOGPARAM0_A_MANT_ST  = 21,\n\tGX_BP_FOGPARAM0_A_MANT_END = 31,\n\n\t// A exponent [13-20]\n\tGX_BP_FOGPARAM0_A_EXP_ST  = 13,\n\tGX_BP_FOGPARAM0_A_EXP_END = 20,\n\n\t// A sign [12-12]\n\tGX_BP_FOGPARAM0_A_SIGN_ST  = 12,\n\tGX_BP_FOGPARAM0_A_SIGN_END = 12,\n} GXBPFogParam0;\n\n// BP locators for fog parameter 1.\ntypedef enum _GXBPFogParam1 {\n\t// B magnitude [8-31]\n\tGX_BP_FOGPARAM1_B_MAG_ST  = 8,\n\tGX_BP_FOGPARAM1_B_MAG_END = 31,\n} GXBPFogParam1;\n\n// BP locators for fog parameter 2.\ntypedef enum _GXBPFogParam2 {\n\t// B shift [27-31]\n\tGX_BP_FOGPARAM2_B_SHIFT_ST  = 27,\n\tGX_BP_FOGPARAM2_B_SHIFT_END = 31,\n} GXBPFogParam2;\n\n// BP locators for fog parameter 3.\ntypedef enum _GXBPFogParam3 {\n\t// C mantissa [21-31]\n\tGX_BP_FOGPARAM3_C_MANT_ST  = 21,\n\tGX_BP_FOGPARAM3_C_MANT_END = 31,\n\n\t// C exponent [13-20]\n\tGX_BP_FOGPARAM3_C_EXP_ST  = 13,\n\tGX_BP_FOGPARAM3_C_EXP_END = 20,\n\n\t// C sign [12-12]\n\tGX_BP_FOGPARAM3_C_SIGN_ST  = 12,\n\tGX_BP_FOGPARAM3_C_SIGN_END = 12,\n\n\t// Projection [11]\n\tGX_BP_FOGPARAM3_PROJ_ST  = 11,\n\tGX_BP_FOGPARAM3_PROJ_END = 11,\n\n\t// F select [8-10]\n\tGX_BP_FOGPARAM3_FSEL_ST  = 8,\n\tGX_BP_FOGPARAM3_FSEL_END = 10,\n} GXBPFogParam3;\n\n// BP locators for fog color.\ntypedef enum _GXBPFogColor {\n\t// RGB components of color [8-31]\n\tGX_BP_FOGCOLOR_RGB_ST  = 8,\n\tGX_BP_FOGCOLOR_RGB_END = 31,\n} GXBPFogColor;\n\n// BP locators for fog range.\ntypedef enum _GXBPFogRange {\n\t// Center [22-31]\n\tGX_BP_FOGRANGE_CENTER_ST  = 22,\n\tGX_BP_FOGRANGE_CENTER_END = 31,\n\n\t// Enabled [21-21]\n\tGX_BP_FOGRANGE_ENABLED_ST  = 21,\n\tGX_BP_FOGRANGE_ENABLED_END = 21,\n} GXBPFogRange;\n\n// BP locators for fog range K.\ntypedef enum _GXBPFogRangeK {\n\t// Hi [20-31]\n\tGX_BP_FOGRANGEK_HI_ST  = 20,\n\tGX_BP_FOGRANGEK_HI_END = 31,\n\n\t// Lo [8-19]\n\tGX_BP_FOGRANGEK_LO_ST  = 8,\n\tGX_BP_FOGRANGEK_LO_END = 19,\n} GXBPFogRangeK;\n\n// BP locators for blend mode.\ntypedef enum _GXBPBlendMode {\n\t// Blend enable [31-31]\n\tGX_BP_BLENDMODE_ENABLE_ST  = 31,\n\tGX_BP_BLENDMODE_ENABLE_END = 31,\n\n\t// Logic operation enable [30-30]\n\tGX_BP_BLENDMODE_LOGIC_OP_ST  = 30,\n\tGX_BP_BLENDMODE_LOGIC_OP_END = 30,\n\n\t// Dither [29-29]\n\tGX_BP_BLENDMODE_DITHER_ST  = 29,\n\tGX_BP_BLENDMODE_DITHER_END = 29,\n\n\t// Color update [28-28]\n\tGX_BP_BLENDMODE_COLOR_UPDATE_ST  = 28,\n\tGX_BP_BLENDMODE_COLOR_UPDATE_END = 28,\n\n\t// Alpha update [27-27]\n\tGX_BP_BLENDMODE_ALPHA_UPDATE_ST  = 27,\n\tGX_BP_BLENDMODE_ALPHA_UPDATE_END = 27,\n\n\t// Destination factor [24-26]\n\tGX_BP_BLENDMODE_DSTFACTOR_ST  = 24,\n\tGX_BP_BLENDMODE_DSTFACTOR_END = 26,\n\n\t// Source factor [21-23]\n\tGX_BP_BLENDMODE_SRCFACTOR_ST  = 21,\n\tGX_BP_BLENDMODE_SRCFACTOR_END = 23,\n\n\t// Subtract [20-20]\n\tGX_BP_BLENDMODE_SUBTRACT_ST  = 20,\n\tGX_BP_BLENDMODE_SUBTRACT_END = 20,\n\n\t// Logic mode [16-19]\n\tGX_BP_BLENDMODE_LOGICMODE_ST  = 16,\n\tGX_BP_BLENDMODE_LOGICMODE_END = 19,\n} GXBPBlendMode;\n\n// BP locators for Z mode.\ntypedef enum _GXBPZMode {\n\t// Test enable [31-31]\n\tGX_BP_ZMODE_TEST_ENABLE_ST  = 31,\n\tGX_BP_ZMODE_TEST_ENABLE_END = 31,\n\n\t// Compare [28-30]\n\tGX_BP_ZMODE_COMPARE_ST  = 28,\n\tGX_BP_ZMODE_COMPARE_END = 30,\n\n\t// Update enable [27-27]\n\tGX_BP_ZMODE_UPDATE_ENABLE_ST  = 27,\n\tGX_BP_ZMODE_UPDATE_ENABLE_END = 27,\n} GXBPZMode;\n\n// BP locators for Z control.\ntypedef enum _GXBPZControl {\n\t// Pixel format [29-31]\n\tGX_BP_ZCONTROL_PIXEL_FMT_ST  = 29,\n\tGX_BP_ZCONTROL_PIXEL_FMT_END = 31,\n\n\t// Z format [26-28]\n\tGX_BP_ZCONTROL_Z_FMT_ST  = 26,\n\tGX_BP_ZCONTROL_Z_FMT_END = 28,\n\n\t// Whether to do Z-buffering before or after texturing [25-25]\n\tGX_BP_ZCONTROL_BEFORE_TEX_ST  = 25,\n\tGX_BP_ZCONTROL_BEFORE_TEX_END = 25,\n} GXBPZControl;\n\n// BP locators for destination alpha.\ntypedef enum _GXBPDstAlpha {\n\t// Alpha [24-31]\n\tGX_BP_DSTALPHA_ALPHA_ST  = 24,\n\tGX_BP_DSTALPHA_ALPHA_END = 31,\n\n\t// Enable [23-23]\n\tGX_BP_DSTALPHA_ENABLE_ST  = 23,\n\tGX_BP_DSTALPHA_ENABLE_END = 23,\n\n\t// YUV format [21-22]\n\tGX_BP_DSTALPHA_YUV_FMT_ST  = 21,\n\tGX_BP_DSTALPHA_YUV_FMT_END = 22,\n} GXBPDstAlpha;\n\n// BP locators for field mask.\ntypedef enum _GXBPFieldMask {\n\t// Whether to write odd fields to the EFB [31-31]\n\tGX_BP_FIELDMASK_ODD_ST  = 31,\n\tGX_BP_FIELDMASK_ODD_END = 31,\n\n\t// Whether to write even fields to the EFB [30-30]\n\tGX_BP_FIELDMASK_EVEN_ST  = 30,\n\tGX_BP_FIELDMASK_EVEN_END = 30,\n} GXBPFieldMask;\n\n// BP locators for line and point settings.\ntypedef enum _GXBPLinePtWidth {\n\t// Line size/width [24-31]\n\tGX_BP_LINEPTWIDTH_LINESZ_ST  = 24,\n\tGX_BP_LINEPTWIDTH_LINESZ_END = 31,\n\n\t// Point size [16-23]\n\tGX_BP_LINEPTWIDTH_POINTSZ_ST  = 16,\n\tGX_BP_LINEPTWIDTH_POINTSZ_END = 23,\n\n\t// Line offset [13-15]\n\tGX_BP_LINEPTWIDTH_LINEOFS_ST  = 13,\n\tGX_BP_LINEPTWIDTH_LINEOFS_END = 15,\n\n\t// Point offset [10-12]\n\tGX_BP_LINEPTWIDTH_POINTOFS_ST  = 10,\n\tGX_BP_LINEPTWIDTH_POINTOFS_END = 12,\n\n\t// Interlacing adjustment for aspect ratio [9-9]\n\tGX_BP_LINEPTWIDTH_ADJUST_ST  = 9,\n\tGX_BP_LINEPTWIDTH_ADJUST_END = 9,\n} GXBPLinePtWidth;\n\n// Miscellaneous token types.\ntypedef enum _GXMiscToken {\n\tGX_MT_NULL               = 0,\n\tGX_MT_XF_FLUSH           = 1,\n\tGX_MT_DL_SAVE_CONTEXT    = 2,\n\tGX_MT_ABORT_WAIT_COPYOUT = 3,\n} GXMiscToken;\n\n// Transform memory types.\ntypedef enum _GXXfMem {\n\tGX_XF_MEM_POSMTX     = 0x000, // position coord matrix\n\tGX_XF_MEM_NRMMTX     = 0x400, // normal coord matrix\n\tGX_XF_MEM_DUALTEXMTX = 0x500, // dual texture matrix\n\tGX_XF_MEM_LIGHTOBJ   = 0x600, // light object\n} GXXfMem;\n\n// BP locators for top-left scissor.\ntypedef enum _GXBPScissorTL {\n\t// Top component [21-31]\n\tGX_BP_SCISSORTL_TOP_ST  = 21,\n\tGX_BP_SCISSORTL_TOP_END = 31,\n\n\t// Left component [9-19]\n\tGX_BP_SCISSORTL_LEFT_ST  = 9,\n\tGX_BP_SCISSORTL_LEFT_END = 19,\n} GXBPScissorTL;\n\n// BP locators for bottom-right scissor.\ntypedef enum _GXBPScissorBR {\n\t// Bottom component [21-31]\n\tGX_BP_SCISSORBR_BOT_ST  = 21,\n\tGX_BP_SCISSORBR_BOT_END = 31,\n\n\t// Right component [9-19]\n\tGX_BP_SCISSORBR_RIGHT_ST  = 9,\n\tGX_BP_SCISSORBR_RIGHT_END = 19,\n} GXBPScissorBR;\n\n// BP locators for scissor offset.\ntypedef enum _GXBPScissorOffset {\n\t// X offset [22-31]\n\tGX_BP_SCISSOROFS_OX_ST  = 22,\n\tGX_BP_SCISSOROFS_OX_END = 31,\n\n\t// Y offset [12-21]\n\tGX_BP_SCISSOROFS_OY_ST  = 12,\n\tGX_BP_SCISSOROFS_OY_END = 21,\n} GXBPScissorOffset;\n\n// Perf-0 types.\ntypedef enum _GXPerf0 {\n\tGX_PERF0_VERTICES      = 0,\n\tGX_PERF0_CLIP_VTX      = 1,\n\tGX_PERF0_CLIP_CLKS     = 2,\n\tGX_PERF0_XF_WAIT_IN    = 3,\n\tGX_PERF0_XF_WAIT_OUT   = 4,\n\tGX_PERF0_XF_XFRM_CLKS  = 5,\n\tGX_PERF0_XF_LIT_CLKS   = 6,\n\tGX_PERF0_XF_BOT_CLKS   = 7,\n\tGX_PERF0_XF_REGLD_CLKS = 8,\n\tGX_PERF0_XF_REGRD_CLKS = 9,\n\tGX_PERF0_CLIP_RATIO    = 10,\n\n\tGX_PERF0_TRIANGLES           = 11,\n\tGX_PERF0_TRIANGLES_CULLED    = 12,\n\tGX_PERF0_TRIANGLES_PASSED    = 13,\n\tGX_PERF0_TRIANGLES_SCISSORED = 14,\n\tGX_PERF0_TRIANGLES_0TEX      = 15,\n\tGX_PERF0_TRIANGLES_1TEX      = 16,\n\tGX_PERF0_TRIANGLES_2TEX      = 17,\n\tGX_PERF0_TRIANGLES_3TEX      = 18,\n\tGX_PERF0_TRIANGLES_4TEX      = 19,\n\tGX_PERF0_TRIANGLES_5TEX      = 20,\n\tGX_PERF0_TRIANGLES_6TEX      = 21,\n\tGX_PERF0_TRIANGLES_7TEX      = 22,\n\tGX_PERF0_TRIANGLES_8TEX      = 23,\n\tGX_PERF0_TRIANGLES_0CLR      = 24,\n\tGX_PERF0_TRIANGLES_1CLR      = 25,\n\tGX_PERF0_TRIANGLES_2CLR      = 26,\n\n\tGX_PERF0_QUAD_0CVG    = 27,\n\tGX_PERF0_QUAD_NON0CVG = 28,\n\tGX_PERF0_QUAD_1CVG    = 29,\n\tGX_PERF0_QUAD_2CVG    = 30,\n\tGX_PERF0_QUAD_3CVG    = 31,\n\tGX_PERF0_QUAD_4CVG    = 32,\n\tGX_PERF0_AVG_QUAD_CNT = 33,\n\n\tGX_PERF0_CLOCKS = 34,\n\tGX_PERF0_NONE   = 35,\n} GXPerf0;\n\n// Perf-1 types.\ntypedef enum _GXPerf1 {\n\tGX_PERF1_TEXELS      = 0,\n\tGX_PERF1_TX_IDLE     = 1,\n\tGX_PERF1_TX_REGS     = 2,\n\tGX_PERF1_TX_MEMSTALL = 3,\n\tGX_PERF1_TC_CHECK1_2 = 4,\n\tGX_PERF1_TC_CHECK3_4 = 5,\n\tGX_PERF1_TC_CHECK5_6 = 6,\n\tGX_PERF1_TC_CHECK7_8 = 7,\n\tGX_PERF1_TC_MISS     = 8,\n\n\tGX_PERF1_VC_ELEMQ_FULL    = 9,\n\tGX_PERF1_VC_MISSQ_FULL    = 10,\n\tGX_PERF1_VC_MEMREQ_FULL   = 11,\n\tGX_PERF1_VC_STATUS7       = 12,\n\tGX_PERF1_VC_MISSREP_FULL  = 13,\n\tGX_PERF1_VC_STREAMBUF_LOW = 14,\n\tGX_PERF1_VC_ALL_STALLS    = 15,\n\tGX_PERF1_VERTICES         = 16,\n\n\tGX_PERF1_FIFO_REQ    = 17,\n\tGX_PERF1_CALL_REQ    = 18,\n\tGX_PERF1_VC_MISS_REQ = 19,\n\tGX_PERF1_CP_ALL_REQ  = 20,\n\n\tGX_PERF1_CLOCKS = 21,\n\tGX_PERF1_NONE   = 22,\n} GXPerf1;\n\n// Vertex cache perf types.\ntypedef enum _GXVCachePerf {\n\tGX_VC_POS  = 0,\n\tGX_VC_NRM  = 1,\n\tGX_VC_CLR0 = 2,\n\tGX_VC_CLR1 = 3,\n\tGX_VC_TEX0 = 4,\n\tGX_VC_TEX1 = 5,\n\tGX_VC_TEX2 = 6,\n\tGX_VC_TEX3 = 7,\n\tGX_VC_TEX4 = 8,\n\tGX_VC_TEX5 = 9,\n\tGX_VC_TEX6 = 10,\n\tGX_VC_TEX7 = 11,\n\n\tGX_VC_ALL = 15\n} GXVCachePerf;\n\n#endif /* GXENUM_H *//* end \"dolphin/gx/GXEnum.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct _GXVtxDescList {\n    /* 0x0 */ GXAttr attr;\n    /* 0x4 */ GXAttrType type;\n} GXVtxDescList;  // Size: 0x08\n\ntypedef struct _GXVtxAttrFmtList {\n    /* 0x00 */ GXAttr mAttrib;\n    /* 0x04 */ GXCompCnt mCompCnt;\n    /* 0x08 */ GXCompType mCompType;\n    /* 0x0C */ u8 mCompShift;\n} GXVtxAttrFmtList;  // Size: 0x10\n\nvoid GXSetVtxDesc(GXAttr attr, GXAttrType type);\nvoid GXSetVtxDescv(GXVtxDescList* list);\nvoid __GXSetVCD(void);\nvoid __GXCalculateVLim(void);\nvoid GXClearVtxDesc(void);\nvoid GXSetVtxAttrFmt(GXVtxFmt fmt, GXAttr attr, GXCompCnt cnt, GXCompType type, u8);\nvoid GXSetVtxAttrFmtv(GXVtxFmt fmt, GXVtxAttrFmtList* list);\nvoid __GXSetVAT(void);\nvoid GXSetArray(GXAttr attr, void* base, u8);\nvoid GXInvalidateVtxCache(void);\nvoid GXSetTexCoordGen2(GXTexCoordID dst, GXTexGenType type, GXTexGenSrc src, u32 mtx,\n                       GXBool renormalize, u32 pt_mtx);\nvoid GXSetNumTexGens(u8 numTexGens);\n\nvoid GXGetVtxAttrFmtv(GXVtxFmt param_0, GXVtxAttrFmtList* param_1);\nvoid GXGetVtxAttrFmt(GXVtxFmt param_0, int param_1, GXCompCnt* param_2, GXCompType* param_3,\n                     u8* param_4);\nvoid GXGetVtxDescv(GXVtxDescList* attrPtr);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* GXATTR_H */\n/* end \"dolphin/gx/GXAttr.h\" */\n/* \"include/dolphin/gx/GX.h\" line 4 \"dolphin/gx/GXBump.h\" */\n#ifndef GXBUMP_H\n#define GXBUMP_H\n\n/* \"include/dolphin/gx/GXBump.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXSetTevIndirect(GXTevStageID tevStage, GXIndTexStageID texStage, GXIndTexFormat texFmt,\n                      GXIndTexBiasSel biasSel, GXIndTexMtxID mtxID, GXIndTexWrap wrapS,\n                      GXIndTexWrap wrapT, u8 addPrev, u8 utcLod, GXIndTexAlphaSel alphaSel);\nvoid GXSetIndTexMtx(GXIndTexMtxID mtxID, f32 offset[6], s8 scale_exp);\nvoid GXSetIndTexCoordScale(GXIndTexStageID texStage, GXIndTexScale scaleS, GXIndTexScale scaleT);\nvoid GXSetIndTexOrder(GXIndTexStageID stage, GXTexCoordID coord, GXTexMapID map);\nvoid GXSetNumIndStages(u8 num);\nvoid GXSetTevDirect(GXTevStageID stage);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* GXBUMP_H */\n/* end \"dolphin/gx/GXBump.h\" */\n/* \"include/dolphin/gx/GX.h\" line 5 \"dolphin/gx/GXDisplayList.h\" */\n#ifndef GXDISPLAYLIST_H\n#define GXDISPLAYLIST_H\n\n/* \"include/dolphin/gx/GXDisplayList.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXBeginDisplayList(void* list, u32 capacity);\nvoid GXEndDisplayList(void);\nvoid GXCallDisplayList(void* list, u32 nbytes);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* GXDISPLAYLIST_H */\n/* end \"dolphin/gx/GXDisplayList.h\" */\n/* \"include/dolphin/gx/GX.h\" line 6 \"dolphin/gx/GXFifo.h\" */\n#ifndef GXFIFO_H\n#define GXFIFO_H\n\n/* \"include/dolphin/gx/GXFifo.h\" line 3 \"dolphin/gx/GXStruct.h\" */\n#ifndef GXSTRUCT_H\n#define GXSTRUCT_H\n\n/* \"include/dolphin/gx/GXStruct.h\" line 3 \"global.h\" */\n#ifndef _global_h_\n#define _global_h_\n\n/* \"include/global.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#define ARRAY_SIZE(o) (sizeof((o)) / sizeof(*(o)))\n\n// Align X to the previous N bytes (N must be power of two)\n#define ALIGN_PREV(X, N) ((X) & ~((N)-1))\n// Align X to the next N bytes (N must be power of two)\n#define ALIGN_NEXT(X, N) ALIGN_PREV(((X) + (N)-1), N)\n#define IS_ALIGNED(X, N) (((X) & ((N)-1)) == 0)\n#define IS_NOT_ALIGNED(X, N) (((X) & ((N)-1)) != 0)\n\n#define JUT_EXPECT(...)\n#define ASSERT(...)\n#define FLAG_ON(V, F) (((V) & (F)) == 0)\n\n#define FLOAT_LABEL(x) (*(f32*)&x)\n#define DOUBLE_LABEL(x) (*(f64*)&x)\n\n#define _SDA_BASE_(dummy) 0\n#define _SDA2_BASE_(dummy) 0\n\n#ifndef IN_VSCODE_EDITOR\n#define GLUE(a, b) a##b\n#define GLUE2(a, b) GLUE(a, b)\n#define STATIC_ASSERT(cond) typedef char GLUE2(static_assertion_failed, __LINE__)[(cond) ? 1 : -1]\n#else\n#define STATIC_ASSERT(...)\n#endif\n\n// hack to make functions that return comparisons as int match\nextern int __cntlzw(unsigned int);\ninline BOOL checkEqual(s32 a, s32 b) {\n    return (u32)__cntlzw(a - b) >> 5;\n}\n\n#endif\n/* end \"global.h\" */\n\ntypedef struct _GXColor {\n    /* 0x0 */ u8 r;\n    /* 0x1 */ u8 g;\n    /* 0x2 */ u8 b;\n    /* 0x3 */ u8 a;\n} GXColor;\n\ntypedef struct _GXColorS10 {\n    /* 0x0 */ s16 r;\n    /* 0x2 */ s16 g;\n    /* 0x4 */ s16 b;\n    /* 0x6 */ s16 a;\n} GXColorS10;\n\ntypedef struct _GXRenderModeObj {\n    /* 0x00 */ s32 vi_tv_mode;\n    /* 0x04 */ u16 fb_width;\n    /* 0x06 */ u16 efb_height;\n    /* 0x08 */ u16 xfb_height;\n    /* 0x0A */ u16 vi_x_origin;\n    /* 0x0C */ u16 vi_y_origin;\n    /* 0x0E */ u16 vi_width;\n    /* 0x10 */ u16 vi_height;\n    /* 0x14 */ s32 xfb_mode;\n    /* 0x18 */ u8 field_rendering;\n    /* 0x19 */ u8 antialiasing;\n    /* 0x1A */ u8 sample_pattern[12][2];\n    /* 0x32 */ u8 vfilter[7];\n} GXRenderModeObj;\n\nSTATIC_ASSERT(sizeof(GXRenderModeObj) == 60);\n\ntypedef struct _GXTexObj {\n    /* 0x00 */ u32 texture_filter;\n    /* 0x04 */ u32 texture_lod;\n    /* 0x08 */ u32 texture_size;\n    /* 0x0C */ u32 texture_address;\n    /* 0x10 */ u32 user_data;\n    /* 0x14 */ u32 texture_format;\n    /* 0x18 */ u32 tlut_name;\n    /* 0x1C */ u16 texture_time_count;\n    /* 0x1E */ u8 texture_tile_type;\n    /* 0x1F */ u8 texture_flags;\n} GXTexObj;\n\ntypedef struct _GXTlutObj {\n    /* 0x0 */ u32 format;\n    /* 0x4 */ u32 address;\n    /* 0x8 */ u32 numEntries;\n} GXTlutObj;\n\ntypedef struct _GXLightObj {\n    /* 0x00 */ u8 field_0x0[0xc];\n    /* 0x0C */ GXColor color;\n    /* 0x10 */ f32 a0;\n    /* 0x14 */ f32 a1;\n    /* 0x18 */ f32 a2;\n    /* 0x1C */ f32 k0;\n    /* 0x20 */ f32 k1;\n    /* 0x24 */ f32 k2;\n    /* 0x28 */ f32 posX;\n    /* 0x2C */ f32 posY;\n    /* 0x30 */ f32 posZ;\n    /* 0x34 */ f32 dirX;\n    /* 0x38 */ f32 dirY;\n    /* 0x3C */ f32 dirZ;\n} GXLightObj;\n\ntypedef struct _GXFogAdjTable {\n    /* 0x0 */ u16 fogVals[10];\n} GXFogAdjTable;\n\ntypedef struct _GXFifoObj {\n    /* 0x00 */ void* base;\n    /* 0x04 */ void* end;\n    /* 0x08 */ u32 size;\n    /* 0x0C */ u32 high_wtrmark;\n    /* 0x10 */ u32 low_wtrmark;\n    /* 0x14 */ void* read_ptr;\n    /* 0x18 */ void* write_ptr;\n    /* 0x1C */ s32 rw_dst;\n    /* 0x20 */ u8 fifo_wrap;\n    /* 0x21 */ u8 cpu_fifo_ready;\n    /* 0x22 */ u8 gp_fifo_ready;\n    /* 0x23 */ u8 field_0x23[93];\n} GXFifoObj;  // Size: 0x80\n\ntypedef struct _GXTexRegion {\n    /* 0x00 */ u8 dummy[0x10];\n} GXTexRegion;  // Size: 0x10\n\ntypedef struct _GXTlutRegion {\n    /* 0x00 */ u8 dummy[0x10];\n} GXTlutRegion;  // Size: 0x10\n\n#endif /* GXSTRUCT_H */\n/* end \"dolphin/gx/GXStruct.h\" */\n/* \"include/dolphin/gx/GXFifo.h\" line 4 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n/* \"include/dolphin/gx/GXFifo.h\" line 5 \"dolphin/os/OSThread.h\" */\n#ifndef OSTHREAD_H\n#define OSTHREAD_H\n\n/* \"include/dolphin/os/OSThread.h\" line 3 \"dolphin/os/OSContext.h\" */\n#ifndef OSCONTEXT_H\n#define OSCONTEXT_H\n\n/* \"include/dolphin/os/OSContext.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define __OS_CONTEXT_FRAME 768\n\n#define OS_CONTEXT_R0 0\n#define OS_CONTEXT_R1 4\n#define OS_CONTEXT_R2 8\n#define OS_CONTEXT_R3 12\n#define OS_CONTEXT_R4 16\n#define OS_CONTEXT_R5 20\n#define OS_CONTEXT_R6 24\n#define OS_CONTEXT_R7 28\n#define OS_CONTEXT_R8 32\n#define OS_CONTEXT_R9 36\n#define OS_CONTEXT_R10 40\n#define OS_CONTEXT_R11 44\n#define OS_CONTEXT_R12 48\n#define OS_CONTEXT_R13 52\n#define OS_CONTEXT_R14 56\n#define OS_CONTEXT_R15 60\n#define OS_CONTEXT_R16 64\n#define OS_CONTEXT_R17 68\n#define OS_CONTEXT_R18 72\n#define OS_CONTEXT_R19 76\n#define OS_CONTEXT_R20 80\n#define OS_CONTEXT_R21 84\n#define OS_CONTEXT_R22 88\n#define OS_CONTEXT_R23 92\n#define OS_CONTEXT_R24 96\n#define OS_CONTEXT_R25 100\n#define OS_CONTEXT_R26 104\n#define OS_CONTEXT_R27 108\n#define OS_CONTEXT_R28 112\n#define OS_CONTEXT_R29 116\n#define OS_CONTEXT_R30 120\n#define OS_CONTEXT_R31 124\n\n#define OS_CONTEXT_CR 128\n#define OS_CONTEXT_LR 132\n#define OS_CONTEXT_CTR 136\n#define OS_CONTEXT_XER 140\n\n#define OS_CONTEXT_FPR0 144\n#define OS_CONTEXT_FPR1 152\n#define OS_CONTEXT_FPR2 160\n#define OS_CONTEXT_FPR3 168\n#define OS_CONTEXT_FPR4 176\n#define OS_CONTEXT_FPR5 184\n#define OS_CONTEXT_FPR6 192\n#define OS_CONTEXT_FPR7 200\n#define OS_CONTEXT_FPR8 208\n#define OS_CONTEXT_FPR9 216\n#define OS_CONTEXT_FPR10 224\n#define OS_CONTEXT_FPR11 232\n#define OS_CONTEXT_FPR12 240\n#define OS_CONTEXT_FPR13 248\n#define OS_CONTEXT_FPR14 256\n#define OS_CONTEXT_FPR15 264\n#define OS_CONTEXT_FPR16 272\n#define OS_CONTEXT_FPR17 280\n#define OS_CONTEXT_FPR18 288\n#define OS_CONTEXT_FPR19 296\n#define OS_CONTEXT_FPR20 304\n#define OS_CONTEXT_FPR21 312\n#define OS_CONTEXT_FPR22 320\n#define OS_CONTEXT_FPR23 328\n#define OS_CONTEXT_FPR24 336\n#define OS_CONTEXT_FPR25 344\n#define OS_CONTEXT_FPR26 352\n#define OS_CONTEXT_FPR27 360\n#define OS_CONTEXT_FPR28 368\n#define OS_CONTEXT_FPR29 376\n#define OS_CONTEXT_FPR30 384\n#define OS_CONTEXT_FPR31 392\n\n#define OS_CONTEXT_FPSCR 400\n\n#define OS_CONTEXT_SRR0 408\n#define OS_CONTEXT_SRR1 412\n\n#define OS_CONTEXT_MODE 416\n#define OS_CONTEXT_STATE 418\n\n#define OS_CONTEXT_GQR0 420\n#define OS_CONTEXT_GQR1 424\n#define OS_CONTEXT_GQR2 428\n#define OS_CONTEXT_GQR3 432\n#define OS_CONTEXT_GQR4 436\n#define OS_CONTEXT_GQR5 440\n#define OS_CONTEXT_GQR6 444\n#define OS_CONTEXT_GQR7 448\n#define __OSCONTEXT_PADDING 452\n\n#define OS_CONTEXT_PSF0 456\n#define OS_CONTEXT_PSF1 464\n#define OS_CONTEXT_PSF2 472\n#define OS_CONTEXT_PSF3 480\n#define OS_CONTEXT_PSF4 488\n#define OS_CONTEXT_PSF5 496\n#define OS_CONTEXT_PSF6 504\n#define OS_CONTEXT_PSF7 512\n#define OS_CONTEXT_PSF8 520\n#define OS_CONTEXT_PSF9 528\n#define OS_CONTEXT_PSF10 536\n#define OS_CONTEXT_PSF11 544\n#define OS_CONTEXT_PSF12 552\n#define OS_CONTEXT_PSF13 560\n#define OS_CONTEXT_PSF14 568\n#define OS_CONTEXT_PSF15 576\n#define OS_CONTEXT_PSF16 584\n#define OS_CONTEXT_PSF17 592\n#define OS_CONTEXT_PSF18 600\n#define OS_CONTEXT_PSF19 608\n#define OS_CONTEXT_PSF20 616\n#define OS_CONTEXT_PSF21 624\n#define OS_CONTEXT_PSF22 632\n#define OS_CONTEXT_PSF23 640\n#define OS_CONTEXT_PSF24 648\n#define OS_CONTEXT_PSF25 656\n#define OS_CONTEXT_PSF26 664\n#define OS_CONTEXT_PSF27 672\n#define OS_CONTEXT_PSF28 680\n#define OS_CONTEXT_PSF29 688\n#define OS_CONTEXT_PSF30 696\n#define OS_CONTEXT_PSF31 704\n#define OS_CONTEXT_STATE_EXC 0x02u\n\n#define OS_CONTEXT_STATE_FPSAVED 0x01u\n\ntypedef struct OSContext {\n    /* 0x000 */ u32 gpr[32];\n    /* 0x080 */ u32 cr;\n    /* 0x084 */ u32 lr;\n    /* 0x088 */ u32 ctr;\n    /* 0x08C */ u32 xer;\n    /* 0x090 */ f64 fpr[32];\n    /* 0x190 */ u32 field_0x190;\n    /* 0x194 */ u32 fpscr;\n    /* 0x198 */ u32 srr0;\n    /* 0x19C */ u32 srr1;\n    /* 0x1A0 */ u16 mode;\n    /* 0x1A2 */ u16 state;\n    /* 0x1A4 */ u32 gqr[8];\n    /* 0x1C4 */ f64 ps[32];\n} OSContext;\n\nOSContext* OS_CURRENT_CONTEXT : 0x800000D4;\nOSContext* OS_CURRENT_FPU_CONTEXT : 0x800000D8;\n\nvoid __OSLoadFPUContext(void);\nvoid __OSSaveFPUContext(s32 unused0, s32 unused1, OSContext* context);\nvoid OSSaveFPUContext(OSContext* context);\nvoid OSSetCurrentContext(OSContext* context);\nOSContext* OSGetCurrentContext(void);\nu32 OSSaveContext(OSContext* context);\nvoid OSLoadContext(OSContext* context);\nvoid OSClearContext(OSContext* context);\nvoid OSInitContext(OSContext* context, u32 pc, u32 lr);\nvoid OSDumpContext(OSContext* context);\nstatic void OSSwitchFPUContext(u8 err, OSContext* context);\nvoid __OSContextInit(void);\nvoid OSFillFPUContext(OSContext* context);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSCONTEXT_H */\n/* end \"dolphin/os/OSContext.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef u16 OSThreadState;\ntypedef s32 OSPriority;  //  0 highest, 31 lowest\n\n#define OS_THREAD_STATE_UNINITIALIZED 0\n#define OS_THREAD_STATE_READY 1\n#define OS_THREAD_STATE_RUNNING 2\n#define OS_THREAD_STATE_WAITING 4\n#define OS_THREAD_STATE_DEAD 8\n\n#define OS_THREAD_ATTR_DETACH 0x0001u\n\n#define OS_THREAD_STACK_MAGIC 0xDEADBABE\n\n#define OS_PRIORITY_MIN 0   // highest\n#define OS_PRIORITY_MAX 31  // lowest\n#define OS_PRIORITY_IDLE OS_PRIORITY_MAX\n\ntypedef struct OSThread OSThread;\ntypedef struct OSThreadQueue OSThreadQueue;\ntypedef struct OSThreadLink OSThreadLink;\n\ntypedef struct OSMutex OSMutex;\ntypedef struct OSMutexQueue OSMutexQueue;\ntypedef struct OSMutexLink OSMutexLink;\ntypedef struct OSCond OSCond;\n\nstruct OSThreadLink {\n    OSThread* next;\n    OSThread* prev;\n};\n\nstruct OSThreadQueue {\n    /* 0x0 */ OSThread* head;\n    /* 0x4 */ OSThread* tail;\n};\n\nstruct OSMutexLink {\n    OSMutex* next;\n    OSMutex* prev;\n};\n\nstruct OSMutexQueue {\n    OSMutex* head;\n    OSMutex* tail;\n};\n\nstruct OSThread {\n    OSContext context;\n    OSThreadState state;\n    u16 attributes;\n    s32 suspend_count;\n    s32 effective_priority;\n    u32 base_priority;\n    void* exit_value;\n    OSThreadQueue* queue;\n    OSThreadLink link;\n    OSThreadQueue join_queue;\n    OSMutex* mutex;\n    OSMutexQueue owned_mutexes;\n    OSThreadLink active_threads_link;\n    u8* stack_base;\n    u8* stack_end;\n    u8* error_code;\n    void* data[2];\n};\n\ntypedef void (*OSSwitchThreadCallback)(OSThread* from, OSThread* to);\n\nOSThreadQueue OS_THREAD_QUEUE : 0x800000DC;\nOSThread* OS_CURRENT_THREAD : 0x800000E4;\n\nstatic void DefaultSwitchThreadCallback(OSThread* from, OSThread* to);\nOSSwitchThreadCallback OSSetSwitchThreadCallback(OSSwitchThreadCallback func);\nvoid __OSThreadInit(void);\nvoid OSInitThreadQueue(OSThreadQueue* queue);\nOSThread* OSGetCurrentThread(void);\nBOOL OSIsThreadTerminated(OSThread* thread);\ns32 OSDisableScheduler(void);\ns32 OSEnableScheduler(void);\nstatic void UnsetRun(OSThread* thread);\ns32 __OSGetEffectivePriority(OSThread* thread);\nstatic OSThread* SetEffectivePriority(OSThread* thread, s32 priority);\nvoid __OSPromoteThread(OSThread* thread, s32 priority);\nstatic OSThread* SelectThread(BOOL yield);\nvoid __OSReschedule(void);\nvoid OSYieldThread(void);\nBOOL OSCreateThread(OSThread* thread, void* func, void* param, void* stackBase, u32 stackSize,\n                    s32 priority, u16 attribute);\nvoid OSExitThread(void* exitValue);\nvoid OSCancelThread(OSThread* thread);\nvoid OSDetachThread(OSThread* thread);\ns32 OSResumeThread(OSThread* thread);\ns32 OSSuspendThread(OSThread* thread);\nvoid OSSleepThread(OSThreadQueue* queue);\nvoid OSWakeupThread(OSThreadQueue* queue);\ns32 OSSetThreadPriority(OSThread* thread, s32 priority);\ns32 OSGetThreadPriority(OSThread* thread);\nstatic s32 CheckThreadQueue(OSThreadQueue* thread);\ns32 OSCheckActiveThreads(void);\nstatic void OSClearStack(u8 value);\nextern u8 data_804516D0[8];\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSTHREAD_H */\n/* end \"dolphin/os/OSThread.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef void (*GXBreakPtCallback)(void);\n\nvoid GXInitFifoBase(GXFifoObj* fifo, void* base, u32 size);\nvoid GXInitFifoPtrs(GXFifoObj* fifo, void* read_ptr, void* write_ptr);\nvoid GXSetCPUFifo(GXFifoObj* fifo);\nvoid GXSetGPFifo(GXFifoObj* fifo);\nvoid GXSaveCPUFifo(GXFifoObj* fifo);\nvoid __GXSaveCPUFifoAux(GXFifoObj* fifo);\nvoid GXGetGPStatus(GXBool* overhi, GXBool* underlo, GXBool* read_idle, GXBool* cmd_idle, GXBool* breakpoint);\nvoid* GXGetFifoBase(GXFifoObj* fifo);\nu32 GXGetFifoSize(GXFifoObj* fifo);\nGXBreakPtCallback GXSetBreakPtCallback(GXBreakPtCallback cb);\nvoid __GXFifoInit(void);\nvoid __GXFifoReadEnable(void);\nvoid __GXFifoReadDisable(void);\nvoid __GXFifoLink(u8);\nvoid __GXWriteFifoIntEnable(u32, u32);\nvoid __GXWriteFifoIntReset(u32, u32);\nvoid __GXCleanGPFifo(void);\nOSThread* GXSetCurrentGXThread(void);\nOSThread* GXGetCurrentGXThread(void);\nGXFifoObj* GXGetCPUFifo(void);\nGXFifoObj* GXGetGPFifo(void);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* GXFIFO_H */\n/* end \"dolphin/gx/GXFifo.h\" */\n/* \"include/dolphin/gx/GX.h\" line 7 \"dolphin/gx/GXFrameBuf.h\" */\n#ifndef GXFRAMEBUF_H\n#define GXFRAMEBUF_H\n\n/* \"include/dolphin/gx/GXFrameBuf.h\" line 3 \"dolphin/gx/GXStruct.h\" */\n/* end \"dolphin/gx/GXStruct.h\" */\n/* \"include/dolphin/gx/GXFrameBuf.h\" line 4 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXSetDispCopySrc(u16 left, u16 top, u16 width, u16 height);\nvoid GXSetTexCopySrc(u16 left, u16 top, u16 width, u16 height);\nvoid GXSetDispCopyDst(u16 arg0, u16 arg1);\nvoid GXSetTexCopyDst(u16 width, u16 height, s32 fmt, GXBool mipmap);\nvoid GXSetDispCopyFrame2Field(GXCopyMode mode);\nvoid GXSetCopyClamp(GXFBClamp clamp);\nu16 GXGetNumXfbLines(u32 efb_height, f32 y_scale);\nf32 GXGetYScaleFactor(u16 efb_height, u16 xfb_height);\nu32 GXSetDispCopyYScale(f32 y_scale);\nvoid GXSetCopyClear(GXColor color, u32 clear_z);\nvoid GXSetCopyFilter(GXBool antialias, u8 pattern[12][2], GXBool vf, u8 vfilter[7]);\nvoid GXSetDispCopyGamma(GXGamma gamma);\nvoid GXCopyDisp(void* dst, GXBool clear);\nvoid GXCopyTex(void* dst, GXBool clear);\nvoid GXClearBoundingBox(void);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* GXFRAMEBUF_H */\n/* end \"dolphin/gx/GXFrameBuf.h\" */\n/* \"include/dolphin/gx/GX.h\" line 8 \"dolphin/gx/GXGeometry.h\" */\n#ifndef GXGEOMETRY_H\n#define GXGEOMETRY_H\n\n/* \"include/dolphin/gx/GXGeometry.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid __GXSetDirtyState(void);\nvoid GXBegin(GXPrimitive type, GXVtxFmt fmt, u16 vert_num);\nvoid __GXSendFlushPrim(void);\nvoid GXSetLineWidth(u8 width, GXTexOffset offsets);\nvoid GXSetPointSize(u8 size, GXTexOffset offsets);\nvoid GXEnableTexOffsets(GXTexCoordID coord, GXBool line, GXBool point);\nvoid GXSetCullMode(GXCullMode mode);\nvoid GXSetCoPlanar(GXBool enable);\nvoid __GXSetGenMode(void);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* GXGEOMETRY_H */\n/* end \"dolphin/gx/GXGeometry.h\" */\n/* \"include/dolphin/gx/GX.h\" line 9 \"dolphin/gx/GXLight.h\" */\n#ifndef GXLIGHT_H\n#define GXLIGHT_H\n\n/* \"include/dolphin/gx/GXLight.h\" line 3 \"dolphin/gx/GXStruct.h\" */\n/* end \"dolphin/gx/GXStruct.h\" */\n/* \"include/dolphin/gx/GXLight.h\" line 4 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXInitLightAttn(GXLightObj* obj, f32 a0, f32 a1, f32 a2, f32 k0, f32 k1, f32 k2);\nvoid GXInitLightSpot(GXLightObj* obj, f32 cutoff, GXSpotFn spot_fn);\nvoid GXInitLightDistAttn(GXLightObj* obj, f32 dist, f32 brightness, GXDistAttnFn dist_fn);\nvoid GXInitLightPos(GXLightObj* obj, f32 x, f32 y, f32 z);\nvoid GXInitLightDir(GXLightObj* obj, f32 x, f32 y, f32 z);\nvoid GXInitLightColor(GXLightObj* obj, GXColor color);\nvoid GXLoadLightObjImm(GXLightObj* obj, GXLightID light);\nvoid GXSetChanAmbColor(GXChannelID channel, GXColor color);\nvoid GXSetChanMatColor(GXChannelID channel, GXColor color);\nvoid GXSetNumChans(u8 chan_num);\nvoid GXSetChanCtrl(GXChannelID channel, GXBool enable, GXColorSrc amb_src, GXColorSrc mat_src, u32 light_mask, GXDiffuseFn diff_fn, GXAttnFn attn_fn);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* GXLIGHT_H */\n/* end \"dolphin/gx/GXLight.h\" */\n/* \"include/dolphin/gx/GX.h\" line 10 \"dolphin/gx/GXMisc.h\" */\n#ifndef GXMISC_H\n#define GXMISC_H\n\n/* \"include/dolphin/gx/GXMisc.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXSetMisc(u32 id, u32 value);\nvoid GXFlush(void);\nvoid __GXAbort(void);\nvoid GXAbortFrame(void);\nvoid GXSetDrawDone(void);\nvoid GXDrawDone(void);\nvoid GXPixModeSync(void);\nvoid GXPokeAlphaMode(GXCompare comp, u8 threshold);\nvoid GXPokeAlphaRead(GXAlphaReadMode mode);\nvoid GXPokeAlphaUpdate(GXBool enable_update);\nvoid GXPokeBlendMode(GXBlendMode mode, GXBlendFactor src_factor, GXBlendFactor dst_factor, GXLogicOp op);\nvoid GXPokeColorUpdate(GXBool enable_update);\nvoid GXPokeDstAlpha(GXBool enable, u8 alpha);\nvoid GXPokeDither(GXBool enable);\nvoid GXPokeZMode(GXBool enable_compare, GXCompare comp, GXBool update_enable);\nvoid GXPeekZ(u16 x, u16 y, u32* z);\n\ntypedef void (*GXDrawSyncCallback)(u16 token);\nGXDrawSyncCallback GXSetDrawSyncCallback(GXDrawSyncCallback callback);\n\ntypedef void (*GXDrawDoneCallback)(void);\nGXDrawDoneCallback GXSetDrawDoneCallback(GXDrawDoneCallback callback);\nvoid __GXPEInit(void);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* GXMISC_H */\n/* end \"dolphin/gx/GXMisc.h\" */\n/* \"include/dolphin/gx/GX.h\" line 11 \"dolphin/gx/GXPerf.h\" */\n#ifndef GXPERF_H\n#define GXPERF_H\n\n/* \"include/dolphin/gx/GXPerf.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n/* \"include/dolphin/gx/GXPerf.h\" line 4 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXSetGPMetric(GXPerf0 perf0, GXPerf1 perf1);\nvoid GXClearGPMetric(void);\nvoid GXReadXfRasMetric(u32*, u32*, u32*, u32*);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* GXPERF_H */\n/* end \"dolphin/gx/GXPerf.h\" */\n/* \"include/dolphin/gx/GX.h\" line 12 \"dolphin/gx/GXPixel.h\" */\n#ifndef GXPIXEL_H\n#define GXPIXEL_H\n\n/* \"include/dolphin/gx/GXPixel.h\" line 3 \"dolphin/gx/GXStruct.h\" */\n/* end \"dolphin/gx/GXStruct.h\" */\n/* \"include/dolphin/gx/GXPixel.h\" line 4 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXSetFog(GXFogType type, f32 startZ, f32 endZ, f32 nearZ, f32 farZ, GXColor color);\nvoid GXSetFogRangeAdj(GXBool enable, u16 center, GXFogAdjTable* table);\nvoid GXSetBlendMode(GXBlendMode mode, GXBlendFactor src_factor, GXBlendFactor dst_factor, GXLogicOp op);\nvoid GXSetColorUpdate(GXBool enable_update);\nvoid GXSetAlphaUpdate(GXBool enable_update);\nvoid GXSetZMode(GXBool enable_compare, GXCompare comp, GXBool enable_update);\nvoid GXSetZCompLoc(GXBool z_buf_before_tex);\nvoid GXSetPixelFmt(GXPixelFmt pixel_fmt, GXZFmt16 z_fmt);\nvoid GXSetDither(GXBool enable_dither);\nvoid GXSetDstAlpha(GXBool enable, u8 alpha);\nvoid GXSetFieldMask(GXBool odd_mask, GXBool even_mask);\nvoid GXSetFieldMode(GXBool field_mode, GXBool half_aspect_ratio);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* GXPIXEL_H */\n/* end \"dolphin/gx/GXPixel.h\" */\n/* \"include/dolphin/gx/GX.h\" line 13 \"dolphin/gx/GXTev.h\" */\n#ifndef GXTEV_H\n#define GXTEV_H\n\n/* \"include/dolphin/gx/GXTev.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n/* \"include/dolphin/gx/GXTev.h\" line 4 \"dolphin/gx/GXStruct.h\" */\n/* end \"dolphin/gx/GXStruct.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXSetTevOp(GXTevStageID id, GXTevMode mode);\nvoid GXSetTevColorIn(GXTevStageID stage, GXTevColorArg a, GXTevColorArg b, GXTevColorArg c,\n                     GXTevColorArg d);\nvoid GXSetTevAlphaIn(GXTevStageID stage, GXTevAlphaArg a, GXTevAlphaArg b, GXTevAlphaArg c,\n                     GXTevAlphaArg d);\nvoid GXSetTevColorOp(GXTevStageID stage, GXTevOp op, GXTevBias bias, GXTevScale scale, GXBool clamp,\n                     GXTevRegID out_reg);\nvoid GXSetTevAlphaOp(GXTevStageID stage, GXTevOp op, GXTevBias bias, GXTevScale scale, GXBool clamp,\n                     GXTevRegID out_reg);\nvoid GXSetTevColor(GXTevRegID id, GXColor color);\nvoid GXSetTevColorS10(GXTevRegID id, GXColorS10 color);\nvoid GXSetTevKColor(GXTevKColorID id, GXColor color);\nvoid GXSetTevKColorSel(GXTevStageID stage, GXTevKColorSel color_sel);\nvoid GXSetTevKAlphaSel(GXTevStageID stage, GXTevKAlphaSel alpha_sel);\nvoid GXSetTevSwapMode(GXTevStageID stage, GXTevSwapSel ras_sel, GXTevSwapSel tex_sel);\nvoid GXSetTevSwapModeTable(GXTevSwapSel select, GXTevColor r, GXTevColor g, GXTevColor b,\n                           GXTevColor a);\nvoid GXSetAlphaCompare(GXCompare comp0, u8 ref0, GXAlphaOp op, GXCompare comp1, u8 ref1);\nvoid GXSetZTexture(GXZTexOp op, GXTexFmt fmt, u32 bias);\nvoid GXSetTevOrder(GXTevStageID stage, GXTexCoordID coord, GXTexMapID map, GXChannelID color);\nvoid GXSetNumTevStages(u8 num_stages);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* GXTEV_H */\n/* end \"dolphin/gx/GXTev.h\" */\n/* \"include/dolphin/gx/GX.h\" line 14 \"dolphin/gx/GXTexture.h\" */\n#ifndef GXTEXTURE_H\n#define GXTEXTURE_H\n\n/* \"include/dolphin/gx/GXTexture.h\" line 3 \"dolphin/gx/GXInit.h\" */\n#ifndef GXINIT_H\n#define GXINIT_H\n\n/* \"include/dolphin/gx/GXInit.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n/* \"include/dolphin/gx/GXInit.h\" line 4 \"dolphin/gx/GXStruct.h\" */\n/* end \"dolphin/gx/GXStruct.h\" */\n/* \"include/dolphin/gx/GXInit.h\" line 5 \"dolphin/mtx/mtx.h\" */\n/* end \"dolphin/mtx/mtx.h\" */\n\ntypedef GXTexRegion (*GXTexRegionCallback)(GXTexObj* obj);\ntypedef GXTlutRegion* (*GXTlutRegionCallback)(u32 name);\n\ntypedef struct _GXData {\n    /* 0x000 */ u16 field_0x0;\n    /* 0x002 */ u16 bpSentNot;\n    /* 0x004 */ u16 vNum;\n    /* 0x006 */ u16 vLim;\n    /* 0x008 */ u32 cpEnable;\n    /* 0x00C */ u32 cpStatus;\n    /* 0x010 */ u32 cpClr;\n    /* 0x014 */ u32 vcdLoReg;\n    /* 0x018 */ GXAttrType vcdHiReg;\n    /* 0x01C */ GXCompCnt vatA[8];\n    /* 0x03C */ GXCompCnt vatB[8];\n    /* 0x05C */ u32 vatC[8];\n    /* 0x07C */ u32 lpSize;\n    /* 0x080 */ u32 matIdxA;\n    /* 0x084 */ u32 matIdxB;\n    /* 0x088 */ u8 field_0x88[0xA8 - 0x88];\n    /* 0x0A8 */ GXColor ambColors[2];\n    /* 0x0B0 */ GXColor matColors[2];\n    /* 0x0B8 */ u32 suTs0[8];  // GX_MAX_TEXCOORD\n    /* 0x0D8 */ u32 suTs1[8];  // GX_MAX_TEXCOORD\n    /* 0x0F8 */ u32 suScis0;\n    /* 0x0FC */ u32 suScis1;\n    /* 0x100 */ u32 tref[GX_MAX_TEVSTAGE / 2];\n    /* 0x120 */ u32 iref;\n    /* 0x124 */ u32 bpMask;\n    /* 0x128 */ u32 field_0x128;\n    /* 0x12C */ u32 field_0x12c;\n    /* 0x130 */ u32 tevc[GX_MAX_TEVSTAGE];\n    /* 0x170 */ u32 teva[GX_MAX_TEVSTAGE];\n    /* 0x1B0 */ u32 tevKsel[GX_MAX_TEVSTAGE / 2];\n    /* 0x1D0 */ u32 cmode0;\n    /* 0x1D4 */ u32 cmode1;\n    /* 0x1D8 */ u32 zmode;\n    /* 0x1DC */ u32 peCtrl;\n    /* 0x1E0 */ u32 field_0x1e0;\n    /* 0x1E4 */ u32 field_0x1e4;\n    /* 0x1E8 */ u32 field_0x1e8;\n    /* 0x1EC */ u32 field_0x1ec;\n    /* 0x1F0 */ u32 field_0x1f0;\n    /* 0x1F4 */ u32 field_0x1f4;\n    /* 0x1F8 */ u32 field_0x1f8;\n    /* 0x1FC */ u32 cpTex;\n    /* 0x200 */ u8 field_0x200;\n    /* 0x204 */ u32 genMode;\n    /* 0x208 */ GXTexRegion TexRegions0[8];\n    /* 0x288 */ GXTexRegion TexRegions1[8];\n    /* 0x308 */ GXTexRegion TexRegions2[8];\n    /* 0x388 */ GXTlutRegion TlutRegions[16]; \n    /* 0x488 */ GXTlutRegion field_0x488[4]; \n    /* 0x4C8 */ GXTexRegionCallback texRegionCB;\n    /* 0x4CC */ GXTlutRegionCallback tlutRegionCB;\n    /* 0x4D0 */ GXAttrType nrmDataType;\n    /* 0x4D4 */ GXBool hasNrm;\n    /* 0x4D5 */ GXBool hasBiNrm;\n    /* 0x4D8 */ GXProjectionType projectionType;\n    /* 0x4DC */ f32 field_0x4dc;\n    /* 0x4E0 */ f32 field_0x4e0;\n    /* 0x4E4 */ f32 field_0x4e4;\n    /* 0x4E8 */ f32 field_0x4e8;\n    /* 0x4EC */ f32 field_0x4ec;\n    /* 0x4F0 */ f32 field_0x4f0;\n    /* 0x4F4 */ f32 vpLeft;\n    /* 0x4F8 */ f32 vpTop;\n    /* 0x4FC */ f32 vpWd;\n    /* 0x500 */ f32 vpHt;\n    /* 0x504 */ f32 vpNearz;\n    /* 0x508 */ f32 vpFarz;\n    /* 0x50C */ f32 zOffset;\n    /* 0x510 */ f32 zScale;\n    /* 0x514 */ u32 field_0x514[8];\n    /* 0x534 */ u32 field_0x534[8];\n    /* 0x558 */ u32 texmapId[9];\n    /* 0x578 */ u8 field_0x578[0x594 - 0x578];\n    /* 0x594 */ u32 tcsManEnab;\n    /* 0x598 */ u32 tevTcEnab;\n    /* 0x59C */ u32 perf0;\n    /* 0x5A0 */ u32 perf1;\n    /* 0x5A4 */ u32 perfSel;\n    /* 0x5A8 */ u8 inDispList;\n    /* 0x5A9 */ u8 dlSaveContext;\n    /* 0x5AA */ u8 abtWaitPECopy;\n    /* 0x5AB */ u8 dirtyVAT;\n    /* 0x5AC */ u32 dirtyFlags;\n} GXData;  // Size: 0x5B0\n\nSTATIC_ASSERT(sizeof(GXData) == 0x5B0);\n\nextern GXData* const __GXData;\n\n// Define register addresses.\n#define GX_CP_ADDR  (0x0C000000)\n#define GX_PE_ADDR  (0x0C001000)\n#define GX_PI_ADDR  (0x0C003000)\n#define GX_MEM_ADDR (0x0C004000)\n\nextern u32* __piReg;\nextern u16* __cpReg;\nextern u16* __peReg;\nextern vu16* __memReg;\n\n#define GX_GET_MEM_REG(offset) (*(vu16*)((vu16*)(__memReg) + (offset)))\n#define GX_GET_CP_REG(offset)  (*(vu16*)((vu16*)(__cpReg) + (offset)))\n#define GX_GET_PE_REG(offset)  (*(vu16*)((vu16*)(__peReg) + (offset)))\n#define GX_GET_PI_REG(offset)  (*(vu32*)((vu32*)(__piReg) + (offset)))\n\n#define GX_SET_MEM_REG(offset, val) (*(vu16*)((vu16*)(__memReg) + (offset)) = val)\n#define GX_SET_CP_REG(offset, val)  (*(vu16*)((vu16*)(__cpReg) + (offset)) = val)\n#define GX_SET_PE_REG(offset, val)  (*(vu16*)((vu16*)(__peReg) + (offset)) = val)\n#define GX_SET_PI_REG(offset, val)  (*(vu32*)((vu32*)(__piReg) + (offset)) = val)\n\ninline void GXSetWasteFlags() {\n\tGXData* data = __GXData;\n\tdata->dirtyFlags |= GX_DIRTY_SU_TEX | GX_DIRTY_BP_MASK;\n\tdata->bpSentNot = 0;\n}\n\nstatic inline void set_x2(u16 value)\n{\n    __GXData->bpSentNot = value;\n}\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic inline u32 GXReadMEMReg(u32 addrLo, u32 addrHi)\n{\n\tu32 hiStart, hiNew, lo;\n\thiStart = GX_GET_MEM_REG(addrHi);\n\tdo {\n\t\thiNew   = hiStart;\n\t\tlo      = GX_GET_MEM_REG(addrLo);\n\t\thiStart = GX_GET_MEM_REG(addrHi);\n\t} while (hiStart != hiNew);\n\n\treturn ((hiStart << 16) | lo);\n}\n\nGXTexRegion* __GXDefaultTexRegionCallback(GXTexObj* obj, GXTexMapID mapID);\nGXTlutRegion* __GXDefaultTlutRegionCallback(u32 tlut);\nBOOL __GXShutdown(BOOL);\nvoid __GXInitRevisionBits(void);\nGXFifoObj* GXInit(void* base, u32 size);\nvoid __GXInitGX(void);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* GXINIT_H */\n/* end \"dolphin/gx/GXInit.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nu32 GXGetTexBufferSize(u16 width, u16 height, u32 format, GXBool mipmap, u8 max_lod);\nvoid __GetImageTileCount(u32 arg0, u16 arg1, u16 arg2, s32* arg3, s32* arg4, s32* arg5);\nvoid GXInitTexObj(GXTexObj* obj, void* image, u16 width, u16 height, GXTexFmt fmt,\n                  GXTexWrapMode wrapS, GXTexWrapMode wrapT, GXBool mipmap);\nvoid GXInitTexObjCI(GXTexObj* obj, void* image, u16 width, u16 height, GXCITexFmt format,\n                    GXTexWrapMode wrapS, GXTexWrapMode wrapT, GXBool mipmap, u32 tlut_name);\nvoid GXInitTexObjLOD(GXTexObj* obj, GXTexFilter min_filter, GXTexFilter max_filter, f32 min_lod,\n                     f32 max_lod, f32 lod_bias, GXBool bias_clamp, GXBool edge_lod,\n                     GXAnisotropy aniso);\nu16 GXGetTexObjWidth(GXTexObj* obj);\nu16 GXGetTexObjHeight(GXTexObj* obj);\nGXTexFmt GXGetTexObjFmt(GXTexObj* obj);\nGXTexWrapMode GXGetTexObjWrapS(GXTexObj* obj);\nGXTexWrapMode GXGetTexObjWrapT(GXTexObj* obj);\nGXBool GXGetTexObjMipMap(GXTexObj* obj);\nu32 GXGetTexObjTlut(GXTexObj* obj);\nvoid GXLoadTexObj(GXTexObj* obj, GXTexMapID id);\nvoid GXInitTlutObj(GXTlutObj* obj, void* lut, GXTlutFmt fmt, u16 entry_num);\nvoid GXLoadTlut(GXTlutObj* obj, u32 tlut_name);\nvoid GXInitTexCacheRegion(GXTexRegion* region, GXBool is_32b_mipmap, u32 tmem_even,\n                          GXTexCacheSize size_even, u32 tmem_odd, GXTexCacheSize size_odd);\nvoid GXInitTlutRegion(GXTlutRegion* region, u32 tmem_addr, GXTlutSize tlut_size);\nvoid GXInvalidateTexAll(void);\n\nGXTexRegionCallback GXSetTexRegionCallback(GXTexRegionCallback callback);\nGXTlutRegionCallback GXSetTlutRegionCallback(GXTlutRegionCallback callback);\n\nvoid GXSetTexCoordScaleManually(GXTexCoordID coord, GXBool enable, u16 s_scale, u16 t_scale);\n\nvoid __SetSURegs();\nvoid __GXSetSUTexRegs();\nvoid __GXSetTmemConfig();\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* GXTEXTURE_H */\n/* end \"dolphin/gx/GXTexture.h\" */\n/* \"include/dolphin/gx/GX.h\" line 15 \"dolphin/gx/GXTransform.h\" */\n#ifndef GXTRANSFORM_H\n#define GXTRANSFORM_H\n\n/* \"include/dolphin/gx/GXTransform.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n/* \"include/dolphin/gx/GXTransform.h\" line 4 \"dolphin/mtx/mtx.h\" */\n/* end \"dolphin/mtx/mtx.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXProject(f32 model_x, f32 model_y, f32 model_z, Mtx model_mtx, f32* proj_mtx, f32* viewpoint,\n               f32* screen_x, f32* screen_y, f32* screen_z);\nvoid GXSetProjection(Mtx44 mtx, GXProjectionType type);\nvoid GXSetProjectionv(f32* p);\nvoid GXGetProjectionv(f32* p);\nvoid GXLoadPosMtxImm(Mtx mtx, u32 id);\nvoid GXLoadNrmMtxImm(Mtx mtx, u32 id);\nvoid GXSetCurrentMtx(u32 id);\nvoid GXLoadTexMtxImm(Mtx mtx, u32 id, GXTexMtxType type);\nvoid GXSetViewport(f32 x_orig, f32 y_orig, f32 width, f32 height, f32 near_z, f32 far_z);\nvoid GXGetViewportv(f32* p);\nvoid GXSetScissor(u32 left, u32 top, u32 width, u32 height);\nvoid GXGetScissor(u32* left, u32* top, u32* width, u32* height);\nvoid GXSetScissorBoxOffset(u32 x_offset, u32 y_offset);\nvoid GXSetClipMode(GXClipMode mode);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* GXTRANSFORM_H */\n/* end \"dolphin/gx/GXTransform.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Pack value into bitfield\n#define GX_BITFIELD_SET(field, pos, size, value) (field) = __rlwimi((field), (value), 31 - (pos) - (size) + 1, (pos), (pos) + (size)-1)\n\n#define GX_BITGET(field, pos, size)              ((field) >> (31 - (pos) - (size) + 1) & ((1 << (size)) - 1))\n#define GX_GET_REG(reg, st, end)    GX_BITGET(reg, st, (end - st + 1))\n#define GX_SET_REG(reg, x, st, end) GX_BITFIELD_SET(reg, st, (end - st + 1), x)\n\n#define INSERT_FIELD(reg, value, nbits, shift)                                 \\\n    (reg) = ((u32) (reg) & ~(((1 << (nbits)) - 1) << (shift))) |               \\\n            ((u32) (value) << (shift));\n\n#define FAST_FLAG_SET(regOrg, newFlag, shift, size)                                                                \\\n\tdo {                                                                                                           \\\n\t\t(regOrg) = (u32)__rlwimi((int)(regOrg), (int)(newFlag), (shift), (32 - (shift) - (size)), (31 - (shift))); \\\n\t} while (0);\n\n#define GX_LOAD_BP_REG 0x61\n#define GX_NOP 0\n\ntypedef union {\n\tu8 u8;\n\tu16 u16;\n\tu32 u32;\n\tu64 u64;\n\ts8 s8;\n\ts16 s16;\n\ts32 s32;\n\ts64 s64;\n\tf32 f32;\n\tf64 f64;\n} PPCWGPipe;\n\n#define GXFIFO_ADDR 0xCC008000\nvolatile PPCWGPipe GXFIFO : GXFIFO_ADDR;\n\n#define GFX_FIFO(T) (*(volatile T*)GXFIFO_ADDR)\n\n#define GX_WRITE_U8(data) GXFIFO.u8 = data;\n#define GX_WRITE_U32(data) GXFIFO.u32 = data;\n#define GX_WRITE_F32(val) (GXFIFO.f32 = (f32)val)\n\n#define GX_CP_LOAD_REG(addr, data)          \\\n\tGXFIFO.s8  = GX_FIFO_CMD_LOAD_CP_REG; \\\n\tGXFIFO.s8  = (addr);                  \\\n\tGXFIFO.s32 = (data);\n\n/**\n * Header for an XF register load\n */\n#define GX_XF_LOAD_REG_HDR(addr)            \\\n\tGXFIFO.s8  = GX_FIFO_CMD_LOAD_XF_REG; \\\n\tGXFIFO.s32 = (addr);\n\n/**\n * Load immediate value into XF register\n */\n#define GX_XF_LOAD_REG(addr, data) \\\n\tGX_XF_LOAD_REG_HDR(addr);      \\\n\tGXFIFO.s32 = (data);\n\n/**\n * Load immediate value into BP register\n */\n#define GX_BP_LOAD_REG(data)                \\\n\tGXFIFO.s8  = GX_FIFO_CMD_LOAD_BP_REG; \\\n\tGXFIFO.s32 = (data);\n\n/**\n * Load immediate values into multiple XF registers\n */\n#define GX_XF_LOAD_REGS(size, addr)    \\\n\t{                                  \\\n\t\tu32 cmd = (size) << 16 | addr; \\\n\t\tGX_XF_LOAD_REG_HDR(cmd);       \\\n\t}\n\ninline void GXPosition3f32(f32 x, f32 y, f32 z) {\n    GXFIFO.f32 = x;\n    GXFIFO.f32 = y;\n    GXFIFO.f32 = z;\n}\n\ninline void GXNormal3f32(f32 x, f32 y, f32 z) {\n    GXFIFO.f32 = x;\n    GXFIFO.f32 = y;\n    GXFIFO.f32 = z;\n}\n\ninline void GXPosition2f32(f32 x, f32 z) {\n    GXFIFO.f32 = x;\n    GXFIFO.f32 = z;\n}\n\ninline void GXColor1u32(u32 c) {\n    GFX_FIFO(u32) = c;\n}\n\ninline void GXTexCoord2f32(f32 s, f32 t) {\n    GFX_FIFO(f32) = s;\n    GFX_FIFO(f32) = t;\n}\n\ninline void GXTexCoord2u8(u8 s, u8 t) {\n    GFX_FIFO(u8) = s;\n    GFX_FIFO(u8) = t;\n}\n\ninline void GXTexCoord1x8(u8 s) {\n    GFX_FIFO(u8) = s;\n}\n\ninline void GXPosition2u16(u16 x, u16 y) {\n    GFX_FIFO(u16) = x;\n    GFX_FIFO(u16) = y;\n}\n\ninline void GXPosition1x16(u16 x) {\n    GFX_FIFO(u16) = x;\n}\n\ninline void GXPosition1x8(u8 x) {\n    GFX_FIFO(u8) = x;\n}\n\ninline void GXPosition3s8(s8 x, s8 y, s8 z) {\n    GFX_FIFO(s8) = x;\n    GFX_FIFO(s8) = y;\n    GFX_FIFO(s8) = z;\n}\n\ninline void GXPosition2s8(s8 x, s8 y) {\n    GFX_FIFO(s8) = x;\n    GFX_FIFO(s8) = y;\n}\n\ninline void i_GXPosition3s16(s16 x, s16 y, s16 z) {\n    GFX_FIFO(s16) = x;\n    GFX_FIFO(s16) = y;\n    GFX_FIFO(s16) = z;\n}\n\ninline void GXTexCoord2s8(s8 x, s8 y) {\n    GFX_FIFO(s8) = x;\n    GFX_FIFO(s8) = y;\n}\n\ninline void i_GXTexCoord2u16(u16 x, u16 y) {\n    GFX_FIFO(u16) = x;\n    GFX_FIFO(u16) = y;\n}\n\ninline void GXTexCoord2s16(const s16 u, const s16 v) {\n\tGFX_FIFO(s16) = u;\n\tGFX_FIFO(s16) = v;\n}\n\ninline void GFWriteBPCmd(u32 param_1) {\n  GXFIFO.u8 = 0x61;\n  GXFIFO.u32 = param_1;\n}\n\nstatic inline u32 GXReadCPReg(u32 addrLo, u32 addrHi) {\n\tu32 hiStart, hiNew, lo;\n\thiStart = GX_GET_CP_REG(addrHi);\n\tdo {\n\t\thiNew   = hiStart;\n\t\tlo      = GX_GET_CP_REG(addrLo);\n\t\thiStart = GX_GET_CP_REG(addrHi);\n\t} while (hiStart != hiNew);\n\n\treturn ((hiStart << 16) | lo);\n}\n\ninline void GFFill(u16 param_1, u32 param_2) {\n  GXFIFO.u8 = 0x10;\n  GXFIFO.u16 = 0;\n  GXFIFO.u16 = param_1;\n  GXFIFO.u32 = param_2;\n}\n\ninline void i_GXEnd() {}\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif\n/* end \"dolphin/gx/GX.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DShape.h\" line 6 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass J3DCurrentMtxInfo {\npublic:\n    u32 mMtxIdxRegA;\n    u32 mMtxIdxRegB;\n};\n\nstatic inline void J3DFifoWriteCPCmd(u8 cmd, u32 param) {\n    GFX_FIFO(u8) = GX_CMD_LOAD_CP_REG;\n    GFX_FIFO(u8) = cmd;\n    GFX_FIFO(u32) = param;\n}\n\nstatic inline void J3DFifoWriteXFCmd(u16 cmd, u16 len) {\n    GFX_FIFO(u8) = GX_CMD_LOAD_XF_REG;\n    GFX_FIFO(u16) = (len - 1);\n    GFX_FIFO(u16) = cmd;\n}\n\nclass J3DCurrentMtx : public J3DCurrentMtxInfo {\npublic:\n    J3DCurrentMtx() {\n        mMtxIdxRegA = 0x3cf3cf00;\n        mMtxIdxRegB = 0x00f3cf3c;\n    }\n\n    J3DCurrentMtx& operator=(J3DCurrentMtxInfo const& info) {\n        mMtxIdxRegA = info.mMtxIdxRegA;\n        mMtxIdxRegB = info.mMtxIdxRegB;\n        return *this;\n    }\n\n    u32 getMtxIdxRegA() const { return mMtxIdxRegA; }\n    u32 getMtxIdxRegB() const { return mMtxIdxRegB; }\n\n    inline void load() const {\n        J3DFifoWriteCPCmd(0x30, getMtxIdxRegA());  // CP_MATINDEX_A\n        J3DFifoWriteCPCmd(0x40, getMtxIdxRegB());  // CP_MATINDEX_B\n        J3DFifoWriteXFCmd(0x1018, 2);\n        GFX_FIFO(u32) = getMtxIdxRegA();\n        GFX_FIFO(u32) = getMtxIdxRegB();\n    }\n\n    void setCurrentTexMtx(u8 param_1, u8 param_2, u8 param_3, u8 param_4,\n        u8 param_5, u8 param_6, u8 param_7, u8 param_8) {\n        mMtxIdxRegA = ((param_1 & 0xff) << 6) | (param_2 << 0xc)| (param_3 << 0x12) | (param_4 << 0x18);\n        mMtxIdxRegB = (param_5) | param_6 << 6 | param_7 << 0xc | param_8 << 0x12;\n    }\n};\n\nclass J3DMaterial;\nclass J3DVertexData;\nclass J3DDrawMtxData;\n\nenum J3DShpFlag {\n    J3DShpFlag_Visible = 0x0001,\n    J3DShpFlag_SkinPosCpu = 0x0004,\n    J3DShpFlag_SkinNrmCpu = 0x0008,\n    J3DShpFlag_Hidden = 0x0010,\n    J3DShpFlag_EnableLod = 0x0100,\n    J3DShpFlag_NoMtx = 0x0200,\n};\n\nclass J3DShape {\npublic:\n    J3DShape() {\n        initialize();\n    }\n\n    enum {\n        kVcdVatDLSize = 0xC0,\n    };\n\n    /* 80314B48 */ void initialize();\n    /* 80314BB8 */ void addTexMtxIndexInDL(_GXAttr, u32);\n    /* 80314CBC */ void addTexMtxIndexInVcd(_GXAttr);\n    /* 80314DA8 */ void calcNBTScale(Vec const&, f32 (*)[3][3], f32 (*)[3][3]);\n    /* 80314E28 */ u32 countBumpMtxNum() const;\n    /* 80314EEC */ void loadVtxArray() const;\n    /* 80314F5C */ bool isSameVcdVatCmd(J3DShape*);\n    /* 80314F98 */ void makeVtxArrayCmd();\n    /* 80315260 */ void makeVcdVatCmd();\n    /* 80315300 */ void loadPreDrawSetting() const;\n    /* 80315398 */ void setArrayAndBindPipeline() const;\n\n    /* 803155E0 */ virtual void draw() const;\n    /* 8031544C */ virtual void drawFast() const;\n    /* 80315628 */ virtual void simpleDraw() const;\n    /* 803156AC */ virtual void simpleDrawCache() const;\n\n    void onFlag(u32 flag) { mFlags |= flag; }\n    void offFlag(u32 flag) { mFlags &= ~flag; }\n    bool checkFlag(u32 flag) const { return !!(mFlags & flag); }\n    void setDrawMtxDataPointer(J3DDrawMtxData* pMtxData) { mDrawMtxData = pMtxData; }\n    void setVertexDataPointer(J3DVertexData* pVtxData) { mVertexData = pVtxData; }\n    void* getVcdVatCmd() const { return mVcdVatCmd; }\n    void setVcdVatCmd(void* pVatCmd) { mVcdVatCmd = (u8*)pVatCmd; }\n    void show() { offFlag(J3DShpFlag_Visible); }\n    void hide() { onFlag(J3DShpFlag_Visible); }\n    void setCurrentViewNoPtr(u32* pViewNoPtr) { mCurrentViewNo = pViewNoPtr; }\n    void setCurrentMtx(J3DCurrentMtx& mtx) { mCurrentMtx = mtx; }\n    void setScaleFlagArray(u8* pScaleFlagArray) { mScaleFlagArray = pScaleFlagArray; }\n    void setDrawMtx(Mtx** pDrawMtx) { mDrawMtx = pDrawMtx; }\n    void setNrmMtx(Mtx33** pNrmMtx) { mNrmMtx = pNrmMtx; }\n    void setTexMtxLoadType(u32 type) { mFlags = (mFlags & 0xFFFF0FFF) | type; }\n    bool getNBTFlag() const { return mHasNBT; }\n    u32 getBumpMtxOffset() const { return mBumpMtxOffset; }\n    GXVtxDescList* getVtxDesc() const { return mVtxDesc; }\n\n    J3DMaterial* getMaterial() const { return mMaterial; }\n    u32 getIndex() const { return mIndex; }\n    u32 getPipeline() const { return (mFlags >> 2) & 0x07; }\n    u32 getTexMtxLoadType() const { return mFlags & 0xF000; }\n    u32 getMtxGroupNum() const { return mMtxGroupNum; }\n    J3DShapeDraw* getShapeDraw(u32 idx) const { return mShapeDraw[idx]; }\n    J3DShapeMtx* getShapeMtx(u32 idx) const { return mShapeMtx[idx]; }\n    Vec* getMin() { return &mMin; }\n    Vec* getMax() { return &mMax; }\n\n    static void resetVcdVatCache() { sOldVcdVatCmd = NULL; }\n\n    static void* sOldVcdVatCmd;\n\nprivate:\n    friend struct J3DShapeFactory;\n    friend class J3DJointTree;\n\n    /* 0x04 */ J3DMaterial* mMaterial;\n    /* 0x08 */ u16 mIndex;\n    /* 0x0A */ u16 mMtxGroupNum;\n    /* 0x0C */ u32 mFlags;\n    /* 0x10 */ f32 mRadius;\n    /* 0x14 */ Vec mMin;\n    /* 0x20 */ Vec mMax;\n    /* 0x2C */ u8* mVcdVatCmd;\n    /* 0x30 */ GXVtxDescList* mVtxDesc;\n    /* 0x34 */ bool mHasNBT;\n    /* 0x38 */ J3DShapeMtx** mShapeMtx;\n    /* 0x3C */ J3DShapeDraw** mShapeDraw;\n    /* 0x40 */ J3DCurrentMtx mCurrentMtx;\n    /* 0x48 */ bool mHasPNMTXIdx;\n    /* 0x4C */ J3DVertexData* mVertexData;\n    /* 0x50 */ J3DDrawMtxData* mDrawMtxData;\n    /* 0x54 */ u8* mScaleFlagArray;\n    /* 0x58 */ Mtx** mDrawMtx;\n    /* 0x5C */ Mtx33** mNrmMtx;\n    /* 0x60 */ u32* mCurrentViewNo;\n    /* 0x64 */ u32 mBumpMtxOffset;\n};\n\n#endif /* J3DSHAPE_H */\n/* end \"JSystem/J3DGraphBase/J3DShape.h\" */\n/* \"include/JSystem/J3DGraphAnimator/J3DShapeTable.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass JUTNameTab;\n\nclass J3DShapeTable {\npublic:\n    J3DShapeTable() {\n        mShapeNum = 0;\n        mShapeNodePointer = NULL;\n        mShapeName = NULL;\n    }\n\n    /* 803258A0 */ void hide();\n    /* 803258D8 */ void show();\n    /* 80325910 */ void initShapeNodes(J3DDrawMtxData*, J3DVertexData*);\n    /* 8032597C */ void sortVcdVatCmd();\n\n    virtual ~J3DShapeTable();\n\n    u16 getShapeNum() const { return mShapeNum; }\n    J3DShape* getShapeNodePointer(u16 idx) const { return mShapeNodePointer[idx]; }\n\nprivate:\n    friend class J3DModelLoader;\n    \n    /* 0x4 */ u16 mShapeNum;\n    /* 0x8 */ J3DShape** mShapeNodePointer;\n    /* 0xC */ JUTNameTab* mShapeName;\n};  // Size: 0x10\n\n#endif /* J3DSHAPETABLE_H */\n/* end \"JSystem/J3DGraphAnimator/J3DShapeTable.h\" */\n/* \"include/JSystem/J3DGraphAnimator/J3DModelData.h\" line 6 \"JSystem/J3DGraphBase/J3DSys.h\" */\n#ifndef J3DSYS_H\n#define J3DSYS_H\n\n/* \"include/JSystem/J3DGraphBase/J3DSys.h\" line 3 \"dolphin/gx/GX.h\" */\n/* end \"dolphin/gx/GX.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DSys.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n// Perhaps move to a new J3DEnum.h?\nenum J3DError {\n    kJ3DError_Success = 0,\n    kJ3DError_Alloc = 4,\n};\n\nenum J3DSysDrawBuffer {\n    /* 0x0 */ J3DSys_OPA_BUFFER_e,\n    /* 0x1 */ J3DSys_XLU_BUFFER_e\n};\n\nclass J3DMtxCalc;\nclass J3DModel;\nclass J3DMatPacket;\nclass J3DShapePacket;\nclass J3DShape;\nclass J3DDrawBuffer;\nclass J3DTexture;\n\nstruct J3DTexCoordScaleInfo {\n    /* 0x0 */ u16 field_0x00;\n    /* 0x2 */ u16 field_0x02;\n    /* 0x4 */ u16 field_0x04;\n    /* 0x6 */ u16 field_0x06;\n};\n\nenum J3DSysFlag {\n    J3DSysFlag_SkinPosCpu = 0x00000004,\n    J3DSysFlag_SkinNrmCpu = 0x00000008,\n    J3DSysFlag_PostTexMtx = 0x40000000,\n};\n\nstruct J3DSys {\n    /* 0x000 */ Mtx mViewMtx;\n    /* 0x030 */ J3DMtxCalc* mCurrentMtxCalc;\n    /* 0x034 */ u32 mFlags;\n    /* 0x038 */ J3DModel* mModel;\n    /* 0x03C */ J3DMatPacket* mMatPacket;\n    /* 0x040 */ J3DShapePacket* mShapePacket;\n    /* 0x044 */ J3DShape* mShape;\n    /* 0x048 */ J3DDrawBuffer* mDrawBuffer[2];\n    /* 0x050 */ u32 mDrawMode;\n    /* 0x054 */ u32 mMaterialMode;\n    /* 0x058 */ J3DTexture* mTexture;\n    /* 0x05C */ u8 field_0x5c[0x04];\n    /* 0x060 */ u32 mTexCacheRegionNum;\n    /* 0x064 */ GXTexRegion mTexCacheRegion[8];\n    /* 0x0E4 */ u8 field_0xe4[0x20];\n    /* 0x104 */ Mtx* mModelDrawMtx;\n    /* 0x108 */ Mtx33* mModelNrmMtx;\n    /* 0x10C */ void* mVtxPos;\n    /* 0x110 */ void* mVtxNrm;\n    /* 0x114 */ _GXColor* mVtxCol;\n    /* 0x118 */ Vec* mNBTScale;\n\n    /* 8030FDE8 */ J3DSys();\n    /* 8030FEC0 */ void loadPosMtxIndx(int, u16) const;\n    /* 8030FEE4 */ void loadNrmMtxIndx(int, u16) const;\n    /* 8030FF0C */ void setTexCacheRegion(_GXTexCacheSize);\n    /* 803100BC */ void drawInit();\n    /* 8031073C */ void reinitGX();\n    /* 8031079C */ void reinitGenMode();\n    /* 803107E8 */ void reinitLighting();\n    /* 80310894 */ void reinitTransform();\n    /* 80310998 */ void reinitTexture();\n    /* 80310A3C */ void reinitTevStages();\n    /* 80310D44 */ void reinitIndStages();\n    /* 80310E3C */ void reinitPixelProc();\n\n    enum DrawMode {\n        /* 0x3 */ OPA_TEX_EDGE = 3,\n        /* 0x4 */ XLU,\n    };\n\n    MtxP getViewMtx() { return mViewMtx; }\n\n    void setDrawModeOpaTexEdge() { mDrawMode = OPA_TEX_EDGE; }\n\n    void setDrawModeXlu() { mDrawMode = XLU; }\n\n    void* getVtxPos() const { return mVtxPos; }\n    void setVtxPos(void* pVtxPos) { mVtxPos = pVtxPos; }\n\n    void* getVtxNrm() const { return mVtxNrm; }\n    void setVtxNrm(void* pVtxNrm) { mVtxNrm = pVtxNrm; }\n\n    void* getVtxCol() const { return mVtxCol; }\n    void setVtxCol(_GXColor* pVtxCol) { mVtxCol = pVtxCol; }\n\n    void setModel(J3DModel* pModel) { mModel = pModel; }\n    void setShapePacket(J3DShapePacket* pPacket) { mShapePacket = pPacket; }\n    void setMatPacket(J3DMatPacket* pPacket) { mMatPacket = pPacket; }\n    J3DMatPacket* getMatPacket() { return mMatPacket; }\n    void setMaterialMode(u32 mode) { mMaterialMode = mode; }\n\n    void setCurrentMtxCalc(J3DMtxCalc * pCalc) { mCurrentMtxCalc = pCalc; }\n    J3DMtxCalc * getCurrentMtxCalc() const { return mCurrentMtxCalc; }\n\n    void setTexture(J3DTexture* pTex) { mTexture = pTex; }\n    J3DTexture* getTexture() { return mTexture; }\n\n    void setNBTScale(Vec* scale) { mNBTScale = scale; }\n    Vec* getNBTScale() { return mNBTScale; }\n\n    void onFlag(u32 flag) { mFlags |= flag; }\n\n    void offFlag(u32 flag) { mFlags &= ~flag; }\n\n    bool checkFlag(u32 flag) { return mFlags & flag; }\n\n    void setModelDrawMtx(Mtx* pMtxArr) {\n        mModelDrawMtx = pMtxArr;\n        GXSetArray(GX_POS_MTX_ARRAY, mModelDrawMtx, sizeof(*mModelDrawMtx));\n    }\n\n    void setModelNrmMtx(Mtx33* pMtxArr) {\n        mModelNrmMtx = pMtxArr;\n        GXSetArray(GX_NRM_MTX_ARRAY, mModelNrmMtx, sizeof(*mModelNrmMtx));\n    }\n\n    // Type 0: Opa Buffer\n    // Type 1: Xlu Buffer\n    void setDrawBuffer(J3DDrawBuffer* buffer, int type) { mDrawBuffer[type] = buffer; }\n\n    // Type 0: Opa Buffer\n    // Type 1: Xlu Buffer\n    J3DDrawBuffer* getDrawBuffer(int type) { return mDrawBuffer[type]; }\n\n    Mtx& getModelDrawMtx(u16 no) const { return mModelDrawMtx[no]; }\n    J3DShapePacket* getShapePacket() const { return mShapePacket; }\n\n    void setViewMtx(Mtx m) { MTXCopy(m, mViewMtx); }\n\n    J3DModel* getModel() { return mModel; }\n\n    static Mtx mCurrentMtx;\n    static Vec mCurrentS;\n    static Vec mParentS;\n    static J3DTexCoordScaleInfo sTexCoordScaleTable[8];\n};\n\nextern u32 j3dDefaultViewNo;\nextern J3DSys j3dSys;\n\n#endif /* J3DSYS_H */\n/* end \"JSystem/J3DGraphBase/J3DSys.h\" */\n/* \"include/JSystem/J3DGraphAnimator/J3DModelData.h\" line 7 \"JSystem/J3DGraphBase/J3DVertex.h\" */\n#ifndef J3DVERTEX_H\n#define J3DVERTEX_H\n\n/* \"include/JSystem/J3DGraphBase/J3DVertex.h\" line 3 \"dolphin/gx/GXAttr.h\" */\n/* end \"dolphin/gx/GXAttr.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DVertex.h\" line 4 \"dolphin/mtx/vec.h\" */\n/* end \"dolphin/mtx/vec.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DVertex.h\" line 5 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef struct _GXColor GXColor;\nclass J3DModel;\nclass J3DAnmVtxColor;\nclass J3DVertexBuffer;\n\nstruct J3DVtxColorCalc {\n    /* 8032E180 */ void calc(J3DModel*);\n    virtual void calc(J3DVertexBuffer*);\n\n    /* 0x0 */ void* vtable;  // inlined vtable?\n    /* 0x4 */ u32 mFlags;\n    /* 0x8 */ J3DAnmVtxColor* mpVtxColor;\n};\n\nclass J3DVertexData {\npublic:\n    J3DVertexData();\n\n    void* getVtxPosArray() const { return mVtxPosArray; }\n    void* getVtxNrmArray() const { return mVtxNrmArray; }\n    GXColor* getVtxColorArray(u8 idx) const { return mVtxColorArray[idx]; }\n    void* getVtxTexCoordArray(u8 idx) const { return mVtxTexCoordArray[idx]; }\n    void* getVtxNBTArray() const { return mVtxNBTArray; }\n    u32 getNrmNum() const { return mNrmNum; }\n    u32 getVtxNum() const { return mVtxNum; }\n    GXVtxAttrFmtList* getVtxAttrFmtList() { return mVtxAttrFmtList; }\n    u8 getVtxPosFrac() { return mVtxPosFrac; }\n    u8 getVtxNrmFrac() { return mVtxNrmFrac; }\n    int getVtxPosType() { return mVtxPosType; }\n    int getVtxNrmType() { return mVtxNrmType; }\n\n    void setVtxPosFrac(u8 frac) { mVtxPosFrac = frac; }\n    void setVtxPosType(GXCompType type) { mVtxPosType = type; }\n    void setVtxNrmFrac(u8 frac) { mVtxNrmFrac = frac; }\n    void setVtxNrmType(GXCompType type) { mVtxNrmType = type; }\n\nprivate:\n    friend class J3DModelLoader;\n    \n    /* 0x00 */ u32 mVtxNum;\n    /* 0x04 */ u32 mNrmNum;\n    /* 0x08 */ u32 mColNum;\n    /* 0x0C */ u32 mTexCoordNum;\n    /* 0x10 */ u32 mPacketNum;\n    /* 0x14 */ GXVtxAttrFmtList* mVtxAttrFmtList;\n    /* 0x18 */ void* mVtxPosArray;\n    /* 0x1C */ void* mVtxNrmArray;\n    /* 0x20 */ void* mVtxNBTArray;\n    /* 0x24 */ GXColor* mVtxColorArray[2];\n    /* 0x2C */ void* mVtxTexCoordArray[8];\n    /* 0x4C */ u8 mVtxPosFrac;\n    /* 0x50 */ GXCompType mVtxPosType;\n    /* 0x54 */ u8 mVtxNrmFrac;\n    /* 0x58 */ GXCompType mVtxNrmType;\n};\n\nclass J3DVertexBuffer {\npublic:\n    J3DVertexBuffer() { init(); }\n\n    /* 80310F78 */ void setVertexData(J3DVertexData*);\n    /* 80310FD8 */ void init();\n    /* 80311030 */ ~J3DVertexBuffer();\n    /* 8031106C */ void setArray() const;\n    /* 80311090 */ s32 copyLocalVtxPosArray(u32);\n    /* 803111B0 */ s32 copyLocalVtxNrmArray(u32);\n    /* 803112D0 */ s32 copyLocalVtxArray(u32);\n    /* 80311478 */ s32 allocTransformedVtxPosArray();\n    /* 8031152C */ s32 allocTransformedVtxNrmArray();\n\n    void setCurrentVtxPos(void* pVtxPos) { mCurrentVtxPos = pVtxPos; }\n    void* getCurrentVtxPos() { return mCurrentVtxPos; }\n\n    void setCurrentVtxNrm(void* pVtxNrm) { mCurrentVtxNrm = pVtxNrm; }\n    void* getCurrentVtxNrm() { return mCurrentVtxNrm; }\n\n    void setCurrentVtxCol(GXColor* pVtxCol) { mCurrentVtxCol = pVtxCol; }\n\n    void frameInit() {\n        setCurrentVtxPos(mVtxPosArray[0]);\n        setCurrentVtxNrm(mVtxNrmArray[0]);\n        setCurrentVtxCol(mVtxColArray[0]);\n    }\n\n    void* getTransformedVtxPos(int idx) { return mTransformedVtxPosArray[idx]; }\n    void* getTransformedVtxNrm(int idx) { return mTransformedVtxNrmArray[idx]; }\n    J3DVertexData* getVertexData() { return mVtxData; }\n\n    void swapTransformedVtxPos() {\n        void* tmp = mTransformedVtxPosArray[0];\n        mTransformedVtxPosArray[0] = mTransformedVtxPosArray[1];\n        mTransformedVtxPosArray[1] = tmp;\n    }\n\n    void swapTransformedVtxNrm() {\n        void* tmp = mTransformedVtxNrmArray[0];\n        mTransformedVtxNrmArray[0] = mTransformedVtxNrmArray[1];\n        mTransformedVtxNrmArray[1] = tmp;\n    }\n\nprivate:\n    /* 0x00 */ J3DVertexData* mVtxData;\n    /* 0x04 */ void* mVtxPosArray[2];\n    /* 0x0C */ void* mVtxNrmArray[2];\n    /* 0x14 */ GXColor* mVtxColArray[2];\n    /* 0x1C */ void* mTransformedVtxPosArray[2];\n    /* 0x24 */ void* mTransformedVtxNrmArray[2];\n    /* 0x2C */ void* mCurrentVtxPos;\n    /* 0x30 */ void* mCurrentVtxNrm;\n    /* 0x34 */ GXColor* mCurrentVtxCol;\n};  // Size: 0x38\n\nstruct VertexNormal {\n    Vec data;\n};\n\n#endif /* J3DVERTEX_H */\n/* end \"JSystem/J3DGraphBase/J3DVertex.h\" */\n\ntypedef struct _GXColor GXColor;\nclass JUTNameTab;\n\nclass J3DModelData {\npublic:\n    /* 80325D88 */ void clear();\n    /* 80325DA0 */ J3DModelData();\n    /* 80325E14 */ s32 newSharedDisplayList(u32);\n    /* 80325EC8 */ void indexToPtr();\n    /* 80325F94 */ void makeSharedDL();\n    /* 8032600C */ void simpleCalcMaterial(u16, f32 (*)[4]);\n    /* 803260CC */ void syncJ3DSysPointers() const;\n    /* 803260F8 */ void syncJ3DSysFlags() const;\n\n    /* 8032617C */ virtual ~J3DModelData();\n\n    J3DMaterialTable& getMaterialTable() { return mMaterialTable; }\n    JUTNameTab* getMaterialName() const { return mMaterialTable.getMaterialName(); }\n    J3DVertexData& getVertexData() { return mVertexData; }\n    u16 getShapeNum() const { return mShapeTable.getShapeNum(); }\n    u16 getMaterialNum() const { return mMaterialTable.getMaterialNum(); }\n    u16 getJointNum() const { return mJointTree.getJointNum(); }\n    u16 getDrawMtxNum() const { return mJointTree.getDrawMtxNum(); }\n    J3DMaterial* getMaterialNodePointer(u16 idx) const {\n        return mMaterialTable.getMaterialNodePointer(idx);\n    }\n    u32 getVtxNum() const { return mVertexData.getVtxNum(); }\n    u32 getNrmNum() const { return mVertexData.getNrmNum(); }\n    u8 getDrawMtxFlag(u16 idx) const { return mJointTree.getDrawMtxFlag(idx); }\n    u16 getDrawMtxIndex(u16 idx) const { return mJointTree.getDrawMtxIndex(idx); }\n    J3DDrawMtxData* getDrawMtxData() { return mJointTree.getDrawMtxData(); }\n    J3DShapeTable* getShapeTable() { return &mShapeTable; }\n    J3DShape* getShapeNodePointer(u16 idx) const { return mShapeTable.getShapeNodePointer(idx); }\n    J3DJoint* getJointNodePointer(u16 idx) const { return mJointTree.getJointNodePointer(idx); }\n    J3DJointTree& getJointTree() { return mJointTree; }\n    J3DModelHierarchy const* getHierarchy() { return mJointTree.getHierarchy(); }\n    void setHierarchy(J3DModelHierarchy* hierarchy) { mJointTree.setHierarchy(hierarchy); }\n    void setBasicMtxCalc(J3DMtxCalc* calc) { mJointTree.setBasicMtxCalc(calc); }\n    JUTNameTab* getJointName() const { return mJointTree.getJointName(); }\n    Mtx& getInvJointMtx(s32 idx) const { return mJointTree.getInvJointMtx(idx); }\n    J3DTexture* getTexture() const { return mMaterialTable.getTexture(); }\n    JUTNameTab* getTextureName() const { return mMaterialTable.getTextureName(); }\n    u16 getWEvlpMtxNum() const { return mJointTree.getWEvlpMtxNum(); }\n    u16* getWEvlpMixMtxIndex() const { return mJointTree.getWEvlpMixIndex(); }\n    f32* getWEvlpMixWeight() const { return mJointTree.getWEvlpMixWeight(); }\n    u8 getWEvlpMixMtxNum(u16 idx) const { return mJointTree.getWEvlpMixMtxNum(idx); }\n    u16* getWEvlpImportantMtxIndex() const { return mJointTree.getWEvlpImportantMtxIndex(); }\n    u32 getModelDataType() const { return mJointTree.getModelDataType(); }\n    void setModelDataType(u32 type) { mJointTree.setModelDataType(type); }\n    void* getVtxPosArray() const { return mVertexData.getVtxPosArray(); }\n    void* getVtxNrmArray() const { return mVertexData.getVtxNrmArray(); }\n    GXColor* getVtxColorArray(u8 idx) const { return mVertexData.getVtxColorArray(idx); }\n    bool checkFlag(u32 flag) const { return (mFlags & flag) ? true : false; }\n    u32 getFlag() const { return mFlags; }\n    void const* getRawData() const { return mpRawData; }\n    u16 checkBumpFlag() const { return mbHasBumpArray; }\n    void setBumpFlag(u32 flag) { mbHasBumpArray = flag; }\n    bool checkBBoardFlag() const { return mbHasBillboard == 1; }\n    bool isLocked() { return mMaterialTable.isLocked(); }\n    void entryTexMtxAnimator(J3DAnmTextureSRTKey* anm) { mMaterialTable.entryTexMtxAnimator(anm); }\n    void entryTevRegAnimator(J3DAnmTevRegKey* anm) { mMaterialTable.entryTevRegAnimator(anm); }\n    void entryTexNoAnimator(J3DAnmTexPattern* anm) { mMaterialTable.entryTexNoAnimator(anm); }\n    int removeTexNoAnimator(J3DAnmTexPattern* anm) {\n        return mMaterialTable.removeTexNoAnimator(anm);\n    }\n    int removeTexMtxAnimator(J3DAnmTextureSRTKey* anm) {\n        return mMaterialTable.removeTexMtxAnimator(anm);\n    }\n    int removeTevRegAnimator(J3DAnmTevRegKey* anm) {\n        return mMaterialTable.removeTevRegAnimator(anm);\n    }\n    int removeMatColorAnimator(J3DAnmColor* anm) {\n        return mMaterialTable.removeMatColorAnimator(anm);\n    }\n    void syncJ3DSys() {\n        syncJ3DSysFlags();\n        syncJ3DSysPointers();\n    }\n    void makeHierarchy(J3DJoint* joint, J3DModelHierarchy const** hierarchy) {\n        mJointTree.makeHierarchy(joint, hierarchy, &mMaterialTable, &mShapeTable);\n        mShapeTable.initShapeNodes(getDrawMtxData(), &getVertexData());\n    }\n\nprivate:\n    friend class J3DModelLoader;\n\n    /* 0x04 */ void const* mpRawData;\n    /* 0x08 */ u32 mFlags;\n    /* 0x0C */ u16 mbHasBumpArray;\n    /* 0x0E */ u16 mbHasBillboard;\n    /* 0x10 */ J3DJointTree mJointTree;\n    /* 0x58 */ J3DMaterialTable mMaterialTable;\n    /* 0x78 */ J3DShapeTable mShapeTable;\n    /* 0x88 */ J3DVertexData mVertexData;\n};  // Size: 0xE4\n\n#endif /* J3DMODELDATA_H */\n/* end \"JSystem/J3DGraphAnimator/J3DModelData.h\" */\n/* \"include/JSystem/J3DGraphAnimator/J3DAnimation.h\" line 4 \"JSystem/JUtility/JUTNameTab.h\" */\n#ifndef JUTNAMETAB_H\n#define JUTNAMETAB_H\n\n/* \"include/JSystem/JUtility/JUTNameTab.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nstruct ResNTAB {\n    u16 mEntryNum;\n    u16 mPad0;\n    struct Entry {\n        u16 mKeyCode;\n        u16 mOffs;\n    } mEntries[1];\n\n    inline const char* getName(u32 index) const {\n        return ((const char*)mEntries) + mEntries[index].mOffs - 4;\n    }\n};\n\nclass JUTNameTab {\npublic:\n    JUTNameTab();\n    JUTNameTab(const ResNTAB* pNameTable);\n    virtual ~JUTNameTab() {};\n\n    void setResource(const ResNTAB* pNameTable);\n    s32 getIndex(char const*) const;\n    const char* getName(u16 index) const;\n    u16 calcKeyCode(char const* pName) const;\n    const ResNTAB* getResNameTable() const { return mNameTable; }\n\nprivate:\n    /* 0x4 */ const ResNTAB* mNameTable;\n    /* 0x8 */ const char* mpStrData;\n    /* 0xC */ u16 mNameNum;\n};\n\n#endif /* JUTNAMETAB_H */\n/* end \"JSystem/JUtility/JUTNameTab.h\" */\n/* \"include/JSystem/J3DGraphAnimator/J3DAnimation.h\" line 5 \"global.h\" */\n/* end \"global.h\" */\n\ntypedef struct _GXColor GXColor;\ntypedef struct _GXColorS10 GXColorS10;\n\nstruct J3DAnmKeyTableBase {\n    /* 0x00 */ u16 mMaxFrame;\n    /* 0x02 */ u16 mOffset;\n    /* 0x04 */ u16 mType;\n};  // Size = 0x6\n\nstruct J3DAnmColorKeyTable {\n    J3DAnmKeyTableBase mRInfo;\n    J3DAnmKeyTableBase mGInfo;\n    J3DAnmKeyTableBase mBInfo;\n    J3DAnmKeyTableBase mAInfo;\n};  // Size = 0x18\n\nstruct J3DAnmVtxColorIndexDataItem {\n    u16 count;\n    u32 offset;\n};\n\nstruct J3DAnmVtxColorIndexData {\n    J3DAnmVtxColorIndexDataItem field_0x0[4];\n};\n\nstruct J3DAnmColorFullTable {\n    /* 0x00 */ u16 mRMaxFrame;\n    /* 0x02 */ u16 mROffset;\n    /* 0x04 */ u16 mGMaxFrame;\n    /* 0x06 */ u16 mGOffset;\n    /* 0x08 */ u16 mBMaxFrame;\n    /* 0x0A */ u16 mBOffset;\n    /* 0x0C */ u16 mAMaxFrame;\n    /* 0x0E */ u16 mAOffset;\n};  // Size = 0x10\n\nstruct J3DAnmVisibilityFullTable {\n    u16 _0;\n    u16 _2;\n};  // Size = 0x4\n\nstruct J3DAnmTransformKeyTable {\n    J3DAnmKeyTableBase mScaleInfo;\n    J3DAnmKeyTableBase mRotationInfo;\n    J3DAnmKeyTableBase mTranslateInfo;\n};  // Size = 0x12\n\nstruct J3DAnmTransformFullTable {\n    /* 0x00 */ u16 mScaleMaxFrame;\n    /* 0x02 */ u16 mScaleOffset;\n    /* 0x04 */ u16 mRotationMaxFrame;\n    /* 0x06 */ u16 mRotationOffset;\n    /* 0x08 */ u16 mTranslateMaxFrame;\n    /* 0x0A */ u16 mTranslateOffset;\n};  // Size = 0xC\n\nstruct J3DAnmTexPatternFullTable {\n    /* 0x00 */ u16 mMaxFrame;\n    /* 0x02 */ u16 mOffset;\n    /* 0x04 */ u8 _4;\n    /* 0x06 */ u16 _6;\n};  // Size = 0x8\n\nstruct J3DAnmCRegKeyTable {\n    /* 0x00 */ J3DAnmKeyTableBase mRTable;\n    /* 0x06 */ J3DAnmKeyTableBase mGTable;\n    /* 0x0C */ J3DAnmKeyTableBase mBTable;\n    /* 0x12 */ J3DAnmKeyTableBase mATable;\n    /* 0x18 */ u8 _18;\n    u8 padding[3];\n};  // Size = 0x1C\n\nstruct J3DAnmKRegKeyTable {\n    /* 0x00 */ J3DAnmKeyTableBase mRTable;\n    /* 0x06 */ J3DAnmKeyTableBase mGTable;\n    /* 0x0C */ J3DAnmKeyTableBase mBTable;\n    /* 0x12 */ J3DAnmKeyTableBase mATable;\n    /* 0x18 */ u8 _18;\n    u8 padding[3];\n};  // Size = 0x1C\n\nstruct J3DAnmDataBlockHeader {  // actual name unknown\n    /* 0x0 */ u32 mType;\n    /* 0x4 */ u32 mNextOffset;\n};  // Size = 0x8\n\nstruct J3DAnmDataHeader {  // actual name unknown\n    /* 0x00 */ u32 mMagic;\n    /* 0x04 */ u32 mType;\n    /* 0x08 */ u8 _8[4];\n    /* 0x0C */ u32 mCount;\n    /* 0x10 */ u8 _10[0x20 - 0x10];\n    /* 0x20 */ J3DAnmDataBlockHeader mFirst;\n};\n\nstruct J3DAnmVtxColorFullData {\n    /* 0x00 */ J3DAnmDataBlockHeader mHeader;\n    /* 0x08 */ u8 field_0x8;\n    /* 0x09 */ u8 field_0x9;  // padding?\n    /* 0x0A */ s16 mFrameMax;\n    /* 0x0C */ u16 mAnmTableNum[2];\n    /* 0x10 */ u8 field_0x10[0x18 - 0x10];\n    /* 0x18 */ s32 mTableOffsets[2];\n    /* 0x20 */ s32 mVtxColorIndexDataOffsets[2];\n    /* 0x28 */ s32 mVtxColorIndexPointerOffsets[2];\n    /* 0x30 */ s32 mRValuesOffset;\n    /* 0x34 */ s32 mGValuesOffset;\n    /* 0x38 */ s32 mBValuesOffset;\n    /* 0x3C */ s32 mAValuesOffset;\n};  // Size = 0x40\n\nSTATIC_ASSERT(sizeof(J3DAnmVtxColorFullData) == 0x40);\n\nstruct J3DAnmVisibilityFullData {\n    /* 0x00 */ J3DAnmDataBlockHeader mHeader;\n    /* 0x08 */ u8 field_0x8;\n    /* 0x09 */ u8 field_0x9;  // padding?\n    /* 0x0A */ s16 mFrameMax;\n    /* 0x0C */ u16 field_0xc;\n    /* 0x0E */ u16 field_0xe;\n    /* 0x10 */ s32 mTableOffset;\n    /* 0x14 */ s32 mValuesOffset;\n};  // Size = 0x18\n\nSTATIC_ASSERT(sizeof(J3DAnmVisibilityFullData) == 0x18);\n\nstruct J3DAnmTransformFullData {\n    /* 0x00 */ J3DAnmDataBlockHeader mHeader;\n    /* 0x08 */ u8 field_0x8;\n    /* 0x09 */ u8 field_0x9;\n    /* 0x0A */ s16 mFrameMax;\n    /* 0x0C */ u16 field_0xc;\n    /* 0x0E */ u8 field_0xe[0x14 - 0xe];\n    /* 0x14 */ s32 mTableOffset;\n    /* 0x18 */ s32 mScaleValOffset;\n    /* 0x1C */ s32 mRotValOffset;\n    /* 0x20 */ s32 mTransValOffset;\n};  // Size = 0x24\n\nSTATIC_ASSERT(sizeof(J3DAnmTransformFullData) == 0x24);\n\nstruct J3DAnmColorKeyData {\n    /* 0x00 */ J3DAnmDataBlockHeader mHeader;\n    /* 0x08 */ u8 field_0x8;\n    /* 0x09 */ u8 field_0x9[3];\n    /* 0x0C */ s16 mFrameMax;\n    /* 0x0E */ u16 mUpdateMaterialNum;\n    /* 0x10 */ u16 field_0x10;\n    /* 0x12 */ u16 field_0x12;\n    /* 0x14 */ u16 field_0x14;\n    /* 0x16 */ u16 field_0x16;\n    /* 0x18 */ s32 mTableOffset; /* Created by retype action */\n    /* 0x1C */ s32 mUpdateMaterialIDOffset;\n    /* 0x20 */ s32 mNameTabOffset; /* Created by retype action */\n    /* 0x24 */ s32 mRValOffset;\n    /* 0x28 */ s32 mGValOffset;\n    /* 0x2C */ s32 mBValOffset;\n    /* 0x30 */ s32 mAValOffset;\n};  // Size = 0x34\n\nSTATIC_ASSERT(sizeof(J3DAnmColorKeyData) == 0x34);\n\nstruct J3DAnmTextureSRTKeyData {\n    /* 0x00 */ J3DAnmDataBlockHeader mHeader;\n    /* 0x08 */ u8 field_0x8;\n    /* 0x09 */ u8 field_0x9;\n    /* 0x0A */ s16 field_0xa;\n    /* 0x0C */ u16 field_0xc;\n    /* 0x0E */ u16 field_0xe;\n    /* 0x10 */ u16 field_0x10;\n    /* 0x12 */ u16 field_0x12;\n    /* 0x14 */ s32 mTableOffset;\n    /* 0x18 */ s32 mUpdateMatIDOffset;\n    /* 0x1C */ s32 mNameTab1Offset;\n    /* 0x20 */ s32 mUpdateTexMtxIDOffset;\n    /* 0x24 */ s32 unkOffset;\n    /* 0x28 */ s32 mScaleValOffset;\n    /* 0x2C */ s32 mRotValOffset;\n    /* 0x30 */ s32 mTransValOffset;\n    /* 0x34 */ u16 field_0x34;\n    /* 0x36 */ u16 field_0x36;\n    /* 0x38 */ u16 field_0x38;\n    /* 0x3A */ u16 field_0x3a;\n    /* 0x3C */ s32 mInfoTable2Offset;\n    /* 0x40 */ s32 field_0x40;\n    /* 0x44 */ u32 mNameTab2Offset;\n    /* 0x48 */ s32 field_0x48;\n    /* 0x4C */ s32 field_0x4c;\n    /* 0x50 */ s32 field_0x50;\n    /* 0x54 */ s32 field_0x54;\n    /* 0x58 */ s32 field_0x58;\n    /* 0x5C */ s32 field_0x5c;\n};  // Size = 0x60\n\nSTATIC_ASSERT(sizeof(J3DAnmTextureSRTKeyData) == 0x60);\n\nstruct J3DAnmVtxColorKeyData {\n    /* 0x00 */ J3DAnmDataBlockHeader mHeader;\n    /* 0x08 */ u8 field_0x8;\n    /* 0x09 */ u8 field_0x9;\n    /* 0x0A */ s16 mFrameMax;\n    /* 0x0C */ u16 mAnmTableNum[2];\n    /* 0x10 */ u8 field_0x10[0x18 - 0x10];\n    /* 0x18 */ s32 mTableOffsets[2];\n    /* 0x20 */ s32 mVtxColoIndexDataOffset[2];\n    /* 0x28 */ s32 mVtxColoIndexPointerOffset[2];\n    /* 0x30 */ s32 mRValOffset;\n    /* 0x34 */ s32 mGValOffset;\n    /* 0x38 */ s32 mBValOffset;\n    /* 0x3C */ s32 mAValOffset;\n};  // Size = 0x40\n\nSTATIC_ASSERT(sizeof(J3DAnmVtxColorKeyData) == 0x40);\n\nstruct J3DAnmTexPatternFullData {\n    /* 0x00 */ J3DAnmDataBlockHeader mHeader;\n    /* 0x08 */ u8 field_0x8;\n    /* 0x09 */ u8 field_0x9;\n    /* 0x0A */ s16 mFrameMax;\n    /* 0x0C */ u16 field_0xc;\n    /* 0x0E */ u16 field_0xe;\n    /* 0x10 */ s32 mTableOffset;\n    /* 0x14 */ s32 mValuesOffset;\n    /* 0x18 */ s32 mUpdateMaterialIDOffset;\n    /* 0x1C */ s32 mNameTabOffset;\n};  // Size = 0x20\n\nSTATIC_ASSERT(sizeof(J3DAnmTexPatternFullData) == 0x20);\n\nstruct J3DAnmTevRegKeyData {\n    /* 0x00 */ J3DAnmDataBlockHeader mHeader;\n    /* 0x08 */ u8 field_0x8;\n    /* 0x09 */ u8 field_0x9;  // maybe padding\n    /* 0x0A */ s16 mFrameMax;\n    /* 0x0C */ u16 mCRegUpdateMaterialNum;\n    /* 0x0E */ u16 mKRegUpdateMaterialNum;\n    /* 0x10 */ u16 field_0x10;\n    /* 0x12 */ u16 field_0x12;\n    /* 0x14 */ u16 field_0x14;\n    /* 0x16 */ u16 field_0x16;\n    /* 0x18 */ u16 field_0x18;\n    /* 0x1A */ u16 field_0x1a;\n    /* 0x1C */ u16 field_0x1c;\n    /* 0x1E */ u16 field_0x1e;\n    /* 0x20 */ s32 mCRegTableOffset;\n    /* 0x24 */ s32 mKRegTableOffset;\n    /* 0x28 */ s32 mCRegUpdateMaterialIDOffset;\n    /* 0x2C */ s32 mKRegUpdateMaterialIDOffset;\n    /* 0x30 */ s32 mCRegNameTabOffset;\n    /* 0x34 */ s32 mKRegNameTabOffset;\n    /* 0x38 */ s32 mCRValuesOffset;\n    /* 0x3C */ s32 mCGValuesOffset;\n    /* 0x40 */ s32 mCBValuesOffset;\n    /* 0x44 */ s32 mCAValuesOffset;\n    /* 0x48 */ s32 mKRValuesOffset;\n    /* 0x4C */ s32 mKGValuesOffset;\n    /* 0x50 */ s32 mKBValuesOffset;\n    /* 0x54 */ s32 mKAValuesOffset;\n};  // Size = 0x58\n\nSTATIC_ASSERT(sizeof(J3DAnmTevRegKeyData) == 0x58);\n\nstruct J3DAnmColorFullData { /* PlaceHolder Structure */\n    /* 0x00 */ J3DAnmDataBlockHeader mHeader;\n    /* 0x08 */ u8 field_0x8;\n    /* 0x09 */ u8 field_0x9[3];\n    /* 0x0C */ s16 mFrameMax;\n    /* 0x0E */ u16 mUpdateMaterialNum;\n    /* 0x10 */ u8 field_0x10[0x18 - 0x10];\n    /* 0x18 */ s32 mTableOffset;\n    /* 0x1C */ s32 mUpdateMaterialIDOffset;\n    /* 0x20 */ s32 mNameTabOffset;\n    /* 0x24 */ s32 mRValuesOffset;\n    /* 0x28 */ s32 mGValuesOffset;\n    /* 0x2C */ s32 mBValuesOffset;\n    /* 0x30 */ s32 mAValuesOffset;\n};  // Size = 0x34\n\nSTATIC_ASSERT(sizeof(J3DAnmColorFullData) == 0x34);\n\nclass J3DAnmBase {\npublic:\n    J3DAnmBase(s16 i_frameMax) {\n        mAttribute = 0;\n        field_0x5 = 0;\n        mFrameMax = i_frameMax;\n        mFrame = 0.0f;\n    }\n\n    virtual ~J3DAnmBase();\n\n    u8 getAttribute() const { return mAttribute; }\n    s16 getFrameMax() const { return mFrameMax; }\n    f32 getFrame() const { return mFrame; }\n    void setFrame(f32 frame) { mFrame = frame; }\n\nprivate:\n    /* 0x4 */ u8 mAttribute;\n    /* 0x5 */ u8 field_0x5;\n    /* 0x6 */ s16 mFrameMax;\n    /* 0x8 */ f32 mFrame;\n};  // Size: 0xC\n\nclass J3DAnmTransform : public J3DAnmBase {\npublic:\n    /* 80328E40 */ J3DAnmTransform(s16, f32*, s16*, f32*);\n\n    /* 8003B93C */ virtual ~J3DAnmTransform();\n    /* 8003C77C */ virtual s32 getKind() const;\n    virtual void getTransform(u16, J3DTransformInfo*) const = 0;\n\nprivate:\n    /* 0x0C */ f32* field_0xc;\n    /* 0x10 */ s16* field_0x10;\n    /* 0x14 */ f32* field_0x14;\n    /* 0x18 */ s16 field_0x18;\n    /* 0x1A */ s16 field_0x1a;\n    /* 0x1C */ s16 field_0x1c;\n    /* 0x1E */ s16 field_0x1e;\n};  // Size: 0x20\n\nclass J3DAnmTransformKey : public J3DAnmTransform {\npublic:\n    J3DAnmTransformKey() : J3DAnmTransform(0, NULL, NULL, NULL) {\n        field_0x20 = 0;\n        field_0x24 = 0;\n    }\n\n    /* 80329A34 */ void calcTransform(f32, u16, J3DTransformInfo*) const;\n\n    /* 8003B8D0 */ virtual ~J3DAnmTransformKey();\n    /* 8003C800 */ virtual s32 getKind() const;\n    /* 8003C808 */ virtual void getTransform(u16, J3DTransformInfo*) const;\n\nprivate:\n    /* 0x20 */ int field_0x20;\n    /* 0x24 */ int field_0x24;\n};  // Size: 0x28\n\nclass J3DAnmTransformFull : public J3DAnmTransform {\npublic:\n    /* 8032C2AC */ virtual ~J3DAnmTransformFull();\n    /* 8032C318 */ virtual s32 getKind() const;\n    /* 80328E90 */ virtual void getTransform(u16, J3DTransformInfo*) const;\n\nprivate:\n    /* 0x20 */ int field_0x20;\n};  // Size: 0x24\n\nclass J3DAnmTransformFullWithLerp : public J3DAnmTransformFull {\npublic:\n    /* 8032C228 */ virtual ~J3DAnmTransformFullWithLerp();\n    /* 8032C2A4 */ virtual s32 getKind() const;\n    /* 803291F0 */ virtual void getTransform(u16, J3DTransformInfo*) const;\n};  // Size: 0x24\n\nstruct J3DTextureSRTInfo;\nclass J3DModelData;\nclass J3DMaterialTable;\n\nclass J3DAnmTextureSRTKey : public J3DAnmBase {\npublic:\n    /* 80329E5C */ J3DAnmTextureSRTKey();\n    /* 80329F14 */ void calcTransform(f32, u16, J3DTextureSRTInfo*) const;\n    /* 8032B0C0 */ void searchUpdateMaterialID(J3DMaterialTable*);\n    /* 8032B1D4 */ void searchUpdateMaterialID(J3DModelData*);\n\n    /* 8032C198 */ virtual ~J3DAnmTextureSRTKey();\n    /* 8032C220 */ virtual s32 getKind() const;\n\n    void getTransform(u16 param_0, J3DTextureSRTInfo* pSRTInfo) const {\n        calcTransform(getFrame(), param_0, pSRTInfo);\n    }\n\n    u16 getUpdateMaterialID(u16 idx) const { return mUpdateMaterialID[idx]; }\n    u16 getUpdateMaterialNum() const { return field_0x14 / 3; }\n\nprivate:\n    /* 0x0C */ int field_0xc;\n    /* 0x10 */ int field_0x10;\n    /* 0x14 */ u16 field_0x14;\n    /* 0x16 */ u16 field_0x16;\n    /* 0x18 */ u16 field_0x18;\n    /* 0x1A */ u16 field_0x1a;\n    /* 0x1C */ int field_0x1c;\n    /* 0x20 */ int field_0x20;\n    /* 0x24 */ int field_0x24;\n    /* 0x28 */ u8 mUpdateTexMtxID[4];\n    /* 0x2C */ u16* mUpdateMaterialID;\n    /* 0x30 */ JUTNameTab field_0x30;\n    /* 0x40 */ int field_0x40;\n    /* 0x44 */ u16 field_0x44;\n    /* 0x46 */ u16 field_0x46;\n    /* 0x48 */ u16 field_0x48;\n    /* 0x4A */ u16 field_0x4a;\n    /* 0x4C */ int field_0x4c;\n    /* 0x50 */ int field_0x50;\n    /* 0x54 */ int field_0x54;\n    /* 0x58 */ int field_0x58;\n    /* 0x5C */ u8 field_0x5c[4];\n    /* 0x60 */ u16* field_0x60;\n    /* 0x64 */ JUTNameTab field_0x64;\n    /* 0x74 */ u8 field_0x74[4];\n    /* 0x78 */ u32 mTexMtxCalcType;\n};  // Size: 0x7C\n\nclass J3DAnmTexPattern : public J3DAnmBase {\npublic:\n    /* 8032AED8 */ J3DAnmTexPattern();\n    /* 8032AF50 */ void getTexNo(u16, u16*) const;\n    /* 8032B004 */ void searchUpdateMaterialID(J3DMaterialTable*);\n    /* 8032B09C */ void searchUpdateMaterialID(J3DModelData*);\n\n    /* 8032BD20 */ virtual ~J3DAnmTexPattern();\n    /* 8032BD94 */ virtual s32 getKind() const;\n\nprivate:\n    /* 0x0C */ void* field_0xc;\n    /* 0x10 */ void* mAnmTable;\n    /* 0x14 */ u16 field_0x14;\n    /* 0x16 */ u16 mUpdateMaterialNum;\n    /* 0x18 */ u16* field_0x18;\n    /* 0x1C */ JUTNameTab field_0x1c;\n};  // Size: 0x2C\n\nclass J3DAnmTevRegKey : public J3DAnmBase {\npublic:\n    /* 8032AE18 */ J3DAnmTevRegKey();\n    /* 8032B1F8 */ void getTevColorReg(u16, _GXColorS10*) const;\n    /* 8032B4BC */ void getTevKonstReg(u16, _GXColor*) const;\n    /* 8032B780 */ void searchUpdateMaterialID(J3DMaterialTable*);\n    /* 8032B87C */ void searchUpdateMaterialID(J3DModelData*);\n\n    /* 8032BD9C */ virtual ~J3DAnmTevRegKey();\n    /* 8032BE24 */ virtual s32 getKind() const;\n\n    u16 getCRegUpdateMaterialNum() const { return mCRegUpdateMaterialNum; }\n    u16 getKRegUpdateMaterialNum() const { return mKRegUpdateMaterialNum; }\n\n    u16 getCRegUpdateMaterialID(u16 idx) const { return mCRegUpdateMaterialID[idx]; }\n    u16 getKRegUpdateMaterialID(u16 idx) const { return mKRegUpdateMaterialID[idx]; }\n\nprivate:\n    /* 0x0C */ u16 mCRegUpdateMaterialNum;\n    /* 0x0E */ u16 mKRegUpdateMaterialNum;\n    /* 0x10 */ u16 field_0x10;\n    /* 0x12 */ u16 field_0x12;\n    /* 0x14 */ u16 field_0x14;\n    /* 0x16 */ u16 field_0x16;\n    /* 0x18 */ u16 field_0x18;\n    /* 0x1A */ u16 field_0x1a;\n    /* 0x1C */ u16 field_0x1c;\n    /* 0x1E */ u16 field_0x1e;\n    /* 0x20 */ u16* mCRegUpdateMaterialID;\n    /* 0x24 */ JUTNameTab field_0x24;\n    /* 0x34 */ u16* mKRegUpdateMaterialID;\n    /* 0x38 */ JUTNameTab field_0x38;\n    /* 0x48 */ void* field_0x48;\n    /* 0x4C */ void* field_0x4c;\n    /* 0x50 */ int field_0x50;\n    /* 0x54 */ int field_0x54;\n    /* 0x58 */ int field_0x58;\n    /* 0x5C */ int field_0x5c;\n    /* 0x60 */ int field_0x60;\n    /* 0x64 */ int field_0x64;\n    /* 0x68 */ int field_0x68;\n    /* 0x6C */ int field_0x6c;\n};  // Size: 0x70\n\nclass J3DAnmColor : public J3DAnmBase {\npublic:\n    /* 8032A828 */ J3DAnmColor();\n    /* 8032A8A4 */ void searchUpdateMaterialID(J3DMaterialTable*);\n\n    /* 8032BCAC */ virtual ~J3DAnmColor();\n    /* 8032BF44 */ virtual s32 getKind() const;\n    /* 8032BF4C */ virtual void getColor(u16, _GXColor*) const;\n\n    u16 getUpdateMaterialNum() const { return mUpdateMaterialNum; }\n    bool isValidUpdateMaterialID(u16 id) const { return mUpdateMaterialID[id] != 0xFFFF; }\n    u16 getUpdateMaterialID(u16 idx) const { return mUpdateMaterialID[idx]; }\n\nprivate:\n    /* 0x0C */ u16 field_0xc;\n    /* 0x0E */ u16 field_0xe;\n    /* 0x10 */ u16 field_0x10;\n    /* 0x12 */ u16 field_0x12;\n    /* 0x14 */ u16 mUpdateMaterialNum;\n    /* 0x18 */ u16* mUpdateMaterialID;\n    /* 0x1C */ JUTNameTab field_0x1c;\n};  // Size: 0x2C\n\nclass J3DAnmColorKey : public J3DAnmColor {\npublic:\n    /* 8032AB00 */ J3DAnmColorKey();\n\n    /* 8032BE2C */ virtual ~J3DAnmColorKey();\n    /* 8032BEB0 */ virtual s32 getKind() const;\n    /* 8032AB54 */ virtual void getColor(u16, _GXColor*) const;\n\nprivate:\n    /* 0x2C */ int field_0x2c;\n    /* 0x30 */ int field_0x30;\n    /* 0x34 */ int field_0x34;\n    /* 0x38 */ int field_0x38;\n    /* 0x3C */ int field_0x3c;\n};\n\nclass J3DAnmColorFull : public J3DAnmColor {\npublic:\n    /* 8032AB00 */ J3DAnmColorFull();\n\n    /* 8032BE2C */ virtual ~J3DAnmColorFull();\n    /* 8032BEB0 */ virtual s32 getKind() const;\n    /* 8032AB54 */ virtual void getColor(u16, _GXColor*) const;\n\nprivate:\n    /* 0x2C */ int field_0x2c;\n    /* 0x30 */ int field_0x30;\n    /* 0x34 */ int field_0x34;\n    /* 0x38 */ int field_0x38;\n    /* 0x3C */ int field_0x3c;\n};\n\nclass J3DAnmVtxColor : public J3DAnmBase {\npublic:\n    J3DAnmVtxColor();\n\n    virtual ~J3DAnmVtxColor();\n    virtual s32 getKind() const;\n    virtual void getColor(u8, u16, _GXColor*) const;\n\nprivate:\n    /* 0x0C */ s16 mAnmTableNum[2];\n    /* 0x10 */ int mAnmVtxColorIndexData[2];\n};  // Size: 0x18\n\nclass J3DAnmVtxColorKey : public J3DAnmVtxColor {\npublic:\n    /* 8032A4E0 */ J3DAnmVtxColorKey();\n\n    /* 8032BF50 */ virtual ~J3DAnmVtxColorKey();\n    /* 8032BFBC */ virtual s32 getKind() const;\n    /* 8032A53C */ virtual void getColor(u8, u16, _GXColor*) const;\n\nprivate:\n    /* 0x18 */ int field_0x18[2];\n};\n\nclass J3DAnmVtxColorFull : public J3DAnmVtxColor {\n    /* 8032A30C */ J3DAnmVtxColorFull();\n\n    /* 8032BFC4 */ virtual ~J3DAnmVtxColorFull();\n    /* 8032C030 */ virtual s32 getKind() const;\n    /* 8032A368 */ virtual void getColor(u8, u16, _GXColor*) const;\n\nprivate:\n    /* 0x18 */ int field_0x18[2];\n};\n\nclass J3DAnmCluster : public J3DAnmBase {\npublic:\n    /* 8032BCAC */ virtual ~J3DAnmCluster();\n    /* 8032BF44 */ virtual s32 getKind() const;\n    /* 8032BF4C */ virtual f32 getWeight(u16) const;\n\nprivate:\n    /* 0x0C */ f32* field_0xc;\n};  // Size: 0x10\n\nclass J3DAnmClusterFull : public J3DAnmCluster {\npublic:\n    /* 8032BCAC */ virtual ~J3DAnmClusterFull();\n    /* 8032BF44 */ virtual s32 getKind() const;\n    /* 8032BF4C */ virtual f32 getWeight(u16) const;\n\nprivate:\n    /* 0x10 */ int field_0x10;\n};\n\nclass J3DAnmClusterKey : public J3DAnmCluster {\npublic:\n    /* 8032C044 */ virtual ~J3DAnmClusterKey();\n    /* 8032C0B0 */ virtual s32 getKind() const;\n    /* 8032A218 */ virtual f32 getWeight(u16) const;\n\nprivate:\n    /* 0x10 */ int field_0x10;\n};\n\nclass J3DFrameCtrl {\npublic:\n    enum Attribute_e {\n        LOOP_ONCE_e,\n        LOOP_ONCE_RESET_e,\n        LOOP_REPEAT_e,\n        LOOP_MIRROR_ONCE_e,\n        LOOP_MIRROR_REPEAT_e,\n    };\n\n    J3DFrameCtrl() { this->init(0); }\n    void init(s16);\n    BOOL checkPass(f32);\n    void update();\n    virtual ~J3DFrameCtrl() {}\n\n    u8 getAttribute() const { return mAttribute; }\n    void setAttribute(u8 attr) { mAttribute = attr; }\n    u8 getState() const { return mState; }\n    bool checkState(u8 state) const { return mState & state; }\n    s16 getStart() const { return mStart; }\n    void setStart(s16 start) {\n        mStart = start;\n        mFrame = start;\n    }\n    s16 getEnd() const { return mEnd; }\n    void setEnd(s16 end) { mEnd = end; }\n    s32 getLoop() { return mLoop; }\n    void setLoop(s16 loop) { mLoop = loop; }\n    f32 getRate() const { return mRate; }\n    void setRate(f32 rate) { mRate = rate; }\n    f32 getFrame() const { return mFrame; }\n    void setFrame(f32 frame) { mFrame = frame; }\n    void reset() {\n        mFrame = mStart;\n        mRate = 1.0f;\n        mState = 0;\n    }\n\nprivate:\n    /* 0x04 */ u8 mAttribute;\n    /* 0x05 */ u8 mState;\n    /* 0x06 */ s16 mStart;\n    /* 0x08 */ s16 mEnd;\n    /* 0x0A */ s16 mLoop;\n    /* 0x0C */ f32 mRate;\n    /* 0x10 */ f32 mFrame;\n};  // Size: 0x14\n\n#endif /* J3DANIMATION_H */\n/* end \"JSystem/J3DGraphAnimator/J3DAnimation.h\" */\n/* \"include/m_Do/m_Do_ext.h\" line 4 \"JSystem/J3DGraphAnimator/J3DModel.h\" */\n#ifndef J3DMODEL_H\n#define J3DMODEL_H\n\n/* \"include/JSystem/J3DGraphAnimator/J3DModel.h\" line 3 \"JSystem/J3DGraphAnimator/J3DSkinDeform.h\" */\n#ifndef J3DSKINDEFORM_H\n#define J3DSKINDEFORM_H\n\n/* \"include/JSystem/J3DGraphAnimator/J3DSkinDeform.h\" line 3 \"JSystem/J3DGraphAnimator/J3DCluster.h\" */\n#ifndef J3DCLUSTER_H\n#define J3DCLUSTER_H\n\n/* \"include/JSystem/J3DGraphAnimator/J3DCluster.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass J3DDeformer;\n\nstruct J3DCluster {\n    /* 0x00 */ f32 field_0x0;\n    /* 0x04 */ f32 field_0x4;\n    /* 0x08 */ int field_0x8;\n    /* 0x0C */ int field_0xc;\n    /* 0x10 */ u16 field_0x10;\n    /* 0x12 */ u16 field_0x12;\n    /* 0x14 */ u16 field_0x14;\n    /* 0x16 */ u16 field_0x16;\n    /* 0x18 */ u16 field_0x18[2];\n    /* 0x1C */ int field_0x1c;\n    /* 0x20 */ J3DDeformer* mDeformer;\n};\n\nstruct J3DClusterKey {};\n\n#endif /* J3DCLUSTER_H */\n/* end \"JSystem/J3DGraphAnimator/J3DCluster.h\" */\n/* \"include/JSystem/J3DGraphAnimator/J3DSkinDeform.h\" line 4 \"JSystem/J3DGraphAnimator/J3DMtxBuffer.h\" */\n#ifndef J3DMTXBUFFER_H\n#define J3DMTXBUFFER_H\n\n/* \"include/JSystem/J3DGraphAnimator/J3DMtxBuffer.h\" line 3 \"JSystem/J3DGraphAnimator/J3DModelData.h\" */\n/* end \"JSystem/J3DGraphAnimator/J3DModelData.h\" */\n/* \"include/JSystem/J3DGraphAnimator/J3DMtxBuffer.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass J3DModelData;\n\nclass J3DMtxBuffer {\npublic:\n    J3DMtxBuffer() { initialize(); }\n\n    /* 80326214 */ void initialize();\n    /* 80326258 */ s32 create(J3DModelData*, u32);\n    /* 80326364 */ s32 createAnmMtx(J3DModelData*);\n    /* 803263F0 */ s32 createWeightEnvelopeMtx(J3DModelData*);\n    /* 8032648C */ s32 setNoUseDrawMtx();\n    /* 803264B8 */ s32 createDoubleDrawMtx(J3DModelData*, u32);\n    /* 80326664 */ s32 createBumpMtxArray(J3DModelData*, u32);\n    /* 803268D4 */ void calcWeightEnvelopeMtx();\n    /* 80326ACC */ void calcDrawMtx(u32, Vec const&, f32 const (&)[3][4]);\n    /* 80326D3C */ void calcNrmMtx();\n    /* 80326EF0 */ void calcBBoardMtx();\n\n    MtxP getAnmMtx(int idx) const { return mpAnmMtx[idx]; }\n    void setAnmMtx(int i, Mtx m) { MTXCopy(m, (MtxP)mpAnmMtx[i]); }\n    MtxP getWeightAnmMtx(int idx) const { return mpWeightEvlpMtx[idx]; }\n    MtxP getUserAnmMtx(int idx) const { return mpUserAnmMtx[idx]; }\n\n    void setScaleFlag(int idx, u8 flag) { mpScaleFlagArr[idx] = flag; }\n    u32* getCurrentViewNoPtr() { return &mCurrentViewNo; }\n    u8* getScaleFlagArray() const { return mpScaleFlagArr; }\n    u8 getScaleFlag(int idx) const { return mpScaleFlagArr[idx]; }\n    u8 getEnvScaleFlag(int idx) const { return mpEvlpScaleFlagArr[idx]; }\n    Mtx** getDrawMtxPtrPtr() const { return mpDrawMtxArr[1]; }\n    Mtx* getDrawMtxPtr() const { return mpDrawMtxArr[1][mCurrentViewNo]; }\n    Mtx* getDrawMtx(u16 idx) const { return &mpDrawMtxArr[1][mCurrentViewNo][idx]; }\n    Mtx33** getNrmMtxPtrPtr() const { return mpNrmMtxArr[1]; }\n    Mtx33* getNrmMtxPtr() const { return mpNrmMtxArr[1][mCurrentViewNo]; }\n    Mtx33* getNrmMtx(u16 idx) const { return &mpNrmMtxArr[1][mCurrentViewNo][idx]; }\n    Mtx33*** getBumpMtxPtrPtr() const { return mpBumpMtxArr[1]; }\n    Mtx33* getBumpMtxPtr(int idx) const { return mpBumpMtxArr[1][idx][mCurrentViewNo]; }\n    J3DJointTree* getJointTree() const { return mJointTree; }\n\n    void swapDrawMtx() {\n        Mtx* tmp = mpDrawMtxArr[0][mCurrentViewNo];\n        mpDrawMtxArr[0][mCurrentViewNo] = mpDrawMtxArr[1][mCurrentViewNo];\n        mpDrawMtxArr[1][mCurrentViewNo] = tmp;\n    }\n\n    void swapNrmMtx() {\n        Mtx33* tmp = mpNrmMtxArr[0][mCurrentViewNo];\n        mpNrmMtxArr[0][mCurrentViewNo] = mpNrmMtxArr[1][mCurrentViewNo];\n        mpNrmMtxArr[1][mCurrentViewNo] = tmp;\n    }\n\n    static Mtx sNoUseDrawMtx;\n    static Mtx33 sNoUseNrmMtx;\n    static Mtx* sNoUseDrawMtxPtr;\n    static Mtx33* sNoUseNrmMtxPtr;\n\nprivate:\n    /* 0x00 */ J3DJointTree* mJointTree;\n    /* 0x04 */ u8* mpScaleFlagArr;\n    /* 0x08 */ u8* mpEvlpScaleFlagArr;\n    /* 0x0C */ Mtx* mpAnmMtx;\n    /* 0x10 */ Mtx* mpWeightEvlpMtx;\n    /* 0x14 */ Mtx** mpDrawMtxArr[2];\n    /* 0x1C */ Mtx33** mpNrmMtxArr[2];\n    /* 0x28 */ Mtx33*** mpBumpMtxArr[2];\n    /* 0x2C */ u32 mFlags;\n    /* 0x30 */ u32 mCurrentViewNo;\n    /* 0x34 */ Mtx* mpUserAnmMtx;\n\npublic:\n    /* 803283B4 */ virtual ~J3DMtxBuffer();\n};\n\nvoid J3DCalcViewBaseMtx(f32 (*param_0)[4], Vec const& param_1, f32 const (&param_2)[3][4],\n                            f32 (*param_3)[4]);\n\n#endif /* J3DMTXBUFFER_H */\n/* end \"JSystem/J3DGraphAnimator/J3DMtxBuffer.h\" */\n/* \"include/JSystem/J3DGraphAnimator/J3DSkinDeform.h\" line 5 \"JSystem/J3DGraphBase/J3DTransform.h\" */\n/* end \"JSystem/J3DGraphBase/J3DTransform.h\" */\n/* \"include/JSystem/J3DGraphAnimator/J3DSkinDeform.h\" line 6 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass J3DModel;\nclass J3DAnmCluster;\n\nclass J3DDeformData {\npublic:\n    /* 8032E1F8 */ J3DDeformData();\n    /* 8032E230 */ void offAllFlag(u32);\n    /* 8032E298 */ void deform(J3DVertexBuffer*);\n    /* 8032E274 */ void deform(J3DModel*);\n    /* 8032E364 */ void setAnm(J3DAnmCluster*);\n\nprivate:\n    /* 0x00 */ u16 mClusterNum;\n    /* 0x02 */ u16 mClusterKeyNum;\n    /* 0x04 */ u16 field_0x4;\n    /* 0x08 */ J3DCluster** mClusterPointer;\n    /* 0x0C */ J3DClusterKey** mClusterKeyPointer;\n    /* 0x10 */ int field_0x10;\n    /* 0x14 */ u16 field_0x14;\n    /* 0x16 */ u16 field_0x16;\n    /* 0x18 */ void* mVtxPos;\n    /* 0x1C */ void* mVtxNrm;\n    /* 0x20 */ int field_0x20;\n    /* 0x24 */ int field_0x24;\n};  // Size: 0x28\n\nstruct J3DSkinNList {\n    /* 8032C6E4 */ J3DSkinNList();\n    /* 8032C85C */ void calcSkin_VtxPosF32(f32 (*)[4], void*, void*);\n    /* 8032C8E4 */ void calcSkin_VtxNrmF32(f32 (*)[4], void*, void*);\n\n    /* 0x00 */ u16* field_0x0;\n    /* 0x04 */ u16* field_0x4;\n    /* 0x08 */ f32* field_0x8;\n    /* 0x0C */ f32* field_0xc;\n    /* 0x10 */ u16 field_0x10;\n    /* 0x12 */ u16 field_0x12;\n};  // Size: 0x14\n\nclass J3DSkinDeform {\npublic:\n    /* 8032C96C */ J3DSkinDeform();\n    /* 8032C9B0 */ void initSkinInfo(J3DModelData*);\n    /* 8032CF44 */ int initMtxIndexArray(J3DModelData*);\n    /* 8032D378 */ void changeFastSkinDL(J3DModelData*);\n    /* 8032D5C4 */ void calcNrmMtx(J3DMtxBuffer*);\n    /* 8032D738 */ void transformVtxPosNrm(J3DModelData*);\n    /* 8032D87C */ void calcAnmInvJointMtx(J3DMtxBuffer*);\n    /* 8032D8F4 */ void deformFastVtxPos_F32(J3DVertexBuffer*, J3DMtxBuffer*) const;\n    /* 8032DA1C */ void deformFastVtxNrm_F32(J3DVertexBuffer*, J3DMtxBuffer*) const;\n    /* 8032DB50 */ void deformVtxPos_F32(J3DVertexBuffer*, J3DMtxBuffer*) const;\n    /* 8032DC74 */ void deformVtxPos_S16(J3DVertexBuffer*, J3DMtxBuffer*) const;\n    /* 8032DDB8 */ void deformVtxNrm_F32(J3DVertexBuffer*) const;\n    /* 8032DEBC */ void deformVtxNrm_S16(J3DVertexBuffer*) const;\n    /* 8032DFDC */ void deform(J3DModel*);\n    void setNrmMtx(int i, MtxP mtx) {\n        J3DPSMtx33CopyFrom34(mtx, (Mtx3P)mNrmMtx[i]);\n    }\n    Mtx3P getNrmMtx(int i) { return mNrmMtx[i]; }\n    void onFlag(u32 flag) { mFlags |= flag; }\n    void offFlag(u32 flag) { mFlags &= ~flag; }\n    bool checkFlag(u32 flag) { return mFlags & flag; }\n\n    /* 8032E064 */ virtual void deform(J3DVertexBuffer*, J3DMtxBuffer*);\n    /* 8032E1B0 */ virtual ~J3DSkinDeform();\n\n    static u16* sWorkArea_WEvlpMixMtx[1024];\n    static f32* sWorkArea_WEvlpMixWeight[1024];\n    static u16 sWorkArea_MtxReg[1024 + 4 /* padding */];\n\nprivate:\n    /* 0x04 */ u16* mPosData;\n    /* 0x08 */ u16* mNrmData;\n    /* 0x0C */ Mtx* mPosMtx;\n    /* 0x10 */ Mtx33* mNrmMtx;\n    /* 0x14 */ u32 mFlags;\n    /* 0x18 */ u8 field_0x18;\n    /* 0x19 */ u8 field_0x19;\n    /* 0x1C */ int field_0x1c;\n    /* 0x20 */ int field_0x20;\n    /* 0x24 */ J3DSkinNList* mSkinNList;\n};\n\nclass J3DDeformer {\npublic:\n    /* 8032E39C */ J3DDeformer(J3DDeformData*);\n    /* 8032EAB4 */ void deform(J3DVertexBuffer*, u16, f32*);\n    /* 8032E3BC */ void deform(J3DVertexBuffer*, u16);\n    /* 8032E4A4 */ void deform_VtxPosF32(J3DVertexBuffer*, J3DCluster*, J3DClusterKey*, f32*);\n    /* 8032E60C */ void deform_VtxNrmF32(J3DVertexBuffer*, J3DCluster*, J3DClusterKey*, f32*);\n    /* 8032EBCC */ void normalizeWeight(int, f32*);\n\nprivate:\n    /* 0x00 */ J3DDeformData* mDeformData;\n    /* 0x04 */ J3DAnmCluster* mAnmCluster;\n    /* 0x08 */ int field_0x8;\n    /* 0x0C */ int field_0xc;\n    /* 0x10 */ u32 mFlags;\n};  // Size: 0x14\n\ninline void J3DFillZero32B(register void* param_0, register u32 param_1) {\n    asm {\n        srwi param_1, param_1, 5\n        mtctr param_1\n    lbl_8032D948:\n    \tdcbz 0, param_0\n    \taddi param_0, param_0, 0x20\n    \tbdnz lbl_8032D948\n    }\n}\n\n#endif /* J3DSKINDEFORM_H */\n/* end \"JSystem/J3DGraphAnimator/J3DSkinDeform.h\" */\n/* \"include/JSystem/J3DGraphAnimator/J3DModel.h\" line 4 \"JSystem/J3DGraphBase/J3DPacket.h\" */\n#ifndef J3DPACKET_H\n#define J3DPACKET_H\n\n/* \"include/JSystem/J3DGraphBase/J3DPacket.h\" line 3 \"JSystem/J3DGraphBase/J3DSys.h\" */\n/* end \"JSystem/J3DGraphBase/J3DSys.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DPacket.h\" line 4 \"dolphin/gd/GDBase.h\" */\n#ifndef GDBASE_H\n#define GDBASE_H\n\n/* \"include/dolphin/gd/GDBase.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct GDLObj {\n    /* 0x0 */ u8* start;\n    /* 0x4 */ u32 length;\n    /* 0x8 */ u8* ptr;\n    /* 0xC */ u8* end;\n} GDLObj;  // Size: 0x10\n\nextern GDLObj* __GDCurrentDL;\n\ntypedef void (*GDOverflowCallback)(void);\n\nvoid GDInitGDLObj(GDLObj*, u8*, u32);\nvoid GDFlushCurrToMem();\nvoid GDPadCurr32();\nvoid GDOverflowed(void);\n\ninline void __GDWrite(u8 data) {\n    *__GDCurrentDL->ptr++ = data;\n}\n\ninline void GDSetCurrent(GDLObj* obj) {\n    __GDCurrentDL = obj;\n}\n\ninline u32 GDGetGDLObjOffset(GDLObj* obj) {\n    return (u32)(obj->ptr - obj->start);\n}\n\ninline u8* GDGetCurrPointer() {\n    return __GDCurrentDL->ptr;\n}\n\ninline s32 GDGetCurrOffset() {\n    return __GDCurrentDL->ptr - __GDCurrentDL->start;\n}\n\ninline void GDSetCurrOffset(s32 offs) {\n    __GDCurrentDL->ptr = __GDCurrentDL->start + offs;\n}\n\ninline void GDAdvCurrOffset(s32 offs) {\n    __GDCurrentDL->ptr += offs;\n}\n\ninline void GDOverflowCheck(u32 len) {\n    if (__GDCurrentDL->ptr + len > __GDCurrentDL->end) {\n        GDOverflowed();\n    }\n}\n\ninline void GDWrite_u32(u32 v) {\n    GDOverflowCheck(4);\n    __GDWrite((v >> 24) & 0xff);\n    __GDWrite((v >> 16) & 0xff);\n    __GDWrite((v >> 8) & 0xff);\n    __GDWrite((v >> 0) & 0xff);\n}\n\ninline void GDWrite_u16(u16 v) {\n    GDOverflowCheck(2);\n    __GDWrite(v >> 8);\n    __GDWrite(v & 0xff);\n}\n\ninline void GDWrite_u8(u8 v) {\n    GDOverflowCheck(1);\n    __GDWrite(v);\n}\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* GDBASE_H */\n/* end \"dolphin/gd/GDBase.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DPacket.h\" line 5 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass J3DMatPacket;\n\nclass J3DDrawBuffer;\nclass J3DMaterial;\nclass J3DMaterialAnm;\nclass J3DModel;\nclass J3DMtxBuffer;\nclass J3DShape;\nclass J3DTexMtx;\nclass J3DTexMtxObj;\nclass J3DTexture;\n\ninline u32 getDiffFlag_LightObjNum(u32 param_1) {\n    return (param_1 & 0xf0) >> 4;\n}\n\ninline u32 getDiffFlag_TexGenNum(u32 param_1) {\n    return (param_1 & 0xf00) >> 8;\n}\n\ninline int calcDifferedBufferSize_TexMtxSize(int param_1) {\n  return param_1 * 0x35;\n}\n\ninline int calcDifferedBufferSize_TexGenSize(int param_1) {\n    return param_1 * 0x3d + 10;\n}\n\ninline u32 getDiffFlag_TexNoNum(u32 param_1) {\n    return (param_1 & 0xf0000) >> 0x10;\n}\n\ninline int calcDifferedBufferSize_TexNoSize(int param_1) {\n    return param_1 * 0x37;\n}\n\ninline u32 calcDifferedBufferSize_TexNoAndTexCoordScaleSize(u32 param_1) {\n    u32 res = param_1 * 0x37;\n    res += ((param_1 + 1) >> 1) * 0x37;\n    return res;\n}\n\ninline u32 getDiffFlag_TevStageNum(u32 param_1) {\n    return (param_1 & 0xf00000) >> 0x14;\n}\n\ninline int calcDifferedBufferSize_TevStageSize(int param_1) {\n    return param_1 * 10;\n}\n\ninline int calcDifferedBufferSize_TevStageDirectSize(int param_1) {\n    return param_1 * 5;\n}\n\nclass J3DDisplayListObj {\npublic:\n    J3DDisplayListObj() {\n        mpData[0] = NULL;\n        mpData[1] = NULL;\n        mSize = 0;\n        mCapacity = 0;\n    }\n\n    J3DError newDisplayList(u32);\n    J3DError newSingleDisplayList(u32);\n    J3DError single_To_Double();\n    void setSingleDisplayList(void*, u32);\n    void swapBuffer();\n    void callDL() const;\n    void beginDL();\n    u32 endDL();\n    void beginPatch();\n    u32 endPatch();\n\n    u8* getDisplayList(int idx) const { return (u8*)mpData[idx]; }\n    u32 getDisplayListSize() const { return mSize; }\n\n    static GDLObj sGDLObj;\n    static s32 sInterruptFlag;\n\n    /* 0x0 */ void* mpData[2];\n    /* 0x8 */ u32 mSize;\n    /* 0xC */ u32 mCapacity;\n};  // Size: 0x10\n\nclass J3DPacket {\npublic:\n    J3DPacket() {\n        mpNextPacket = NULL;\n        mpFirstChild = NULL;\n        mpUserData = NULL;\n    }\n\n    void addChildPacket(J3DPacket*);\n    \n    J3DPacket* getNextPacket() const { return mpNextPacket; }\n    void setNextPacket(J3DPacket* i_packet) { mpNextPacket = i_packet; }\n\n    void drawClear() {\n        mpNextPacket = NULL;\n        mpFirstChild = NULL;\n    }\n\n    void setUserArea(u32 area) { mpUserData = (void*)area; }\n\n    virtual int entry(J3DDrawBuffer*);\n    virtual void draw();\n    virtual ~J3DPacket() {}\n\npublic:\n    /* 0x04 */ J3DPacket* mpNextPacket;\n    /* 0x08 */ J3DPacket* mpFirstChild;\n    /* 0x0C */ void* mpUserData;\n};  // Size: 0x10\n\nclass J3DDrawPacket : public J3DPacket {\npublic:\n    J3DDrawPacket();\n    ~J3DDrawPacket();\n    J3DError newDisplayList(u32);\n    J3DError newSingleDisplayList(u32);\n    virtual void draw();\n\n    J3DDisplayListObj* getDisplayListObj() const { return mpDisplayListObj; }\n    void setDisplayListObj(J3DDisplayListObj* pObj) { mpDisplayListObj = pObj; }\n\n    void beginPatch() { mpDisplayListObj->beginPatch(); }\n    void endPatch() { mpDisplayListObj->endPatch(); }\n\n    void callDL() const { getDisplayListObj()->callDL(); }\n\n    enum {\n        LOCKED = 0x01,\n    };\n\n    bool checkFlag(u32 flag) const { return (mFlags & flag) != 0; }\n    void onFlag(u32 flag) { mFlags |= flag; }\n    void offFlag(u32 flag) { mFlags &= ~flag; }\n    void lock() { onFlag(LOCKED); }\n    void unlock() { offFlag(LOCKED); }\n    J3DTexMtxObj* getTexMtxObj() const { return mpTexMtxObj; }\n    bool isLocked() const { return checkFlag(1); }\n\npublic:\n    /* 0x10 */ u32 mFlags;\n    /* 0x14 */ char mPad0[0x0C];  // unk\n    /* 0x20 */ J3DDisplayListObj* mpDisplayListObj;\n    /* 0x24 */ J3DTexMtxObj* mpTexMtxObj;\n};  // Size: 0x28\n\nclass J3DShapePacket : public J3DDrawPacket {\npublic:\n    J3DShapePacket();\n    u32 calcDifferedBufferSize(u32);\n    J3DError newDifferedDisplayList(u32);\n    void prepareDraw() const;\n    void drawFast();\n\n    virtual ~J3DShapePacket();\n    virtual void draw();\n\n    void setShape(J3DShape* pShape) { mpShape = pShape; }\n    void setModel(J3DModel* pModel) { mpModel = pModel; }\n    void setMtxBuffer(J3DMtxBuffer* pMtxBuffer) { mpMtxBuffer = pMtxBuffer; }\n    void setBaseMtxPtr(Mtx* pMtx) { mpBaseMtxPtr = pMtx; }\n\n    J3DShape* getShape() const { return mpShape; }\n    J3DModel* getModel() const { return mpModel; }\n    Mtx* getBaseMtxPtr() const { return mpBaseMtxPtr; }\n\npublic:\n    /* 0x28 */ J3DShape* mpShape;\n    /* 0x2C */ J3DMtxBuffer* mpMtxBuffer;\n    /* 0x30 */ Mtx* mpBaseMtxPtr;\n    /* 0x34 */ u32 mDiffFlag;\n    /* 0x38 */ J3DModel* mpModel;\n};  // Size: 0x3C\n\nclass J3DMatPacket : public J3DDrawPacket {\npublic:\n    J3DMatPacket();\n    void addShapePacket(J3DShapePacket*);\n    void beginDiff();\n    void endDiff();\n    bool isSame(J3DMatPacket*) const;\n\n    J3DMaterial* getMaterial() const { return mpMaterial; }\n    J3DShapePacket* getShapePacket() const { return mpShapePacket; }\n    void setShapePacket(J3DShapePacket* packet) { mpShapePacket = packet; }\n    void setInitShapePacket(J3DShapePacket* packet) { mpInitShapePacket = packet; }\n    void setMaterialAnmID(J3DMaterialAnm* materialAnm) { mpMaterialAnm = materialAnm; }\n    bool isChanged() const { return mDiffFlag & 0x80000000; }\n    bool isEnabled_Diff() const { return mpInitShapePacket->getDisplayListObj() != NULL; }\n\n    virtual ~J3DMatPacket();\n    virtual int entry(J3DDrawBuffer*);\n    virtual void draw();\n\npublic:\n    /* 0x28 */ J3DShapePacket* mpInitShapePacket;\n    /* 0x2C */ J3DShapePacket* mpShapePacket;\n    /* 0x30 */ J3DMaterial* mpMaterial;\n    /* 0x34 */ u32 mDiffFlag;\n    /* 0x38 */ J3DTexture* mpTexture;\n    /* 0x3C */ J3DMaterialAnm* mpMaterialAnm;\n};  // Size: 0x40\n\n#endif /* J3DPACKET_H */\n/* end \"JSystem/J3DGraphBase/J3DPacket.h\" */\n/* \"include/JSystem/J3DGraphAnimator/J3DModel.h\" line 5 \"JSystem/J3DGraphBase/J3DVertex.h\" */\n/* end \"JSystem/J3DGraphBase/J3DVertex.h\" */\n/* \"include/JSystem/J3DGraphAnimator/J3DModel.h\" line 6 \"dolphin/mtx/mtxvec.h\" */\n/* end \"dolphin/mtx/mtxvec.h\" */\n/* \"include/JSystem/J3DGraphAnimator/J3DModel.h\" line 7 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nenum J3DMdlFlag {\n    /* 0x00001 */ J3DMdlFlag_Unk00001 = 0x1,\n    /* 0x00002 */ J3DMdlFlag_Unk00002 = 0x2,\n    /* 0x00004 */ J3DMdlFlag_SkinPosCpu = 0x4,\n    /* 0x00008 */ J3DMdlFlag_SkinNrmCpu = 0x8,\n    /* 0x00010 */ J3DMdlFlag_Unk00010 = 0x10, \n    /* 0x20000 */ J3DMdlFlag_Unk20000 = 0x20000,\n    /* 0x40000 */ J3DMdlFlag_Unk40000 = 0x40000,\n    /* 0x80000 */ J3DMdlFlag_Unk80000 = 0x80000,\n};\n\nstruct J3DUnkCalc1 {\n    virtual void calc(J3DModel* model);\n};\n\nstruct J3DUnkCalc2 {\n    virtual void unk();\n    virtual void calc(J3DModelData* mpModelData);\n};\n\ntypedef void (*J3DCalcCallBack)(J3DModel*, u32 timing);\n\nclass J3DModel {\npublic:\n    J3DModel() {\n        initialize();\n    }\n    J3DModel(J3DModelData* param_0, u32 param_1, u32 param_2) {\n        initialize();\n        entryModelData(param_0, param_1, param_2);\n    }\n\n    /* 800CFFF4 */ void setBaseTRMtx(f32 (*)[4]);\n    /* 80327100 */ void initialize();\n    /* 80327184 */ s32 entryModelData(J3DModelData*, u32, u32);\n    /* 80327300 */ s32 createShapePacket(J3DModelData*);\n    /* 803273CC */ s32 createMatPacket(J3DModelData*, u32);\n    /* 803275FC */ s32 newDifferedDisplayList(u32);\n    /* 8032767C */ void lock();\n    /* 803276B4 */ void unlock();\n    /* 803279A0 */ void diff();\n    /* 80327A2C */ s32 setDeformData(J3DDeformData*, u32);\n    /* 80327AA0 */ s32 setSkinDeform(J3DSkinDeform*, u32);\n    /* 80327BD4 */ void calcAnmMtx();\n    /* 80327C58 */ void calcWeightEnvelopeMtx();\n    /* 80328190 */ void calcNrmMtx();\n    /* 803281B4 */ void calcBumpMtx();\n    /* 803282B8 */ void calcBBoardMtx();\n    /* 803282EC */ void prepareShapePackets();\n    MtxP getAnmMtx(int);\n\n    /* 80327CA4 */ virtual void update();\n    /* 80327E4C */ virtual void entry();\n    /* 80327CF0 */ virtual void calc();\n    /* 803276EC */ virtual void calcMaterial();\n    /* 80327858 */ virtual void calcDiffTexMtx();\n    /* 80327F40 */ virtual void viewCalc();\n    /* 80328350 */ virtual ~J3DModel();\n\n    J3DModelData* getModelData() { return mModelData; }\n\n    void onFlag(u32 flag) { mFlags |= flag; }\n    void offFlag(u32 flag) { mFlags &= ~flag; }\n    bool checkFlag(u32 flag) const { return (mFlags & flag) ? true : false; }\n\n    bool isCpuSkinningOn() const { return (mFlags & J3DMdlFlag_SkinPosCpu) && (mFlags & J3DMdlFlag_SkinNrmCpu); }\n\n    Mtx& getBaseTRMtx() { return mBaseTransformMtx; }\n    void i_setBaseTRMtx(Mtx m) { MTXCopy(m, mBaseTransformMtx); }\n    u32 getMtxCalcMode() const { return mFlags & 0x03; }\n    J3DVertexBuffer* getVertexBuffer() const { return (J3DVertexBuffer*)&mVertexBuffer; }\n    J3DMatPacket* getMatPacket(u16 idx) const { return &mMatPacket[idx]; }\n    J3DShapePacket* getShapePacket(u16 idx) const { return &mShapePacket[idx]; }\n    J3DMtxBuffer* getMtxBuffer() const { return mMtxBuffer; }\n    void setScaleFlag(int idx, u8 flag) { mMtxBuffer->setScaleFlag(idx, flag); }\n    Mtx33* getBumpMtxPtr(int idx) const { return mMtxBuffer->getBumpMtxPtr(idx); }\n    Mtx33* getNrmMtxPtr() const { return mMtxBuffer->getNrmMtxPtr(); }\n    Mtx* getDrawMtxPtr() const { return mMtxBuffer->getDrawMtxPtr(); }\n    void setBaseScale(const Vec& scale) { mBaseScale = scale; }\n    void setUserArea(u32 area) { mUserArea = area; }\n    u32 getUserArea() const { return mUserArea; }\n    Vec* getBaseScale() { return &mBaseScale; }\n    void setAnmMtx(int i, Mtx m) { mMtxBuffer->setAnmMtx(i, m); }\n\n    // is there a better way to handle inlines with same name as non-inlines?\n    MtxP i_getAnmMtx(int p1) { return mMtxBuffer->getAnmMtx(p1); }\n    void i_setAnmMtx(int p1, Mtx mtx) { mMtxBuffer->setAnmMtx(p1, mtx); }\n\n    /* 0x04 */ J3DModelData* mModelData;\n    /* 0x08 */ u32 mFlags;\n    /* 0x0C */ u32 mDiffFlag;\n    /* 0x10 */ J3DCalcCallBack mCalcCallBack;\n    /* 0x14 */ u32 mUserArea;\n    /* 0x18 */ Vec mBaseScale;\n    /* 0x24 */ Mtx mBaseTransformMtx;\n    /* 0x54 */ Mtx mInternalView;\n    /* 0x84 */ J3DMtxBuffer* mMtxBuffer;\n    /* 0x88 */ J3DVertexBuffer mVertexBuffer;\n    /* 0xC0 */ J3DMatPacket* mMatPacket;\n    /* 0xC4 */ J3DShapePacket* mShapePacket;\n    /* 0xC8 */ J3DDeformData* mDeformData;\n    /* 0xCC */ J3DSkinDeform* mSkinDeform;\n    /* 0xD0 */ J3DVtxColorCalc* mVtxColorCalc;\n    /* 0xD4 */ J3DUnkCalc1* mUnkCalc1;\n    /* 0xD8 */ J3DUnkCalc2* mUnkCalc2;\n};\n\n#endif /* J3DMODEL_H */\n/* end \"JSystem/J3DGraphAnimator/J3DModel.h\" */\n/* \"include/m_Do/m_Do_ext.h\" line 5 \"Z2AudioLib/Z2SoundObject.h\" */\n#ifndef Z2SOUNDOBJECT_H\n#define Z2SOUNDOBJECT_H\n\n/* \"include/Z2AudioLib/Z2SoundObject.h\" line 3 \"Z2AudioLib/Z2SoundHandles.h\" */\n#ifndef Z2SOUNDHANDLES_H\n#define Z2SOUNDHANDLES_H\n\n/* \"include/Z2AudioLib/Z2SoundHandles.h\" line 3 \"JSystem/JAudio2/JAISoundHandles.h\" */\n#ifndef JAISOUNDHANDLES_H\n#define JAISOUNDHANDLES_H\n\n/* \"include/JSystem/JAudio2/JAISoundHandles.h\" line 3 \"JSystem/JAudio2/JAISound.h\" */\n#ifndef JAISOUND_H\n#define JAISOUND_H\n\n/* \"include/JSystem/JAudio2/JAISound.h\" line 3 \"JSystem/JAudio2/JAISoundParams.h\" */\n#ifndef JAISOUNDPARAMS_H\n#define JAISOUNDPARAMS_H\n\n/* \"include/JSystem/JAudio2/JAISoundParams.h\" line 3 \"JSystem/JAudio2/JASSoundParams.h\" */\n#ifndef JASSOUNDPARAMS_H\n#define JASSOUNDPARAMS_H\n\n/* \"include/JSystem/JAudio2/JASSoundParams.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nstruct JASSoundParams {\n    /* 8029E3B0 */ void clamp();\n    /* 8029E47C */ void combine(JASSoundParams const&, JASSoundParams const&);\n\n    void initVolume() { mVolume = 1.0f; }\n    void initFxMix() { mFxMix = 0.0f; }\n    void initPitch() { mPitch = 1.0f; }\n    void initPan() { mPan = 0.5f; }\n    void initDolby() { mDolby = 0.0f; }\n    void init() {\n        initVolume();\n        initPitch();\n        initFxMix();\n        initPan();\n        initDolby();\n    }\n\n    JASSoundParams() { init(); }\n\n    void clampVolume() {\n        if (mVolume < 0.0f)\n            mVolume = 0.0f;\n        else if (mVolume > 1.0f)\n            mVolume = 1.0f;\n    }\n\n    void clampFxMix(void) {\n        if (mFxMix < 0.0f)\n            mFxMix = 0.0f;\n        else if (mFxMix > 1.0f)\n            mFxMix = 1.0f;\n    }\n\n    void clampPitch() {\n        if (mPitch < 0.0f)\n            mPitch = 0.0f;\n        else if (mPitch > 8.0f)\n            mPitch = 8.0f;\n    }\n\n    void clampPan() {\n        if (mPan < 0.0f)\n            mPan = 0.0f;\n        else if (mPan > 1.0f)\n            mPan = 1.0f;\n    }\n    \n    void clampDolby() {\n        if (mDolby < 0.0f)\n            mDolby = 0.0f;\n        else if (mDolby > 1.0f)\n            mDolby = 1.0f;\n    }\n\n    /* 0x00 */ f32 mVolume;\n    /* 0x04 */ f32 mFxMix;\n    /* 0x08 */ f32 mPitch;\n    /* 0x0C */ f32 mPan;\n    /* 0x10 */ f32 mDolby;\n};  // Size: 0x14\n\n#endif /* JASSOUNDPARAMS_H */\n/* end \"JSystem/JAudio2/JASSoundParams.h\" */\n\nstruct JAISoundParamsProperty {\n    void init() {\n        field_0x0 = 1.0f;\n        field_0x4 = 0.0f;\n        field_0x8 = 1.0f;\n    }\n\n    /* 0x00 */ f32 field_0x0;\n    /* 0x04 */ f32 field_0x4;\n    /* 0x08 */ f32 field_0x8;\n};  // Size: 0xC\n\nstruct JAISoundParamsTransition {\n    struct TTransition {\n        void zero() {\n            field_0x0 = 0.0f;\n            mCount = 0;\n            field_0x4 = 0.0f;\n        }\n\n        void set(f32 newValue, f32 intensity, u32 fadeCount) {\n            mCount = fadeCount;\n            field_0x0 = (newValue - intensity) / mCount;\n            field_0x4 = newValue;\n        }\n\n        f32 apply(f32 param_0) {\n            if (mCount > 1) {\n                mCount--;\n                param_0 += field_0x0;\n            } else {\n                if (mCount == 1) {\n                    mCount = 0;\n                    param_0 = field_0x4;\n                }\n            }\n            return param_0;\n        }\n\n        /* 0x0 */ f32 field_0x0;\n        /* 0x4 */ f32 field_0x4;\n        /* 0x8 */ u32 mCount;\n    };  // Size: 0xC\n\n    void init() {\n        mVolume.zero();\n        mPitch.zero();\n        mFxMix.zero();\n        mPan.zero();\n        mDolby.zero();\n    }\n\n    void apply(JASSoundParams* pParams) {\n        pParams->mVolume = mVolume.apply(pParams->mVolume);\n        pParams->mPitch = mPitch.apply(pParams->mPitch);\n        pParams->mFxMix = mFxMix.apply(pParams->mFxMix);\n        pParams->mDolby = mDolby.apply(pParams->mDolby);\n        pParams->mPan = mPan.apply(pParams->mPan);\n    }\n\n    /* 0x00 */ TTransition mVolume;\n    /* 0x0C */ TTransition mPitch;\n    /* 0x18 */ TTransition mFxMix;\n    /* 0x24 */ TTransition mPan;\n    /* 0x30 */ TTransition mDolby;\n};  // Size: 0x3C\n\nstruct JAISoundParamsMove {\n    JAISoundParamsMove() : mParams() {}\n\n    void init() {\n        mParams.init();\n        mTransition.init();\n    }\n\n    void calc() { mTransition.apply(&mParams); }\n\n    /* 802A2DB4 */ void moveVolume(f32, u32);\n    /* 802A2E0C */ void movePitch(f32, u32);\n    /* 802A2E64 */ void moveFxMix(f32, u32);\n    /* 802A2EBC */ void movePan(f32, u32);\n    /* 802A2F14 */ void moveDolby(f32, u32);\n\n    /* 0x00 */ JASSoundParams mParams;\n    /* 0x14 */ JAISoundParamsTransition mTransition;\n};  // Size: 0x50\n\nstruct JAISoundParams {\n    JAISoundParams() : mMove() {}\n    void mixOutAll(JASSoundParams const&, JASSoundParams*, f32);\n\n    void init() {\n        mMove.init();\n        mProperty.init();\n    }\n\n    /* 0x0 */ JAISoundParamsProperty mProperty;\n    /* 0xC */ JAISoundParamsMove mMove;\n};  // Size: 0x5C\n// OG Size: 0x20\n\n#endif /* JAISOUNDPARAMS_H */\n/* end \"JSystem/JAudio2/JAISoundParams.h\" */\n/* \"include/JSystem/JAudio2/JAISound.h\" line 4 \"JSystem/JAudio2/JAIAudible.h\" */\n#ifndef JAIAUDIBLE_H\n#define JAIAUDIBLE_H\n\n/* \"include/JSystem/JAudio2/JAIAudible.h\" line 3 \"JSystem/JGeometry.h\" */\n/* end \"JSystem/JGeometry.h\" */\n\nstruct JASSoundParams;\n\nclass JAIAudible {\npublic:\n    virtual ~JAIAudible();\n    virtual JASSoundParams* getOuterParams(int) = 0;\n    virtual void calc() = 0;\n\n    JGeometry::TVec3<float>& getPos() { return mPos; }\n    void setPos(const JGeometry::TVec3<float>& other) { mPos.set(other); }\n\n    /* 0x04 */ JGeometry::TVec3<float> mPos;\n};\n\n#endif /* JAIAUDIBLE_H */\n/* end \"JSystem/JAudio2/JAIAudible.h\" */\n/* \"include/JSystem/JAudio2/JAISound.h\" line 5 \"global.h\" */\n/* end \"global.h\" */\n\nclass JAISoundID {\npublic:\n    operator u32() const { return this->mId.mFullId; }\n    void operator=(JAISoundID const& other) { mId.mFullId = other.mId.mFullId; };\n\n    JAISoundID(u32 pId) { mId.mFullId = pId; };\n\n    JAISoundID(JAISoundID const& other) { mId = other.mId; };\n\n    JAISoundID() {}\n\n    bool isAnonymous() { return mId.mFullId == 0xffffffff; }\n    void setAnonymous() { mId.mFullId = -1; }\n\n    union {\n        u32 mFullId;\n        struct {\n            u8 b0;\n            u8 b1;\n            u8 b2;\n            u8 b3;\n        } mBytes;\n        struct {\n            u16 mSoundType;\n            u16 mShortId;\n        } mAdvancedId;  // Debug doesn't have an inline for referencing the short ID so I assume\n                        // it's similar to this\n    } mId;\n};\n\nclass JASTrack;\n\nstruct JAISoundStatus_ {\n    /* 802A2220 */ s32 lockWhenPrepared();\n    /* 802A2244 */ s32 unlockIfLocked();\n\n    void init() {\n        field_0x0.value = 0;\n        field_0x1.value = 0;\n        *((u16*)&state) = 0;\n        user_data = 0;\n    }\n\n    bool isAlive();  // used in assert\n    bool isDead() { return state.unk == 6;}\n\n    inline bool isPlaying() { return state.unk == 5; }\n\n    inline bool isMute() { return field_0x0.flags.mute; }\n    inline bool isPaused() { return field_0x0.flags.paused; }\n    void pauseWhenOut() {\n        field_0x1.flags.flag6 = 1;\n    }\n\n    /* 0x0 */ union {\n        u8 value;\n        struct {\n            u8 mute : 1;\n            u8 paused : 1;\n            u8 flag3 : 1;\n            u8 flag4 : 1;\n            u8 flag5 : 1;\n            u8 flag6 : 1;\n            u8 flag7 : 1;\n            u8 flag8 : 1;\n        } flags;\n    } field_0x0;\n    /* 0x1 */ union {\n        u8 value;\n        struct {\n            u8 flag1 : 1;\n            u8 flag2 : 1;\n            u8 flag3 : 1;\n            u8 flag4 : 1;\n            u8 flag5 : 1;\n            u8 flag6 : 1;\n            u8 flag7 : 1;\n            u8 flag8 : 1;\n        } flags;\n    } field_0x1;\n    /* 0x2 */ struct {\n        u8 unk;\n        struct {\n            u8 flag1 : 1;\n            u8 flag2 : 1;\n            u8 animationState : 2;\n            u8 flag5 : 1;\n            u8 flag6 : 1;\n            u8 flag7 : 1;\n            u8 flag8 : 1;\n        } flags;\n    } state;\n    /* 0x4 */ u32 user_data;\n};  // Size: 0x6\n\nstruct JAISoundFader {\n    void forceIn() {\n        mIntensity = 1.0f;\n        mTransition.zero();\n    }\n    void forceOut() {\n        mIntensity = 0.0f;\n        mTransition.zero();\n    }\n    void fadeOut(u32 fadeCount) {\n        if (fadeCount != 0) {\n            mTransition.set(0.0f, mIntensity, fadeCount);\n        } else {\n            forceOut();\n        }\n    }\n    void fadeIn(u32 param_1) {\n        if (param_1 == 0) {\n            forceIn();\n        } else {\n            mTransition.set(1.0f, mIntensity, param_1);\n        }\n    }\n    void fadeInFromOut(u32 param_1) {\n        mIntensity = 0.0f;\n        fadeIn(param_1);\n    }\n    bool isOut() {\n        return (mTransition.mCount == 0 && mIntensity < 0.01f);\n    }\n    inline void calc() { mIntensity = mTransition.apply(mIntensity); }\n    f32 getIntensity() { return mIntensity; }\n\n    /* 0x00 */ f32 mIntensity;\n    /* 0x04 */ JAISoundParamsTransition::TTransition mTransition;\n};  // Size: 0x10\ntemplate <typename A0>\nstruct JAISoundStrategyMgr__unknown {\n    virtual void virtual2();\n    virtual void virtual3(A0*);\n    virtual void virtual4(A0*, const JASSoundParams&);\n};\n\ntemplate <typename A0>\nstruct JAISoundStrategyMgr {\n    virtual void virtual2();\n    virtual JAISoundStrategyMgr__unknown<A0>* virtual3(JAISoundID);\n    virtual void virtual4(JAISoundStrategyMgr__unknown<A0>*);\n};\n/* JAISoundStrategyMgr<JAISe> */\nstruct JAISoundStrategyMgr__template0 {};\n/* JAISoundStrategyMgr<JAISeq> */\nstruct JAISoundStrategyMgr__template1 {};\n/* JAISoundStrategyMgr<JAIStream> */\nstruct JAISoundStrategyMgr__template2 {};\n\nclass JAISoundActivity {\npublic:\n    void init() { field_0x0.value = 0; }\n\n    /* 0x0 */ union {\n        u8 value;\n        struct {\n            u8 flag1 : 1;\n            u8 flag2 : 1;\n            u8 flag3 : 1;\n            u8 flag4 : 1;\n            u8 flag5 : 1;\n            u8 flag6 : 1;\n            u8 flag7 : 1;\n            u8 flag8 : 1;\n        } flags;\n    } field_0x0;\n};\n\nclass JAITempoMgr {\npublic:\n    /* 0x00 */ f32 mTempo;\n    /* 0x04 */ JAISoundParamsTransition::TTransition field_0x4;\n\n    JAITempoMgr() { init(); }\n    void init() { setTempo(1.0f); }\n    void setTempo(f32 param_0) {\n        mTempo = param_0;\n        field_0x4.zero();\n    }\n    f32 getTempo() { return mTempo; }\n    void calc() { mTempo = field_0x4.apply(mTempo); }\n};\n\nclass JAISoundHandle;\nclass JAIAudible;\nclass JAIAudience;\nclass JAISe;\nclass JAISeq;\nclass JAISoundChild;\nclass JAIStream;\nclass JAITempoMgr;\nclass JAISound {\npublic:\n    /* 802A21A0 */ void releaseHandle();\n    /* 802A21BC */ void attachHandle(JAISoundHandle*);\n    /* 802A22F8 */ JAISound();\n    /* 802A2328 */ void start_JAISound_(JAISoundID, JGeometry::TVec3<f32> const*, JAIAudience*);\n    /* 802A244C */ bool acceptsNewAudible() const;\n    /* 802A2474 */ void newAudible(JGeometry::TVec3<f32> const&, JGeometry::TVec3<f32> const*, u32,\n                                   JAIAudience*);\n    /* 802A2598 */ void stop();\n    /* 802A24DC */ void stop(u32 fadeout);\n    /* 802A25F0 */ void die_JAISound_();\n    /* 802A266C */ void increasePrepareCount_JAISound_();\n    /* 802A26B8 */ bool calc_JAISound_();\n    /* 802A29DC */ void initTrack_JAISound_(JASTrack*);\n\n    virtual s32 getNumChild() const = 0;\n    virtual JAISoundChild* getChild(int) = 0;\n    virtual void releaseChild(int) = 0;\n    /* 802A25D8 */ virtual JAISe* asSe();\n    /* 802A25E0 */ virtual JAISeq* asSeq();\n    /* 802A25E8 */ virtual JAIStream* asStream();\n    virtual JASTrack* getTrack() = 0;\n    virtual JASTrack* getChildTrack(int) = 0;\n    virtual JAITempoMgr* getTempoMgr() = 0;\n    virtual bool JAISound_tryDie_() = 0;\n\n    JAISoundID getID() const;\n    u8 getAnimationState() const { return status_.state.flags.animationState; }\n    bool isAnimated() const { return getAnimationState() != 0; }\n    void setAnimationState(u8 pState) {\n        status_.state.flags.animationState = pState;\n    }\n    u32 getUserData() const { return status_.user_data; }\n    void setUserData(u32 pUserData) { status_.user_data = pUserData; }\n    JAIAudible* getAudible() const { return audible_; }\n    bool isHandleAttached() const { return handle_ != NULL; }\n    bool hasLifeTime() const { return status_.field_0x1.flags.flag2; }\n    void removeLifeTime_() { status_.field_0x1.flags.flag1 = false; }\n    void stop_JAISound_() {\n        status_.state.flags.flag5 = 0;\n        status_.state.flags.flag1 = 1;\n    }\n    bool isStopping() {\n        bool isStopping = false;\n        if (status_.state.flags.flag1) {\n            isStopping = !status_.state.flags.flag5 || fader.isOut();\n        }\n        return isStopping;\n    }\n\n    void pause(bool param_0) {\n        status_.field_0x0.flags.paused = param_0;\n    }\n\n    void updateLifeTime(u32 param_0) {\n        if (lifeTime < param_0) {\n            lifeTime = param_0;\n        }\n    }\n\n    void setLifeTime(u32 param_0, bool param_1) {\n        lifeTime = param_0;\n        setComesBack(param_1);\n        status_.field_0x1.flags.flag2 = 1;\n    }\n\n    void setComesBack(bool param_0) {\n        status_.field_0x1.flags.flag1 = 1;\n        if (param_0) {\n            status_.pauseWhenOut();\n        }\n    }\n\n    bool setPos(const JGeometry::TVec3<f32>& param_1) {\n        if (audible_ != NULL) {\n            audible_->setPos(param_1);\n        }\n        return audible_ != NULL;\n    }\n\n    void fadeIn(u32 param_1) {\n        fader.fadeInFromOut(param_1);\n        return;\n    }\n\n    s32 getCount() const { return mCount; }\n\n    JAISoundParamsMove& getAuxiliary() { return params.mMove; }\n\n    /* 0x04 */ JAISoundHandle* handle_;\n    /* 0x08 */ JAIAudible* audible_;\n    /* 0x0C */ JAIAudience* audience_;\n    /* 0x10 */ u32 lifeTime;\n    /* 0x14 */ s32 prepareCount;\n    /* 0x18 */ JAISoundID soundID;\n    /* 0x1C */ JAISoundStatus_ status_;\n    /* 0x24 */ JAISoundFader fader;\n    /* 0x34 */ u32 mPriority;\n    /* 0x38 */ s32 mCount;\n    /* 0x3C */ JAISoundParams params;\n};  // Size: 0x98\n\nSTATIC_ASSERT(sizeof(JAISound) == 0x98);\n\n#endif /* JAISOUND_H */\n/* end \"JSystem/JAudio2/JAISound.h\" */\n/* \"include/JSystem/JAudio2/JAISoundHandles.h\" line 4 \"JSystem/JUtility/JUTAssert.h\" */\n#ifndef JUTASSERT_H\n#define JUTASSERT_H\n\n/* \"include/JSystem/JUtility/JUTAssert.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n/* \"include/JSystem/JUtility/JUTAssert.h\" line 4 \"dolphin/os/OS.h\" */\n#ifndef OS_H_\n#define OS_H_\n\n/* \"include/dolphin/os/OS.h\" line 3 \"__va_arg.h\" */\n#ifndef __VA_ARG_H\n#define __VA_ARG_H\n\n/* \"libs/PowerPC_EABI_Support/Runtime/Inc/__va_arg.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef struct __va_list_struct {\n    char gpr;\n    char fpr;\n    char reserved[2];\n    char* input_arg_area;\n    char* reg_save_area;\n} _va_list_struct;\n\ntypedef _va_list_struct __va_list[1];\n\n#ifdef __cplusplus\nextern \"C\" void* __va_arg(_va_list_struct*, int);\n#else\nvoid* __va_arg(_va_list_struct*, int);\n#endif\n\n#if IN_VSCODE_EDITOR\n#define __builtin_va_info(...)\n#define _var_arg_typeof(...)\n#endif\n\n// from defined-string in mwcceppc.exe:\n// __builtin_va_info: initialize the __va_list_struct\n// _var_arg_typeof: convert type to integer for __va_arg\n#define __va_start(list, fmt) __builtin_va_info(&list)\n#define __va_arg(list, type) (*((type*)__va_arg(list, _var_arg_typeof(type))))\n#define va_start __va_start\n#define va_arg __va_arg\n#define va_end __va_end\n#define va_list __va_list\n#define __va_end(list) ((void)0)\n\n#define __va_copy(a, b) (*(a) = *(b))\n\n#endif /* __VA_ARG_H */\n/* end \"__va_arg.h\" */\n/* \"include/dolphin/os/OS.h\" line 4 \"dolphin/dvd/dvd.h\" */\n#ifndef DVD_H\n#define DVD_H\n\n/* \"include/dolphin/dvd/dvd.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef enum DVDState {\n    DVD_STATE_END = 0x0,\n    DVD_STATE_BUSY = 0x1,\n    DVD_STATE_WAITING = 0x2,\n    DVD_STATE_COVER_CLOSED = 0x3,\n    DVD_STATE_NO_DISK = 0x4,\n    DVD_STATE_COVER_OPEN = 0x5,\n    DVD_STATE_WRONG_DISK = 0x6,\n    DVD_STATE_MOTOR_STOPPED = 0x7,\n    DVD_STATE_IGNORED = 0x8,\n    DVD_STATE_CANCELED = 0xa,  // lmao they skipped 9\n    DVD_STATE_RETRY = 0xb,\n    DVD_STATE_FATAL_ERROR = -1,\n} DVDState;\n\n\ntypedef enum DVDResult {\n    DVD_RESULT_GOOD = 0,\n    DVD_RESULT_FATAL_ERROR = -1,\n    DVD_RESULT_IGNORED = -2,\n    DVD_RESULT_CANCELED = -3,\n} DVDResult;\n\ntypedef struct DVDDirectory {\n    /* 0x0 */ u32 entry_number;\n    /* 0x4 */ u32 location;\n    /* 0x8 */ u32 next;\n} DVDDirectory;\n\ntypedef struct DVDDirectoryEntry {\n    /* 0x0 */ u32 entry_number;\n    /* 0x4 */ BOOL is_directory;\n    /* 0x8 */ char* name;\n} DVDDirectoryEntry;\n\ntypedef struct DVDDiskID {\n    /* 0x00 */ char game_name[4];\n    /* 0x04 */ char company[2];\n    /* 0x06 */ u8 disk_number;\n    /* 0x07 */ u8 game_version;\n    /* 0x08 */ u8 is_streaming;\n    /* 0x09 */ u8 streaming_buffer_size;\n    /* 0x0A */ u8 padding[22];\n} DVDDiskID;\n\nstruct DVDFileInfo;\nstruct DVDCommandBlock;\ntypedef void (*DVDCBCallback)(s32 result, struct DVDCommandBlock* block);\ntypedef void (*DVDCallback)(s32 result, struct DVDFileInfo* info);\n\ntypedef struct DVDCommandBlock {\n    /* 0x00 */ struct DVDCommandBlock* next;\n    /* 0x04 */ struct DVDCommandBlock* prev;\n    /* 0x08 */ u32 command;\n    /* 0x0C */ s32 state;\n    /* 0x10 */ u32 offset;\n    /* 0x14 */ u32 length;\n    /* 0x18 */ void* buffer;\n    /* 0x1C */ u32 current_transfer_size;\n    /* 0x20 */ u32 transferred_size;\n    /* 0x24 */ DVDDiskID* disk_id;\n    /* 0x28 */ DVDCBCallback callback;\n    /* 0x2C */ void* user_data;\n} DVDCommandBlock;\n\ntypedef struct DVDFileInfo {\n    /* 0x00 */ DVDCommandBlock block;\n    /* 0x30 */ u32 start_address;\n    /* 0x34 */ u32 length;\n    /* 0x38 */ DVDCallback callback;\n} DVDFileInfo;\n\ntypedef struct DVDDriveInfo {\n    /* 0x00 */ u16 revision_level;\n    /* 0x02 */ u16 device_code;\n    /* 0x04 */ u32 release_date;\n    /* 0x08 */ u8 padding[24];\n} DVDDriveInfo;\n\ntypedef struct DVDBB1 {\n  u32 appLoaderLength;\n  void* appLoaderFunc1;\n  void* appLoaderFunc2;\n  void* appLoaderFunc3;\n} DVDBB1;\n\ntypedef struct DVDBB2 {\n  u32 bootFilePosition;\n  u32 FSTPosition;\n  u32 FSTLength;\n  u32 FSTMaxLength;\n  void* FSTAddress;\n  u32 userPosition;\n  u32 userLength;\n\n  u32 padding0;\n} DVDBB2;\n\n#define DVD_MIN_TRANSFER_SIZE 32\n\ntypedef void (*DVDOptionalCommandChecker)(DVDCommandBlock* block, void (*cb)(u32 intType));\n\nvoid DVDInit(void);\nBOOL DVDOpen(const char* filename, DVDFileInfo* fileinfo);\nBOOL DVDClose(DVDFileInfo* fileinfo);\nBOOL DVDReadPrio(DVDFileInfo* fileinfo, void*, s32, s32, s32);\nDVDDiskID* DVDGetCurrentDiskID(void);\nBOOL DVDFastOpen(long, DVDFileInfo* fileinfo);\ns32 DVDGetCommandBlockStatus(const DVDCommandBlock* block);\nBOOL DVDReadAsyncPrio(DVDFileInfo* fileinfo, void*, long, long, DVDCallback, long);\nint DVDConvertPathToEntrynum(const char*);\ns32 DVDGetDriveStatus(void);\nBOOL DVDCheckDisk(void);\nBOOL DVDChangeDir(const char* dirname);\nBOOL DVDCloseDir(DVDDirectory* dir);\nBOOL DVDOpenDir(const char*, DVDDirectory* dir);\nBOOL DVDReadDir(DVDDirectory* dir, DVDDirectoryEntry* entry);\nBOOL DVDReadAbsAsyncPrio(DVDCommandBlock* block, void* addr, s32 length, s32 offset,\n                         DVDCBCallback callback, s32 prio);\nBOOL DVDReadAbsAsyncForBS(DVDCommandBlock* block, void* addr, s32 length, s32 offset,\n                          DVDCBCallback callback);\nBOOL DVDReadDiskID(DVDCommandBlock* block, DVDDiskID* diskID, DVDCBCallback callback);\nBOOL DVDCancelStreamAsync(DVDCommandBlock* block, DVDCBCallback callback);\nBOOL DVDInquiryAsync(DVDCommandBlock* block, DVDDriveInfo* info, DVDCBCallback callback);\nvoid DVDReset(void);\nBOOL DVDSetAutoInvalidation(BOOL autoInval);\nvoid DVDResume(void);\nstatic BOOL DVDCancelAsync(DVDCommandBlock* block, DVDCBCallback callback);\ns32 DVDCancel(DVDCommandBlock* block);\nvoid __DVDPrepareResetAsync(DVDCBCallback callbac);\nBOOL DVDCompareDiskID(DVDDiskID* id1, DVDDiskID* id2);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* DVD_H */\n/* end \"dolphin/dvd/dvd.h\" */\n\n/* \"include/dolphin/os/OS.h\" line 6 \"dolphin/os/OSAlarm.h\" */\n#ifndef OSALARM_H\n#define OSALARM_H\n\n/* \"include/dolphin/os/OSAlarm.h\" line 3 \"dolphin/os/OSError.h\" */\n#ifndef OSERROR_H\n#define OSERROR_H\n\n/* \"include/dolphin/os/OSError.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct OSContext OSContext;\n\nextern u32 __OSFpscrEnableBits;\ntypedef u16 OSError;\n\n#define OS_ERROR_SYSTEM_RESET 0\n#define OS_ERROR_MACHINE_CHECK 1\n#define OS_ERROR_DSI 2\n#define OS_ERROR_ISI 3\n#define OS_ERROR_INTERRUPT 4\n#define OS_ERROR_ALIGNMENT 5\n#define OS_ERROR_PROGRAM 6\n#define OS_ERROR_FLOATING_POINT 7\n#define OS_ERROR_DECREMENTER 8\n#define OS_ERROR_SYSTEM_CALL 9\n#define OS_ERROR_TRACE 10\n#define OS_ERROR_PERFORMANCE_MONITOR 11\n#define OS_ERROR_BREAKPOINT 12\n#define OS_ERROR_RESERVED 13\n#define OS_ERROR_THERMAL_INTERRUPT 14\n#define OS_ERROR_MEMORY_PROTECTION 15\n#define OS_ERROR_FLOATING_POINT_EXCEPTION 16\n\ntypedef enum {\n    EXCEPTION_SYSTEM_RESET,\n    EXCEPTION_MACHINE_CHECK,\n    EXCEPTION_DSI,\n    EXCEPTION_ISI,\n    EXCEPTION_EXTERNAL_INTERRUPT,\n    EXCEPTION_ALIGNMENT,\n    EXCEPTION_PROGRAM,\n    EXCEPTION_FLOATING_POINT,\n    EXCEPTION_DECREMENTER,\n    EXCEPTION_SYSTEM_CALL,\n    EXCEPTION_TRACE\t,\n    EXCEPTION_PERFORMANCE_MONITOR,\n    EXCEPTION_BREAKPOINT,\n    EXCEPTION_RESERVED,\n    EXCEPTION_THERMAL_INTERRUPT,\n    EXCEPTION_MEMORY_PROTECTION,\n    EXCEPTION_FLOATING_POINT_EXCEPTION,\n} OSException;\n\ntypedef u8 __OSException;\n\ntypedef void (*OSErrorHandler)(OSError error, OSContext* context, u32, u32);\n// Using this type for the C++ handlers makes stuff not match\ntypedef void (*OSErrorHandlerEx)(OSError error, OSContext* context, u32, u32, ...);\n\nOSErrorHandler OSSetErrorHandler(OSError error, OSErrorHandler handler);\nvoid __OSUnhandledException(__OSException exception, OSContext* context, u32 dsisr, u32 dar);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSERROR_H */\n/* end \"dolphin/os/OSError.h\" */\n/* \"include/dolphin/os/OSAlarm.h\" line 4 \"dolphin/os/OSTime.h\" */\n#ifndef OSTIME_H\n#define OSTIME_H\n\n/* \"include/dolphin/os/OSTime.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef s64 OSTime;\ntypedef u32 OSTick;\n\nOSTime OS_SYSTEM_TIME : 0x800030D8;\n\ntypedef struct OSCalendarTime {\n    /* 0x00 */ s32 seconds;\n    /* 0x04 */ s32 minutes;\n    /* 0x08 */ s32 hours;\n    /* 0x0C */ s32 day_of_month;\n    /* 0x10 */ s32 month;\n    /* 0x14 */ s32 year;\n    /* 0x18 */ s32 week_day;\n    /* 0x1C */ s32 year_day;\n    /* 0x20 */ s32 milliseconds;\n    /* 0x24 */ s32 microseconds;\n} OSCalendarTime;\n\nOSTime OSGetTime(void);\nOSTick OSGetTick(void);\nOSTime __OSGetSystemTime(void);\nOSTime __OSTimeToSystemTime(OSTime time);\nvoid GetDates(s32 days, OSCalendarTime* ct);\nvoid OSTicksToCalendarTime(OSTime ticks, OSCalendarTime* ct);\n\nextern u32 __OSBusClock : 0x800000F8;\n\n#define OS_BUS_CLOCK (__OSBusClock)\n#define OS_CORE_CLOCK (*(u32*)0x800000FC)\n#define OS_TIMER_CLOCK (OS_BUS_CLOCK / 4)\n#define OS_TIMER_CLOCK_MS (OS_TIMER_CLOCK / 1000)\n\n#define OSTicksToCycles(ticks) (((ticks) * ((OS_CORE_CLOCK * 2) / OS_TIMER_CLOCK)) / 2)\n#define OSTicksToSeconds(ticks) ((ticks) / OS_TIMER_CLOCK)\n#define OSTicksToMilliseconds(ticks) ((ticks) / (OS_TIMER_CLOCK / 1000))\n#define OSTicksToMicroseconds(ticks) (((ticks)*8) / (OS_TIMER_CLOCK / 125000))\n#define OSTicksToNanoseconds(ticks) (((ticks)*8000) / (OS_TIMER_CLOCK / 125000))\n#define OSSecondsToTicks(sec) ((sec)*OS_TIMER_CLOCK)\n#define OSMillisecondsToTicks(msec) ((msec) * (OS_TIMER_CLOCK / 1000))\n#define OSMicrosecondsToTicks(usec) (((usec) * (OS_TIMER_CLOCK / 125000)) / 8)\n#define OSNanosecondsToTicks(nsec) (((nsec) * (OS_TIMER_CLOCK / 125000)) / 8000)\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSTIME_H */\n/* end \"dolphin/os/OSTime.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct OSAlarmLink {\n    /* 0x0 */ struct OSAlarm* prev;\n    /* 0x4 */ struct OSAlarm* next;\n} OSAlarmLink;\n\ntypedef struct OSAlarm;\ntypedef void (*OSAlarmHandler)(struct OSAlarm* alarm, OSContext* context);\n\ntypedef struct OSAlarm {\n    /* 0x00 */ OSAlarmHandler handler;\n    /* 0x04 */ u32 tag;\n    /* 0x08 */ OSTime fire_time;\n    /* 0x10 */ OSAlarmLink link;\n    /* 0x18 */ OSTime period_time;\n    /* 0x20 */ OSTime start_time;\n} OSAlarm;  // Size: 0x28\n\ntypedef struct OSAlarmQueue {\n    OSAlarm* head;\n    OSAlarm* tail;\n} OSAlarmQueue;\n\nvoid OSInitAlarm(void);\nvoid OSCreateAlarm(OSAlarm* alarm);\nstatic void InsertAlarm(OSAlarm* alarm, s64 time, OSAlarmHandler handler);\nvoid OSSetAlarm(OSAlarm* alarm, s64 time, OSAlarmHandler handler);\nvoid OSSetPeriodicAlarm(OSAlarm* alarm, s64 start, s64 period, OSAlarmHandler handler);\nvoid OSCancelAlarm(OSAlarm* alarm);\nstatic void DecrementerExceptionCallback(__OSException exception, OSContext* context);\nstatic void DecrementerExceptionHandler(__OSException exception, OSContext* context);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSALARM_H */\n/* end \"dolphin/os/OSAlarm.h\" */\n/* \"include/dolphin/os/OS.h\" line 7 \"dolphin/os/OSAlloc.h\" */\n#ifndef OSALLOC_H\n#define OSALLOC_H\n\n/* \"include/dolphin/os/OSAlloc.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct OSHeapDescriptor {\n    /* 0x0 */ s32 size;\n    /* 0x4 */ struct OSHeapCell* freeList;\n    /* 0x8 */ struct OSHeapCell* usedList;\n} OSHeapDescriptor;\n\ntypedef struct OSHeapCell {\n    /* 0x00 */ struct OSHeapCell* prev;\n    /* 0x04 */ struct OSHeapCell* next;\n    /* 0x08 */ s32 size;\n    /* 0x0C */ struct OSHeapDescriptor* hd;\n    /* 0x10 */ s32 usedSize;\n    /* 0x14 */ char field_0x14[0x20 - 0x14];\n} OSHeapCell;\n\ntypedef u32 OSHeapHandle;\n\nextern volatile s32 __OSCurrHeap;\n\n#define OSRoundUp32B(x) (((u32)(x) + 0x1F) & ~(0x1F))\n#define OSRoundDown32B(x) (((u32)(x)) & ~(0x1F))\n\n#define OSRoundUp(x, align) (((x) + (align)-1) & (-(align)))\n#define OSRoundUpPtr(x, align) ((void*)((((u32)(x)) + (align)-1) & (~((align)-1))))\n\n#define OSRoundDown(x, align) ((x) & (-(align)))\n#define OSRoundDownPtr(x, align) ((void*)(((u32)(x)) & (~((align)-1))))\n\nstatic OSHeapCell* DLInsert(OSHeapCell* list, OSHeapCell* child);\nvoid OSFreeToHeap(OSHeapHandle handle, void* ptr);\ns32 OSSetCurrentHeap(OSHeapHandle handle);\nvoid* OSInitAlloc(void* lo, void* hi, s32 maxHeaps);\nOSHeapHandle OSCreateHeap(void* start, void* end);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSALLOC_H */\n/* end \"dolphin/os/OSAlloc.h\" */\n/* \"include/dolphin/os/OS.h\" line 8 \"dolphin/os/OSArena.h\" */\n#ifndef OSARENA_H\n#define OSARENA_H\n\n/* \"include/dolphin/os/OSArena.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid* OSGetArenaHi(void);\nvoid* OSGetArenaLo(void);\nvoid OSSetArenaHi(void* hi);\nvoid OSSetArenaLo(void* lo);\nvoid* OSAllocFromArenaLo(u32 size, s32 alignment);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSARENA_H */\n/* end \"dolphin/os/OSArena.h\" */\n/* \"include/dolphin/os/OS.h\" line 9 \"dolphin/os/OSAudioSystem.h\" */\n#ifndef OSAUDIOSYSTEM_H\n#define OSAUDIOSYSTEM_H\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid __OSInitAudioSystem(void);\nvoid __OSStopAudioSystem(void);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSAUDIOSYSTEM_H */\n/* end \"dolphin/os/OSAudioSystem.h\" */\n/* \"include/dolphin/os/OS.h\" line 10 \"dolphin/os/OSCache.h\" */\n#ifndef OSCACHE_H\n#define OSCACHE_H\n\n/* \"include/dolphin/os/OSCache.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic void DCEnable(void);\nvoid DCInvalidateRange(void* start, u32 nBytes);\nvoid DCFlushRange(void* start, u32 nBytes);\nvoid DCStoreRange(void* start, u32 nBytes);\nvoid DCFlushRangeNoSync(void* start, u32 nBytes);\nvoid DCStoreRangeNoSync(void* start, u32 nBytes);\nvoid DCZeroRange(void* start, u32 nBytes);\nvoid ICInvalidateRange(void* start, u32 nBytes);\nvoid ICFlashInvalidate(void);\nstatic void ICEnable(void);\nvoid __LCEnable(void);\nvoid LCEnable(void);\nvoid LCDisable(void);\nstatic void LCStoreBlocks(void* destAddr, void* srcAddr, u32 blockNum);\nu32 LCStoreData(void* destAddr, void* srcAddr, u32 nBytes);\nvoid LCQueueWait(u32 len);\nstatic void L2GlobalInvalidate(void);\nstatic void DMAErrorHandler(u16 error, struct OSContext* context, ...);\nvoid __OSCacheInit(void);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSCACHE_H */\n/* end \"dolphin/os/OSCache.h\" */\n/* \"include/dolphin/os/OS.h\" line 11 \"dolphin/os/OSContext.h\" */\n/* end \"dolphin/os/OSContext.h\" */\n/* \"include/dolphin/os/OS.h\" line 12 \"dolphin/os/OSError.h\" */\n/* end \"dolphin/os/OSError.h\" */\n/* \"include/dolphin/os/OS.h\" line 13 \"dolphin/os/OSExec.h\" */\n#ifndef OSEXEC_H\n#define OSEXEC_H\n\n/* \"include/dolphin/os/OSExec.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    /* 0x00 */ BOOL valid;\n    /* 0x04 */ u32 restartCode;\n    /* 0x08 */ u32 bootDol;\n    /* 0x0C */ void* regionStart;\n    /* 0x10 */ void* regionEnd;\n    /* 0x18 */ BOOL argsUseDefault;\n    /* 0x14 */ void* argsAddr;  // valid only when argsUseDefault = FALSE\n} OSExecParams;\n\nstatic s32 PackArgs(void* param_0, u32 param_1, void* param_2);\nstatic void Run(int param_0);\nstatic void ReadDisc(void* param_0, s32 param_1, s32 param_2);\nstatic void Callback(void);\nvoid __OSGetExecParams(OSExecParams* param_0);\nvoid __OSBootDolSimple(u32 param_0, u32 param_1, void* param_2, void* param_3, s32 param_4, u32 param_5, void* param_6);\nvoid __OSBootDol(s32 param_0, u32 param_1, char** param_2);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSEXEC_H */\n/* end \"dolphin/os/OSExec.h\" */\n/* \"include/dolphin/os/OS.h\" line 14 \"dolphin/os/OSFont.h\" */\n#ifndef OSFONT_H\n#define OSFONT_H\n\n/* \"include/dolphin/os/OSFont.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef enum {\n    OS_FONT_ENCODE_ANSI,\n    OS_FONT_ENCODE_SJIS,\n    OS_FONT_ENCODE_2,\n    OS_FONT_ENCODE_UTF8,\n    OS_FONT_ENCODE_UTF16,\n    OS_FONT_ENCODE_UTF32,\n    OS_FONT_ENCODE_MAX\n} OSFontEncode;\n\ntypedef struct OSFontHeader {\n    /* 0x00 */ u16 type;          \n    /* 0x02 */ u16 firstChar;     \n    /* 0x04 */ u16 lastChar;      \n    /* 0x06 */ u16 invalidChar;   \n    /* 0x08 */ u16 ascent;        \n    /* 0x0A */ u16 descent;       \n    /* 0x0C */ u16 width;         \n    /* 0x0E */ u16 leading;       \n    /* 0x10 */ u16 cellWidth;     \n    /* 0x12 */ u16 cellHeight;    \n    /* 0x14 */ u32 sheetSize;     \n    /* 0x18 */ u16 sheetFormat;   \n    /* 0x1A */ u16 sheetNumCol;   \n    /* 0x1C */ u16 sheetNumRow;   \n    /* 0x1E */ u16 sheetWidth;    \n    /* 0x20 */ u16 sheetHeight;   \n    /* 0x22 */ u16 widthTableOfs; \n    /* 0x24 */ u32 sheetImageOfs; \n    /* 0x28 */ u32 sheetFullSize; \n    /* 0x2C */ u8 c0;             \n    /* 0x2D */ u8 c1;             \n    /* 0x2E */ u8 c2;             \n    /* 0x2F */ u8 c3;             \n} OSFontHeader;\n\nstatic u32 GetFontCode(u16 param_0, u16 param_1);\nu16 OSGetFontEncode(void);\nstatic const u8* ParseStringS(u16 encode, const u8* str, OSFontHeader** fontOut, u32* codeOut);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSFONT_H */\n/* end \"dolphin/os/OSFont.h\" */\n/* \"include/dolphin/os/OS.h\" line 15 \"dolphin/os/OSInterrupt.h\" */\n#ifndef OSINTERRUPT_H\n#define OSINTERRUPT_H\n\n/* \"include/dolphin/os/OSInterrupt.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct OSContext OSContext;\n\ntypedef enum {\n    OS_INTR_MEM_0,\n    OS_INTR_MEM_1,\n    OS_INTR_MEM_2,\n    OS_INTR_MEM_3,\n    OS_INTR_MEM_ADDRESS,\n    OS_INTR_DSP_AI,\n    OS_INTR_DSP_ARAM,\n    OS_INTR_DSP_DSP,\n    OS_INTR_AI_AI,\n    OS_INTR_EXI_0_EXI,\n    OS_INTR_EXI_0_TC,\n    OS_INTR_EXI_0_EXT,\n    OS_INTR_EXI_1_EXI,\n    OS_INTR_EXI_1_TC,\n    OS_INTR_EXI_1_EXT,\n    OS_INTR_EXI_2_EXI,\n    OS_INTR_EXI_2_TC,\n    OS_INTR_PI_CP,\n    OS_INTR_PI_PE_TOKEN,\n    OS_INTR_PI_PE_FINISH,\n    OS_INTR_PI_SI,\n    OS_INTR_PI_DI,\n    OS_INTR_PI_RSW,\n    OS_INTR_PI_ERROR,\n    OS_INTR_PI_VI,\n    OS_INTR_PI_DEBUG,\n    OS_INTR_PI_HSP,\n    OS_INTR_PI_ACR,\n    OS_INTR_28,\n    OS_INTR_29,\n    OS_INTR_30,\n    OS_INTR_31,\n\n    OS_INTR_MAX\n} OSInterruptType;\n\n#define OS_INTERRUPTMASK(interrupt) (0x80000000u >> (interrupt))\n\n#define OS_INTERRUPTMASK_MEM_0 OS_INTERRUPTMASK(OS_INTR_MEM_0)\n#define OS_INTERRUPTMASK_MEM_1 OS_INTERRUPTMASK(OS_INTR_MEM_1)\n#define OS_INTERRUPTMASK_MEM_2 OS_INTERRUPTMASK(OS_INTR_MEM_2)\n#define OS_INTERRUPTMASK_MEM_3 OS_INTERRUPTMASK(OS_INTR_MEM_3)\n#define OS_INTERRUPTMASK_MEM_ADDRESS OS_INTERRUPTMASK(OS_INTR_MEM_ADDRESS)\n#define OS_INTERRUPTMASK_MEM                                                                       \\\n  (OS_INTERRUPTMASK_MEM_0 | OS_INTERRUPTMASK_MEM_1 | OS_INTERRUPTMASK_MEM_2 |                      \\\n   OS_INTERRUPTMASK_MEM_3 | OS_INTERRUPTMASK_MEM_ADDRESS)\n\n#define OS_INTERRUPTMASK_DSP_AI OS_INTERRUPTMASK(OS_INTR_DSP_AI)\n#define OS_INTERRUPTMASK_DSP_ARAM OS_INTERRUPTMASK(OS_INTR_DSP_ARAM)\n#define OS_INTERRUPTMASK_DSP_DSP OS_INTERRUPTMASK(OS_INTR_DSP_DSP)\n#define OS_INTERRUPTMASK_DSP                                                                       \\\n  (OS_INTERRUPTMASK_DSP_AI | OS_INTERRUPTMASK_DSP_ARAM | OS_INTERRUPTMASK_DSP_DSP)\n\n#define OS_INTERRUPTMASK_AI_AI OS_INTERRUPTMASK(OS_INTR_AI_AI)\n#define OS_INTERRUPTMASK_AI (OS_INTERRUPTMASK_AI_AI)\n\n#define OS_INTERRUPTMASK_EXI_0_EXI OS_INTERRUPTMASK(OS_INTR_EXI_0_EXI)\n#define OS_INTERRUPTMASK_EXI_0_TC OS_INTERRUPTMASK(OS_INTR_EXI_0_TC)\n#define OS_INTERRUPTMASK_EXI_0_EXT OS_INTERRUPTMASK(OS_INTR_EXI_0_EXT)\n#define OS_INTERRUPTMASK_EXI_0                                                                     \\\n  (OS_INTERRUPTMASK_EXI_0_EXI | OS_INTERRUPTMASK_EXI_0_TC | OS_INTERRUPTMASK_EXI_0_EXT)\n\n#define OS_INTERRUPTMASK_EXI_1_EXI OS_INTERRUPTMASK(OS_INTR_EXI_1_EXI)\n#define OS_INTERRUPTMASK_EXI_1_TC OS_INTERRUPTMASK(OS_INTR_EXI_1_TC)\n#define OS_INTERRUPTMASK_EXI_1_EXT OS_INTERRUPTMASK(OS_INTR_EXI_1_EXT)\n#define OS_INTERRUPTMASK_EXI_1                                                                     \\\n  (OS_INTERRUPTMASK_EXI_1_EXI | OS_INTERRUPTMASK_EXI_1_TC | OS_INTERRUPTMASK_EXI_1_EXT)\n\n#define OS_INTERRUPTMASK_EXI_2_EXI OS_INTERRUPTMASK(OS_INTR_EXI_2_EXI)\n#define OS_INTERRUPTMASK_EXI_2_TC OS_INTERRUPTMASK(OS_INTR_EXI_2_TC)\n#define OS_INTERRUPTMASK_EXI_2 (OS_INTERRUPTMASK_EXI_2_EXI | OS_INTERRUPTMASK_EXI_2_TC)\n#define OS_INTERRUPTMASK_EXI                                                                       \\\n  (OS_INTERRUPTMASK_EXI_0_EXI | OS_INTERRUPTMASK_EXI_0_TC | OS_INTERRUPTMASK_EXI_0_EXT |           \\\n   OS_INTERRUPTMASK_EXI_1_EXI | OS_INTERRUPTMASK_EXI_1_TC | OS_INTERRUPTMASK_EXI_1_EXT |           \\\n   OS_INTERRUPTMASK_EXI_2_EXI | OS_INTERRUPTMASK_EXI_2_TC)\n\n#define OS_INTERRUPTMASK_PI_PE_TOKEN OS_INTERRUPTMASK(OS_INTR_PI_PE_TOKEN)\n#define OS_INTERRUPTMASK_PI_PE_FINISH OS_INTERRUPTMASK(OS_INTR_PI_PE_FINISH)\n#define OS_INTERRUPTMASK_PI_PE (OS_INTERRUPTMASK_PI_PE_TOKEN | OS_INTERRUPTMASK_PI_PE_FINISH)\n\n#define OS_INTERRUPTMASK_PI_CP OS_INTERRUPTMASK(OS_INTR_PI_CP)\n#define OS_INTERRUPTMASK_PI_SI OS_INTERRUPTMASK(OS_INTR_PI_SI)\n#define OS_INTERRUPTMASK_PI_DI OS_INTERRUPTMASK(OS_INTR_PI_DI)\n#define OS_INTERRUPTMASK_PI_RSW OS_INTERRUPTMASK(OS_INTR_PI_RSW)\n#define OS_INTERRUPTMASK_PI_ERROR OS_INTERRUPTMASK(OS_INTR_PI_ERROR)\n#define OS_INTERRUPTMASK_PI_VI OS_INTERRUPTMASK(OS_INTR_PI_VI)\n#define OS_INTERRUPTMASK_PI_DEBUG OS_INTERRUPTMASK(OS_INTR_PI_DEBUG)\n#define OS_INTERRUPTMASK_PI_HSP OS_INTERRUPTMASK(OS_INTR_PI_HSP)\n#define OS_INTERRUPTMASK_PI                                                                        \\\n  (OS_INTERRUPTMASK_PI_CP | OS_INTERRUPTMASK_PI_SI | OS_INTERRUPTMASK_PI_DI |                      \\\n   OS_INTERRUPTMASK_PI_RSW | OS_INTERRUPTMASK_PI_ERROR | OS_INTERRUPTMASK_PI_VI |                  \\\n   OS_INTERRUPTMASK_PI_PE_TOKEN | OS_INTERRUPTMASK_PI_PE_FINISH | OS_INTERRUPTMASK_PI_DEBUG |      \\\n   OS_INTERRUPTMASK_PI_HSP)\n\ntypedef s16 OSInterrupt;\ntypedef u32 OSInterruptMask;\ntypedef void (*OSInterruptHandler)(OSInterrupt interrupt, OSContext* context);\n\nBOOL OSDisableInterrupts(void);\nvoid __RAS_OSDisableInterrupts_end(void);\nBOOL OSEnableInterrupts(void);\nBOOL OSRestoreInterrupts(BOOL enable);\nOSInterruptHandler __OSSetInterruptHandler(OSInterrupt interrupt, OSInterruptHandler handler);\nOSInterruptHandler __OSGetInterruptHandler(s16 index);\nvoid __OSInterruptInit(void);\nstatic OSInterruptMask SetInterruptMask(OSInterruptMask param_0, OSInterruptMask param_1);\nOSInterruptMask __OSMaskInterrupts(OSInterruptMask mask);\nOSInterruptMask __OSUnmaskInterrupts(OSInterruptMask mask);\nvoid __OSDispatchInterrupt(u8 interrupt, OSContext* context);\nstatic void ExternalInterruptHandler(OSInterrupt interrupt, OSContext* context);\n\nvoid __RAS_OSDisableInterrupts_begin(void);\nvoid __RAS_OSDisableInterrupts_end(void);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSINTERRUPT_H */\n/* end \"dolphin/os/OSInterrupt.h\" */\n/* \"include/dolphin/os/OS.h\" line 16 \"dolphin/os/OSLink.h\" */\n#ifndef OSLINK_H\n#define OSLINK_H\n\n/* \"include/dolphin/os/OSLink.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct OSModuleQueue {\n\tint* first;\n\tint* last;\n} OSModuleQueue;\n\nOSModuleQueue __OSModuleList : 0x800030C8;\nvoid* __OSStringTable : 0x800030D0;\n\ntypedef struct OSSectionInfo {\n    u32 mOffset;\n    u32 mSize;\n} OSSectionInfo;\n\ntypedef struct OSModuleInfo {\n    u32 mId;\n    u32 mNext;\n    u32 mPrev;\n    u32 mNumSections;\n    struct {  // Needed to get an assert correct; very likely bigger\n        u32 sectionInfoOffset;\n    } info;\n    u32 mModuleNameOffset;\n    u32 mModuleNameSize;\n    u32 mModuleVersion;\n    u32 mBssSize;\n    u32 mRelocationTableOffset;\n    u32 mImportTableOffset;\n    u32 mImportTableSize;\n    u8 mPrologSection;\n    u8 mEpilogSection;\n    u8 mUnresolvedSection;\n    u8 mBssSection;\n    u32 prolog;\n    u32 epilog;\n    u32 mUnresolvedFuncOffset;\n    u32 mModuleAlignment;\n    u32 mBssAlignment;\n    u32 fixSize;\n} OSModuleInfo;\n\nBOOL OSLink(OSModuleInfo* module);\nBOOL OSLinkFixed(OSModuleInfo* module, u32 param_1);\nBOOL OSUnlink(OSModuleInfo* module);\nstatic void OSNotifyLink(void);\nstatic void OSNotifyUnlink(void);\nvoid OSSetStringTable(void* string_table);\nstatic BOOL Relocate(OSModuleInfo* param_0, OSModuleInfo* param_1);\nstatic BOOL Link(OSModuleInfo* module, u32 param_1);\nstatic BOOL Undo(OSModuleInfo* param_0, OSModuleInfo* param_1);\nvoid __OSModuleInit(void);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSLINK_H */\n/* end \"dolphin/os/OSLink.h\" */\n/* \"include/dolphin/os/OS.h\" line 17 \"dolphin/os/OSMemory.h\" */\n#ifndef OSMEMORY_H\n#define OSMEMORY_H\n\n/* \"include/dolphin/os/OSMemory.h\" line 3 \"dolphin/os/OSInterrupt.h\" */\n/* end \"dolphin/os/OSInterrupt.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define OS_PROTECT_CHAN0 0\n#define OS_PROTECT_CHAN1 1\n#define OS_PROTECT_CHAN2 2\n#define OS_PROTECT_CHAN3 3\n\n#define OS_PROTECT_CONTROL_NONE 0x00\n#define OS_PROTECT_CONTROL_READ 0x01\n#define OS_PROTECT_CONTROL_WRITE 0x02\n#define OS_PROTECT_CONTROL_RDWR (OS_PROTECT_CONTROL_READ | OS_PROTECT_CONTROL_WRITE)\n\nstatic void MEMIntrruptHandler(OSInterrupt interrupt, struct OSContext* context);\nvoid OSProtectRange(u32 channel, void* address, u32 nBytes, u32 control);\nstatic void Config24MB(void);\nstatic void Config48MB(void);\nstatic void RealMode(u32 config);\nvoid __OSInitMemoryProtection(void);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSMEMORY_H */\n/* end \"dolphin/os/OSMemory.h\" */\n/* \"include/dolphin/os/OS.h\" line 18 \"dolphin/os/OSMessage.h\" */\n#ifndef OSMESSAGE_H\n#define OSMESSAGE_H\n\n/* \"include/dolphin/os/OSMessage.h\" line 3 \"dolphin/os/OSThread.h\" */\n/* end \"dolphin/os/OSThread.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef void* OSMessage;\n\ntypedef struct OSMessageQueue {\n    /* 0x00 */ OSThreadQueue sending_queue;\n    /* 0x08 */ OSThreadQueue receiving_queue;\n    /* 0x10 */ OSMessage* message_array;\n    /* 0x14 */ s32 num_messages;\n    /* 0x18 */ s32 first_index;\n    /* 0x1C */ s32 num_used;\n} OSMessageQueue;\n\n// Flags to turn blocking on/off when sending/receiving message\n#define OS_MESSAGE_NOBLOCK 0\n#define OS_MESSAGE_BLOCK 1\n\nvoid OSInitMessageQueue(OSMessageQueue* queue, OSMessage* msgArray, s32 msgCount);\nBOOL OSSendMessage(OSMessageQueue* queue, OSMessage msg, s32 flags);\nBOOL OSReceiveMessage(OSMessageQueue* queue, OSMessage* msg, s32 flags);\nBOOL OSJamMessage(OSMessageQueue* queue, OSMessage msg, s32 flags);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSMESSAGE_H */\n/* end \"dolphin/os/OSMessage.h\" */\n/* \"include/dolphin/os/OS.h\" line 19 \"dolphin/os/OSMutex.h\" */\n#ifndef OSMUTEX_H\n#define OSMUTEX_H\n\n/* \"include/dolphin/os/OSMutex.h\" line 3 \"dolphin/os/OSThread.h\" */\n/* end \"dolphin/os/OSThread.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct OSMutex {\n    /* 0x00 */ OSThreadQueue queue;\n    /* 0x08 */ OSThread* thread;\n    /* 0x0C */ s32 count;\n    /* 0x10 */ OSMutexLink link;\n} OSMutex;  // Size: 0x18\n\ntypedef struct OSCond {\n    OSThreadQueue queue;\n} OSCond;\n\nvoid OSInitMutex(OSMutex* mutex);\nvoid OSLockMutex(OSMutex* mutex);\nvoid OSUnlockMutex(OSMutex* mutex);\nBOOL OSTryLockMutex(OSMutex* mutex);\nvoid OSInitCond(OSCond* cond);\nvoid OSWaitCond(OSCond* cond, OSMutex* mutex);\nvoid OSSignalCond(OSCond* cond);\n\nvoid __OSUnlockAllMutex(OSThread* thread);\nBOOL __OSCheckMutex(OSMutex* thread);\nBOOL __OSCheckDeadLock(OSThread* thread);\nBOOL __OSCheckMutexes(OSThread* thread);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSMUTEX_H */\n/* end \"dolphin/os/OSMutex.h\" */\n/* \"include/dolphin/os/OS.h\" line 20 \"dolphin/os/OSReboot.h\" */\n#ifndef OSREBOOT_H\n#define OSREBOOT_H\n\n/* \"include/dolphin/os/OSReboot.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid __OSReboot(u32 param_0, u32 param_1);\nvoid OSSetSaveRegion(void* start, void* end);\nvoid OSGetSaveRegion(void** start, void** end);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSREBOOT_H */\n/* end \"dolphin/os/OSReboot.h\" */\n/* \"include/dolphin/os/OS.h\" line 21 \"dolphin/os/OSReset.h\" */\n#ifndef OSRESET_H\n#define OSRESET_H\n\n/* \"include/dolphin/os/OSReset.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvu32 __PIRegs[12] : 0xCC003000;\n\n#define OS_RESETCODE_RESTART 0x80000000\n#define OS_RESETCODE_SYSTEM 0x40000000\n\n#define OS_RESETCODE_EXEC 0xC0000000\n#define OS_RESETCODE_NETCONFIG 0xC0010000\n\n#define OS_RESET_TIMEOUT OSMillisecondsToTicks(1000)\n\n#define OS_RESET_RESTART 0\n#define OS_RESET_HOTRESET 1\n#define OS_RESET_SHUTDOWN 2\n\n#define OS_RESET_PRIO_SO 110\n#define OS_RESET_PRIO_IP 111\n#define OS_RESET_PRIO_CARD 127\n#define OS_RESET_PRIO_PAD 127\n#define OS_RESET_PRIO_GX 127\n#define OS_RESET_PRIO_ALARM 4294967295\n\ntypedef s32 (*OSResetFunction)(s32);\n\ntypedef struct OSResetFunctionInfo {\n    /* 0x0 */ OSResetFunction func;\n    /* 0x4 */ u32 priority;\n    /* 0x8 */ struct OSResetFunctionInfo* next;\n    /* 0xC */ struct OSResetFunctionInfo* prev;\n} OSResetFunctionInfo;\n\ntypedef struct OSResetQueue {\n    OSResetFunctionInfo* first;\n    OSResetFunctionInfo* last;\n} OSResetQueue;\n\nvoid OSRegisterResetFunction(OSResetFunctionInfo* info);\nBOOL __OSCallResetFunctions(u32 param_0);\nstatic void Reset(s32 param_0);\nstatic void KillThreads(void);\nvoid __OSDoHotReset(s32 param_0);\nvoid OSResetSystem(int reset, u32 resetCode, BOOL forceMenu);\nu32 OSGetResetCode(void);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSRESET_H */\n/* end \"dolphin/os/OSReset.h\" */\n/* \"include/dolphin/os/OS.h\" line 22 \"dolphin/os/OSResetSW.h\" */\n#ifndef OSRESETSW_H\n#define OSRESETSW_H\n\n/* \"include/dolphin/os/OSResetSW.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef void (*OSResetCallback)(void);\n\nstatic BOOL OSGetResetButtonState(void);\nBOOL OSGetResetSwitchState(void);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSRESETSW_H */\n/* end \"dolphin/os/OSResetSW.h\" */\n/* \"include/dolphin/os/OS.h\" line 23 \"dolphin/os/OSRtc.h\" */\n#ifndef OSRTC_H\n#define OSRTC_H\n\n/* \"include/dolphin/os/OSRtc.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef u32 OSSoundMode;\n\n#define OS_SOUND_MODE_MONO 0\n#define OS_SOUND_MODE_STEREO 1\n\n#define RTC_CMD_READ 0x20000000\n#define RTC_CMD_WRITE 0xa0000000\n\n#define RTC_SRAM_ADDR 0x00000100\n#define RTC_SRAM_SIZE 64\n\n#define RTC_CHAN 0\n#define RTC_DEV 1\n#define RTC_FREQ 3  // EXI_FREQ_8M\n\ntypedef struct SramControlBlock {\n    u8 sram[RTC_SRAM_SIZE];\n    u32 offset;\n    BOOL enabled;\n    BOOL locked;\n    BOOL sync;\n    void (*callback)(void);\n} SramControlBlock;\n\ntypedef struct OSSram {\n    u16 checkSum;\n    u16 checkSumInv;\n    u32 ead0;\n    u32 ead1;\n    u32 counterBias;\n    s8 displayOffsetH;\n    u8 ntd;\n    u8 language;\n    u8 flags;\n} OSSram;\n\ntypedef struct OSSramEx {\n    u8 flashID[2][12];\n    u32 wirelessKeyboardID;\n    u16 wirelessPadID[4];\n    u8 dvdErrorCode;\n    u8 _padding0;\n    u8 flashIDCheckSum[2];\n    u16 gbs;\n    u8 _padding1[2];\n} OSSramEx;\n\nvoid __OSInitSram(void);\nOSSram* __OSLockSram(void);\nOSSramEx* __OSLockSramEx(void);\nBOOL __OSUnlockSram(BOOL commit);\nBOOL __OSUnlockSramEx(BOOL commit);\nBOOL __OSSyncSram(void);\nu32 OSGetSoundMode(void);\nvoid OSSetSoundMode(OSSoundMode mode);\nu32 OSGetProgressiveMode(void);\nvoid OSSetProgressiveMode(u32 mode);\nu16 OSGetWirelessID(s32 channel);\nvoid OSSetWirelessID(s32 channel, u16 id);\nstatic u16 OSGetGbsMode(void);\nstatic void OSSetGbsMode(u16 mode);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSRTC_H */\n/* end \"dolphin/os/OSRtc.h\" */\n/* \"include/dolphin/os/OS.h\" line 24 \"dolphin/os/OSSync.h\" */\n#ifndef OSSYNC_H\n#define OSSYNC_H\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic void SystemCallVector(void);\nvoid __OSInitSystemCall(void);\n\nvoid __OSSystemCallVectorEnd(void);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* OSSYNC_H */\n/* end \"dolphin/os/OSSync.h\" */\n/* \"include/dolphin/os/OS.h\" line 25 \"dolphin/os/OSThread.h\" */\n/* end \"dolphin/os/OSThread.h\" */\n/* \"include/dolphin/os/OS.h\" line 26 \"dolphin/os/OSTime.h\" */\n/* end \"dolphin/os/OSTime.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Upper words of the masks, since UIMM is only 16 bits\n#define OS_CACHED_REGION_PREFIX 0x8000\n#define OS_UNCACHED_REGION_PREFIX 0xC000\n#define OS_PHYSICAL_MASK 0x3FFF\n\n#define OS_BASE_CACHED (OS_CACHED_REGION_PREFIX << 16)\n#define OS_BASE_UNCACHED (OS_UNCACHED_REGION_PREFIX << 16)\n\n#define OS_CONSOLE_MASK 0xf0000000\n#define OS_CONSOLE_RETAIL 0x00000000\n#define OS_CONSOLE_DEVELOPMENT 0x10000000\n#define OS_CONSOLE_TDEV 0x20000000\n\n#define OS_CONSOLE_RETAIL4 0x00000004\n#define OS_CONSOLE_RETAIL3 0x00000003\n#define OS_CONSOLE_RETAIL2 0x00000002\n#define OS_CONSOLE_RETAIL1 0x00000001\n#define OS_CONSOLE_TDEVHW4 0x20000007\n#define OS_CONSOLE_TDEVHW3 0x20000006\n#define OS_CONSOLE_TDEVHW2 0x20000005\n#define OS_CONSOLE_TDEVHW1 0x20000004\n#define OS_CONSOLE_DEVHW4 0x10000007\n#define OS_CONSOLE_DEVHW3 0x10000006\n#define OS_CONSOLE_DEVHW2 0x10000005\n#define OS_CONSOLE_DEVHW1 0x10000004\n#define OS_CONSOLE_MINNOW 0x10000003\n#define OS_CONSOLE_ARTHUR 0x10000002\n#define OS_CONSOLE_PC_EMULATOR 0x10000001\n#define OS_CONSOLE_EMULATOR 0x10000000\n\nvolatile u16 __OSDeviceCode : 0x800030E6;\n\nvolatile u32 OS_PI_INTR_CAUSE : 0xCC003000;\nvolatile u32 OS_PI_INTR_MASK : 0xCC003004;\n\nvolatile u16 OS_MI_INTR_MASK : 0xCC00401C;\n\nvolatile u16 OS_DSP_DMA_ADDR_HI : 0xCC005030;\nvolatile u16 OS_DSP_DMA_ADDR_LO : 0xCC005032;\nvolatile u16 OS_DSP_INTR_MASK : 0xCC00500A;\n\nvolatile u16 OS_ARAM_DMA_ADDR_HI : 0xCC005020;\nvolatile u16 OS_ARAM_DMA_ADDR_LO : 0xCC005022;\n\nBOOL OSIsThreadSuspended(OSThread* thread);\n\nu32 OSGetConsoleType(void);\n\nvoid OSAttention(const char* msg, ...);\nvoid OSPanic(const char* file, s32 line, const char* fmt, ...);\nvoid OSReport(const char* fmt, ...);\nvoid OSReport_Error(const char* fmt, ...);\nvoid OSReport_FatalError(const char* fmt, ...);\nvoid OSReport_System(const char* fmt, ...);\nvoid OSReport_Warning(const char* fmt, ...);\nvoid OSReportDisable(void);\nvoid OSReportEnable(void);\nvoid OSReportForceEnableOff(void);\nvoid OSReportForceEnableOn(void);\nvoid OSVReport(const char* format, va_list list);\nvoid OSVAttention(const char* fmt, va_list args);\nvoid OSReportInit(void);\n\nextern u8 __OSReport_disable;\nextern u8 __OSReport_Error_disable;\nextern u8 __OSReport_Warning_disable;\nextern u8 __OSReport_System_disable;\nextern u8 __OSReport_enable;\n\nextern BOOL __OSIsGcam;\n\nextern u32 BOOT_REGION_START : 0x812FDFF0;\nextern u32 BOOT_REGION_END : 0x812FDFEC;\n\nvoid OSReportInit__Fv(void);  // needed for inline asm\n\nu8* OSGetStackPointer(void);\nvoid __OSFPRInit(void);\nstatic void InquiryCallback(u32 param_0, DVDCommandBlock* param_1);\nvoid OSInit(void);\nstatic void OSExceptionInit(void);\nvoid __OSDBIntegrator(void);\nvoid __OSDBJump(void);\n\ntypedef void (*OSExceptionHandler)(__OSException, OSContext*);\nOSExceptionHandler __OSSetExceptionHandler(__OSException exception, OSExceptionHandler handler);\nOSExceptionHandler __OSGetExceptionHandler(__OSException exception);\nstatic void OSExceptionVector(void);\nvoid __DBVECTOR();\nvoid __OSEVSetNumber();\nvoid __OSEVEnd();\nstatic void OSDefaultExceptionHandler(__OSException exception, OSContext* context);\nvoid __OSPSInit(void);\nu32 __OSGetDIConfig(void);\nvoid OSRegisterVersion(const char* version);\nvoid OSSwitchFiberEx(u32, u32, u32, u32, u32, u32);\n\ninline s16 __OSf32tos16(register f32 inF) {\n    register s16 out;\n    u32 tmp;\n    register u32* tmpPtr = &tmp;\n    // clang-format off\n    asm {\n        psq_st inF, 0(tmpPtr), 0x1, 5\n        lha out, 0(tmpPtr)\n    }\n    // clang-format on\n\n    return out;\n}\n\ninline void OSf32tos16(f32* f, s16* out) {\n    *out = __OSf32tos16(*f);\n}\n\ninline u8 __OSf32tou8(register f32 inF) {\n    register u8 out;\n    u32 tmp;\n    register u32* tmpPtr = &tmp;\n    // clang-format off\n    asm {\n        psq_st inF, 0(tmpPtr), 0x1, 2\n        lbz out, 0(tmpPtr)\n    }\n    // clang-format on\n\n    return out;\n}\n\ninline void OSf32tou8(f32* f, u8* out) {\n    *out = __OSf32tou8(*f);\n}\n\ninline void i_OSInitFastCast(void) {\n    // clang-format off\n    asm {\n        li r3, 4\n        oris r3, r3, 4\n        mtspr 0x392, r3\n        li r3, 5\n        oris r3, r3, 5\n        mtspr 0x393, r3\n        li r3, 6\n        oris r3, r3, 6\n        mtspr 0x394, r3\n        li r3, 7\n        oris r3, r3, 7\n        mtspr 0x395, r3\n    }\n    // clang-format on\n}\n\ntypedef struct OSBootInfo {\n    /* 0x00 */ DVDDiskID disk_info;\n    /* 0x20 */ u32 boot_code;\n    /* 0x24 */ u32 version;\n    /* 0x28 */ u32 memory_size;\n    /* 0x2C */ u32 console_type;\n    /* 0x30 */ void* arena_lo;\n    /* 0x34 */ void* arena_hi;\n    /* 0x38 */ void* fst_location;\n    /* 0x3C */ u32 fst_max_length;\n} OSBootInfo;\n\ntypedef struct BI2Debug {\n    /* 0x00 */ s32 debugMonSize;\n    /* 0x04 */ s32 simMemSize;\n    /* 0x08 */ u32 argOffset;\n    /* 0x0C */ u32 debugFlag;\n    /* 0x10 */ int trackLocation;\n    /* 0x14 */ int trackSize;\n    /* 0x18 */ u32 countryCode;\n    /* 0x1C */ u8 unk[8];\n    /* 0x24 */ u32 padSpec;\n} BI2Debug;\n\nstruct GLOBAL_MEMORY {\n    DVDDiskID disk;\n    u32 nintendo_boot_code; /* Nintendo Standard Boot Code. */\n    u32 field_0x24;         /* \tVersion (set by apploader) */\n    u32 memory_size;        /* Memory Size (Physical) 24MB */\n    u32 field_0x2c;         /* Production Board Model */\n    u32 arena_low;          /* \tArena Low */\n    u32 arena_high;         /* \tArena High */\n    u32 field_0x38;         /* \tStart of FST (varies in all games) */\n    u32 field_0x3c;         /* Maximum FST Size (varies in all games) */\n    u8 padding_0x40[32];\n    u8 field_0x60[36]; /* Hook is PPC assembler used by Debugger.  */\n    u8 padding_0x84[84];\n    OSContext* field_0xd8; /* Current OSContext instance. */\n    OSThread* field_0xdc;  /* OSThread pointer, previously created thread. */\n    OSThread* field_0xe0;  /* OSThread pointer, most recently created thread. */\n    OSThread* field_0xe4;  /* Current thread pointer. */\n    u32 field_0xe8;        /* Dev Debugger Monitor Address (If present) */\n    u32 field_0xec;        /* Simulated Memory Size */\n    u32 field_0xf0;        /* Pointer to data read from partition's bi2.bin, set by apploader */\n    u32 field_0xf4;        /* Console Bus Speed */\n    u32 field_0xf8;        /* Console CPU Speed */\n    u8 padding_0xfc[5892];\n    u8 field_0x1800[6144]; /* Unused Exception Vector */\n    u8 padding_0x3000[64];\n    u32 field_0x3040[34]; /* \t__OSInterrupt table. */\n    u32 field_0x30c8;     /* Pointer to the first loaded REL file. */\n    u32 field_0x30cc;     /* Pointer to the last loaded REL file. */\n    u32 field_0x30d0;     /* Pointer to a REL module name table, or 0. */\n    u8 padding_0x30d8[4];\n    u64 field_0x30d8; /* System time */\n    u8 padding_0x30e0[4];\n    u32 field_0x30e4; /* __OSPADButton */\n    u8 padding_0x30ec[8];\n    OSExecParams* field_0x30f0; /* DOL Execute Parameters */\n    u8 padding_0x30f4[12];\n    u32 field_0x3100; /* Physical MEM1 size */\n    u32 field_0x3104; /* Simulated MEM1 size */\n    u8 padding_0x3108[8];\n    u32 field_0x3110; /* Heap pointer (end of usable memory by the game) */\n    u8 padding_0x3114[4];\n    u32 field_0x3118; /* \tPhysical MEM2 size */\n    u32 field_0x311c; /* Simulated MEM2 size */\n    u8 padding_0x3120[16];\n    u32 field_0x3130; /* IOS Heap Range (start) */\n    u32 field_0x3134; /* IOS Heap Range (end) */\n    u32 field_0x3138; /* Hollywood Version */\n    u8 padding_0x313c[4];\n    u32 field_0x3140; /* \tIOS version */\n    u32 field_0x3144; /* \tIOS Build Date */\n    u8 padding_0x3148[16];\n    u32 field_0x3158; /* \tGDDR Vendor Code */\n    u32 field_0x315c; /* During the boot process, */\n    u32 field_0x3160; /* Init semaphore (1-2 main() waits for this to clear) */\n    u32 field_0x3164; /* GC (MIOS) mode flag? */\n    u8 padding_0x3168[24];\n    u32 field_0x3180; /* \tGame ID */\n    u8 field_0x3184;  /* Application type. 0x80 for disc games, 0x81 for channels. */\n    u8 padding_0x3185;\n    u8 field_0x3186; /* Application type 2 */\n    u8 padding_0x3187;\n    u32 field_0x3188; /* Minimum IOS version */\n    u32 field_0x318c; /* \tTitle Booted from NAND (Launch Code) */\n    u32 field_0x3190; /* \tTitle Booted from NAND (Return Code) */\n    u32 field_0x3194; /* While reading a disc, the system menu reads the first partition table (0x20\n                         bytes from 0x00040020) and stores a pointer to the data partition entry.\n                         When launching the disc game, it copies the partition type to 0x3194. The\n                         partition type for data partitions is 0, so typically this location always\n                         has 0. */\n    u32 field_0x3198; /* While reading a disc, the system menu reads the first partition table (0x20\n                         bytes from 0x00040020) and stores a pointer to the data partition entry.\n                         When launching the disc game, it copies the partition offset to 0x3198. */\n    u32 field_0x319c; /* Set by the apploader to 0x80 for single-layer discs and 0x81 for dual-layer\n                         discs (determined by whether 0x7ed40000 is the value at offset 0x30 in the\n                         partition's bi2.bin; it seems that that value is 0 for single-layer discs).\n                         Early titles' apploaders do not set it at all, leaving the value as 0. This\n                         controls the /dev/di#0x8D_DVDLowUnencryptedRead out-of-bounds Error #001\n                         read for titles that do make such a read: they try to read at 0x7ed40000\n                         for dual-layer discs and 0x460a0000 for single-layer discs. */\n    u8 field_0x31a0[3424];\n};\n\n#define OS_ASSERT(...)\n\n#define OSPhysicalToCached(paddr) ((void*)((u32)(paddr) + OS_BASE_CACHED))\n#define OSPhysicalToUncached(paddr) ((void*)((u32)(paddr) + OS_BASE_UNCACHED))\n#define OSCachedToPhysical(caddr) ((u32)((u8*)(caddr)-OS_BASE_CACHED))\n#define OSUncachedToPhysical(ucaddr) ((u32)((u8*)(ucaddr)-OS_BASE_UNCACHED))\n#define OSCachedToUncached(caddr) ((void*)((u8*)(caddr) + (OS_BASE_UNCACHED - OS_BASE_CACHED)))\n#define OSUncachedToCached(ucaddr) ((void*)((u8*)(ucaddr) - (OS_BASE_UNCACHED - OS_BASE_CACHED)))\n\nextern OSTime __OSStartTime;\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif\n/* end \"dolphin/os/OS.h\" */\n\n#ifdef DEBUG\n#define JUT_ASSERT(LINE, COND)                                                                     \\\n    if ((COND) == 0) {                                                                             \\\n        JUTAssertion::showAssert(JUTAssertion::getSDevice(), __FILE__, LINE, #COND);               \\\n        OSPanic(__FILE__, LINE, \"Halt\");                                                           \\\n    }\n\n#define JUT_PANIC(LINE, TEXT)                                                                      \\\n    JUTAssertion::showAssert(JUTAssertion::getSDevice(), __FILE__, LINE, TEXT);                    \\\n    OSPanic(__FILE__, LINE, \"Halt\");\n\n#define JUT_WARN(LINE, ...)                                                                        \\\n    JUTAssertion::setWarningMessage_f(JUTAssertion::getSDevice(), __FILE__, LINE, __VA_ARGS__);    \\\n\n#define JUT_LOG(LINE, ...)                                                                         \\\n    JUTAssertion::setLogMessage_f(JUTAssertion::getSDevice(), __FILE__, LINE, __VA_ARGS__)\n\n#else\n#define JUT_ASSERT(...)\n#define JUT_PANIC(...)\n#define JUT_WARN(...)\n#define JUT_LOG(...)\n#endif\n\nnamespace JUTAssertion {\n    /* 802E495C */ void create();\n    /* 802E4960 */ u32 flush_subroutine();\n    /* 802E499C */ void flushMessage();\n    /* 802E4A54 */ void flushMessage_dbPrint();\n    /* 802E4C34 */ void setVisible(bool);\n    /* 802E4C3C */ void setMessageCount(int);\n\n    u32 getSDevice();\n    void showAssert(u32 device, const char * file, int line, const char * assertion);\n    void setWarningMessage_f(u32 device, char * file, int line, const char * fmt, ...);\n    void setLogMessage_f(u32 device, char* file, int line, const char* fmt, ...);\n};\n\nextern bool sAssertVisible;\n\n#endif /* JUTASSERT_H */\n/* end \"JSystem/JUtility/JUTAssert.h\" */\n\nclass JAISound;\nclass JAISoundID;\n\nclass JAISoundHandle {\npublic:\n    JAISoundHandle() {sound_ = NULL;};\n    ~JAISoundHandle() { releaseSound(); }\n\n    bool isSoundAttached() const { return sound_ != NULL; }\n\n    JAISound* operator->() const {\n        JUT_ASSERT(58, sound_ != 0);\n        return sound_;\n    }\n\n    operator bool() const { return isSoundAttached(); }\n\n    void releaseSound();\n\n    JAISound* getSound() { return sound_; }\n\n    JAISound* sound_;  // member from assert in operator->()\n};\n\nclass JAISoundHandles {\npublic:\n    JAISoundHandles(JAISoundHandle* pHandle, int param_1) {\n        mSoundHandle = pHandle;\n        numHandles_ = param_1;\n    };\n\n    JAISoundHandle* getHandleSoundID(JAISoundID);\n    JAISoundHandle* getFreeHandle();\n\nprivate:\n    JAISoundHandle* mSoundHandle;\n    int numHandles_;\n};\n\n#endif /* JAISOUNDHANDLES_H */\n/* end \"JSystem/JAudio2/JAISoundHandles.h\" */\n/* \"include/Z2AudioLib/Z2SoundHandles.h\" line 4 \"JSystem/JSupport/JSUList.h\" */\n#ifndef JSULIST_H\n#define JSULIST_H\n\n/* \"include/JSystem/JSupport/JSUList.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntemplate <typename T>\nclass JSUList;\n\n//\n// Link\n//\n\nclass JSUPtrList;\nclass JSUPtrLink {\npublic:\n    JSUPtrLink(void* object);\n    ~JSUPtrLink();\n\n    void* getObjectPtr() const { return mObject; }\n\n    JSUPtrList* getList() const { return mList; }\n\n    JSUPtrLink* getNext() const { return mNext; }\n\n    JSUPtrLink* getPrev() const { return mPrev; }\n\npublic:\n    void* mObject;\n    JSUPtrList* mList;\n    JSUPtrLink* mPrev;\n    JSUPtrLink* mNext;\n};\n\ntemplate <typename T>\nclass JSULink : public JSUPtrLink {\npublic:\n    JSULink(T* object) : JSUPtrLink((void*)object) {}\n\n    T* getObject() const { return (T*)getObjectPtr(); }\n\n    JSUList<T>* getSupervisor() const { return (JSUList<T>*)this->getList(); }\n\n    JSULink<T>* getNext() const { return (JSULink<T>*)this->JSUPtrLink::getNext(); }\n\n    JSULink<T>* getPrev() const { return (JSULink<T>*)this->JSUPtrLink::getPrev(); }\n};\n\n//\n// List\n//\n\nclass JSUPtrList {\npublic:\n    JSUPtrList() { this->initiate(); }\n    JSUPtrList(bool init);\n    ~JSUPtrList();\n\n    void initiate();\n    void setFirst(JSUPtrLink* first);\n    bool append(JSUPtrLink* ptr);\n    bool prepend(JSUPtrLink* ptr);\n    bool insert(JSUPtrLink* before, JSUPtrLink* ptr);\n    bool remove(JSUPtrLink* ptr);\n    JSUPtrLink* getNthLink(u32 i) const;\n\n    JSUPtrLink* getFirstLink() const { return mHead; }\n\n    JSUPtrLink* getLastLink() const { return mTail; }\n\n    u32 getNumLinks() const { return mLength; }\n\nprivate:\n    JSUPtrLink* mHead;\n    JSUPtrLink* mTail;\n    u32 mLength;\n};\n\ntemplate <typename T>\nclass JSUList : public JSUPtrList {\npublic:\n    JSUList() : JSUPtrList() {}\n    JSUList(bool init) : JSUPtrList(init) {}\n\n    ~JSUList() {}\n\n    bool append(JSULink<T>* link) { return this->JSUPtrList::append((JSUPtrLink*)link); }\n\n    bool prepend(JSULink<T>* link) { return this->JSUPtrList::prepend((JSUPtrLink*)link); }\n\n    bool insert(JSULink<T>* before, JSULink<T>* link) {\n        return this->JSUPtrList::insert((JSUPtrLink*)before, (JSUPtrLink*)link);\n    }\n\n    bool remove(JSULink<T>* link) { return this->JSUPtrList::remove((JSUPtrLink*)link); }\n\n    JSULink<T>* getFirst() const { return (JSULink<T>*)getFirstLink(); }\n\n    JSULink<T>* getLast() const { return (JSULink<T>*)getLastLink(); }\n\n    JSULink<T>* getNth(int index) { return (JSULink<T>*)getNthLink(index); }\n\n    JSULink<T>* getEnd() const { return NULL; }\n\n    u32 getNumLinks() const { return this->JSUPtrList::getNumLinks(); }\n};\n\ntemplate <typename T>\nclass JSUListIterator {\npublic:\n    JSUListIterator() : mLink(NULL) {}\n    JSUListIterator(JSULink<T>* link) : mLink(link) {}\n    JSUListIterator(JSUList<T>* list) : mLink(list->getFirst()) {}\n\n    JSUListIterator<T>& operator=(JSULink<T>* link) {\n        this->mLink = link;\n        return *this;\n    }\n\n    T* getObject() { return this->mLink->getObject(); }\n\n    bool operator==(JSULink<T> const* other) const { return this->mLink == other; }\n    bool operator!=(JSULink<T> const* other) const { return this->mLink != other; }\n    bool operator==(JSUListIterator<T> const& other) const { return this->mLink == other.mLink; }\n    bool operator!=(JSUListIterator<T> const& other) const { return this->mLink != other.mLink; }\n\n    JSUListIterator<T> operator++(int) {\n        JSUListIterator<T> prev = *this;\n        this->mLink = this->mLink->getNext();\n        return prev;\n    }\n\n    JSUListIterator<T>& operator++() {\n        this->mLink = this->mLink->getNext();\n        return *this;\n    }\n\n    JSUListIterator<T> operator--(int) {\n        JSUListIterator<T> prev = *this;\n        this->mLink = this->mLink->getPrev();\n        return prev;\n    }\n\n    JSUListIterator<T>& operator--() {\n        this->mLink = this->mLink->getPrev();\n        return *this;\n    }\n\n    T& operator*() { return *this->getObject(); }\n\n    T* operator->() { return this->getObject(); }\n\n// private:\n    JSULink<T>* mLink;\n};\n\n//\n// Tree\n//\n\ntemplate <typename T>\nclass JSUTree : public JSUList<T>, public JSULink<T> {\npublic:\n    JSUTree(T* owner) : JSUList<T>(), JSULink<T>(owner) {}\n    ~JSUTree() {}\n\n    bool appendChild(JSUTree<T>* child) { return this->append(child); }\n\n    bool removeChild(JSUTree<T>* child) { return this->remove(child); }\n\n    bool insertChild(JSUTree<T>* before, JSUTree<T>* child) { return this->insert(before, child); }\n\n    JSUTree<T>* getEndChild() const { return NULL; }\n\n    JSUTree<T>* getFirstChild() const { return (JSUTree<T>*)this->getFirst(); }\n\n    JSUTree<T>* getLastChild() const { return (JSUTree<T>*)this->getLast(); }\n\n    JSUTree<T>* getNextChild() const { return (JSUTree<T>*)this->getNext(); }\n\n    JSUTree<T>* getPrevChild() const { return (JSUTree<T>*)this->getPrev(); }\n\n    u32 getNumChildren() const { return this->getNumLinks(); }\n\n    T* getObject() const { return (T*)this->getObjectPtr(); }\n\n    JSUTree<T>* getParent() const { return (JSUTree<T>*)this->getList(); }\n};\n\ntemplate <typename T>\nclass JSUTreeIterator {\npublic:\n    JSUTreeIterator() : mTree(NULL) {}\n    JSUTreeIterator(JSUTree<T>* tree) : mTree(tree) {}\n\n    JSUTreeIterator<T>& operator=(JSUTree<T>* tree) {\n        this->mTree = tree;\n        return *this;\n    }\n\n    T* getObject() { return this->mTree->getObject(); }\n\n    bool operator==(JSUTree<T>* other) { return this->mTree == other; }\n\n    bool operator!=(JSUTree<T>* other) { return this->mTree != other; }\n\n    JSUTreeIterator<T> operator++(int) {\n        JSUTreeIterator<T> prev = *this;\n        this->mTree = this->mTree->getNextChild();\n        return prev;\n    }\n\n    JSUTreeIterator<T>& operator++() {\n        this->mTree = this->mTree->getNextChild();\n        return *this;\n    }\n\n    T* operator*() { return this->getObject(); }\n\n    T* operator->() { return this->getObject(); }\n\nprivate:\n    JSUTree<T>* mTree;\n};\n\n#endif /* JSULIST_H */\n/* end \"JSystem/JSupport/JSUList.h\" */\n/* \"include/Z2AudioLib/Z2SoundHandles.h\" line 5 \"JSystem/JAudio2/JASHeapCtrl.h\" */\n#ifndef JASHEAPCTRL_H\n#define JASHEAPCTRL_H\n\n/* \"include/JSystem/JAudio2/JASHeapCtrl.h\" line 3 \"JSystem/JSupport/JSUList.h\" */\n/* end \"JSystem/JSupport/JSUList.h\" */\n/* \"include/JSystem/JAudio2/JASHeapCtrl.h\" line 4 \"dolphin/os/OSInterrupt.h\" */\n/* end \"dolphin/os/OSInterrupt.h\" */\n/* \"include/JSystem/JAudio2/JASHeapCtrl.h\" line 5 \"dolphin/os/OSMutex.h\" */\n/* end \"dolphin/os/OSMutex.h\" */\n\nclass JASDisposer;\nclass JKRHeap;\nclass JKRSolidHeap;\n\nclass JASHeap {\npublic:\n    /* 80290140 */ JASHeap(JASDisposer* param_0 = NULL);\n    /* 802901AC */ void initRootHeap(void*, u32);\n    /* 8029021C */ bool alloc(JASHeap*, u32);\n    /* 802903F4 */ bool allocTail(JASHeap*, u32);\n    /* 802904E4 */ bool free();\n    /* 80290608 */ void insertChild(JASHeap*, JASHeap*, void*, u32, bool);\n    /* 802906F0 */ JASHeap* getTailHeap();\n    /* 8029077C */ u32 getTailOffset();\n    /* 802907E0 */ u32 getCurOffset();\n    /* 80290B54 */ ~JASHeap();\n\n    void* getBase() { return mBase; }\n    bool isAllocated() { return mBase; }\n\n    /* 0x00 */ JSUTree<JASHeap> mTree;\n    /* 0x1C */ OSMutex mMutex;\n    /* 0x34 */ JASDisposer* mDisposer;\n    /* 0x38 */ u8* mBase;\n    /* 0x3c */ u32 mSize;\n    /* 0x40 */ JASHeap* field_0x40;\n};\n\nnamespace JASKernel {\n    /* 802909B8 */ void setupRootHeap(JKRSolidHeap*, u32);\n    /* 80290AC0 */ JKRHeap* getSystemHeap();\n    /* 80290AC8 */ void* getCommandHeap();\n    /* 80290AD0 */ void setupAramHeap(u32, u32);\n    /* 80290B08 */ JASHeap* getAramHeap();\n\n    extern u8 audioAramHeap[68];\n    extern u32 sAramBase;\n    extern JKRHeap* sSystemHeap;\n    extern void* sCommandHeap;\n};\n\nstruct JASGenericMemPool {\n    /* 80290848 */ JASGenericMemPool();\n    /* 80290860 */ ~JASGenericMemPool();\n    /* 802908C8 */ void newMemPool(u32, int);\n    /* 80290948 */ void* alloc(u32);\n    /* 80290994 */ void free(void*, u32);\n\n    /* 0x00 */ void* field_0x0;\n    /* 0x04 */ int freeMemCount;\n    /* 0x08 */ int totalMemCount;\n    /* 0x0C */ int field_0xc;\n\n};\n\nnamespace JASThreadingModel {\n    template <typename A0>\n    struct InterruptsDisable {\n        struct Lock {\n            Lock(const A0& param_0) { field_0x0 = OSDisableInterrupts(); }\n            ~Lock() { OSRestoreInterrupts(field_0x0); }\n\n            BOOL field_0x0;\n        };\n    };\n\n    \n    struct ObjectLevelLockable {\n        // Should be templated on the chunk memory but couldn't initialize it inside the class itself\n        //template <typename A0>\n        struct Lock {\n            Lock(OSMutex* mutex) {\n                mMutex = mutex;\n                OSLockMutex(mMutex);\n            }\n\n            ~Lock() {\n                OSUnlockMutex(mMutex);\n            }\n\n            OSMutex* mMutex;\n        };\n    };\n};\n\ntemplate <typename T>\nclass JASMemPool : public JASGenericMemPool {\npublic:\n    void newMemPool(int param_0) { JASGenericMemPool::newMemPool(sizeof(T), param_0); }\n    void* alloc(u32 n) { return JASGenericMemPool::alloc(n); }\n    void free(void* ptr, u32 n) { JASGenericMemPool::free(ptr, n); }\n};\n\ntemplate<u32 ChunkSize, typename T>\nclass JASMemChunkPool {\n    struct MemoryChunk {\n        MemoryChunk(MemoryChunk* nextChunk) {\n            mNextChunk = nextChunk;\n            mUsedSize = 0;\n            mChunks = 0;\n        }\n\n        bool checkArea(void* ptr) {\n            return (u8*)this + 0xc <= (u8*)ptr && (u8*)ptr < (u8*)this + (ChunkSize + 0xc);\n        }\n\n        MemoryChunk* getNextChunk() {\n            return mNextChunk;\n        }\n\n        void* alloc(u32 size) {\n            u8* rv = mBuffer + mUsedSize;\n            mUsedSize += size;\n            mChunks++;\n            return rv;\n        }\n\n        void free() {\n            mChunks--;\n        }\n\n        bool isEmpty() {\n            return mChunks == 0;\n        }\n\n        void setNextChunk(MemoryChunk* chunk) {\n            mNextChunk = chunk;\n        }\n\n        u32 getFreeSize() {\n            return ChunkSize - mUsedSize;\n        }\n\n        void revive() {\n            mUsedSize = 0;\n        }\n\n        MemoryChunk* mNextChunk;\n        u32 mUsedSize;\n        u32 mChunks;\n        u8 mBuffer[ChunkSize];\n    };\npublic:\n    bool createNewChunk() {\n        bool uVar2;\n        if (field_0x18 != NULL && field_0x18->isEmpty()) {\n            field_0x18->revive();\n            uVar2 = 1;\n        } else {\n            MemoryChunk* pMVar4 = field_0x18;\n            field_0x18 = new (JASKernel::getSystemHeap(), 0) MemoryChunk(pMVar4);\n            if (field_0x18 != NULL) {\n                uVar2 = 1;\n            } else {\n                field_0x18 = new (JKRHeap::getSystemHeap(), 0) MemoryChunk(pMVar4);\n                if (field_0x18 != NULL) {\n                    uVar2 = 1;\n                } else {\n                    field_0x18 = pMVar4;\n                    uVar2 = 0;\n                }\n            }\n        }\n        return uVar2;\n    }\n\n    void* alloc(u32 size) {\n        T::Lock lock(&mMutex);\n        if (field_0x18->getFreeSize() < size) {\n            if (ChunkSize < size) {\n                return NULL;\n            }\n            if (createNewChunk() == 0) {\n                return NULL;\n            }\n        }\n        return field_0x18->alloc(size);\n    }\n\n    void free(void* ptr) {\n        T::Lock lock(&((JASMemChunkPool<ChunkSize,T>*)ptr)->mMutex);\n        MemoryChunk* chunk = ((JASMemChunkPool<ChunkSize,T>*)ptr)->field_0x18;\n        MemoryChunk* prevChunk = NULL;\n        while (chunk != NULL) {\n            if (chunk->checkArea(this)) {\n                chunk->free();\n                if (chunk != ((JASMemChunkPool<ChunkSize,T>*)ptr)->field_0x18 && chunk->isEmpty()) {\n                    MemoryChunk* nextChunk = chunk->getNextChunk();\n                    delete chunk;\n                    prevChunk->setNextChunk(nextChunk);\n                }\n                return;\n            }\n            prevChunk = chunk;\n            chunk = chunk->getNextChunk();\n        }\n    }\n\n    /* 0x00 */ OSMutex mMutex;\n    /* 0x18 */ MemoryChunk* field_0x18;\n};\n\ntemplate <typename T>\nclass JASPoolAllocObject {\npublic:\n    static void* operator new(size_t n) {\n        JASMemPool<T>* memPool = getMemPool();\n        return memPool->alloc(sizeof(T));\n    }\n    static void operator delete(void* ptr, size_t n) {\n        JASMemPool<T>* memPool_ = getMemPool();\n        memPool_->free(ptr, sizeof(T));\n    }\n    static void newMemPool(int param_0) {\n        JASMemPool<T>* memPool_ = getMemPool();\n        memPool_->newMemPool(param_0);\n    }\n\nprivate:\n    static JASMemPool<T>* getMemPool() {\n        static JASMemPool<T> memPool_;\n        return &memPool_;\n    }\n};\n\ntemplate <typename T>\nclass JASMemPool_MultiThreaded : public JASGenericMemPool {\npublic:\n    void newMemPool(int param_0) {\n        JASThreadingModel::InterruptsDisable<JASMemPool_MultiThreaded<T> >::Lock lock(*this);\n        JASGenericMemPool::newMemPool(sizeof(T), param_0);\n    }\n\n    void* alloc(size_t count) {\n        JASThreadingModel::InterruptsDisable<JASMemPool_MultiThreaded<T> >::Lock lock(*this);\n        return JASGenericMemPool::alloc(count);\n    }\n\n    void free(void* ptr, u32 param_1) {\n        JASThreadingModel::InterruptsDisable<JASMemPool_MultiThreaded<T> >::Lock lock(*this);\n        JASGenericMemPool::free(ptr, param_1);\n    }\n};\n\ntemplate <typename T>\nclass JASPoolAllocObject_MultiThreaded {\npublic:\n    static void* operator new(size_t n) {\n        JASMemPool_MultiThreaded<T>* memPool_ = getMemPool();\n        return memPool_->alloc(sizeof(T));\n    }\n    static void operator delete(void* ptr, size_t n) {\n        JASMemPool_MultiThreaded<T>* memPool_ = getMemPool();\n        memPool_->free(ptr, sizeof(T));\n    }\n\n    static void newMemPool(int n) {\n        getMemPool()->newMemPool(n);\n    }\n\nprivate:\n    static JASMemPool_MultiThreaded<T>* getMemPool() {\n        static JASMemPool_MultiThreaded<T> memPool_;\n        return &memPool_;\n    }\n};\n\nextern JKRSolidHeap* JASDram;\n\n#endif /* JASHEAPCTRL_H */\n/* end \"JSystem/JAudio2/JASHeapCtrl.h\" */\n/* \"include/Z2AudioLib/Z2SoundHandles.h\" line 6 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass Z2SoundHandlePool : public JAISoundHandle, public JSULink<Z2SoundHandlePool> { // , public JASPoolAllocObject<Z2SoundHandlePool> {\npublic:\n    Z2SoundHandlePool() : JAISoundHandle(), JSULink<Z2SoundHandlePool>(this) {}\n    ~Z2SoundHandlePool() {}\n};\n\nclass Z2SoundHandles : protected JSUList<Z2SoundHandlePool> {\npublic:\n    Z2SoundHandles();\n    ~Z2SoundHandles();\n\n    void initHandlesPool(u8 pNumHandles);\n    void deleteHandlesPool();\n    JAISoundHandle* getFreeHandle();\n    JAISoundHandle* getLowPrioSound(JAISoundID pSoundId);\n\n    bool isActive() const;\n\n    JAISoundHandle* getHandleSoundID(JAISoundID pSoundId);\n    JAISoundHandle* getHandleUserData(u32 pUserData);\n\n    void stopAllSounds(u32 fadeout);\n\n    void setPos(const JGeometry::TVec3<f32>& pos);\n\n    int getNumHandles() const { return getNumLinks(); }\n    JAISoundHandle* getHandle(int index) { return (Z2SoundHandlePool*)getNth(index); }\n\nprivate:\n    /* 0xC */ u8 mNumHandles;\n};\n\n#endif /* Z2SOUNDHANDLES_H */\n/* end \"Z2AudioLib/Z2SoundHandles.h\" */\n/* \"include/Z2AudioLib/Z2SoundObject.h\" line 4 \"JSystem/JAudio2/JAUSoundAnimator.h\" */\n#ifndef JAUSOUNDANIMATOR_H\n#define JAUSOUNDANIMATOR_H\n\n/* \"include/JSystem/JAudio2/JAUSoundAnimator.h\" line 3 \"JSystem/JAudio2/JAISound.h\" */\n/* end \"JSystem/JAudio2/JAISound.h\" */\n/* \"include/JSystem/JAudio2/JAUSoundAnimator.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass JAUSoundAnimation;\n\nclass JAUSoundAnimationSound {\npublic:\n    bool playsOnlyForward() const { return (mFlags & 1) != 0; }\n    bool playsOnlyReverse() const { return (mFlags & 2) != 0; }\n    bool stopsWhenAnimationChanges() const { return (mFlags & 4) != 0; }\n    bool playsOnlyOnce() const { return (mFlags & 8) != 0; }\n    bool stopsWhenNoteOff() const { return (mFlags & 0x10) != 0; }\n    bool stopsWhenSpeedIsZero() const { return (mFlags & 0x20) != 0; }\n    bool setsLifeTime() const { return (mFlags & 0x40) != 0; }\n    bool playsAtIntervals() const { return (mFlags & 0x80) != 0; }\n\n    bool isNoting(f32 param_0) const {\n        if (field_0x04 == field_0x08) {\n            return true;\n        }\n        if (field_0x04 > field_0x08) {\n            if (field_0x08 <= param_0 && param_0 < field_0x04) {\n                return true;\n            }\n        } else {\n            if (field_0x04 <= param_0 && param_0 < field_0x08) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    bool isNotingOn(f32 param_0, bool param_1) const {\n        if (setsLifeTime()) {\n            return isNoting(param_0);\n        }\n        if (param_1) {\n            return param_0 <= field_0x04;\n        } else {\n            return param_0 >= field_0x04;\n        }\n    }\n\n    bool isNotingOff(f32 param_0, bool param_1) const {\n        if (setsLifeTime()) {\n            return !isNoting(param_0);\n        }\n        if (field_0x04 == field_0x08) {\n            return false;\n        }\n        if (param_1) {\n            return param_0 <= field_0x08;\n        } else {\n            return param_0 >= field_0x08;\n        }\n    }\n\n    /* 0x00 */ JAISoundID mSoundId;\n    /* 0x04 */ f32 field_0x04;\n    /* 0x08 */ f32 field_0x08;\n    /* 0x0C */ f32 field_0x0c;\n    /* 0x10 */ u32 mFlags;\n    /* 0x14 */ u8 field_0x14;\n    /* 0x15 */ u8 field_0x15;\n    /* 0x16 */ u8 field_0x16;\n    /* 0x17 */ u8 field_0x17;\n    /* 0x18 */ u8 field_0x18;\n    /* 0x19 */ u8 field_0x19;\n    /* 0x1A */ s8 field_0x1a;\n    /* 0x1B */ u8 unk_0x1b[5];\n}; /* size 0x20 */\n\nclass JAUSoundAnimationControl {\npublic:\n    virtual ~JAUSoundAnimationControl() = 0;\n    virtual JAUSoundAnimationSound* getSound(const JAUSoundAnimation*, int) = 0;\n    virtual u16 getNumSounds(const JAUSoundAnimation*) = 0;\n};\n\nclass JAUSoundAnimation {\npublic:\n    /* 802A6F70 */ int getStartSoundIndex(f32) const;\n    /* 802A7044 */ int getEndSoundIndex(f32) const;\n\n    u16 getNumSounds() const {\n        if (mControl != NULL) {\n            return mControl->getNumSounds(this);\n        } else {\n            return mNumSounds;\n        }\n    }\n\n    const JAUSoundAnimationSound* getSound(int i_index) const {\n        if (mControl != NULL) {\n            return mControl->getSound(this, i_index);\n        } else {\n            return &mSounds + i_index;\n        }\n    }\n\n    /* 0x0 */ u16 mNumSounds;\n    /* 0x4 */ JAUSoundAnimationControl* mControl;\n    /* 0x8 */ JAUSoundAnimationSound mSounds;  // actually an array\n};\n\n#endif /* JAUSOUNDANIMATOR_H */\n/* end \"JSystem/JAudio2/JAUSoundAnimator.h\" */\n/* \"include/Z2AudioLib/Z2SoundObject.h\" line 5 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass Z2SoundStarter;\n\nclass Z2SoundObjBase : protected Z2SoundHandles {\npublic:\n    Z2SoundObjBase();\n    ~Z2SoundObjBase();\n\n    void deleteObject();\n    JAISoundHandle* startCollisionSE(u32, u32, Z2SoundObjBase*);\n\n    bool isAlive() const { return mIsInitialized; }\n    void setSoundStarter(Z2SoundStarter* i_soundStarter) { mSoundStarter = i_soundStarter; }\n\n    virtual void framework(u32, s8);\n    virtual void dispose();\n    virtual bool stopOK(Z2SoundHandlePool& pool);\n    virtual void init(Vec* pSoundPos, u8 pNumHandles);\n    virtual JAISoundHandle* startSound(JAISoundID, u32, s8);\n    virtual JAISoundHandle* startLevelSound(JAISoundID, u32, s8);\n\n    /* 0x14 */ Z2SoundStarter* mSoundStarter;\n    /* 0x18 */ JGeometry::TVec3<f32>* mSoundPos;\n    /* 0x1C */ u16 field_0x1c;\n    /* 0x1E */ s8 field_0x1e;\n    /* 0x1F */ bool mIsInitialized;\n};\n\nclass Z2SoundObjSimple : public Z2SoundObjBase {\npublic:\n    Z2SoundObjSimple();\n    ~Z2SoundObjSimple();\n\n    virtual void init(Vec* pSoundPos, u8 pNumHandles);\n    virtual JAISoundHandle* startSound(JAISoundID, u32, s8);\n    virtual JAISoundHandle* startLevelSound(JAISoundID, u32, s8);\n};\n\nclass Z2SoundObjAnime : public Z2SoundObjBase {\npublic:\n    /* 802BEB94 */ Z2SoundObjAnime();\n    /* 802BEBFC */ void initAnime(void*, bool, f32, f32);\n    /* 802BED68 */ void ageSounds_();\n    /* 802BEED4 */ void updateAnime(f32, f32);\n    /* 802BF304 */ void updateSoundLifeTime_(f32, f32);\n    /* 802BF660 */ void startSoundInner(JGeometry::TVec3<f32> const&, f32, Z2SoundStarter*, u32,\n                                        s8);\n    /* 802BF890 */ u32 getSoundID(JAUSoundAnimationSound const*,\n                                         JGeometry::TVec3<f32> const&, f32);\n    /* 802BF898 */ bool playsSound(JAUSoundAnimationSound const*, JGeometry::TVec3<f32> const&,\n                                   f32);\n\n    /* 802BEBDC */ virtual void init(Vec*, u8);\n\n    void stopAnime() { mpAnimation = NULL; }\n    void setLoopStartFrame(f32 i_frame) {\n        mStartSoundFrame = i_frame;\n        mStartSoundIndex = mpAnimation->getStartSoundIndex(i_frame);\n    }\n    void setLoopEndFrame(f32 i_frame) {\n        mEndSoundFrame = i_frame;\n        mEndSoundIndex = mpAnimation->getEndSoundIndex(i_frame);\n    }\n    void setLoopFrame(f32 i_startFrame, f32 i_endFrame) {\n        setLoopStartFrame(i_startFrame);\n        setLoopEndFrame(i_endFrame);\n    }\n\n    /* 0x20 */ JAUSoundAnimation* mpAnimation;\n    /* 0x24 */ int field_0x24;\n    /* 0x28 */ f32 mCurSoundFrame;\n    /* 0x2C */ f32 mStartSoundFrame;\n    /* 0x30 */ f32 mEndSoundFrame;\n    /* 0x34 */ int mStartSoundIndex;\n    /* 0x38 */ int mEndSoundIndex;\n    /* 0x3C */ int field_0x3c;\n    /* 0x40 */ int mCurSoundIndex;\n    /* 0x44 */ bool mReverse;\n};\n\nclass Z2DopplerSoundObjBase : public Z2SoundObjBase {\npublic:\n    Z2DopplerSoundObjBase();\n    ~Z2DopplerSoundObjBase();\n\n    virtual void framework(u32, s8);\n    virtual void init(Vec*, u8);\n    virtual JAISoundHandle* startSound(JAISoundID, u32, s8);\n    virtual JAISoundHandle* startLevelSound(JAISoundID, u32, s8);\n\n    /* 0x20 */ JGeometry::TVec3<f32> field_0x20;\n    /* 0x2C */ JGeometry::TVec3<f32> field_0x2c;\n};\n\nclass Z2SoundObjArrow : public Z2DopplerSoundObjBase {\npublic:\n    /* 802BEB38 */ Z2SoundObjArrow();\n    /* 802BEB74 */ virtual void init(Vec*, u8);\n};\n\n#endif /* Z2SOUNDOBJECT_H */\n/* end \"Z2AudioLib/Z2SoundObject.h\" */\n/* \"include/m_Do/m_Do_ext.h\" line 6 \"global.h\" */\n/* end \"global.h\" */\n/* \"include/m_Do/m_Do_ext.h\" line 7 \"m_Do/m_Do_audio.h\" */\n#ifndef M_DO_M_DO_AUDIO_H\n#define M_DO_M_DO_AUDIO_H\n\n/* \"include/m_Do/m_Do_audio.h\" line 3 \"Z2AudioLib/Z2AudioMgr.h\" */\n#ifndef Z2AUDIOMGR_H\n#define Z2AUDIOMGR_H\n\n/* \"include/Z2AudioLib/Z2AudioMgr.h\" line 3 \"JSystem/JAudio2/JASAudioReseter.h\" */\n#ifndef JASAUDIORESETER_H\n#define JASAUDIORESETER_H\n\n/* \"include/JSystem/JAudio2/JASAudioReseter.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nstruct JASAudioReseter {\n    /* 8029D0B4 */ JASAudioReseter();\n    /* 8029D0FC */ ~JASAudioReseter();\n    /* 8029D138 */ bool start(u32, bool);\n    /* 8029D1D4 */ void resume();\n    /* 8029D1F8 */ s32 checkDone() const;\n    /* 8029D200 */ s32 calc();\n    /* 8029D2D4 */ static s32 callback(void*);\n\n    /* 0x0 */ u32 field_0x0;\n    /* 0x4 */ f32 mDSPLevel;\n    /* 0x8 */ s32 mIsDone;\n    /* 0xC */ bool field_0xc;\n};  // Size: 0x10\n\n#endif /* JASAUDIORESETER_H */\n/* end \"JSystem/JAudio2/JASAudioReseter.h\" */\n/* \"include/Z2AudioLib/Z2AudioMgr.h\" line 4 \"Z2AudioLib/Z2Audience.h\" */\n#ifndef Z2AUDIENCE_H\n#define Z2AUDIENCE_H\n\n/* \"include/Z2AudioLib/Z2Audience.h\" line 3 \"JSystem/JAudio2/JAIAudience.h\" */\n#ifndef JAIAUDIENCE_H\n#define JAIAUDIENCE_H\n\n/* \"include/JSystem/JAudio2/JAIAudience.h\" line 3 \"JSystem/JGeometry.h\" */\n/* end \"JSystem/JGeometry.h\" */\n\nclass JAIAudible;\nclass JAISoundID;\nstruct JASSoundParams;\n\nstruct JAIAudience {\n    virtual ~JAIAudience();\n    virtual JAIAudible* newAudible(JGeometry::TVec3<f32> const&, JAISoundID,\n                                   JGeometry::TVec3<f32> const*, u32) = 0;\n    virtual int getMaxChannels() = 0;\n    virtual void deleteAudible(JAIAudible*) = 0;\n    virtual u32 calcPriority(JAIAudible*) = 0;\n    virtual void mixChannelOut(JASSoundParams const&, JAIAudible*, int) = 0;\n};\n\n#endif /* JAIAUDIENCE_H */\n/* end \"JSystem/JAudio2/JAIAudience.h\" */\n/* \"include/Z2AudioLib/Z2Audience.h\" line 4 \"JSystem/JAudio2/JASGadget.h\" */\n#ifndef JASGADGET_H\n#define JASGADGET_H\n\n/* \"include/JSystem/JAudio2/JASGadget.h\" line 3 \"JSystem/JUtility/JUTAssert.h\" */\n/* end \"JSystem/JUtility/JUTAssert.h\" */\n/* \"include/JSystem/JAudio2/JASGadget.h\" line 4 \"string.h\" */\n#ifndef _MSL_COMMON_STRING_H\n#define _MSL_COMMON_STRING_H\n\n/* \"libs/PowerPC_EABI_Support/MSL/MSL_C/MSL_Common/Include/string.h\" line 3 \"stddef.h\" */\n/* end \"stddef.h\" */\n/* \"libs/PowerPC_EABI_Support/MSL/MSL_C/MSL_Common/Include/string.h\" line 4 \"extras.h\" */\n#ifndef _MSL_COMMON_EXTRAS_H\n#define _MSL_COMMON_EXTRAS_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint strnicmp(const char* str1, const char* str2, int n);\nint stricmp(const char* str1, const char* str2);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _MSL_COMMON_EXTRAS_H */\n/* end \"extras.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid* memcpy(void* dst, const void* src, size_t n);\nvoid* memset(void* dst, int val, size_t n);\nint memcmp(const void* lhs, const void* rhs, size_t count);\nvoid* __memrchr(const void* ptr, int ch, size_t count);\nvoid* memchr(const void* ptr, int ch, size_t count);\nvoid* memmove(void* dst, const void* src, size_t n);\nchar* strrchr(const char* str, int c);\nchar* strchr(const char* str, int c);\nint strncmp(const char* str1, const char* str2, size_t n);\nint strcmp(const char* str1, const char* str2);\nchar* strcat(char* dst, const char* src);\nchar* strncpy(char* dst, const char* src, size_t n);\nchar* strcpy(char* dst, const char* src);\nsize_t strlen(const char* str);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _MSL_COMMON_STRING_H */\n/* end \"string.h\" */\n\ntemplate<class T>\nclass JASGlobalInstance {\npublic:\n    JASGlobalInstance(T* inst) {\n        sInstance = inst;\n    }\n\n    JASGlobalInstance(bool param_1) {\n        if (param_1) {\n            JUT_ASSERT(186, sInstance == 0);\n            sInstance = (T*)this;\n        }\n    }\n\n    ~JASGlobalInstance() {\n        if (sInstance == (T*)this) {\n            sInstance = NULL;\n        }\n    }\n\n    static T* getInstance() { return sInstance; }\n\n    static T* sInstance;\n};\n\ntemplate<class T>\nclass JASPtrTable {\npublic:\n    JASPtrTable(T** param_0, u32 size) {\n        mTable = param_0;\n        mSize = size;\n        memset(mTable, 0, size * 4);\n    }\n    T* get(u32 index) {\n        if (index >= mSize) {\n            return NULL;\n        }\n        return mTable[index];\n    }\n    T* get(u32 index) const {\n        if (index >= mSize) {\n            return NULL;\n        }\n        return mTable[index];\n    }\n    void set(u32 index, T* value) {\n        JUT_ASSERT(229, index < mSize);\n        mTable[index] = value;\n    }\n\nprivate:\n    /* 0x00 */ T** mTable;\n    /* 0x04 */ u32 mSize;\n};\n\ntemplate<class T, size_t N>\nclass JASPtrArray : public JASPtrTable<T> {\npublic:\n    JASPtrArray() : JASPtrTable<T>(mArray, N) {}\n\nprivate:\n    /* 0x08 */ T* mArray[N];\n};\n\n#endif /* JASGADGET_H */\n/* end \"JSystem/JAudio2/JASGadget.h\" */\n/* \"include/Z2AudioLib/Z2Audience.h\" line 5 \"JSystem/JAudio2/JAIAudible.h\" */\n/* end \"JSystem/JAudio2/JAIAudible.h\" */\n/* \"include/Z2AudioLib/Z2Audience.h\" line 6 \"JSystem/JAudio2/JASSoundParams.h\" */\n/* end \"JSystem/JAudio2/JASSoundParams.h\" */\n/* \"include/Z2AudioLib/Z2Audience.h\" line 7 \"JSystem/JAudio2/JASHeapCtrl.h\" */\n/* end \"JSystem/JAudio2/JASHeapCtrl.h\" */\n/* \"include/Z2AudioLib/Z2Audience.h\" line 8 \"JSystem/JAudio2/JAUAudibleParam.h\" */\n#ifndef JAUAUDIBLEPARAM_H\n#define JAUAUDIBLEPARAM_H\n\n/* \"include/JSystem/JAudio2/JAUAudibleParam.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nstruct JAUAudibleParam {\n    f32 getDopplerPower() const {\n        return (u32)((*(u8*)&field_0x0.raw >> 4) & 0xf) * (1.0f / 15.0f);\n    }\n    union {\n        struct {\n            u16 f0;\n            u16 f1;\n        } half;\n        struct {\n            u8 b0_0 : 1;\n            u8 b0_1 : 1;\n            u8 b0_2 : 1;\n            u8 b0_3 : 1;\n            u8 b0_4 : 1;\n            u8 b0_5 : 1;\n            u8 b0_6 : 1;\n            u8 b0_7 : 1;\n            u8 b1_0 : 1;\n            u8 b1_1 : 1;\n            u8 b1_2_7 : 6;\n            u8 b2;\n            u8 b3;\n        } bytes;\n        u32 raw;\n    } field_0x0;\n};\n\n#endif /* JAUAUDIBLEPARAM_H */\n/* end \"JSystem/JAudio2/JAUAudibleParam.h\" */\n/* \"include/Z2AudioLib/Z2Audience.h\" line 9 \"JSystem/TPosition3.hh\" */\n#ifndef TPOSITION3_H\n#define TPOSITION3_H\n\n/* \"include/JSystem/TPosition3.hh\" line 3 \"dolphin/mtx/mtx.h\" */\n/* end \"dolphin/mtx/mtx.h\" */\n/* \"include/JSystem/TPosition3.hh\" line 4 \"JSystem/JMath/JMath.h\" */\n#ifndef JMATH_H\n#define JMATH_H\n\n/* \"include/JSystem/JMath/JMath.h\" line 3 \"dolphin/mtx/mtx.h\" */\n/* end \"dolphin/mtx/mtx.h\" */\n\nvoid JMAMTXApplyScale(const Mtx, Mtx, f32, f32, f32);\nvoid JMAEulerToQuat(s16 param_0, s16 param_1, s16 param_2, Quaternion* param_3);\nvoid JMAQuatLerp(const Quaternion*, const Quaternion*, f32, Quaternion*);\n\ninline f32 JMAFastReciprocal(f32 value) {\n    return __fres(value);\n}\n\ninline float __frsqrtes(register double f) {\n    register float out;\n    // clang-format off\n    asm {\n        frsqrte out, f\n    }\n    // clang-format on\n    return out;\n}\n\ninline f32 JMAFastSqrt(register f32 input) {\n    if (input > 0.0f) {\n        register f32 out;\n        asm {\n            frsqrte out, input\n        }\n        return out * input;\n    } else {\n        return input;\n    }\n}\n\nnamespace JMath {\n\ninline f32 fastReciprocal(f32 value) {\n    return JMAFastReciprocal(value);\n}\n\ninline void gekko_ps_copy3(register void* dst, register const void* src) {\n    register f32 src0;\n    register f32 src1;\n    asm {\n        psq_l src0, 0(src), 0, 0\n        lfs src1, 8(src)\n        psq_st src0, 0(dst), 0, 0\n        stfs src1, 8(dst)\n    };\n}\n\ninline void gekko_ps_copy6(register void* dst, register const void* src) {\n    register f32 src0;\n    register f32 src1;\n    register f32 src2;\n    asm {\n        psq_l src0, 0(src), 0, 0\n        psq_l src1, 8(src), 0, 0\n        psq_l src2, 16(src), 0, 0\n        psq_st src0, 0(dst), 0, 0\n        psq_st src1, 8(dst), 0, 0\n        psq_st src2, 16(dst), 0, 0\n    };\n}\n\ninline void gekko_ps_copy12(register void* dst, register const void* src) {\n    register f32 src0;\n    register f32 src1;\n    register f32 src2;\n    register f32 src3;\n    register f32 src4;\n    register f32 src5;\n    asm {\n        psq_l src0, 0(src), 0, 0\n        psq_l src1, 8(src), 0, 0\n        psq_l src2, 16(src), 0, 0\n        psq_l src3, 24(src), 0, 0\n        psq_l src4, 32(src), 0, 0\n        psq_l src5, 40(src), 0, 0\n        psq_st src0, 0(dst), 0, 0\n        psq_st src1, 8(dst), 0, 0\n        psq_st src2, 16(dst), 0, 0\n        psq_st src3, 24(dst), 0, 0\n        psq_st src4, 32(dst), 0, 0\n        psq_st src5, 40(dst), 0, 0\n    };\n}\n\ninline void gekko_ps_copy16(register void* dst, register const void* src) {\n    register f32 src0;\n    register f32 src1;\n    register f32 src2;\n    register f32 src3;\n    register f32 src4;\n    register f32 src5;\n    register f32 src6;\n    register f32 src7;\n    asm {\n        psq_l src0, 0(src), 0, 0\n        psq_l src1, 8(src), 0, 0\n        psq_l src2, 16(src), 0, 0\n        psq_l src3, 24(src), 0, 0\n        psq_l src4, 32(src), 0, 0\n        psq_l src5, 40(src), 0, 0\n        psq_l src6, 48(src), 0, 0\n        psq_l src7, 56(src), 0, 0\n        psq_st src0, 0(dst), 0, 0\n        psq_st src1, 8(dst), 0, 0\n        psq_st src2, 16(dst), 0, 0\n        psq_st src3, 24(dst), 0, 0\n        psq_st src4, 32(dst), 0, 0\n        psq_st src5, 40(dst), 0, 0\n        psq_st src6, 48(dst), 0, 0\n        psq_st src7, 56(dst), 0, 0\n    };\n}\n\n};  // namespace JMath\n\n#endif /* JMATH_H */\n/* end \"JSystem/JMath/JMath.h\" */\n\nnamespace JGeometry {\n\ntemplate <typename T>\nstruct SMatrix34C {\n    T data[3][4];\n};\n\ntemplate <>\nstruct SMatrix34C<f32> {\n    f32 data[3][4];\n\n    void identity() { MTXIdentity(data); }\n\n    typedef f32 ArrType[4];\n    void set(const ArrType* src) { JMath::gekko_ps_copy12((f32*)data, (f32*)src); }\n\n    operator ArrType*() { return data; }\n    operator const ArrType*() const { return data; }\n};\n\ntemplate <typename T>\nstruct TMatrix34 : public T {};\n\ntemplate <typename T>\nstruct TRotation3 : public T {};\n\ntemplate <typename T>\nstruct TPosition3 : public T {};\n\ntypedef TPosition3<TRotation3<TMatrix34<SMatrix34C<f32> > > > TPosition3f32;\n\n}  // namespace JGeometry\n\n#endif/* end \"JSystem/TPosition3.hh\" */\n/* \"include/Z2AudioLib/Z2Audience.h\" line 10 \"dolphin/mtx/mtxvec.h\" */\n/* end \"dolphin/mtx/mtxvec.h\" */\n\nstruct Z2Audible;\n\nstruct Z2AudibleAbsPos {\n    /* 802BBCDC */ void calc(JGeometry::TVec3<f32> const&);\n    /* 802BBD18 */ void init(JGeometry::TVec3<f32>*, JGeometry::TVec3<f32> const&,\n                             JGeometry::TVec3<f32> const*);\n\n    /* 0x00 */ JGeometry::TVec3<f32> field_0x0;\n    /* 0x0C */ JGeometry::TVec3<f32> field_0xc;\n};\n\nstruct Z2AudioCamera {\n    /* 802BC758 */ Z2AudioCamera();\n    /* 802BC788 */ void init();\n    /* 802BC8AC */ void setCameraState(f32 (*)[4], Vec&, Vec&, f32, f32, bool, bool);\n    /* 802BC7DC */ void setCameraState(f32 const (*)[4], Vec&, bool);\n    /* 802BCBEC */ void convertAbsToRel(Z2Audible*, int);\n    /* 802BCC7C */ bool convertAbsToRel(Vec&, Vec*) const;\n    /* 802BCCC0 */ bool isInSight(Vec&) const;\n    JGeometry::TVec3<f32>* getPos() { return &mPos; }\n    f32 getVolCenterZ() const { return mVolCenterZ; }\n    void setMainCamera() { mSetMainCamera = true; }\n    void setTargetVolume(f32 volume) { \n        if (volume < 0.0f) {\n            volume = 0.0f;\n        }\n        mTargetVolume = volume;\n    }\n    f32 getDolbyCenterZ() const { return mDolbyCenterZ; }\n    f32 getFovySin() const { return mFovySin; }\n    const JGeometry::TVec3<f32>* getVel() const { return &mVel; }\n\n\n    /* 0x00 */ JGeometry::TPosition3f32 field_0x0;\n    /* 0x30 */ JGeometry::TVec3<f32> mVel;\n    /* 0x3C */ JGeometry::TVec3<f32> mPos;\n    /* 0x48 */ JGeometry::TVec3<f32> field_0x48;\n    /* 0x54 */ f32 mFovySin;\n    /* 0x58 */ f32 mVolCenterZ;\n    /* 0x5C */ f32 mTargetVolume;\n    /* 0x60 */ f32 mDolbyCenterZ;\n    /* 0x64 */ f32 mCamDist;\n    /* 0x68 */ f32 field_0x68;\n    /* 0x6C */ f32 field_0x6c;\n    /* 0x70 */ bool mSetMainCamera;\n};  // Size: 0x74\n\nstruct Z2SpotMic {\n    /* 802BCD28 */ Z2SpotMic();\n    /* 802BCDA8 */ void clearMicState(int);\n    /* 802BCDE8 */ void calcVolumeFactor(int);\n    /* 802BCE14 */ void setMicState(Z2AudioCamera*, int);\n    /* 802BCF5C */ f32 calcMicDist(Z2Audible*);\n    /* 802BCFE4 */ u32 calcMicPriority(f32);\n    /* 802BD03C */ f32 calcMicVolume(f32, int, f32);\n\n    void setPosPtr(Vec* i_posPtr) { mPosPtr = i_posPtr; }\n    bool isOn() const { return mMicOn; }\n\n    /* 0x00 */ f32 field_0x0;\n    /* 0x04 */ f32 field_0x4;\n    /* 0x08 */ f32 field_0x8;\n    /* 0x0C */ f32 field_0xc;\n    /* 0x10 */ Z2AudioCamera* field_0x10[1];\n    /* 0x14 */ Vec* mPosPtr;\n    /* 0x18 */ f32 field_0x18[1];\n    /* 0x1C */ f32 field_0x1c;\n    /* 0x20 */ f32 field_0x20[1];\n    /* 0x24 */ bool mIgnoreIfOut;\n    /* 0x25 */ bool mMicOn;\n    /* 0x26 */ u8 field_0x26[1];\n};  // Size: 0x28\n\nstruct Z2Audience3DSetting {\n    /* 802BC248 */ Z2Audience3DSetting();\n    /* 802BC284 */ void init();\n    /* 802BC308 */ void initVolumeDist();\n    /* 802BC4D0 */ void updateVolumeDist(f32);\n    /* 802BC6A4 */ void initDolbyDist();\n    /* 802BC6F8 */ void updateDolbyDist(f32, f32);\n\n    void calcVolumeFactorAll() {\n        field_0x0[1] = 1.25f * field_0x0[0];\n        field_0x0[2] = 1.5f * field_0x0[0];\n        field_0x0[3] = 2.0f * field_0x0[0];\n        field_0x0[4] = 3.0f * field_0x0[0];\n        field_0x0[5] = 4.0f * field_0x0[0];\n        field_0x0[6] = 6.0f * field_0x0[0];\n        field_0x0[7] = 8.0f * field_0x0[0];\n        field_0x0[8] = 0.9f * field_0x0[0];\n        field_0x0[9] = 0.8f * field_0x0[0];\n        field_0x0[10] = 0.7f * field_0x0[0];\n        field_0x0[11] = 0.6f * field_0x0[0];\n        field_0x0[12] = 0.5f * field_0x0[0];\n        field_0x0[13] = 0.4f * field_0x0[0];\n        field_0x0[14] = 0.3f * field_0x0[0];\n        for (int i = 0; i < 15; i++) {\n            field_0x70[i] = (field_0x40 - 1.0f) / (field_0x0[i] - field_0x3c);\n        }\n    }\n\n    void calcPriorityFactorAll() {\n        for (int i = 0; i < 15; i++) {\n            field_0xac[i] = field_0x64 / (field_0x0[i] - field_0x3c);\n        }\n    }\n\n    void calcFxMixFactorAll() {\n        for (int i = 0; i < 15; i++) {\n            field_0xe8[i] = (field_0x54 - field_0x50) / (field_0x0[i] - field_0x3c);\n        }\n    }\n\n    /* 0x000 */ f32 field_0x0[15];\n    /* 0x03C */ f32 field_0x3c;\n    /* 0x040 */ f32 field_0x40;\n    /* 0x044 */ f32 field_0x44;\n    /* 0x048 */ f32 field_0x48;\n    /* 0x04C */ f32 field_0x4c;\n    /* 0x050 */ f32 field_0x50;\n    /* 0x054 */ f32 field_0x54;\n    /* 0x058 */ f32 field_0x58;\n    /* 0x05C */ f32 field_0x5c;\n    /* 0x060 */ f32 field_0x60;\n    /* 0x064 */ u32 field_0x64;\n    /* 0x068 */ f32 field_0x68;\n    /* 0x06C */ f32 field_0x6c;\n    /* 0x070 */ f32 field_0x70[15];\n    /* 0x0AC */ f32 field_0xac[15];\n    /* 0x0E8 */ f32 field_0xe8[15];\n    /* 0x124 */ bool mVolumeDistInit;\n    /* 0x125 */ bool mDolbyDistInit;\n};  // Size: 0x128\n\nstruct Z2AudibleRelPos {\n    /* 0x00 */ JGeometry::TVec3<f32> field_0x00;\n    /* 0x0C */ f32 field_0xC;\n    /* 0x10 */ f32 field_0x10;\n};\n\nstruct Z2AudibleChannel {\n    /* 802BBE74 */ Z2AudibleChannel();\n    void init() {\n        field_0x0.init();\n        field_0x28 = -1.0f;\n        mPan = 0.5f;\n        mDolby = 0.0f;\n        field_0x34 = 1.0f;\n    }\n\n    /* 0x00 */ JASSoundParams field_0x0;\n    /* 0x14 */ Z2AudibleRelPos field_0x14;\n    /* 0x28 */ f32 field_0x28;\n    /* 0x2c */ f32 mPan;\n    /* 0x30 */ f32 mDolby;\n    /* 0x34 */ f32 field_0x34;\n};\n\nstruct Z2Audible : public JAIAudible, public JASPoolAllocObject<Z2Audible> {\n    /* 802BBD94 */ Z2Audible(JGeometry::TVec3<f32> const&, JGeometry::TVec3<f32> const*, u32, bool);\n    /* 802BBE98 */ void calc();\n    /* 802BBED0 */ JASSoundParams* getOuterParams(int);\n    /* 802BBEE4 */ void setOuterParams(JASSoundParams const&, JASSoundParams const&, int);\n    /* 802BC204 */ Z2AudibleChannel* getChannel(int);\n    /* 802BC218 */ u32 getDistVolBit();\n    /* 802BD510 */ ~Z2Audible();\n    bool isDoppler() {\n        return ((*(u8*)&field_0x10.field_0x0) >> 4) & 0xf;\n    }\n    JAUAudibleParam* getAudibleParam() { return &field_0x10; }\n    const JAUAudibleParam* getAudibleParam() const { return &field_0x10; }\n    void setAudibleParam(JAUAudibleParam param) { field_0x10 = param; }\n    const JGeometry::TVec3<f32>* getVel() const { return &field_0x14.field_0xc; }\n\n    /* 0x10 */ JAUAudibleParam field_0x10;\n    /* 0x14 */ Z2AudibleAbsPos field_0x14;\n    /* 0x2C */ Z2AudibleChannel field_0x2c[1];\n    /* 0x64 */ f32 field_0x64[1];\n};\n\nstruct Z2Audience : public JAIAudience, public JASGlobalInstance<Z2Audience> {\n    /* 802BD130 */ Z2Audience();\n    /* 802BD2DC */ void setAudioCamera(f32 (*)[4], Vec&, Vec&, f32, f32, bool, int, bool);\n    /* 802BD704 */ f32 calcOffMicSound(f32);\n    /* 802BD90C */ void setTargetVolume(f32, int);\n    /* 802BD92C */ bool convertAbsToRel(Vec&, Vec*, int);\n    /* 802BD95C */ f32 calcRelPosVolume(Vec const&, f32, int);\n    /* 802BDA44 */ f32 calcRelPosPan(Vec const&, int);\n    /* 802BDB44 */ f32 calcRelPosDolby(Vec const&, int);\n    /* 802BDBDC */ f32 calcVolume_(f32, int) const;\n    /* 802BDC44 */ u32 calcDeltaPriority_(f32, int, bool) const;\n    /* 802BDCB0 */ f32 calcPitchDoppler_(JGeometry::TVec3<f32> const&,\n                                          JGeometry::TVec3<f32> const&,\n                                          JGeometry::TVec3<f32> const&, f32) const;\n    /* 802BDD00 */ f32 calcFxMix_(f32, int) const;\n    /* 802BDD48 */ f32 calcPitch_(Z2AudibleChannel*, Z2Audible const*, Z2AudioCamera const*) const;\n\n    /* 802BD1FC */ virtual ~Z2Audience();\n    /* 802BD338 */ virtual JAIAudible* newAudible(JGeometry::TVec3<f32> const&, JAISoundID,\n                                                  JGeometry::TVec3<f32> const*, u32);\n    /* 802BDED4 */ virtual int getMaxChannels();\n    /* 802BD4D4 */ virtual void deleteAudible(JAIAudible*);\n    /* 802BD5B8 */ virtual u32 calcPriority(JAIAudible*);\n    /* 802BD71C */ virtual void mixChannelOut(JASSoundParams const&, JAIAudible*, int);\n\n    Z2SpotMic* getLinkMic() { return mLinkMic; }\n    JGeometry::TVec3<f32> getAudioCamPos() {\n        JGeometry::TVec3<f32> pos;\n        JGeometry::setTVec3f(*(Vec*)mAudioCamera[0].getPos(), *(Vec*)pos);\n        return pos;\n    }\n    Z2Audience3DSetting* getSetting() { return &mSetting; }\n\n    /* 0x004 */ f32 field_0x4;\n    /* 0x008 */ u8 field_0x8;\n    /* 0x00C */ Z2Audience3DSetting mSetting;\n    /* 0x134 */ Z2AudioCamera mAudioCamera[1];\n    /* 0x1A8 */ Z2SpotMic mSpotMic[1];\n    /* 0x1D0 */ Z2SpotMic* mLinkMic;\n    /* 0x1D4 */ s32 mNumPlayers;\n    /* 0x1D8 */ u8 field_0x1d8[4];\n    /* 0x1DC */ bool mUsingOffMicVol;\n};  // Size: 0x1E0\n\ninline Z2Audience* Z2GetAudience() {\n    return JASGlobalInstance<Z2Audience>::getInstance();\n}\n\n#endif /* Z2AUDIENCE_H */\n/* end \"Z2AudioLib/Z2Audience.h\" */\n/* \"include/Z2AudioLib/Z2AudioMgr.h\" line 5 \"Z2AudioLib/Z2FxLineMgr.h\" */\n#ifndef Z2FXLINEMGR_H\n#define Z2FXLINEMGR_H\n\n/* \"include/Z2AudioLib/Z2FxLineMgr.h\" line 3 \"JSystem/JAudio2/JASGadget.h\" */\n/* end \"JSystem/JAudio2/JASGadget.h\" */\n\nclass JKRArchive;\nclass JKRHeap;\n\nstruct Z2FxLineEditNode {};\n\nstruct Z2FxLineConfig {};\n\nstruct Z2FxLineMgr : public JASGlobalInstance<Z2FxLineMgr> {\n    /* 802BA7DC */ Z2FxLineMgr();\n    /* 802BA7FC */ void initDataArc(JKRArchive*, JKRHeap*);\n    /* 802BAC28 */ void setLineID(s8, bool, bool);\n    /* 802BAC74 */ void setLine(Z2FxLineConfig*, bool, bool);\n    /* 802BAE1C */ void setFxForceOff(bool);\n    /* 802BAE48 */ void setUnderWaterFx(bool);\n    /* 802BAEB8 */ void setSceneFx(s32);\n\n    /* 0x00 */ int field_0x0;\n    /* 0x04 */ void* mFxLineBuffer[4];\n    /* 0x14 */ s8 mLineID;\n    /* 0x15 */ s8 mFxDataNum;\n    /* 0x16 */ bool mSetUnderWaterFx;\n    /* 0x18 */ Z2FxLineEditNode* mHIOEdit;\n};  // Size: 0x1C\n\ninline Z2FxLineMgr* Z2GetFxLineMgr() {\n    return JASGlobalInstance<Z2FxLineMgr>::getInstance();\n}\n\n#endif /* Z2FXLINEMGR_H */\n/* end \"Z2AudioLib/Z2FxLineMgr.h\" */\n/* \"include/Z2AudioLib/Z2AudioMgr.h\" line 6 \"Z2AudioLib/Z2SceneMgr.h\" */\n#ifndef Z2SCENEMGR_H\n#define Z2SCENEMGR_H\n\n/* \"include/Z2AudioLib/Z2SceneMgr.h\" line 3 \"JSystem/JAudio2/JAISound.h\" */\n/* end \"JSystem/JAudio2/JAISound.h\" */\n/* \"include/Z2AudioLib/Z2SceneMgr.h\" line 4 \"JSystem/JAudio2/JASGadget.h\" */\n/* end \"JSystem/JAudio2/JASGadget.h\" */\n\nclass Z2SceneMgr : public JASGlobalInstance<Z2SceneMgr> {\npublic:\n    Z2SceneMgr();\n    void setInDarkness(bool);\n    void setSceneExist(bool);\n    void setFadeOutStart(u8);\n    void setFadeInStart(u8);\n    void setSceneName(char*, s32, s32);\n    void sceneChange(JAISoundID, u8, u8, u8, u8, u8, bool);\n    void framework();\n    void load1stDynamicWave();\n    void _load1stWaveInner_1();\n    void _load1stWaveInner_2();\n    bool check1stDynamicWave();\n    void load2ndDynamicWave();\n    void sceneBgmStart();\n    void loadStaticWaves();\n    BOOL checkFirstWaves();\n    void eraseSeWave(u32);\n    void eraseBgmWave(u32);\n    void getWaveLoadStatus(u32, u32);\n    void loadSeWave(u32);\n    void loadBgmWave(u32);\n\n    bool isSceneExist() const { return sceneExist; }\n    int getCurrentSceneNum() const { return sceneNum; }\n\nprivate:\n    /* 0x00 */ long BGM_ID;\n    /* 0x04 */ int sceneNum;\n    /* 0x08 */ int timer;\n    /* 0x0C */ s8 roomNum;\n    /* 0x0D */ u8 SeWave_1;\n    /* 0x0E */ u8 SeWaveToErase_1;\n    /* 0x0F */ u8 SeWave_2;\n    /* 0x10 */ u8 SeWaveToErase_2;\n    /* 0x11 */ u8 BgmWave_1;\n    /* 0x12 */ u8 BgmWaveToErase_1;\n    /* 0x13 */ u8 BgmWave_2;\n    /* 0x14 */ u8 BgmWaveToErase_2;\n    /* 0x15 */ u8 SeWave_3;\n    /* 0x16 */ u8 SeWaveToErase_3;\n    /* 0x17 */ u8 field_0x17;\n    /* 0x18 */ u8 field_0x18;\n    /* 0x19 */ u8 field_0x19;\n    /* 0x1A */ u8 field_0x1a;\n    /* 0x1B */ u8 field_0x1b;\n    /* 0x1C */ bool inGame;\n    /* 0x1D */ bool sceneExist;\n    /* 0x1E */ bool inDarkness;\n};  // Size = 0x20\n\ninline Z2SceneMgr* Z2GetSceneMgr() {\n    return JASGlobalInstance<Z2SceneMgr>::getInstance();\n}\n\n#endif /* Z2SCENEMGR_H */\n/* end \"Z2AudioLib/Z2SceneMgr.h\" */\n/* \"include/Z2AudioLib/Z2AudioMgr.h\" line 7 \"Z2AudioLib/Z2SeMgr.h\" */\n#ifndef Z2SEMGR_H\n#define Z2SEMGR_H\n\n/* \"include/Z2AudioLib/Z2SeMgr.h\" line 3 \"JSystem/JAudio2/JAISoundHandles.h\" */\n/* end \"JSystem/JAudio2/JAISoundHandles.h\" */\n/* \"include/Z2AudioLib/Z2SeMgr.h\" line 4 \"JSystem/JAudio2/JASGadget.h\" */\n/* end \"JSystem/JAudio2/JASGadget.h\" */\n/* \"include/Z2AudioLib/Z2SeMgr.h\" line 5 \"dolphin/mtx/vec.h\" */\n/* end \"dolphin/mtx/vec.h\" */\n\nstruct Z2MultiSeMgr {\n    Z2MultiSeMgr();\n    ~Z2MultiSeMgr();\n    void registMultiSePos(Vec*);\n    void resetMultiSePos();\n    void getPanPower();\n    void getDolbyPower();\n\n    void setVolumeScale(f32 param_0) { mVolumeScale = param_0; }\n\n    /* 0x00 */ float mVolumeScale;\n    /* 0x04 */ float mMaxVolume;\n    /* 0x08 */ float mMaxPowL;\n    /* 0x0C */ float mMaxPowR;\n    /* 0x10 */ float mMaxPowB;\n    /* 0x14 */ float mMaxPowF;\n    /* 0x18 */ s8 mPosCount;\n};  // Size = 0x1C\n\nstruct Z2MultiSeObj : Z2MultiSeMgr {\n    Z2MultiSeObj();\n    ~Z2MultiSeObj() {}\n\n    /* 0x1C */ u32 field_0x1c;\n    /* 0x20 */ u8 field_0x20;\n};  // Size = 0x24\n\nclass Z2SeMgr : public JASGlobalInstance<Z2SeMgr> {\npublic:\n    /* 802AB64C */ Z2SeMgr();\n    /* 802AB750 */ void initSe();\n    /* 802AB80C */ void resetModY();\n    /* 802AB830 */ void modHeightAtCamera(Vec const**);\n    /* 802AB93C */ void incrCrowdSize();\n    /* 802AB960 */ void decrCrowdSize();\n    /* 802AB984 */ void seStart(JAISoundID, Vec const*, u32, s8, f32, f32, f32, f32, u8);\n    /* 802AC50C */ void seStartLevel(JAISoundID, Vec const*, u32, s8, f32, f32, f32, f32, u8);\n    /* 802AD8B0 */ void seStop(JAISoundID, u32);\n    /* 802AD94C */ void seStopAll(u32);\n    /* 802AD9F4 */ void seMoveVolumeAll(f32, u32);\n    /* 802ADB14 */ void messageSePlay(u16, Vec*, s8);\n    /* 802ADB50 */ void talkInSe();\n    /* 802ADC54 */ void talkOutSe();\n    /* 802ADD58 */ void menuInSe();\n    /* 802ADE5C */ void setLevObjSE(u32, Vec*, s8);\n    /* 802ADFF4 */ void setMultiTriggerSE(u32, Vec*, s8);\n    /* 802AE184 */ void processSeFramework();\n    /* 802AE524 */ void isLevelSe(JAISoundID);\n    /* 802AE5B0 */ bool isSoundCulling(JAISoundID);\n    /* 802B9AC4 */ void resetCrowdSize();\n\nprivate:\n    /* 0x000 */ JAISoundHandle mSoundHandle[24];\n    /* 0x060 */ JAISoundHandles field_0x60;\n    /* 0x068 */ Z2MultiSeObj mLevelObjSe[10];\n    /* 0x1D0 */ u8 mLevelObjectSeCount;\n    /* 0x1D4 */ Z2MultiSeObj mMultiTriggerSe[10];\n    /* 0x33C */ u8 mMultiTriggerSeCount;\n    /* 0x33D */ u8 field_0x33d[0x60];\n    /* 0x3A0 */ u32 mModY[8];\n    /* 0x3C0 */ u8 field_0x3c0;\n    /* 0x3C1 */ u8 field_0x3c1;\n    /* 0x3C2 */ u8 field_0x3c2;\n    /* 0x3C3 */ u8 field_0x3c3;\n    /* 0x3C4 */ u8 field_0x3c4;\n    /* 0x3C5 */ u8 field_0x3c5;\n    /* 0x3C6 */ u8 field_0x3c6;\n    /* 0x3C7 */ u8 field_0x3c7;\n    /* 0x3C8 */ u8 field_0x3c8;\n    /* 0x3C9 */ u8 field_0x3c9;\n    /* 0x3CA */ u8 field_0x3ca;\n    /* 0x3CB */ u8 field_0x3cb;\n    /* 0x3CC */ u8 mCrowdSize;\n};  // Size = 0x3D0\n\ninline Z2SeMgr* Z2GetSeMgr() {\n    return JASGlobalInstance<Z2SeMgr>::getInstance();\n}\n\n// JAISoundID's for sound effects\nenum Z2SoundID {\n    Z2SE_SY_DUMMY = 0x0,\n    Z2SE_ENTER_GAME = 0x1,\n    Z2SE_QUIT_GAME = 0x2,\n    Z2SE_TITLE_ENTER = 0x3,\n    Z2SE_FILE_SELECT_CURSOR = 0x4,\n    Z2SE_FILE_SELECT_SUB = 0x5,\n    Z2SE_POINT_ON_ICON = 0x6,\n    Z2SE_NAVI_POINTER_MOVE = 0x7,\n    Z2SE_NAVI_FLY = 0x8,\n    Z2SE_NAVI_RETURN = 0x9,\n    Z2SE_FILE_SELECT_LEVEL = 0xA,\n    Z2SE_NO_SOUND = 0xB,\n    Z2SE_READ_RIDDLE_A = 0xC,\n    Z2SE_READ_RIDDLE_B = 0xD,\n    Z2SE_NAVI_CALLVOICE = 0xE,\n    Z2SE_NAVI_BLINK = 0xF,\n    Z2SE_NAVI_TALK_START = 0x10,\n    Z2SE_NAVI_TALK_END = 0x11,\n    Z2SE_OPTION_MENU_CURSOR = 0x12,\n    Z2SE_DPD_SCREEN_IN = 0x13,\n    Z2SE_DPD_SCREEN_OUT = 0x14,\n    Z2SE_HEART_PIECE_GET = 0x17,\n    Z2SE_CONSUMP_ITEM_GET = 0x18,\n    Z2SE_CONSUM_INC_CNT_1 = 0x1B,\n    Z2SE_CONSUM_INC_CNT_2 = 0x1C,\n    JA_SE_SYS_EV_TIMER_20 = 0x1D,\n    JA_SE_SYS_EV_TIMER_10 = 0x1E,\n    JA_SE_SYS_EV_TIMER_5 = 0x1F,\n    JA_SE_SYS_EV_TIMER_0 = 0x20,\n    Z2SE_HP_GAUGE_INC = 0x21,\n    Z2SE_MAGIC_METER_RECOVER = 0x22,\n    Z2SE_MAGIC_METER_DEC = 0x23,\n    Z2SE_MAGIC_METER_FINISH = 0x24,\n    Z2SE_OIL_METER_RECOVER = 0x25,\n    Z2SE_OIL_METER_LESS = 0x26,\n    Z2SE_OIL_METER_FINISH = 0x27,\n    Z2SE_SWIM_TIMER_ON = 0x28,\n    Z2SE_SWIM_TIMER_DEC = 0x29,\n    Z2SE_SWIM_TIMER_BLINK_1 = 0x2A,\n    Z2SE_SWIM_TIMER_BLINK_2 = 0x2B,\n    Z2SE_SWIM_TIMER_RECOVER = 0x2C,\n    Z2SE_DPD_CALIB_MODE = 0x2D,\n    Z2SE_DPD_CALIB_SET_A = 0x2E,\n    Z2SE_DPD_CALIB_SET_B = 0x2F,\n    Z2SE_DPD_CALIB_SET_C = 0x30,\n    Z2SE_DPD_CALIB_SET_D = 0x31,\n    Z2SE_DPD_CALIB_SET_E = 0x32,\n    Z2SE_FORCE_BACK = 0x33,\n    Z2SE_ALMOST_DIE_ALERM_1 = 0x34,\n    Z2SE_ALMOST_DIE_ALERM_2 = 0x35,\n    Z2SE_ALMOST_DIE_ALERM_3 = 0x36,\n    Z2SE_SUBJ_VIEW_IN = 0x37,\n    Z2SE_SUBJ_VIEW_OUT = 0x38,\n    Z2SE_KARI_EN_WING_S = 0x39,\n    Z2SE_KARI_EN_WING_M = 0x3A,\n    Z2SE_SYS_RESULT_WRONG = 0x3B,\n    Z2SE_ITEM_RING_IN = 0x3C,\n    Z2SE_ITEM_RING_OUT = 0x3D,\n    Z2SE_ITEM_RING_ROLL = 0x3E,\n    Z2SE_WHIP_HORSE = 0x3F,\n    Z2SE_WHIP_RECOVER = 0x40,\n    Z2SE_WHIP_RECOVER_ALL = 0x41,\n    Z2SE_WARP_MAP_CURSOR = 0x46,\n    Z2SE_WARP_MAP_ON = 0x47,\n    Z2SE_WARP_MAP_DECIDE = 0x48,\n    Z2SE_WARP_MAP_OFF = 0x49,\n    Z2SE_SYS_ERROR = 0x4A,\n    Z2SE_SY_COW_GET_IN = 0x4B,\n    Z2SE_SY_CURSOR_OPTION = 0x4C,\n    Z2SE_SY_CURSOR_ITEM = 0x4D,\n    Z2SE_SY_CURSOR_FLOOR = 0x4E,\n    Z2SE_SY_ITEM_SET_X = 0x4F,\n    Z2SE_SY_ITEM_SET_Y = 0x50,\n    Z2SE_SY_EXP_WIN_OPEN = 0x51,\n    Z2SE_SY_EXP_WIN_CLOSE = 0x52,\n    Z2SE_SY_HINT_BUTTON = 0x56,\n    Z2SE_SY_L_FOCUS_SET = 0x57,\n    Z2SE_SY_L_FOCUS_RESET = 0x58,\n    Z2SE_SY_CAMERA_L_MOVE = 0x59,\n    Z2SE_SY_CAMERA_L_CANCEL = 0x5A,\n    Z2SE_SY_MENU_IN = 0x5B,\n    Z2SE_SY_MENU_OUT = 0x5C,\n    Z2SE_SY_MENU_PAGE_CHANGE = 0x5D,\n    Z2SE_SY_TALK_START = 0x5E,\n    Z2SE_SY_TALK_NEXT = 0x5F,\n    Z2SE_SY_TALK_END = 0x60,\n    Z2SE_SY_TALK_WIN_OPEN = 0x61,\n    Z2SE_SY_TALK_WIN_CLOSE = 0x62,\n    Z2SE_SY_TALK_CURSOR = 0x63,\n    Z2SE_SY_TALK_CURSOR_OK = 0x64,\n    Z2SE_SY_DEMO_MESSAGE_NEXT = 0x65,\n    Z2SE_SY_DEMO_MESSAGE_END = 0x66,\n    Z2SE_SY_L_FOCUS_SET_SOFT = 0x67,\n    Z2SE_SY_BOOM_LOCK_ON_1 = 0x68,\n    Z2SE_SY_BOOM_LOCK_ON_2 = 0x69,\n    Z2SE_SY_BOOM_LOCK_ON_3 = 0x6A,\n    Z2SE_SY_BOOM_LOCK_ON_4 = 0x6B,\n    Z2SE_SY_BOOM_LOCK_ON_5 = 0x6C,\n    Z2SE_SY_CURSOR_OK = 0x6D,\n    Z2SE_SY_CURSOR_CANCEL = 0x6E,\n    Z2SE_SY_ITEM_USE_CANCEL = 0x6F,\n    Z2SE_GREEN_LUPY_GET = 0x70,\n    Z2SE_BLUE_LUPY_GET = 0x71,\n    Z2SE_RED_LUPY_GET = 0x72,\n    Z2SE_LUPY_INC_CNT_1 = 0x73,\n    Z2SE_LUPY_INC_CNT_2 = 0x74,\n    Z2SE_LUPY_DEC_CNT_1 = 0x75,\n    Z2SE_LUPY_DEC_CNT_2 = 0x76,\n    Z2SE_SY_HINT_BUTTON_BLINK = 0x77,\n    Z2SE_SY_SUMO_READY = 0x78,\n    Z2SE_SY_SUMO_START = 0x79,\n    Z2SE_SY_TEXT_DISP_ALL = 0x7A,\n    Z2SE_SY_TEXT_OUT = 0x7B,\n    Z2SE_SY_TEXT_OUT_FEMALE = 0x7C,\n    Z2SE_SY_TEXT_OUT_CHILD = 0x7D,\n    Z2SE_SY_TEXT_OUT_GORON = 0x7E,\n    Z2SE_SY_TEXT_OUT_ZORA = 0x7F,\n    Z2SE_SY_TEXT_OUT_GREY = 0x80,\n    Z2SE_SY_TEXT_OUT_SPIRIT = 0x81,\n    Z2SE_SY_TEXT_OUT_BRAVE = 0x82,\n    Z2SE_SY_TEXT_OUT_GANON = 0x83,\n    Z2SE_SY_TEXT_OUT_ZANT = 0x84,\n    Z2SE_SY_TEXT_OUT_YAMI = 0x85,\n    Z2SE_SY_WARP_FADE = 0x86,\n    Z2SE_SY_WARP_FADE_GW = 0x87,\n    Z2SE_SY_MG_TIMER_20 = 0x88,\n    Z2SE_SY_MG_TIMER_10 = 0x89,\n    Z2SE_SY_MG_TIMER_5 = 0x8A,\n    Z2SE_SY_MG_TIMEUP = 0x8B,\n    Z2SE_SY_MG_CANOE_SCORE = 0x8C,\n    Z2SE_SY_MG_KARGO_COMBO_01 = 0x8D,\n    Z2SE_SY_MG_KARGO_COMBO_02 = 0x8E,\n    Z2SE_SY_MG_KARGO_COMBO_03 = 0x8F,\n    Z2SE_SY_MG_KARGO_COMBO_04 = 0x90,\n    Z2SE_SY_MG_KARGO_COMBO_05 = 0x91,\n    Z2SE_SY_MG_KARGO_COMBO_06 = 0x92,\n    Z2SE_SY_MG_KARGO_COMBO_07 = 0x93,\n    Z2SE_SY_MG_KARGO_COMBO_08 = 0x94,\n    Z2SE_SY_MG_KARGO_COMBO_09 = 0x95,\n    Z2SE_SY_MG_KARGO_COMBO_10 = 0x96,\n    Z2SE_SY_MG_SEKI_BLACK_OUT = 0x97,\n    Z2SE_SY_MG_SEKI_WHITE_OUT = 0x98,\n    Z2SE_SY_MG_SEKI_FAILURE = 0x99,\n    Z2SE_SY_MG_CANOE_SCORE_2 = 0x9A,\n    Z2SE_SY_WARP_FADE_FAIRY = 0x9B,\n    Z2SE_D25_WHITE_OUT = 0x9C,\n    Z2SE_D28_SPACE_OUT = 0x9D,\n    Z2SE_D24_FLASHBACK = 0x9E,\n    Z2SE_SY_CONTINUE_OK = 0x9F,\n    Z2SE_SY_MENU_CURSOR_COMMON = 0xA0,\n    Z2SE_SY_MENU_NEXT = 0xA1,\n    Z2SE_SY_MENU_BACK = 0xA2,\n    Z2SE_SY_MENU_CHANGE_WINDOW = 0xA3,\n    Z2SE_SY_MENU_SUB_IN = 0xA4,\n    Z2SE_SY_MENU_SUB_OUT = 0xA5,\n    Z2SE_SY_MENU_SUB_NEXT = 0xA6,\n    Z2SE_SY_NEW_FILE = 0xA7,\n    Z2SE_SY_FILE_MENU_SLIDE_IN = 0xA8,\n    Z2SE_SY_FILE_COPY_LEVEL = 0xA9,\n    Z2SE_SY_FILE_COPY_OK = 0xAA,\n    Z2SE_SY_FILE_DELETE_LEVEL = 0xAB,\n    Z2SE_SY_FILE_DELETE_OK = 0xAC,\n    Z2SE_SY_FILE_SAVE_LEVEL = 0xAD,\n    Z2SE_SY_FILE_SAVE_OK = 0xAE,\n    Z2SE_SY_FILE_ERROR = 0xAF,\n    Z2SE_SY_NAME_CURSOR = 0xB0,\n    Z2SE_SY_NAME_INPUT = 0xB1,\n    Z2SE_SY_NAME_DELETE = 0xB2,\n    Z2SE_SY_NAME_OK = 0xB3,\n    Z2SE_SY_ITEM_SET_B = 0xB4,\n    Z2SE_SY_ITEM_COMBINE_ON = 0xB5,\n    Z2SE_SY_ITEM_COMBINE_OFF = 0xB6,\n    Z2SE_SY_ITEM_COMBINE_ICON = 0xB7,\n    Z2SE_SY_MAP_OPEN_S = 0xB8,\n    Z2SE_SY_MAP_CLOSE_S = 0xB9,\n    Z2SE_SY_MAP_OPEN_L = 0xBA,\n    Z2SE_SY_MAP_CLOSE_L = 0xBB,\n    Z2SE_SY_MAP_ZOOMIN = 0xBC,\n    Z2SE_SY_MAP_ZOOMOUT = 0xBD,\n    Z2SE_SY_MAP_SCROLL = 0xBE,\n    Z2SE_SY_MAP_DPD_HOLD_ON = 0xBF,\n    Z2SE_SY_MAP_DPD_HOLD_OFF = 0xC0,\n    Z2SE_SY_MAP_AREA_SELECT = 0xC1,\n    Z2SE_SY_LETTER_OPEN = 0xC2,\n    Z2SE_SY_LETTER_CLOSE = 0xC3,\n    Z2SE_SY_LETTER_NEXT_PAGE = 0xC4,\n    Z2SE_SY_LIGHT_POT_EQUIP = 0xC5,\n    Z2SE_SY_LIGHT_DROP_GET = 0xC6,\n    Z2SE_SY_LIGHT_DROP_COMPLETE = 0xC7,\n    Z2SE_SY_OPTION_SWITCH = 0xC8,\n    Z2SE_SY_SOUND_MODE_MONO = 0xC9,\n    Z2SE_SY_SOUND_MODE_STEREO = 0xCA,\n    Z2SE_SY_SOUND_MODE_SURROUND = 0xCB,\n    Z2SE_SY_DPD_CALIB_SW = 0xCC,\n    Z2SE_SY_SENSOR_BAR_WIDTH = 0xCD,\n    Z2SE_SY_MG_CANOE_SCORE_DW = 0xCE,\n    Z2SE_SY_HAWK_GET_KAGO = 0xCF,\n    Z2SE_AL_V_ATTACK_S = 0x10000,\n    Z2SE_AL_V_ATTACK_L = 0x10001,\n    Z2SE_AL_V_DAMAGE_S = 0x10002,\n    Z2SE_AL_V_DAMAGE_L = 0x10003,\n    Z2SE_AL_V_ATTACK_M = 0x10004,\n    Z2SE_AL_V_JUMP_S = 0x10005,\n    Z2SE_AL_V_JUMP_L = 0x10006,\n    Z2SE_AL_V_BACKTEN = 0x10007,\n    Z2SE_AL_V_ZENTEN_FAIL = 0x10008,\n    Z2SE_AL_V_ZENTEN_FAIL_2 = 0x10009,\n    Z2SE_AL_V_GRAB = 0x1000A,\n    Z2SE_AL_V_FOOT_MISS = 0x1000B,\n    Z2SE_AL_V_FALL = 0x1000C,\n    Z2SE_AL_V_LANDING_FAIL = 0x1000D,\n    Z2SE_AL_V_LANDING_FAIL_2 = 0x1000E,\n    Z2SE_AL_V_LIFTUP_S = 0x1000F,\n    Z2SE_AL_V_LIFTUP_L = 0x10010,\n    Z2SE_AL_V_THROW_S = 0x10011,\n    Z2SE_AL_V_THROW_L = 0x10012,\n    Z2SE_AL_V_PUSH_ROCK = 0x10013,\n    Z2SE_AL_V_TIRED_S = 0x10014,\n    Z2SE_AL_V_TIRED_L = 0x10015,\n    Z2SE_AL_V_DIE = 0x10016,\n    Z2SE_AL_V_DIE_SHORT = 0x10017,\n    Z2SE_AL_V_CLIMB = 0x10018,\n    Z2SE_AL_V_DRINK = 0x10019,\n    Z2SE_AL_V_DRINK_2 = 0x1001A,\n    Z2SE_AL_V_RUSH_HORSE = 0x1001B,\n    Z2SE_AL_V_ATTACK_RUN = 0x1001C,\n    Z2SE_AL_V_SWING_BOTTLE = 0x1001D,\n    Z2SE_AL_V_BITTEN_LOOP = 0x1001E,\n    Z2SE_AL_V_D04_WAKE_UP = 0x1001F,\n    Z2SE_AL_V_D04_NOTICE = 0x10020,\n    Z2SE_AL_V_D04_SURPRISE_A = 0x10021,\n    Z2SE_AL_V_D04_SURPRISE_B = 0x10022,\n    Z2SE_AL_V_D04_KIDNAPPED = 0x10023,\n    Z2SE_AL_V_D04_SURPRISE_C = 0x10024,\n    Z2SE_AL_V_GORONJUMP = 0x10025,\n    Z2SE_AL_V_DRINK_DAMAGE = 0x10026,\n    Z2SE_AL_V_SWING_IB = 0x10027,\n    Z2SE_AL_V_THROW_IB = 0x10028,\n    Z2SE_AL_V_FALL_MAGMA = 0x10029,\n    Z2SE_AL_V_FALL_QUICKSAND = 0x1002A,\n    Z2SE_AL_V_ATTACK_S_FREE = 0x1002B,\n    Z2SE_AL_V_ATTACK_M_FREE = 0x1002C,\n    Z2SE_AL_V_ATTACK_L_FREE = 0x1002D,\n    Z2SE_WL_V_BREATH_WAIT = 0x1002E,\n    Z2SE_WL_V_BREATH_TIRED = 0x1002F,\n    Z2SE_WL_V_BREATH_SIT = 0x10030,\n    Z2SE_WL_V_BREATH_WALK = 0x10031,\n    Z2SE_WL_V_BREATH_RUN = 0x10032,\n    Z2SE_WL_V_BREATH_JUMP = 0x10033,\n    Z2SE_WL_V_DAMAGE = 0x10034,\n    Z2SE_WL_V_HOWL = 0x10035,\n    Z2SE_WL_V_YAWN = 0x10036,\n    Z2SE_WL_V_ROAR = 0x10037,\n    Z2SE_WL_V_ATTACK_S = 0x10038,\n    Z2SE_WL_V_ATTACK_L = 0x10039,\n    Z2SE_WL_V_ATTACK_SPIN = 0x1003A,\n    Z2SE_WL_V_ATTACK_THRUST = 0x1003B,\n    Z2SE_WL_V_THREAT = 0x1003C,\n    Z2SE_WL_V_DASH = 0x1003D,\n    Z2SE_WL_V_SNIFF = 0x1003E,\n    Z2SE_WL_V_NOSE = 0x1003F,\n    Z2SE_WL_V_LAND_DAMAGE = 0x10040,\n    Z2SE_WL_V_FALL_TO_RESTART = 0x10041,\n    Z2SE_WL_V_RESTART = 0x10042,\n    Z2SE_WL_V_DIE = 0x10043,\n    Z2SE_WL_V_BITE_ATTACK = 0x10044,\n    Z2SE_WL_V_BITE_THROAT = 0x10045,\n    Z2SE_WL_V_HOLD_MOUTH = 0x10046,\n    Z2SE_WL_V_LOCK_JUMP = 0x10047,\n    Z2SE_AL_V_SUMO_HARITE_ATK = 0x10048,\n    Z2SE_AL_V_SUMO_HARITE_DMG = 0x10049,\n    Z2SE_AL_V_SUMO_TUCKLE_ATK = 0x1004A,\n    Z2SE_AL_V_SUMO_HOLDED = 0x1004B,\n    Z2SE_AL_V_SUMO_HOLD_BACK = 0x1004C,\n    Z2SE_AL_V_SUMO_PUSH = 0x1004D,\n    Z2SE_AL_V_SUMO_PUSH_LAST = 0x1004E,\n    Z2SE_AL_V_SUMO_FALL_LOSE = 0x1004F,\n    Z2SE_AL_V_UNDER_WATER = 0x10050,\n    Z2SE_AL_V_KAITEN = 0x10051,\n    Z2SE_AL_V_KAITEN_FREE = 0x10052,\n    Z2SE_AL_V_DAMAGE_FREEZE = 0x10053,\n    Z2SE_AL_V_DAMAGE_ELEC = 0x10054,\n    Z2SE_AL_V_DAMAGE_COMIC = 0x10055,\n    Z2SE_AL_V_BACKTEN_FREE = 0x10056,\n    Z2SE_AL_V_JUMP_HANG = 0x10057,\n    Z2SE_AL_V_CLIMB_WALL = 0x10058,\n    Z2SE_AL_V_THROW_GORON = 0x10059,\n    Z2SE_AL_V_PULL_CHAIN_FM = 0x1005A,\n    Z2SE_AL_V_DIVING = 0x1005B,\n    Z2SE_AL_V_MAGNET_CAUGHT = 0x1005C,\n    Z2SE_AL_V_RELAX_A = 0x1005D,\n    Z2SE_AL_V_RELAX_B = 0x1005E,\n    Z2SE_AL_V_RELAX_C = 0x1005F,\n    Z2SE_AL_V_TAMING = 0x10060,\n    Z2SE_AL_V_SUMO_SHIKO = 0x10061,\n    Z2SE_AL_V_SUMO_PUSHED_BACK = 0x10062,\n    Z2SE_AL_V_ATTACK_RUN_FREE = 0x10063,\n    Z2SE_AL_V_D02_LOOKBACK = 0x10064,\n    Z2SE_AL_V_D02_WRY_FACE = 0x10065,\n    Z2SE_AL_V_D04_NOD_SMILE = 0x10066,\n    Z2SE_AL_V_D04_LOOKBACK = 0x10067,\n    Z2SE_AL_V_D04_SURPRISE_D = 0x10068,\n    Z2SE_AL_V_D04_ATTACKED = 0x10069,\n    Z2SE_AL_V_D04_SURPRISE_E = 0x1006A,\n    Z2SE_AL_V_D04_DASH = 0x1006B,\n    Z2SE_AL_V_D04_SUFFER_A = 0x1006C,\n    Z2SE_AL_V_D04_SUFFER_B = 0x1006D,\n    Z2SE_AL_V_D04_SUFFER_C = 0x1006E,\n    Z2SE_AL_V_D04_FALL_DOWN_A = 0x1006F,\n    Z2SE_AL_V_D04_FALL_DOWN_B = 0x10070,\n    Z2SE_AL_V_D04_TRANSFORM = 0x10071,\n    Z2SE_AL_V_D11_SURPRISE = 0x10072,\n    Z2SE_AL_V_D15_RUSH_HORSE = 0x10073,\n    Z2SE_AL_V_D15_SURPRISE = 0x10074,\n    Z2SE_AL_V_D15_ANGER = 0x10075,\n    Z2SE_AL_V_D36_SWAY_JUMP = 0x10076,\n    Z2SE_AL_V_D36_SWAY_LAND = 0x10077,\n    Z2SE_AL_V_D36_JUMP_TO_HORSE = 0x10078,\n    Z2SE_AL_V_D36_LOOSE_BALANCE = 0x10079,\n    Z2SE_AL_V_D36_HANG_HORSE = 0x1007A,\n    Z2SE_AL_V_D36_LOOK_BACK = 0x1007B,\n    Z2SE_AL_V_D16_SMILE = 0x1007C,\n    Z2SE_AL_V_D17_LOOK_BACK = 0x1007D,\n    Z2SE_AL_V_D17_NOD = 0x1007E,\n    Z2SE_AL_V_D18_SMILING = 0x1007F,\n    Z2SE_AL_V_D18_SHUDDER = 0x10080,\n    Z2SE_AL_V_D18_DARK_LAUGH = 0x10081,\n    Z2SE_AL_V_D18_SCREAM = 0x10082,\n    Z2SE_AL_V_D18_AWAKE = 0x10083,\n    Z2SE_AL_V_D19_HIT_SHOULDER = 0x10084,\n    Z2SE_AL_V_D19_WORRIED = 0x10085,\n    Z2SE_AL_V_D19_NOTICE = 0x10086,\n    Z2SE_AL_V_D19_CANT_SAY = 0x10087,\n    Z2SE_AL_V_D35_LOOK_BACK = 0x10088,\n    Z2SE_AL_V_D20_SURPRISE = 0x10089,\n    Z2SE_AL_V_D20_UPSET = 0x1008A,\n    Z2SE_AL_V_D20_DAMAGE = 0x1008B,\n    Z2SE_AL_V_D22_PULLOUT = 0x1008C,\n    Z2SE_AL_V_D22_TAKE_A_REST = 0x1008D,\n    Z2SE_AL_V_CANON_JUMP = 0x1008E,\n    Z2SE_AL_V_JUMP_DIVING = 0x1008F,\n    Z2SE_AL_V_INSECT_LOOP = 0x10090,\n    Z2SE_AL_V_GUARD_BROKEN = 0x10091,\n    Z2SE_AL_V_TAME = 0x10092,\n    Z2SE_AL_V_TATE_OSHI = 0x10093,\n    Z2SE_AL_V_TODOME_JUMP = 0x10094,\n    Z2SE_AL_V_TODOME_RETURN = 0x10095,\n    Z2SE_AL_V_SOTOMO_ROLL = 0x10096,\n    Z2SE_AL_V_SOTOMO_ATK = 0x10097,\n    Z2SE_AL_V_KABUTO_JUMP = 0x10098,\n    Z2SE_AL_V_KABUTO_ATK = 0x10099,\n    Z2SE_AL_V_IAIGIRI = 0x1009A,\n    Z2SE_AL_V_JUMP_ATTACK_L_1 = 0x1009B,\n    Z2SE_AL_V_JUMP_ATTACK_L_2 = 0x1009C,\n    Z2SE_AL_V_KAITENGIRI_L = 0x1009D,\n    Z2SE_AL_V_OUGI_KAMAE = 0x1009E,\n    Z2SE_AL_V_ENTRANCE = 0x1009F,\n    Z2SE_AL_V_APPEARANCE = 0x100A0,\n    Z2SE_AL_V_TW_PULL = 0x100A1,\n    Z2SE_AL_V_D_MHOP = 0x100A2,\n    Z2SE_AL_V_MSTR_SW_STICK = 0x100A3,\n    Z2SE_AL_V_MSTR_SW_PULLOUT = 0x100A4,\n    Z2SE_AL_V_GET_SWL = 0x100A5,\n    Z2SE_AL_V_D_ODOROKU = 0x100A6,\n    Z2SE_AL_V_D_ASHIMOTO = 0x100A7,\n    Z2SE_AL_V_D_UNAZUKU = 0x100A8,\n    Z2SE_AL_V_TERRORED = 0x100A9,\n    Z2SE_WL_V_TERRORED = 0x100AA,\n    Z2SE_AL_V_DAMAGE_ON_HORSE = 0x100AB,\n    Z2SE_AL_V_CLING_HORSE = 0x100AC,\n    Z2SE_AL_V_TRANSFORM = 0x100AD,\n    Z2SE_WL_V_CATCHED = 0x100AE,\n    Z2SE_WL_V_CATCHED_LOOP = 0x100AF,\n    Z2SE_WL_V_SLIP_ROLL = 0x100B0,\n    Z2SE_WL_V_SLIP_CLIMB = 0x100B1,\n    Z2SE_WL_V_DIE_WATER = 0x100B2,\n    Z2SE_WL_V_FALL_MAGMA = 0x100B3,\n    Z2SE_WL_V_FALL_QUICKSAND = 0x100B4,\n    Z2SE_WL_V_PUSH_ROCK = 0x100B5,\n    Z2SE_WL_V_TURN_BACK = 0x100B6,\n    Z2SE_WL_V_HOLD_THROW = 0x100B7,\n    Z2SE_WL_V_BITE_HANG = 0x100B8,\n    Z2SE_WL_V_FAILED = 0x100B9,\n    Z2SE_WL_V_FOOTMISS = 0x100BA,\n    Z2SE_WL_V_ENTRANCE = 0x100BB,\n    Z2SE_WL_V_MD_SHOCK = 0x100BC,\n    Z2SE_WL_V_TW_PULL = 0x100BD,\n    Z2SE_WL_V_ATTACK_POU_ST = 0x100BE,\n    Z2SE_WL_V_ATTACK_POU_BITE = 0x100BF,\n    Z2SE_WL_V_DAMAGE_ELEC = 0x100C0,\n    Z2SE_WL_V_DAMAGE_FREEZE = 0x100C1,\n    Z2SE_AL_V_VS_GND_TUBA_A = 0x100C2,\n    Z2SE_AL_V_VS_GND_TUBA_B = 0x100C3,\n    Z2SE_AL_V_VS_GND_TUBA_C = 0x100C4,\n    Z2SE_AL_V_VS_GND_TUBA_WIN = 0x100C5,\n    Z2SE_AL_V_VS_GND_TUBA_LOSE = 0x100C6,\n    Z2SE_WL_V_TITLE_HOWL = 0x100C7,\n    Z2SE_AL_SWORD_PULLOUT = 0x20000,\n    Z2SE_AL_SWORD_PUTIN = 0x20001,\n    Z2SE_AL_SWORD_SWING_S = 0x20002,\n    Z2SE_AL_SWORD_SWING_L = 0x20003,\n    Z2SE_AL_SWORD_THRUST = 0x20004,\n    Z2SE_AL_KAITENGIRI = 0x20005,\n    Z2SE_AL_FINISH_SWING1 = 0x20006,\n    Z2SE_AL_FINISH_SWING2 = 0x20007,\n    Z2SE_AL_FINISH_PUTIN = 0x20008,\n    Z2SE_WOLFATTACK_WIND_S = 0x20009,\n    Z2SE_WOLFATTACK_WIND_L = 0x2000A,\n    Z2SE_WOLF_DIG_HOLE = 0x2000B,\n    Z2SE_WOLF_WIPE_OFF_WATER = 0x2000C,\n    Z2SE_WOLFATTACK_WIND_TAIL = 0x2000D,\n    Z2SE_WOLFATTACK_WIND_SCREW = 0x2000E,\n    Z2SE_WOLF_SWALLOW = 0x2000F,\n    Z2SE_AL_KICK_HORSE = 0x20010,\n    Z2SE_BOOM_TORNADO = 0x20011,\n    Z2SE_AL_SET_CHAIN = 0x20012,\n    Z2SE_AL_GRAB_CHAIN = 0x20013,\n    Z2SE_AL_DAMAGE_NORMAL = 0x20014,\n    Z2SE_AL_DAMAGE_LARGE = 0x20015,\n    Z2SE_AL_BODYATTACK = 0x20016,\n    Z2SE_WOLFATTACK_WIND_RUSH = 0x20017,\n    Z2SE_WARP_DOME_OPEN = 0x20018,\n    Z2SE_WARP_DOME_SUSTAIN = 0x20019,\n    Z2SE_BOOM_POWER_RESUME = 0x2001A,\n    Z2SE_BOOM_POWER_FULL = 0x2001B,\n    Z2SE_MIDNA_BIND_AREA_OPEN = 0x2001C,\n    Z2SE_MIDNA_BIND_AREA_SUS = 0x2001D,\n    Z2SE_PLAY_REED_TOBIKUSA = 0x2001E,\n    Z2SE_TOBIKUSA_ECHO = 0x2001F,\n    Z2SE_AL_SWING_BOTTLE = 0x20020,\n    Z2SE_AL_PADDLING_FORWARD = 0x20021,\n    Z2SE_AL_PADDLING_BACKWARD = 0x20022,\n    Z2SE_PLAY_REED_UMAKUSA = 0x20023,\n    Z2SE_UMAKUSA_ECHO = 0x20024,\n    Z2SE_SWORD_POWER_COME = 0x20025,\n    Z2SE_AL_SWORD_SHIELD_ADD = 0x20026,\n    Z2SE_AL_HARNESS_ADD_HS = 0x20027,\n    Z2SE_AL_HARNESS_ADD_WB = 0x20028,\n    Z2SE_AL_KANTERA_SWING_ADD = 0x20029,\n    Z2SE_AL_MAGNETIZED = 0x2002A,\n    JA_SE_LK_CUT_GRASS = 0x2002B,\n    JA_SE_FT_ADD_GRASS = 0x2002C,\n    Z2SE_AL_ITEM_TAKEOUT = 0x2002D,\n    JA_SE_LK_BOOM_FLY = 0x2002E,\n    JA_SE_LK_BOOM_CATCH = 0x2002F,\n    JA_SE_LK_FALL_DAMAGE = 0x20030,\n    Z2SE_AL_IB_SWING = 0x20031,\n    Z2SE_AL_IB_THROW = 0x20032,\n    Z2SE_AL_IB_PULLBACK = 0x20033,\n    Z2SE_AL_IB_CATCH = 0x20034,\n    Z2SE_AL_IB_CHAIN_ADD = 0x20035,\n    Z2SE_AL_HS_HANGING_UP = 0x20036,\n    Z2SE_AL_HS_HANGING_DOWN = 0x20037,\n    JA_SE_LK_MOVE_ROCK = 0x20038,\n    JA_SE_LK_MOVE_ROCK_LIMIT = 0x20039,\n    JA_SE_LK_MOVE_WBLOCK = 0x2003A,\n    JA_SE_LK_MOVE_WBLOCK_LIMIT = 0x2003B,\n    Z2SE_AL_ARROW_EMPTY = 0x2003C,\n    JA_SE_LK_W_WEP_CRT_HIT = 0x2003D,\n    JA_SE_LK_MS_WEP_CRT_HIT = 0x2003E,\n    Z2SE_AL_WALK_IN_WATER = 0x2003F,\n    Z2SE_AL_WALK_OUT_WATER = 0x20040,\n    Z2SE_AL_BURNING = 0x20041,\n    Z2SE_AL_DRAW_BOW = 0x20042,\n    Z2SE_AL_HS_OPEN = 0x20043,\n    Z2SE_WOLF_POWER_COME = 0x20044,\n    Z2SE_LK_BOTTLE_CLOSE = 0x20045,\n    Z2SE_LK_BOTTLE_OPEN = 0x20046,\n    Z2SE_AL_BURN_START = 0x20047,\n    Z2SE_LK_HS_SHOOT = 0x20048,\n    Z2SE_LK_HS_CHAIN = 0x20049,\n    Z2SE_LK_HS_WIND_UP = 0x2004A,\n    Z2SE_LK_HS_WIND_UP_FIN = 0x2004B,\n    Z2SE_AL_FREEZE = 0x2004C,\n    Z2SE_LK_SCOOP_WATER = 0x2004D,\n    Z2SE_LK_SPRINKLE_WATER = 0x2004E,\n    Z2SE_AL_OPEN_LETTER = 0x2004F,\n    Z2SE_WOLF_SENSE_OPEN_START = 0x20050,\n    Z2SE_WOLF_SENSE_OPEN = 0x20051,\n    Z2SE_WOLF_DIG_HOLE_THROUGH = 0x20052,\n    Z2SE_WOLF_WIPE_OFF_DUST = 0x20053,\n    Z2SE_WOLF_BODYATTACK = 0x20054,\n    Z2SE_AL_FREEZE_RECOVER = 0x20055,\n    Z2SE_AL_PICKUP_GRASS = 0x20056,\n    Z2SE_AL_ITEM_TAKEOUT_FAST = 0x20057,\n    Z2SE_AL_KANTERA_BURNING = 0x20058,\n    Z2SE_AL_KANTERA_SWING = 0x20059,\n    Z2SE_AL_KANTERA_OFF = 0x2005A,\n    Z2SE_AL_GORON_JUMP_START = 0x2005B,\n    Z2SE_AL_GORON_JUMP_ROLLING = 0x2005C,\n    Z2SE_AL_KANTERA_OFF_SWING = 0x2005D,\n    Z2SE_AL_CHANGE_BOOTS = 0x2005E,\n    Z2SE_AL_STROKE_GOAT_A = 0x2005F,\n    Z2SE_AL_STROKE_GOAT_B = 0x20060,\n    Z2SE_AL_DAMAGE_SMALL = 0x20061,\n    Z2SE_AL_UNDERWATER_BUBBLE = 0x20062,\n    Z2SE_AL_WATER_STROKE_S = 0x20063,\n    Z2SE_AL_WATER_STROKE_L = 0x20064,\n    Z2SE_AL_WATER_STROKE_FAST = 0x20065,\n    Z2SE_AL_WATER_STROKE_CIRCLE = 0x20066,\n    Z2SE_AL_COPYROD_THROW = 0x20067,\n    Z2SE_AL_COPYROD_RETURN = 0x20068,\n    Z2SE_AL_COPYROD_CATCH = 0x20069,\n    Z2SE_AL_COPYROD_SWING = 0x2006A,\n    Z2SE_AL_COPYROD_READY = 0x2006B,\n    Z2SE_AL_SPINNER_RIDE = 0x2006C,\n    Z2SE_AL_SPINNER_EXTEND = 0x2006D,\n    Z2SE_AL_SPINNER_RAIL = 0x2006E,\n    Z2SE_AL_SINK_MAGMA = 0x2006F,\n    Z2SE_AL_SINK_SAND_LEVEL = 0x20070,\n    Z2SE_AL_SINK_SAND_OUT = 0x20071,\n    Z2SE_AL_SINK_SAND_PITFALL = 0x20072,\n    Z2SE_AL_SINK_SNOW_LEVEL = 0x20073,\n    Z2SE_AL_SINK_SNOW_OUT = 0x20074,\n    Z2SE_AL_SINK_SNOW_PITFALL = 0x20075,\n    Z2SE_AL_SPINNER_START = 0x20076,\n    Z2SE_AL_SPINNER_END = 0x20077,\n    Z2SE_AL_ROD_SWING_LURE = 0x20078,\n    Z2SE_AL_ROD_SWING_UKI = 0x20079,\n    Z2SE_AL_ROD_CASTING_LOOP = 0x2007A,\n    Z2SE_AL_ROD_ROLLBACK_SLOW = 0x2007B,\n    Z2SE_AL_ROD_ROLLBACK_FAST = 0x2007C,\n    Z2SE_AL_REEL_SLOW_LOOP = 0x2007D,\n    Z2SE_AL_REEL_FAST_LOOP = 0x2007E,\n    Z2SE_AL_ROD_BEND = 0x2007F,\n    Z2SE_AL_FISHING_HIT = 0x20080,\n    Z2SE_AL_LURE_IN_WATER = 0x20081,\n    Z2SE_AL_UKI_IN_WATER = 0x20082,\n    Z2SE_AL_FISH_JUMP_UP = 0x20083,\n    Z2SE_AL_FISH_JUMP_DOWN = 0x20084,\n    Z2SE_AL_FISH_CATCH = 0x20085,\n    Z2SE_AL_FISH_RELEASE = 0x20086,\n    Z2SE_AL_FISH_JUMP_UP_S = 0x20087,\n    Z2SE_AL_REEL_CRATCH_OFF = 0x20088,\n    Z2SE_AL_UKI_OUT_WATER = 0x20089,\n    Z2SE_AL_ROD_TAKEOUT = 0x2008A,\n    Z2SE_AL_LURE_BOUND = 0x2008B,\n    Z2SE_AL_FISHING_BOOTS_GET = 0x2008C,\n    Z2SE_AL_REEL_ROLL_THROW = 0x2008D,\n    Z2SE_AL_COPYROD_WAIT = 0x2008E,\n    Z2SE_AL_COPYROD_READY_OFF = 0x2008F,\n    Z2SE_AL_D04_HEARTBEAT = 0x20090,\n    Z2SE_AL_SNOBO_RIDE = 0x20091,\n    Z2SE_AL_SNOBO_BREAK = 0x20092,\n    Z2SE_AL_SNOBO_JUMP = 0x20093,\n    Z2SE_AL_SNOBO_LAND = 0x20094,\n    Z2SE_WOLF_SENSE_CLOSE = 0x20095,\n    Z2SE_AL_WARP_IN_TATE = 0x20096,\n    Z2SE_AL_WARP_IN_YOKO = 0x20097,\n    Z2SE_AL_WARP_OUT = 0x20098,\n    Z2SE_WOLF_WARP_IN_TATE = 0x20099,\n    Z2SE_WOLF_WARP_IN_YOKO = 0x2009A,\n    Z2SE_WOLF_WARP_OUT = 0x2009B,\n    Z2SE_AL_SHOE_PKPK = 0x2009C,\n    Z2SE_AL_TORIDASU = 0x2009D,\n    Z2SE_AL_CANOE_COL = 0x2009E,\n    Z2SE_AL_CANOE_FALL_DW = 0x2009F,\n    Z2SE_AL_CANOE_FALL_WET = 0x200A0,\n    Z2SE_AL_LV3_FALL_WET = 0x200A1,\n    Z2SE_AL_SWM_STICK = 0x200A2,\n    Z2SE_AL_SWM_PULL = 0x200A3,\n    Z2SE_AL_COPYROD_COMEBACK = 0x200A4,\n    Z2SE_AL_WAIT_SWORD_SWING = 0x200A5,\n    Z2SE_AL_PULL_CHAIN = 0x200A6,\n    Z2SE_AL_PULL_CHAIN_STOP = 0x200A7,\n    Z2SE_AL_TRANSFORM_A_TO_W = 0x200A8,\n    Z2SE_AL_TRANSFORM_W_TO_A = 0x200A9,\n    Z2SE_AL_SCOOP_OIL = 0x200AA,\n    Z2SE_AL_SCOOP_SOUP = 0x200AB,\n    Z2SE_AL_ELEC_DAMAGE = 0x200AC,\n    Z2SE_AL_WOOD_SHIELD_BURN = 0x200AD,\n    Z2SE_AL_IN_WATER_FALL = 0x200AE,\n    Z2SE_AL_PACHINKO_DRAW = 0x200AF,\n    Z2SE_AL_PACHINKO_SHOT = 0x200B0,\n    Z2SE_AL_JUMP_DIVE_WATER = 0x200B1,\n    Z2SE_AL_SWORD_COLLIDE = 0x200B2,\n    Z2SE_AL_JUMP_ATK_L_IMPACT = 0x200B3,\n    Z2SE_AL_KAITEN_L_SLASH = 0x200B4,\n    Z2SE_AL_HAWK_EYE_PUTON = 0x200B5,\n    Z2SE_AL_HAWK_EYE_PUTOFF = 0x200B6,\n    Z2SE_AL_HAWK_EYE_PAN = 0x200B7,\n    Z2SE_AL_HAWK_EYE_ZOOMIN = 0x200B8,\n    Z2SE_AL_HAWK_EYE_ZOOMOUT = 0x200B9,\n    Z2SE_AL_SNOBO_ICEBREAK = 0x200BA,\n    Z2SE_AL_ICE_SLIP = 0x200BB,\n    Z2SE_AL_LIGHTNING_SW_GET = 0x200BC,\n    Z2SE_AL_LIGHTNING_SW_GLOW = 0x200BD,\n    Z2SE_AL_M_ARMER_RECOVER = 0x200BE,\n    Z2SE_AL_LTN_SWORD_SWING_S = 0x200BF,\n    Z2SE_AL_LTN_SWORD_SWING_L = 0x200C0,\n    Z2SE_AL_LTN_SWORD_THRUST = 0x200C1,\n    Z2SE_AL_LTN_KAITENGIRI = 0x200C2,\n    Z2SE_AL_LTN_FINISH_SWING1 = 0x200C3,\n    Z2SE_AL_LTN_FINISH_SWING2 = 0x200C4,\n    Z2SE_AL_LTN_SW_WAIT_SWING = 0x200C5,\n    Z2SE_AL_UKI_KURUKURU_LOOP = 0x200C6,\n    Z2SE_AL_UKI_POKOPOKO = 0x200C7,\n    Z2SE_AL_DOJOU_EAT_IMPACT = 0x200C8,\n    Z2SE_D22_WLF_LIGHT = 0x200C9,\n    Z2SE_D22_WLF_BRK = 0x200CA,\n    Z2SE_D22_AL_PULL_OUT = 0x200CB,\n    Z2SE_D04_AL_TF_BRIGHT = 0x200CC,\n    Z2SE_D04_AL_TF_BRIGHT_2 = 0x200CE,\n    Z2SE_D04_WLF_TF_OFF = 0x200D0,\n    Z2SE_D04_WLF_CHAIN = 0x200D1,\n    Z2SE_D06_WLF_BITE_CHAIN = 0x200D2,\n    Z2SE_D06_WLF_CHAIN_LAND = 0x200D3,\n    Z2SE_D06_WLF_SWING_BD = 0x200D4,\n    Z2SE_BOOM_GET_DEMO_LOOP1 = 0x200D5,\n    Z2SE_BOOM_GET_DEMO_LOOP2 = 0x200D6,\n    Z2SE_AL_M_ARMER_TURNOFF = 0x200D7,\n    Z2SE_AL_LURE_BOUND_WOOD = 0x200D8,\n    Z2SE_AL_BACKTEN_WIND = 0x200D9,\n    Z2SE_FN_WALK_DUMMY = 0x30000,\n    Z2SE_FN_JUMP_DUMMY = 0x30001,\n    Z2SE_FN_BOUND_DUMMY = 0x30002,\n    Z2SE_FN_HAND_DUMMY = 0x30003,\n    Z2SE_FN_WALK_HEAVY = 0x30004,\n    Z2SE_FN_JUMP_HEAVY = 0x30005,\n    Z2SE_FN_LADDER_CLIMB = 0x30006,\n    Z2SE_FN_LADDER_DOWN = 0x30007,\n    Z2SE_WL_WALK_L_DUMMY = 0x30008,\n    Z2SE_WL_WALK_R_DUMMY = 0x30009,\n    Z2SE_WL_RUN_L_DUMMY = 0x3000A,\n    Z2SE_WL_RUN_R_DUMMY = 0x3000B,\n    Z2SE_FN_WALL_CLIMB = 0x3000C,\n    Z2SE_FN_LINK_CRAWL = 0x3000D,\n    Z2SE_FN_ROPE_CREAK = 0x3000E,\n    Z2SE_FN_CHAIN_CREAK = 0x3000F,\n    Z2SE_HS_WALK_L_DUMMY = 0x30010,\n    Z2SE_HS_WALK_R_DUMMY = 0x30011,\n    Z2SE_HS_TROT_L_DUMMY = 0x30012,\n    Z2SE_HS_TROT_R_DUMMY = 0x30013,\n    Z2SE_HS_GALLOP_L_DUMMY = 0x30014,\n    Z2SE_HS_GALLOP_R_DUMMY = 0x30015,\n    Z2SE_FT_HORSE_PEDAL = 0x30016,\n    Z2SE_FN_LINK_SLIP = 0x30017,\n    Z2SE_FN_WOLF_SLIP = 0x30018,\n    Z2SE_FN_HORSE_SLIP = 0x30019,\n    Z2SE_BODY_FALL_DOWN = 0x3001A,\n    Z2SE_AL_SWIM = 0x3001B,\n    Z2SE_AL_INTO_WATER = 0x3001C,\n    Z2SE_AL_OUTOF_WATER = 0x3001D,\n    Z2SE_AL_DIVE_INTO_WATER = 0x3001E,\n    Z2SE_AL_DIVE_SWIM = 0x3001F,\n    Z2SE_AL_SWIM_UNDERWATER = 0x30020,\n    Z2SE_WL_SWIM = 0x30021,\n    Z2SE_WL_INTO_WATER = 0x30022,\n    Z2SE_WL_OUTOF_WATER = 0x30023,\n    Z2SE_WL_DIG_GROUND = 0x30024,\n    Z2SE_WB_FRONT_L_DUMMY = 0x30025,\n    Z2SE_WB_FRONT_R_DUMMY = 0x30026,\n    Z2SE_WB_REAR_L_DUMMY = 0x30027,\n    Z2SE_WB_REAR_R_DUMMY = 0x30028,\n    Z2SE_EN_WB_L_SLIP = 0x30029,\n    Z2SE_EN_WB_KICK_GROUND = 0x3002A,\n    Z2SE_BB_FRONT_L = 0x3002B,\n    Z2SE_BB_FRONT_R = 0x3002C,\n    Z2SE_BB_REAR_L = 0x3002D,\n    Z2SE_BB_REAR_R = 0x3002E,\n    Z2SE_EN_BB_KICK_GROUND = 0x3002F,\n    Z2SE_EN_BB_FN_WALK_L = 0x30030,\n    Z2SE_EN_BB_FN_WALK_R = 0x30031,\n    Z2SE_RIDER_FOOTNOTE = 0x30032,\n    Z2SE_RIDER_FOOTNOTE_WATER = 0x30033,\n    Z2SE_GOAT_WALK_L_GROUND = 0x30034,\n    Z2SE_GOAT_WALK_R_GROUND = 0x30035,\n    Z2SE_GOAT_RUN_L_GROUND = 0x30036,\n    Z2SE_GOAT_RUN_R_GROUND = 0x30037,\n    Z2SE_GORON_FOOTNOTE = 0x30038,\n    Z2SE_STALFOS_FOOTNOTE = 0x30039,\n    Z2SE_STALHOUND_FOOTNOTE = 0x3003A,\n    Z2SE_BABYSTAL_FOOTNOTE = 0x3003B,\n    Z2SE_FN_GOB_WALK = 0x3003C,\n    Z2SE_FN_GOB_STEP = 0x3003D,\n    Z2SE_FN_GOB_JUMP = 0x3003E,\n    Z2SE_FN_ROPE_CREAK_ADD = 0x3003F,\n    Z2SE_FN_SANDAL_WALK_L = 0x30040,\n    Z2SE_FN_SANDAL_WALK_R = 0x30041,\n    Z2SE_FN_SANDAL_JUMP = 0x30042,\n    Z2SE_FN_SANDAL_WALK_ADULT_L = 0x30043,\n    Z2SE_FN_SANDAL_WALK_ADULT_R = 0x30044,\n    Z2SE_FN_KICK_STONE = 0x30045,\n    Z2SE_FN_NPC_CHILD_WALK_L = 0x30046,\n    Z2SE_FN_NPC_CHILD_WALK_R = 0x30047,\n    Z2SE_FN_NPC_CHILD_JUMP = 0x30048,\n    Z2SE_FN_NPC_ADULT_WALK_L = 0x30049,\n    Z2SE_FN_NPC_ADULT_WALK_R = 0x3004A,\n    Z2SE_FN_ARMER_LIGHT_ADD = 0x3004B,\n    Z2SE_FN_ARMER_HEAVY_ADD = 0x3004C,\n    Z2SE_FN_SEKIZOU_L = 0x3004D,\n    Z2SE_FN_SEKIZOU_R = 0x3004E,\n    Z2SE_FN_ZORA_L = 0x3004F,\n    Z2SE_FN_ZORA_R = 0x30050,\n    Z2SE_AL_SWIM_DASH = 0x30051,\n    Z2SE_WL_SWIM_DASH = 0x30052,\n    Z2SE_KN_FOOTNOTE_A = 0x30053,\n    Z2SE_KN_FOOTNOTE_B = 0x30054,\n    Z2SE_D15_ECHO_SANDAL_L = 0x30055,\n    Z2SE_D15_ECHO_SANDAL_R = 0x30056,\n    Z2SE_D15_WB_FOOT_FRONT_L = 0x30057,\n    Z2SE_D15_WB_FOOT_FRONT_R = 0x30058,\n    Z2SE_D15_WB_FOOT_REAR_L = 0x30059,\n    Z2SE_D15_WB_FOOT_REAR_R = 0x3005A,\n    Z2SE_HIT_SWORD = 0x40000,\n    Z2SE_HIT_SWORD_STAB = 0x40001,\n    Z2SE_HIT_SHIELD_ATTACK = 0x40002,\n    Z2SE_HIT_WOLFBITE = 0x40003,\n    Z2SE_HIT_WOLFKICK = 0x40004,\n    Z2SE_HIT_WOOD_WEAPON = 0x40005,\n    Z2SE_HIT_HAMMER = 0x40006,\n    Z2SE_HIT_ARROW_STICK = 0x40007,\n    Z2SE_HIT_ARROW_REBOUND = 0x40008,\n    Z2SE_HIT_HOOKSHOT_STICK = 0x40009,\n    Z2SE_HIT_HOOKSHOT_REBOUND = 0x4000A,\n    Z2SE_HIT_METAL_WEAPON = 0x4000B,\n    Z2SE_HIT_STONE_WEAPON = 0x4000C,\n    Z2SE_HIT_HARD_BODY = 0x4000D,\n    Z2SE_HIT_SOFT_BODY = 0x4000E,\n    Z2SE_HIT_DUMMY_CANCEL = 0x4000F,\n    Z2SE_HIT_SWORD_RUN = 0x40010,\n    Z2SE_HIT_EN_WOOD_WEAPON = 0x40011,\n    Z2SE_HIT_THOROW_OBJ = 0x40012,\n    Z2SE_HIT_SPINNER = 0x40013,\n    Z2SE_HIT_COPYROD = 0x40014,\n    Z2SE_HIT_STATUE_HAMMER = 0x40015,\n    Z2SE_HIT_AL_ARROW_STICK = 0x40016,\n    Z2SE_HIT_AL_ARROW_REBOUND = 0x40017,\n    Z2SE_HIT_PACHINKO = 0x40018,\n    Z2SE_SWORD_STICK_PULLOUT = 0x40019,\n    Z2SE_COL_FLIP_ARROW = 0x4001A,\n    Z2SE_COL_FLIP_BOOM = 0x4001B,\n    Z2SE_HIT_ROPE_CUT = 0x4001C,\n    Z2SE_HIT_ROPE_REBOUND = 0x4001D,\n    Z2SE_HIT_CHAIN_REBOUND = 0x4001E,\n    JA_SE_OBJ_BREAK_WOOD_S = 0x4001F,\n    JA_SE_OBJ_BREAK_WOOD_L = 0x40020,\n    JA_SE_OBJ_BREAK_CHINA_S = 0x40021,\n    JA_SE_OBJ_BREAK_CHINA_L = 0x40022,\n    JA_SE_OBJ_BREAK_WRAILING = 0x40023,\n    JA_SE_OBJ_HIT_SHOCK_SWITCH = 0x40024,\n    Z2SE_HS_V_CRY = 0x50000,\n    Z2SE_HS_V_BURURU = 0x50001,\n    Z2SE_CAT_CRY_FAMILIER = 0x50002,\n    Z2SE_CAT_CRY_ANNOY = 0x50003,\n    Z2SE_CAT_CRY_CARRY = 0x50004,\n    Z2SE_CAT_CRY_ATTACK = 0x50005,\n    Z2SE_CHICKEN_WALK = 0x50006,\n    Z2SE_CHICKEN_CRY = 0x50007,\n    Z2SE_CAT_CRY_ANNOY_D = 0x50008,\n    Z2SE_CAT_CRY_ATTACK_D = 0x50009,\n    Z2SE_HS_V_ANNOY = 0x5000B,\n    Z2SE_HS_V_RUSH = 0x5000C,\n    Z2SE_DOG_BARK = 0x5000D,\n    Z2SE_DOG_BREATH = 0x5000E,\n    Z2SE_DOG_CARRIED = 0x5000F,\n    Z2SE_M007_DOG_COME_RUNNING = 0x50013,\n    Z2SE_KOSARU_V_WAIT = 0x50014,\n    Z2SE_KOSARU_V_WALK = 0x50015,\n    Z2SE_KOSARU_V_JUMP = 0x50016,\n    Z2SE_KOSARU_V_CALL = 0x50017,\n    Z2SE_KOSARU_V_CATCH = 0x50018,\n    Z2SE_KOSARU_V_THROW = 0x50019,\n    Z2SE_KOSARU_V_PRISONED = 0x5001A,\n    Z2SE_KOSARU_V_POINT = 0x5001B,\n    Z2SE_KOSARU_V_CRUSHED = 0x5001C,\n    Z2SE_KOSARU_V_SCARED = 0x5001D,\n    Z2SE_KOSARU_V_SLAPPED_HIP = 0x5001E,\n    Z2SE_GOAT_V_CRY = 0x5001F,\n    Z2SE_GOAT_V_RUN = 0x50020,\n    Z2SE_GOAT_V_NOSE = 0x50021,\n    Z2SE_GOAT_V_EAT = 0x50022,\n    Z2SE_DOG_V_CALL_HELP = 0x50023,\n    Z2SE_DOG_V_JUMP = 0x50024,\n    Z2SE_HAWK_V_FIND_LINK = 0x50025,\n    Z2SE_HAWK_V_LANDING = 0x50026,\n    Z2SE_HAWK_V_TAKE_OFF = 0x50027,\n    Z2SE_MK_V_DEMO_HELP_APPEAR = 0x50028,\n    Z2SE_MK_V_ROPE_START = 0x50029,\n    Z2SE_MK_V_SWINGING = 0x5002A,\n    Z2SE_MK_V_D_DELIGHT = 0x5002B,\n    Z2SE_MK_V_D_BOMB_SHOW = 0x5002C,\n    Z2SE_MK_V_LOSE_BOMB = 0x5002D,\n    Z2SE_TKS_V_OUT_OF_POT = 0x5002E,\n    Z2SE_TKS_V_JUMP_UP = 0x5002F,\n    Z2SE_TKS_V_RUNNING_LOOP = 0x50030,\n    Z2SE_TKS_V_FALLING_LOOP = 0x50031,\n    Z2SE_TKS_V_ODOROKI_LOOP = 0x50032,\n    Z2SE_TKC_V_ODOROKI_LOOP = 0x50033,\n    Z2SE_TKJ_V_ODOROKI_LOOP = 0x50034,\n    Z2SE_HAWK_V_REGI_DEMO_1 = 0x50035,\n    Z2SE_HAWK_V_REGI_DEMO_2 = 0x50036,\n    Z2SE_TKJ_V_RUNNING_LOOP = 0x50037,\n    Z2SE_TKJ_V_CATCHED_CRY = 0x50038,\n    Z2SE_M019_YELIA_01 = 0x50039,\n    Z2SE_M020_YELIA_02 = 0x5003A,\n    Z2SE_TKJ_V_THROWN_CRY = 0x5003B,\n    Z2SE_TKS_V_TRANSLATE = 0x5003C,\n    Z2SE_M023_YELIA_05 = 0x5003D,\n    Z2SE_MOIR_V_WOLF_SURPRISE = 0x5003E,\n    Z2SE_MOIR_V_SHIT_H = 0x5003F,\n    Z2SE_MOIR_V_SHIT_L = 0x50040,\n    Z2SE_GRA_V_SPAWATER_SHOUT = 0x50041,\n    Z2SE_TKJ_V_SHOP_TALK = 0x50042,\n    Z2SE_KOSARU_V_SWING_KANTERA = 0x50043,\n    Z2SE_KOSARU_V_JUMP_SURPRISE = 0x50044,\n    Z2SE_KOSARU_V_RELEIEF = 0x50045,\n    Z2SE_KOSARU_V_KAGO_WAIT = 0x50046,\n    Z2SE_TAMABE_V_TUTO_BIKKURI = 0x50047,\n    Z2SE_SHA_V_URANAU = 0x50048,\n    Z2SE_M036_URI_01 = 0x5004A,\n    Z2SE_KN_V_BREATH = 0x5004B,\n    Z2SE_KN_V_GUARD = 0x5004C,\n    Z2SE_KN_V_DAMAGE_S = 0x5004D,\n    Z2SE_KN_V_DAMAGE_M = 0x5004E,\n    Z2SE_KN_V_DAMAGE_L = 0x5004F,\n    Z2SE_KN_V_ATTACK = 0x50050,\n    Z2SE_KN_V_BALL_READY = 0x50051,\n    Z2SE_KN_V_BALL_THROW = 0x50052,\n    Z2SE_KN_V_SOTOMOGIRI = 0x50053,\n    Z2SE_KN_V_KABUTOWARI = 0x50054,\n    Z2SE_KN_V_IAIGIRI = 0x50055,\n    Z2SE_KN_V_JUMP_ATTACK_L = 0x50056,\n    Z2SE_WLF_V_DEMO_BREATH_RUN = 0x50057,\n    Z2SE_WLF_V_DEMO_BREATH_WAI = 0x50058,\n    Z2SE_WLF_V_DEMO_UNARI = 0x50059,\n    Z2SE_D07V_WLF_UNARI_TRIG = 0x5005A,\n    Z2SE_M053_KOLIN_03 = 0x5005B,\n    Z2SE_TARO_V_CAGE_CRY_LOOP = 0x5005C,\n    Z2SE_M055_TARO_02 = 0x5005D,\n    Z2SE_M056_TARO_03 = 0x5005E,\n    Z2SE_TARO_V_CAGE_HAPPY = 0x5005F,\n    Z2SE_M058_TARO_05 = 0x50060,\n    Z2SE_WLF_V_DEMO_DAMAGE_S = 0x50061,\n    Z2SE_WLF_V_DEMO_DAMAGE_L = 0x50062,\n    Z2SE_D20V_WLF_WAIT_BREATH = 0x50063,\n    Z2SE_D20V_WLF_WAIT_DAMAGE = 0x50064,\n    Z2SE_POST_V_RUN_HIGH = 0x50065,\n    Z2SE_POST_V_RUN_LOW = 0x50066,\n    Z2SE_GORON_V_SMR_CAUTION = 0x5006A,\n    Z2SE_GORON_V_SMR_TO_STONE = 0x5006B,\n    Z2SE_GORON_V_SMR_REPLY = 0x5006C,\n    Z2SE_YAMI_MURMUR_S = 0x5006D,\n    Z2SE_YAMI_MURMUR_D = 0x5006E,\n    Z2SE_YAMI_MURMUR_T = 0x5006F,\n    Z2SE_SHAD_V_INCANTATION_L = 0x50070,\n    Z2SE_GRA_A_V_BRBR = 0x50071,\n    Z2SE_CHIN_V_KUSHAMI = 0x50072,\n    Z2SE_M077_HANJO_05 = 0x50073,\n    Z2SE_MDN_V_WARP_LIFTUP = 0x50074,\n    Z2SE_MSG_V_MDN_D21 = 0x50075,\n    Z2SE_GOAT_V_THROWN = 0x50077,\n    Z2SE_GOAT_V_ANGRY = 0x50078,\n    Z2SE_GOAT_V_BREATH = 0x50079,\n    Z2SE_GOAT_V_BREATH_SHAKE = 0x5007A,\n    Z2SE_KOSARU_V_DELIGHT = 0x5007B,\n    Z2SE_EN_WB_V_INANAKI = 0x5007C,\n    Z2SE_EN_WB_V_DAMAGE = 0x5007D,\n    Z2SE_EN_WB_V_INANAKI_DMG = 0x5007E,\n    Z2SE_EN_WB_V_BREATH = 0x5007F,\n    Z2SE_EN_WB_V_CRASH = 0x50080,\n    Z2SE_EN_WB_V_DOWN = 0x50081,\n    Z2SE_EN_WB_V_UP = 0x50082,\n    Z2SE_EN_WB_V_RIDE = 0x50083,\n    Z2SE_MK_V_COME_BACK = 0x50084,\n    Z2SE_MIDNA_V_LAUGH_LOOP = 0x50085,\n    Z2SE_GORON_V_FIGHTING_WAIT = 0x50086,\n    Z2SE_GORON_V_PUNCH = 0x50087,\n    Z2SE_GORON_V_GUARD = 0x50088,\n    Z2SE_GORON_V_TOTTER = 0x50089,\n    Z2SE_GORON_V_HEAD_BACK = 0x5008A,\n    Z2SE_GORON_V_HIT_TO_STONE = 0x5008B,\n    Z2SE_GORON_V_RECOVER = 0x5008C,\n    Z2SE_GORON_V_TO_STONE = 0x5008D,\n    Z2SE_GORON_V_THROWN = 0x5008E,\n    Z2SE_GORON_V_RELAX = 0x5008F,\n    Z2SE_GORON_V_THROWN_FIRST = 0x50090,\n    Z2SE_MYNA_V_LIGHT_ON = 0x50091,\n    Z2SE_MYNA_V_LIGHT_OFF = 0x50092,\n    Z2SE_BOU_V_SUMO_HARITE_ATK = 0x50093,\n    Z2SE_BOU_V_SUMO_HARITE_DMG = 0x50094,\n    Z2SE_BOU_V_SUMO_TUCKLE_ATK = 0x50095,\n    Z2SE_BOU_V_SUMO_HOLDED = 0x50096,\n    Z2SE_BOU_V_SUMO_HOLD_BACK = 0x50097,\n    Z2SE_BOU_V_SUMO_PUSH = 0x50098,\n    Z2SE_BOU_V_SUMO_PUSH_LAST = 0x50099,\n    Z2SE_BOU_V_SUMO_FALL_LOSE = 0x5009A,\n    Z2SE_HS_V_D15_CRY = 0x5009B,\n    Z2SE_HS_V_COACH_CRY = 0x5009E,\n    Z2SE_HS_V_CRY_UMAKUSA = 0x5009F,\n    Z2SE_MIDNA_V_APPEAR = 0x500A0,\n    Z2SE_HYL_MDN_RPLY = 0x500A1,\n    Z2SE_HYL_MDN_JOKE = 0x500A2,\n    Z2SE_HYL_MDN_SEXY = 0x500A3,\n    Z2SE_HYL_MDN_RDCL = 0x500A4,\n    Z2SE_HYL_MDN_BORE = 0x500A5,\n    Z2SE_HYL_MDN_IRRT = 0x500A6,\n    Z2SE_HYL_MDN_ORDR = 0x500A7,\n    Z2SE_HYL_MDN_RSNT = 0x500A8,\n    Z2SE_HYL_MDN_CHER = 0x500A9,\n    Z2SE_HYL_MDN_CONF = 0x500AA,\n    Z2SE_HYL_MDN_HSTL = 0x500AB,\n    Z2SE_HYL_MDN_TIRE = 0x500AC,\n    Z2SE_HYL_MDN_SRUS = 0x500AD,\n    Z2SE_HYL_MDN_RPLB = 0x500AE,\n    Z2SE_HYL_MDN_APLG = 0x500AF,\n    Z2SE_HYL_MDN_DSID = 0x500B0,\n    Z2SE_HYL_MDN_AFRD = 0x500B1,\n    Z2SE_MDN_D07_OTT = 0x500B2,\n    Z2SE_MDN_D10_HOO = 0x500B3,\n    Z2SE_MDN_D10_HMNG = 0x500B4,\n    Z2SE_MSG_V_MDN_LAUGH_30 = 0x500B5,\n    Z2SE_MSG_V_MDN_LAUGH_31 = 0x500B6,\n    Z2SE_MSG_V_MDN_LAUGH_32 = 0x500B7,\n    Z2SE_MSG_V_A_MDN_102 = 0x500B8,\n    Z2SE_MSG_V_A_MDN_103 = 0x500B9,\n    Z2SE_MSG_V_A_MDN_104 = 0x500BA,\n    Z2SE_YM_V_SNOBO_RIDING = 0x500BB,\n    Z2SE_YM_V_SNOBO_JUMP = 0x500BC,\n    Z2SE_YM_V_SNOBO_SPIN = 0x500BD,\n    Z2SE_YW_V_SNOBO_RIDING = 0x500BE,\n    Z2SE_YW_V_SNOBO_JUMP = 0x500BF,\n    Z2SE_YW_V_SNOBO_SPIN = 0x500C0,\n    Z2SE_BOU_V_SUMO_SHIKO = 0x500C1,\n    Z2SE_BOU_V_SUMO_PUSHED_BACK = 0x500C2,\n    Z2SE_GRN_V_SUMO_SHIKO = 0x500C3,\n    Z2SE_GRN_V_SUMO_HARITE_ATK = 0x500C4,\n    Z2SE_GRN_V_SUMO_HARITE_DMG = 0x500C5,\n    Z2SE_GRN_V_SUMO_TUCKLE_ATK = 0x500C6,\n    Z2SE_GRN_V_SUMO_HOLDED = 0x500C7,\n    Z2SE_GRN_V_SUMO_HOLD_BACK = 0x500C8,\n    Z2SE_GRN_V_SUMO_PUSH = 0x500C9,\n    Z2SE_GRN_V_SUMO_PUSHED_BACK = 0x500CA,\n    Z2SE_GRN_V_SUMO_PUSH_LAST = 0x500CB,\n    Z2SE_GRN_V_SUMO_FALL_LOSE = 0x500CC,\n    Z2SE_MESSAGE_SE_COMMON = 0x500CD,\n    Z2SE_YAMI_CUT_S = 0x500CE,\n    Z2SE_YAMI_CUT_D = 0x500CF,\n    Z2SE_YAMI_CUT_T = 0x500D0,\n    Z2SE_YAMI_CUT_L_SWD_S = 0x500D1,\n    Z2SE_YAMI_CUT_L_SWD_D = 0x500D2,\n    Z2SE_YAMI_CUT_L_SWD_T = 0x500D3,\n    Z2SE_YELIA_V_KYAAA_TRIG = 0x500D4,\n    Z2SE_YELIA_V_KYAAA_LOOP = 0x500D5,\n    Z2SE_TARO_V_SWING_L = 0x500D6,\n    Z2SE_TARO_V_SWING_S = 0x500D7,\n    Z2SE_TARO_V_ARROW_YEAH = 0x500D8,\n    Z2SE_BESU_MV_DOUYOU = 0x500D9,\n    Z2SE_MOI_MV_WOUND_UMEKI = 0x500DA,\n    Z2SE_MOI_V_WOUND_SWING = 0x500DB,\n    Z2SE_MOI_V_SWING_L = 0x500DC,\n    Z2SE_MOI_V_SWING_S = 0x500DD,\n    Z2SE_MOI_V_WOUND_BREATH = 0x500DE,\n    Z2SE_MOI_V_SLEEP_UNASARE = 0x500DF,\n    Z2SE_URI_V_SCREAM_L = 0x500E0,\n    Z2SE_URI_V_SCREAM_S = 0x500E1,\n    Z2SE_KYURY_MV_ZEKKU = 0x500E2,\n    Z2SE_KYURY_MV_WORRY = 0x500E3,\n    Z2SE_HANJO_MV_CRY = 0x500E4,\n    Z2SE_GRZ_V_BREAK = 0x500E5,\n    Z2SE_GRZ_V_BREAK_FINISH_M = 0x500E6,\n    Z2SE_GRZ_V_BREATH = 0x500E7,\n    Z2SE_GRZ_V_SNIFF = 0x500E8,\n    Z2SE_GRZ_V_BREAK_FINISH_L = 0x500E9,\n    Z2SE_GRO_MV_SINGING = 0x500EA,\n    Z2SE_GRR_MV_SINGING = 0x500EB,\n    Z2SE_ZRC_V_SLEEPING = 0x500EC,\n    Z2SE_ZRC_V_UNASARE = 0x500ED,\n    Z2SE_ZRA_MV_WOUND_BREATH = 0x500EE,\n    Z2SE_ZRA_MV_WOUND_COUGH = 0x500EF,\n    Z2SE_SHAD_V_INCANTATION = 0x500F0,\n    Z2SE_YKM_V_GETFOOD = 0x500F1,\n    Z2SE_FAIRY_V_SMILING_S = 0x500F2,\n    Z2SE_FAIRY_V_SIGH_S = 0x500F3,\n    Z2SE_FAIRY_V_SIGH_L = 0x500F4,\n    Z2SE_POST_V_THEME = 0x500F5,\n    Z2SE_POST_V_FANFARE = 0x500F6,\n    Z2SE_CLERK_MV_SONG_HO = 0x500F7,\n    Z2SE_WAD_A_MV_DANCE = 0x500F8,\n    Z2SE_MCN_A_V_DANCE = 0x500F9,\n    Z2SE_WCN_A_V_DANCE = 0x500FA,\n    Z2SE_BESU_V_SHIKARARE = 0x500FB,\n    Z2SE_KKRI_V_AISOWARAI = 0x500FC,\n    Z2SE_KKRI_V_GREETING = 0x500FD,\n    Z2SE_LUD_V_HOUSHIN = 0x500FE,\n    Z2SE_LUD_V_SHIKARARE = 0x500FF,\n    Z2SE_GRZ_V_NOD = 0x50100,\n    Z2SE_GRO_V_BREATH = 0x50101,\n    Z2SE_GRS_V_SURPRISED = 0x50102,\n    Z2SE_GRA_V_ROLLING = 0x50103,\n    Z2SE_TOBY_V_BOOT = 0x50104,\n    Z2SE_THE_V_BURNING = 0x50105,\n    Z2SE_ASH_V_SMILING = 0x50106,\n    Z2SE_YKM_V_DASH = 0x50107,\n    Z2SE_YKM_V_HUG = 0x50108,\n    Z2SE_YKW_V_HUG = 0x50109,\n    Z2SE_FAIRY_V_SMILING_L = 0x5010A,\n    Z2SE_POST_V_APPEAR = 0x5010B,\n    Z2SE_POST_V_SMILING = 0x5010C,\n    Z2SE_CHIN_V_YEAH = 0x5010D,\n    Z2SE_CHIN_V_SMILING = 0x5010E,\n    Z2SE_INS_V_UFUFU = 0x5010F,\n    Z2SE_YELIA_V_LOOK_KIBORI = 0x50110,\n    Z2SE_MAN_A1_V_AWAY = 0x50111,\n    Z2SE_MAN_A1_V_SURPRISE = 0x50112,\n    Z2SE_MAN_A1_V_FEAR = 0x50113,\n    Z2SE_MAN_A1_V_HEY = 0x50114,\n    Z2SE_MAN_A1_V_LAUGH = 0x50115,\n    Z2SE_MAN_A1_V_HMM = 0x50116,\n    Z2SE_MAD_A1_V_AWAY = 0x50117,\n    Z2SE_MAD_A1_V_SURPRISE = 0x50118,\n    Z2SE_MAD_A1_V_FEAR = 0x50119,\n    Z2SE_MAD_A1_V_HEY = 0x5011A,\n    Z2SE_MAD_A1_V_LAUGH = 0x5011B,\n    Z2SE_MAD_A1_V_HMM = 0x5011C,\n    Z2SE_MCN_A1_V_AWAY = 0x5011D,\n    Z2SE_MCN_A1_V_SURPRISE = 0x5011E,\n    Z2SE_MCN_A1_V_FEAR = 0x5011F,\n    Z2SE_MCN_A1_V_HEY = 0x50120,\n    Z2SE_MCN_A1_V_LAUGH = 0x50121,\n    Z2SE_MCN_A1_V_HMM = 0x50122,\n    Z2SE_MON_A1_V_AWAY = 0x50123,\n    Z2SE_MON_A1_V_SURPRISE = 0x50124,\n    Z2SE_MON_A1_V_FEAR = 0x50125,\n    Z2SE_MON_A1_V_HEY = 0x50126,\n    Z2SE_MON_A1_V_LAUGH = 0x50127,\n    Z2SE_MON_A1_V_HMM = 0x50128,\n    Z2SE_MAN_B1_V_AWAY = 0x50129,\n    Z2SE_MAN_B1_V_SURPRISE = 0x5012A,\n    Z2SE_MAN_B1_V_FEAR = 0x5012B,\n    Z2SE_MAN_B1_V_HEY = 0x5012C,\n    Z2SE_MAN_B1_V_LAUGH = 0x5012D,\n    Z2SE_MAN_B1_V_HMM = 0x5012E,\n    Z2SE_MAN_C1_V_AWAY = 0x5012F,\n    Z2SE_MAN_C1_V_SURPRISE = 0x50130,\n    Z2SE_MAN_C1_V_FEAR = 0x50131,\n    Z2SE_MAN_C1_V_HEY = 0x50132,\n    Z2SE_MAN_C1_V_LAUGH = 0x50133,\n    Z2SE_MAN_C1_V_HMM = 0x50134,\n    Z2SE_MAS_A1_V_AWAY = 0x50135,\n    Z2SE_MAS_A1_V_SURPRISE = 0x50136,\n    Z2SE_MAS_A1_V_FEAR = 0x50137,\n    Z2SE_MAS_A1_V_HEY = 0x50138,\n    Z2SE_MAS_A1_V_LAUGH = 0x50139,\n    Z2SE_MAS_A1_V_HMM = 0x5013A,\n    Z2SE_MBN_A1_V_AWAY = 0x5013B,\n    Z2SE_MBN_A1_V_SURPRISE = 0x5013C,\n    Z2SE_MBN_A1_V_FEAR = 0x5013D,\n    Z2SE_MBN_A1_V_HEY = 0x5013E,\n    Z2SE_MBN_A1_V_LAUGH = 0x5013F,\n    Z2SE_MBN_A1_V_HMM = 0x50140,\n    Z2SE_MAD_A2_V_AWAY = 0x50141,\n    Z2SE_MAD_A2_V_SURPRISE = 0x50142,\n    Z2SE_MAD_A2_V_FEAR = 0x50143,\n    Z2SE_MAD_A2_V_HEY = 0x50144,\n    Z2SE_MAD_A2_V_LAUGH = 0x50145,\n    Z2SE_MAD_A2_V_HMM = 0x50146,\n    Z2SE_MAN_A2_V_AWAY = 0x50147,\n    Z2SE_MAN_A2_V_SURPRISE = 0x50148,\n    Z2SE_MAN_A2_V_FEAR = 0x50149,\n    Z2SE_MAN_A2_V_HEY = 0x5014A,\n    Z2SE_MAN_A2_V_LAUGH = 0x5014B,\n    Z2SE_MAN_A2_V_HMM = 0x5014C,\n    Z2SE_MCN_A2_V_AWAY = 0x5014D,\n    Z2SE_MCN_A2_V_SURPRISE = 0x5014E,\n    Z2SE_MCN_A2_V_FEAR = 0x5014F,\n    Z2SE_MCN_A2_V_HEY = 0x50150,\n    Z2SE_MCN_A2_V_LAUGH = 0x50151,\n    Z2SE_MCN_A2_V_HMM = 0x50152,\n    Z2SE_MON_A2_V_AWAY = 0x50153,\n    Z2SE_MON_A2_V_SURPRISE = 0x50154,\n    Z2SE_MON_A2_V_FEAR = 0x50155,\n    Z2SE_MON_A2_V_HEY = 0x50156,\n    Z2SE_MON_A2_V_LAUGH = 0x50157,\n    Z2SE_MON_A2_V_HMM = 0x50158,\n    Z2SE_MAN_B2_V_AWAY = 0x50159,\n    Z2SE_MAN_B2_V_SURPRISE = 0x5015A,\n    Z2SE_MAN_B2_V_FEAR = 0x5015B,\n    Z2SE_MAN_B2_V_HEY = 0x5015C,\n    Z2SE_MAN_B2_V_LAUGH = 0x5015D,\n    Z2SE_MAN_B2_V_HMM = 0x5015E,\n    Z2SE_MAN_C2_V_AWAY = 0x5015F,\n    Z2SE_MAN_C2_V_SURPRISE = 0x50160,\n    Z2SE_MAN_C2_V_FEAR = 0x50161,\n    Z2SE_MAN_C2_V_HEY = 0x50162,\n    Z2SE_MAN_C2_V_LAUGH = 0x50163,\n    Z2SE_MAN_C2_V_HMM = 0x50164,\n    Z2SE_MAS_A2_V_AWAY = 0x50165,\n    Z2SE_MAS_A2_V_SURPRISE = 0x50166,\n    Z2SE_MAS_A2_V_FEAR = 0x50167,\n    Z2SE_MAS_A2_V_HEY = 0x50168,\n    Z2SE_MAS_A2_V_LAUGH = 0x50169,\n    Z2SE_MAS_A2_V_HMM = 0x5016A,\n    Z2SE_MBN_A2_V_AWAY = 0x5016B,\n    Z2SE_MBN_A2_V_SURPRISE = 0x5016C,\n    Z2SE_MBN_A2_V_FEAR = 0x5016D,\n    Z2SE_MBN_A2_V_HEY = 0x5016E,\n    Z2SE_MBN_A2_V_LAUGH = 0x5016F,\n    Z2SE_MBN_A2_V_HMM = 0x50170,\n    Z2SE_WAN_A1_V_AWAY = 0x50171,\n    Z2SE_WAN_A1_V_SURPRISE = 0x50172,\n    Z2SE_WAN_A1_V_FEAR = 0x50173,\n    Z2SE_WAN_A1_V_HEY = 0x50174,\n    Z2SE_WAN_A1_V_LAUGH = 0x50175,\n    Z2SE_WAN_A1_V_HMM = 0x50176,\n    Z2SE_WAD_A1_V_AWAY = 0x50177,\n    Z2SE_WAD_A1_V_SURPRISE = 0x50178,\n    Z2SE_WAD_A1_V_FEAR = 0x50179,\n    Z2SE_WAD_A1_V_HEY = 0x5017A,\n    Z2SE_WAD_A1_V_LAUGH = 0x5017B,\n    Z2SE_WAD_A1_V_HMM = 0x5017C,\n    Z2SE_MAT_A1_V_AWAY = 0x5017D,\n    Z2SE_MAT_A1_V_SURPRISE = 0x5017E,\n    Z2SE_MAT_A1_V_FEAR = 0x5017F,\n    Z2SE_MAT_A1_V_HEY = 0x50180,\n    Z2SE_MAT_A1_V_LAUGH = 0x50181,\n    Z2SE_MAT_A1_V_HMM = 0x50182,\n    Z2SE_WCN_A1_V_AWAY = 0x50183,\n    Z2SE_WCN_A1_V_SURPRISE = 0x50184,\n    Z2SE_WCN_A1_V_FEAR = 0x50185,\n    Z2SE_WCN_A1_V_HEY = 0x50186,\n    Z2SE_WCN_A1_V_LAUGH = 0x50187,\n    Z2SE_WCN_A1_V_HMM = 0x50188,\n    Z2SE_WON_A1_V_AWAY = 0x50189,\n    Z2SE_WON_A1_V_SURPRISE = 0x5018A,\n    Z2SE_WON_A1_V_FEAR = 0x5018B,\n    Z2SE_WON_A1_V_HEY = 0x5018C,\n    Z2SE_WON_A1_V_LAUGH = 0x5018D,\n    Z2SE_WON_A1_V_HMM = 0x5018E,\n    Z2SE_WGN_A1_V_AWAY = 0x5018F,\n    Z2SE_WGN_A1_V_SURPRISE = 0x50190,\n    Z2SE_WGN_A1_V_FEAR = 0x50191,\n    Z2SE_WGN_A1_V_HEY = 0x50192,\n    Z2SE_WGN_A1_V_LAUGH = 0x50193,\n    Z2SE_WGN_A1_V_HMM = 0x50194,\n    Z2SE_WAN_B1_V_AWAY = 0x50195,\n    Z2SE_WAN_B1_V_SURPRISE = 0x50196,\n    Z2SE_WAN_B1_V_FEAR = 0x50197,\n    Z2SE_WAN_B1_V_HEY = 0x50198,\n    Z2SE_WAN_B1_V_LAUGH = 0x50199,\n    Z2SE_WAN_B1_V_HMM = 0x5019A,\n    Z2SE_WAN_A2_V_AWAY = 0x5019B,\n    Z2SE_WAN_A2_V_SURPRISE = 0x5019C,\n    Z2SE_WAN_A2_V_FEAR = 0x5019D,\n    Z2SE_WAN_A2_V_HEY = 0x5019E,\n    Z2SE_WAN_A2_V_LAUGH = 0x5019F,\n    Z2SE_WAN_A2_V_HMM = 0x501A0,\n    Z2SE_WAD_A2_V_AWAY = 0x501A1,\n    Z2SE_WAD_A2_V_SURPRISE = 0x501A2,\n    Z2SE_WAD_A2_V_FEAR = 0x501A3,\n    Z2SE_WAD_A2_V_HEY = 0x501A4,\n    Z2SE_WAD_A2_V_LAUGH = 0x501A5,\n    Z2SE_WAD_A2_V_HMM = 0x501A6,\n    Z2SE_MAT_A2_V_AWAY = 0x501A7,\n    Z2SE_MAT_A2_V_SURPRISE = 0x501A8,\n    Z2SE_MAT_A2_V_FEAR = 0x501A9,\n    Z2SE_MAT_A2_V_HEY = 0x501AA,\n    Z2SE_MAT_A2_V_LAUGH = 0x501AB,\n    Z2SE_MAT_A2_V_HMM = 0x501AC,\n    Z2SE_WCN_A2_V_AWAY = 0x501AD,\n    Z2SE_WCN_A2_V_SURPRISE = 0x501AE,\n    Z2SE_WCN_A2_V_FEAR = 0x501AF,\n    Z2SE_WCN_A2_V_HEY = 0x501B0,\n    Z2SE_WCN_A2_V_LAUGH = 0x501B1,\n    Z2SE_WCN_A2_V_HMM = 0x501B2,\n    Z2SE_WON_A2_V_AWAY = 0x501B3,\n    Z2SE_WON_A2_V_SURPRISE = 0x501B4,\n    Z2SE_WON_A2_V_FEAR = 0x501B5,\n    Z2SE_WON_A2_V_HEY = 0x501B6,\n    Z2SE_WON_A2_V_LAUGH = 0x501B7,\n    Z2SE_WON_A2_V_HMM = 0x501B8,\n    Z2SE_WGN_A2_V_AWAY = 0x501B9,\n    Z2SE_WGN_A2_V_SURPRISE = 0x501BA,\n    Z2SE_WGN_A2_V_FEAR = 0x501BB,\n    Z2SE_WGN_A2_V_HEY = 0x501BC,\n    Z2SE_WGN_A2_V_LAUGH = 0x501BD,\n    Z2SE_WGN_A2_V_HMM = 0x501BE,\n    Z2SE_WAN_B2_V_AWAY = 0x501BF,\n    Z2SE_WAN_B2_V_SURPRISE = 0x501C0,\n    Z2SE_WAN_B2_V_FEAR = 0x501C1,\n    Z2SE_WAN_B2_V_HEY = 0x501C2,\n    Z2SE_WAN_B2_V_LAUGH = 0x501C3,\n    Z2SE_WAN_B2_V_HMM = 0x501C4,\n    Z2SE_MSG_V_A_MDN_1 = 0x501C8,\n    Z2SE_MSG_V_A_MDN_2 = 0x501C9,\n    Z2SE_MSG_V_KOKKO = 0x501CA,\n    Z2SE_MSG_V_SQUIRREL = 0x501CB,\n    Z2SE_MSG_V_CAT = 0x501CC,\n    Z2SE_MSG_V_PERU = 0x501CD,\n    Z2SE_MSG_V_FROG = 0x501CE,\n    Z2SE_MSG_V_DOG = 0x501CF,\n    Z2SE_MSG_V_MONKEY = 0x501D0,\n    Z2SE_MSG_V_MYNA = 0x501D1,\n    Z2SE_KIU_V_FEAR = 0x501D2,\n    Z2SE_HANA_V_FEAR = 0x501D3,\n    Z2SE_MICH_V_FEAR = 0x501D4,\n    Z2SE_MOI_V_KUTT = 0x501D5,\n    Z2SE_YKM_V_HUMMING = 0x501D6,\n    Z2SE_YKM_V_ATTACK_TREE = 0x501D7,\n    Z2SE_YKM_V_JUMP_TO_LEAF = 0x501D8,\n    Z2SE_GRA_V_YURAYURA = 0x501D9,\n    Z2SE_SEKI_V_KAKUSEI_1 = 0x501DA,\n    Z2SE_SEKI_V_KAKUSEI_2 = 0x501DB,\n    Z2SE_SEKI_V_JUMP_1 = 0x501DC,\n    Z2SE_SEKI_V_COL1 = 0x501DD,\n    Z2SE_SEKI_V_COL2 = 0x501DE,\n    Z2SE_SEKI_V_NO_JUMP_1 = 0x501DF,\n    Z2SE_SEKI_V_NO_JUMP_2 = 0x501E0,\n    Z2SE_GRA_V_ROLLING_RETURN = 0x501E1,\n    Z2SE_SEKI_V_JUMP_2 = 0x501E2,\n    Z2SE_SEKI_V_CLEAR_1 = 0x501E3,\n    Z2SE_SEKI_V_CLEAR_2 = 0x501E4,\n    Z2SE_MOI_V_GUARD_SWING = 0x501E5,\n    Z2SE_JAGA_V_SURPRISE = 0x501E6,\n    Z2SE_TOBY_V_SURPRISE = 0x501E7,\n    Z2SE_TOBY_V_BURUBURU = 0x501E8,\n    Z2SE_MDN_V_FLY_OUT = 0x501E9,\n    Z2SE_MDN_V_MGN_TAME = 0x501EA,\n    Z2SE_MDN_V_CLINGST = 0x501EB,\n    Z2SE_MDN_V_LV_PANIC = 0x501EC,\n    Z2SE_MDN_V_HIT = 0x501ED,\n    Z2SE_MDN_V_LOOKABOUT_1 = 0x501EE,\n    Z2SE_MDN_V_WLSWIMDIE = 0x501EF,\n    Z2SE_MDN_V_WAITD = 0x501F0,\n    Z2SE_MDN_V_SWAITA = 0x501F1,\n    Z2SE_MDN_V_SWAITB_1 = 0x501F2,\n    Z2SE_D26V_MDN_CRY_2 = 0x501F3,\n    Z2SE_MDN_V_SWAITB_3 = 0x501F4,\n    Z2SE_MDN_V_SWAITC = 0x501F5,\n    Z2SE_MDN_V_SWAITD = 0x501F6,\n    Z2SE_MDN_V_LEADSWAIT = 0x501F7,\n    Z2SE_MDN_V_HIP = 0x501F8,\n    Z2SE_MDN_V_WLDIEA = 0x501F9,\n    Z2SE_MDN_V_ENTRANCE = 0x501FA,\n    Z2SE_MDN_V_DOOROP = 0x501FB,\n    Z2SE_MDN_V_ROPEWAIT_1 = 0x501FC,\n    Z2SE_MDN_V_ROPEWAIT_2 = 0x501FD,\n    Z2SE_MDN_V_ROPEFALTER = 0x501FE,\n    Z2SE_MDN_V_WAITTP = 0x501FF,\n    Z2SE_MDN_V_MGN_CATCH = 0x50200,\n    Z2SE_MDN_V_MGN_THROW = 0x50201,\n    Z2SE_D01V_LINK_SMILE_KLN = 0x50202,\n    Z2SE_D01V_ARU_CALLING = 0x50203,\n    Z2SE_D01V_YELIA_NOTICE = 0x50204,\n    Z2SE_D01V_LINK_SMILE_YLA = 0x50205,\n    Z2SE_D02V_BOU_APPEAR = 0x50206,\n    Z2SE_D02V_YELIA_NOTICE = 0x50207,\n    Z2SE_D02V_BOU_LOOKBACK = 0x50208,\n    Z2SE_D02V_BOU_SHOGERU = 0x50209,\n    Z2SE_D02V_BOU_KOMATTA = 0x5020A,\n    Z2SE_D04V_YELIA_SURPRISE = 0x5020B,\n    Z2SE_D04V_YELIA_SCREAM = 0x5020C,\n    Z2SE_D13V_BANS_KEIKAI = 0x5020D,\n    Z2SE_D13V_TARO_ODOSARE = 0x5020E,\n    Z2SE_D13V_BANS_SOPPO = 0x5020F,\n    Z2SE_D13V_BESU_CRY_OUT = 0x50210,\n    Z2SE_D13V_LEN_KOMARU = 0x50211,\n    Z2SE_D13V_BANS_MASK = 0x50212,\n    Z2SE_D13V_LEN_NIRAMU = 0x50213,\n    Z2SE_D13V_BANS_YOTTEKURU = 0x50214,\n    Z2SE_D13V_BANS_LOOK_BASE = 0x50215,\n    Z2SE_D13V_BANS_TOBITSUKI = 0x50216,\n    Z2SE_D13V_BANS_ZUKKOKE = 0x50217,\n    Z2SE_D13V_BANS_ATOZUSARI = 0x50218,\n    Z2SE_D13V_BESU_CRYING = 0x50219,\n    Z2SE_D13V_KOLIN_HARAWARE = 0x5021A,\n    Z2SE_D13V_BANS_WHO = 0x5021B,\n    Z2SE_D13V_TARO_FUN = 0x5021C,\n    Z2SE_D16V_KOLIN_WAKEUP = 0x5021D,\n    Z2SE_D16V_KOLIN_RELIEF = 0x5021E,\n    Z2SE_D16V_KOLIN_KOBUSHI = 0x5021F,\n    Z2SE_D16V_LINK_NOD = 0x50220,\n    Z2SE_D16V_KOLIN_SLEEP = 0x50221,\n    Z2SE_D16V_TARO_SURPRISE = 0x50222,\n    Z2SE_D16V_BESU_SURPRISE = 0x50223,\n    Z2SE_D16V_TARO_CARRY = 0x50224,\n    Z2SE_D35V_KOLIN_SMILE = 0x50225,\n    Z2SE_D35V_LINK_MIHIRAKI = 0x50226,\n    Z2SE_D35V_KOLIN_RUN = 0x50227,\n    Z2SE_D35V_THE_RELIEF = 0x50228,\n    Z2SE_D35V_LINK_LOOK_THE = 0x50229,\n    Z2SE_D35V_THE_WINK = 0x5022A,\n    Z2SE_D35V_LINK_NOTICE_1 = 0x5022B,\n    Z2SE_D35V_LINK_NOTICE_2 = 0x5022C,\n    Z2SE_D37V_LINK_SMILE = 0x5022D,\n    Z2SE_D37V_TARO_HIPPARARE = 0x5022E,\n    Z2SE_D37V_YELIA_SMILE = 0x5022F,\n    Z2SE_D14V_KOLIN_KIDUKU = 0x50230,\n    Z2SE_D14V_KOLIN_KOKERU = 0x50231,\n    Z2SE_D14V_TARO_RUN = 0x50232,\n    Z2SE_D14V_BESU_RUN = 0x50233,\n    Z2SE_D14V_TARO_STOP = 0x50234,\n    Z2SE_D14V_BESU_STOP = 0x50235,\n    Z2SE_D14V_TARO_JIMAN = 0x50236,\n    Z2SE_D14V_KOLIN_STANDUP = 0x50237,\n    Z2SE_D14V_BANS_SHOKAI = 0x50238,\n    Z2SE_D14V_KOLIN_MITSUMERU = 0x50239,\n    Z2SE_D14V_TARO_MITSUMERU = 0x5023A,\n    Z2SE_D14V_BESU_MITSUMERU = 0x5023B,\n    Z2SE_D17V_KOLIN_SITDOWN = 0x5023C,\n    Z2SE_D17V_KOLIN_BREATH = 0x5023D,\n    Z2SE_D17V_LINK_SURPRISE = 0x5023E,\n    Z2SE_D17V_KOLIN_ALLRIGHT = 0x5023F,\n    Z2SE_D17V_LINK_RELIEF_KLN = 0x50240,\n    Z2SE_D19V_LINK_SHOULDER_HIT = 0x50241,\n    Z2SE_D19V_DOC_NIRAMU = 0x50242,\n    Z2SE_D19V_LINK_CANNOT_SAY = 0x50243,\n    Z2SE_D19V_DOC_SORASU = 0x50244,\n    Z2SE_D19V_YELIA_MATTE = 0x50245,\n    Z2SE_D19V_YELIA_SIGH = 0x50246,\n    Z2SE_D19V_LINK_KIDUKU = 0x50247,\n    Z2SE_D19V_YELIA_KIDUKAZU = 0x50248,\n    Z2SE_D19V_LINK_YLA_BACK = 0x50249,\n    Z2SE_D19V_THE_THINK = 0x5024A,\n    Z2SE_D19V_YELIA_SITDOWN = 0x5024B,\n    Z2SE_D19V_ZRC_BREATH_1 = 0x5024C,\n    Z2SE_D19V_THE_IDEA = 0x5024D,\n    Z2SE_D19V_YELIA_FACEUP = 0x5024E,\n    Z2SE_D19V_HAI_A_SEKI = 0x5024F,\n    Z2SE_D19V_HAI_B_SEKI = 0x50250,\n    Z2SE_D19V_HAI_C_SEKI = 0x50251,\n    Z2SE_D19V_HAI_D_SEKI = 0x50252,\n    Z2SE_D19V_HAI_E_SEKI = 0x50253,\n    Z2SE_D19V_THE_NOTICE_HAI = 0x50254,\n    Z2SE_D19V_HAI_A_MORIAGARI = 0x50255,\n    Z2SE_D19V_HAI_B_MORIAGARI = 0x50256,\n    Z2SE_D19V_HAI_C_MORIAGARI = 0x50257,\n    Z2SE_D19V_HAI_D_MORIAGARI = 0x50258,\n    Z2SE_D19V_HAI_E_MORIAGARI = 0x50259,\n    Z2SE_D19V_THE_YOKATTA = 0x5025A,\n    Z2SE_D19V_THE_REMEMBER = 0x5025B,\n    Z2SE_D19V_THE_FIND_ONE = 0x5025C,\n    Z2SE_D19V_HAI_E_ONLY_ME = 0x5025D,\n    Z2SE_D19V_HAI_E_ESCAPE = 0x5025E,\n    Z2SE_D19V_THE_UNARU = 0x5025F,\n    Z2SE_D19V_THE_NIDOTO = 0x50260,\n    Z2SE_D19V_THE_FIND_LINK = 0x50261,\n    Z2SE_D19V_LINK_M_LOST_YLA = 0x50262,\n    Z2SE_D19V_ZRC_BREATH_2 = 0x50263,\n    Z2SE_D19V_THE_THROW_KISS = 0x50264,\n    Z2SE_D19V_THE_LAUGH = 0x50265,\n    Z2SE_D17V_LINK_NOTICE = 0x50266,\n    Z2SE_D06V_MDN_KAWASU = 0x50267,\n    Z2SE_D06V_MDN_LAUGH_OVER = 0x50268,\n    Z2SE_D08V_MDN_SEEK = 0x50269,\n    Z2SE_D08V_KOLIN_CHANGE = 0x5026A,\n    Z2SE_D08V_YELIA_CHANGE = 0x5026B,\n    Z2SE_D18V_LINK_IN_THE_DARK = 0x5026C,\n    Z2SE_D18V_LINK_SMILING = 0x5026D,\n    Z2SE_D18V_YELIA_SMILING = 0x5026E,\n    Z2SE_D18V_YELIA_ATTACK = 0x5026F,\n    Z2SE_D18V_LINK_B_SMILE = 0x50270,\n    Z2SE_D18V_LINK_B_MAGIC = 0x50271,\n    Z2SE_D18V_LINK_REMOVE = 0x50272,\n    Z2SE_D18V_LINK_B_LAUGH = 0x50273,\n    Z2SE_D18V_LINK_B_SURPRISE = 0x50274,\n    Z2SE_D18V_LINK_B_WEAK = 0x50275,\n    Z2SE_D18V_LINK_B_LOOKBACK = 0x50276,\n    Z2SE_D18V_LINK_B_SHOUT = 0x50277,\n    Z2SE_D18V_YELIA_UFUFU_1 = 0x50278,\n    Z2SE_D18V_YELIA_UFUFU_2 = 0x50279,\n    Z2SE_D18V_YELIA_AHAHA_1 = 0x5027A,\n    Z2SE_D18V_YELIA_AHAHA_2 = 0x5027B,\n    Z2SE_D18V_YELIA_AHAHA_3 = 0x5027C,\n    Z2SE_D18V_LINK_WAKEUP = 0x5027D,\n    Z2SE_D18V_LINK_BREATH = 0x5027E,\n    Z2SE_D26V_MDN_CRY_1 = 0x5027F,\n    Z2SE_D26V_MJN_1ST = 0x50280,\n    Z2SE_D26V_MJN_JUMP = 0x50281,\n    Z2SE_D26V_MJN_HAND_UP = 0x50282,\n    Z2SE_D26V_MJN_SPEAR_ATK = 0x50283,\n    Z2SE_D26V_MDN_NOTICE = 0x50284,\n    Z2SE_MDN_V_STN_OUT = 0x50285,\n    Z2SE_D20V_MDN_HAA = 0x50286,\n    Z2SE_MSG_MDN_KKK = 0x50287,\n    Z2SE_D28V_MJN_TAME = 0x50288,\n    Z2SE_D28V_MJN_RUSH = 0x50289,\n    Z2SE_D28V_SEI_A = 0x5028A,\n    Z2SE_D28V_SEI_B = 0x5028B,\n    Z2SE_D28V_SEI_C = 0x5028C,\n    Z2SE_D28V_SEI_D = 0x5028D,\n    Z2SE_D20V_LINK_LOOKBACK = 0x5028E,\n    Z2SE_D20V_LINK_CANNOT_SAY = 0x5028F,\n    Z2SE_D20V_LINK_SHOUT = 0x50290,\n    Z2SE_D20V_MDN_APPEAR = 0x50291,\n    Z2SE_D20V_MDN_SHIBARARE = 0x50292,\n    Z2SE_D20V_MDN_UBAWARE = 0x50293,\n    Z2SE_D20V_ZANT_THROW_AWAY = 0x50294,\n    Z2SE_D20V_MDN_HIT_GROUND = 0x50295,\n    Z2SE_D20V_MDN_FATALLY = 0x50296,\n    Z2SE_D20V_MDN_SHIBARI_AGAIN = 0x50297,\n    Z2SE_D20V_MDN_BRAINWASH = 0x50298,\n    Z2SE_D20V_ZANT_WANT_YOU = 0x50299,\n    Z2SE_D20V_MDN_AWAY_ZANT = 0x5029A,\n    Z2SE_D20V_MDN_SHIBARI_THIRD = 0x5029B,\n    Z2SE_D20V_MDN_UMEKI = 0x5029C,\n    Z2SE_D20V_MDN_SHOUT = 0x5029D,\n    Z2SE_D21V_MDN_BREATH = 0x5029E,\n    Z2SE_D21V_MDN_FALLDOWN = 0x5029F,\n    Z2SE_D21V_MDN_HATTOSURU = 0x502A0,\n    Z2SE_D21V_ZELDA_HATTOSURU = 0x502A1,\n    Z2SE_D21V_MDN_LIGHT = 0x502A2,\n    Z2SE_D21V_MDN_LOOK_BARRIER = 0x502A3,\n    Z2SE_D21V_MDN_KUYASHI = 0x502A4,\n    Z2SE_D22V_MDN_TOBASARE = 0x502A5,\n    Z2SE_D22V_LINK_PULLING = 0x502A6,\n    Z2SE_D22V_LINK_PULLED = 0x502A7,\n    Z2SE_D23V_LINK_NOD = 0x502A8,\n    Z2SE_D24V_KNJ_OUR_MISS = 0x502A9,\n    Z2SE_D24V_MDN_CHANGED_DOWN = 0x502AA,\n    Z2SE_D24V_MDN_SLOW_WALK = 0x502AB,\n    Z2SE_D24V_MDN_KUYASHI = 0x502AC,\n    Z2SE_D24V_KNJ_SEE_OFF = 0x502AD,\n    Z2SE_D09V_SEI_APPEAR = 0x502AE,\n    Z2SE_D11V_SEI_APPEAR = 0x502AF,\n    Z2SE_D14V_SEI_APPEAR = 0x502B0,\n    Z2SE_D20V_SEI_APPEAR = 0x502B1,\n    Z2SE_D20V_SEI_DMG = 0x502B2,\n    Z2SE_D22V_LINK_SWING_1 = 0x502B3,\n    Z2SE_D22V_LINK_SWING_2 = 0x502B4,\n    Z2SE_D22V_LINK_SWING_3 = 0x502B5,\n    Z2SE_D25V_MDN_NOT_CHANGE = 0x502B6,\n    Z2SE_D25V_ZANT_FATALLY = 0x502B7,\n    Z2SE_D25V_ZANT_DREAMING = 0x502B8,\n    Z2SE_D25V_ZANT_DIE = 0x502B9,\n    Z2SE_D27V_MDN_LOOK_ZELDA = 0x502BA,\n    Z2SE_D27V_LINK_LOOK_ZELDA = 0x502BB,\n    Z2SE_D27V_LINK_STOP_BY_MDN = 0x502BC,\n    Z2SE_D27V_GANON_SITDOWN = 0x502BD,\n    Z2SE_D27V_GANON_STANDUP = 0x502BE,\n    Z2SE_D27V_GANON_STOOD_FACE = 0x502BF,\n    Z2SE_D27V_GANON_LEFT_HAND = 0x502C0,\n    Z2SE_D27V_GANON_TRIFORCE = 0x502C1,\n    Z2SE_D27V_GANON_LAUGH_DENY = 0x502C2,\n    Z2SE_D27V_LINK_AH_MDN_FLY = 0x502C3,\n    Z2SE_D27V_MDN_TUBUTUUKA = 0x502C4,\n    Z2SE_D27V_MDN_NO_DAMAGE = 0x502C5,\n    Z2SE_D27V_MDN_ATTACK_ZLD = 0x502C6,\n    Z2SE_D27V_MDN_STOP_ATTACK = 0x502C7,\n    Z2SE_D27V_MDN_BLEW_AWAY = 0x502C8,\n    Z2SE_D27V_MDN_HIT_GROUND = 0x502C9,\n    Z2SE_D27V_LINK_FOLLOW_MDN = 0x502CA,\n    Z2SE_D27V_LINK_LOOKBACK = 0x502CB,\n    Z2SE_D27V_ZELDA_G_WALK = 0x502CC,\n    Z2SE_D27V_ZELDA_G_FLOAT = 0x502CD,\n    Z2SE_D27V_ZELDA_G_HIRUMU = 0x502CE,\n    Z2SE_D27V_ZELDA_G_ATTACKED = 0x502CF,\n    Z2SE_D27V_GANON_SCREAM = 0x502D0,\n    Z2SE_D27V_GANON_TO_PORK_1 = 0x502D1,\n    Z2SE_D28V_LINK_LOOK_GNN = 0x502D2,\n    Z2SE_D28V_ZELDA_LOOK_GNN = 0x502D3,\n    Z2SE_D28V_LINK_BACK = 0x502D4,\n    Z2SE_D28V_LINK_NOTICE_MDN_1 = 0x502D5,\n    Z2SE_D28V_LINK_NOTICE_MDN_2 = 0x502D6,\n    Z2SE_D28V_LINK_REACH_HAND = 0x502D7,\n    Z2SE_D28V_LINK_BEFORE_WARP = 0x502D8,\n    Z2SE_D28V_LINK_LOOK_AROUND = 0x502D9,\n    Z2SE_D28V_LINK_RUMBLE = 0x502DA,\n    Z2SE_D28V_ZELDA_RUMBLE = 0x502DB,\n    Z2SE_D28V_ZELDA_LOOK_MASK = 0x502DC,\n    Z2SE_D28V_LINK_LOOK_MASK = 0x502DD,\n    Z2SE_D28V_LINK_COME_HORSE = 0x502DE,\n    Z2SE_D28V_ZELDA_MAGIC = 0x502DF,\n    Z2SE_D29V_GANON_STANDUP = 0x502E0,\n    Z2SE_D29V_GANON_BREATH = 0x502E1,\n    Z2SE_D29V_GANON_TRIFORCE = 0x502E2,\n    Z2SE_D29V_GANON_BEFORE_D = 0x502E3,\n    Z2SE_D29V_GANON_DIE = 0x502E4,\n    Z2SE_D30V_LINK_NOTICE_MDN = 0x502E5,\n    Z2SE_D30V_LINK_RUN_TO_MDN = 0x502E6,\n    Z2SE_D30V_LINK_LOOK_MDN = 0x502E7,\n    Z2SE_D30V_LINK_SMILING = 0x502E8,\n    Z2SE_D30V_LINK_SURPRISE = 0x502E9,\n    Z2SE_D30V_ZELDA_SURPRISE = 0x502EA,\n    Z2SE_D30V_LINK_LOOKBACK = 0x502EB,\n    Z2SE_D32V_MDN_LOOK_MIRROR = 0x502EC,\n    Z2SE_D32V_MDN_KUYASHII = 0x502ED,\n    Z2SE_D32V_GANON_UMEKI = 0x502EE,\n    Z2SE_D32V_GANON_PIERCED = 0x502EF,\n    Z2SE_D32V_GANON_FURISIBORU = 0x502F0,\n    Z2SE_D32V_GANON_RIGHT_FREE = 0x502F1,\n    Z2SE_D32V_KNJ_SURPRISE = 0x502F2,\n    Z2SE_D32V_GANON_LEFT_FREE = 0x502F3,\n    Z2SE_D32V_KNJ_ATTACKED = 0x502F4,\n    Z2SE_D32V_KNJ_OTHERS_SURP = 0x502F5,\n    Z2SE_D32V_GANON_USE_SWORD = 0x502F6,\n    Z2SE_D32V_GANON_IN_MIRROR = 0x502F7,\n    Z2SE_D32V_KNJ_NAGEKI = 0x502F8,\n    Z2SE_D32V_KNJ_SETSUMEIGO_1 = 0x502F9,\n    Z2SE_D32V_KNJ_SETSUMEIGO_2 = 0x502FA,\n    Z2SE_D33V_ZANT_STANDUP = 0x502FB,\n    Z2SE_D33V_ZANT_NEJIRU = 0x502FC,\n    Z2SE_D33V_ZANT_HANERU = 0x502FD,\n    Z2SE_D33V_ZANT_IKIGIRE = 0x502FE,\n    Z2SE_D33V_ZANT_JUMP_TO_LNK = 0x502FF,\n    Z2SE_D33V_ZANT_KAITEN = 0x50300,\n    Z2SE_D33V_ZANT_EBIZORI = 0x50301,\n    Z2SE_D33V_ZANT_HIZATSUKI = 0x50302,\n    Z2SE_D33V_ZANT_KUYASHII = 0x50303,\n    Z2SE_D33V_ZANT_ATOZUSARI = 0x50304,\n    Z2SE_D33V_GANON_UMEKI = 0x50305,\n    Z2SE_D33V_ZANT_BOUZEN = 0x50306,\n    Z2SE_D32V_GANON_LAUGH_1 = 0x50307,\n    Z2SE_D32V_GANON_LAUGH_2 = 0x50308,\n    Z2SE_D07V_MDN_LAUGH_WOLF = 0x50309,\n    Z2SE_D07V_ZELDA_SURPRISE = 0x5030A,\n    Z2SE_D07V_MDN_AH = 0x5030B,\n    Z2SE_D07V_HAI_C_WAIT = 0x5030C,\n    Z2SE_D07V_HAI_E_WAIT = 0x5030D,\n    Z2SE_D07V_HAI_F_WAIT = 0x5030E,\n    Z2SE_D07V_HAI_G_WAIT = 0x5030F,\n    Z2SE_D07V_HAI_A_SMOKE = 0x50310,\n    Z2SE_D07V_HAI_C_SMOKE = 0x50311,\n    Z2SE_D07V_HAI_G_SMOKE = 0x50312,\n    Z2SE_D07V_ZELDA_NN = 0x50313,\n    Z2SE_D07V_HAI_B_ATTACK = 0x50314,\n    Z2SE_D07V_HAI_C_ATTACK = 0x50315,\n    Z2SE_D07V_HAI_C_SWING = 0x50316,\n    Z2SE_D07V_HAI_C_COUNTER = 0x50317,\n    Z2SE_D07V_HAI_C_FUMARERU = 0x50318,\n    Z2SE_D07V_ZELDA_AH = 0x50319,\n    Z2SE_D07V_HAI_C_NECK_1 = 0x5031A,\n    Z2SE_D07V_HAI_D_NECK_1 = 0x5031B,\n    Z2SE_D07V_HAI_E_NECK_1 = 0x5031C,\n    Z2SE_D07V_HAI_A_NECK_2 = 0x5031D,\n    Z2SE_D07V_HAI_G_LOOKBACK = 0x5031E,\n    Z2SE_D07V_ZELDA_SUR_OR_DIE = 0x5031F,\n    Z2SE_D07V_MDN_OTTO = 0x50320,\n    Z2SE_D07V_MDN_RIDE_WOLF = 0x50321,\n    Z2SE_D15V_TARO_HEAR_STEP = 0x50322,\n    Z2SE_D15V_BESU_HEAR_STEP = 0x50323,\n    Z2SE_D15V_TARO_LOOK_ENEMY = 0x50324,\n    Z2SE_D15V_BESU_LOOK_ENEMY = 0x50325,\n    Z2SE_D15V_TARO_BREATH = 0x50326,\n    Z2SE_D15V_KOLIN_LOOK_ENEMY = 0x50327,\n    Z2SE_D15V_KOLIN_MAYOI = 0x50328,\n    Z2SE_D15V_KOLIN_KETSUI = 0x50329,\n    Z2SE_D15V_KOLIN_ATTACK = 0x5032A,\n    Z2SE_D15V_BESU_TAORERU = 0x5032B,\n    Z2SE_D15V_BANS_APPEAR = 0x5032C,\n    Z2SE_D15V_BANS_MENOMAE = 0x5032D,\n    Z2SE_D15V_BANS_DOWNMASK = 0x5032E,\n    Z2SE_D06V_MDN_AKUBI = 0x5032F,\n    Z2SE_D29V_GANON_BREATH_T1 = 0x50330,\n    Z2SE_D29V_GANON_BREATH_L1 = 0x50331,\n    Z2SE_D29V_GANON_BREATH_T2 = 0x50332,\n    Z2SE_D29V_GANON_BREATH_L2 = 0x50333,\n    Z2SE_D06V_MDN_KIAI = 0x50334,\n    Z2SE_D22V_WLF_LONG_BARK = 0x50335,\n    Z2SE_MIDNA_APPEAR = 0x60000,\n    Z2SE_MIDNA_DISAPPEAR = 0x60001,\n    Z2SE_CAT_SWIM = 0x60002,\n    Z2SE_BIRD_FLYING = 0x60003,\n    Z2SE_BIRD_STAY = 0x60004,\n    Z2SE_CHICKEN_WING = 0x60005,\n    Z2SE_GORON_PUNCHWIND = 0x60006,\n    Z2SE_GORON_TO_STONE = 0x60007,\n    Z2SE_GORON_TREMBLE = 0x60008,\n    Z2SE_GORON_RECOVER = 0x60009,\n    JA_SE_CM_MONS_EXPLODE = 0x6000A,\n    Z2SE_MIDNA_JUMP = 0x6000B,\n    Z2SE_CSL_TOWN_BAND_GT_1 = 0x6000C,\n    Z2SE_CSL_TOWN_BAND_GT_2 = 0x6000D,\n    Z2SE_CSL_TOWN_BAND_GT_3 = 0x6000E,\n    Z2SE_CSL_TOWN_BAND_FLUTE = 0x6000F,\n    JA_SE_CM_MAGBALL_BOUND = 0x60010,\n    Z2SE_CSL_TOWN_BAND_VOCAL = 0x60011,\n    JA_SE_CM_CUT_GRASS = 0x60012,\n    Z2SE_KN_BALL_LEVEL = 0x60013,\n    Z2SE_TKC_WARP_IN = 0x60014,\n    Z2SE_TKC_WARP_OUT = 0x60015,\n    Z2SE_TKS_SHOW_UP = 0x60016,\n    Z2SE_TKS_HIDE = 0x60017,\n    Z2SE_TKS_BOUND = 0x60018,\n    Z2SE_TKJ_FOOTNOTE = 0x60019,\n    Z2SE_ZELDA_ARROW_DRAW = 0x6001A,\n    Z2SE_ZELDA_ARROW_SHOT = 0x6001B,\n    Z2SE_ZELDA_ARROW_FLY = 0x6001C,\n    Z2SE_ZELDA_ARROW_HIT = 0x6001D,\n    Z2SE_MIDNA_JUMP_FINISH = 0x6001E,\n    Z2SE_KOSARU_FOOTNOTE = 0x6001F,\n    Z2SE_KOSARU_JUMP_START = 0x60020,\n    Z2SE_KOSARU_JUMP_END = 0x60021,\n    Z2SE_KOSARU_HAND_CLAP = 0x60022,\n    Z2SE_KOSARU_FALL_GROUND = 0x60023,\n    Z2SE_KOSARU_JUMP_WIND = 0x60024,\n    Z2SE_KOSARU_ATTACK_POLL = 0x60025,\n    Z2SE_KOSARU_ROLL = 0x60026,\n    Z2SE_KOSARU_CLIMB = 0x60027,\n    Z2SE_DARK_VANISH = 0x60028,\n    Z2SE_MIDNA_BIND_LOCK_ON = 0x60029,\n    Z2SE_MIDNA_BIND_LOCK_SUS = 0x6002A,\n    Z2SE_CM_BODYFALL_S = 0x6002B,\n    Z2SE_CM_BODYFALL_M = 0x6002C,\n    Z2SE_CM_BODYFALL_L = 0x6002D,\n    Z2SE_CM_BODYFALL_ASASE_S = 0x6002E,\n    Z2SE_CM_BODYFALL_ASASE_M = 0x6002F,\n    Z2SE_CM_BODYFALL_ASASE_L = 0x60030,\n    Z2SE_CM_BODYFALL_WATER_S = 0x60031,\n    Z2SE_CM_BODYFALL_WATER_M = 0x60032,\n    Z2SE_CM_BODYFALL_WATER_L = 0x60033,\n    Z2SE_CM_KAZAKIRI_S = 0x60034,\n    Z2SE_CM_KAZAKIRI_M = 0x60035,\n    Z2SE_CM_KAZAKIRI_L = 0x60036,\n    Z2SE_HORSE_BODYHIT = 0x60037,\n    Z2SE_HORSE_SUDDEN_STOP = 0x60038,\n    Z2SE_HAWK_WING = 0x60039,\n    Z2SE_HAWK_GLIDE = 0x6003A,\n    Z2SE_HAWK_HOVER = 0x6003B,\n    Z2SE_HAWK_LANDING = 0x6003C,\n    Z2SE_MK_ROPE_SWING = 0x6003D,\n    Z2SE_MK_DARK_BOOMERANG = 0x6003E,\n    Z2SE_MK_DARK_BOOM_RESUME = 0x6003F,\n    Z2SE_MK_DARK_INSECT_DEATH = 0x60040,\n    Z2SE_KOSARU_FT_BRIDGE = 0x60041,\n    Z2SE_KOSARU_SWIM = 0x60042,\n    Z2SE_TKJ_WING = 0x60043,\n    Z2SE_TKC_WING = 0x60044,\n    Z2SE_LINKBIRD_CRY = 0x60045,\n    Z2SE_LINKBIRD_WING = 0x60046,\n    Z2SE_MOI_STIFF_SHOULDER = 0x60047,\n    Z2SE_MOI_BELT_TIGHTEN_UP = 0x60048,\n    Z2SE_MOI_HOLD_SWORD = 0x60049,\n    Z2SE_GORON_ROLLING = 0x6004A,\n    Z2SE_GORON_ROLL_BOUND = 0x6004B,\n    Z2SE_SUMO_HARITE_HIT = 0x6004C,\n    Z2SE_SUMO_TUCKLE_HIT = 0x6004D,\n    Z2SE_COACH_WHEEL_ROLL_A = 0x6004E,\n    Z2SE_COACH_WHEEL_ROLL_B = 0x6004F,\n    Z2SE_COACH_SHAKE = 0x60050,\n    Z2SE_COACH_FIRE = 0x60051,\n    Z2SE_COACH_HIT_ARROW = 0x60052,\n    Z2SE_COACH_HIT_WIND = 0x60053,\n    Z2SE_BHANDS_HIT_TABLE = 0x60054,\n    Z2SE_LINK_COVER_WATER = 0x60055,\n    Z2SE_DUCK_INTO_WTR = 0x60056,\n    Z2SE_DUCK_SWIM = 0x60057,\n    Z2SE_DUCK_SING = 0x60058,\n    Z2SE_DUCK_SING_S = 0x60059,\n    Z2SE_DUCK_CRY = 0x6005A,\n    Z2SE_DUCK_CRY_S = 0x6005B,\n    Z2SE_HENA_CLAP = 0x6005C,\n    Z2SE_BANS_SHOVEL = 0x6005D,\n    Z2SE_BANS_SHOVEL2 = 0x6005E,\n    Z2SE_BANS_KICK = 0x6005F,\n    Z2SE_CSTATUE_HIT_BALL = 0x60060,\n    Z2SE_CSTATUE_ACTIVE_LOOP = 0x60061,\n    Z2SE_CSTATUE_S_START = 0x60062,\n    Z2SE_CSTATUE_S_STOP = 0x60063,\n    Z2SE_CSTATUE_S_WALK_A = 0x60064,\n    Z2SE_CSTATUE_S_BOUND = 0x60065,\n    Z2SE_CSTATUE_L_START = 0x60066,\n    Z2SE_CSTATUE_L_STOP = 0x60067,\n    Z2SE_CSTATUE_L_WALK_A = 0x60068,\n    Z2SE_CSTATUE_L_BOUND = 0x60069,\n    Z2SE_CSTATUE_L_WAKEUP = 0x6006A,\n    Z2SE_CSTATUE_L_WAKEUP_D = 0x6006B,\n    Z2SE_CSTATUE_L_SWING_UP = 0x6006C,\n    Z2SE_CSTATUE_L_SWING_DOWN = 0x6006D,\n    Z2SE_CSTATUE_L_RESET_ARM = 0x6006E,\n    Z2SE_CSTATUE_L_REBOUND = 0x6006F,\n    Z2SE_CSTATUE_S_WALK_B = 0x60070,\n    Z2SE_CSTATUE_L_WALK_B = 0x60071,\n    Z2SE_CSTATUE_F_WALK_A = 0x60072,\n    Z2SE_CSTATUE_F_WALK_B = 0x60073,\n    Z2SE_CSTATUE_F_BOUND = 0x60074,\n    Z2SE_KLN_HIHI_OP = 0x60075,\n    Z2SE_KLN_HIHI_CLAP = 0x60076,\n    Z2SE_KLN_HIHI_CLTH = 0x60077,\n    Z2SE_KLN_HIHI_HAND = 0x60078,\n    Z2SE_KYR_CLN_DISH = 0x60079,\n    Z2SE_MOI_SWD_FURI = 0x6007A,\n    Z2SE_POUYA_RECOVER_FADE = 0x6007B,\n    Z2SE_ZELDA_ARROW_READY = 0x6007C,\n    Z2SE_TRL_FLAP = 0x6007D,\n    Z2SE_TRL_SING_HPY = 0x60080,\n    Z2SE_TRL_SING_ANGRY = 0x60081,\n    Z2SE_TRL_LIGHT_ON = 0x60082,\n    Z2SE_TRL_SURIASHI = 0x60083,\n    Z2SE_G_WLF_ATK = 0x60084,\n    Z2SE_G_WLF_UNARU = 0x60085,\n    Z2SE_YM_SNOBO_RIDE = 0x60086,\n    Z2SE_YM_SNOBO_JUMP = 0x60087,\n    Z2SE_YM_SNOBO_LAND = 0x60088,\n    Z2SE_YM_SNOBO_SPIN = 0x60089,\n    Z2SE_YW_SNOBO_RIDE = 0x6008A,\n    Z2SE_YW_SNOBO_JUMP = 0x6008B,\n    Z2SE_YW_SNOBO_LAND = 0x6008C,\n    Z2SE_YW_SNOBO_SPIN = 0x6008D,\n    Z2SE_YM_ATTACK_TREE = 0x6008E,\n    Z2SE_YM_FISH = 0x6008F,\n    Z2SE_GORON_CHILD_SITDOWN = 0x60090,\n    Z2SE_YAMI_TRANSFORM_S = 0x60091,\n    Z2SE_YAMI_TRANSFORM_D = 0x60092,\n    Z2SE_YAMI_TRANSFORM_T = 0x60093,\n    Z2SE_GRA_SPA_RLX_A_1 = 0x60094,\n    Z2SE_GRA_SPA_RLX_A_2 = 0x60095,\n    Z2SE_GRA_SPA_RLX_B_1 = 0x60096,\n    Z2SE_GRA_SPA_RLX_B_2 = 0x60097,\n    Z2SE_ZRZ_MV = 0x60098,\n    Z2SE_NPC_SNOW_WALK = 0x60099,\n    Z2SE_YK_WALK = 0x6009A,\n    Z2SE_YK_LARGE_WALK = 0x6009B,\n    Z2SE_GRZ_ROCK_PUNCH = 0x6009C,\n    Z2SE_GRZ_ROCK_BREAK = 0x6009D,\n    Z2SE_RACA_CLAP = 0x6009E,\n    Z2SE_MDN_WARP_MAGIC = 0x6009F,\n    Z2SE_MDN_WARP_IN_TATE = 0x600A0,\n    Z2SE_MDN_WARP_IN_YOKO = 0x600A1,\n    Z2SE_A_MDN_WARP_IN_YOKO = 0x600A2,\n    Z2SE_INSCT_KIRA = 0x600A3,\n    Z2SE_INSCT_BTBT = 0x600A4,\n    Z2SE_INSCT_KSKS = 0x600A5,\n    Z2SE_TOBY_REPAIR_A = 0x600A6,\n    Z2SE_TOBY_REPAIR_B = 0x600A7,\n    Z2SE_TOBY_REPAIR_C = 0x600A8,\n    Z2SE_KOSARU_FT_TSUTA = 0x600A9,\n    Z2SE_KOSARU_KANTERA_SWING = 0x600AA,\n    Z2SE_KOSARU_KANTERA_ADD = 0x600AB,\n    Z2SE_KOSARU_KANTERA_FALL = 0x600AC,\n    Z2SE_POUYA_TORIDASU = 0x600AD,\n    Z2SE_POUYA_TORIDASU_2 = 0x600AE,\n    Z2SE_POSTMAN_PUT_LETTER = 0x600AF,\n    Z2SE_THEB_WIP = 0x600B0,\n    Z2SE_THEB_WIP_B = 0x600B1,\n    Z2SE_GRA_ATK_AT_THE = 0x600B2,\n    Z2SE_GZ_NE_JUMP = 0x600B3,\n    Z2SE_GZ_NE_KNKN = 0x600B4,\n    Z2SE_M_GENERAL_CLAP = 0x600B5,\n    Z2SE_SHOE_MUNE_TATAKU = 0x600B6,\n    Z2SE_GRA_A_DRINK = 0x600B7,\n    Z2SE_CLERKB_MOONWALK_TURN = 0x600B8,\n    Z2SE_ASHB_MASKOFF = 0x600B9,\n    Z2SE_ASHB_HAND = 0x600BA,\n    Z2SE_MOI_KABUTO_OFF = 0x600BB,\n    Z2SE_MOI_KABUTO_ON = 0x600BC,\n    Z2SE_MDN_ESCAPE_HOLE_OP = 0x600BD,\n    Z2SE_FAIRY_STAY = 0x600BE,\n    Z2SE_FAIRY_HANE_OP = 0x600BF,\n    Z2SE_FAIRY_HANE_STAY = 0x600C0,\n    Z2SE_FAIRY_STANDUP = 0x600C1,\n    Z2SE_FAIRY_WALK = 0x600C2,\n    Z2SE_INS_SEARCH = 0x600C3,\n    Z2SE_ZRA_DIVE_SPLASH = 0x600C4,\n    Z2SE_ZRA_SWIM = 0x600C5,\n    Z2SE_ZRA_SWIM_B = 0x600C6,\n    Z2SE_ZRA_SWIM_TURN = 0x600C7,\n    Z2SE_ZRA_FLOAT = 0x600C8,\n    Z2SE_ZRA_FLOAT_B = 0x600C9,\n    Z2SE_ZRA_WAIT_SWIM = 0x600CA,\n    Z2SE_ZRA_DIVE = 0x600CB,\n    Z2SE_ZRA_DIVE_B = 0x600CC,\n    Z2SE_ZRA_TOBIKOMI_S = 0x600CD,\n    Z2SE_SEKI_YARI = 0x600CE,\n    Z2SE_SEKI_ST_DEMO = 0x600CF,\n    Z2SE_SEKI_END_DEMO_1 = 0x600D0,\n    Z2SE_GIRLS_HEART = 0x600D2,\n    Z2SE_YM_SCRATCH = 0x600D3,\n    Z2SE_YM_RIDE_LEAF = 0x600D4,\n    Z2SE_ZRA_DIVE_SPLASH_OUT = 0x600D5,\n    Z2SE_FAIRY_S_LV = 0x600D6,\n    Z2SE_FAIRY_S_FLY = 0x600D7,\n    Z2SE_FAIRY_S_FLY_RTT = 0x600D8,\n    Z2SE_YM_HIT_STOMACH = 0x600D9,\n    Z2SE_YM_SNIFF = 0x600DA,\n    Z2SE_SEKI_JUMP_LAND = 0x600DB,\n    Z2SE_SEKI_JUMP_COL = 0x600DC,\n    Z2SE_SEKI_END_DEMO_2 = 0x600DD,\n    Z2SE_MDN_HIP = 0x600DE,\n    Z2SE_MDN_HIP_WTR = 0x600DF,\n    Z2SE_MDN_LAND = 0x600E0,\n    Z2SE_MDN_LAND_WTR = 0x600E1,\n    Z2SE_MDN_MV = 0x600E2,\n    Z2SE_MDN_HAIR_LEAD = 0x600E3,\n    Z2SE_MDN_TWPULL = 0x600E4,\n    Z2SE_MDN_HAIR_OP = 0x600E5,\n    Z2SE_MDN_HAIR_CL = 0x600E6,\n    Z2SE_MDN_TAKES = 0x600E7,\n    Z2SE_MDN_PACKAWAY = 0x600E8,\n    Z2SE_MDN_HAND = 0x600E9,\n    Z2SE_MDN_HAND_WTR = 0x600EA,\n    Z2SE_MDN_LEG = 0x600EB,\n    Z2SE_MDN_LEG_WTR = 0x600EC,\n    Z2SE_D13_BANS_MASK_UP = 0x600ED,\n    Z2SE_D13_BANS_MASK_DOWN = 0x600EE,\n    Z2SE_D13_BANS_MASK_FALL = 0x600EF,\n    Z2SE_G_WLF_BREATH = 0x600F0,\n    Z2SE_G_WLF_JUMP = 0x600F1,\n    Z2SE_G_WLF_TRANSFORM = 0x600F2,\n    Z2SE_D07_ZANT_FOOTSET = 0x600F3,\n    Z2SE_D30_SEIREI = 0x600F4,\n    Z2SE_D30_WIND = 0x600F5,\n    Z2SE_D30_NAMIDA = 0x600F6,\n    Z2SE_D32_KENJA_APPEAR = 0x600F7,\n    Z2SE_D32_HORSE = 0x600FD,\n    Z2SE_D32_KENJA_DIE = 0x600FE,\n    Z2SE_D32_KENJA_MIRROR = 0x600FF,\n    Z2SE_D25_MDN_HAIR_UP = 0x60101,\n    Z2SE_D25_MDN_HAIR_EXTEND = 0x60103,\n    Z2SE_D25_MDN_HAIR_SHORTEN = 0x60104,\n    Z2SE_D26_MDN_TRANSFORM = 0x60105,\n    Z2SE_D26_MDN_JINARI = 0x60106,\n    Z2SE_D26_MJN_FN = 0x60107,\n    Z2SE_D26_MJN_LAND = 0x60108,\n    Z2SE_D26_MJN_FN_SUBERI = 0x60109,\n    Z2SE_D27_MDN_TRANSFORM = 0x6010D,\n    Z2SE_D27_MJN_EXTEND = 0x6010E,\n    Z2SE_D28_MDN_LIGHT = 0x6010F,\n    Z2SE_D28_ZLD_LIGHT = 0x60110,\n    Z2SE_D28_LZ_WARP_IN = 0x60111,\n    Z2SE_D28_MDN_TRANSFORM = 0x60112,\n    Z2SE_D28_MJN_MV_UP = 0x60113,\n    Z2SE_D28_LZ_WARP_OUT = 0x60114,\n    Z2SE_D28_LZ_WARP_SEIREI = 0x60115,\n    Z2SE_SEI_GEM_A = 0x60116,\n    Z2SE_SEI_GEM_B = 0x60117,\n    Z2SE_SEI_GEM_C = 0x60118,\n    Z2SE_SEI_GEM_D = 0x60119,\n    Z2SE_SEKI_OFF = 0x6011A,\n    Z2SE_D21_ZLD_TF_1 = 0x6011B,\n    Z2SE_D21_ZLD_TF_2 = 0x6011C,\n    Z2SE_D21_ZLD_LIGHT = 0x6011D,\n    Z2SE_D21_MDN_LIGHT = 0x6011E,\n    Z2SE_D21_ZLD_TRANSPARENT = 0x6011F,\n    Z2SE_D24_KENJA_STAY = 0x60120,\n    Z2SE_D24_KENJA_OUT = 0x60121,\n    Z2SE_SEI_APPEAR_HEAD = 0x60122,\n    Z2SE_D09_SEI_APPEAR = 0x60123,\n    Z2SE_SEI_A_ENERGY = 0x60124,\n    Z2SE_D09_SEI_VANISH = 0x60125,\n    Z2SE_D09_SEI_AWAY = 0x60126,\n    Z2SE_D11_MDN_LAND_WTR = 0x60127,\n    Z2SE_D11_MDN_AWAY = 0x60128,\n    Z2SE_D11_SEI_APPEAR_HEAD = 0x60129,\n    Z2SE_SEI_B_ENERGY = 0x6012B,\n    Z2SE_SEI_C_ENERGY = 0x6012C,\n    Z2SE_D14_SEI_WING = 0x6012D,\n    Z2SE_D14_SEI_AWAY_HEAD = 0x6012E,\n    Z2SE_D18_MDN_LAND = 0x6012F,\n    Z2SE_D18_MDN_LAND_BK = 0x60130,\n    Z2SE_D18_MDN_AWAY = 0x60131,\n    Z2SE_D18_SEI_APPEAR = 0x60132,\n    Z2SE_D18_SEI_SWIM = 0x60133,\n    Z2SE_D18_SEI_APPEAR_2 = 0x60134,\n    Z2SE_SEI_D_ENERGY = 0x60135,\n    Z2SE_D18_YLA_APPEAR = 0x60136,\n    Z2SE_D18_D_AL_ENERGY_COME = 0x60139,\n    Z2SE_D18_AL_VANISH = 0x6013A,\n    Z2SE_D18_SEI_GEMS_APPEAR = 0x6013B,\n    Z2SE_D20_SEI_APPEAR_1 = 0x6013C,\n    Z2SE_D20_SEI_APPEAR_2 = 0x60143,\n    Z2SE_D20_MDN_WARP_EXIT = 0x60144,\n    Z2SE_D20_WLF_WARP_OUT = 0x60145,\n    Z2SE_D20_WLF_FALL = 0x60146,\n    Z2SE_D06_MDN_JUMP_1 = 0x60147,\n    Z2SE_D06_MDN_JUMP_2 = 0x60148,\n    Z2SE_D06_MDN_BUBBLE = 0x60149,\n    Z2SE_D24_MDN_FOOT = 0x6014A,\n    Z2SE_D08_MDN_OUT_WINDOW = 0x6014B,\n    Z2SE_D08_MDN_FR_IN = 0x6014C,\n    Z2SE_D08_MDN_WARP = 0x6014D,\n    Z2SE_D10_MDN_MAGIC = 0x6014E,\n    Z2SE_D07_MDN_TOUCH_WOLF = 0x6014F,\n    Z2SE_D07_PEOPLE_TW = 0x60150,\n    Z2SE_D07_Z_TAKE_HOOD = 0x60151,\n    Z2SE_D15_BANS_HELM_DW = 0x60152,\n    Z2SE_D06_MDN_MAGIC = 0x60153,\n    Z2SE_CSTATUE_GM_HIT_BALL = 0x60154,\n    Z2SE_CSTATUE_GM_START = 0x60155,\n    Z2SE_CSTATUE_GM_ACTIVE_LP = 0x60156,\n    Z2SE_CSTATUE_GM_STOP = 0x60157,\n    Z2SE_CSTATUE_GM_SWING_DOWN = 0x60158,\n    Z2SE_CSTATUE_GM_HIT_GROUND = 0x60159,\n    Z2SE_CSTATUE_GM_RESET_ARM = 0x6015A,\n    Z2SE_CSTATUE_GM_MOVE_STOP = 0x6015B,\n    Z2SE_CSTATUE_SEAL_VANISH = 0x6015C,\n    Z2SE_D04_CONNECTED_CHAIN = 0x6015D,\n    Z2SE_D06_WOLF_ONLY_CHAIN = 0x6015E,\n    Z2SE_SARU_CHAIN_DEMO = 0x6015F,\n    Z2SE_SARU_CHAIN_SWING = 0x60160,\n    Z2SE_EN_SINEWAVE = 0x70000,\n    Z2SE_EN_FM_FOOTNOTE = 0x70001,\n    Z2SE_EN_FM_BLAST = 0x70002,\n    Z2SE_EN_FM_BUN = 0x70003,\n    Z2SE_EN_FM_CHAIN_FOOTNOTE = 0x70004,\n    Z2SE_EN_FM_CHAIN_HIKIZURI = 0x70005,\n    Z2SE_EN_FM_V_BLAST_GAOO = 0x70006,\n    Z2SE_EN_FM_V_DAMAGE = 0x70007,\n    Z2SE_EN_FM_V_GAOO_LONG = 0x70008,\n    Z2SE_EN_FM_V_UDEHURI = 0x70009,\n    Z2SE_EN_FM_HOTAIR = 0x7000A,\n    Z2SE_EN_FM_BURNING = 0x7000B,\n    Z2SE_EN_FM_V_GAOO_SHORT = 0x7000C,\n    Z2SE_EN_NS_UDEHURI = 0x7000D,\n    Z2SE_EN_NS_FALLTREE = 0x7000E,\n    Z2SE_EN_NS_DOSA = 0x7000F,\n    Z2SE_EN_NS_V_DAMAGE = 0x70010,\n    Z2SE_EN_NS_V_DEATH = 0x70011,\n    Z2SE_EN_RD_SWING_CLUB = 0x70012,\n    Z2SE_EN_RD_V_DAMAGE = 0x70013,\n    Z2SE_EN_RD_V_DEATH = 0x70014,\n    Z2SE_EN_RD_V_SNIPED_DAMAGE = 0x70015,\n    Z2SE_EN_RD_V_SNIPED_FALLING = 0x70016,\n    Z2SE_EN_RD_V_SHOT_ARROW = 0x70017,\n    Z2SE_EN_RD_V_RIDING_YELL = 0x70018,\n    Z2SE_EN_RD_V_DODGE = 0x70019,\n    Z2SE_EN_RD_V_FIND_LINK_YELL = 0x7001A,\n    Z2SE_EN_RD_V_COMMANDER = 0x7001B,\n    Z2SE_EN_RD_V_NOTICE = 0x7001C,\n    Z2SE_EN_RD_V_LAKE_APPEAR = 0x7001D,\n    Z2SE_EN_SF_V_FIRST_DEMO = 0x7001F,\n    Z2SE_EN_DN_V_DAMAGE = 0x70021,\n    Z2SE_EN_DN_V_DEATH = 0x70022,\n    Z2SE_EN_HG_V_D28_STAND = 0x70024,\n    Z2SE_EN_HG_V_D28_STANDTURN = 0x70025,\n    Z2SE_EN_KR_WING = 0x70027,\n    Z2SE_EN_KR_V_DAMAGE = 0x70028,\n    Z2SE_EN_KR_V_DEATH = 0x70029,\n    Z2SE_EN_KR_V_ATTACK = 0x7002A,\n    Z2SE_EN_KR_V_NAKU = 0x7002B,\n    Z2SE_EN_KR_V_FURA = 0x7002C,\n    Z2SE_EN_KR_V_FIND = 0x7002D,\n    Z2SE_EN_KR_FALLDOWN = 0x7002E,\n    Z2SE_EN_KR_GLIDE = 0x7002F,\n    Z2SE_EN_KR_V_DAMAGE_S = 0x70030,\n    Z2SE_EN_KR_V_DOWN = 0x70031,\n    Z2SE_EN_KR_V_ATTACK2 = 0x70032,\n    Z2SE_EN_KR_V_AWAKE = 0x70033,\n    Z2SE_EN_RD_V_WAND_ATTACK = 0x70034,\n    Z2SE_EN_RD_V_READY_WEAPON = 0x70035,\n    Z2SE_EN_RD_V_RUNNING_BREATH = 0x70036,\n    Z2SE_EN_RD_V_CALLING = 0x70037,\n    Z2SE_EN_RD_V_JUMP_RIDING = 0x70038,\n    Z2SE_EN_DN_FN_L = 0x70039,\n    Z2SE_EN_DN_FN_R = 0x7003A,\n    Z2SE_EN_DN_FN_RUN_L = 0x7003B,\n    Z2SE_EN_DN_FN_RUN_R = 0x7003C,\n    Z2SE_EN_DN_TAIL = 0x7003D,\n    Z2SE_EN_DN_V_TAIL = 0x7003E,\n    Z2SE_EN_DN_V_FIND = 0x7003F,\n    Z2SE_EN_DN_KNIFE = 0x70040,\n    Z2SE_EN_DN_V_KNIFE = 0x70041,\n    Z2SE_EN_DN_KNIFE2_A = 0x70042,\n    Z2SE_EN_DN_KNIFE2_B = 0x70043,\n    Z2SE_EN_DN_V_KNIFE2_A = 0x70044,\n    Z2SE_EN_DN_V_BREATH = 0x70045,\n    Z2SE_EN_DN_V_GUARD = 0x70046,\n    Z2SE_EN_DN_V_JUMP = 0x70047,\n    Z2SE_EN_DN_V_SEARCH = 0x70048,\n    Z2SE_EN_DN_V_SEARCH2 = 0x70049,\n    Z2SE_EN_DN_V_DRAWBACK = 0x7004A,\n    Z2SE_EN_DN_V_UP = 0x7004B,\n    Z2SE_EN_DN_V_AWAKE = 0x7004C,\n    Z2SE_EN_DN_V_DAMAGE2 = 0x7004D,\n    Z2SE_EN_DN_V_SURPRIZE = 0x7004E,\n    Z2SE_EN_DN_V_FIND_BOMB = 0x7004F,\n    Z2SE_EN_DN_V_LOOK_BOMB = 0x70050,\n    Z2SE_EN_DN_V_KICK_BOMB = 0x70051,\n    Z2SE_EN_ZAN_DEMO_FOOT = 0x70052,\n    Z2SE_EN_PM_V_LAUGH = 0x70055,\n    Z2SE_EN_PM_V_DAMAGE = 0x70056,\n    Z2SE_EN_PM_V_DEATH = 0x70057,\n    Z2SE_EN_PM_FADEIN = 0x70058,\n    Z2SE_EN_PM_FADEOUT = 0x70059,\n    Z2SE_EN_PM_TRUMPET = 0x7005A,\n    Z2SE_EN_PM_MOVE = 0x7005B,\n    Z2SE_EN_PM_LAMP_FALL = 0x7005C,\n    Z2SE_EN_FM_YUGE = 0x7005D,\n    Z2SE_EN_FM_DOWNSPLASH = 0x7005E,\n    Z2SE_EN_FM_DOWNYUGE = 0x7005F,\n    Z2SE_EN_FM_CHAIN_HIT = 0x70060,\n    Z2SE_EN_FM_CHAIN_CUTOFF = 0x70061,\n    Z2SE_EN_AI_DOSU = 0x70062,\n    Z2SE_EN_AI_HAMMER = 0x70063,\n    Z2SE_EN_AI_GURAGURA = 0x70064,\n    Z2SE_EN_AI_V_AWAKE = 0x70065,\n    Z2SE_EN_AI_V_DAMAGE = 0x70066,\n    Z2SE_EN_AI_V_HAMMER = 0x70067,\n    Z2SE_EN_AI_V_MOGAKU = 0x70068,\n    Z2SE_EN_MK_V_BREATH = 0x70069,\n    Z2SE_EN_MK_V_THROW_BOOM = 0x7006A,\n    Z2SE_EN_MK_V_CATCH_BOOM = 0x7006B,\n    Z2SE_EN_MK_V_DAMAGE = 0x7006C,\n    Z2SE_EN_MK_V_DAMAGE_L = 0x7006D,\n    Z2SE_EN_MK_V_DEAD = 0x7006E,\n    Z2SE_EN_MK_V_PROVOKE_A = 0x7006F,\n    Z2SE_EN_MK_V_PROVOKE_B = 0x70070,\n    Z2SE_EN_MK_V_JUMP = 0x70071,\n    Z2SE_EN_MK_V_SNEER = 0x70072,\n    Z2SE_EN_MK_V_HIT_BOOM = 0x70073,\n    Z2SE_EN_MK_V_DOWN = 0x70074,\n    Z2SE_EN_MK_V_AWAKE = 0x70075,\n    Z2SE_EN_MK_V_LOOSE_BALANCE = 0x70076,\n    Z2SE_EN_MK_FOOTNOTE = 0x70077,\n    Z2SE_EN_MK_JUMP_START = 0x70078,\n    Z2SE_EN_MK_JUMP_END = 0x70079,\n    Z2SE_EN_MK_FALL_GROUND = 0x7007A,\n    Z2SE_EN_MK_BOOM_FLY = 0x7007B,\n    Z2SE_EN_MK_CATCH_BOOM = 0x7007C,\n    Z2SE_EN_MK_JUMP_WIND = 0x7007D,\n    Z2SE_EN_MK_CRAWL = 0x7007E,\n    Z2SE_EN_MK_SCRATCH_HIP = 0x7007F,\n    Z2SE_EN_DB_GRASS = 0x70080,\n    Z2SE_EN_DB_V_CREEP = 0x70081,\n    Z2SE_EN_DB_ATTACK = 0x70082,\n    Z2SE_EN_DB_V_ATTACK = 0x70083,\n    Z2SE_EN_DB_V_DAMAGE = 0x70084,\n    Z2SE_EN_DB_V_DAMAGE_S = 0x70085,\n    Z2SE_EN_DB_V_DEATH = 0x70086,\n    Z2SE_EN_DB_V_WAIT = 0x70087,\n    Z2SE_EN_DB_V_FAINT = 0x70088,\n    Z2SE_EN_DB_V_AWAKE = 0x70089,\n    Z2SE_EN_DB_V_CUT = 0x7008A,\n    Z2SE_EN_DB_BERON = 0x7008B,\n    Z2SE_EN_DB_APPEAR = 0x7008C,\n    Z2SE_EN_DB_HIKKOMU = 0x7008D,\n    Z2SE_EN_SF_V_ATTACK = 0x7008E,\n    Z2SE_EN_SF_V_NOTICE = 0x7008F,\n    Z2SE_EN_SF_V_GUARD = 0x70090,\n    Z2SE_EN_SF_V_DRAWBACK = 0x70091,\n    Z2SE_EN_SF_V_DAMAGE = 0x70092,\n    Z2SE_EN_SF_V_FALLDOWN = 0x70093,\n    Z2SE_EN_SF_V_RESURRECTION = 0x70094,\n    Z2SE_EN_SF_BUILD_UP = 0x70095,\n    Z2SE_EN_SF_BREAK_DOWN = 0x70096,\n    Z2SE_EN_SF_SHAKE_BONES = 0x70097,\n    Z2SE_EN_SF_SWING_SWORD_L = 0x70098,\n    Z2SE_EN_SF_SWING_SWORD_S = 0x70099,\n    Z2SE_EN_AI_AWAKE = 0x7009A,\n    Z2SE_EN_AI_BREAK_LAST = 0x7009B,\n    Z2SE_EN_AI_HAMMER_HIT = 0x7009C,\n    Z2SE_EN_AI_FLASH = 0x7009D,\n    Z2SE_EN_SH_V_APPEAR = 0x7009E,\n    Z2SE_EN_SH_V_BREATH = 0x7009F,\n    Z2SE_EN_SH_V_ATTACK = 0x700A0,\n    Z2SE_EN_SH_V_DAMAGE = 0x700A1,\n    Z2SE_EN_SH_V_DEAD = 0x700A2,\n    Z2SE_EN_SH_APPEAR = 0x700A3,\n    Z2SE_EN_SH_DISAPPEAR = 0x700A4,\n    Z2SE_EN_SH_DEAD = 0x700A5,\n    Z2SE_EN_ST_SILK = 0x700A6,\n    Z2SE_EN_BA_WING = 0x700A7,\n    Z2SE_EN_GO_FOOTNOTE = 0x700A8,\n    Z2SE_EN_ST_SILK_WRAP = 0x700A9,\n    Z2SE_EN_ST_SILK_CUT = 0x700AA,\n    Z2SE_EN_BS_V_ATTACK = 0x700AB,\n    Z2SE_EN_BS_V_NOTICE = 0x700AC,\n    Z2SE_EN_BS_V_DAMAGE = 0x700AD,\n    Z2SE_EN_BS_V_DEAD = 0x700AE,\n    Z2SE_EN_BS_APPEAR = 0x700AF,\n    Z2SE_EN_BS_DEAD = 0x700B0,\n    Z2SE_EN_BS_SHAKE_BONES = 0x700B1,\n    Z2SE_EN_BS_ATTACK_SPEAR = 0x700B2,\n    Z2SE_EN_BA_V_NAKU = 0x700B3,\n    Z2SE_EN_BA_V_ATTACK = 0x700B4,\n    Z2SE_EN_BA_V_DEATH = 0x700B5,\n    Z2SE_EN_ST_FOOTNOTE = 0x700B6,\n    Z2SE_EN_ST_ATTACK = 0x700B7,\n    Z2SE_EN_ST_V_WAIT = 0x700B8,\n    Z2SE_EN_ST_HUG_ATTACK = 0x700B9,\n    Z2SE_EN_ST_V_DEATH = 0x700BA,\n    Z2SE_EN_ST_JUMP = 0x700BB,\n    Z2SE_EN_ST_JUMPBACK = 0x700BC,\n    Z2SE_EN_KG_ATTACK = 0x700BD,\n    Z2SE_EN_KG_V_ATTACK = 0x700BE,\n    Z2SE_EN_KG_V_DEATH = 0x700BF,\n    Z2SE_EN_KG_V_FIND = 0x700C0,\n    Z2SE_EN_KG_FOOTNOTE = 0x700C1,\n    Z2SE_EN_KG_FALL = 0x700C2,\n    Z2SE_EN_KG_V_WAIT = 0x700C3,\n    Z2SE_EN_NZ_V_NAKU = 0x700C4,\n    Z2SE_EN_NZ_V_DEATH = 0x700C5,\n    Z2SE_EN_NZ_BITE = 0x700C6,\n    Z2SE_EN_NZ_FOOTNOTE = 0x700C7,\n    Z2SE_EN_NZ_FN_WATER = 0x700C8,\n    Z2SE_EN_PO_ATTACK = 0x700C9,\n    Z2SE_EN_PO_V_ATTACK = 0x700CA,\n    Z2SE_EN_PO_V_DEATH = 0x700CB,\n    Z2SE_EN_PO_V_FIND = 0x700CC,\n    Z2SE_EN_PO_V_BIKKURI = 0x700CD,\n    Z2SE_EN_PO_MOVE = 0x700CE,\n    Z2SE_EN_PO_V_DAMAGE = 0x700CF,\n    Z2SE_EN_PO_LAMP = 0x700D0,\n    Z2SE_EN_PO_VISIBLE = 0x700D1,\n    Z2SE_EN_PO_V_LAUGH = 0x700D2,\n    Z2SE_EN_NS_V_AWAKE = 0x700D3,\n    Z2SE_EN_NS_V_HIRUMU = 0x700D4,\n    Z2SE_EN_FS_ATTACK = 0x700D5,\n    Z2SE_EN_FS_DAMAGE = 0x700D6,\n    Z2SE_EN_FS_DEATH = 0x700D7,\n    Z2SE_EN_FS_APPEAR = 0x700D8,\n    Z2SE_EN_FS_POSE = 0x700D9,\n    Z2SE_EN_FS_KUBIKASIGE = 0x700DA,\n    Z2SE_EN_FS_LAND = 0x700DB,\n    Z2SE_EN_FS_LAND_WATER = 0x700DC,\n    Z2SE_EN_PM_FN_L = 0x700DD,\n    Z2SE_EN_PM_FN_R = 0x700DE,\n    Z2SE_EN_PM_FN_WATER_L = 0x700DF,\n    Z2SE_EN_PM_FN_WATER_R = 0x700E0,\n    Z2SE_EN_PM_LAND = 0x700E1,\n    Z2SE_EN_PM_LAND_WATER = 0x700E2,\n    Z2SE_EN_FS_BACKSWING = 0x700E3,\n    Z2SE_EN_FS_MOVE = 0x700E4,\n    Z2SE_EN_PM_V_FOGBLOW = 0x700E5,\n    Z2SE_EN_YM_FOOTNOTE = 0x700E6,\n    Z2SE_EN_YM_DEATH = 0x700E7,\n    Z2SE_EN_YM_MOGAKU = 0x700E8,\n    Z2SE_EN_YM_WAIT = 0x700EA,\n    Z2SE_EN_BI_FOOTNOTE = 0x700EB,\n    Z2SE_EN_BI_WAIT = 0x700EC,\n    Z2SE_EN_BI_APPEAR = 0x700ED,\n    Z2SE_EN_BI_STAND = 0x700EE,\n    Z2SE_EN_BI_CROUCH = 0x700EF,\n    Z2SE_EN_YM_JUMP = 0x700F0,\n    Z2SE_EN_RDB_V_DAMAGE = 0x700F6,\n    Z2SE_EN_RDB_V_DEATH = 0x700F7,\n    Z2SE_EN_RDB_V_HOICK = 0x700F8,\n    Z2SE_EN_RDB_HORN = 0x700F9,\n    Z2SE_EN_NS_FN_L = 0x700FA,\n    Z2SE_EN_NS_FN_R = 0x700FB,\n    Z2SE_EN_NS_HAND_L = 0x700FC,\n    Z2SE_EN_NS_HAND_R = 0x700FD,\n    Z2SE_EN_BH_V_APPEAR = 0x700FE,\n    Z2SE_EN_BH_V_ATTACK = 0x700FF,\n    Z2SE_EN_BH_ATTACK = 0x70100,\n    Z2SE_EN_BH_V_DAMAGE = 0x70101,\n    Z2SE_EN_BH_V_WAIT = 0x70102,\n    Z2SE_EN_BH_V_NODAMAGE = 0x70103,\n    Z2SE_EN_BH_V_EAT = 0x70104,\n    Z2SE_EN_BH_V_ROUT = 0x70105,\n    Z2SE_EN_BH_SPLASH_UP = 0x70106,\n    Z2SE_EN_BH_SPLASH_DOWN = 0x70107,\n    Z2SE_EN_BH_V_AWAKE = 0x70108,\n    Z2SE_EN_BH_BURST = 0x70109,\n    Z2SE_EN_BQ_V_APPEAR = 0x7010A,\n    Z2SE_EN_BQ_V_BARK = 0x7010B,\n    Z2SE_EN_BQ_APPEAR = 0x7010C,\n    Z2SE_EN_BQ_V_WAIT = 0x7010E,\n    Z2SE_EN_BQ_V_BOMBDAMAGE = 0x7010F,\n    Z2SE_EN_BQ_V_DAMAGEWAIT = 0x70110,\n    Z2SE_EN_BQ_V_COREDAMAGE = 0x70111,\n    Z2SE_EN_BQ_V_BACK = 0x70113,\n    Z2SE_EN_BQ_V_DAMAGEBACK = 0x70114,\n    Z2SE_EN_NS_V_ATTACK = 0x70115,\n    Z2SE_EN_NS_V_SEARCH = 0x70116,\n    Z2SE_EN_YM_FALL = 0x70117,\n    Z2SE_EN_NS_V_WAIT = 0x70118,\n    Z2SE_EN_NS_V_ATTACK2 = 0x70119,\n    Z2SE_EN_BQ_DOWN = 0x7011A,\n    Z2SE_EN_YM_ATTACK = 0x7011B,\n    Z2SE_EN_YM_DEFENCE = 0x7011C,\n    Z2SE_EN_YM_FIND = 0x7011D,\n    Z2SE_EN_YM_LAND = 0x7011E,\n    Z2SE_EN_YM_MOVE = 0x7011F,\n    Z2SE_EN_DB_DRY = 0x70120,\n    Z2SE_EN_BB_V_INANAKI = 0x70122,\n    Z2SE_EN_BB_V_START = 0x70123,\n    Z2SE_EN_BE_FLY_D = 0x70124,\n    Z2SE_EN_BE_FLY_GROUP_D = 0x70125,\n    Z2SE_EN_BE_STAY = 0x70126,\n    Z2SE_EN_BE_FLY = 0x70127,\n    Z2SE_EN_BE_DEATH = 0x70128,\n    Z2SE_EN_BE_STAY_GROUP = 0x70129,\n    Z2SE_EN_BE_FLY_GROUP = 0x7012A,\n    Z2SE_EN_BE_GO_HOME = 0x7012B,\n    Z2SE_EN_RDB_V_LAUGH = 0x7012C,\n    Z2SE_EN_RDB_V_FAINT = 0x7012D,\n    Z2SE_EN_RDB_V_AWAKE = 0x7012E,\n    Z2SE_EN_RDB_V_HOICK2 = 0x7012F,\n    Z2SE_EN_BB_V_BREATH = 0x70130,\n    Z2SE_EN_BB_V_BREATH2 = 0x70131,\n    Z2SE_EN_RDB_V_DAMAGE_L = 0x70136,\n    Z2SE_EN_RDB_BREAK_ARMOR = 0x70137,\n    Z2SE_EN_RDB_V_RUNDOWN = 0x70138,\n    Z2SE_EN_BB_RUNDOWN = 0x70139,\n    Z2SE_EN_DB_SHRINK = 0x7013A,\n    Z2SE_EN_BH_ABUKU = 0x7013B,\n    Z2SE_EN_BQ_ABUKU = 0x7013C,\n    Z2SE_EN_BQ_DOKUHAKI = 0x7013D,\n    Z2SE_EN_BQ_DOKUSMOKE = 0x7013E,\n    Z2SE_EN_BQ_V_DOKUHAKI = 0x7013F,\n    Z2SE_EN_BQ_JINARI = 0x70140,\n    Z2SE_EN_BH_JINARI = 0x70141,\n    Z2SE_EN_BQ_V_DEAD = 0x70142,\n    Z2SE_EN_BQ_V_NODAMAGE = 0x70143,\n    Z2SE_EN_BQ_EYE_LAND = 0x70145,\n    Z2SE_EN_BH_V_SP_ATTACK = 0x70146,\n    Z2SE_EN_WS_V_YOKOKU = 0x70147,\n    Z2SE_EN_WS_V_ATTACK = 0x70148,\n    Z2SE_EN_WS_V_DAMAGE = 0x70149,\n    Z2SE_EN_WS_V_DEATH = 0x7014A,\n    Z2SE_EN_WS_FOOTNOTE = 0x7014B,\n    Z2SE_EN_GB_SWINGHEAD = 0x7014C,\n    Z2SE_EN_GB_DROPKEY = 0x7014D,\n    Z2SE_EN_GB_V_ATTACK = 0x7014E,\n    Z2SE_EN_GB_V_ATTACK_DASH = 0x7014F,\n    Z2SE_EN_GB_V_DAMAGE = 0x70150,\n    Z2SE_EN_GB_V_NODAMAGE = 0x70151,\n    Z2SE_EN_GB_V_WAIT = 0x70152,\n    Z2SE_EN_GB_BOMBROOT = 0x70153,\n    Z2SE_EN_GB_V_DIE = 0x70154,\n    Z2SE_EN_GF_WAIT = 0x70155,\n    Z2SE_EN_GF_EAT = 0x70156,\n    Z2SE_EN_GF_BURST = 0x70157,\n    Z2SE_EN_GF_OPEN = 0x70158,\n    Z2SE_EN_GF_CLOSE = 0x70159,\n    Z2SE_EN_GF_BOUND = 0x7015A,\n    Z2SE_EN_GF_BOUND_CLOSE = 0x7015B,\n    Z2SE_EN_GF_DIE = 0x7015C,\n    Z2SE_EN_DB_V_BITE = 0x7015D,\n    Z2SE_EN_DB_V_BITING = 0x7015E,\n    Z2SE_EN_DB_V_RELEASE = 0x7015F,\n    Z2SE_EN_BQ_V_TODOME = 0x70160,\n    Z2SE_EN_ST_V_NODAMAGE = 0x70161,\n    Z2SE_EN_ST_V_ATTACKA = 0x70162,\n    Z2SE_EN_ST_V_ATTACKB = 0x70163,\n    Z2SE_EN_ST_V_ATTACKC = 0x70164,\n    Z2SE_EN_ST_V_DAWNA = 0x70165,\n    Z2SE_EN_ST_V_DAWNB = 0x70166,\n    Z2SE_EN_ST_V_DAWNC = 0x70167,\n    Z2SE_EN_ST_V_DEATH2 = 0x70168,\n    Z2SE_EN_ST_V_DEFENSE = 0x70169,\n    Z2SE_EN_ST_V_HIT = 0x7016A,\n    Z2SE_EN_ST_V_STAND = 0x7016B,\n    Z2SE_EN_ST_V_DEATHA = 0x7016C,\n    Z2SE_EN_ST_SILK_RELEASE = 0x7016D,\n    Z2SE_EN_ST_APPEAR = 0x7016E,\n    Z2SE_EN_BQ_EYE_EXPLODE = 0x7016F,\n    Z2SE_EN_WB_RUNDOWN = 0x70170,\n    Z2SE_EN_ST_SHELL_BREAK = 0x70171,\n    Z2SE_EN_RDB_V_DEMO04_UHM = 0x70172,\n    Z2SE_EN_NS_V_DEMO04_HIPPARU = 0x70173,\n    Z2SE_EN_RDB_V_DEMO04_HORN = 0x70174,\n    Z2SE_EN_RDB_V_DEMO04_LAUGH = 0x70175,\n    Z2SE_EN_RDB_V_DEMO04_WBFN1 = 0x70176,\n    Z2SE_EN_RDB_V_DEMO04_WBFN2 = 0x70177,\n    Z2SE_EN_OC_FOOTNOTE_L = 0x70178,\n    Z2SE_EN_OC_FOOTNOTE_R = 0x70179,\n    Z2SE_EN_OC_V_LEAP_A = 0x7017A,\n    Z2SE_EN_OC_LEAP_B = 0x7017B,\n    Z2SE_EN_OC_V_SEARCH = 0x7017C,\n    Z2SE_EN_OC_V_STAND = 0x7017D,\n    Z2SE_EN_OC_V_FIND = 0x7017E,\n    Z2SE_EN_OC_V_DASH = 0x7017F,\n    Z2SE_EN_OC_V_WAIT = 0x70180,\n    Z2SE_EN_OC_V_DAMAGE = 0x70181,\n    Z2SE_EN_OC_V_DAMAGE_LR = 0x70182,\n    Z2SE_EN_OC_V_CRY = 0x70183,\n    Z2SE_EN_OC_V_ATTACK_B = 0x70184,\n    Z2SE_EN_OC_V_ATTACK_C = 0x70185,\n    Z2SE_EN_OC_V_ATTACK_B2 = 0x70186,\n    Z2SE_EN_OC_V_ATTACK_C2 = 0x70187,\n    Z2SE_EN_OC_ATTACK_B = 0x70188,\n    Z2SE_EN_OC_ATTACK_C = 0x70189,\n    Z2SE_EN_OC_V_TALK = 0x7018A,\n    Z2SE_EN_OC_V_STAND_WAIT = 0x7018B,\n    Z2SE_EN_OC_V_FINISH = 0x7018C,\n    Z2SE_EN_OC_V_WAIT_ST = 0x7018D,\n    Z2SE_EN_OC_V_WALK_ST = 0x7018E,\n    Z2SE_EN_OC_V_TALK_B = 0x7018F,\n    Z2SE_EN_OC_V_LEAP_SPIN = 0x70190,\n    Z2SE_EN_OC_V_DEATH = 0x70191,\n    Z2SE_EN_OC_CLUB_HIT = 0x70192,\n    Z2SE_EN_OC_CLUB_DAGGLE = 0x70193,\n    Z2SE_EN_YM_NEAR = 0x70194,\n    Z2SE_EN_YM_ELECTRIC = 0x70195,\n    Z2SE_EN_YM_ELECTRIC_LOOP = 0x70196,\n    Z2SE_EN_YM_DIG = 0x70197,\n    Z2SE_EN_YM_FN_UNDER = 0x70198,\n    Z2SE_EN_YM_FLY = 0x70199,\n    Z2SE_EN_YM_FLY_ATTACK = 0x7019A,\n    Z2SE_EN_DF_BOUND = 0x7019B,\n    Z2SE_EN_DF_BURST = 0x7019C,\n    Z2SE_EN_DF_DIE = 0x7019D,\n    Z2SE_EN_DF_EAT = 0x7019E,\n    Z2SE_EN_DF_EAT_WAIT = 0x7019F,\n    Z2SE_EN_DF_SPITOUT = 0x701A0,\n    Z2SE_EN_DF_WAIT = 0x701A1,\n    Z2SE_EN_OC_V_GALE = 0x701A2,\n    Z2SE_EN_OC_V_ANGRY_A = 0x701A3,\n    Z2SE_EN_OC_V_ANGRY_B = 0x701A4,\n    Z2SE_EN_OC_V_FALL = 0x701A5,\n    Z2SE_EN_MS_V_NAKU = 0x701A6,\n    Z2SE_EN_MS_V_FIND = 0x701A7,\n    Z2SE_EN_MS_V_DEATH = 0x701A8,\n    Z2SE_EN_MS_BITE = 0x701A9,\n    Z2SE_EN_MS_FOOTNOTE = 0x701AA,\n    Z2SE_EN_MS_FN_WATER = 0x701AB,\n    Z2SE_EN_MS_SWIM = 0x701AC,\n    Z2SE_EN_MS_FALLWATER = 0x701AD,\n    Z2SE_EN_MS_V_DAMAGE = 0x701AE,\n    Z2SE_EN_OC_V_DROWNED = 0x701AF,\n    Z2SE_EN_OC_DROWNED = 0x701B0,\n    Z2SE_EN_OC_V_SAKEBU = 0x701B1,\n    Z2SE_EN_OC_V_JUMP = 0x701B2,\n    Z2SE_EN_NS_V_SHOUT = 0x701B3,\n    Z2SE_EN_YR_V_DEATH = 0x701B4,\n    Z2SE_EN_YR_V_DAMAGE = 0x701B5,\n    Z2SE_EN_YR_V_DAMAGE_S = 0x701B6,\n    Z2SE_EN_YR_V_ATTACK = 0x701B7,\n    Z2SE_EN_YR_V_ATTACK2 = 0x701B8,\n    Z2SE_EN_YR_V_FURA = 0x701B9,\n    Z2SE_EN_YR_WING = 0x701BA,\n    Z2SE_EN_YR_V_NAKU = 0x701BB,\n    Z2SE_EN_YR_V_FIND = 0x701BC,\n    Z2SE_EN_YR_GLIDE = 0x701BD,\n    Z2SE_EN_YR_V_AWAKE = 0x701BE,\n    Z2SE_EN_YR_V_DOWN = 0x701BF,\n    Z2SE_EN_YR_V_DEATH2 = 0x701C0,\n    Z2SE_EN_YR_V_HOVERING = 0x701C1,\n    Z2SE_EN_KR_V_DEATH2 = 0x701C2,\n    Z2SE_EN_BA_V_BITE = 0x701C3,\n    Z2SE_EN_BA_V_DEATH2 = 0x701C4,\n    Z2SE_EN_BA_V_FURA = 0x701C5,\n    Z2SE_EN_BA_FIRE = 0x701C6,\n    Z2SE_EN_YK_WING = 0x701C7,\n    Z2SE_EN_YK_V_NAKU = 0x701C8,            // shadow keese - cry/screech\n    Z2SE_EN_YK_V_ATTACK = 0x701C9,          // shadow keese - attack\n    Z2SE_EN_YK_V_DEATH = 0x701CA,           // shadow keese - death\n    Z2SE_EN_YK_V_BITE = 0x701CB,            // shadow keese - bite\n    Z2SE_EN_YK_V_DEATH2 = 0x701CC,          // shadow keese - death2\n    Z2SE_EN_YK_V_FURA = 0x701CD,            // shadow keese - unsteady\n    Z2SE_EN_BA_V_SPIN = 0x701CE,\n    Z2SE_EN_YK_V_SPIN = 0x701CF,            // shadow keese - spinning in gale boomerang wind\n    Z2SE_EN_YG_V_NAKU = 0x701D0,\n    Z2SE_EN_YG_V_FIND = 0x701D1,\n    Z2SE_EN_YG_V_DEATH = 0x701D2,\n    Z2SE_EN_YG_BITE = 0x701D3,\n    Z2SE_EN_YG_SWIM = 0x701D4,\n    Z2SE_EN_YG_FALLWATER = 0x701D5,\n    Z2SE_EN_YG_V_DAMAGE = 0x701D6,\n    Z2SE_EN_YG_DARK = 0x701D7,\n    Z2SE_EN_YG_FOOTNOTE = 0x701D8,\n    Z2SE_EN_YG_FN_WATER = 0x701D9,\n    Z2SE_EN_YG_JUMP = 0x701DA,\n    Z2SE_EN_BM_BOOT = 0x701DB,\n    Z2SE_EN_BM_UP = 0x701DC,\n    Z2SE_EN_BM_DOWN = 0x701DD,\n    Z2SE_EN_BM_TURN = 0x701DE,\n    Z2SE_EN_BM_BEAM = 0x701DF,\n    Z2SE_EN_BM_EYE_BREAK = 0x701E0,\n    Z2SE_EN_GOB_PROVOKE_KNUCKLES = 0x701E1,\n    Z2SE_EN_GOB_ARM_SWING_WAIT = 0x701E2,\n    Z2SE_EN_GOB_ARM_SWING_ATTACK = 0x701E3,\n    Z2SE_EN_GOB_ARM_DOWN_WIND = 0x701E4,\n    Z2SE_EN_GOB_ARM_DOWN_FLOOR = 0x701E5,\n    Z2SE_EN_GOB_STOMACH_BOUND = 0x701E6,\n    Z2SE_EN_GOB_HIP_DOWN = 0x701E7,\n    Z2SE_EN_GOB_ROLLING = 0x701E8,\n    Z2SE_EN_GOB_ROLLING_BOUND = 0x701E9,\n    Z2SE_EN_GOB_CATCHED_FRICTION = 0x701EA,\n    Z2SE_EN_GOB_KNUCKLE_GROUND = 0x701EB,\n    Z2SE_EN_GOB_MAGMA_JUMP = 0x701EC,\n    Z2SE_EN_GOB_V_JUMP = 0x701ED,\n    Z2SE_EN_GOB_V_ATK_A_READY = 0x701EE,\n    Z2SE_EN_GOB_V_ATK_A_WAIT = 0x701EF,\n    Z2SE_EN_GOB_V_ATK_A = 0x701F0,\n    Z2SE_EN_GOB_V_ATK_B_READY = 0x701F1,\n    Z2SE_EN_GOB_V_ATK_B_WAIT = 0x701F2,\n    Z2SE_EN_GOB_V_ATK_B = 0x701F3,\n    Z2SE_EN_GOB_V_PROVOKE_A = 0x701F4,\n    Z2SE_EN_GOB_V_PROVOKE_B = 0x701F5,\n    Z2SE_EN_GOB_V_DAMAGE = 0x701F6,\n    Z2SE_EN_GOB_V_STOMACH = 0x701F7,\n    Z2SE_EN_GOB_V_HIP_DOWN = 0x701F8,\n    Z2SE_EN_GOB_V_CATCHED_ANNOY = 0x701F9,\n    Z2SE_EN_GOB_V_THROWN = 0x701FA,\n    Z2SE_EN_GOB_V_MAGMA = 0x701FB,\n    Z2SE_EN_GOB_V_RECOVER = 0x701FC,\n    Z2SE_EN_GOB_V_CATCHED = 0x701FD,\n    Z2SE_EN_GOB_V_GUARD = 0x701FE,\n    Z2SE_EN_GOB_V_MAGMA_LAST = 0x701FF,\n    Z2SE_EN_GOB_V_FALL_LAST = 0x70200,\n    Z2SE_EN_GOB_V_GETUP_LAST = 0x70201,\n    Z2SE_EN_GOB_HELMET_OFF = 0x70202,\n    Z2SE_EN_GOB_HELMET_BOUND = 0x70203,\n    Z2SE_EN_GOB_HELMET_MELT = 0x70204,\n    Z2SE_EN_GOB_KNUCKLES_FRICTION = 0x70205,\n    Z2SE_EN_BA_V_FAINT = 0x70206,\n    Z2SE_EN_YK_V_FAINT = 0x70207,               // shadow keese - bouncing on ground during chance\n    Z2SE_EN_HZ_V_WALK = 0x70208,\n    Z2SE_EN_HZ_WALK = 0x70209,\n    Z2SE_EN_HZ_V_WIND_NAKU = 0x7020A,\n    Z2SE_EN_HZ_V_WIND = 0x7020B,\n    Z2SE_EN_HZ_V_JUMP = 0x7020C,\n    Z2SE_EN_HZ_JUMP = 0x7020D,\n    Z2SE_EN_HZ_V_LAUGH = 0x7020E,\n    Z2SE_EN_HZ_V_LANDING = 0x7020F,\n    Z2SE_EN_HZ_LANDING = 0x70210,\n    Z2SE_EN_HZ_V_DAMAGE = 0x70211,\n    Z2SE_EN_HZ_V_STAND = 0x70212,\n    Z2SE_EN_HZ_V_DEATH = 0x70213,\n    Z2SE_EN_HZ_V_WAIT = 0x70214,\n    Z2SE_EN_HZ_V_BACK = 0x70215,\n    Z2SE_EN_HZ_BACK = 0x70216,\n    Z2SE_EN_HZ_V_DEATH_STAND = 0x70217,\n    Z2SE_EN_HZ_V_FAINT = 0x70218,\n    Z2SE_EN_HZ_V_GALE = 0x70219,\n    Z2SE_EN_HZ_SLIDE = 0x7021A,\n    Z2SE_EN_HZ_V_DROWNED_A = 0x7021B,\n    Z2SE_EN_HZ_V_DROWNED_B = 0x7021C,\n    Z2SE_EN_HZ_WIND = 0x7021D,\n    Z2SE_EN_HZ_CLOSE = 0x7021E,\n    Z2SE_EN_HZ_SWING = 0x7021F,\n    Z2SE_EN_HZ_BACK_JUMP = 0x70220,\n    Z2SE_EN_HZ_DROWNSPLASH = 0x70221,\n    Z2SE_EN_NS_V_HANGED = 0x70222,\n    Z2SE_EN_NS_V_HANGEDAMAGE = 0x70223,\n    Z2SE_EN_NS_V_HANGEDBRUSH = 0x70224,\n    Z2SE_EN_NS_V_HANGEDBRUSH2 = 0x70225,\n    Z2SE_EN_BM_SPARK = 0x70226,\n    Z2SE_EN_BM_UNLOCK = 0x70227,\n    Z2SE_EN_BM_TURN_END = 0x70228,\n    Z2SE_EN_BM_BURN = 0x70229,\n    Z2SE_EN_BM_SLIDE = 0x7022A,\n    Z2SE_EN_ST_V_WATERDEAD = 0x7022B,\n    Z2SE_EN_ST_V_WINDDAMAGE = 0x7022C,\n    Z2SE_EN_BI_ATTACK = 0x7022D,\n    Z2SE_EN_PM_ZELDASONG = 0x7022E,\n    Z2SE_EN_GB_V_DOSUN = 0x7022F,\n    Z2SE_EN_GB_DOSUN_DASH = 0x70230,\n    Z2SE_EN_GB_DOSUN = 0x70231,\n    Z2SE_EN_DF_EAT_POT = 0x70232,\n    Z2SE_EN_DF_EAT_BOKKURI = 0x70233,\n    Z2SE_EN_YC_WING = 0x70234,\n    Z2SE_EN_YC_GLIDE = 0x70235,\n    Z2SE_EN_YC_CRASH = 0x70236,\n    Z2SE_EN_OT_SWIM = 0x70237,\n    Z2SE_EN_OT_V_DEATH = 0x70238,\n    Z2SE_EN_OT_BORN = 0x70239,\n    Z2SE_EN_DT_FALLING = 0x7023A,\n    Z2SE_EN_DT_SPLASH = 0x7023B,\n    Z2SE_EN_DT_V_DOWN_DAMAGE = 0x7023C,\n    Z2SE_EN_DT_V_DOWN_DAMAGE2 = 0x7023D,\n    Z2SE_EN_BM_FIND = 0x7023E,\n    Z2SE_EN_BM_HEAT = 0x7023F,\n    Z2SE_EN_HM_WAIT = 0x70240,\n    Z2SE_EN_HM_WALK = 0x70241,\n    Z2SE_EN_HM_V_GUARD = 0x70242,\n    Z2SE_EN_HM_V_SIPPU = 0x70243,\n    Z2SE_EN_HM_V_DIE = 0x70244,\n    Z2SE_EN_HM_FALL = 0x70245,\n    Z2SE_EN_HM_LAND = 0x70246,\n    Z2SE_EN_HM_V_ATTACK = 0x70247,\n    Z2SE_EN_HM_ATTACK = 0x70248,\n    Z2SE_EN_HM_FIRE = 0x70249,\n    Z2SE_EN_TT_V_DAMAGE_ARROW = 0x7024A,\n    Z2SE_EN_TT_V_DAMAGE = 0x7024B,\n    Z2SE_EN_TT_V_EYE_DEATH = 0x7024C,\n    Z2SE_EN_TT_LEG_DEATH = 0x7024D,\n    Z2SE_EN_TT_JUMP = 0x7024E,\n    Z2SE_EN_TT_V_JUMP = 0x7024F,\n    Z2SE_EN_TT_LAND = 0x70250,\n    Z2SE_EN_TT_LAND_WATER = 0x70251,\n    Z2SE_EN_TT_V_WIND = 0x70252,\n    Z2SE_EN_TT_WAIT = 0x70253,\n    Z2SE_EN_TT_V_PUSH = 0x70254,\n    Z2SE_EN_TT_V_WAIT = 0x70255,\n    Z2SE_EN_TK_SWIM = 0x70256,\n    Z2SE_EN_TK_APPEAR = 0x70257,\n    Z2SE_EN_TK_APPEAR2 = 0x70258,\n    Z2SE_EN_TK_HIDE = 0x70259,\n    Z2SE_EN_TK_V_ATTACK = 0x7025A,\n    Z2SE_EN_TK_ATTACK = 0x7025B,\n    Z2SE_EN_TK_V_DAMAGE = 0x7025C,\n    Z2SE_EN_TK_SHOT = 0x7025D,\n    Z2SE_EN_TK_HIT = 0x7025E,\n    Z2SE_EN_TK_V_WAIT = 0x7025F,\n    Z2SE_EN_TK_KYORO = 0x70260,\n    Z2SE_EN_TK2_SWIM = 0x70261,\n    Z2SE_EN_TK2_APPEAR = 0x70262,\n    Z2SE_EN_TK2_APPEAR2 = 0x70263,\n    Z2SE_EN_TK2_HIDE = 0x70264,\n    Z2SE_EN_TK2_V_ATTACK = 0x70265,\n    Z2SE_EN_TK2_ATTACK = 0x70266,\n    Z2SE_EN_TK2_V_DAMAGE = 0x70267,\n    Z2SE_EN_TK2_SHOT = 0x70268,\n    Z2SE_EN_TK2_HIT = 0x70269,\n    Z2SE_EN_TK2_V_WAIT = 0x7026A,\n    Z2SE_EN_TK2_KYORO = 0x7026B,\n    Z2SE_EN_DD_V_DAMAGE = 0x7026C,\n    Z2SE_EN_DD_V_DIE = 0x7026D,\n    Z2SE_EN_DD_V_DIE_ARROW = 0x7026E,\n    Z2SE_EN_DD_V_DIE_BOMB = 0x7026F,\n    Z2SE_EN_DD_DIE_BOMB = 0x70270,\n    Z2SE_EN_DD_V_GUARD = 0x70271,\n    Z2SE_EN_DD_V_WAIT = 0x70272,\n    Z2SE_EN_DD_WALK_L = 0x70273,\n    Z2SE_EN_DD_WALK_R = 0x70274,\n    Z2SE_EN_DD_RUN_L = 0x70275,\n    Z2SE_EN_DD_RUN_R = 0x70276,\n    Z2SE_EN_DD_V_FIRE_A = 0x70277,\n    Z2SE_EN_DD_V_FIRE_B = 0x70278,\n    Z2SE_EN_DD_V_FIRE_C = 0x70279,\n    Z2SE_EN_DD_FALL = 0x7027A,\n    Z2SE_EN_SM_HIT = 0x7027B,\n    Z2SE_EN_GI_SHOUT = 0x7027C,\n    Z2SE_EN_BOSS_EXPLODE = 0x7027D,\n    Z2SE_EN_BOSS_CONVERGE = 0x7027E,\n    Z2SE_EN_FM_V_CHAIN_BREAK = 0x7027F,\n    Z2SE_EN_FM_CHAIN_TENSION = 0x70280,\n    Z2SE_EN_FM_V_OPDEMO = 0x70281,\n    Z2SE_EN_FM_OPDEMO = 0x70282,\n    Z2SE_EN_FM_V_DEMOEND = 0x70283,\n    Z2SE_EN_FM_DEMOEND = 0x70284,\n    Z2SE_EN_FM_DEMOEND_CORE = 0x70285,\n    Z2SE_EN_FM_SAITENKA = 0x70286,\n    Z2SE_EN_FM_V_CHANCE = 0x70287,\n    Z2SE_EN_FM_V_CHANCEDAMAGE = 0x70288,\n    Z2SE_EN_FM_V_DAMAGEWALK = 0x70289,\n    Z2SE_EN_FM_DOWN = 0x7028A,\n    Z2SE_EN_FM_V_DOWN = 0x7028B,\n    Z2SE_EN_FM_V_DOWNWAIT = 0x7028C,\n    Z2SE_EN_FM_V_HANGWAIT = 0x7028D,\n    Z2SE_EN_FM_V_KYORO = 0x7028E,\n    Z2SE_EN_FM_V_UP = 0x7028F,\n    Z2SE_EN_FM_V_UP02 = 0x70290,\n    Z2SE_EN_FM_V_UP02_2 = 0x70291,\n    Z2SE_EN_FM_V_WAIT = 0x70292,\n    Z2SE_EN_FM_V_ATTACK_TAME = 0x70293,\n    Z2SE_EN_FM_ATTACK_TAME = 0x70294,\n    Z2SE_EN_FM_ATTACK02_CHAIN = 0x70295,\n    Z2SE_EN_FM_CORE_EYEOPEN = 0x70296,\n    Z2SE_EN_FM_CORE_GLOW = 0x70297,\n    Z2SE_EN_FM_COREHIT = 0x70298,\n    Z2SE_EN_FM_V_FIND = 0x70299,\n    Z2SE_EN_YB_V_CRY = 0x7029A,\n    Z2SE_EN_YB_FLY = 0x7029B,\n    Z2SE_EN_YB_ABUKU = 0x7029C,\n    Z2SE_EN_YB_SPLASH = 0x7029D,\n    Z2SE_EN_YB_ELECTRIC = 0x7029E,\n    Z2SE_EN_YB_ELECTRIC_LOOP = 0x7029F,\n    Z2SE_EN_YB_ELECTRIC_LOOP_WTR = 0x702A0,\n    Z2SE_EN_DK_WAIT = 0x702A1,\n    Z2SE_EN_DK_CHARGE = 0x702A2,\n    Z2SE_EN_DK_ATTACK = 0x702A3,\n    Z2SE_EN_DK_GUARD = 0x702A4,\n    Z2SE_EN_DK_PULLOUT = 0x702A5,\n    Z2SE_EN_DK_BUBBLE = 0x702A6,\n    Z2SE_EN_BG_SWIM = 0x702A7,\n    Z2SE_EN_BG_V_DAMAGE = 0x702A8,\n    Z2SE_EN_BG_SANDSMOKE = 0x702A9,\n    Z2SE_EN_FM_V_TODOME = 0x702AA,\n    Z2SE_EN_DD_V_FIND = 0x702AB,\n    Z2SE_EN_SB_WAIT = 0x702AC,\n    Z2SE_EN_SB_DEFENCE = 0x702AD,\n    Z2SE_EN_SB_ATTACK01 = 0x702AE,\n    Z2SE_EN_SB_ATTACK02 = 0x702AF,\n    Z2SE_EN_SB_DEATH = 0x702B0,\n    Z2SE_EN_SB_JUMP = 0x702B1,\n    Z2SE_EN_SB_LAND = 0x702B2,\n    Z2SE_EN_SB_SHIELD = 0x702B3,\n    Z2SE_EN_SB_BIND = 0x702B4,\n    Z2SE_EN_SB_BUBBLE = 0x702B5,\n    Z2SE_EN_YB_V_ATTACK = 0x702B6,\n    Z2SE_EN_YB_V_DAMAGE = 0x702B7,\n    Z2SE_EN_YB_SHIRU = 0x702B8,\n    Z2SE_EN_YB_V_DAMAGE_DOWN = 0x702B9,\n    Z2SE_EN_YB_V_DOWN_DAMAGE = 0x702BA,\n    Z2SE_EN_YB_V_DOWN_WAIT = 0x702BB,\n    Z2SE_EN_YB_V_DEATH = 0x702BC,\n    Z2SE_EN_YB_V_FLY_WAIT = 0x702BD,\n    Z2SE_EN_YB_V_GUARD = 0x702BE,\n    Z2SE_EN_YB_V_DOWN_IN = 0x702BF,\n    Z2SE_EN_YB_V_RISE = 0x702C0,\n    Z2SE_EN_YB_MOVE_ONWATER = 0x702C1,\n    Z2SE_EN_YB_MOVE_UNDERWATER = 0x702C2,\n    Z2SE_EN_YB_HIT_FLOATBOARD = 0x702C3,\n    Z2SE_EN_SG_BITE = 0x702C4,\n    Z2SE_EN_SG_SWIM = 0x702C5,\n    Z2SE_EN_SG_BOUND = 0x702C6,\n    Z2SE_EN_SG_V_DEATH = 0x702C7,\n    Z2SE_EN_SC_V_WAIT = 0x702C8,\n    Z2SE_EN_SC_V_FIND = 0x702C9,\n    Z2SE_EN_SC_V_DAMAGE = 0x702CA,\n    Z2SE_EN_SC_V_DEAD = 0x702CB,\n    Z2SE_EN_SC_V_PROVOKE = 0x702CC,\n    Z2SE_EN_SC_V_ESCAPE = 0x702CD,\n    Z2SE_EN_SC_JUMP = 0x702CE,\n    Z2SE_EN_SC_LAND = 0x702CF,\n    Z2SE_EN_SC_LAND_WATER = 0x702D0,\n    Z2SE_EN_SC_V_WHISTLE = 0x702D1,\n    Z2SE_EN_SC_V_F_SHOCK = 0x702D2,\n    Z2SE_EN_SC_V_LIBERATION = 0x702D3,\n    Z2SE_EN_SC_V_KYORO = 0x702D4,\n    Z2SE_EN_SC_SL_MOVE = 0x702D5,\n    Z2SE_EN_SC_SL_REBOUND = 0x702D6,\n    Z2SE_EN_SC_SL_ATTACK = 0x702D7,\n    Z2SE_EN_SC_SL_LAND = 0x702D8,\n    Z2SE_EN_SC_SL_JUMP_IN = 0x702D9,\n    Z2SE_EN_SC_SL_EXPLODE = 0x702DA,\n    Z2SE_EN_SC_V_ATTACK = 0x702DB,\n    Z2SE_EN_SC_V_WHISTLE2 = 0x702DC,\n    Z2SE_EN_OI_DEMO_APPEAR = 0x702DD,\n    Z2SE_EN_OI_DEMO_APPEAR2 = 0x702DE,\n    Z2SE_EN_MM_V_RUSH = 0x702DF,\n    Z2SE_EN_MM_V_KYORO = 0x702E0,\n    Z2SE_EN_MM_V_FIND = 0x702E1,\n    Z2SE_EN_MM_V_SURPRISE = 0x702E3,\n    Z2SE_EN_MM_V_DAMAGE = 0x702E4,\n    Z2SE_EN_MM_V_NO_DAMAGE = 0x702E5,\n    Z2SE_EN_MM_V_DEAD = 0x702E6,\n    Z2SE_EN_MM_R2W_MET = 0x702E7,\n    Z2SE_EN_MM_R2W_NOMET = 0x702E8,\n    Z2SE_EN_MM_BRAKE_LND = 0x702E9,\n    Z2SE_EN_MM_BRAKE_WTR = 0x702EA,\n    Z2SE_EN_MM_FALL_LND = 0x702EB,\n    Z2SE_EN_MM_FALL_WTR = 0x702EC,\n    Z2SE_EN_MM_WALK_LND = 0x702ED,\n    Z2SE_EN_MM_WALK_WTR = 0x702EE,\n    Z2SE_EN_MM_RUN_LND = 0x702EF,\n    Z2SE_EN_MM_RUN_WTR = 0x702F0,\n    Z2SE_EN_MM_MET_LIFT_WTR = 0x702F1,\n    Z2SE_EN_MM_MET_PUT_LND = 0x702F2,\n    Z2SE_EN_MM_MET_PUT_WTR = 0x702F3,\n    Z2SE_EN_MM_MET_BOUND_LND = 0x702F4,\n    Z2SE_EN_MM_MET_BOUND_WTR = 0x702F5,\n    Z2SE_EN_MM_MET_TAKEN = 0x702F6,\n    Z2SE_EN_YO_ICE_MOVE = 0x702F7,\n    Z2SE_EN_YO_ICE_ATTACK = 0x702F8,\n    Z2SE_EN_YO_ICE_LAND = 0x702F9,\n    Z2SE_EN_YO_ICE_VIBERATE = 0x702FA,\n    Z2SE_EN_YO_ICE_PULLOUT = 0x702FB,\n    Z2SE_EN_YO_ICE_BREAK = 0x702FC,\n    Z2SE_EN_YO_MOVE1 = 0x702FD,\n    Z2SE_EN_YO_MOVE2 = 0x702FE,\n    Z2SE_EN_YO_BOUND1 = 0x702FF,\n    Z2SE_EN_YO_BOUND2 = 0x70300,\n    Z2SE_EN_YO_BREAK1 = 0x70301,\n    Z2SE_EN_YO_BREAK2 = 0x70302,\n    Z2SE_EN_YO_ROLL1 = 0x70303,\n    Z2SE_EN_YO_ROLL2 = 0x70304,\n    Z2SE_EN_YO_MOVE_FLY = 0x70305,\n    Z2SE_EN_YO_FALL = 0x70306,\n    Z2SE_EN_YO_LAND = 0x70307,\n    Z2SE_EN_YO_VIBRATE = 0x70308,\n    Z2SE_EN_YO_PULLOUT = 0x70309,\n    Z2SE_EN_YO_BREAK3 = 0x7030A,\n    Z2SE_EN_YO_HIT_WALL = 0x7030B,\n    Z2SE_EN_YO_VIBE_ROOM = 0x7030C,\n    Z2SE_EN_YO_V_ICICLE = 0x7030D,\n    Z2SE_EN_DT_WALK = 0x7030E,\n    Z2SE_EN_DT_FOOTNOTE_L = 0x7030F,\n    Z2SE_EN_DT_FOOTNOTE_R = 0x70310,\n    Z2SE_EN_DT_JUMP = 0x70311,\n    Z2SE_EN_DT_V_JUMP = 0x70312,\n    Z2SE_EN_DT_V_DOWN_WAIT = 0x70313,\n    Z2SE_EN_DT_V_RETURN = 0x70314,\n    Z2SE_EN_DT_SWING = 0x70315,\n    Z2SE_EN_DT_V_CROAK = 0x70316,\n    Z2SE_EN_DT_SPAWN = 0x70317,\n    Z2SE_EN_DT_CROAK_DAMAGE = 0x70318,\n    Z2SE_EN_DT_CROAK_BOMB = 0x70319,\n    Z2SE_EN_DT_V_KYORO = 0x7031A,\n    Z2SE_EN_DT_V_DEAD = 0x7031B,\n    Z2SE_EN_DT_SMALL_DAMAGE = 0x7031C,\n    Z2SE_EN_DT_STEP = 0x7031D,\n    Z2SE_EN_DT_NODAMAGE_FOOT = 0x7031E,\n    Z2SE_EN_DT_V_OPDEMO = 0x7031F,\n    Z2SE_EN_FZ_BOUND = 0x70320,\n    Z2SE_EN_FZ_DAMAGE = 0x70321,\n    Z2SE_EN_FZ_DEATH = 0x70322,\n    Z2SE_EN_FZ_MOVE = 0x70323,\n    Z2SE_EN_FL_DAMAGE = 0x70324,\n    Z2SE_EN_FL_DEATH = 0x70325,\n    Z2SE_EN_FL_BREATH = 0x70326,\n    Z2SE_EN_DT_V_TODOME = 0x70327,\n    Z2SE_EN_VA_V_FOUND = 0x70328,\n    Z2SE_EN_VA_V_VISUAL = 0x70329,\n    Z2SE_EN_VA_V_ATK1 = 0x7032B,\n    Z2SE_EN_VA_V_ATK2 = 0x7032C,\n    Z2SE_EN_VA_V_ATK3 = 0x7032D,\n    Z2SE_EN_VA_V_BITED = 0x7032E,\n    Z2SE_EN_VA_V_NO_DMG = 0x7032F,\n    Z2SE_EN_VA_V_VANISH = 0x70330,\n    Z2SE_EN_VA_V_ROTATE = 0x70331,\n    Z2SE_EN_VA_V_DYING = 0x70332,\n    Z2SE_EN_VA_V_DEAD = 0x70333,\n    Z2SE_EN_VA_V_DMG = 0x70334,\n    Z2SE_EN_VA_V_DMG_L = 0x70335,\n    Z2SE_EN_VA_V_ATK_FLY = 0x70336,\n    Z2SE_EN_VA_V_ATK_FLY2 = 0x70337,\n    Z2SE_EN_VA_V_DOWN = 0x70338,\n    Z2SE_EN_VA_SWD_FLY = 0x70339,\n    Z2SE_EN_VA_SWD_IMPACT = 0x7033A,\n    Z2SE_EN_VA_SWD_ATK1 = 0x7033B,\n    Z2SE_EN_VA_SWD_ATK2 = 0x7033C,\n    Z2SE_EN_VA_SWD_ATK3 = 0x7033D,\n    Z2SE_EN_VA_VANISH = 0x7033E,\n    Z2SE_EN_VA_SWD_ATK_T = 0x7033F,\n    Z2SE_EN_VA_ATK_FLY = 0x70340,\n    Z2SE_EN_VA_ATK_FLY2 = 0x70341,\n    Z2SE_EN_VA_DOWN = 0x70342,\n    Z2SE_EN_VA_OPENING1 = 0x70343,\n    Z2SE_EN_VA_OPENING2 = 0x70344,\n    Z2SE_EN_VA_END = 0x70345,\n    Z2SE_EN_VA_ATK_BALL = 0x70346,\n    Z2SE_EN_OI_TENT_MOVE = 0x70347,\n    Z2SE_EN_OI_TENT_SWING = 0x70348,\n    Z2SE_EN_OI_V_TENT_DAMAGE = 0x70349,\n    Z2SE_EN_OI_CORE_MOVE = 0x7034A,\n    Z2SE_EN_OI_CORE_PULLOUT = 0x7034B,\n    Z2SE_EN_OI_V_CORE_DAMAGE = 0x7034C,\n    Z2SE_EN_OI_V_EAT = 0x7034D,\n    Z2SE_EN_OI_V_SWALLOW = 0x7034F,\n    Z2SE_EN_OI_V_DRAWIN = 0x70350,\n    Z2SE_EN_OI_V_EAT02 = 0x70351,\n    Z2SE_EN_OI_V_THROWUP = 0x70352,\n    Z2SE_EN_OI_MOVE = 0x70353,\n    Z2SE_EN_OI_HIT_COLUMN = 0x70354,\n    Z2SE_EN_OI_V_DAMAGE = 0x70355,\n    Z2SE_EN_OI_V_TODOME = 0x70356,\n    Z2SE_EN_OI_V_ENDDEMO = 0x70357,\n    Z2SE_EN_OI_ENDDEMO = 0x70358,\n    Z2SE_EN_SW_MOVE = 0x70359,\n    Z2SE_EN_SW_JUMP_OUT = 0x7035A,\n    Z2SE_EN_SW_JUMP_IN = 0x7035B,\n    Z2SE_EN_SW_BTBT = 0x7035C,\n    Z2SE_EN_SW_DIVE = 0x7035D,\n    Z2SE_EN_SW_V_DMG = 0x7035E,\n    Z2SE_EN_SW_V_DEAD = 0x7035F,\n    Z2SE_EN_SW_V_CATCH = 0x70360,\n    Z2SE_EN_BU_WING = 0x70361,\n    Z2SE_EN_BU_WING_L = 0x70362,\n    Z2SE_EN_BU_V_ATK = 0x70363,\n    Z2SE_EN_BU_V_DMG = 0x70364,\n    Z2SE_EN_BU_DMG_BOUND = 0x70365,\n    Z2SE_EN_BU_NODMG_BOUND = 0x70366,\n    Z2SE_EN_BU_MOVE_BOUND = 0x70367,\n    Z2SE_EN_BU_V_DEAD = 0x70368,\n    Z2SE_EN_BU_LV_FIRE = 0x70369,\n    Z2SE_EN_GI_WALK = 0x7036B,\n    Z2SE_EN_GI_ATK_STRK = 0x7036C,\n    Z2SE_EN_GI_ATK_IMPCT = 0x7036D,\n    Z2SE_EN_GI_V_ATK = 0x7036E,\n    Z2SE_EN_GI_V_DMG = 0x7036F,\n    Z2SE_EN_GI_V_DEAD = 0x70370,\n    Z2SE_EN_OI_HIT_TENTACLE = 0x70371,\n    Z2SE_EN_OI_HIT_WALL = 0x70372,\n    Z2SE_EN_OI_EXPLODE = 0x70373,\n    Z2SE_EN_OI_BG_APPEAR = 0x70374,\n    Z2SE_EN_BUG_WALK_GRD = 0x70375,\n    Z2SE_EN_BUG_WALK_GRD_GRP = 0x70376,\n    Z2SE_EN_BUG_WALK_BODY = 0x70377,\n    Z2SE_EN_BUG_WALK_BODY_GRP = 0x70378,\n    Z2SE_EN_BUG_JUMP = 0x70379,\n    Z2SE_EN_BUG_DIE = 0x7037A,\n    Z2SE_EN_KK_ATTACK01 = 0x7037B,\n    Z2SE_EN_KK_ATTACK03 = 0x7037C,\n    Z2SE_EN_KK_FOOTNOTE = 0x7037D,\n    Z2SE_EN_KK_CRASH = 0x7037E,\n    Z2SE_EN_KK_DAMAGE = 0x7037F,\n    Z2SE_EN_KK_NO_DAMAGE = 0x70380,\n    Z2SE_EN_KK_DEAD = 0x70381,\n    Z2SE_EN_KK_RESTORE = 0x70382,\n    Z2SE_EN_KK_APPEAR = 0x70383,\n    Z2SE_EN_KK_THROW = 0x70384,\n    Z2SE_EN_KK_SPEAR_STICK = 0x70385,\n    Z2SE_EN_FL_BLIZZARD = 0x70386,\n    Z2SE_EN_FL_ROTATE = 0x70387,\n    Z2SE_EN_WW_V_WAIT = 0x70388,\n    Z2SE_EN_WW_V_DAMAGE = 0x70389,\n    Z2SE_EN_WW_V_DEAD = 0x7038A,\n    Z2SE_EN_WW_JUMP = 0x7038B,\n    Z2SE_EN_WW_APPEAR = 0x7038C,\n    Z2SE_EN_WW_FOOTNOTE = 0x7038D,\n    Z2SE_EN_WW_HIDE = 0x7038E,\n    Z2SE_EN_WW_V_ATTACK = 0x7038F,\n    Z2SE_EN_TH_BRANDISH = 0x70390,\n    Z2SE_EN_TH_BRANDISH_START = 0x70391,\n    Z2SE_EN_TH_V_DAMAGE = 0x70392,\n    Z2SE_EN_TH_V_ENDDEMO = 0x70393,\n    Z2SE_EN_TH_V_LOOKAROUND = 0x70394,\n    Z2SE_EN_TH_V_PULLBACK = 0x70395,\n    Z2SE_EN_TH_V_THROW = 0x70396,\n    Z2SE_EN_TH_V_TRAP = 0x70397,\n    Z2SE_EN_FL_BLIZZARD_END = 0x70398,\n    Z2SE_EN_TN_V_KIAI_OP = 0x70399,\n    Z2SE_EN_TN_V_KIAI = 0x7039A,\n    Z2SE_EN_TN_V_KIAI_AGE = 0x7039B,\n    Z2SE_EN_TN_V_DMG = 0x7039C,\n    Z2SE_EN_TN_V_DMG_2 = 0x7039D,\n    Z2SE_EN_TN_V_THROW = 0x7039E,\n    Z2SE_EN_TN_V_PULL_OUT = 0x7039F,\n    Z2SE_EN_TN_V_KICK = 0x703A0,\n    Z2SE_EN_TN_V_JUMP = 0x703A1,\n    Z2SE_EN_TN_V_ZEIZEI = 0x703A2,\n    Z2SE_EN_TN_V_KURUSI = 0x703A3,\n    Z2SE_EN_TN_V_DEAD = 0x703A4,\n    Z2SE_EN_TN_V_DEAD2 = 0x703A5,\n    Z2SE_EN_TN_FOOT_M1 = 0x703A6,\n    Z2SE_EN_TN_FOOT_M2 = 0x703A7,\n    Z2SE_EN_TN_FOOT_L = 0x703A8,\n    Z2SE_EN_TN_SWD_L = 0x703A9,\n    Z2SE_EN_TN_SWD_IMPCT = 0x703AA,\n    Z2SE_EN_TN_ATK_NO_DMG = 0x703AB,\n    Z2SE_EN_TN_PULL_OUT = 0x703AC,\n    Z2SE_EN_TN_SWD_S_TRST = 0x703AD,\n    Z2SE_EN_TN_SWD_S = 0x703AE,\n    Z2SE_EN_TN_HIZA = 0x703AF,\n    Z2SE_EN_TN_BRK_ARMOR = 0x703B0,\n    Z2SE_EN_TN_ARMOR_BND = 0x703B1,\n    Z2SE_EN_TN_SHIELD_BND = 0x703B2,\n    Z2SE_EN_TN_WEAPON_FLY = 0x703B3,\n    Z2SE_EN_TN_WEAPON_STOP = 0x703B4,\n    Z2SE_EN_TN_SAYA_BND_1 = 0x703B5,\n    Z2SE_EN_TN_SAYA_BND_2 = 0x703B6,\n    Z2SE_EN_TN_SWD_DROP = 0x703B7,\n    Z2SE_EN_ZM_EMERGE = 0x703B8,\n    Z2SE_EN_ZM_DISAPPER = 0x703B9,\n    Z2SE_EN_ZM_PRE_ATK = 0x703BA,\n    Z2SE_EN_ZM_BALL_OUT = 0x703BB,\n    Z2SE_EN_ZM_BALL_FLY = 0x703BC,\n    Z2SE_EN_ZM_BALL_BURST = 0x703BD,\n    Z2SE_EN_ZM_V_DMG = 0x703BE,\n    Z2SE_EN_ZM_V_DEAD = 0x703BF,\n    Z2SE_EN_ZM_DROP = 0x703C0,\n    Z2SE_EN_SM_HIT2 = 0x703C1,\n    Z2SE_EN_SM_MOVE = 0x703C2,\n    Z2SE_EN_SM_MOVE2 = 0x703C3,\n    Z2SE_EN_SM_JUMP = 0x703C4,\n    Z2SE_EN_SM_JUMP2 = 0x703C5,\n    Z2SE_EN_SM_FUSION = 0x703C6,\n    Z2SE_EN_SM_FUSION2 = 0x703C7,\n    Z2SE_EN_SM_LAND = 0x703C8,\n    Z2SE_EN_SM_LAND2 = 0x703C9,\n    Z2SE_EN_MF_V_DEATH = 0x703CA,\n    Z2SE_EN_MF_V_DAMAGE = 0x703CB,\n    Z2SE_EN_MF_V_DAMAGE2 = 0x703CC,\n    Z2SE_EN_MF_TAIL = 0x703CD,\n    Z2SE_EN_MF_KNIFE = 0x703CE,\n    Z2SE_EN_MF_KNIFE2_A = 0x703CF,\n    Z2SE_EN_MF_KNIFE2_B = 0x703D0,\n    Z2SE_EN_MF_V_DRAWBACK = 0x703D1,\n    Z2SE_EN_MF_V_AWAKE = 0x703D2,\n    Z2SE_EN_MF_V_UP = 0x703D3,\n    Z2SE_EN_MF_FN_L = 0x703D4,\n    Z2SE_EN_MF_FN_R = 0x703D5,\n    Z2SE_EN_MF_FN_RUN_L = 0x703D6,\n    Z2SE_EN_MF_FN_RUN_R = 0x703D7,\n    Z2SE_EN_MF_V_TAIL = 0x703D8,\n    Z2SE_EN_MF_V_FIND = 0x703D9,\n    Z2SE_EN_MF_V_KNIFE = 0x703DA,\n    Z2SE_EN_MF_V_KNIFE2_A = 0x703DB,\n    Z2SE_EN_MF_V_BREATH = 0x703DC,\n    Z2SE_EN_MF_V_GUARD = 0x703DD,\n    Z2SE_EN_MF_V_JUMP = 0x703DE,\n    Z2SE_EN_MF_V_SEARCH = 0x703DF,\n    Z2SE_EN_MF_V_SEARCH2 = 0x703E0,\n    Z2SE_EN_MF_V_SURPRISE = 0x703E1,\n    Z2SE_EN_MF_V_FIND_BOMB = 0x703E2,\n    Z2SE_EN_MF_V_LOOK_BOMB = 0x703E3,\n    Z2SE_EN_MF_V_KICK_BOMB = 0x703E4,\n    Z2SE_EN_TN_V_ATK_SLD = 0x703E5,\n    Z2SE_EN_TN_V_2_SWD_1 = 0x703E6,\n    Z2SE_EN_TN_V_2_SWD_2 = 0x703E7,\n    Z2SE_EN_TN_V_THRUST = 0x703E8,\n    Z2SE_EN_BM_BEAM2 = 0x703E9,\n    Z2SE_EN_BM_BURN2 = 0x703EA,\n    Z2SE_EN_BM_BREAK = 0x703EB,\n    Z2SE_EN_PZ_V_ATK_RDY = 0x703EC,\n    Z2SE_EN_PZ_V_ATK_TRW = 0x703ED,\n    Z2SE_EN_PZ_V_DMG = 0x703EE,\n    Z2SE_EN_PZ_V_DEAD = 0x703EF,\n    Z2SE_EN_PZ_EMERGE = 0x703F0,\n    Z2SE_EN_PZ_DISAPPEAR = 0x703F1,\n    Z2SE_EN_PZ_BALL_EMERGE = 0x703F2,\n    Z2SE_EN_PZ_BALL = 0x703F3,\n    Z2SE_EN_PZ_BALL_BURST = 0x703F4,\n    Z2SE_EN_PZ_PT_EMERGE = 0x703F5,\n    Z2SE_EN_PZ_PT = 0x703F6,\n    Z2SE_EN_PZ_PT_DISAPPEAR = 0x703F7,\n    Z2SE_EN_PZ_DKBB_SEED = 0x703F8,\n    Z2SE_EN_PZ_DKBB_VANISH = 0x703F9,\n    Z2SE_EN_PZ_FIRE_OUT = 0x703FA,\n    Z2SE_EN_PZ_FIRE = 0x703FB,\n    Z2SE_EN_PZ_FIRE_BURST = 0x703FC,\n    Z2SE_EN_PZ_FOG = 0x703FD,\n    Z2SE_EN_YO_DEMO_OP1 = 0x703FE,\n    Z2SE_EN_YO_DEMO_OP2 = 0x703FF,\n    Z2SE_EN_YO_DEMO_MID = 0x70400,\n    Z2SE_EN_YO_DEMO_END = 0x70401,\n    Z2SE_EN_PZ_V_ATK_TRW_1ST = 0x70402,\n    Z2SE_EN_ZAN_WARP_OUT = 0x70403,\n    Z2SE_EN_ZAN_WARP_IN = 0x70404,\n    Z2SE_EN_ZAN_V_ATK_BALL = 0x70405,\n    Z2SE_EN_ZAN_V_ATK_BALL_MG = 0x70406,\n    Z2SE_EN_ZAN_V_ATK_BALL_OI = 0x70407,\n    Z2SE_EN_ZAN_V_ATK_BALL_MK = 0x70408,\n    Z2SE_EN_ZAN_FIRE_OUT = 0x70409,\n    Z2SE_EN_ZAN_FIRE = 0x7040A,\n    Z2SE_EN_ZAN_FIRE_BURST = 0x7040B,\n    Z2SE_EN_ZAN_V_DMG = 0x7040C,\n    Z2SE_EN_ZAN_V_DMG_MG = 0x7040D,\n    Z2SE_EN_ZAN_V_DMG_OI = 0x7040E,\n    Z2SE_EN_ZAN_V_DMG_MK = 0x7040F,\n    Z2SE_EN_ZAN_V_DMG_YO = 0x70410,\n    Z2SE_EN_ZAN_V_DMG_CTL = 0x70411,\n    Z2SE_EN_ZAN_V_NO_DMG = 0x70412,\n    Z2SE_EN_ZAN_MAHOJIN_BB = 0x70413,\n    Z2SE_EN_ZAN_MAHOJIN_MG = 0x70414,\n    Z2SE_EN_ZAN_MAHOJIN_OI = 0x70415,\n    Z2SE_EN_ZAN_MAHOJIN_MK = 0x70416,\n    Z2SE_EN_ZAN_MAHOJIN_YO = 0x70417,\n    Z2SE_EN_ZAN_MAHOJIN_CTL = 0x70418,\n    Z2SE_EN_ZAN_OP_V_WAKEUP = 0x70419,\n    Z2SE_EN_ZAN_OP_FLY = 0x7041A,\n    Z2SE_EN_ZAN_BB_V_ZEIZEI = 0x7041B,\n    Z2SE_EN_ZAN_BB_V_JUMP = 0x7041C,\n    Z2SE_EN_ZAN_BB_LAND = 0x7041D,\n    Z2SE_EN_ZAN_BB_FOOT = 0x7041E,\n    Z2SE_EN_ZAN_BB_V_FALL = 0x7041F,\n    Z2SE_EN_ZAN_BB_WTR = 0x70420,\n    Z2SE_EN_ZAN_MG_V_JUMP = 0x70421,\n    Z2SE_EN_ZAN_MG_LAND = 0x70422,\n    Z2SE_EN_ZAN_OI_V_CAUGHT = 0x70423,\n    Z2SE_EN_ZAN_OI_SWIM1 = 0x70424,\n    Z2SE_EN_ZAN_OI_SWIM2 = 0x70425,\n    Z2SE_EN_ZZ_MV = 0x70426,\n    Z2SE_EN_ZZ_HANAIKI = 0x70427,\n    Z2SE_EN_ZZ_OPEN = 0x70428,\n    Z2SE_EN_ZZ_CLOSE = 0x70429,\n    Z2SE_EN_ZAN_MK_V_OTT = 0x7042A,\n    Z2SE_EN_ZAN_MK_V_FALL = 0x7042B,\n    Z2SE_EN_ZAN_MK_UMARU = 0x7042C,\n    Z2SE_EN_ZAN_MK_V_MGGG = 0x7042D,\n    Z2SE_EN_ZAN_MK_V_JUMP = 0x7042E,\n    Z2SE_EN_ZAN_MK_LAND = 0x7042F,\n    Z2SE_EN_ZAN_YO_V_HUGE = 0x70430,\n    Z2SE_EN_ZAN_YO_LAND_HUGE = 0x70431,\n    Z2SE_EN_ZAN_YO_V_LAND = 0x70432,\n    Z2SE_EN_ZAN_YO_V_JUMP = 0x70433,\n    Z2SE_EN_ZAN_YO_FUMI = 0x70434,\n    Z2SE_EN_ZAN_YO_V_FUMI_1 = 0x70435,\n    Z2SE_EN_ZAN_YO_V_FUMI_2 = 0x70436,\n    Z2SE_EN_ZAN_YO_V_FUMI_3 = 0x70437,\n    Z2SE_EN_ZAN_YO_LAND = 0x70438,\n    Z2SE_EN_ZAN_YO_V_KENKEN = 0x70439,\n    Z2SE_EN_ZAN_CTL_OP = 0x7043A,\n    Z2SE_EN_ZAN_CTL_SWD_RUB = 0x7043B,\n    Z2SE_EN_ZAN_CTL_FOOT = 0x7043C,\n    Z2SE_EN_ZAN_CTL_SW_SWING_L = 0x7043D,\n    Z2SE_EN_ZAN_CTL_FOOT_L = 0x7043E,\n    Z2SE_EN_ZAN_CTL_V_SW_ATK_A1 = 0x7043F,\n    Z2SE_EN_ZAN_CTL_V_SW_ATK_A2 = 0x70440,\n    Z2SE_EN_ZAN_CTL_SW_SWING_S1 = 0x70441,\n    Z2SE_EN_ZAN_CTL_SW_SWING_S2 = 0x70442,\n    Z2SE_EN_ZAN_CTL_V_SW_ATK_B1 = 0x70443,\n    Z2SE_EN_ZAN_CTL_V_SW_ATK_B2 = 0x70444,\n    Z2SE_EN_ZAN_CTL_SPIN_ATK = 0x70445,\n    Z2SE_EN_ZAN_CTL_V_SPIN_ATK = 0x70446,\n    Z2SE_EN_ZAN_CTL_V_ZEIZEI = 0x70447,\n    Z2SE_EN_ZAN_V_DMG_SHINARU = 0x70448,\n    Z2SE_EN_ZAN_V_DMG_JITANDA = 0x70449,\n    Z2SE_EN_ZAN_END = 0x7044A,\n    Z2SE_EN_KG_V_DAMAGE = 0x7044B,\n    Z2SE_EN_GBA_V_DEATH = 0x7044C,\n    Z2SE_EN_GBA_FOOTNOTE = 0x7044D,\n    Z2SE_EN_GBA_LAYEGG = 0x7044E,\n    Z2SE_EN_GBA_FUKA = 0x7044F,\n    Z2SE_EN_GBA_LAND = 0x70450,\n    Z2SE_EN_ZAN_L4_1 = 0x70451,\n    Z2SE_EN_ZAN_L4_2 = 0x70452,\n    Z2SE_EN_ZAN_L4_WARP_IN = 0x70453,\n    Z2SE_EN_ZAN_L4_WARP_OUT = 0x70454,\n    Z2SE_EN_ZH_START = 0x70455,\n    Z2SE_EN_ZH_MV = 0x70456,\n    Z2SE_EN_ZH_ATK_PRE = 0x70457,\n    Z2SE_EN_ZH_ATK = 0x70458,\n    Z2SE_EN_ZH_FALL = 0x70459,\n    Z2SE_EN_ZH_DROP = 0x7045A,\n    Z2SE_EN_ZH_PIYO = 0x7045B,\n    Z2SE_EN_ZH_BLINK = 0x7045C,\n    Z2SE_EN_ZH_WAKEUP = 0x7045D,\n    Z2SE_EN_ZH_DMG = 0x7045E,\n    Z2SE_EN_ZH_MV_WALL = 0x7045F,\n    Z2SE_EN_ZAN_YO_FLOAT_WAIT = 0x70460,\n    Z2SE_EN_PH_HIT = 0x70461,\n    Z2SE_EN_PH_PROPELLER = 0x70462,\n    Z2SE_EN_RB_APPEAR = 0x70463,\n    Z2SE_EN_RB_MOVE = 0x70464,\n    Z2SE_EN_RB_V_DEATH = 0x70465,\n    Z2SE_EN_RB_BACKDOWN = 0x70466,\n    Z2SE_EN_GE_V_NAKU = 0x70467,\n    Z2SE_EN_GE_V_ATTACK = 0x70468,\n    Z2SE_EN_GE_V_DEATH = 0x70469,\n    Z2SE_EN_GE_WING = 0x7046A,\n    Z2SE_EN_GE_GLIDE = 0x7046B,\n    Z2SE_EN_GE_V_FURA = 0x7046C,\n    Z2SE_EN_GO_V_BEAMATTACK_A = 0x7046D,\n    Z2SE_EN_GO_V_BEAMATTACK_C = 0x7046E,\n    Z2SE_EN_GO_DASH = 0x7046F,\n    Z2SE_EN_GO_V_DEATH = 0x70470,\n    Z2SE_EN_GO_LANDING = 0x70471,\n    Z2SE_EN_GO_V_LANDING_DAMAGE = 0x70472,\n    Z2SE_EN_GO_LANDING_WAIT = 0x70473,\n    Z2SE_EN_GO_RETURN = 0x70474,\n    Z2SE_EN_GO_V_ROOF_DAMAGE = 0x70475,\n    Z2SE_EN_GO_SLOW_MOVE = 0x70476,\n    Z2SE_EN_GO_WAIT = 0x70477,\n    Z2SE_EN_GO_DEMO_OP = 0x70478,\n    Z2SE_EN_GO_BEAM = 0x70479,\n    Z2SE_EN_DR_WING = 0x7047A,\n    Z2SE_EN_DR_GLIDE = 0x7047B,\n    Z2SE_EN_DR_V_FIRE = 0x7047C,\n    Z2SE_EN_DR_BREAK_ARMOR = 0x7047D,\n    Z2SE_EN_DR_V_BURU = 0x7047E,\n    Z2SE_EN_DR_V_DAMAGE = 0x7047F,\n    Z2SE_EN_DR_V_DAMAGE_LAST = 0x70480,\n    Z2SE_EN_DR_V_DEATH = 0x70481,\n    Z2SE_EN_DR_FALL = 0x70482,\n    Z2SE_EN_DR_V_FIRE_A = 0x70483,\n    Z2SE_EN_DR_FLAP = 0x70484,\n    Z2SE_EN_DR_V_HOVERING = 0x70485,\n    Z2SE_EN_DR_V_WAKEUP = 0x70486,\n    Z2SE_EN_DR_V_SCREAM = 0x70487,\n    Z2SE_EN_DR_V_POLE_STAY = 0x70488,\n    Z2SE_EN_DR_DEMO_DESTROY = 0x70489,\n    Z2SE_EN_DR_V_NAKU = 0x7048A,\n    Z2SE_EN_DR_V_TUME = 0x7048B,\n    Z2SE_EN_DR_TUME = 0x7048C,\n    Z2SE_EN_DR_CORE_HIT = 0x7048D,\n    Z2SE_EN_DR_WIND_ATTACK = 0x7048E,\n    Z2SE_EN_YC_V_HANGED = 0x7048F,\n    Z2SE_EN_YC_V_BRUSH = 0x70490,\n    Z2SE_EN_YC_V_BRUSH2 = 0x70491,\n    Z2SE_EN_YC_DASH = 0x70492,\n    Z2SE_EN_YC_V_HOVERING = 0x70493,\n    Z2SE_EN_YC_V_ATTACK = 0x70494,\n    Z2SE_EN_YC_V_DAMAGE = 0x70495,\n    Z2SE_EN_YC_SPLASH = 0x70496,\n    Z2SE_EN_KC_WING = 0x70497,\n    Z2SE_EN_KC_GLIDE = 0x70498,\n    Z2SE_EN_KC_CRASH = 0x70499,\n    Z2SE_EN_KC_V_CRASH = 0x7049A,\n    Z2SE_EN_KC_DASH = 0x7049B,\n    Z2SE_EN_KC_SPLASH = 0x7049C,\n    Z2SE_EN_VA_FIRE_BURST = 0x7049D,\n    Z2SE_EN_GG_V_ATTACK = 0x7049E,\n    Z2SE_EN_GG_ATTACK = 0x7049F,\n    Z2SE_EN_GG_WING = 0x704A0,\n    Z2SE_EN_GG_V_SHOUT = 0x704A1,\n    Z2SE_EN_GG_V_ATTACK_A = 0x704A2,\n    Z2SE_EN_GG_ATTACK_A = 0x704A3,\n    Z2SE_EN_GG_V_ATTACK_B = 0x704A4,\n    Z2SE_EN_GG_ATTACK_B = 0x704A5,\n    Z2SE_EN_GG_V_ATTACK_C = 0x704A6,\n    Z2SE_EN_GG_ATTACK_C = 0x704A7,\n    Z2SE_EN_GG_V_DAMAGE = 0x704A8,\n    Z2SE_EN_GG_V_DIE_BOSS = 0x704A9,\n    Z2SE_EN_GG_V_DIE = 0x704AA,\n    Z2SE_EN_GG_V_FAINT = 0x704AB,\n    Z2SE_EN_GG_V_BREATH = 0x704AC,\n    Z2SE_EN_GG_FOOTNOTE = 0x704AD,\n    Z2SE_EN_MD_V_DAMAGE = 0x704AE,\n    Z2SE_EN_MD_V_DEATH = 0x704AF,\n    Z2SE_EN_MD_V_DEATH_PRESS = 0x704B0,\n    Z2SE_EN_ZAN_MG_V_ZEIZEI = 0x704B1,\n    Z2SE_EN_GG_V_DEMO_OP = 0x704B2,\n    Z2SE_EN_YC_HIT_SIDE = 0x704B3,\n    Z2SE_EN_PM_V_OP = 0x704B4,\n    Z2SE_EN_PM_V_END = 0x704B5,\n    Z2SE_EN_ZS_APPEAR = 0x704B6,\n    Z2SE_EN_ZS_DISAPPEAR = 0x704B7,\n    Z2SE_EN_ZS_V_DMG = 0x704B8,\n    Z2SE_EN_ZS_V_DEAD = 0x704B9,\n    Z2SE_EN_ZS_V_WAIT = 0x704BA,\n    Z2SE_EN_DS_OPDEMO = 0x704BB,\n    Z2SE_EN_DS_HANDS = 0x704BC,\n    Z2SE_EN_DS_V_ATK_FIRE = 0x704BD,\n    Z2SE_EN_DS_V_RTT = 0x704BE,\n    Z2SE_EN_DS_V_ATK_1 = 0x704BF,\n    Z2SE_EN_DS_V_ATK_2 = 0x704C0,\n    Z2SE_EN_DS_ATK = 0x704C1,\n    Z2SE_EN_DS_HAND_1 = 0x704C2,\n    Z2SE_EN_DS_HAND_2 = 0x704C3,\n    Z2SE_EN_DS_DMG_WAIT = 0x704C4,\n    Z2SE_EN_DS_BONE_BRK = 0x704C5,\n    Z2SE_EN_DS_V_DMG_A = 0x704C6,\n    Z2SE_EN_DS_V_DMG_B = 0x704C7,\n    Z2SE_EN_DS_V_DMG_L = 0x704C8,\n    Z2SE_EN_DS_DMG_A_FALL = 0x704C9,\n    Z2SE_EN_DS_DMG_B_FALL = 0x704CA,\n    Z2SE_EN_DS_DMG_L_FALL = 0x704CB,\n    Z2SE_EN_DS_DMG_HAND = 0x704CC,\n    Z2SE_EN_DS_DMG_BODY = 0x704CD,\n    Z2SE_EN_DS_V_NODMG = 0x704CE,\n    Z2SE_EN_DS_V_WAIT_A = 0x704CF,\n    Z2SE_EN_DS_V_WAIT_B = 0x704D0,\n    Z2SE_EN_DS_V_WAIT_C = 0x704D1,\n    Z2SE_EN_DS_MDEMO_FALL = 0x704D2,\n    Z2SE_EN_DS_MDEMO_REBOOT = 0x704D3,\n    Z2SE_EN_DS_H_FLOAT = 0x704D4,\n    Z2SE_EN_DS_H_COL = 0x704D5,\n    Z2SE_EN_DS_H_DOWN_UP = 0x704D6,\n    Z2SE_EN_DS_H_V_DMG_SPNR = 0x704D7,\n    Z2SE_EN_DS_H_V_DMG_SWD = 0x704D8,\n    Z2SE_EN_DS_H_V_ATK = 0x704D9,\n    Z2SE_EN_DS_END_V = 0x704DA,\n    Z2SE_EN_DS_END_COL = 0x704DB,\n    Z2SE_EN_DS_END_COL_LAST = 0x704DC,\n    Z2SE_EN_DR_V_BOOT_A = 0x704DD,\n    Z2SE_EN_DR_V_BOOT_B = 0x704DE,\n    Z2SE_EN_DR_LAND = 0x704DF,\n    Z2SE_EN_DR_CRASH = 0x704E0,\n    Z2SE_EN_DR_CORE_GLOW = 0x704E1,\n    Z2SE_EN_HZE_MOVE = 0x704E2,\n    Z2SE_EN_HZE_V_LAUGH = 0x704E3,\n    Z2SE_EN_HZE_V_ATK_YOKOKU = 0x704E4,\n    Z2SE_EN_HZE_V_ATK_A_START = 0x704E5,\n    Z2SE_EN_HZE_ATK_A_MOVE = 0x704E6,\n    Z2SE_EN_HZE_ATK_B_LIGHT = 0x704E7,\n    Z2SE_EN_HZE_ATK_B_LIGHTWALL = 0x704E8,\n    Z2SE_EN_HZE_V_ATK_B_LIGHTWALL = 0x704E9,\n    Z2SE_EN_HZE_ATK_C_BALL = 0x704EA,\n    Z2SE_EN_HZE_V_ATK_C_THROW = 0x704EB,\n    Z2SE_EN_HZE_ATK_C_BALL_HIT = 0x704EC,\n    Z2SE_EN_HZE_ATK_C_BALL_RETURN = 0x704ED,\n    Z2SE_EN_HZE_V_DAMAGE = 0x704EE,\n    Z2SE_EN_HZE_DAMAGE = 0x704EF,\n    Z2SE_EN_HZE_V_REBIRTH = 0x704F0,\n    Z2SE_EN_HZE_V_DAMAGE_LAST = 0x704F1,\n    Z2SE_EN_ZAN_L4_V = 0x704F2,\n    Z2SE_EN_DS_EYE_OFF = 0x704F3,\n    Z2SE_EN_MGN_DEMO_OP = 0x704F4,\n    Z2SE_EN_MGN_DEMO_END = 0x704F5,\n    Z2SE_EN_MGN_FOOTNOTE = 0x704F6,\n    Z2SE_EN_MGN_WARP = 0x704F7,\n    Z2SE_EN_MGN_SLIP = 0x704F8,\n    Z2SE_EN_MGN_APPR_EFF = 0x704F9,\n    Z2SE_EN_MGN_V_KOROBU = 0x704FA,\n    Z2SE_EN_MGN_V_DAMAGE = 0x704FB,\n    Z2SE_EN_MGN_V_RETURN = 0x704FC,\n    Z2SE_EN_MGN_V_GROWL = 0x704FD,\n    Z2SE_EN_MGN_MIDNA_CATCHED = 0x704FE,\n    Z2SE_EN_MGN_V_MIDNA_CATCHED = 0x704FF,\n    Z2SE_EN_MGN_V_MIDNA_THROW = 0x70500,\n    Z2SE_EN_MGN_V_MIDNA_RELEASE = 0x70501,\n    Z2SE_EN_ZM_BALL_REFLECT = 0x70502,\n    Z2SE_EN_ZM_PARA = 0x70503,\n    Z2SE_EN_GG_V_DEMO_MID = 0x70504,\n    Z2SE_EN_GG_V_TAKE_OFF = 0x70505,\n    Z2SE_EN_GG_V_PULL = 0x70506,\n    Z2SE_EN_GG_ATK_MOVE = 0x70507,\n    Z2SE_EN_GG_V_DEMO_OP_LV9 = 0x70508,\n    Z2SE_EN_HG_V_BREATH = 0x70509,\n    Z2SE_EN_HG_FOOTNOTE_L = 0x7050A,\n    Z2SE_EN_HG_FOOTNOTE_R = 0x7050B,\n    Z2SE_EN_HG_SLIP = 0x7050C,\n    Z2SE_EN_HG_LAND = 0x7050D,\n    Z2SE_EN_HG_V_STAND = 0x7050E,\n    Z2SE_EN_HG_V_STANDTURN = 0x7050F,\n    Z2SE_EN_GND_LIGHTBALL = 0x70510,\n    Z2SE_EN_GND_LIGHTBALL_SPLIT = 0x70511,\n    Z2SE_EN_GND_LIGHTBALL_SUB = 0x70512,\n    Z2SE_EN_GND_LIGHTBALL_SUB_HIT = 0x70513,\n    Z2SE_EN_GND_DENKIBIRI = 0x70514,\n    Z2SE_EN_GND_V_SPUR = 0x70515,\n    Z2SE_EN_GND_V_BRAKE = 0x70516,\n    Z2SE_EN_GND_V_ATTACK01A = 0x70517,\n    Z2SE_EN_GND_V_ATTACK01B = 0x70518,\n    Z2SE_EN_GND_V_ATTACK02A = 0x70519,\n    Z2SE_EN_GND_V_ATTACK02C = 0x7051A,\n    Z2SE_EN_GND_V_JUMP_START = 0x7051B,\n    Z2SE_EN_GND_V_DAMAGE01 = 0x7051C,\n    Z2SE_EN_GND_V_DAMAGE02 = 0x7051D,\n    Z2SE_EN_GND_V_RETURN = 0x7051E,\n    Z2SE_EN_GND_V_DOWN = 0x7051F,\n    Z2SE_EN_DS_H_COL_WALL = 0x70520,\n    Z2SE_EN_PO_V_AWAKE = 0x70521,\n    Z2SE_EN_PO_V_DOWN = 0x70522,\n    Z2SE_EN_PO_LAMP_LAND = 0x70523,\n    Z2SE_EN_PO_SOUL = 0x70524,\n    Z2SE_EN_DS_SMOKE_1 = 0x70525,\n    Z2SE_EN_DS_SMOKE_2 = 0x70526,\n    Z2SE_EN_FK_MOVE = 0x70527,\n    Z2SE_EN_FK_DEATH = 0x70528,\n    Z2SE_EN_HP_V_ATTACK = 0x70529,\n    Z2SE_EN_HP_SWING = 0x7052A,\n    Z2SE_EN_HP_V_DAMAGE = 0x7052B,\n    Z2SE_EN_HP_V_DOWN = 0x7052C,\n    Z2SE_EN_HP_V_DEAD = 0x7052D,\n    Z2SE_EN_HP_V_LAUGH = 0x7052E,\n    Z2SE_EN_HP_V_FOUND = 0x7052F,\n    Z2SE_EN_HP_V_RETURN = 0x70530,\n    Z2SE_EN_HP_MOVE = 0x70531,\n    Z2SE_EN_CR_FOOTNOTE = 0x70532,\n    Z2SE_EN_CR_LAYEGG = 0x70533,\n    Z2SE_EN_CR_EGG_BOMB = 0x70534,\n    Z2SE_EN_CR_V_DEATH = 0x70535,\n    Z2SE_EN_OC_NATA_HIT = 0x70536,\n    Z2SE_EN_OC_NATA_DAGGLE = 0x70537,\n    Z2SE_EN_CR_EGG_BOUND = 0x70538,\n    Z2SE_EN_PO_SOUL_PULLOUT = 0x70539,\n    Z2SE_EN_GND_MANTEAU = 0x7053A,\n    Z2SE_EN_GND_FOOTNOTE = 0x7053B,\n    Z2SE_EN_GND_V_CHOUHATU = 0x7053C,\n    Z2SE_EN_GND_V_ATTACKA = 0x7053D,\n    Z2SE_EN_GND_ATTACKA = 0x7053E,\n    Z2SE_EN_GND_V_ATTACKB = 0x7053F,\n    Z2SE_EN_GND_ATTACKB = 0x70540,\n    Z2SE_EN_GND_V_ATTACKC_A = 0x70541,\n    Z2SE_EN_GND_ATTACKC_A = 0x70542,\n    Z2SE_EN_GND_V_ATTACKC_C = 0x70543,\n    Z2SE_EN_GND_ATTACKC_C = 0x70544,\n    Z2SE_EN_GND_V_ATTACKD = 0x70545,\n    Z2SE_EN_GND_ATTACKD = 0x70546,\n    Z2SE_EN_GND_V_ATTACKE_A = 0x70547,\n    Z2SE_EN_GND_ATTACKE_A = 0x70548,\n    Z2SE_EN_GND_V_ATTACKE_B = 0x70549,\n    Z2SE_EN_GND_ATTACKE_B = 0x7054A,\n    Z2SE_EN_GND_V_ATTACKE_C2 = 0x7054B,\n    Z2SE_EN_GND_ATTACKE_C2 = 0x7054C,\n    Z2SE_EN_GND_V_ATTACK_F = 0x7054D,\n    Z2SE_EN_GND_ATTACK_F = 0x7054E,\n    Z2SE_EN_GND_FN_SLIDE = 0x7054F,\n    Z2SE_EN_GND_V_ATTACK_G1 = 0x70550,\n    Z2SE_EN_GND_ATTACK_G1 = 0x70551,\n    Z2SE_EN_GND_V_ATTACK_G2 = 0x70552,\n    Z2SE_EN_GND_ATTACK_G2 = 0x70553,\n    Z2SE_EN_GND_V_JUMP = 0x70554,\n    Z2SE_EN_GND_JUMP = 0x70555,\n    Z2SE_EN_GND_LAND = 0x70556,\n    Z2SE_EN_GND_TUBAZERI_EFF = 0x70557,\n    Z2SE_EN_GND_V_TUBAZERI_A = 0x70558,\n    Z2SE_EN_GND_V_TUBAZERI_B = 0x70559,\n    Z2SE_EN_GND_V_TUBAZERI_C = 0x7055A,\n    Z2SE_EN_GND_V_TUBAZERI_WIN = 0x7055B,\n    Z2SE_EN_GND_V_TUBAZERI_LOSE = 0x7055C,\n    Z2SE_EN_GND_TUBAZERI_PUSH = 0x7055D,\n    Z2SE_EN_GND_V_DEFENCE = 0x7055E,\n    Z2SE_EN_GND_V_KUZURE = 0x7055F,\n    Z2SE_EN_GND_V_DAMAGE = 0x70560,\n    Z2SE_EN_GND_DOWN = 0x70561,\n    Z2SE_EN_GND_V_DOWNWAIT = 0x70562,\n    Z2SE_EN_GND_V_DOWNUP = 0x70563,\n    Z2SE_EN_GND_V_DOWNB = 0x70564,\n    Z2SE_EN_GND_V_LAUGH = 0x70565,\n    Z2SE_EN_GND_V_END = 0x70566,\n    Z2SE_EN_GND_V_STANDUP = 0x70567,\n    Z2SE_EN_GND_V_LOOK = 0x70568,\n    Z2SE_EN_GND_V_SAYAOPEN = 0x70569,\n    Z2SE_EN_GND_SAYAOPEN = 0x7056A,\n    Z2SE_EN_RDB_LV9_OP = 0x7056B,\n    Z2SE_EN_RDB_V_LV9_OP = 0x7056C,\n    Z2SE_EN_RDB_V_LV9_END01 = 0x7056D,\n    Z2SE_EN_RDB_V_LV9_END02 = 0x7056E,\n    Z2SE_EN_RDB_V_LV9_END03 = 0x7056F,\n    Z2SE_EN_RDB_V_OP_DEMO_SWING = 0x70570,\n    Z2SE_EN_RDB_OP_DEMO_SWING = 0x70571,\n    Z2SE_EN_RDB_V_ED_DEMO_DOWN = 0x70572,\n    Z2SE_EN_RDB_V_ED_DEMO_DOWNUP = 0x70573,\n    Z2SE_EN_RDB_V_ED_DEMO_WALK = 0x70574,\n    Z2SE_EN_RDB_ED_FOOTNOTE = 0x70575,\n    Z2SE_EN_RDB_FOOTNOTE = 0x70576,\n    Z2SE_EN_RDB_V_ATTACK = 0x70577,\n    Z2SE_EN_RDB_ATTACK01 = 0x70578,\n    Z2SE_EN_RDB_ATTACK01_HIT = 0x70579,\n    Z2SE_EN_RDB_ATTACK02 = 0x7057A,\n    Z2SE_EN_RDB_ATTACK02B = 0x7057B,\n    Z2SE_EN_RDB_ATTACK03 = 0x7057C,\n    Z2SE_EN_RDB_V_PUSH = 0x7057D,\n    Z2SE_EN_RDB_DEMO_ONO_LAND = 0x7057E,\n    Z2SE_EN_RDB_V_DEMO_EXCITE = 0x7057F,\n    Z2SE_EN_PH_APPEAR = 0x70580,\n    Z2SE_D29_GND_TF_OFF = 0x70581,\n    Z2SE_D29_ZAN_NECK = 0x70582,\n    Z2SE_D29_GND_WIND = 0x70583,\n    Z2SE_D32_GND_TF1 = 0x70584,\n    Z2SE_D32_GND_HAND1 = 0x70585,\n    Z2SE_D32_GND_TF2 = 0x70586,\n    Z2SE_D32_GND_HAND2 = 0x70587,\n    Z2SE_D32_GND_ATK = 0x70588,\n    Z2SE_D32_GND_WARP = 0x70589,\n    Z2SE_D33_ZAN_MASK_OFF = 0x7058A,\n    Z2SE_D33_ZAN_BTBT_1 = 0x7058B,\n    Z2SE_D33_ZAN_BTBT_2 = 0x7058C,\n    Z2SE_D33_ZAN_ZOOM_UP = 0x7058D,\n    Z2SE_D33_GND_BALL1 = 0x7058E,\n    Z2SE_D33_GND_BALL2 = 0x7058F,\n    Z2SE_D33_ZAN_INTO_BALL = 0x70590,\n    Z2SE_D33_GND_FIRE = 0x70591,\n    Z2SE_D25_ZAN_STICK = 0x70592,\n    Z2SE_D25_ZAN_BALOON = 0x70593,\n    Z2SE_D27_GND_KIZU = 0x70594,\n    Z2SE_D27_GND_TF = 0x70595,\n    Z2SE_D27_GND_PTCL_1 = 0x70596,\n    Z2SE_D27_GND_PTCL_2 = 0x70597,\n    Z2SE_D27_GND_PTCL_3 = 0x70598,\n    Z2SE_D27_HZEL_EYE_OP = 0x70599,\n    Z2SE_D27_HZEL_FLOAT = 0x7059A,\n    Z2SE_D27_HZEL_LIGHT = 0x7059B,\n    Z2SE_D27_GND_GATHER = 0x7059C,\n    Z2SE_D28_MGN_FIRE = 0x7059D,\n    Z2SE_D28_MGN_CHANGE = 0x7059E,\n    Z2SE_D28_GND_SPIRIT = 0x7059F,\n    Z2SE_D28V_GND_CRY_1 = 0x705A0,\n    Z2SE_D28_WIND = 0x705A2,\n    Z2SE_D28_FK_THROUGH_1 = 0x705A3,\n    Z2SE_D28_FK_THROUGH_2 = 0x705A4,\n    Z2SE_D24_ZAN_PUNCH = 0x705A5,\n    Z2SE_EN_GND_V_DAMAGE_DOWN = 0x705A6,\n    Z2SE_D20_ZAN_APPEAR = 0x705A7,\n    Z2SE_D20_ZAN_MAGIC_ATK = 0x705A8,\n    Z2SE_D20_ZAN_MASK_OP = 0x705A9,\n    Z2SE_EN_HZE_V_ATK_C_RETURN = 0x705AA,\n    Z2SE_D07_NS_CATCH_FACE = 0x705AD,\n    Z2SE_D07_NS_JUMP_LAND = 0x705B0,\n    Z2SE_D15_RDB_HELM_UP = 0x705B1,\n    Z2SE_D36_RD_1_FALL = 0x705B2,\n    Z2SE_D36_RD_2_FALL = 0x705B3,\n    Z2SE_EN_MGN_V_TURN = 0x705B4,\n    Z2SE_EN_GG_MET_BREAK = 0x705B5,\n    Z2SE_EN_GG_MET_LAND = 0x705B6,\n    Z2SE_EN_DR_DEMO_FIRST = 0x705B7,\n    Z2SE_EN_YC_V_NAKU = 0x705B8,\n    Z2SE_EN_KC_V_NAKU = 0x705B9,\n    Z2SE_OBJ_ARROW_DRAW_NORMAL = 0x80000,\n    Z2SE_OBJ_DARK_GATE_RIPPLE_WLF = 0x80001,\n    Z2SE_OBJ_ARROW_SHOT_NORMAL = 0x80002,\n    Z2SE_OBJ_ARROW_SHOT_GAIN = 0x80003,\n    Z2SE_OBJ_ARROW_FLY_NORMAL = 0x80004,\n    Z2SE_OBJ_ARROW_FLY_GAIN = 0x80005,\n    Z2SE_OBJ_ARROW_FIRE_READY = 0x80006,\n    Z2SE_OBJ_ARROW_SHOT_FIRE = 0x80007,\n    Z2SE_OBJ_ARROW_FLY_FIRE = 0x80008,\n    Z2SE_OBJ_BOMB_WALL_BREAK = 0x80009,\n    Z2SE_OBJ_BOMB_IGNITION = 0x8000A,\n    Z2SE_OBJ_BOMB_EXPLODE = 0x8000B,\n    Z2SE_OBJ_ARROWBOMB_SHOT = 0x8000C,\n    Z2SE_OBJ_ARROWBOMB_SHOTGAIN = 0x8000D,\n    Z2SE_OBJ_ARROWBOMB_FLY = 0x8000E,\n    Z2SE_OBJ_ARROWBOMB_FLYGAIN = 0x8000F,\n    Z2SE_OBJ_DOOR_STEEL_BAR = 0x80010,\n    Z2SE_OBJ_STONE_DOOR_OPEN = 0x80011,\n    Z2SE_OBJ_STONE_DOOR_CLOSE = 0x80012,\n    Z2SE_OBJ_STONE_DOOR_OPEN_STOP = 0x80013,\n    Z2SE_OBJ_STONE_DOOR_CLOSE_STOP = 0x80014,\n    Z2SE_OBJ_MK_COLUMN_SHAKE = 0x80015,\n    Z2SE_OBJ_BOMB_ROCK_BREAK = 0x80016,\n    Z2SE_OBJ_FIRE_IGNITION = 0x80017,\n    Z2SE_OBJ_FIRE_BURNING = 0x80018,\n    Z2SE_OBJ_FIRE_OFF = 0x80019,\n    Z2SE_OBJ_WATERBOMB_EXPLODE = 0x8001A,\n    JA_SE_OBJ_STN_DOOR_MOVE_U = 0x8001B,\n    JA_SE_OBJ_STN_DOOR_MOVE_D = 0x8001C,\n    JA_SE_OBJ_STN_DOOR_STOP_U = 0x8001D,\n    JA_SE_OBJ_STN_DOOR_STOP_D = 0x8001E,\n    Z2SE_OBJ_TBOX_OPEN_A = 0x8001F,\n    Z2SE_OBJ_TBOX_OPEN_B = 0x80020,\n    Z2SE_OBJ_TBOX_OPEN_B_SLOW = 0x80021,\n    Z2SE_OBJ_TBOX_OPEN_C = 0x80022,\n    Z2SE_OBJ_KNOB_DOOR_LOCKED = 0x80023,\n    Z2SE_OBJ_KNOB_DOOR_OPEN = 0x80024,\n    Z2SE_OBJ_KNOB_DOOR_CLOSE = 0x80025,\n    Z2SE_OBJ_ROCK_FALL_DUMMY = 0x80026,\n    Z2SE_OBJ_ROCK_FALL_DIRECT = 0x80027,\n    Z2SE_OBJ_BOMB_EXP_WTRSURF = 0x80028,\n    Z2SE_OBJ_FALL_WATER_S = 0x80029,\n    Z2SE_OBJ_FALL_WATER_M = 0x8002A,\n    Z2SE_OBJ_FALL_WATER_L = 0x8002B,\n    JA_SE_OBJ_FALL_MAGMA_S = 0x8002C,\n    JA_SE_OBJ_FALL_MAGMA_M = 0x8002D,\n    JA_SE_OBJ_FALL_MAGMA_L = 0x8002E,\n    JA_SE_OBJ_BLOCK_FALL_NORMAL = 0x8002F,\n    JA_SE_OBJ_WBOX_FALL_NORMAL = 0x80030,\n    JA_SE_OBJ_BREAK_WATER_POT = 0x80031,\n    JA_SE_OBJ_BURN_WBOX_S = 0x80032,\n    JA_SE_OBJ_BURN_WBOX_L = 0x80033,\n    JA_SE_OBJ_BURN_WRAILING = 0x80034,\n    JA_SE_OBJ_PUT_POT_S = 0x80035,\n    JA_SE_OBJ_PUT_POT_L = 0x80036,\n    JA_SE_OBJ_PUT_POT_W = 0x80037,\n    JA_SE_OBJ_PUT_WBOX_S = 0x80038,\n    JA_SE_OBJ_PUT_STONE = 0x80039,\n    JA_SE_OBJ_PUT_ROCK = 0x8003A,\n    Z2SE_OBJ_BREAK_STONE = 0x8003B,\n    Z2SE_OBJ_BREAK_ROCK = 0x8003C,\n    Z2SE_OBJ_BREAK_STEPS = 0x8003D,\n    Z2SE_OBJ_BREAK_BAMBOOFENCE = 0x8003E,\n    JA_SE_OBJ_FOOT_SW_ON = 0x80040,\n    Z2SE_OBJ_D19_DOOR_CLOSE = 0x80041,\n    Z2SE_OBJ_D19_PUT_LANCE = 0x80042,\n    Z2SE_OBJ_D18_SWORD_STICK = 0x80043,\n    Z2SE_OBJ_HACHINOSU_HIT = 0x80044,\n    Z2SE_OBJ_HACHINOSU_BOUND = 0x80045,\n    Z2SE_OBJ_HACHINOSU_BREAK = 0x80046,\n    Z2SE_OBJ_SNOWTREE_HIT = 0x80050,\n    Z2SE_OBJ_BOSS_LOCK_OPEN = 0x80060,\n    Z2SE_OBJ_LUPY_OUT = 0x80078,\n    Z2SE_OBJ_LUPY_BOUND = 0x80083,\n    Z2SE_OBJ_MAGIC_POT_BOUND = 0x80084,\n    Z2SE_OBJ_ARROW_BOUND = 0x80085,\n    Z2SE_OBJ_GEYSER_LOW = 0x80088,\n    Z2SE_OBJ_GEYSER_HIGH = 0x80089,\n    Z2SE_OBJ_BOMB_BOUND = 0x80094,\n    Z2SE_OBJ_WOODSHIELD_BREAK = 0x80095,\n    Z2SE_OBJ_GNAW_CHAIN_SW = 0x80096,\n    Z2SE_OBJ_PULLDOWN_CHAIN_SW = 0x80097,\n    Z2SE_OBJ_STOP_CHAIN_SW = 0x80098,\n    Z2SE_OBJ_SWAY_CHAIN = 0x80099,\n    Z2SE_OBJ_OPEN_CHAIN_SW_DOOR = 0x8009A,\n    Z2SE_OBJ_MOVE_JAIL_DOOR = 0x8009B,\n    Z2SE_OBJ_OPEN_ZELDAROOM_DOOR = 0x8009C,\n    Z2SE_OBJ_BREAK_IRON_FENCE = 0x8009D,\n    Z2SE_OBJ_FIREWOOD_BURNING = 0x800A3,\n    Z2SE_OBJ_FIREWOOD_SHAKE = 0x800A4,\n    Z2SE_OBJ_FIREWOOD_BREAK = 0x800A5,\n    Z2SE_OBJ_FIREWOOD_SMOKE = 0x800A6,\n    Z2SE_OBJ_PUMPKIN_PULLOUT = 0x800A7,\n    Z2SE_OBJ_PUMPKIN_PUT = 0x800A8,\n    Z2SE_OBJ_PUMPKIN_CRASH = 0x800A9,\n    Z2SE_OBJ_WARP_RESPONSE = 0x800AA,\n    Z2SE_OBJ_WARP_HINT = 0x800AB,\n    Z2SE_OBJ_PEEL_OFF_TILE = 0x800AC,\n    Z2SE_OBJ_WARP_HOLE = 0x800AD,\n    Z2SE_OBJ_WARP_OUT = 0x800AE,\n    Z2SE_OBJ_MONKEYJAIL_BREAK = 0x800AF,\n    Z2SE_OBJ_MONKEYJAIL_CREAK = 0x800B0,\n    Z2SE_OBJ_MONKEYJAIL_SHAKE = 0x800B1,\n    Z2SE_OBJ_WOOD_DOOR_ROLLOPEN = 0x800B2,\n    Z2SE_OBJ_WOOD_DOOR_ROLLCLOSE = 0x800B3,\n    Z2SE_OBJ_WOOD_DOOR_OPEN_STOP = 0x800B4,\n    Z2SE_OBJ_WOOD_DOOR_CLOSE_STOP = 0x800B5,\n    Z2SE_OBJ_DOOR_CHAIN_LOCK_OPEN = 0x800B6,\n    Z2SE_OBJ_BOKKURI_PULLOUT = 0x800B7,\n    Z2SE_OBJ_BOKKURI_PUT = 0x800B8,\n    Z2SE_OBJ_BOKKURI_BURST = 0x800B9,\n    Z2SE_OBJ_PEEL_OFF_LEAVES = 0x800BA,\n    Z2SE_OBJ_FOOT_SWITCH_ON = 0x800BB,\n    Z2SE_OBJ_FOOT_SWITCH_SLIDE = 0x800BC,\n    Z2SE_OBJ_KAKASHI_SHAKE = 0x800BD,\n    Z2SE_OBJ_FLAG_TRAILING = 0x800BE,\n    Z2SE_OBJ_BRIDGE_TRAILING = 0x800BF,\n    Z2SE_OBJ_BOKKURI_HIT_ROLL = 0x800C0,\n    Z2SE_OBJ_WATERMILL_ROUND = 0x800C1,\n    Z2SE_OBJ_DOOR_WOOD_BAR_CL = 0x800C2,\n    Z2SE_OBJ_DOOR_WOOD_BAR_OP = 0x800C3,\n    Z2SE_OBJ_KEY_BOUND = 0x800C4,\n    Z2SE_OBJ_KEY_TWINKLE = 0x800C5,\n    Z2SE_OBJ_CANOE_WAVE = 0x800C6,\n    Z2SE_OBJ_WOOD_DOOR_ROLLOPEN2 = 0x800C7,\n    Z2SE_OBJ_CAT_DOOR = 0x800C8,\n    Z2SE_OBJ_RANCH_WOODPLATE = 0x800C9,\n    Z2SE_OBJ_CAT_VANE_ROLL = 0x800CA,\n    Z2SE_OBJ_CAT_VANE_BREAK = 0x800CB,\n    Z2SE_OBJ_STEP_MOVESTART = 0x800CC,\n    Z2SE_OBJ_STEP_MOVE = 0x800CD,\n    Z2SE_OBJ_STEP_MOVEEND = 0x800CE,\n    Z2SE_OBJ_BOOMSHTR_SWITCH = 0x800CF,\n    Z2SE_OBJ_BOOMSHTR_GATA = 0x800D0,\n    Z2SE_OBJ_BOOMSHTR_OPEN = 0x800D1,\n    Z2SE_OBJ_STRAWFENCE_IGNITION = 0x800D2,\n    Z2SE_OBJ_STRAWFENCE_BURNING = 0x800D3,\n    Z2SE_OBJ_BOKKURI_FALLWATER = 0x800D4,\n    Z2SE_OBJ_BONES_BREAK_L = 0x800D5,\n    Z2SE_OBJ_KEY_TWINKLE_HIDDEN = 0x800D6,\n    Z2SE_OBJ_RANCHHOUSE_DOOR_OPEN = 0x800D7,\n    Z2SE_OBJ_KEYLOCK_BOUND = 0x800D8,\n    Z2SE_OBJ_BOOMSHTR2_GATA1 = 0x800DC,\n    Z2SE_OBJ_BOOMSHTR2_GATA2 = 0x800DD,\n    Z2SE_OBJ_BOOMSHTR2_GATA3 = 0x800DE,\n    Z2SE_OBJ_BOOMSHTR2_DIRT = 0x800DF,\n    Z2SE_OBJ_BOOMSHTR2_DIRT_L = 0x800E0,\n    Z2SE_OBJ_BOOMSHTR2_OPEN = 0x800E1,\n    Z2SE_OBJ_BOOMSHTR2_PARA = 0x800E2,\n    Z2SE_OBJ_BOOMSHTR_HIT_SW = 0x800E3,\n    Z2SE_OBJ_BOARD_BREAK = 0x800E4,\n    Z2SE_OBJ_BOARD_BOUND = 0x800E5,\n    Z2SE_OBJ_BOARD_PUT = 0x800E6,\n    Z2SE_OBJ_DARK_GATE = 0x800E7,\n    Z2SE_OBJ_COLUMN_SHAKE_HARD = 0x800E8,\n    Z2SE_OBJ_COLUMN_SHAKE_FIRST = 0x800E9,\n    Z2SE_WARP_HOLE_OPEN = 0x800EA,\n    Z2SE_DEMO_NS_WARPHOLE = 0x800EB,\n    Z2SE_OBJ_WATERGATE_MOVE = 0x800EC,\n    Z2SE_OBJ_LIGHTDROP_APPEAR = 0x800ED,\n    Z2SE_OBJ_LIGHTDROP_FLOAT = 0x800EE,\n    Z2SE_OBJ_LIGHTDROP_DRAW_IN = 0x800EF,\n    Z2SE_OBJ_BARRIER_STN_APPEAR = 0x800F0,\n    Z2SE_OBJ_BARRIER_STN_STICK = 0x800F1,\n    Z2SE_OBJ_BARRIER_STN_DISAPPEAR = 0x800F2,\n    Z2SE_OBJ_BARRIER_STN_TURN_ON = 0x800F3,\n    Z2SE_OBJ_BARRIER_EMERGENCE = 0x800F4,\n    Z2SE_OBJ_BARRIER_COLLISION = 0x800F5,\n    Z2SE_OBJ_SKULL_BREAK = 0x800F6,\n    Z2SE_OBJ_SKULL_PUT = 0x800F7,\n    Z2SE_OBJ_PUT_WATER_S = 0x800F8,\n    Z2SE_OBJ_PUT_WATER_M = 0x800F9,\n    Z2SE_OBJ_PUT_WATER_L = 0x800FA,\n    Z2SE_OBJ_WOODBOX_BREAK = 0x800FB,\n    Z2SE_OBJ_ZELDAROOM_DOOR_MOVE = 0x800FC,\n    Z2SE_OBJ_SPIRALSTEP_DOOR_1 = 0x800FD,\n    Z2SE_OBJ_SPIRALSTEP_DOOR_2 = 0x800FE,\n    Z2SE_OBJ_SPIRALSTEP_DOOR_3 = 0x800FF,\n    Z2SE_OBJ_SPIRALSTEP_DOOR_4 = 0x80100,\n    Z2SE_OBJ_SPIRALSTEP_DOOR_5 = 0x80101,\n    Z2SE_OBJ_SPIRALSTEP_DOOR_6 = 0x80102,\n    Z2SE_OBJ_SPIRALSTEP_DOOR_7 = 0x80103,\n    Z2SE_OBJ_SPIRALSTEP_DOOR_8 = 0x80104,\n    Z2SE_OBJ_SPIRALSTEP_DOOR_BOUND = 0x80105,\n    Z2SE_OBJ_WOODSHIELD_SHAKE = 0x80106,\n    Z2SE_OBJ_WOODSHIELD_COME_OFF = 0x80107,\n    Z2SE_OBJ_WOODSHIELD_BOUND = 0x80108,\n    Z2SE_OBJ_GOBFLOOR_CHAIN_BREAK = 0x80109,\n    Z2SE_OBJ_GOBFLOOR_INTO_MAGMA = 0x8010A,\n    Z2SE_OBJ_WOODSTICK_BOUND = 0x8010B,\n    Z2SE_OBJ_WOODSTICK_PUT = 0x8010C,\n    Z2SE_OBJ_CHURCH_ALTER_MOVE = 0x8010D,\n    Z2SE_OBJ_CHURCH_ALTER_STOP = 0x8010E,\n    Z2SE_OBJ_WOODROOF_BREAK = 0x8010F,\n    Z2SE_OBJ_GLASSWINDOW_BREAK = 0x80110,\n    Z2SE_OBJ_CHEST_DOWN = 0x80111,\n    Z2SE_OBJ_WEB_BURN = 0x80112,\n    Z2SE_OBJ_WEB_BOUND_L = 0x80113,\n    Z2SE_OBJ_WEB_BOUND_S = 0x80114,\n    Z2SE_OBJ_ROLLBRG_MOVESTART = 0x80116,\n    Z2SE_OBJ_ROLLBRG_MOVE = 0x80117,\n    Z2SE_OBJ_ROLLBRG_MOVEEND = 0x80118,\n    Z2SE_OBJ_BOOMSHTR_ATTACK = 0x80119,\n    Z2SE_OBJ_BOOMSHTR_S_OPEN = 0x8011A,\n    Z2SE_OBJ_CBLOCK_SLIDEMOVE = 0x8011B,\n    Z2SE_OBJ_CBLOCK_STOP = 0x8011C,\n    Z2SE_OBJ_MYNA_LIGHT_BURNING = 0x8011D,\n    Z2SE_OBJ_MYNA_LIGHT_ON = 0x8011E,\n    Z2SE_OBJ_MYNA_LIGHT_OFF = 0x8011F,\n    Z2SE_OBJ_BROKENBRIDGE = 0x80120,\n    Z2SE_OBJ_BOOMSHTR2_CLOSE = 0x80121,\n    Z2SE_OBJ_MAGMAPOLE_YOBI = 0x80122,\n    Z2SE_OBJ_MAGMAPOLE_BLAST = 0x80123,\n    Z2SE_OBJ_PIPEFIRE_REST = 0x80124,\n    Z2SE_OBJ_PIPEFIRE_YOBI = 0x80125,\n    Z2SE_OBJ_PIPEFIRE_BLAST = 0x80126,\n    Z2SE_OBJ_HEAVYSW_MOVE = 0x80127,\n    Z2SE_OBJ_HEAVYSW_UP = 0x80128,\n    Z2SE_OBJ_HEAVYSW_DOWN = 0x80129,\n    Z2SE_OBJ_HEAVYSW_STOP = 0x8012A,\n    Z2SE_OBJ_GORONGATE_MOVE = 0x8012B,\n    Z2SE_OBJ_GORONGATE_STOP = 0x8012C,\n    Z2SE_OBJ_BREAK_WOODNAIL_FENCE = 0x8012D,\n    Z2SE_OBJ_BREAK_BARREL = 0x8012E,\n    Z2SE_OBJ_MAGNELIFT_TURN_S = 0x8012F,\n    Z2SE_OBJ_MAGNELIFT_STOP_S = 0x80130,\n    Z2SE_OBJ_MAGNELIFT_TURN_M = 0x80131,\n    Z2SE_OBJ_MAGNELIFT_STOP_M = 0x80132,\n    Z2SE_OBJ_MAGNELIFT_TURN_L = 0x80133,\n    Z2SE_OBJ_MAGNELIFT_STOP_L = 0x80134,\n    Z2SE_OBJ_CWALL_MOVE = 0x80135,\n    Z2SE_OBJ_CWALL_MOVE_STOP = 0x80136,\n    Z2SE_OBJ_CWALL_BACK = 0x80137,\n    Z2SE_OBJ_CWALL_BACK_STOP = 0x80138,\n    Z2SE_OBJ_BOMBBARREL_HIT = 0x80139,\n    Z2SE_OBJ_BOMBBARREL_IGNITION = 0x8013A,\n    Z2SE_OBJ_BOMBBARREL_BREAK = 0x8013B,\n    Z2SE_OBJ_MOVE_WBLOCK = 0x8013C,\n    Z2SE_OBJ_MOVE_WBLOCK_LIMIT = 0x8013D,\n    Z2SE_OBJ_ATK_FENCE_HIT = 0x8013E,\n    Z2SE_OBJ_ATK_FENCE_FALLDOWN = 0x8013F,\n    Z2SE_OBJ_HEAVY_FUMISW_RIDE = 0x80140,\n    Z2SE_OBJ_HEAVY_FUMISW_DROP = 0x80141,\n    Z2SE_OBJ_HEAVY_FUMISW_ON = 0x80142,\n    Z2SE_OBJ_ROPEBRDG_CUT = 0x80143,\n    Z2SE_OBJ_ROPEBRDG_MOVE_S = 0x80144,\n    Z2SE_OBJ_ROPEBRDG_FALLDOWN_S = 0x80145,\n    Z2SE_OBJ_ROPEBRDG_MOVE_L = 0x80146,\n    Z2SE_OBJ_ROPEBRDG_FALLDOWN_L = 0x80147,\n    Z2SE_OBJ_MAGNEARM_MOVESTART = 0x80148,\n    Z2SE_OBJ_MAGNEARM_MOVE = 0x80149,\n    Z2SE_OBJ_MAGNEARM_STOP = 0x8014A,\n    Z2SE_OBJ_MAGNEARM_UP = 0x8014B,\n    Z2SE_OBJ_MAGNEARM_DOWN = 0x8014C,\n    Z2SE_OBJ_MAGNEARM_SWING = 0x8014D,\n    Z2SE_OBJ_BREAK_WOOD_S = 0x8014E,\n    Z2SE_OBJ_BREAK_WOOD_L = 0x8014F,\n    Z2SE_OBJ_BLOCK_FALL_NORMAL = 0x80150,\n    Z2SE_OBJ_WBOX_FALL_NORMAL = 0x80151,\n    Z2SE_OBJ_PUT_WBOX_S = 0x80152,\n    Z2SE_OBJ_PUT_STONE = 0x80153,\n    Z2SE_OBJ_MOVE_ROCK = 0x80154,\n    Z2SE_OBJ_MOVE_ROCK_LIMIT = 0x80155,\n    Z2SE_OBJ_HEAVY_FUMISW_OFF = 0x80156,\n    Z2SE_OBJ_ELEVATOR_START = 0x80157,\n    Z2SE_OBJ_ELEVATOR_MOVE = 0x80158,\n    Z2SE_OBJ_ELEVATOR_STOP = 0x80159,\n    Z2SE_OBJ_CHAINSW_PULL = 0x8015A,\n    Z2SE_OBJ_CHAINSW_PULLHEAVY = 0x8015B,\n    Z2SE_OBJ_CHAINSW_BACK = 0x8015C,\n    Z2SE_OBJ_CHAINSW_BACKFAST = 0x8015D,\n    Z2SE_OBJ_CHAINSW_ON = 0x8015E,\n    Z2SE_OBJ_CHAND_TOP = 0x8015F,\n    Z2SE_OBJ_CHAND_FALLDOWN = 0x80160,\n    Z2SE_OBJ_CHAND_FALLDOWN_S = 0x80161,\n    Z2SE_OBJ_FM_BREAK_PILLAR = 0x80162,\n    Z2SE_OBJ_FM_DIRTFALL = 0x80163,\n    Z2SE_OBJ_STALAC_BREAK = 0x80164,\n    Z2SE_OBJ_STALAC_LAND = 0x80165,\n    Z2SE_OBJ_STALAC_LAND_WATER = 0x80166,\n    Z2SE_OBJ_ROLLSTAIR_ROLL = 0x80167,\n    Z2SE_OBJ_ROLLSTAIR_STOP = 0x80168,\n    Z2SE_OBJ_BURASW_ON = 0x80169,\n    Z2SE_OBJ_BURASW_OFF = 0x8016A,\n    Z2SE_OBJ_FLOATBOARD = 0x8016B,\n    Z2SE_OBJ_FLOATBOARD_SWING = 0x8016C,\n    Z2SE_OBJ_FLOATBOARD_SWING_L = 0x8016D,\n    Z2SE_OBJ_CWALL_BACK_SLOW = 0x8016E,\n    Z2SE_OBJ_CWALL_CHAIN_TENSION = 0x8016F,\n    Z2SE_OBJ_ROOF_ANA = 0x80170,\n    Z2SE_OBJ_MADO_YURE = 0x80171,\n    Z2SE_OBJ_MADO_NOT_BREAK = 0x80172,\n    Z2SE_OBJ_MADO_BREAK_PRPR = 0x80173,\n    Z2SE_OBJ_TANSU_YURE = 0x80174,\n    Z2SE_OBJ_BOMB_HOUSE_BURN = 0x80175,\n    Z2SE_OBJ_BOMB_HOUSE_BURN_S = 0x80176,\n    Z2SE_OBJ_BOMB_HOUSE_EXPLD = 0x80177,\n    Z2SE_OBJ_TABLE_BRAKE = 0x80178,\n    Z2SE_OBJ_ARW_TRGT_BRK = 0x80179,\n    Z2SE_OBJ_ARW_TRGT_BRK_LAST = 0x8017A,\n    Z2SE_OBJ_SHOCK_SW_ON = 0x8017B,\n    Z2SE_OBJ_GEAR_LV = 0x8017D,\n    Z2SE_OBJ_WTR_WHL_1 = 0x8017E,\n    Z2SE_OBJ_WTR_WHL_1_SPLSH = 0x8017F,\n    Z2SE_OBJ_WTR_WHL_2 = 0x80180,\n    Z2SE_OBJ_WTR_WHL_2_SPLSH = 0x80181,\n    Z2SE_OBJ_WTR_CLMN_WAIT = 0x80182,\n    Z2SE_OBJ_WTR_CLMN_READY = 0x80183,\n    Z2SE_OBJ_WTR_CLMN_UP = 0x80184,\n    Z2SE_OBJ_WTR_CLMN_DOWN = 0x80186,\n    Z2SE_OBJ_SW_W_DR_OP = 0x80187,\n    Z2SE_OBJ_SW_W_DR_OP_STOP = 0x80188,\n    Z2SE_OBJ_SW_W_DR_CL = 0x80189,\n    Z2SE_OBJ_SW_W_DR_CL_STOP = 0x8018A,\n    Z2SE_OBJ_LV3_KNOB_DR_OP = 0x8018B,\n    Z2SE_OBJ_LV3_KNOB_DR_CL = 0x8018C,\n    Z2SE_OBJ_NET_SHTR_OP = 0x8018D,\n    Z2SE_OBJ_NET_SHTR_CL = 0x8018E,\n    Z2SE_OBJ_NET_L_SHTR_CL = 0x8018F,\n    Z2SE_OBJ_SW_FENCE_DOWN = 0x80190,\n    Z2SE_OBJ_LV3_SHTR_OP = 0x80191,\n    Z2SE_OBJ_LV3_SHTR_CL = 0x80192,\n    Z2SE_OBJ_WALLSHUTTER_OPEN = 0x80193,\n    Z2SE_OBJ_LV3_SHTR_UP_STOP = 0x80194,\n    Z2SE_OBJ_LV3_SHTR_DW_STOP = 0x80195,\n    Z2SE_OBJ_LV3_SHTR_CL_WTR = 0x80196,\n    Z2SE_OBJ_LV3_SHTR_OP_MDN = 0x80197,\n    Z2SE_OBJ_SW_FENCE_DWN_WTR = 0x80198,\n    Z2SE_OBJ_MAGNE_EFFECT = 0x80199,\n    Z2SE_OBJ_LV3_SHTR_OP_FX = 0x8019A,\n    Z2SE_OBJ_WOOD_DR_OP_MDN = 0x8019B,\n    Z2SE_OBJ_WOOD_DR_OP_MDN_FX = 0x8019C,\n    Z2SE_OBJ_SPNR_SW_FIT = 0x8019D,\n    Z2SE_OBJ_SPNR_SW_CL = 0x8019E,\n    Z2SE_OBJ_SPNR_GEAR_S = 0x8019F,\n    Z2SE_OBJ_STN_WL_RL = 0x801A0,\n    Z2SE_OBJ_STN_WL_RL_OP = 0x801A1,\n    Z2SE_OBJ_STN_WL_RL_ST = 0x801A2,\n    Z2SE_OBJ_STN_SPRL_RAIL = 0x801A3,\n    Z2SE_OBJ_STN_SPRL_RAIL_DW = 0x801A4,\n    Z2SE_OBJ_STN_SPRL_RAIL_ST = 0x801A5,\n    Z2SE_OBJ_RL_SWD_LV = 0x801A6,\n    Z2SE_OBJ_RL_SWD_TRG = 0x801A7,\n    Z2SE_OBJ_SWD_FENCE_POP = 0x801A8,\n    Z2SE_OBJ_TOGE_SPIN = 0x801A9,\n    Z2SE_OBJ_RL_SW_WALL_ON = 0x801AA,\n    Z2SE_OBJ_RL_SW_WALL_OFF = 0x801AB,\n    Z2SE_OBJ_RL_SW_WALL_MV = 0x801AC,\n    Z2SE_OBJ_RL_SW_ELVTR_UP = 0x801AD,\n    Z2SE_OBJ_RL_SW_ELVTR_DW = 0x801AE,\n    Z2SE_OBJ_RL_SW_ELVTR_ON = 0x801AF,\n    Z2SE_OBJ_RL_SW_ELVTR_OFF = 0x801B0,\n    Z2SE_OBJ_HIDDEN_WALL_MV = 0x801B1,\n    Z2SE_OBJ_HIDDEN_WALL_ST = 0x801B2,\n    Z2SE_OBJ_POU_GATE_CL = 0x801B3,\n    Z2SE_OBJ_POU_GATE_OP = 0x801B4,\n    Z2SE_OBJ_FALL_STAIR = 0x801B5,\n    Z2SE_OBJ_STL_FENCE_UP = 0x801B6,\n    Z2SE_OBJ_STL_FENCE_DW = 0x801B7,\n    Z2SE_OBJ_LV4_CNDL_MISS = 0x801B8,\n    Z2SE_OBJ_CHANDELIER_SWING = 0x801B9,\n    Z2SE_OBJ_CHANDELIER_UP = 0x801BA,\n    Z2SE_OBJ_CHANDELIER_DW_TRG = 0x801BB,\n    Z2SE_OBJ_CHANDELIER_DW_LV = 0x801BC,\n    Z2SE_OBJ_SINK_FLOOR_DW = 0x801BD,\n    Z2SE_OBJ_SINK_FLOOR_UP = 0x801BE,\n    Z2SE_OBJ_SPNR_RAIL_ATRCT = 0x801BF,\n    Z2SE_OBJ_HEAVYSW_ON = 0x801C0,\n    Z2SE_OBJ_SPNR_GEAR_L = 0x801C1,\n    Z2SE_OBJ_POU_GATE_QUAKE = 0x801C2,\n    Z2SE_OBJ_RL_SW_ELVTR_OFF_TOP = 0x801C3,\n    Z2SE_OBJ_LV3_FLR_SW_ON = 0x801C4,\n    Z2SE_OBJ_LV3_FLR_SW_OFF = 0x801C5,\n    Z2SE_OBJ_BOSS_LOCK_OPEN_LV5 = 0x801C6,\n    Z2SE_OBJ_ICE_BREAK = 0x801C7,\n    Z2SE_OBJ_ICE_KEZURU = 0x801C8,\n    Z2SE_OBJ_CANNON_CHARGE = 0x801C9,\n    Z2SE_OBJ_CANNON_MOVE = 0x801CA,\n    Z2SE_OBJ_CANNON_STOP = 0x801CB,\n    Z2SE_OBJ_SPNR_SW_RL = 0x801CC,\n    Z2SE_OBJ_DOOR_STEEL_BAR_CL = 0x801CD,\n    Z2SE_OBJ_FIRE_TAKEN = 0x801CE,\n    Z2SE_OBJ_FIRE_EMERGE = 0x801CF,\n    Z2SE_OBJ_FIRE_FLY = 0x801D0,\n    Z2SE_OBJ_KNTR_BREAK = 0x801D1,\n    Z2SE_OBJ_IRONBLOCK_MOVE = 0x801D2,\n    Z2SE_OBJ_IRONBLOCK_STOP = 0x801D3,\n    Z2SE_OBJ_IRONBALL_HIT = 0x801D4,\n    Z2SE_OBJ_IRONBALL_HIT_SNOW = 0x801D5,\n    Z2SE_OBJ_IRONBALL_HIT_ICE = 0x801D6,\n    Z2SE_OBJ_ARMOR_SWING = 0x801D7,\n    Z2SE_OBJ_ARMOR_HIT = 0x801D8,\n    Z2SE_OBJ_ARMOR_BREAK = 0x801D9,\n    Z2SE_OBJ_CHANDLV5_HIT = 0x801DA,\n    Z2SE_OBJ_CHANDLV5_SWING = 0x801DB,\n    Z2SE_OBJ_BREAK_FLOOR = 0x801DC,\n    Z2SE_OBJ_IRONTRAY_SWITCH = 0x801DD,\n    Z2SE_OBJ_IRONTRAY_BALL = 0x801DE,\n    Z2SE_OBJ_IRONBLOCK_LAND = 0x801DF,\n    Z2SE_OBJ_DOOR_LOCK_OPEN = 0x801E0,\n    Z2SE_OBJ_TOGE_ROLL_MV = 0x801E1,\n    Z2SE_OBJ_L6_RL_SW_ON = 0x801E2,\n    Z2SE_OBJ_L6_RL_SW_OFF = 0x801E3,\n    Z2SE_OBJ_L6_RL_SW_MV = 0x801E4,\n    Z2SE_OBJ_L6_RL_FLR_MV = 0x801E5,\n    Z2SE_OBJ_L6_RL_FLR_ST = 0x801E6,\n    Z2SE_OBJ_L6_SW_GATE_OP_MV = 0x801E7,\n    Z2SE_OBJ_L6_SW_GATE_OP_ST = 0x801E8,\n    Z2SE_OBJ_L6_SW_GATE_CL_MV = 0x801E9,\n    Z2SE_OBJ_L6_SW_GATE_CL_ST = 0x801EA,\n    Z2SE_OBJ_L6_ELK_GATE_LV = 0x801EB,\n    Z2SE_OBJ_L6_ELK_GATE_TOUCH = 0x801EC,\n    Z2SE_OBJ_L6_MARIO_GATE_ON = 0x801ED,\n    Z2SE_OBJ_L6_MARIO_GATE_OFF = 0x801EE,\n    Z2SE_OBJ_L6_MARIO_GATE_MV = 0x801EF,\n    Z2SE_OBJ_L6_UD_BLOCK_UP = 0x801F0,\n    Z2SE_OBJ_L6_UD_BLOCK_UP_ST = 0x801F1,\n    Z2SE_OBJ_L6_UD_BLOCK_DW = 0x801F2,\n    Z2SE_OBJ_L6_UD_BLOCK_DW_ST = 0x801F3,\n    Z2SE_OBJ_L6_BALANCE_MV = 0x801F4,\n    Z2SE_OBJ_L6_BALANCE_ST = 0x801F5,\n    Z2SE_OBJ_L6_BLADE = 0x801F6,\n    Z2SE_OBJ_L6_WARP_DW_ST = 0x801F7,\n    Z2SE_OBJ_L6_WARP_UP_ST = 0x801F8,\n    Z2SE_OBJ_L6_WARP_LV = 0x801F9,\n    Z2SE_OBJ_L6_SW_GATE_ON = 0x801FA,\n    Z2SE_OBJ_L6_SW_GATE_OFF = 0x801FB,\n    Z2SE_OBJ_L6_SW_GATE_MV = 0x801FC,\n    Z2SE_OBJ_T_BOX_EMERGE = 0x801FD,\n    Z2SE_OBJ_BREAK_WOOD_FURNITURE = 0x801FE,\n    Z2SE_OBJ_KNOB_DOOR_LV5_OP = 0x801FF,\n    Z2SE_OBJ_KNOB_DOOR_LV5_CL = 0x80200,\n    Z2SE_OBJ_FLN_GATE_ATK = 0x80201,\n    Z2SE_OBJ_FLN_GATE_L_OP = 0x80202,\n    Z2SE_OBJ_FLN_GATE_CRK = 0x80203,\n    Z2SE_OBJ_NABE_BUBBLE = 0x80204,\n    Z2SE_OBJ_L8_L_BALL = 0x80205,\n    Z2SE_OBJ_L8_L_BALL_REVIVE = 0x80206,\n    Z2SE_OBJ_L8_L_BALL_BOUND = 0x80207,\n    Z2SE_OBJ_L8_STAIR_ON = 0x80208,\n    Z2SE_OBJ_L8_STAIR = 0x80209,\n    Z2SE_OBJ_L8_STAIR_OFF = 0x8020A,\n    Z2SE_OBJ_L8_STAIR_MV_UP = 0x8020B,\n    Z2SE_OBJ_L8_STAIR_MV_DW = 0x8020C,\n    Z2SE_OBJ_L8_STAIR_ST_UP = 0x8020D,\n    Z2SE_OBJ_L8_STAIR_ST_DW = 0x8020E,\n    Z2SE_OBJ_L8_L_BALL_SW_ON = 0x8020F,\n    Z2SE_OBJ_L8_L_BALL_SW = 0x80210,\n    Z2SE_OBJ_L8_L_BALL_SW_OFF = 0x80211,\n    Z2SE_OBJ_L8_L_TORCH_SW = 0x80212,\n    Z2SE_OBJ_L8_L_LIFT_ON = 0x80213,\n    Z2SE_OBJ_L8_L_LIFT_MV = 0x80214,\n    Z2SE_OBJ_L8_B_FOG_FLY = 0x80215,\n    Z2SE_OBJ_L8_B_FOG_STAY = 0x80216,\n    Z2SE_OBJ_L8_B_FALL_S = 0x80217,\n    Z2SE_OBJ_L8_B_FALL_L = 0x80218,\n    Z2SE_OBJ_L8_SHTR_OP = 0x80219,\n    Z2SE_OBJ_L8_SHTR_CL = 0x8021A,\n    Z2SE_OBJ_L8_SHTR_CREST_ON = 0x8021B,\n    Z2SE_OBJ_L8_SHTR_CREST_OFF = 0x8021C,\n    Z2SE_OBJ_L8_MBOSS_SHTR_OP = 0x8021D,\n    Z2SE_OBJ_L8_MBOSS_SHTR_CL = 0x8021E,\n    Z2SE_OBJ_TRAP_BREAK = 0x8021F,\n    Z2SE_OBJ_SPNR_SW_PUSH = 0x80220,\n    Z2SE_OBJ_L_SWD_DEMO = 0x80221,\n    Z2SE_GRZ_DOOR_CL = 0x80222,\n    Z2SE_OBJ_ZORA_STN_VANISH = 0x80223,\n    Z2SE_OBJ_CMN_ROCK_LIFT = 0x80224,\n    Z2SE_OBJ_CMN_ROCK_BREAK = 0x80225,\n    Z2SE_OBJ_CMN_ROCK_ROLL = 0x80226,\n    Z2SE_OBJ_CMN_ROCK_BOUND = 0x80227,\n    Z2SE_OBJ_CMN_ROCK_PUT = 0x80228,\n    Z2SE_OBJ_RIDER_GATE_ATK = 0x80229,\n    Z2SE_OBJ_RIDER_GATE_L_OP = 0x8022A,\n    Z2SE_OBJ_RIDER_GATE_CRK = 0x8022B,\n    Z2SE_OBJ_CMN_L_ROCK_LIFT = 0x8022C,\n    Z2SE_OBJ_CMN_L_ROCK_BREAK = 0x8022D,\n    Z2SE_OBJ_CMN_L_ROCK_ROLL = 0x8022E,\n    Z2SE_OBJ_CMN_L_ROCK_BOUND = 0x8022F,\n    Z2SE_OBJ_CMN_L_ROCK_PUT = 0x80230,\n    Z2SE_OBJ_ZORA_BOSEKI_MV = 0x80231,\n    Z2SE_OBJ_BK_DOOR_ATK_CL = 0x80232,\n    Z2SE_OBJ_BK_DOOR_ATK_OP = 0x80233,\n    Z2SE_OBJ_IGATE_ATK_CL = 0x80234,\n    Z2SE_OBJ_IGATE_ATK_OP = 0x80235,\n    Z2SE_OBJ_H_SAKU_ORERU = 0x80236,\n    Z2SE_OBJ_H_SAKU_BREAK = 0x80237,\n    Z2SE_OBJ_IMPAL_DOOR_OP = 0x80238,\n    Z2SE_OBJ_TCANNON_ACTION_LAKE = 0x80239,\n    Z2SE_OBJ_TCANNON_ACTION_L7 = 0x8023A,\n    Z2SE_OBJ_THOUSE_CLOSE = 0x8023B,\n    Z2SE_OBJ_THOUSE_CHANGE = 0x8023C,\n    Z2SE_OBJ_THOUSE_HLIGHT = 0x8023D,\n    Z2SE_OBJ_AMATA_ACTION = 0x8023E,\n    Z2SE_OBJ_AMATA_CRK = 0x8023F,\n    Z2SE_OBJ_KKRK_BRG_LIFT_UP = 0x80240,\n    Z2SE_OBJ_KKRK_BRG_WARP_IN = 0x80241,\n    Z2SE_OBJ_KKRK_BRG_WARP_OUT = 0x80242,\n    Z2SE_OBJ_KKRK_BRG_LIFT_DW = 0x80243,\n    Z2SE_OBJ_ORDN_BRG_LIFT_UP = 0x80244,\n    Z2SE_OBJ_ORDN_BRG_WARP_IN = 0x80245,\n    Z2SE_OBJ_ORDN_BRG_WARP_OUT = 0x80246,\n    Z2SE_OBJ_ORDN_BRG_LIFT_DW = 0x80247,\n    Z2SE_OBJ_TCANNON_LIFT_UP = 0x80248,\n    Z2SE_OBJ_TCANNON_WARP_IN = 0x80249,\n    Z2SE_OBJ_TCANNON_WARP_OUT = 0x8024A,\n    Z2SE_OBJ_VOLC_FALL = 0x8024B,\n    Z2SE_OBJ_VOLC_LIFT_UP = 0x8024C,\n    Z2SE_OBJ_VOLC_WARP_IN = 0x8024D,\n    Z2SE_OBJ_WOOD_STATUE_BOUND = 0x8024E,\n    Z2SE_OBJ_RG_ROCK_BREAK = 0x8024F,\n    Z2SE_OBJ_RG_ROCK_FALL = 0x80250,\n    Z2SE_OBJ_RG_ROCKPOLE_FALL = 0x80251,\n    Z2SE_OBJ_RG_ROCKPOLE_LAND = 0x80252,\n    Z2SE_OBJ_BLN_BREAK_S = 0x80253,\n    Z2SE_OBJ_BLN_BREAK_M = 0x80254,\n    Z2SE_OBJ_BLN_BREAK_L = 0x80255,\n    Z2SE_OBJ_TRAP_BREAK_STN = 0x80256,\n    Z2SE_OBJ_VOLC_WAIT = 0x80257,\n    Z2SE_OBJ_BURASWLV7_ON = 0x80258,\n    Z2SE_OBJ_BURASWLV7_OFF = 0x80259,\n    Z2SE_OBJ_FLR_FALL_START = 0x8025A,\n    Z2SE_OBJ_FLR_GURAGURA = 0x8025B,\n    Z2SE_OBJ_FLR_FALLING = 0x8025C,\n    Z2SE_OBJ_POLE_FALL_START = 0x8025D,\n    Z2SE_OBJ_POLE_FALLING = 0x8025E,\n    Z2SE_OBJ_BRDG_MOVE = 0x8025F,\n    Z2SE_OBJ_BRDG_STOP = 0x80260,\n    Z2SE_OBJ_FAN_ROLL_S = 0x80261,\n    Z2SE_OBJ_FAN_ROLL_M = 0x80262,\n    Z2SE_OBJ_FAN_ROLL_L = 0x80263,\n    Z2SE_OBJ_FAN_WIND_S = 0x80264,\n    Z2SE_OBJ_FAN_WIND_M = 0x80265,\n    Z2SE_OBJ_FAN_WIND_L = 0x80266,\n    Z2SE_OBJ_ONSEN_TARU_BRK = 0x80267,\n    Z2SE_OBJ_CRYSTAL_KRKR = 0x80268,\n    Z2SE_OBJ_THE_DOOR_CL = 0x80269,\n    Z2SE_OBJ_THE_DOOR_MV = 0x8026A,\n    Z2SE_OBJ_GZ_NE_DOOR_OP = 0x8026B,\n    Z2SE_OBJ_ONSEN_WARM_FIRE = 0x8026C,\n    Z2SE_OBJ_STAR_GAME_HIT_1 = 0x8026D,\n    Z2SE_OBJ_STAR_GAME_HIT_2 = 0x8026E,\n    Z2SE_OBJ_STAR_GAME_HIT_3 = 0x8026F,\n    Z2SE_OBJ_STAR_GAME_HIT_4 = 0x80270,\n    Z2SE_OBJ_STAR_GAME_HIT_5 = 0x80271,\n    Z2SE_OBJ_MR_SCRW_ON = 0x80272,\n    Z2SE_OBJ_MR_SCRW_MV = 0x80273,\n    Z2SE_OBJ_MR_SCRW_OFF = 0x80274,\n    Z2SE_OBJ_MR_CHIN = 0x80275,\n    Z2SE_OBJ_MR_TBLE = 0x80276,\n    Z2SE_OBJ_DARK_GATE_RIPPLE = 0x80277,\n    Z2SE_OBJ_DS_FIRE_CLMN = 0x80278,\n    Z2SE_OBJ_DS_CLMN_UP = 0x80279,\n    Z2SE_OBJ_DS_CLMN_UP_ST = 0x8027A,\n    Z2SE_OBJ_DS_H_FIRE = 0x8027B,\n    Z2SE_OBJ_DS_END_ZAN_SWD = 0x8027C,\n    Z2SE_OBJ_PO_TBOX = 0x8027D,\n    Z2SE_OBJ_AMI_ROLL = 0x8027E,\n    Z2SE_OBJ_MDN_ESCAPE_HOLE = 0x8027F,\n    Z2SE_OBJ_DS_END_BRG = 0x80280,\n    Z2SE_OBJ_VSHUTR = 0x80281,\n    Z2SE_OBJ_TOY_BONE_PUT = 0x80282,\n    Z2SE_OBJ_TOY_BONE_BOUND = 0x80283,\n    Z2SE_OBJ_KAGERI_MIRROR_GET = 0x80284,\n    Z2SE_OBJ_DS_END_BRG_ST = 0x80285,\n    Z2SE_OBJ_BOMB_ROCK_BRK_WTR_1 = 0x80286,\n    Z2SE_OBJ_BOMB_ROCK_BRK_WTR_2 = 0x80287,\n    Z2SE_OBJ_G_KABE_BRK = 0x80288,\n    Z2SE_OBJ_BH_HASHI_LV = 0x80289,\n    Z2SE_OBJ_BH_HASHI_TRG = 0x8028A,\n    Z2SE_OBJ_SEKI_TFORCE_ON = 0x8028D,\n    Z2SE_OBJ_SEKI_TILE_EMERGE = 0x8028E,\n    Z2SE_OBJ_SEKI_TILE_ON = 0x8028F,\n    Z2SE_OBJ_SEKI_TILE_ON_LAST = 0x80290,\n    Z2SE_OBJ_SEKI_DOOR_OP = 0x80291,\n    Z2SE_OBJ_KAKO_DOOR_OP_IN = 0x80292,\n    Z2SE_OBJ_KAKO_DOOR_OP_LIGHT = 0x80293,\n    Z2SE_OBJ_KAKO_DOOR_OP_OUT = 0x80294,\n    Z2SE_OBJ_LV6_GATE_STAIR = 0x80295,\n    Z2SE_OBJ_LV6_GATE_GLASS_ON = 0x80296,\n    Z2SE_OBJ_LV6_GATE_GLASS_OFF = 0x80297,\n    Z2SE_OBJ_MG_CANOE_TSUBO_BRK = 0x80298,\n    Z2SE_OBJ_WTR_STREAM = 0x80299,\n    Z2SE_OBJ_WTR_STREAM_S = 0x8029A,\n    Z2SE_OBJ_ZR_GRN_ROCK_GRGR = 0x8029B,\n    Z2SE_OBJ_ZR_GRN_ROCK_BRK = 0x8029C,\n    Z2SE_OBJ_CTL_ROCK_FALL = 0x8029D,\n    Z2SE_OBJ_PM_WALL_FADEAWAY = 0x8029E,\n    Z2SE_OBJ_KAKO_DOOR_LIGHT_RT = 0x8029F,\n    Z2SE_OBJ_MGN_BREAK_PILLAR = 0x802A0,\n    Z2SE_OBJ_LEAF_BEGIN_FALL = 0x802A1,\n    Z2SE_OBJ_LEAF_FALL_DOWN = 0x802A2,\n    Z2SE_OBJ_SNOW_SLIDE = 0x802A3,\n    Z2SE_OBJ_SEKI_DOOR_OP_ST = 0x802A6,\n    Z2SE_OBJ_SAMPLE_TSUBO_BRK = 0x802A7,\n    Z2SE_OBJ_SINK_FLOOR_DW_TRG = 0x802A8,\n    Z2SE_OBJ_GANON_BARRIER_APPR = 0x802A9,\n    Z2SE_OBJ_GANON_BARRIER = 0x802AA,\n    Z2SE_OBJ_ICICLE_FALL = 0x802AB,\n    Z2SE_OBJ_ICICLE_LAND = 0x802AC,\n    Z2SE_OBJ_ICICLE_BRK = 0x802AD,\n    Z2SE_OBJ_HASU_WTR = 0x802AE,\n    Z2SE_OBJ_NIOIMASU_BOUND = 0x802AF,\n    Z2SE_OBJ_YO_HEART_S = 0x802B0,\n    Z2SE_OBJ_YO_HEART_L = 0x802B1,\n    Z2SE_OBJ_GATE_LV9_OP = 0x802B2,\n    Z2SE_OBJ_GATE_LV9_STOP = 0x802B3,\n    Z2SE_OBJ_ROPE_PAINT_CUT = 0x802B4,\n    Z2SE_OBJ_ROPE_PAINT_LAND = 0x802B5,\n    Z2SE_OBJ_LV9_SHTR_OP = 0x802B6,\n    Z2SE_OBJ_LV9_SHTR_CL = 0x802B7,\n    Z2SE_OBJ_YAGURA_BREAK = 0x802B8,\n    Z2SE_OBJ_YAGURA_LAND = 0x802B9,\n    Z2SE_OBJ_SAKU_BREAK = 0x802BA,\n    Z2SE_OBJ_LV9_HOLE_LIGHTON = 0x802BB,\n    Z2SE_OBJ_CHANDLV9_SWING = 0x802BC,\n    Z2SE_OBJ_CHANDLV9_DOWN = 0x802BD,\n    Z2SE_OBJ_POU_SOUL_BREAK = 0x802BE,\n    Z2SE_OBJ_D13_FIRE_BURNING = 0x802BF,\n    Z2SE_OBJ_L6_WARP_COL = 0x802C0,\n    Z2SE_OBJ_CRVN_GATE_ATTACK = 0x802C1,\n    Z2SE_OBJ_CRVN_GATE_OPEN = 0x802C2,\n    Z2SE_OBJ_CRVN_GATE_CREAK = 0x802C3,\n    Z2SE_OBJ_CRVN_GATE_CLOSE = 0x802C4,\n    Z2SE_OBJ_CRVN_GATE_BREAK = 0x802C5,\n    Z2SE_OBJ_CRVN_URA_GATE = 0x802C6,\n    Z2SE_OBJ_CRVN_BURNING = 0x802C7,\n    Z2SE_OBJ_BURASWLV7_GRAB = 0x802C8,\n    Z2SE_OBJ_MONOLIS_HOLE = 0x802C9,\n    Z2SE_OBJ_MIRROR_STAIR_ON = 0x802CA,\n    Z2SE_OBJ_MIRROR_STAIR_OFF = 0x802CB,\n    Z2SE_OBJ_MIRROR_LIGHT = 0x802CC,\n    Z2SE_D30_MIRROR_HIBI = 0x802CD,\n    Z2SE_D30_MIRROR_HIKARI = 0x802CE,\n    Z2SE_D32_SWD_FLOAT = 0x802D0,\n    Z2SE_D32_SWD_FLY = 0x802D1,\n    Z2SE_D32_GND_CHAIN1 = 0x802D2,\n    Z2SE_D32_GND_CHAIN2 = 0x802D3,\n    Z2SE_D32_GND_SWD_OUT = 0x802D5,\n    Z2SE_D32_MIRROR_LIGHT_ON = 0x802D6,\n    Z2SE_D32_MONOLIS_ON = 0x802D7,\n    Z2SE_D32_MONOLIS_OFF = 0x802D8,\n    Z2SE_D34_VOLC_WARP_OUT = 0x802D9,\n    Z2SE_D34_VOLC_FALL = 0x802DA,\n    Z2SE_D34_VOLC_IMPACT = 0x802DB,\n    Z2SE_D34_JINARI = 0x802DC,\n    Z2SE_D34_WTR_FALL = 0x802DD,\n    Z2SE_D34_ICE_FALL = 0x802DE,\n    Z2SE_D25_MDN_STN_FLY = 0x802DF,\n    Z2SE_D26_CTL_BARRIER = 0x802E0,\n    Z2SE_D26_MDN_STN_OUT = 0x802E1,\n    Z2SE_D26_MDN_STN_UNITE = 0x802E2,\n    Z2SE_D26_MDN_STN_GGG = 0x802E3,\n    Z2SE_D26_SPEAR_EMERGE = 0x802E4,\n    Z2SE_D26_SPEAR_HOLE = 0x802E5,\n    Z2SE_D27_BLOCK_ON = 0x802E6,\n    Z2SE_D27_HZEL_TAKE_SWD = 0x802E7,\n    Z2SE_D27_BLOCK_OFF = 0x802E8,\n    Z2SE_D27_MDN_STN_OUT = 0x802E9,\n    Z2SE_D28_MDN_STN_OUT = 0x802EA,\n    Z2SE_D28_MDN_STN_UNITE = 0x802EC,\n    Z2SE_D28_MJN_TAKE_SPEAR = 0x802ED,\n    Z2SE_D28_JINARI = 0x802EE,\n    Z2SE_D28_HYL_CTL_BRK = 0x802EF,\n    Z2SE_D28_MDN_STN_BRK = 0x802F0,\n    Z2SE_D28_GEM_GATHER = 0x802F1,\n    Z2SE_OBJ_CMN_ROCK_ASASE = 0x802F2,\n    Z2SE_OBJ_CMN_ROCK_WTR = 0x802F3,\n    Z2SE_OBJ_CMN_ROCK_PUT_WTR = 0x802F4,\n    Z2SE_OBJ_MIRROR_LIGHT_S = 0x802F5,\n    Z2SE_D21_CTL_BARRIER = 0x802F6,\n    Z2SE_D22_SWD_LIGHT_1 = 0x802F7,\n    Z2SE_D22_SWD_LIGHT_2 = 0x802F8,\n    Z2SE_D22_STN_GATHER = 0x802F9,\n    Z2SE_D22_SWD_PULL_OUT_LIGHT = 0x802FA,\n    Z2SE_D22_FOG_OUT = 0x802FB,\n    Z2SE_D22_SWD_EDGE_LIGHT = 0x802FC,\n    Z2SE_D24_MIRROR_GATHER = 0x802FD,\n    Z2SE_D24_CHAIN_LIGHT = 0x802FE,\n    Z2SE_D24_MONOLIS_FALL = 0x802FF,\n    Z2SE_D24_MONOLIS_LIGHT = 0x80301,\n    Z2SE_D24_STN_OUT = 0x80302,\n    Z2SE_LIGHT_BOWL_AWAY = 0x80303,\n    Z2SE_D18_S1_FLY_1 = 0x80304,\n    Z2SE_D18_S2_FLY_1 = 0x80305,\n    Z2SE_D18_S3_FLY_1 = 0x80306,\n    Z2SE_D18_S1_FLY_2 = 0x80307,\n    Z2SE_D18_S2_FLY_2 = 0x80308,\n    Z2SE_D18_S3_FLY_2 = 0x80309,\n    Z2SE_D18_S1_FLY_3 = 0x8030A,\n    Z2SE_D18_S2_FLY_3 = 0x8030B,\n    Z2SE_D18_S3_FLY_3 = 0x8030C,\n    Z2SE_D18_S_COL = 0x8030D,\n    Z2SE_D18_KNIFE = 0x8030E,\n    Z2SE_D18_TF_BRIGHT = 0x80310,\n    Z2SE_D18_STN_APPEAR = 0x80311,\n    Z2SE_D18_STN_FALL = 0x80312,\n    Z2SE_D18_STN_DISAPPEAR = 0x80313,\n    Z2SE_D20_STN_TAKEN = 0x80314,\n    Z2SE_D20_GENKI_DAMA = 0x80316,\n    Z2SE_D20_I_STN_INTO = 0x80317,\n    Z2SE_D08_DOOR_OP = 0x80318,\n    Z2SE_D07_SMOKE_IN = 0x80319,\n    Z2SE_D07_Z_SWD_FALL = 0x8031A,\n    Z2SE_D07_CTL_SMOKE = 0x8031B,\n    Z2SE_D15_BANS_DOOR_OP = 0x8031C,\n    Z2SE_OBJ_HYRULE_BARRIER = 0x8031D,\n    Z2SE_D06_CHAIN_BRK = 0x8031E,\n    Z2SE_OBJ_HYRULE_DR_MOVE = 0x8031F,\n    Z2SE_OBJ_HYRULE_DR_STOP = 0x80320,\n    Z2SE_ENV_LAKEWATER = 0x90000,\n    Z2SE_ENV_FALL_LV1BOSS = 0x90001,\n    Z2SE_ENV_LAKE_OFFSHORE = 0x90002,\n    JA_SE_MAGMA_L = 0x90003,\n    JA_SE_MAGMA_R = 0x90004,\n    JA_SE_MAGMA_SR = 0x90005,\n    JA_SE_FIREBLAST_NOISE = 0x90006,\n    JA_SE_OBJ_WIND_TAG = 0x90007,\n    Z2SE_D27_STRONG_WIND = 0x90008,\n    Z2SE_ENV_FIELD_WIND_L = 0x90009,\n    Z2SE_ENV_VALLEY_WIND = 0x9000A,\n    JA_SE_ATM_WIND_1 = 0x9000B,\n    JA_SE_ATM_RAIN_START = 0x9000C,\n    JA_SE_ATM_RAIN_END = 0x9000D,\n    Z2SE_ENV_VOLCANO_SHAKE = 0x9000E,\n    Z2SE_ENV_FIELD_WIND_R = 0x9000F,\n    JA_SE_ATM_WIND_HOT = 0x90010,\n    Z2SE_ENV_QUICKSAND_LOOP = 0x90012,\n    Z2SE_ENV_SPIRIT_FALL = 0x90013,\n    Z2SE_ENV_ICED_VILLAGE_L = 0x90014,\n    Z2SE_ENV_ICED_VILLAGE_R = 0x90015,\n    Z2SE_ENV_WATERFALL_NORMAL = 0x90016,\n    Z2SE_ENV_WATERFALL_CALM = 0x90017,\n    Z2SE_ENV_RIVER_NORMAL = 0x90018,\n    Z2SE_ENV_RIVER_SMALL = 0x90019,\n    Z2SE_ENV_WINDTAG_STRONG = 0x9001A,\n    Z2SE_ENV_WINDTAG_SLOW = 0x9001B,\n    Z2SE_ENV_WINDTAG_CEASE = 0x9001C,\n    Z2SE_ENV_SEWER = 0x9001D,\n    Z2SE_ENV_SCENT_GRAVE = 0x9001E,\n    Z2SE_ENV_FOREST_DAY = 0x9001F,\n    Z2SE_ENV_FORESTWIND = 0x90020,\n    Z2SE_OBJ_L_BLOCK_LIGHT = 0x90021,\n    Z2SE_ENV_PUPPET_FOG_L = 0x90022,\n    Z2SE_ENV_PUPPET_FOG_R = 0x90023,\n    Z2SE_ENV_RAIN_NORMAL_L = 0x90024,\n    Z2SE_ENV_RAIN_NORMAL_R = 0x90025,\n    Z2SE_ENV_RAIN_ROOM = 0x90026,\n    Z2SE_ENV_SEWER_FILL = 0x90027,\n    Z2SE_ENV_SEWER_OUT = 0x90028,\n    Z2SE_ENV_THUNDER_FAR = 0x90029,\n    Z2SE_ENV_THUNDER_NEAR = 0x9002A,\n    Z2SE_ENV_THUND_FAR_WIN = 0x9002B,\n    Z2SE_ENV_THUND_NEAR_WIN = 0x9002C,\n    Z2SE_ENV_WIND_SARUDAN = 0x9002D,\n    Z2SE_ENV_SPIRIT_FOUNTAIN = 0x9002E,\n    Z2SE_ENV_RAIN_HARD_L = 0x9002F,\n    Z2SE_ENV_RAIN_HARD_R = 0x90030,\n    Z2SE_ENV_RAIN_HARD_ROOM = 0x90031,\n    Z2SE_ENV_SNOW_MT_WIND_L = 0x90032,\n    Z2SE_ENV_SNOW_MT_WIND_R = 0x90033,\n    Z2SE_ENV_SNOW_MT_WIND_ROOM = 0x90034,\n    Z2SE_ENV_FOG_WIPE = 0x90035,\n    Z2SE_ENV_WATER_WAY = 0x90036,\n    Z2SE_ENV_WATER_SURFACE = 0x90037,\n    Z2SE_ENV_DS_SAND = 0x90038,\n    Z2SE_ENV_SAND_FALL = 0x90039,\n    Z2SE_ENV_FILL_UP_LV3WTR1 = 0x9003A,\n    Z2SE_ENV_FILL_UP_LV3WTR2 = 0x9003B,\n    Z2SE_ENV_FILL_UP_LV3WTR3 = 0x9003C,\n    Z2SE_ENV_WATER_WAY_L = 0x9003D,\n    Z2SE_ENV_PEOPLE_CROWD = 0x9003E,\n    Z2SE_ENV_OUGI_FIELD_L = 0x9003F,\n    Z2SE_ENV_OUGI_FIELD_R = 0x90040,\n    Z2SE_D32_FIRE = 0x90041,\n    Z2SE_D32_WIND = 0x90042,\n    Z2SE_D28_SEIREI_SPACE = 0x90043,\n    Z2SE_D09_ENV_LIGHT_ON = 0x90044,\n    Z2SE_D11_ENV_LIGHT_ON = 0x90045,\n    Z2SE_D14_ENV_LIGHT_ON = 0x90046,\n    Z2SE_D18_ENV_LIGHT_ON = 0x90047,\n    Z2SE_D20_ENV_LIGHT_ON = 0x9004C,\n    Z2SE_D20_ENV_SHINE = 0x9004D,\n    Z2SE_D15_JINARI = 0x9004E\n};\n\n#endif /* Z2SEMGR_H */\n/* end \"Z2AudioLib/Z2SeMgr.h\" */\n/* \"include/Z2AudioLib/Z2AudioMgr.h\" line 8 \"Z2AudioLib/Z2SeqMgr.h\" */\n#ifndef Z2SEQMGR_H\n#define Z2SEQMGR_H\n\n/* \"include/Z2AudioLib/Z2SeqMgr.h\" line 3 \"JSystem/JAudio2/JAISoundHandles.h\" */\n/* end \"JSystem/JAudio2/JAISoundHandles.h\" */\n/* \"include/Z2AudioLib/Z2SeqMgr.h\" line 4 \"JSystem/JAudio2/JASGadget.h\" */\n/* end \"JSystem/JAudio2/JASGadget.h\" */\n\n// move TTransition / Z2SoundFader ?\nstruct TTransition {\n    /* 0x0 */ float field_0x0;\n    /* 0x4 */ float field_0x4;\n    /* 0x8 */ u32 mCount;\n};  // Size = 0xC\n\nstruct Z2SoundFader {\n    void move(f32 vol, u32 count) {\n        mIntensity = vol;\n        mTransition.zero();\n    }\n\n    /* 0x0 */ float mIntensity;\n    /* 0x4 */ JAISoundParamsTransition::TTransition mTransition;\n};  // Size = 0x10\n\nclass Z2SeqMgr : public JASGlobalInstance<Z2SeqMgr> {\npublic:\n    Z2SeqMgr();\n\n    void bgmStart(u32 i_bgmID, u32, s32);\n    void bgmStop(u32 i_bgmID, s32);\n    void subBgmStart(u32);\n    void subBgmStop();\n    void subBgmStopInner();\n    void bgmStreamPrepare(u32);\n    int bgmStreamCheckReady();\n    void bgmStreamPlay();\n    void bgmStreamStop(u32);\n    void changeBgmStatus(s32);\n    void changeSubBgmStatus(s32);\n    void onVariantBgmJumpEnd(bool);\n    void changeFishingBgm(s32);\n    void talkInBgm();\n    void talkOutBgm();\n    void menuInBgm();\n    void menuOutBgm();\n    void fanfareFramework();\n    void stopWolfHowlSong();\n    void setHeightVolMod(bool, u32);\n    void setTimeProcVolMod(bool, u32);\n    void processBgmFramework();\n    bool checkBgmIDPlaying(u32);\n    void getChildTrackVolume(JAISoundHandle*, int);\n    void setChildTrackVolume(JAISoundHandle*, int, float, u32, float, float);\n    void resetBattleBgmParams();\n    void setBattleBgmOff(bool);\n    void setBattleSearched(bool);\n    void setBattleDistIgnore(bool);\n    void setBattleGhostMute(bool);\n    void setBattleDistState(u8);\n    void setBattleSeqState(u8);\n    void setBattleLastHit(u8);\n    void battleBgmFramework();\n    void startBattleBgm(bool);\n    void stopBattleBgm(u8, u8);\n    void fieldBgmStart();\n    void fieldRidingMute();\n    void onFieldBgmJumpStart();\n    void onFieldBgmJumpEnd();\n    void fieldBgmFramework();\n    void mbossBgmMuteProcess();\n    void bgmSetSwordUsing(s32);\n    void bgmNowBattle(float);\n    void taktModeMute();\n    void taktModeMuteOff();\n    void setFieldBgmPlay(bool);\n    /* 802B99AC */ void unMuteSceneBgm(u32);\n    /* 802B9A24 */ void muteSceneBgm(u32, f32);\n    /* 802B9AD0 */ void setTwilightGateVol(f32);\n    /* 802B9AFC */ void setWindStoneVol(f32, u32);\n\n    void onEnemyDamage() { setBattleSeqState(2); }\n\n    void i_setTwilightGateVol(f32 vol) { mTwilightGateVol = vol; }\n\n    void i_setWindStoneVol(f32 vol, u32 count) { mWindStone.move(vol, count); }\n\n    void i_bgmAllUnMute(u32 count) { mAllBgmMaster.move(1.0f, count); }\n\n    void i_unMuteSceneBgm(u32 count) {\n        mBgmPause.move(1.0f, 0);\n        field_0x44.move(1.0f, count);\n    }\n\n    void bgmAllMute(u32 count, f32 val) {\n        mAllBgmMaster.mTransition.set(val, mAllBgmMaster.mIntensity, count);\n    }\n\n    bool isItemGetDemo() {\n        return field_0x08.isSoundAttached() || field_0xba != 0;\n    }\n\n    u32 getMainBgmID() {\n        if (mMainBgmHandle) {\n            return mMainBgmHandle->getID();\n        }\n\n        return -1;\n    }\n\n    u32 getSubBgmID() {\n        if (mSubBgmHandle) {\n            return mSubBgmHandle->getID();\n        }\n\n        return -1;\n    }\n\nprivate:\n    /* 0x00 */ JAISoundHandle mMainBgmHandle;\n    /* 0x04 */ JAISoundHandle mSubBgmHandle;\n    /* 0x08 */ JAISoundHandle field_0x08;\n    /* 0x0C */ JAISoundHandle field_0x0c;\n    /* 0x10 */ JAISoundID field_0x10;\n    /* 0x14 */ Z2SoundFader mMainBgmMaster;\n    /* 0x24 */ Z2SoundFader mSubBgmMaster;\n    /* 0x34 */ Z2SoundFader mBgmPause;\n    /* 0x44 */ Z2SoundFader field_0x44;\n    /* 0x54 */ Z2SoundFader mFanfareMute;\n    /* 0x64 */ Z2SoundFader field_0x64;\n    /* 0x74 */ Z2SoundFader mAllBgmMaster;\n    /* 0x84 */ Z2SoundFader field_0x84;\n    /* 0x94 */ Z2SoundFader mWindStone;\n    /* 0xA4 */ Z2SoundFader field_0xa4;\n    /* 0xB4 */ f32 mTwilightGateVol;\n    /* 0xB8 */ u16 field_0xb8;\n    /* 0xBA */ u8 field_0xba;\n    /* 0xBB */ u8 field_0xbb;\n    /* 0xBC */ u8 field_0xbc;\n    /* 0xBD */ u8 field_0xbd;\n    /* 0xBE */ u8 field_0xbe;\n    /* 0xBF */ u8 field_0xbf;\n    /* 0xC0 */ u8 field_0xc0;\n    /* 0xC1 */ u8 field_0xc1;\n    /* 0xC2 */ u8 field_0xc2;\n    /* 0xC3 */ u8 field_0xc3;\n    /* 0xC4 */ u8 field_0xc4;\n    /* 0xC8 */ f32 field_0xc8;\n    /* 0xCC */ f32 field_0xcc;\n    /* 0xD0 */ u8 mFlags;\n};  // Size = 0xD4\n\ninline Z2SeqMgr* Z2GetSeqMgr() {\n    return JASGlobalInstance<Z2SeqMgr>::getInstance();\n}\n\nenum Z2BgmID {\n    Z2BGM_FIELD_LINK_DAY = 0x1000000,\n    Z2BGM_FIELD_LINK_NIGHT = 0x1000001,\n    Z2BGM_FIELD = 0x1000002,\n    Z2BGM_DUNGEON = 0x1000003,\n    Z2BGM_HORSE_BATTLE = 0x1000004,\n    Z2BGM_TOAL_VILLEGE = 0x1000005,\n    Z2BGM_COWBOY_GAME = 0x1000006,\n    Z2BGM_FACE_OFF_BATTLE = 0x1000007,\n    Z2BGM_BOOMERAMG_MONKEY = 0x1000008,\n    Z2BGM_DUNGEON_FOREST = 0x1000009,\n    Z2BGM_ITEM_GET = 0x100000A,\n    Z2BGM_ITEM_GET_MINI = 0x100000B,\n    Z2BGM_BOSSBABA_0 = 0x100000C,\n    Z2BGM_BOSSBABA_1 = 0x100000D,\n    Z2BGM_BOSSBABA_2 = 0x100000E,\n    Z2BGM_BATTLE_NORMAL = 0x100000F,\n    Z2BGM_RANCH = 0x1000010,\n    Z2BGM_WILD_GOAT = 0x1000011,\n    Z2BGM_OPEN_BOX = 0x1000012,\n    Z2BGM_GAME_OVER = 0x1000013,\n    Z2BGM_ITEM_GET_ME = 0x1000014,\n    Z2BGM_HORSE_BATTLE_D02 = 0x1000015,\n    Z2BGM_TWILIGHT = 0x1000016,\n    Z2BGM_EVENT01 = 0x1000017,\n    Z2BGM_DUNGEON_LV2 = 0x1000018,\n    Z2BGM_TOAL_NIGHT = 0x1000019,\n    Z2BGM_DEATH_MOUNTAIN01 = 0x100001A,\n    Z2BGM_BATTLE_TWILIGHT = 0x100001B,\n    Z2BGM_HEART_GET = 0x100001C,\n    Z2BGM_MAGNE_GORON = 0x100001D,\n    Z2BGM_SHOP01 = 0x100001E,\n    Z2BGM_SHOP02 = 0x100001F,\n    Z2BGM_DUNGEON_LV3 = 0x1000020,\n    Z2BGM_MAGNE_GORON_D01 = 0x1000021,\n    Z2BGM_MAGNE_GORON_D02 = 0x1000022,\n    Z2BGM_FILONE_FOREST = 0x1000023,\n    Z2BGM_SUMO = 0x1000024,\n    Z2BGM_BOSSFIREMAN_0 = 0x1000025,\n    Z2BGM_KAKARIKO = 0x1000026,\n    Z2BGM_DEKUTOAD = 0x1000027,\n    Z2BGM_DEKUTOAD_D01 = 0x1000028,\n    Z2BGM_RODEO = 0x1000029,\n    Z2BGM_BOSSFIREMAN_1 = 0x100002A,\n    Z2BGM_SUMO_D1 = 0x100002B,\n    Z2BGM_INDOOR = 0x100002C,\n    Z2BGM_DUNGEON_LV4 = 0x100002D,\n    Z2BGM_STATUE_GAME = 0x100002E,\n    Z2BGM_EVENT02 = 0x100002F,\n    Z2BGM_BOSS_OCTAEEL_0 = 0x1000030,\n    Z2BGM_BOSS_OCTAEEL_1 = 0x1000031,\n    Z2BGM_BOSS_OCTAEEL_D01 = 0x1000032,\n    Z2BGM_BOSS_OCTAEEL_D02 = 0x1000033,\n    Z2BGM_DESERT = 0x1000034,\n    Z2BGM_ZORA_VILLAGE = 0x1000035,\n    Z2BGM_BRIDGE_ON_FIRE = 0x1000036,\n    Z2BGM_DUNGEON_LV5 = 0x1000037,\n    Z2BGM_DEMO10 = 0x1000038,\n    Z2BGM_VARIANT = 0x1000039,\n    Z2BGM_CARGO_GAME_TW = 0x100003A,\n    Z2BGM_CASTLE_TOWN = 0x100003B,\n    Z2BGM_DUNGEON_LV6 = 0x100003C,\n    Z2BGM_DUNGEON_LV7 = 0x100003D,\n    Z2BGM_DUNGEON_LV8 = 0x100003E,\n    Z2BGM_DUNGEON_LV9_02 = 0x100003F,\n    Z2BGM_DEATH_MOUNTAIN02 = 0x1000040,\n    Z2BGM_HOLY_FOREST = 0x1000041,\n    Z2BGM_FISHING = 0x1000042,\n    Z2BGM_FISHING_BARE = 0x1000043,\n    Z2BGM_FISHING_GET1 = 0x1000044,\n    Z2BGM_FISHING_GET2 = 0x1000045,\n    Z2BGM_FISHING_GET3 = 0x1000046,\n    Z2BGM_LUTERA1 = 0x1000047,\n    Z2BGM_LUTERA2 = 0x1000048,\n    Z2BGM_FISHING_HIT = 0x1000049,\n    Z2BGM_SNOW_MOUNTAIN = 0x100004A,\n    Z2BGM_SNOW_BOARD = 0x100004B,\n    Z2BGM_BOSS_SNOWWOMAN_0 = 0x100004C,\n    Z2BGM_BOSS_SNOWWOMAN_1 = 0x100004D,\n    Z2BGM_DEMO08 = 0x100004E,\n    Z2BGM_DEMO13_SEQ = 0x100004F,\n    Z2BGM_CHURCH1 = 0x1000050,\n    Z2BGM_CHURCH2 = 0x1000051,\n    Z2BGM_HOWL_TOBIKUSA = 0x1000052,\n    Z2BGM_HOWL_UMAKUSA = 0x1000053,\n    Z2BGM_HOWL_ZELDASONG = 0x1000054,\n    Z2BGM_HOWL_LIGHT_PRLD = 0x1000055,\n    Z2BGM_HIDDEN_VIL_D1 = 0x1000056,\n    Z2BGM_HIDDEN_VILLAGE = 0x1000057,\n    Z2BGM_SHOP_CELEB = 0x1000058,\n    Z2BGM_SHOP_MARO = 0x1000059,\n    Z2BGM_LAKE = 0x100005A,\n    Z2BGM_STONE_ZELDASONG = 0x100005B,\n    Z2BGM_STONE_LIGHT_PRLD = 0x100005C,\n    Z2BGM_BOSS_SNOWWOMAN_D1 = 0x100005D,\n    Z2BGM_ROOM_2 = 0x100005E,\n    Z2BGM_MIDNA_SOS = 0x100005F,\n    Z2BGM_FORTUNE = 0x1000060,\n    Z2BGM_IB_MBOSS = 0x1000061,\n    Z2BGM_BOSS_ZANT = 0x1000062,\n    Z2BGM_IB_MBOSS_D01 = 0x1000063,\n    Z2BGM_SUMOMO = 0x1000064,\n    Z2BGM_RAKKA_HOUSE = 0x1000065,\n    Z2BGM_LIGHT_PRLD_DUO = 0x1000066,\n    Z2BGM_SOUL_REQ_STONE = 0x1000067,\n    Z2BGM_SOUL_REQ_HOWL = 0x1000068,\n    Z2BGM_SOUL_REQ_DUO = 0x1000069,\n    Z2BGM_LUTERA_DEMO = 0x100006A,\n    Z2BGM_TEMPLE_OF_TIME = 0x100006B,\n    Z2BGM_TN_MBOSS = 0x100006C,\n    Z2BGM_OBACHAN = 0x100006D,\n    Z2BGM_RIVER_GAME = 0x100006E,\n    Z2BGM_GG_MBOSS = 0x100006F,\n    Z2BGM_OUGI_TRAINING = 0x1000070,\n    Z2BGM_HEALING_STONE = 0x1000071,\n    Z2BGM_HEALING_HOWL = 0x1000072,\n    Z2BGM_HEALING_DUO = 0x1000073,\n    Z2BGM_NEW_01_STONE = 0x1000074,\n    Z2BGM_NEW_01_HOWL = 0x1000075,\n    Z2BGM_NEW_01_DUO = 0x1000076,\n    Z2BGM_SUB_DUNGEON = 0x1000077,\n    Z2BGM_WCS_GAME = 0x1000078,\n    Z2BGM_WCS_D01 = 0x1000079,\n    Z2BGM_MINIGAME_ROOM = 0x100007A,\n    Z2BGM_NEW_02_STONE = 0x100007B,\n    Z2BGM_NEW_02_HOWL = 0x100007C,\n    Z2BGM_NEW_02_DUO = 0x100007D,\n    Z2BGM_NEW_03_STONE = 0x100007E,\n    Z2BGM_NEW_03_HOWL = 0x100007F,\n    Z2BGM_NEW_03_DUO = 0x1000080,\n    Z2BGM_ITEM_GET_INSECT = 0x1000081,\n    Z2BGM_ITEM_GET_SMELL = 0x1000082,\n    Z2BGM_ITEM_GET_POU = 0x1000083,\n    Z2BGM_GG_MBOSS_D01 = 0x1000084,\n    Z2BGM_P_ZANT = 0x1000085,\n    Z2BGM_VS_GANON_01 = 0x1000086,\n    Z2BGM_VS_GANON_02 = 0x1000087,\n    Z2BGM_VS_GANON_04 = 0x1000088,\n    Z2BGM_HARAGIGANT_D01 = 0x1000089,\n    Z2BGM_HARAGIGANT_D02 = 0x100008A,\n    Z2BGM_HARAGIGANT_BTL01 = 0x100008B,\n    Z2BGM_HARAGIGANT_BTL02 = 0x100008C,\n    Z2BGM_DRAGON_D01 = 0x100008D,\n    Z2BGM_DRAGON_D02 = 0x100008E,\n    Z2BGM_DRAGON_BTL01 = 0x100008F,\n    Z2BGM_DRAGON_BTL02 = 0x1000090,\n    Z2BGM_KOROKORO_GAME = 0x1000091,\n    Z2BGM_YAMIMUSHI_B_D01 = 0x1000092,\n    Z2BGM_GOMA_D01 = 0x1000093,\n    Z2BGM_GOMA_BTL01 = 0x1000094,\n    Z2BGM_GOMA_BTL02 = 0x1000095,\n    Z2BGM_FACE_OFF_BATTLE2 = 0x1000096,\n    Z2BGM_FACE_OFF_BATTLE3 = 0x1000097,\n    Z2BGM_SNOWBOARD_WIN = 0x1000098,\n    Z2BGM_SNOWBOARD_LOSE = 0x1000099,\n    Z2BGM_INDOOR_03 = 0x100009A,\n    Z2BGM_INDOOR_04 = 0x100009B,\n    Z2BGM_MINIGAME_WIN01 = 0x100009C,\n    Z2BGM_MINIGAME_WIN02 = 0x100009D,\n    Z2BGM_POSTMAN = 0x100009E,\n    Z2BGM_EVENT05 = 0x100009F,\n    Z2BGM_ITEM_GET_ME_S = 0x10000A0,\n    Z2BGM_D30_01_NEXT_REQ = 0x10000A1,\n    Z2BGM_D30_02_NEXT_REQ = 0x10000A2,\n    Z2BGM_TARO_RESCUE = 0x10000A3,\n    Z2BGM_KOMONJO_GET_INTRO = 0x10000A4,\n    Z2BGM_RIVER_GAME_00 = 0x10000A5,\n    Z2BGM_ZORA_D01 = 0x10000A6,\n    Z2BGM_SUMO_D02 = 0x10000A7,\n    Z2BGM_TN_MBOSS_LV9 = 0x10000A8,\n    Z2BGM_MENU_SELECT = 0x10000A9,\n    Z2BGM_TEMP = 0x10000AA,\n    Z2BGM_TEMP_O = 0x10000AB\n};\n\n#endif /* Z2SEQMGR_H */\n/* end \"Z2AudioLib/Z2SeqMgr.h\" */\n/* \"include/Z2AudioLib/Z2AudioMgr.h\" line 9 \"Z2AudioLib/Z2SoundInfo.h\" */\n#ifndef Z2SOUNDINFO_H\n#define Z2SOUNDINFO_H\n\n/* \"include/Z2AudioLib/Z2SoundInfo.h\" line 3 \"JSystem/JAudio2/JAISoundInfo.h\" */\n#ifndef JAISOUNDINFO_H\n#define JAISOUNDINFO_H\n\n/* \"include/JSystem/JAudio2/JAISoundInfo.h\" line 3 \"JSystem/JAudio2/JAISound.h\" */\n/* end \"JSystem/JAudio2/JAISound.h\" */\n/* \"include/JSystem/JAudio2/JAISoundInfo.h\" line 4 \"JSystem/JAudio2/JASGadget.h\" */\n/* end \"JSystem/JAudio2/JASGadget.h\" */\n\nstruct JAISoundInfo : public JASGlobalInstance<JAISoundInfo> {\n    /* 802A2D34 */ JAISoundInfo(bool);\n    virtual u32 getSoundType(JAISoundID) const = 0;\n    virtual int getCategory(JAISoundID) const = 0;\n    virtual u32 getPriority(JAISoundID) const = 0;\n    virtual void getSeInfo(JAISoundID, JAISe*) const = 0;\n    virtual void getSeqInfo(JAISoundID, JAISeq*) const = 0;\n    virtual void getStreamInfo(JAISoundID, JAIStream*) const = 0;\n    /* 802A2D50 */ virtual ~JAISoundInfo();\n};\n\n#endif /* JAISOUNDINFO_H */\n/* end \"JSystem/JAudio2/JAISoundInfo.h\" */\n/* \"include/Z2AudioLib/Z2SoundInfo.h\" line 4 \"JSystem/JAudio2/JAIStreamDataMgr.h\" */\n#ifndef JAISTREAMDATAMGR_H\n#define JAISTREAMDATAMGR_H\n\n/* \"include/JSystem/JAudio2/JAIStreamDataMgr.h\" line 3 \"JSystem/JAudio2/JAISound.h\" */\n/* end \"JSystem/JAudio2/JAISound.h\" */\n\nstruct JAIStreamDataMgr {\n    virtual s32 getStreamFileEntry(JAISoundID) = 0;\n    virtual ~JAIStreamDataMgr();\n};\n\nstruct JAIStreamAramMgr {\n    virtual void* newStreamAram(u32*) = 0;\n    virtual void deleteStreamAram(u32) = 0;\n    virtual ~JAIStreamAramMgr();\n};\n\n#endif /* JAISTREAMDATAMGR_H */\n/* end \"JSystem/JAudio2/JAIStreamDataMgr.h\" */\n/* \"include/Z2AudioLib/Z2SoundInfo.h\" line 5 \"JSystem/JAudio2/JAUSoundInfo.h\" */\n#ifndef JAUSOUNDINFO_H\n#define JAUSOUNDINFO_H\n\n/* \"include/JSystem/JAudio2/JAUSoundInfo.h\" line 3 \"JSystem/JAudio2/JAISound.h\" */\n/* end \"JSystem/JAudio2/JAISound.h\" */\n/* \"include/JSystem/JAudio2/JAUSoundInfo.h\" line 4 \"JSystem/JAudio2/JASGadget.h\" */\n/* end \"JSystem/JAudio2/JASGadget.h\" */\n\nclass JAUSoundInfo : public JASGlobalInstance<JAUSoundInfo> {\npublic:\n    JAUSoundInfo(bool param_0) : JASGlobalInstance<JAUSoundInfo>(param_0) {}\n    virtual void getAudibleSw(JAISoundID) const = 0;\n    virtual u16 getBgmSeqResourceID(JAISoundID) const = 0;\n};\n\n#endif /* JAUSOUNDINFO_H */\n/* end \"JSystem/JAudio2/JAUSoundInfo.h\" */\n\nclass Z2SoundInfo : public JAISoundInfo, public JAUSoundInfo, public JAIStreamDataMgr, public JASGlobalInstance<Z2SoundInfo> {\npublic:\n    Z2SoundInfo() : JAISoundInfo(true), JAUSoundInfo(true), JASGlobalInstance<Z2SoundInfo>(true) {}\n    /* 802BB448 */ virtual void getAudibleSw(JAISoundID) const;\n    /* 802BB00C */ virtual u16 getBgmSeqResourceID(JAISoundID) const;\n    /* 802BBA88 */ virtual s32 getStreamFileEntry(JAISoundID);\n    /* 802BB090 */ virtual u32 getSoundType(JAISoundID) const;\n    /* 802BB0D8 */ virtual int getCategory(JAISoundID) const;\n    /* 802BB0E0 */ virtual u32 getPriority(JAISoundID) const;\n    /* 802BB6DC */ virtual void getSeInfo(JAISoundID, JAISe*) const;\n    /* 802BB8B4 */ virtual void getSeqInfo(JAISoundID, JAISeq*) const;\n    /* 802BB8E0 */ virtual void getStreamInfo(JAISoundID, JAIStream*) const;\n    /* 802BBBE0 */ virtual ~Z2SoundInfo();\n\n    /* 802BB158 */ u32 getAudibleSwFull(JAISoundID);\n    /* 802BBA10 */ const char* getStreamFilePath(JAISoundID);\n    /* 802BBAC8 */ int getSwBit(JAISoundID) const;\n    /* 802BBB48 */ void getSoundInfo_(JAISoundID, JAISound*) const;\n};\n\ninline Z2SoundInfo* Z2GetSoundInfo() {\n    return JASGlobalInstance<Z2SoundInfo>::getInstance();\n}\n\n#endif /* Z2SOUNDINFO_H */\n/* end \"Z2AudioLib/Z2SoundInfo.h\" */\n/* \"include/Z2AudioLib/Z2AudioMgr.h\" line 10 \"Z2AudioLib/Z2SoundMgr.h\" */\n#ifndef Z2SOUNDMGR_H\n#define Z2SOUNDMGR_H\n\n/* \"include/Z2AudioLib/Z2SoundMgr.h\" line 3 \"JSystem/JAudio2/JAISeMgr.h\" */\n#ifndef JAISEMGR_H\n#define JAISEMGR_H\n\n/* \"include/JSystem/JAudio2/JAISeMgr.h\" line 3 \"JSystem/JAudio2/JAISe.h\" */\n#ifndef JAISE_H\n#define JAISE_H\n\n/* \"include/JSystem/JAudio2/JAISe.h\" line 3 \"JSystem/JAudio2/JAISeqDataMgr.h\" */\n#ifndef JAISEQDATAMGR_H\n#define JAISEQDATAMGR_H\n\n/* \"include/JSystem/JAudio2/JAISeqDataMgr.h\" line 3 \"JSystem/JAudio2/JAISound.h\" */\n/* end \"JSystem/JAudio2/JAISound.h\" */\n\nstruct JAISeqData {\n    JAISeqData(void* param_0, u32 param_1) {\n        field_0x0 = param_0;\n        field_0x4 = param_1;\n    }\n\n    void set(void* param_0, u32 param_1) {\n        field_0x0 = param_0;\n        field_0x4 = param_1;\n    }\n\n    /* 0x00 */ void* field_0x0;\n    /* 0x04 */ u32 field_0x4;\n};\n\nstruct JAISeqDataRegion {\n    bool intersects(JAISeqData& seqData) const {\n        if (field_0x0 + field_0x4 < (u32)seqData.field_0x0) {\n            return false;\n        }\n        if ((u32)seqData.field_0x0 + seqData.field_0x4 < field_0x0) {\n            return false;\n        }\n        return true;\n    }\n\n    /* 0x00 */ u32 field_0x0;\n    /* 0x04 */ u32 field_0x4;\n};\n\n\nstruct JAISeqDataUser {\n    virtual ~JAISeqDataUser();\n    virtual bool isUsingSeqData(JAISeqDataRegion const&) = 0;\n    virtual int releaseSeqData(JAISeqDataRegion const&) = 0;\n};\n\nstruct JAISeqDataMgr {\n    enum SeqDataReturnValue{ SeqDataReturnValue_0 = 0, SeqDataReturnValue_1 = 1, SeqDataReturnValue_2 = 2};\n    virtual ~JAISeqDataMgr();\n    virtual SeqDataReturnValue getSeqData(JAISoundID, JAISeqData*) = 0;\n    virtual int releaseSeqData() = 0;\n    virtual bool setSeqDataUser(JAISeqDataUser*) = 0;\n};\n\n#endif /* JAISEQDATAMGR_H */\n/* end \"JSystem/JAudio2/JAISeqDataMgr.h\" */\n/* \"include/JSystem/JAudio2/JAISe.h\" line 4 \"JSystem/JAudio2/JASTrack.h\" */\n#ifndef JASTRACK_H\n#define JASTRACK_H\n\n/* \"include/JSystem/JAudio2/JASTrack.h\" line 3 \"JSystem/JAudio2/JASGadget.h\" */\n/* end \"JSystem/JAudio2/JASGadget.h\" */\n/* \"include/JSystem/JAudio2/JASTrack.h\" line 4 \"JSystem/JAudio2/JASOscillator.h\" */\n#ifndef JASOSCILLATOR_H\n#define JASOSCILLATOR_H\n\n/* \"include/JSystem/JAudio2/JASOscillator.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n\nstruct JASOscillator {\n\tstruct Point {};\n\n    struct EffectParams {};\n\n\tstruct Data {\n\t\t/* 0x00 */ u32 _00;\n\t\t/* 0x04 */ f32 _04;\n\t\t/* 0x08 */ const short* _08;\n\t\t/* 0x0C */ const short* _0C;\n\t\t/* 0x10 */ f32 _10;\n\t\t/* 0x14 */ f32 _14;\n\t};\n\n\tJASOscillator();\n\n\tvoid initStart(const Data*);\n\tvoid incCounter(f32 param_0);\n\tf32 getValue() const;\n\tvoid release();\n    void update();\n    void updateCurrentValue(f32 param_0);\n\n    void setDirectRelease(u16 param_0) { mDirectRelease = param_0; }\n    void stop() {\n        _1C = 0;\n    }\n\n\t/* 0x00 */ const Data* mData;\n\t/* 0x04 */ f32 _04;\n\t/* 0x08 */ f32 _08;\n\t/* 0x0C */ f32 _0C;\n\t/* 0x10 */ f32 _10;\n\t/* 0x14 */ u16 _14;\n\t/* 0x16 */ u16 mDirectRelease;\n\t/* 0x18 */ u8 _18;\n\t/* 0x1A */ u16 _1A;\n\t/* 0x1C */ int _1C;\n\n    static const f32 sCurveTableLinear[17];\n    static const f32 sCurveTableSampleCell[17];\n\tstatic const f32 sCurveTableSqRoot[17];\n\tstatic const f32 sCurveTableSquare[17];\n};\n\n#endif /* JASOSCILLATOR_H */\n/* end \"JSystem/JAudio2/JASOscillator.h\" */\n/* \"include/JSystem/JAudio2/JASTrack.h\" line 5 \"JSystem/JAudio2/JASRegisterParam.h\" */\n#ifndef JASREGISTERPARAM_H\n#define JASREGISTERPARAM_H\n\n/* \"include/JSystem/JAudio2/JASRegisterParam.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass JASRegisterParam {\npublic:\n    enum RegID {\n        REG0,\n        REG1,\n        REG2,\n        REG3,\n    };\n\n    /* 80293644 */ JASRegisterParam();\n    /* 80293664 */ void init();\n    /* 80293684 */ void write(JASRegisterParam::RegID, u32);\n    /* 802937B8 */ u32 read(JASRegisterParam::RegID);\n\n    u16 field_0x0[14];\n};\n\n#endif /* JASREGISTERPARAM_H */\n/* end \"JSystem/JAudio2/JASRegisterParam.h\" */\n/* \"include/JSystem/JAudio2/JASTrack.h\" line 6 \"JSystem/JAudio2/JASSeqCtrl.h\" */\n#ifndef JASSEQCTRL_H\n#define JASSEQCTRL_H\n\n/* \"include/JSystem/JAudio2/JASSeqCtrl.h\" line 3 \"JSystem/JAudio2/JASSeqReader.h\" */\n#ifndef JASSEQREADER_H\n#define JASSEQREADER_H\n\n/* \"include/JSystem/JAudio2/JASSeqReader.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass JASSeqReader {\npublic:\n    /* 80296108 */ void init();\n    /* 80296148 */ void init(void*);\n    /* 8029618C */ bool call(u32);\n    /* 802961CC */ bool loopStart(u32);\n    /* 80296210 */ bool loopEnd();\n    /* 8029627C */ bool ret();\n    /* 802962B0 */ int readMidiValue();\n\n    void jump(u32 param_1) {\n        field_0x04 = (u8*)field_0x00 + param_1;\n    }\n\n    void jump(void* param_1) {\n        field_0x04 = (u8*)param_1;\n    }\n\n    u32 get24(int param_0) {\n        return (*(u32*)((int)field_0x00 + param_0 - 1)) & 0xffffff;\n    }\n\n    u32* getBase() { return field_0x00; }\n    void* getAddr(u32 param_0) { return (u8*)field_0x00 + param_0; }\n    u8 getByte(u32 param_0) { return *((u8*)field_0x00 + param_0); }\n    u16 get16(u32 param_0) { return *(u16*)((u8*)field_0x00 + param_0); }\n    u32 get32(u32 param_0) { return *(u32*)((u8*)field_0x00 + param_0); }\n    u8* getCur() { return field_0x04; }\n    u32 readByte() { return *field_0x04++; }\n    u32 read16() {\n        u16* tmp = (u16*)field_0x04;\n        field_0x04 += 2;\n        return *tmp;\n    }\n    u32 read24() {\n        field_0x04--;\n        u32* tmp = (u32*)field_0x04;\n        field_0x04 += 4;\n        return *tmp & 0x00ffffff;\n    }\n    u16 getLoopCount() const { return field_0x08 == 0 ? 0 : field_0x2c[field_0x08 - 1]; }\n\n    /* 0x00 */ u32* field_0x00;\n    /* 0x04 */ u8* field_0x04;\n    /* 0x08 */ u32 field_0x08;\n    /* 0x0C */ u16* field_0x0c[8];\n    /* 0x2C */ u16 field_0x2c[8];\n};\n\n#endif /* JASSEQREADER_H */\n/* end \"JSystem/JAudio2/JASSeqReader.h\" */\n\nclass JASTrack;\nclass JASSeqParser;\n\nclass JASSeqCtrl {\npublic:\n    enum IntrType {\n        INTRTYPE_VALUE_0,\n        INTRTYPE_VALUE_1,\n        INTRTYPE_VALUE_2,\n        INTRTYPE_VALUE_3,\n        INTRTYPE_VALUE_4,\n        INTRTYPE_VALUE_5,\n        INTRTYPE_VALUE_6,\n    };\n\n    /* 802938BC */ JASSeqCtrl();\n    /* 80293924 */ void init();\n    /* 80293980 */ void start(void*, u32);\n    /* 802939C4 */ int tickProc(JASTrack*);\n    /* 80293ABC */ void interrupt(JASSeqCtrl::IntrType);\n    /* 80293AE0 */ void setIntrMask(u32);\n    /* 80293AF0 */ void clrIntrMask(u32);\n    /* 80293B00 */ int retIntr();\n    /* 80293B28 */ int findIntr();\n    /* 80293B78 */ void checkIntr();\n    /* 80293BE8 */ void timerProcess();\n\n    const JASSeqReader* getSeqReader() const { return &mReader; }\n    void* getBase() { return mReader.getBase(); }\n    void* getAddr(u32 param_0) { return mReader.getAddr(param_0); }\n    u8 getByte(u32 param_0) { return mReader.getByte(param_0); }\n    u16 get16(u32 param_0) { return mReader.get16(param_0); }\n    u32 get24(int param_0) { return mReader.get24(param_0); }\n    u32 get32(u32 param_0) { return mReader.get32(param_0); }\n    void* getCur() { return mReader.getCur(); }\n    u32 readByte() { return mReader.readByte(); }\n    u32 read16() { return mReader.read16(); }\n    u32 read24() { return mReader.read24(); }\n    bool call(u32 param_0) { return mReader.call(param_0); }\n    bool ret() { return mReader.ret(); }\n    void jump(u32 param_0) { mReader.jump(param_0); }\n    bool loopStart(u32 param_0) { return mReader.loopStart(param_0); }\n    bool loopEnd() { return mReader.loopEnd(); }\n    int readMidiValue() { return mReader.readMidiValue(); }\n    void wait(s32 param_0) { field_0x40 = param_0; }\n    void clrIntr() { field_0x44 = NULL; }\n    void setIntrTable(u32 param_0) { field_0x48 = param_0; }\n    void setIntrTimer(u32 param_0, u32 param_1) {\n        field_0x50 = param_0;\n        field_0x54 = param_1;\n        field_0x58 = param_1;\n    }\n    void waitNoteFinish() { field_0x51 = 1; }\n\n    /* 0x00 */ JASSeqReader mReader;\n    /* 0x3c */ JASSeqParser* field_0x3c;\n    /* 0x40 */ s32 field_0x40;\n    /* 0x44 */ void* field_0x44;\n    /* 0x48 */ u32 field_0x48;\n    /* 0x4c */ u16 field_0x4c;\n    /* 0x4e */ u16 field_0x4e;\n    /* 0x50 */ u8 field_0x50;\n    /* 0x51 */ u8 field_0x51;\n    /* 0x52 */ u16 field_0x52;\n    /* 0x54 */ u32 field_0x54;\n    /* 0x58 */ u32 field_0x58;\n    static JASSeqParser sDefaultParser;\n};\n\n#endif /* JASSEQCTRL_H */\n/* end \"JSystem/JAudio2/JASSeqCtrl.h\" */\n/* \"include/JSystem/JAudio2/JASTrack.h\" line 7 \"JSystem/JAudio2/JASTrackPort.h\" */\n#ifndef JASTRACKPORT_H\n#define JASTRACKPORT_H\n\n/* \"include/JSystem/JAudio2/JASTrackPort.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass JASTrackPort {\npublic:\n    /* 8029354C */ void init();\n    /* 8029357C */ u16 readImport(u32);\n    /* 802935A0 */ u16 readExport(u32);\n    /* 802935C4 */ void writeImport(u32, u16);\n    /* 802935E8 */ void writeExport(u32, u16);\n    /* 8029360C */ u32 checkImport(u32) const;\n    /* 80293628 */ u32 checkExport(u32) const;\n\n    u16 get(u32 param_0) { return field_0x4[param_0]; }\n    void set(u32 param_0, u16 param_1) { field_0x4[param_0] = param_1; }\n\n    u16 field_0x0;\n    u16 field_0x2;\n    u16 field_0x4[16];\n};\n\n#endif /* JASTRACKPORT_H */\n/* end \"JSystem/JAudio2/JASTrackPort.h\" */\n\nstruct JASSoundParams;\n\nnamespace JASDsp {\n    class TChannel;\n\n    extern u32 FILTER_MODE_IIR;\n};\n\nstruct JASChannel {\n    /* 8029AAD0 */ void release(u16);\n    /* 8029AB64 */ void setOscInit(u32, JASOscillator::Data const*);\n    /* 8029AB98 */ void setMixConfig(u32, u16);\n    /* 8029ACD4 */ void setKeySweepTarget(s32, u32);\n    /* 8029BBFC */ void free();\n};\n\nstruct JASTrack {\n    enum Status {\n        STATUS_FREE,\n        STATUS_RUN,\n    };\n\n    struct TChannelMgr {\n        /* 802930DC */ TChannelMgr(JASTrack*);\n        /* 80293148 */ void init();\n        /* 802931B0 */ void releaseAll();\n        /* 80293220 */ void noteOff(u32, u16);\n        /* 802932A0 */ void setPauseFlag(bool);\n\n        /* 0x00 */ JASChannel* field_0x0[8];\n        /* 0x20 */ u8 field_0x20[0x18];  // JASChannelParams\n        /* 0x38 */ short field_0x38[8];\n        /* 0x48 */ JASSoundParams* field_0x48;\n        /* 0x4c */ JASTrack* field_0x4c;\n    };\n\n    struct TList {\n        /* 80292F6C */ void cbSeqMain(void*);\n        /* 80292F90 */ void append(JASTrack*);\n        /* 8029301C */ void seqMain();\n        /* 8029345C */ ~TList();\n    };\n\n    struct MoveParam_ {\n        /* 802932C8 */ MoveParam_();\n\n        /* 0x00 */ f32 field_0x0;\n        /* 0x04 */ f32 field_0x4;\n        /* 0x08 */ int field_0x8;\n    };\n\n    /* 80291228 */ JASTrack();\n    /* 8029131C */ ~JASTrack();\n    /* 80291444 */ void setChannelMgrCount(u32);\n    /* 802915D4 */ void init();\n    /* 802918FC */ void initTimed();\n    /* 8029194C */ void inherit(JASTrack const&);\n    /* 802919F4 */ void assignExtBuffer(u32, JASSoundParams*);\n    /* 80291A08 */ void setSeqData(void*, u32);\n    /* 80291A28 */ void startSeq();\n    /* 80291A78 */ void stopSeq();\n    /* 80291ABC */ void start();\n    /* 80291AC8 */ void close();\n    /* 80291B8C */ void connectChild(u32, JASTrack*);\n    /* 80291BB8 */ void closeChild(u32);\n    /* 80291C30 */ JASTrack* openChild(u32);\n    /* 80291DAC */ void connectBus(int, int);\n    /* 80291DBC */ void setLatestKey(u8);\n    /* 80291DF8 */ void channelStart(JASTrack::TChannelMgr*, u32, u32, u32);\n    /* 80291F38 */ int noteOn(u32, u32, u32);\n    /* 80292008 */ int gateOn(u32, u32, f32, u32);\n    /* 80292198 */ int noteOff(u32, u16);\n    /* 80292220 */ bool checkNoteStop(u32) const;\n    /* 8029226C */ void overwriteOsc(JASChannel*);\n    /* 802922D8 */ void updateTimedParam();\n    /* 80292348 */ void updateTrack(f32);\n    /* 802924E4 */ void updateTempo();\n    /* 80292580 */ void updateSeq(bool, f32);\n    /* 80292644 */ void seqTimeToDspTime(f32);\n    /* 802926E0 */ void setParam(u32, f32, u32);\n    /* 80292708 */ void noteOffAll(u16);\n    /* 802927A0 */ void mute(bool);\n    /* 802927D8 */ void setOscScale(u32, f32);\n    /* 802927E8 */ void setOscTable(u32, JASOscillator::Point const*);\n    /* 80292808 */ void setOscAdsr(s16, s16, s16, s16, u16);\n    /* 8029285C */ void setFIR(s16 const*);\n    /* 8029289C */ void setIIR(s16 const*);\n    /* 802928D0 */ u16 readPortSelf(u32);\n    /* 802928F4 */ void writePortSelf(u32, u16);\n    /* 80292918 */ void writePort(u32, u16);\n    /* 8029297C */ u16 readPort(u32);\n    /* 802929A0 */ void setChannelPauseFlag(bool);\n    /* 80292A3C */ void pause(bool);\n    /* 80292AA4 */ void getTransposeTotal() const;\n    /* 80292AF4 */ void isMute() const;\n    /* 80292B58 */ void setTempo(u16);\n    /* 80292B8C */ void setTempoRate(f32);\n    /* 80292BC0 */ void setTimebase(u16);\n    /* 80292BF4 */ void updateChannel(JASChannel*, JASDsp::TChannel*);\n    /* 80292CA4 */ void channelUpdateCallback(u32, JASChannel*, JASDsp::TChannel*, void*);\n    /* 80292D88 */ void getRootTrack();\n    /* 80292DA0 */ void tickProc();\n    /* 80292E9C */ void seqMain();\n\n    static u8 const sAdsTable[24];\n    static u8 const sEnvOsc[24];\n    static u8 const sPitchEnvOsc[24];\n    static u8 sDefaultBankTable[1036];\n    static u8 sTrackList[16];\n\n    JASSeqCtrl* getSeqCtrl() { return &mSeqCtrl; }\n    u16 getPort(u32 param_0) { return mTrackPort.get(param_0); }\n    void setPort(u32 param_0, u16 param_1) { mTrackPort.set(param_0, param_1); }\n    u32 checkPortIn(u32 param_0) { return mTrackPort.checkImport(param_0); }\n    u32 checkPort(u32 param_0) { return mTrackPort.checkExport(param_0); }\n    u32 readReg(JASRegisterParam::RegID param_0) { return mRegisterParam.read(param_0); }\n    void writeReg(JASRegisterParam::RegID param_0, u32 param_1) { mRegisterParam.write(param_0, param_1); }\n    JASTrack* getParent() { return mParent; }\n    JASTrack* getChild(u32 index) { return mChildren[index]; }\n    int getChannelMgrCount() { return channelMgrCount; }\n    f32 getVibDepth() const { return mVibDepth; }\n    void setVibDepth(f32 param_0) { mVibDepth = param_0; }\n    f32 getVibPitch() const { return mVibPitch; }\n    void setVibPitch(f32 param_0) { mVibPitch = param_0; }\n    f32 getTremDepth() const { return mTremDepth; }\n    void setTremDepth(f32 param_0) { mTremDepth = param_0; }\n    f32 getTremPitch() const { return mTremPitch; }\n    void setTremPitch(f32 param_0) { mTremPitch = param_0; }\n    u16 getVibDelay() const { return mVibDelay; }\n    void setVibDelay(u32 param_0) { mVibDelay = param_0; }\n    u16 getTremDelay() const { return mTremDelay; }\n    void setTremDelay(u32 param_0) { mTremDelay = param_0; }\n    u8 getStatus() const { return mStatus; }\n    void setAutoDelete(u8 param_0) { field_0x216.autoDelete = param_0; }\n    f32 getPanPower() const { return mPanPower; }\n    void setPanPower(f32 param_0) { mPanPower = param_0; }\n    u32 getSkipSample() const { return mSkipSample; }\n    void setSkipSample(u32 param_0) { mSkipSample = param_0; }\n    u16 getDirectRelease() const { return mDirectRelease; }\n    void setDirectRelease(u16 param_0) {mDirectRelease = param_0; }\n    u16 getTimebase() const { return mTimebase; }\n    s8 getTranspose() const { return mTranspose; }\n    void setTranspose(u32 param_0) { mTranspose = param_0; }\n    u16 getBankNumber() const { return mBankNumber; }\n    void setBankNumber(u16 param_0) { mBankNumber = param_0; }\n    u16 getProgNumber() const { return mProgNumber; }\n    void setProgNumber(u16 param_0) { mProgNumber = param_0; }\n    u8 getBendSense() const { return mBendSense; }\n    void setBendSense(u8 param_0) { mBendSense = param_0; }\n    u8 getNoteOnPrio() const { return mNoteOnPrio; }\n    void setNoteOnPrio(u8 param_0) { mNoteOnPrio = param_0; }\n    u8 getReleasePrio() const { return mReleasePrio; }\n    void setReleasePrio(u8 param_0) { mReleasePrio = param_0; }\n    u8 getGateRate() const { return mGateRate; }\n    void setGateRate(u8 param_0) { mGateRate = param_0; }\n\n    /* 0x000 */ JASSeqCtrl mSeqCtrl;\n    /* 0x05C */ JASTrackPort mTrackPort;\n    /* 0x080 */ JASRegisterParam mRegisterParam;\n    /* 0x09C */ MoveParam_ field_0x9c[6];\n    /* 0x0e4 */ u8 mOscParam[0x30]; // JASOscillator::Data[2]\n    /* 0x114 */ u8 field_0x114[0x18]; // JASOscillator::Point[4]\n    /* 0x12C */ JASTrack* mParent;\n    /* 0x130 */ JASTrack* mChildren[16];\n    /* 0x170 */ TChannelMgr* field_0x170[4];\n    /* 0x180 */ TChannelMgr field_0x180;\n    /* 0x1D0 */ int channelMgrCount;\n    /* 0x1D4 */ void* field_0x1d4;\n    /* 0x1D8 */ f32 field_0x1d8;\n    /* 0x1DC */ f32 field_0x1dc;\n    /* 0x1E0 */ f32 mVibDepth;\n    /* 0x1E4 */ f32 mVibPitch;\n    /* 0x1E8 */ f32 mTremDepth;\n    /* 0x1EC */ f32 mTremPitch;\n    /* 0x1F0 */ u16 mVibDelay;\n    /* 0x1F2 */ u16 mTremDelay;\n    /* 0x1F4 */ short field_0x1f4[8];\n    /* 0x204 */ short field_0x204[8];\n    /* 0x214 */ char field_0x214;\n    /* 0x215 */ volatile u8 mStatus;\n    /* 0x216 */ struct {\n        u8 flag0 : 1;\n        u8 flag1 : 1;\n        u8 flag2 : 1;\n        u8 autoDelete : 1;\n        u8 flag4 : 1;\n        u8 flag5 : 1;\n        u8 flag6 : 1;\n        u8 flag7 : 1;\n    } field_0x216;\n    /* 0x218 */ f32 mPanPower;\n    /* 0x21C */ f32 field_0x21c;\n    /* 0x220 */ u32 mSkipSample;\n    /* 0x224 */ u16 mDirectRelease;\n    /* 0x226 */ u16 field_0x226;\n    /* 0x228 */ u16 mTimebase;\n    /* 0x22A */ s8 mTranspose;\n    /* 0x22B */ char field_0x22b;\n    /* 0x22C */ u16 mBankNumber;\n    /* 0x22E */ u16 mProgNumber;\n    /* 0x230 */ u8 mBendSense;\n    /* 0x231 */ u8 mNoteOnPrio;\n    /* 0x232 */ u8 mReleasePrio;\n    /* 0x233 */ u8 mGateRate;\n    /* 0x234 */ u16 field_0x234[6];\n    /* 0x240 */ u8 field_0x240[0x08]; // TLinkListNode\n};\n\nstruct JASDefaultBankTable : public JASGlobalInstance<JASDefaultBankTable> {\n    /* 802934B4 */ ~JASDefaultBankTable();\n};\n\n#endif /* JASTRACK_H */\n/* end \"JSystem/JAudio2/JASTrack.h\" */\n/* \"include/JSystem/JAudio2/JAISe.h\" line 5 \"JSystem/JSupport/JSUList.h\" */\n/* end \"JSystem/JSupport/JSUList.h\" */\n\nclass JAISeMgr;\n\nclass JAISe : public JSULink<JAISe>, public JAISound {\npublic:\n    class TInner {\n    public:\n        TInner() : mSeqData(NULL, 0) {}\n\n        /* 0x000 */ u32 mProperPriority;\n        /* 0x004 */ u32 mPriority;\n        /* 0x008 */ JASSoundParams mSoundParams;\n        /* 0x01c */ JASTrack track;\n        /* 0x264 */ JAISeqData mSeqData;\n        /* 0x26c */ u8 field_0x26c;\n        /* 0x270 */ JAISeMgr* seMgr;\n        /* 0x274 */ JAISoundStrategyMgr<JAISe>* mSoundStrategyMgr;\n        /* 0x278 */ JAISoundStrategyMgr__unknown<JAISe>* field_0x278;\n        /* 0x27c */ JAITempoMgr mTempoMgr;\n    };\n\n    /* 8029F6D8 */ virtual s32 getNumChild() const;\n    /* 8029F6E0 */ virtual JAISoundChild* getChild(int);\n    /* 8029F6E8 */ virtual void releaseChild(int);\n    /* 8029F84C */ virtual JASTrack* getTrack();\n    /* 8029F854 */ virtual JASTrack* getChildTrack(int);\n    /* 8029F864 */ virtual JAISe* asSe();\n    /* 8029F868 */ virtual JAITempoMgr* getTempoMgr();\n    /* 8029F5C8 */ virtual bool JAISound_tryDie_();\n\n    /* 8029F03C */ JAISe(JAISeMgr*, JAISoundStrategyMgr<JAISe>*, u32);\n    /* 8029F0F8 */ void mixOut_(JASSoundParams const&);\n    /* 8029F214 */ void stopTrack_();\n    /* 8029F250 */ void startTrack_(JASSoundParams const&);\n    /* 8029F304 */ void JAISeCategoryMgr_mixOut_(bool, JASSoundParams const&, JAISoundActivity);\n    /* 8029F4CC */ void JAISeCategoryMgr_calc_();\n    /* 8029F650 */ void JAISeMgr_startID_(JAISoundID, JGeometry::TVec3<f32> const*, JAIAudience*);\n    /* 8029F6EC */ bool prepare_getSeqData_();\n    /* 8029F78C */ void prepare_();\n\n    JAISeqData* getSeqData() { return &inner_.mSeqData; }\n    u32 JAISeCategoryMgr_getProperPriority_() const { return inner_.mProperPriority; }\n    u32 JAISeCategoryMgr_getPriority_() const { return inner_.mPriority; }\n    bool isFarAway() const { return mPriority == -1; }\n\n    /* 0x0ac */ TInner inner_;\n};\n\n#endif /* JAISE_H */\n/* end \"JSystem/JAudio2/JAISe.h\" */\n/* \"include/JSystem/JAudio2/JAISeMgr.h\" line 4 \"JSystem/JAudio2/JASHeapCtrl.h\" */\n/* end \"JSystem/JAudio2/JASHeapCtrl.h\" */\n/* \"include/JSystem/JAudio2/JAISeMgr.h\" line 5 \"JSystem/JSupport/JSUList.h\" */\n/* end \"JSystem/JSupport/JSUList.h\" */\n/* \"include/JSystem/JAudio2/JAISeMgr.h\" line 6 \"global.h\" */\n/* end \"global.h\" */\n\nstruct JAIAudience;\nstruct JASSoundParams;\n\nstruct JASNonCopyable {\n    /* 0x0 */ int field_0x0;\n};  // Size: 0x4\n\nstruct JAISeCategoryArrangementItem {\n    u8 mMaxActiveSe;\n    u8 mMaxInactiveSe;\n};\n\nstruct JAISeCategoryArrangement {\n    JAISeCategoryArrangementItem mItems[16];\n};\n\nclass JAISeMgr;\n\nclass JAISeCategoryMgr : public JAISeqDataUser {\npublic:\n    /* 8029F9C4 */ void JAISeMgr_calc_();\n    /* 8029FB30 */ void JAISeMgr_freeDeadSe_();\n    /* 8029FC88 */ u32 JAISeMgr_acceptsNewSe_(u32) const;\n    /* 8029FD40 */ void sortByPriority_();\n    /* 8029FDE0 */ void stop(u32);\n    /* 8029FE34 */ void stop();\n    /* 8029FE78 */ void stopSoundID(JAISoundID);\n    /* 8029FEEC */ void pause(bool);\n    /* 8029FF18 */ void JAISeMgr_mixOut_(JAISoundParamsMove const&, JAISoundActivity);\n    /* 802A0994 */ JAISeCategoryMgr();\n\n    /* 800078DC */ virtual ~JAISeCategoryMgr() {}\n    /* 8029F8B0 */ virtual bool isUsingSeqData(JAISeqDataRegion const&);\n    /* 8029F91C */ virtual int releaseSeqData(JAISeqDataRegion const&);\n\n    JAISoundParamsMove* getParams() { return &mParams; }\n    int getMaxSe() const {\n        return (mMaxActiveSe == 0) ? 0 : mMaxActiveSe + mMaxInactiveSe;\n    }\n    int getMaxActiveSe() const { return mMaxActiveSe; }\n    void setMaxActiveSe(int se) { mMaxActiveSe = se; }\n    void setMaxInactiveSe(int se) { mMaxInactiveSe = se; }\n    JSUList<JAISe>* getSeList() { return &mSeList; }\n    int getNumSe() const { return mSeList.getNumLinks(); }\n    JAIAudience* getAudience() { return (JAIAudience*)field_0x4.field_0x0; }\n\n    /* 0x04 */ JASNonCopyable field_0x4;\n    /* 0x08 */ JAISoundParamsMove mParams;\n    /* 0x58 */ JSUList<JAISe> mSeList;\n    /* 0x64 */ int mMaxInactiveSe;\n    /* 0x68 */ int mMaxActiveSe;\n};  // Size: 0x6C\n\nclass JAISeMgr : public JASGlobalInstance<JAISeMgr>,\n                 public JAISeqDataUser,\n                 public JAISoundActivity {\npublic:\n    /* 802A0074 */ JAISeMgr(bool);\n    /* 802A0268 */ void setCategoryArrangement(JAISeCategoryArrangement const&);\n    /* 802A02A0 */ void stop();\n    /* 802A02F4 */ void stopSoundID(JAISoundID);\n    /* 802A0358 */ void initParams();\n    /* 802A03D8 */ void setAudience(JAIAudience*);\n    /* 802A03E0 */ void setSeqDataMgr(JAISeqDataMgr*);\n    /* 802A0434 */ void resetSeqDataMgr();\n    /* 802A0484 */ JAISe* newSe_(int, u32);\n    /* 802A0574 */ void calc();\n    /* 802A0704 */ void mixOut();\n    /* 802A0768 */ int startSound(JAISoundID, JAISoundHandle*, JGeometry::TVec3<f32> const*);\n    /* 802A08D0 */ int getNumActiveSe() const;\n\n    /* 802A08FC */ virtual ~JAISeMgr();  // inline?\n    /* 802A0168 */ virtual bool isUsingSeqData(JAISeqDataRegion const&);\n    /* 802A01D8 */ virtual int releaseSeqData(JAISeqDataRegion const&);\n\n    JAISeCategoryMgr* getCategory(int categoryIndex) { return &mCategoryMgrs[categoryIndex]; }\n    JAIAudience* getAudience(int categoryIndex) {\n        if (categoryIndex >= 0 && categoryIndex < 16) {\n            JAIAudience* rv = mCategoryMgrs[categoryIndex].getAudience();\n            if (rv) return rv;\n        }\n        return mAudience;\n    }\n    JAISeqDataMgr* getSeqDataMgr() { return mSeqDataMgr; }\n    JAISoundParamsMove* getParams() { return &mParams; }\n\nprivate:\n    /* 0x008 */ JAIAudience* mAudience;\n    /* 0x00C */ JAISeqDataMgr* mSeqDataMgr;\n    /* 0x010 */ int field_0x10;\n    /* 0x014 */ JAISeCategoryMgr mCategoryMgrs[16];\n    /* 0x6D4 */ JAISoundParamsMove mParams;\n};  // Size: 0x724\n\nSTATIC_ASSERT(sizeof(JAISeMgr) == 0x724);\n\n#endif /* JAISEMGR_H */\n/* end \"JSystem/JAudio2/JAISeMgr.h\" */\n/* \"include/Z2AudioLib/Z2SoundMgr.h\" line 4 \"JSystem/JAudio2/JAISeqMgr.h\" */\n#ifndef JAISEQMGR_H\n#define JAISEQMGR_H\n\n/* \"include/JSystem/JAudio2/JAISeqMgr.h\" line 3 \"JSystem/JAudio2/JAISeqDataMgr.h\" */\n/* end \"JSystem/JAudio2/JAISeqDataMgr.h\" */\n/* \"include/JSystem/JAudio2/JAISeqMgr.h\" line 4 \"JSystem/JAudio2/JASGadget.h\" */\n/* end \"JSystem/JAudio2/JASGadget.h\" */\n/* \"include/JSystem/JAudio2/JAISeqMgr.h\" line 5 \"JSystem/JSupport/JSUList.h\" */\n/* end \"JSystem/JSupport/JSUList.h\" */\n/* \"include/JSystem/JAudio2/JAISeqMgr.h\" line 6 \"JSystem/JUtility/JUTAssert.h\" */\n/* end \"JSystem/JUtility/JUTAssert.h\" */\n\nstruct JAIAudience;\nclass JAISeq;\n\nclass JAISeqMgr : public JAISeqDataUser, public JASGlobalInstance<JAISeqMgr> {\npublic:\n    /* 802A1914 */ JAISeqMgr(bool);\n    /* 802A1A08 */ void freeDeadSeq_();\n    /* 802A1B48 */ void startSound(JAISoundID, JAISoundHandle*, JGeometry::TVec3<f32> const*);\n    /* 802A1C90 */ void calc();\n    /* 802A1DFC */ void stop();\n    /* 802A1E3C */ void stop(u32);\n    /* 802A1E8C */ void stopSoundID(JAISoundID);\n    /* 802A1EFC */ void mixOut();\n    /* 802A1F58 */ void beginStartSeq_();\n    /* 802A1FE8 */ void endStartSeq_(JAISeq*, JAISoundHandle*);\n\n    /* 802A20F0 */ virtual ~JAISeqMgr();  // inline?\n    /* 802A1804 */ virtual bool isUsingSeqData(JAISeqDataRegion const&);\n    /* 802A1870 */ virtual int releaseSeqData(JAISeqDataRegion const&);\n\n    void setAudience(JAIAudience* param_0) { mAudience = param_0; }\n    JAISeqDataMgr* getSeqDataMgr() { return seqDataMgr_; }\n    void setSeqDataMgr(JAISeqDataMgr* param_0) {\n        JUT_ASSERT(124, !isActive());\n        resetSeqDataMgr();\n        seqDataMgr_ = param_0;\n        seqDataMgr_->setSeqDataUser(this);\n    }\n    void resetSeqDataMgr() {\n        JUT_ASSERT(131, !isActive());\n        if (seqDataMgr_) {\n            seqDataMgr_->setSeqDataUser(NULL);\n            seqDataMgr_ = NULL;\n        }\n    }\n    JAISoundParamsMove* getParams() { return &mMove; }\n    bool isActive() { return mSeqList.getNumLinks() != 0; }\n\nprivate:\n    /* 0x04 */ JAISoundActivity mActivity;\n    /* 0x08 */ JAIAudience* mAudience;\n    /* 0x0C */ JAISeqDataMgr* seqDataMgr_;\n    /* 0x10 */ void* field_0x10;\n    /* 0x14 */ JAISoundParamsMove mMove;\n    /* 0x64 */ JSUList<JAISeq> mSeqList;\n    /* 0x70 */ int field_0x70;\n};  // Size: 0x74\n\n#endif /* JAISEQMGR_H */\n/* end \"JSystem/JAudio2/JAISeqMgr.h\" */\n/* \"include/Z2AudioLib/Z2SoundMgr.h\" line 5 \"JSystem/JAudio2/JAIStreamMgr.h\" */\n#ifndef JAISTREAMMGR_H\n#define JAISTREAMMGR_H\n\n/* \"include/JSystem/JAudio2/JAIStreamMgr.h\" line 3 \"JSystem/JAudio2/JAISound.h\" */\n/* end \"JSystem/JAudio2/JAISound.h\" */\n/* \"include/JSystem/JAudio2/JAIStreamMgr.h\" line 4 \"JSystem/JAudio2/JASGadget.h\" */\n/* end \"JSystem/JAudio2/JASGadget.h\" */\n/* \"include/JSystem/JAudio2/JAIStreamMgr.h\" line 5 \"JSystem/JSupport/JSUList.h\" */\n/* end \"JSystem/JSupport/JSUList.h\" */\n/* \"include/JSystem/JAudio2/JAIStreamMgr.h\" line 6 \"JSystem/JUtility/JUTAssert.h\" */\n/* end \"JSystem/JUtility/JUTAssert.h\" */\n\nclass JAIStreamAramMgr;\nclass JAIStreamDataMgr;\nclass JAIStreamMgr;\n\nclass JAIStream {\npublic:\n    /* 802A3104 */ JAIStream(JAIStreamMgr*, JAISoundStrategyMgr<JAIStream>*);\n    /* 802A319C */ void JAIStreamMgr_startID_(JAISoundID, s32, JGeometry::TVec3<f32> const*,\n                                              JAIAudience*, int);\n    /* 802A34E4 */ void JAIStreamMgr_mixOut_(JASSoundParams const&, JAISoundActivity);\n    /* 802A388C */ void JAIStreamMgr_calc_();\n};\n\nclass JAIStreamMgr : public JASGlobalInstance<JAIStreamMgr> {\npublic:\n    /* 802A3B68 */ JAIStreamMgr(bool);\n    /* 802A3C3C */ void startSound(JAISoundID, JAISoundHandle*, JGeometry::TVec3<f32> const*);\n    /* 802A3D70 */ void freeDeadStream_();\n    /* 802A3EBC */ void calc();\n    /* 802A4028 */ void stop();\n    /* 802A4068 */ void stop(u32);\n    /* 802A40B8 */ void stopSoundID(JAISoundID);\n    /* 802A4118 */ void mixOut();\n    /* 802A4174 */ void newStream_();\n    /* 802B9978 */ bool isActive() const;\n\n    JAISoundParamsMove* getParams() { return &mParams; }\n    void setStreamDataMgr(JAIStreamDataMgr* param_0) {\n        JUT_ASSERT(139, !isActive());\n        mStreamDataMgr = param_0;\n    }\n    void setStreamAramMgr(JAIStreamAramMgr* param_0) {\n        JUT_ASSERT(157, !isActive());\n        mStreamAramMgr = param_0;\n    }\n\nprivate:\n    /* 0x00 */ JAISoundActivity mActivity;\n    /* 0x04 */ JAISoundParamsMove mParams;\n    /* 0x54 */ int field_0x54;\n    /* 0x58 */ JSUList<JAIStream> mStreamList;\n    /* 0x64 */ JAIStreamDataMgr * mStreamDataMgr;\n    /* 0x68 */ JAIStreamAramMgr* mStreamAramMgr;\n    /* 0x6C */ int field_0x6c;\n};  // Size: 0x70\n\n#endif /* JAISTREAMMGR_H */\n/* end \"JSystem/JAudio2/JAIStreamMgr.h\" */\n/* \"include/Z2AudioLib/Z2SoundMgr.h\" line 6 \"global.h\" */\n/* end \"global.h\" */\n\nu16 seqCallback(JASTrack* param_0, u16 param_1);\n\nclass Z2SoundMgr : public JASGlobalInstance<Z2SoundMgr> {\npublic:\n    /* 802A9E80 */ Z2SoundMgr();\n    /* 802AA1B0 */ void calc();\n    /* 802AA270 */ void setIIR(JAISound*, s16 const*);\n    /* 802AA33C */ void setFilterOff(JAISound*);\n    /* 802AA430 */ void resetFilterAll();\n    /* 802AA528 */ void mixOut();\n    /* 802AA67C */ void framework();\n    /* 802AA6B0 */ void pauseAllGameSound(bool);\n    /* 802AA7DC */ void stopSoundID(JAISoundID);\n    /* 802AA84C */ void stopSync();\n    /* 802AA8C8 */ void stop();\n    /* 802AA908 */ void initParams();\n    /* 802AA9E8 */ void multiVolumeSoundID(JAISoundID, f32);\n    /* 802AAAC4 */ void isPlayingSoundID(JAISoundID);\n\n    /* 802A9EE8 */ virtual int startSound(JAISoundID, JAISoundHandle*,\n                                                 JGeometry::TVec3<f32> const*);\n\n    JAISeMgr* getSeMgr() { return &mSeMgr; }\n    JAISeqMgr* getSeqMgr() { return &mSeqMgr; }\n    JAIStreamMgr* getStreamMgr() { return &mStreamMgr; }\n\nprivate:\n    /* 0x004 */ JAISeMgr mSeMgr;\n    /* 0x728 */ JAISeqMgr mSeqMgr;\n    /* 0x79C */ JAIStreamMgr mStreamMgr;\n    /* 0x80C */ JAISoundID field_0x80c;\n};  // Size: 0x810\n\nSTATIC_ASSERT(sizeof(Z2SoundMgr) == 0x810);\n\ninline Z2SoundMgr* Z2GetSoundMgr() {\n    return JASGlobalInstance<Z2SoundMgr>::getInstance();\n}\n\n#endif /* Z2SOUNDMGR_H */\n/* end \"Z2AudioLib/Z2SoundMgr.h\" */\n/* \"include/Z2AudioLib/Z2AudioMgr.h\" line 11 \"Z2AudioLib/Z2SoundObjMgr.h\" */\n#ifndef Z2SOUNDOBJMGR_H\n#define Z2SOUNDOBJMGR_H\n\n/* \"include/Z2AudioLib/Z2SoundObjMgr.h\" line 3 \"JSystem/JAudio2/JASGadget.h\" */\n/* end \"JSystem/JAudio2/JASGadget.h\" */\n/* \"include/Z2AudioLib/Z2SoundObjMgr.h\" line 4 \"JSystem/JSupport/JSUList.h\" */\n/* end \"JSystem/JSupport/JSUList.h\" */\n\nclass Z2CreatureEnemy;\n\nstruct Z2EnemyArea {\n    /* 0x00 */ u8 field_0x0;\n    /* 0x02 */ u16 field_0x2;\n    /* 0x04 */ u16 field_0x4;\n    /* 0x06 */ u16 field_0x6;\n};\n\nenum Z2EnemyID {\n    Z2_ENEMY_ID_0,\n};\n\nclass Z2SoundObjMgr : public JASGlobalInstance<Z2SoundObjMgr>, protected JSUList<Z2CreatureEnemy> {\npublic:\n    Z2SoundObjMgr();\n    void setForceBattleArea(bool, u16, u16, u16);\n    void searchEnemy();\n    void setGhostEnemyState(u8);\n    u8 getEnemyID(char const*, JSULink<Z2CreatureEnemy>*);\n    void setBattleInit();\n    bool checkBattleFinish();\n    void deleteEnemyAll();\n    bool removeEnemy(JSULink<Z2CreatureEnemy>*);\n    u8 isTwilightBattle();\n\n    bool isForceBattle() { return mForceBattle; }\n\nprivate:\n    /* 0x0C */ Z2EnemyArea mEnemyArea;\n    /* 0x14 */ u8 field_0x14;\n    /* 0x15 */ u8 mEnemyNumNear;\n    /* 0x16 */ u8 field_0x16;\n    /* 0x17 */ u8 mEnemyNumVeryFar;\n    /* 0x18 */ u8 field_0x18;\n    /* 0x19 */ u8 mGhostEnemyState;\n    /* 0x1A */ u8 field_0x1a;\n    /* 0x1B */ u8 mTwilightBattle;\n    /* 0x1C */ bool mForceBattle;\n};  // Size = 0x20\n\ninline Z2SoundObjMgr* Z2GetSoundObjMgr() {\n    return JASGlobalInstance<Z2SoundObjMgr>::getInstance();\n}\n\n#endif /* Z2SOUNDOBJMGR_H */\n/* end \"Z2AudioLib/Z2SoundObjMgr.h\" */\n/* \"include/Z2AudioLib/Z2AudioMgr.h\" line 12 \"Z2AudioLib/Z2SpeechMgr2.h\" */\n#ifndef Z2SPEECHMGR2_H\n#define Z2SPEECHMGR2_H\n\n/* \"include/Z2AudioLib/Z2SpeechMgr2.h\" line 3 \"JSystem/JAudio2/JAISoundHandles.h\" */\n/* end \"JSystem/JAudio2/JAISoundHandles.h\" */\n/* \"include/Z2AudioLib/Z2SpeechMgr2.h\" line 4 \"JSystem/JMath/random.h\" */\n#ifndef RANDOM_H\n#define RANDOM_H\n\n/* \"include/JSystem/JMath/random.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nnamespace JMath {\nstruct TRandom_fast_ {\n    u32 value;\n\n    TRandom_fast_(u32 value);\n    u32 get(void) {\n        value = (value * 0x19660d) + 0x3c6ef35f;\n        return value;\n    }\n\n    u32 get_bit32(void) { return this->get(); }\n\n    // due to the float constant, having this function inlined adds that float to data,\n    // making it not match\n    float get_ufloat_1(void) {\n        // !@bug UB: in C++ it's not legal to read from an union member other\n        // than the last one that was written to.\n        union {\n            f32 f;\n            u32 s;\n        } out;\n        out.s = (this->get() >> 9) | 0x3f800000;\n        return out.f - 1;\n    }\n\n    void setSeed(u32 seed) { value = seed; }\n};\n}  // namespace JMath\n\n#endif /* RANDOM_H */\n/* end \"JSystem/JMath/random.h\" */\n/* \"include/Z2AudioLib/Z2SpeechMgr2.h\" line 5 \"Z2AudioLib/Z2SoundStarter.h\" */\n#ifndef Z2SOUNDSTARTER_H\n#define Z2SOUNDSTARTER_H\n\n/* \"include/Z2AudioLib/Z2SoundStarter.h\" line 3 \"JSystem/JAudio2/JAISoundStarter.h\" */\n#ifndef JAISOUNDSTARTER_H\n#define JAISOUNDSTARTER_H\n\n/* \"include/JSystem/JAudio2/JAISoundStarter.h\" line 3 \"JSystem/JAudio2/JAISound.h\" */\n/* end \"JSystem/JAudio2/JAISound.h\" */\n/* \"include/JSystem/JAudio2/JAISoundStarter.h\" line 4 \"JSystem/JAudio2/JASGadget.h\" */\n/* end \"JSystem/JAudio2/JASGadget.h\" */\n\nstruct JAISoundStarter : public JASGlobalInstance<JAISoundStarter> {\n    /* 802A2F6C */ JAISoundStarter(bool);\n\n    virtual ~JAISoundStarter();\n    /* 802A2FEC */ bool startLevelSound(JAISoundID, JAISoundHandle*, JGeometry::TVec3<f32> const*);\n};\n\n#endif /* JAISOUNDSTARTER_H */\n/* end \"JSystem/JAudio2/JAISoundStarter.h\" */\n/* \"include/Z2AudioLib/Z2SoundStarter.h\" line 4 \"JSystem/JAudio2/JASGadget.h\" */\n/* end \"JSystem/JAudio2/JASGadget.h\" */\n\nstruct Z2SoundStarter : public JAISoundStarter, public JASGlobalInstance<Z2SoundStarter> {\n    Z2SoundStarter(bool);\n    void setPortData(JAISoundHandle*, u32, u16, s8);\n    void getPortData(JAISoundHandle*, u32, s8);\n\n    virtual ~Z2SoundStarter();\n    virtual void startSound(JAISoundID, JAISoundHandle*, JGeometry::TVec3<f32> const*);\n    virtual void startSound(JAISoundID, JAISoundHandle*, JGeometry::TVec3<f32> const*, u32, float,\n                            float, float, float, float, u32);\n};\n\n#endif /* Z2SOUNDSTARTER_H */\n/* end \"Z2AudioLib/Z2SoundStarter.h\" */\n/* \"include/Z2AudioLib/Z2SpeechMgr2.h\" line 6 \"global.h\" */\n/* end \"global.h\" */\n\nstruct Z2SpeechStarter : public Z2SoundStarter {\n    /* 802CCFB8 */ Z2SpeechStarter();\n\n    /* 802CBCEC */ virtual ~Z2SpeechStarter();\n    /* 802CCFF8 */ virtual void startSound(JAISoundID, JAISoundHandle*,\n                                           JGeometry::TVec3<f32> const*, u32, f32, f32, f32, f32,\n                                           f32, u32);\n};\n\nstruct Z2SpeechMgr2 : public JASGlobalInstance<Z2SpeechMgr2> {\n    /* 802CBC60 */ Z2SpeechMgr2();\n    /* 802CBD88 */ void setString(u16 const*, s16, u8, u16);\n    /* 802CBF60 */ void setTextCount(s16);\n    /* 802CC190 */ void speakOneWord(bool);\n    /* 802CC2FC */ void isNonVerbal();\n    /* 802CC4C0 */ void selectUnit(bool);\n    /* 802CC738 */ void selectTail();\n    /* 802CC9D0 */ void framework();\n    /* 802CCA18 */ void playOneShotVoice(u8, u16, Vec*, s8);\n    /* 802CCF88 */ void isMidnaSpeak();\n\n    /* 0x000 */ JAISoundHandle field_0x0;\n    /* 0x004 */ JAISoundHandle field_0x4;\n    /* 0x008 */ JMath::TRandom_fast_ random;\n    /* 0x00C */ Z2SpeechStarter mSpeech;\n    /* 0x010 */ u16 field_0x10[500];\n    /* 0x3F8 */ u16 field_0x3f8;\n    /* 0x3FA */ u16 field_0x3fa;\n    /* 0x3FC */ u16 field_0x3fc;\n    /* 0x3FE */ u8 field_0x3fe;\n    /* 0x3FF */ u8 field_0x3ff;\n    /* 0x400 */ u8 field_0x400;\n    /* 0x401 */ u8 field_0x401;\n    /* 0x402 */ u8 field_0x402[64];\n};  // Size: 0x444\n\nSTATIC_ASSERT(sizeof(Z2SpeechMgr2) == 0x444);\n\ninline Z2SpeechMgr2* Z2GetSpeechMgr2() {\n    return Z2SpeechMgr2::getInstance();\n}\n\n#endif /* Z2SPEECHMGR2_H */\n/* end \"Z2AudioLib/Z2SpeechMgr2.h\" */\n/* \"include/Z2AudioLib/Z2AudioMgr.h\" line 13 \"Z2AudioLib/Z2StatusMgr.h\" */\n#ifndef Z2STATUSMGR_H\n#define Z2STATUSMGR_H\n\n/* \"include/Z2AudioLib/Z2StatusMgr.h\" line 3 \"JSystem/JAudio2/JASGadget.h\" */\n/* end \"JSystem/JAudio2/JASGadget.h\" */\n/* \"include/Z2AudioLib/Z2StatusMgr.h\" line 4 \"dolphin/mtx/vec.h\" */\n/* end \"dolphin/mtx/vec.h\" */\n\nstruct Z2StatusMgr : public JASGlobalInstance<Z2StatusMgr> {\n    Z2StatusMgr();\n    void heartGaugeOn();\n    void processHeartGaugeSound();\n    void talkIn();\n    void talkOut();\n    void menuIn();\n    void menuOut();\n    bool isMovieDemo();\n    void setDemoName(char*);\n    void processTime();\n    bool checkDayTime();\n    void setEventBit(void*);\n    void setCameraPolygonPos(Vec*);\n    void setCameraGroupInfo(u8);\n    void setCameraInWaterDepth(float);\n\n    void setHour(s32 hour) { mHour = hour; }\n    void setMinute(s32 min) { mMinute = min; }\n    void setWeekday(s32 day) { mWeekday = day; }\n\n    /* 0x00 */ u8 mHour;\n    /* 0x01 */ u8 mMinute;\n    /* 0x02 */ u8 mWeekday;\n    /* 0x03 */ u8 field_0x03;\n    /* 0x04 */ s16 mTime;\n    /* 0x08 */ void* mEventBit;\n    /* 0x0C */ bool mIsMenuIn;\n    /* 0x10 */ u32 mCameraMapInfo;\n    /* 0x14 */ u32 field_0x14;\n    /* 0x18 */ f32 mUnderwaterDepth;\n    /* 0x1C */ f32 mCameraInWaterDepthRatio;\n    /* 0x20 */ Vec mPolygonPosition;\n    /* 0x2C */ u8 mDemoStatus;\n    /* 0x2D */ u8 mHeartGaugeOn;\n};  // Size = 0x30\n\ninline Z2StatusMgr* Z2GetStatusMgr() {\n    return JASGlobalInstance<Z2StatusMgr>::getInstance();\n}\n\n#endif /* Z2STATUSMGR_H */\n/* end \"Z2AudioLib/Z2StatusMgr.h\" */\n/* \"include/Z2AudioLib/Z2AudioMgr.h\" line 14 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n/* \"include/Z2AudioLib/Z2AudioMgr.h\" line 15 \"global.h\" */\n/* end \"global.h\" */\n\nclass JKRArchive;\nclass JKRSolidHeap;\n\nclass Z2AudioMgr : public Z2SeMgr, public Z2SeqMgr, public Z2SceneMgr, public Z2StatusMgr, public Z2SoundObjMgr {\npublic:\n    Z2AudioMgr();\n    ~Z2AudioMgr() {}\n    void init(JKRSolidHeap*, u32, void*, JKRArchive*);\n    void setOutputMode(u32);\n    void zeldaGFrameWork();\n    void gframeProcess();\n    void resetProcess(u32, bool);\n    void resetRecover();\n    bool hasReset() const;\n\n    static Z2AudioMgr* getInterface() { return mAudioMgrPtr; }\n\n    static Z2AudioMgr* mAudioMgrPtr;\n\n    /* 0x0514 */ virtual int startSound(JAISoundID, JAISoundHandle*, JGeometry::TVec3<f32> const*);\n    /* 0x0518 */ bool mResettingFlag;\n    /* 0x0519 */ bool field_0x519;\n    /* 0x051C */ JASAudioReseter mAudioReseter;\n    /* 0x052C */ Z2SoundStarter mSoundStarter;\n    /* 0x0530 */ Z2SoundMgr mSoundMgr;\n    /* 0x0D40 */ Z2SoundInfo mSoundInfo;\n    /* 0x0D4C */ Z2Audience mAudience;\n    /* 0x0F2C */ Z2SpeechMgr2 mSpeechMgr;\n    /* 0x1370 */ Z2FxLineMgr mFxLineMgr;\n};  // Size: 0x138C\n\nSTATIC_ASSERT(sizeof(Z2AudioMgr) == 0x138C);\n\ninline Z2AudioMgr* Z2GetAudioMgr() {\n    return Z2AudioMgr::getInterface();\n}\n\n#endif /* Z2AUDIOMGR_H */\n/* end \"Z2AudioLib/Z2AudioMgr.h\" */\n/* \"include/m_Do/m_Do_audio.h\" line 4 \"Z2AudioLib/Z2EnvSeMgr.h\" */\n#ifndef Z2ENVSEMGR_H\n#define Z2ENVSEMGR_H\n\n/* \"include/Z2AudioLib/Z2EnvSeMgr.h\" line 3 \"Z2AudioLib/Z2Calc.h\" */\n#ifndef Z2CALC_H\n#define Z2CALC_H\n\n/* \"include/Z2AudioLib/Z2Calc.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nnamespace Z2Calc {\nenum CurveSign {\n    CURVE_SIGN_0 = 0,\n    CURVE_SIGN_1 = 1,\n};\n\nstruct FNoise1f {\n    FNoise1f(float param_0 = 0.1f, float param_1 = 0.0f, float param_2 = 0.01f) {\n        unk0 = param_0;\n        unk4 = param_0;\n        unk8 = param_2;\n        unk12 = param_1;\n    }\n    void setParam(float, float, float);\n    float tau(float);\n    float calcNoise1f();\n\n    float unk0;\n    float unk4;\n    float unk8;\n    float unk12;\n};\n\nfloat linearTransform(float, float, float, float, float, bool);\nfloat getParamByExp(float, float, float, float, float, float, Z2Calc::CurveSign);\nfloat getRandom(float, float, float);\nfloat getRandom_0_1(void);\n\nextern f32 cEqualCSlope;\nextern f32 cEqualPSlope;\n}  // namespace Z2Calc\n\n#endif /* Z2CALC_H */\n/* end \"Z2AudioLib/Z2Calc.h\" */\n/* \"include/Z2AudioLib/Z2EnvSeMgr.h\" line 4 \"Z2AudioLib/Z2SeMgr.h\" */\n/* end \"Z2AudioLib/Z2SeMgr.h\" */\n/* \"include/Z2AudioLib/Z2EnvSeMgr.h\" line 5 \"global.h\" */\n/* end \"global.h\" */\n\nstruct Z2EnvSeBase {\n    /* 802C589C */ Z2EnvSeBase(Vec* param_0 = NULL);\n    /* 802C58AC */ ~Z2EnvSeBase();\n    /* 802C5908 */ void startEnvSe(JAISoundID, f32, f32, f32, f32, f32, u32);\n    /* 802C5AB4 */ void startEnvSeLevel(JAISoundID, f32, f32, f32, f32, f32, u32);\n\n    /* 0x0 */ Vec* mPos;\n    /* 0x4 */ JAISoundHandle mHandle;\n};  // Size: 0x8\n\nstruct Z2EnvSeAutoPan : public Z2EnvSeBase {\n    /* 802C5ECC */ Z2EnvSeAutoPan();\n    /* 802C5F28 */ ~Z2EnvSeAutoPan();\n    /* 802C5F7C */ void setPanParam(f32, f32, bool, bool, f32, f32);\n    /* 802C5F98 */ void calcPan();\n    /* 802C60E0 */ void startEnvSeAutoPanLevel(JAISoundID, f32, f32, f32);\n\n    /* 0x08 */ f32 field_0x8;\n    /* 0x0C */ f32 field_0xc;\n    /* 0x10 */ f32 field_0x10;\n    /* 0x14 */ f32 field_0x14;\n    /* 0x18 */ bool field_0x18;\n    /* 0x19 */ bool field_0x19;\n};  // Size: 0x1C\n\nstruct Z2EnvSeDir : public Z2EnvSeBase {\n    /* 802C5C9C */ Z2EnvSeDir(Vec* param_0 = NULL);\n    /* 802C5D1C */ ~Z2EnvSeDir();\n    /* 802C5D70 */ void setPanDir(Vec*);\n    /* 802C5D9C */ void calcPan(f32);\n    /* 802C5E90 */ void startEnvSeDirLevel(JAISoundID, f32, f32);\n\n    /* 0x08 */ f32 field_0x8;\n    /* 0x0C */ f32 field_0xc;\n    /* 0x10 */ Vec mPanDir;\n};  // Size: 0x1C\n\nstruct Z2EnvSeMgr : public JASGlobalInstance<Z2EnvSeMgr> {\n    /* 802C611C */ Z2EnvSeMgr();\n    /* 802C6540 */ ~Z2EnvSeMgr();\n    /* 802C66B0 */ void framework();\n    /* 802C6998 */ void resetScene();\n    /* 802C699C */ void resetSceneInner();\n    /* 802C6AC0 */ void initSceneEnvSe(s32, s8, f32);\n    /* 802C6C1C */ void playSceneEnvSe();\n    /* 802C6C84 */ void initStaticEnvSe(u8, u8, u8, u8, Vec*);\n    /* 802C70C8 */ void startStaticEnvSe(s8);\n    /* 802C780C */ void registWindowPos(Vec*);\n    /* 802C7830 */ void startRainSe(s32, s8);\n    /* 802C7CF4 */ void startNearThunderSe(s8);\n    /* 802C7E68 */ void startFarThunderSe(Vec*, s8);\n    /* 802C7FB4 */ void setSnowPower(s8);\n    /* 802C7FBC */ void initStrongWindSe();\n    /* 802C7FC8 */ void setWindDirection(Vec*);\n    /* 802C800C */ void startStrongWindSe(s8);\n    /* 802C80F8 */ void initRiverSe(u8, u8, u8, u8);\n    /* 802C8234 */ void registRiverSePos(Vec*);\n    /* 802C8258 */ void setHyrulSewerOpen(bool);\n    /* 802C8300 */ void startRiverSe(s8);\n    /* 802C8730 */ void initFallSe(u8, u8, u8, u8);\n    /* 802C886C */ void registFallSePos(Vec*);\n    /* 802C8890 */ void startFallSe(s8);\n    /* 802C8A90 */ void initEtcSe(u8, u8, u8, u8);\n    /* 802C8C24 */ void registEtcSePos(Vec*);\n    /* 802C8C48 */ void startEtcSe(s8);\n    /* 802C92C8 */ void registWolfSmellSePos(Vec*);\n    /* 802C92EC */ void startFogWipeTrigger(Vec*);\n    /* 802C93A0 */ void setFogWipeWidth(f32);\n    /* 802C93E4 */ void getFogDensity();\n    /* 802C9400 */ void startFogSe();\n    /* 802C950C */ void initLv3WaterSe(u8, u8, u8, u8);\n    /* 802C9F58 */ void registLv3WaterSePos(u8, Vec*);\n    /* 802CA794 */ void startLv3WaterSe(s8);\n\n    void setWindType(u8 i_type) { mWindType = i_type; }\n    void registSmellSePos(Vec* param_0) { registEtcSePos(param_0); }\n    void startSmellSe(s8 param_0) { startEtcSe(param_0); }\n    void initSmellSe(u8 param_0, u8 param_1, u8 param_2, u8 param_3) {\n        initEtcSe(param_0, param_1, param_2, param_3);\n    }\n\n    /* 0x000 */ Z2EnvSeAutoPan field_0x0;\n    /* 0x01C */ Z2EnvSeAutoPan field_0x1c;\n    /* 0x038 */ u8 field_0x38;\n    /* 0x039 */ u8 field_0x39;\n    /* 0x03C */ f32 field_0x3c;\n    /* 0x040 */ f32 field_0x40;\n    /* 0x044 */ f32 field_0x44;\n    /* 0x048 */ f32 field_0x48;\n    /* 0x04C */ f32 field_0x4c;\n    /* 0x050 */ f32 field_0x50;\n    /* 0x054 */ f32 field_0x54;\n    /* 0x058 */ f32 field_0x58;\n    /* 0x05C */ f32 field_0x5c;\n    /* 0x060 */ f32 field_0x60;\n    /* 0x064 */ Z2MultiSeMgr field_0x64;\n    /* 0x080 */ Z2EnvSeBase field_0x80;\n    /* 0x088 */ Z2EnvSeBase field_0x88;\n    /* 0x090 */ Z2Calc::FNoise1f field_0x90;\n    /* 0x0A0 */ Z2Calc::FNoise1f field_0xa0;\n    /* 0x0B0 */ Z2Calc::FNoise1f field_0xb0;\n    /* 0x0C0 */ Z2Calc::FNoise1f field_0xc0;\n    /* 0x0D0 */ Z2Calc::FNoise1f field_0xd0;\n    /* 0x0E0 */ Z2Calc::FNoise1f field_0xe0;\n    /* 0x0F0 */ Z2Calc::FNoise1f field_0xf0;\n    /* 0x100 */ Z2Calc::FNoise1f field_0x100;\n    /* 0x110 */ Z2EnvSeBase field_0x110;\n    /* 0x118 */ Z2EnvSeBase field_0x118;\n    /* 0x120 */ Z2Calc::FNoise1f field_0x120;\n    /* 0x130 */ Z2Calc::FNoise1f field_0x130;\n    /* 0x140 */ u8 field_0x140;\n    /* 0x141 */ u8 mSnowPower;\n    /* 0x144 */ Z2EnvSeDir field_0x144;\n    /* 0x160 */ u8 mWindType;\n    /* 0x164 */ Z2MultiSeMgr field_0x164;\n    /* 0x180 */ Z2EnvSeBase field_0x180;\n    /* 0x188 */ u8 field_0x188;\n    /* 0x18C */ Z2Calc::FNoise1f field_0x18c;\n    /* 0x19C */ Z2Calc::FNoise1f field_0x19c;\n    /* 0x1AC */ f32 field_0x1ac;\n    /* 0x1B0 */ f32 field_0x1b0;\n    /* 0x1B4 */ f32 field_0x1b4;\n    /* 0x1B8 */ u8 field_0x1b8;\n    /* 0x1BC */ Z2MultiSeMgr field_0x1bc;\n    /* 0x1D8 */ Z2EnvSeBase field_0x1d8;\n    /* 0x1E0 */ u8 field_0x1e0;\n    /* 0x1E4 */ f32 field_0x1e4;\n    /* 0x1E8 */ f32 field_0x1e8;\n    /* 0x1EC */ f32 field_0x1ec;\n    /* 0x1F0 */ Z2MultiSeMgr field_0x1f0;\n    /* 0x20C */ Z2EnvSeBase field_0x20c;\n    /* 0x214 */ u8 field_0x214;\n    /* 0x218 */ f32 field_0x218;\n    /* 0x21C */ f32 field_0x21c;\n    /* 0x220 */ f32 field_0x220;\n    /* 0x224 */ Z2MultiSeMgr field_0x224;\n    /* 0x240 */ Z2EnvSeBase field_0x240;\n    /* 0x248 */ u8 field_0x248;\n    /* 0x24C */ f32 field_0x24c;\n    /* 0x250 */ f32 field_0x250;\n    /* 0x254 */ f32 field_0x254;\n    /* 0x258 */ Z2MultiSeMgr field_0x258;\n    /* 0x274 */ Z2EnvSeBase field_0x274;\n    /* 0x27C */ u8 field_0x27c;\n    /* 0x280 */ f32 field_0x280;\n    /* 0x284 */ f32 field_0x284;\n    /* 0x288 */ f32 field_0x288;\n    /* 0x28C */ Z2MultiSeMgr field_0x28c;\n    /* 0x2A8 */ Z2EnvSeBase field_0x2a8;\n    /* 0x2B0 */ u8 field_0x2b0;\n    /* 0x2B4 */ f32 field_0x2b4;\n    /* 0x2B8 */ f32 field_0x2b8;\n    /* 0x2BC */ f32 field_0x2bc;\n    /* 0x2C0 */ Z2MultiSeMgr field_0x2c0;\n    /* 0x2DC */ Z2EnvSeBase field_0x2dc;\n    /* 0x2E4 */ u8 field_0x2e4;\n    /* 0x2E8 */ Z2Calc::FNoise1f field_0x2e8;\n    /* 0x2F8 */ Z2Calc::FNoise1f field_0x2f8;\n    /* 0x308 */ f32 mFogDensity;\n};  // Size: 0x30C\n\nSTATIC_ASSERT(sizeof(Z2EnvSeMgr) == 0x30C);\n\nextern Z2EnvSeMgr g_mEnvSeMgr;\n\n#endif /* Z2ENVSEMGR_H */\n/* end \"Z2AudioLib/Z2EnvSeMgr.h\" */\n\nclass mDoAud_zelAudio_c : public Z2AudioMgr {\npublic:\n    void reset();\n    mDoAud_zelAudio_c() {}\n    ~mDoAud_zelAudio_c() {}\n\n    static void onInitFlag() { mInitFlag = true; }\n    static bool isInitFlag() { return mInitFlag; }\n    static bool isResetFlag() { return mResetFlag; }\n    static void onResetFlag() { mResetFlag = true; }\n    static void offResetFlag() { mResetFlag = false; }\n    static bool isBgmSet() { return mBgmSet; }\n    static void onBgmSet() { mBgmSet = true; }\n    static void offBgmSet() { mBgmSet = false; }\n\n    static bool mInitFlag;\n    static bool mResetFlag;\n    static bool mBgmSet;\n};\n\nextern JKRSolidHeap* g_mDoAud_audioHeap;\n\nvoid mDoAud_Execute();\nvoid mDoAud_resetProcess();\nbool mDoAud_resetRecover();\nvoid mDoAud_setSceneName(char const* spot, s32 room, s32 layer);\ns32 mDoAud_load1stDynamicWave();\nstatic void mDoAud_setLinkGroupInfo(u8 param_0);\nstatic void mDoAud_setLinkHp(s32 param_0, s32 param_1);\nstatic void mDoAud_seStartLevel(u32 param_0, Vec const* param_1, u32 param_2, s8 param_3);\n\ninline void mDoAud_bgmSetSwordUsing(s32 id) {\n    Z2AudioMgr::getInterface()->bgmSetSwordUsing(id);\n}\n\ninline void mDoAud_bgmStart(u32 i_bgmID) {\n    Z2AudioMgr::getInterface()->bgmStart(i_bgmID, 0, 0);\n}\n\ninline void mDoAud_subBgmStart(u32 i_bgmID) {\n    Z2AudioMgr::getInterface()->subBgmStart(i_bgmID);\n}\n\ninline void mDoAud_bgmNowBattle(f32 param_0) {\n    Z2AudioMgr::getInterface()->bgmNowBattle(param_0);\n}\n\ninline void mDoAud_bgmStreamPrepare(u32 param_0) {\n    Z2AudioMgr::getInterface()->bgmStreamPrepare(param_0);\n}\n\ninline void mDoAud_bgmStreamPlay() {\n    Z2AudioMgr::getInterface()->bgmStreamPlay();\n}\n\ninline void mDoAud_setHour(s32 hour) {\n    Z2AudioMgr::getInterface()->setHour(hour);\n}\n\ninline void mDoAud_setMinute(s32 min) {\n    Z2AudioMgr::getInterface()->setMinute(min);\n}\n\ninline void mDoAud_setWeekday(s32 day) {\n    Z2AudioMgr::getInterface()->setWeekday(day);\n}\n\ninline void mDoAud_setInDarkness(bool state) {\n    Z2AudioMgr::getInterface()->setInDarkness(state);\n}\n\ninline void mDoAud_seStart(u32 i_sfxID, const Vec* i_sePos, u32 param_2, s8 i_reverb) {\n    Z2AudioMgr::getInterface()->seStart(i_sfxID, i_sePos, param_2, i_reverb, 1.0f, 1.0f,\n                                               -1.0f, -1.0f, 0);\n}\n\ninline void i_mDoAud_seStartLevel(u32 i_sfxID, const Vec* i_sePos, u32 param_2, s8 i_reverb) {\n    Z2AudioMgr::getInterface()->seStartLevel(i_sfxID, i_sePos, param_2, i_reverb, 1.0f, 1.0f,\n                                                    -1.0f, -1.0f, 0);\n}\n\ninline void mDoAud_messageSePlay(u16 param_0, Vec* position, s8 param_2) {\n    Z2AudioMgr::getInterface()->messageSePlay(param_0, position, param_2);\n}\n\ninline void mDoAud_sceneBgmStart() {\n    Z2AudioMgr::getInterface()->sceneBgmStart();\n}\n\ninline void mDoAud_load2ndDynamicWave() {\n    Z2AudioMgr::getInterface()->load2ndDynamicWave();\n}\n\ninline bool mDoAud_check1stDynamicWave() {\n    return Z2AudioMgr::getInterface()->check1stDynamicWave();\n}\n\ninline void mDoAud_bgmStop(u32 param_0) {\n    Z2AudioMgr::getInterface()->bgmStop(param_0, 0);\n}\n\ninline void mDoAud_rainPlay(s32 enable) {\n    g_mEnvSeMgr.startRainSe(enable, 0);\n}\n\ninline void mDoAud_heartGaugeOn() {\n    Z2AudioMgr::getInterface()->heartGaugeOn();\n}\n\ninline void mDoAud_setSnowPower(s8 i_power) {\n    g_mEnvSeMgr.setSnowPower(i_power);\n}\n\ninline void mDoAud_setFogWipeWidth(f32 i_width) {\n    g_mEnvSeMgr.setFogWipeWidth(i_width);\n}\n\ninline void mDoAud_startFogWipeTrigger(const Vec* param_0) {\n    g_mEnvSeMgr.startFogWipeTrigger((Vec*)param_0);\n}\n\ninline void mDoAud_changeSubBgmStatus(s32 param_0) {\n    Z2AudioMgr::getInterface()->changeSubBgmStatus(param_0);\n}\n\ninline void mDoAud_taktModeMute() {\n    Z2AudioMgr::getInterface()->taktModeMute();\n}\n\ninline void mDoAud_taktModeMuteOff() {\n    Z2AudioMgr::getInterface()->taktModeMuteOff();\n}\n\ninline void mDoAud_mEnvse_framework() {\n    g_mEnvSeMgr.framework();\n}\n\ninline void mDoAud_mEnvse_resetScene() {\n    g_mEnvSeMgr.resetScene();\n}\n\ninline void mDoAud_mEnvSe_startFarThunderSe(const Vec* param_0) {\n    g_mEnvSeMgr.startFarThunderSe((Vec*)param_0, 0);\n}\n\ninline void mDoAud_mEnvse_initStrongWind() {\n    g_mEnvSeMgr.initStrongWindSe();\n}\n\ninline void mDoAud_mEnvse_setWindDirection(Vec* i_direction) {\n    g_mEnvSeMgr.setWindDirection(i_direction);\n}\n\ninline void mDoAud_mEnvse_startStrongWindSe(s8 i_reverb) {\n    g_mEnvSeMgr.startStrongWindSe(i_reverb);\n}\n\ninline void mDoAud_mEnvse_setWindType(u8 i_type) {\n    g_mEnvSeMgr.setWindType(i_type);\n}\n\ninline void mDoAud_mEnvse_initStaticEnvSe(u8 param_0, u8 param_1, u8 param_2, u8 param_3, const Vec* param_4) {\n    g_mEnvSeMgr.initStaticEnvSe(param_0, param_1, param_2, param_3, (Vec*)param_4);\n}\n\ninline void mDoAud_mEnvse_startStaticEnvSe(s8 i_reverb) {\n    g_mEnvSeMgr.startStaticEnvSe(i_reverb);\n}\n\ninline void mDoAud_mEnvse_initRiverSe(u8 param_0, u8 param_1, u8 param_2, u8 param_3) {\n    g_mEnvSeMgr.initRiverSe(param_0, param_1, param_2, param_3);\n}\n\ninline void mDoAud_mEnvse_registRiverSePos(const Vec* i_pos) {\n    g_mEnvSeMgr.registRiverSePos((Vec*)i_pos);\n}\n\ninline void mDoAud_mEnvse_startRiverSe(s8 i_reverb) {\n    g_mEnvSeMgr.startRiverSe(i_reverb);\n}\n\ninline void mDoAud_mEnvse_initFallSe(u8 param_0, u8 param_1, u8 param_2, u8 param_3) {\n    g_mEnvSeMgr.initFallSe(param_0, param_1, param_2, param_3);\n}\n\ninline void mDoAud_mEnvse_registFallSePos(const Vec* i_pos) {\n    g_mEnvSeMgr.registFallSePos((Vec*)i_pos);\n}\n\ninline void mDoAud_mEnvse_startFallSe(s8 i_reverb) {\n    g_mEnvSeMgr.startFallSe(i_reverb);\n}\n\ninline void mDoAud_mEnvse_initSmellSe(u8 param_0, u8 param_1, u8 param_2, u8 param_3) {\n    g_mEnvSeMgr.initSmellSe(param_0, param_1, param_2, param_3);\n}\n\ninline void mDoAud_mEnvse_registSmellSePos(const Vec* i_pos) {\n    g_mEnvSeMgr.registSmellSePos((Vec*)i_pos);\n}\n\ninline void mDoAud_mEnvse_startSmellSe(s8 i_reverb) {\n    g_mEnvSeMgr.startSmellSe(i_reverb);\n}\n\ninline void mDoAud_mEnvse_registWindowPos(const Vec* i_pos) {\n    g_mEnvSeMgr.registWindowPos((Vec*)i_pos);\n}\n\ninline void mDoAud_initLv3WaterSe(u8 param_0, u8 param_1, u8 param_2, u8 param_3) {\n    g_mEnvSeMgr.initLv3WaterSe(param_0, param_1, param_2, param_3);\n}\n\ninline void mDoAud_registLv3WaterSePos(u8 param_0, const Vec* i_pos) {\n    g_mEnvSeMgr.registLv3WaterSePos(param_0, (Vec*)i_pos);\n}\n\ninline void mDoAud_startLv3WaterSe(s8 i_reverb) {\n    g_mEnvSeMgr.startLv3WaterSe(i_reverb);\n}\n\n#endif /* M_DO_M_DO_AUDIO_H */\n/* end \"m_Do/m_Do_audio.h\" */\n/* \"include/m_Do/m_Do_ext.h\" line 8 \"m_Do/m_Do_mtx.h\" */\n#ifndef M_DO_M_DO_MTX_H\n#define M_DO_M_DO_MTX_H\n\n/* \"include/m_Do/m_Do_mtx.h\" line 3 \"SSystem/SComponent/c_sxyz.h\" */\n#ifndef C_SXYZ_H\n#define C_SXYZ_H\n\n/* \"include/SSystem/SComponent/c_sxyz.h\" line 3 \"dolphin/mtx/vec.h\" */\n/* end \"dolphin/mtx/vec.h\" */\n\nclass csXyz : public SVec {\npublic:\n    static const csXyz Zero;\n    /* 80018BD0 */ ~csXyz() {};\n    /* inline   */ csXyz() {}\n    /* inline   */ csXyz(const csXyz& other) : SVec(other){};\n    /* 802673F4 */ csXyz(s16, s16, s16);\n    /* 80267404 */ csXyz operator+(csXyz&);\n    /* 8026745C */ void operator+=(csXyz&);\n    /* 80267490 */ csXyz operator-(csXyz&);\n    /* 802674E8 */ csXyz operator*(f32);\n    s16 GetX() const { return x; }\n    s16 GetY() const { return y; }\n    s16 GetZ() const { return z; }\n\n    void set(s16 oX, s16 oY, s16 oZ) {\n        x = oX;\n        y = oY;\n        z = oZ;\n    }\n\n    void setall(s16 val) {\n        x = val;\n        y = val;\n        z = val;\n    }\n};\n\n#endif /* C_SXYZ_H */\n/* end \"SSystem/SComponent/c_sxyz.h\" */\n/* \"include/m_Do/m_Do_mtx.h\" line 4 \"SSystem/SComponent/c_xyz.h\" */\n/* end \"SSystem/SComponent/c_xyz.h\" */\n/* \"include/m_Do/m_Do_mtx.h\" line 5 \"dolphin/mtx/mtxvec.h\" */\n/* end \"dolphin/mtx/mtxvec.h\" */\n/* \"include/m_Do/m_Do_mtx.h\" line 6 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nvoid mDoMtx_XYZrotS(Mtx, s16, s16, s16);\nvoid mDoMtx_XYZrotM(Mtx, s16, s16, s16);\nvoid mDoMtx_ZXYrotS(Mtx, s16, s16, s16);\nvoid mDoMtx_ZXYrotM(Mtx, s16, s16, s16);\nvoid mDoMtx_ZrotS(Mtx, s16);\nvoid mDoMtx_YrotS(Mtx, s16);\nvoid mDoMtx_XrotS(Mtx, s16);\nvoid mDoMtx_XrotM(Mtx, s16);\nvoid mDoMtx_YrotM(Mtx, s16);\nvoid mDoMtx_ZrotM(Mtx, s16);\nvoid mDoMtx_MtxToRot(CMtxP, csXyz*);\nvoid mDoMtx_lookAt(Mtx param_0, Vec const* param_1, Vec const* param_2, s16 param_3);\nvoid mDoMtx_lookAt(Mtx param_0, Vec const* param_1, Vec const* param_2, Vec const* param_3,\n                   s16 param_4);\nvoid mDoMtx_concatProjView(f32 const (*param_0)[4], f32 const (*param_1)[4], f32 (*param_2)[4]);\nvoid mDoMtx_ZrotM(Mtx mtx, s16 z);\nbool mDoMtx_inverseTranspose(f32 const (*param_0)[4], f32 (*param_1)[4]);\nvoid mDoMtx_QuatConcat(Quaternion const* param_0, Quaternion const* param_1, Quaternion* param_2);\n\ninline void mDoMtx_multVecSR(Mtx m, const Vec* src, Vec* dst) {\n    MTXMultVecSR(m, src, dst);\n}\n\ninline void cMtx_concat(const Mtx a, const Mtx b, Mtx ab) {\n    MTXConcat(a, b, ab);\n}\n\ninline void cMtx_scale(Mtx m, f32 x, f32 y, f32 z) {\n    MTXScale(m, x, y, z);\n}\n\ninline void mDoMtx_multVec(Mtx m, const Vec* src, Vec* dst) {\n    MTXMultVec(m, src, dst);\n}\n\ninline void mDoMtx_multVecArray(Mtx m, const Vec* src, Vec* dst, u32 count) {\n    MTXMultVecArray(m, src, dst, count);\n}\n\ninline void mDoMtx_copy(const Mtx src, Mtx dst) {\n    MTXCopy(src, dst);\n}\n\ninline void mDoMtx_trans(Mtx m, f32 x, f32 y, f32 z) {\n    MTXTrans(m, x, y, z);\n}\n\ninline void cMtx_XrotM(Mtx mtx, s16 x) {\n    mDoMtx_XrotM(mtx, x);\n}\n\ninline void cMtx_YrotM(Mtx mtx, s16 y) {\n    mDoMtx_YrotM(mtx, y);\n}\n\ninline void cMtx_ZrotM(Mtx mtx, s16 z) {\n    mDoMtx_ZrotM(mtx, z);\n}\n\ninline void cMtx_XrotS(Mtx mtx, s16 x) {\n    mDoMtx_XrotS(mtx, x);\n}\n\ninline void cMtx_YrotS(Mtx mtx, s16 y) {\n    mDoMtx_YrotS(mtx, y);\n}\n\ninline void cMtx_ZrotS(Mtx mtx, s16 z) {\n    mDoMtx_ZrotS(mtx, z);\n}\n\ninline void cMtx_lookAt(Mtx param_0, const Vec* param_1, const Vec* param_2, s16 param_3) {\n    mDoMtx_lookAt(param_0, param_1, param_2, param_3);\n}\n\ninline void cMtx_multVec(Mtx mtx, const Vec* src, Vec* dst) {\n    mDoMtx_multVec(mtx, src, dst);\n}\n\ninline void cMtx_lookAt(Mtx param_0, const Vec* param_1, const Vec* param_2, const Vec* param_3, s16 param_4) {\n    mDoMtx_lookAt(param_0,param_1,param_2,param_3,param_4);\n}\n\ninline void cMtx_copy(const Mtx src, Mtx dst) {\n    mDoMtx_copy(src, dst);\n}\n\ninline void cMtx_multVecArray(Mtx mtx, const Vec* src, Vec* dst, u32 count) {\n    mDoMtx_multVecArray(mtx, src, dst, count);\n}\n\ninline void mDoMtx_multVecZero(MtxP param_0, Vec* param_1) {\n    param_1->x = param_0[0][3];\n    param_1->y = param_0[1][3];\n    param_1->z = param_0[2][3];\n}\n\ninline void mDoMtx_quatMultiply(const Quaternion* a, const Quaternion* b, Quaternion* ab) {\n    QUATMultiply(a,b,ab);\n}\n\ninline void mDoMtx_quatSlerp(const Quaternion* a, const Quaternion* b, Quaternion* ab, f32 param_4) {\n    C_QUATSlerp(a,b,ab,param_4);\n}\n\ninline void mDoMtx_identity(Mtx m) {\n    MTXIdentity(m);\n}\n\ninline void mDoMtx_concat(const Mtx a, const Mtx b, Mtx c) {\n    MTXConcat(a, b, c);\n}\n\ninline void mDoMtx_inverse(const Mtx a, Mtx b) {\n    MTXInverse(a, b);\n}\n\ninline void mDoMtx_scale(Mtx m, f32 x, f32 y, f32 z) {\n    MTXScale(m, x, y, z);\n}\n\ninline void mDoMtx_quat(Mtx m, const Quaternion* q) {\n    MTXQuat(m, q);\n}\n\ninline void cMtx_inverse(const Mtx a, Mtx b) {\n    mDoMtx_inverse(a, b);\n}\n\nclass mDoMtx_stack_c {\npublic:\n    mDoMtx_stack_c() {\n        next = buffer;\n        end = buffer + 16;\n    }\n\n    /* 8000CCC8 */ static bool push();\n    /* 8000CD14 */ static bool pop();\n\n    /**\n     * Translates the `now` Matrix by the given cXyz\n     * @param xyz The xyz translation vector\n     */\n    /* 8000CD64 */ static void transS(cXyz const& xyz);\n\n    /**\n     * Translates a new Matrix by the given cXyz and then concatenates it with the `now` matrix\n     * @param xyz The xyz translation vector\n     */\n    /* 8000CDD4 */ static void transM(cXyz const& xyz);\n\n    /**\n     * Translates a new Matrix by the given X, Y, and Z values and then concatenates it with the `now` matrix\n     * @param x The x-axis translation value\n     * @param y The y-axis translation value\n     * @param z The z-axis translation value\n     */\n    /* 8000CD9C */ static void transM(f32 x, f32 y, f32 z);\n\n    /**\n     * Scales the `now` Matrix by the given cXyz\n     * @param xyz The xyz scale vector\n     */\n    /* 8000CE00 */ static void scaleS(cXyz const& xyz);\n\n    /**\n     * Scales a new Matrix by the given cXyz and then concatenates it with the `now` matrix\n     * @param xyz The xyz scale vector\n     */\n    /* 8000CE70 */ static void scaleM(cXyz const& xyz);\n\n    /**\n     * Scales a new Matrix by the given X, Y, and Z values and then concatenates it with the `now` matrix\n     * @param x The x-axis scale value\n     * @param y The y-axis scale value\n     * @param z The z-axis scale value\n     */\n    /* 8000CE38 */ static void scaleM(f32 x, f32 y, f32 z);\n\n    /* 8000CE9C */ static void XYZrotS(csXyz const& xyz);\n\n    /**\n     * Rotates the `now` matrix by the given csXyz in the order Z, Y, X\n     * @param xyz The xyz rotation vector\n     */\n    /* 8000CED4 */ static void XYZrotM(csXyz const& xyz);\n\n    /* 8000CF0C */ static void ZXYrotS(csXyz const& xyz);\n\n    /**\n     * Rotates the `now` matrix by the given csXyz in the order X, Y, Z\n     * @param xyz The xyz rotation vector\n     */\n    /* 8000CF44 */ static void ZXYrotM(csXyz const& xyz);\n\n    /* 8000CF7C */ static void quatM(Quaternion const*);\n    /* 8000D070 */ ~mDoMtx_stack_c() {}  // inline\n\n    /**\n     * Returns the `now` Matrix\n     * @return The `now` Matrix\n     */\n    static MtxP get() { return now; }\n\n    /**\n     * Translates the `now` Matrix by the given X, Y, and Z values\n     * @param x The x-axis translation value\n     * @param y The y-axis translation value\n     * @param z The z-axis translation value\n     */\n    static void transS(f32 x, f32 y, f32 z) { MTXTrans(now, x, y, z); }\n\n    /**\n     * Scales the `now` Matrix by the given X, Y, and Z values\n     * @param x The x-axis scale value\n     * @param y The y-axis scale value\n     * @param z The z-axis scale value\n     */\n    static void scaleS(f32 x, f32 y, f32 z) { MTXScale(now, x, y, z); }\n\n    /**\n     * Multiplies a given Vec `a` by the `now` Matrix and places the result into Vec `b`\n     * @param a The source Vec\n     * @param b The output Vec\n     */\n    static void multVec(const Vec* a, Vec* b) { MTXMultVec(now, a, b); }\n\n    /**\n     * Multiplies a given Vec `a` by the `now` Matrix's \"Scale-and-Rotate\" component and places the result into Vec `b`\n     * @param a The source Vec\n     * @param b The output Vec\n     */\n    static void multVecSR(const Vec* a, Vec* b) { MTXMultVecSR(now, a, b); }\n\n    static void multVecZero(Vec* v) { mDoMtx_multVecZero(now, v); }\n\n    /**\n     * Multiplies a given Vec array `src` by the `now` Matrix and places the result into Vec array `dst`\n     * @param src The source Vec array\n     * @param dst The output Vec array\n     * @param count The size of the array\n     */\n    static void multVecArray(const Vec* src, Vec* dst, u32 count) {\n        MTXMultVecArray(now, src, dst, count);\n    }\n\n    static void XYZrotS(s16 x, s16 y, s16 z) { mDoMtx_XYZrotS(now, x, y, z); }\n\n    /**\n     * Rotates the `now` matrix by the given X, Y, and Z values in the order Z, Y, X\n     * @param x The x-axis rotation value\n     * @param y The y-axis rotation value\n     * @param z The z-axis rotation value\n     */\n    static void XYZrotM(s16 x, s16 y, s16 z) { mDoMtx_XYZrotM(now, x, y, z); }\n\n    static void ZXYrotS(s16 x, s16 y, s16 z) { mDoMtx_ZXYrotS(now, x, y, z); }\n\n    /**\n     * Rotates the `now` matrix by the given X, Y, and Z values in the order X, Y, Z\n     * @param x The x-axis rotation value\n     * @param y The y-axis rotation value\n     * @param z The z-axis rotation value\n     */\n    static void ZXYrotM(s16 x, s16 y, s16 z) { mDoMtx_ZXYrotM(now, x, y, z); }\n\n    /**\n     * Rotates a new matrix on the Y-axis then concatenates it with the `now` matrix\n     * @param y The rotation value\n     */\n    static void YrotM(s16 y) { mDoMtx_YrotM(now, y); }\n\n    /**\n     * Rotates the `now` matrix on the Y-axis\n     * @param y The rotation value\n     */\n    static void YrotS(s16 y) { mDoMtx_YrotS(now, y); }\n\n    /**\n     * Rotates the `now` matrix on the X-axis\n     * @param x The rotation value\n     */\n    static void XrotS(s16 x) { mDoMtx_XrotS(now, x); }\n\n    /**\n     * Rotates a new matrix on the X-axis then concatenates it with the `now` matrix\n     * @param x The rotation value\n     */\n    static void XrotM(s16 x) { mDoMtx_XrotM(now, x); }\n\n    /**\n     * Rotates the `now` matrix on the Z-axis\n     * @param z The rotation value\n     */\n    static void ZrotS(s16 z) { mDoMtx_ZrotS(now, z); }\n\n    /**\n     * Rotates a new matrix on the z-axis then concatenates it with the `now` matrix\n     * @param z The rotation value\n     */\n    static void ZrotM(s16 z) { mDoMtx_ZrotM(now, z); }\n\n    static void inverse() { MTXInverse(now, now); }\n\n    static void inverseTranspose() { mDoMtx_inverseTranspose(now, now); }\n\n    /**\n     * Concatenates the `now` matrix with the given Matrix `m`\n     * @param m The matrix to concatenate with `now`\n     */\n    static void concat(const Mtx m) { MTXConcat(now, m, now); }\n\n    static void revConcat(const Mtx m) { MTXConcat(m, now, now); }\n\n    /**\n     * Copies a given matrix `m` to the `now` matrix\n     * @param m The source matrix to copy\n     */\n    static void copy(const Mtx m) { MTXCopy(m, now); }\n\n    static void rotAxisRadS(const Vec* axis, f32 rad) {\n        MTXRotAxisRad(now, axis, rad);\n    }\n\n    static Mtx now;\n    static Mtx buffer[16];\n    static Mtx* next;\n    static Mtx* end;\n};\n\nextern Mtx g_mDoMtx_identity;\n\ninline MtxP mDoMtx_getIdentity() {\n    return g_mDoMtx_identity;\n}\n\nclass mDoMtx_quatStack_c {\npublic:\n    mDoMtx_quatStack_c() {\n        field_0x0 = &field_0x4;\n        field_0x114 = field_0x14;\n        field_0x118 = &field_0x114;\n    }\n    ~mDoMtx_quatStack_c() {}  // inline\n\n    /* 0x000 */ Quaternion* field_0x0;\n    /* 0x004 */ Quaternion field_0x4;\n    /* 0x014 */ Quaternion field_0x14[16];\n    /* 0x114 */ Quaternion* field_0x114;\n    /* 0x118 */ Quaternion** field_0x118;\n};  // Size: 0x11C\n\n#endif /* M_DO_M_DO_MTX_H */\n/* end \"m_Do/m_Do_mtx.h\" */\n\nclass JKRArchive;\nclass JKRAssertHeap;\nclass JKRExpHeap;\nclass JKRHeap;\nclass JKRSolidHeap;\nstruct ResTIMG;\nclass Z2Creature;\n\nclass mDoExt_baseAnm {\npublic:\n    mDoExt_baseAnm() {}\n    /* 8000D320 */ int initPlay(s16 i_frameMax, int i_attribute, f32 i_rate, s16 i_startF,\n                                s16 i_endF);\n    /* 8000D428 */ int play();\n\n    J3DFrameCtrl* getFrameCtrl() { return &mFrameCtrl; }\n    f32 getPlaySpeed() { return mFrameCtrl.getRate(); }\n    void setPlaySpeed(f32 speed) { mFrameCtrl.setRate(speed); }\n    f32 getFrame() { return mFrameCtrl.getFrame(); }\n    f32 getEndFrame() { return mFrameCtrl.getEnd(); }\n    void setFrame(f32 frame) { mFrameCtrl.setFrame(frame); }\n    void setPlayMode(int i_mode) { mFrameCtrl.setAttribute(i_mode); }\n    void setLoopFrame(f32 i_frame) { mFrameCtrl.setLoop(i_frame); }\n    bool isStop() {\n        bool stopped = true;\n        if (!mFrameCtrl.checkState(1) && mFrameCtrl.getRate() != 0.0f) {\n            stopped = false;\n        }\n        return stopped;\n    }\n    void reset() { mFrameCtrl.reset(); }\n\nprivate:\n    /* 0x0 */ J3DFrameCtrl mFrameCtrl;\n};  // Size: 0x14\n\nclass mDoExt_transAnmBas : public J3DAnmTransformKey {\npublic:\n    mDoExt_transAnmBas(void* bas) { mBas = bas; }\n    virtual ~mDoExt_transAnmBas();\n\n    void* getBas() { return mBas; }\n\nprivate:\n    /* 0x28 */ void* mBas;\n};\n\nclass mDoExt_btkAnm : public mDoExt_baseAnm {\npublic:\n    mDoExt_btkAnm() { mpAnm = 0; }\n    /* 8000D63C */ int init(J3DMaterialTable* i_matTable, J3DAnmTextureSRTKey* i_btk, int i_anmPlay,\n                            int i_attribute, f32 i_rate, s16 i_start, s16 param_6);\n    /* 8000D6D8 */ void entry(J3DMaterialTable* i_matTable, f32 i_frame);\n\n    void entry(J3DModelData* i_modelData) { entry(i_modelData, getFrame()); }\n    void entry(J3DModelData* i_modelData, f32 i_frame) {\n        entry(&i_modelData->getMaterialTable(), i_frame);\n    }\n    int init(J3DModelData* i_modelData, J3DAnmTextureSRTKey* i_btk, int i_anmPlay, int i_attribute,\n             f32 i_rate, s16 i_start, s16 param_6) {\n        return init(&i_modelData->getMaterialTable(), i_btk, i_anmPlay, i_attribute, i_rate,\n                    i_start, param_6);\n    }\n\n    int remove(J3DModelData* i_modelData) { return i_modelData->removeTexMtxAnimator(mpAnm); }\n    void entryFrame() { entryFrame(getFrame()); }\n    void entryFrame(f32 frame) { mpAnm->setFrame(frame); }\n\n    J3DAnmTextureSRTKey* getBtkAnm() const { return mpAnm; }\n\nprivate:\n    /* 0x14 */ J3DAnmTextureSRTKey* mpAnm;\n};  // Size: 0x18\n\nSTATIC_ASSERT(sizeof(mDoExt_btkAnm) == 0x18);\n\nclass mDoExt_brkAnm : public mDoExt_baseAnm {\npublic:\n    mDoExt_brkAnm() { mpAnm = 0; }\n    /* 8000D70C */ int init(J3DMaterialTable* i_matTable, J3DAnmTevRegKey* i_brk, int i_anmPlay,\n                            int i_attribute, f32 i_rate, s16 i_start, s16 param_6);\n    /* 8000D7A8 */ void entry(J3DMaterialTable* i_matTable, f32 i_frame);\n\n    void entry(J3DModelData* i_modelData) { entry(i_modelData, getFrame()); }\n    void entry(J3DModelData* i_modelData, f32 i_frame) {\n        entry(&i_modelData->getMaterialTable(), i_frame);\n    }\n\n    int init(J3DModelData* i_modelData, J3DAnmTevRegKey* i_brk, int i_anmPlay, int i_attribute,\n             f32 i_rate, s16 i_start, s16 param_6) {\n        return init(&i_modelData->getMaterialTable(), i_brk, i_anmPlay, i_attribute, i_rate,\n                    i_start, param_6);\n    }\n\n    int remove(J3DModelData* i_modelData) { return i_modelData->removeTevRegAnimator(mpAnm); }\n    void entryFrame() { entryFrame(getFrame()); }\n    void entryFrame(f32 frame) { mpAnm->setFrame(frame); }\n\n    J3DAnmTevRegKey* getBrkAnm() const { return mpAnm; }\n\nprivate:\n    /* 0x14 */ J3DAnmTevRegKey* mpAnm;\n};  // Size: 0x18\n\nSTATIC_ASSERT(sizeof(mDoExt_brkAnm) == 0x18);\n\nclass mDoExt_bpkAnm : public mDoExt_baseAnm {\npublic:\n    mDoExt_bpkAnm() { mpAnm = 0; }\n    /* 8000D47C */ int init(J3DMaterialTable* i_matTable, J3DAnmColor* i_bpk, int i_anmPlay,\n                            int i_attribute, f32 i_rate, s16 i_start, s16 param_6);\n    /* 8000D518 */ void entry(J3DMaterialTable* i_matTable, f32 i_frame);\n\n    void entry(J3DModelData* i_modelData) { entry(i_modelData, getFrame()); }\n    void entry(J3DModelData* i_modelData, f32 i_frame) {\n        entry(&i_modelData->getMaterialTable(), i_frame);\n    }\n\n    int init(J3DModelData* i_modelData, J3DAnmColor* i_bpk, int i_anmPlay, int i_attribute,\n             f32 i_rate, s16 i_start, s16 param_6) {\n        return init(&i_modelData->getMaterialTable(), i_bpk, i_anmPlay, i_attribute, i_rate,\n                    i_start, param_6);\n    }\n\n    int remove(J3DModelData* i_modelData) { return i_modelData->removeMatColorAnimator(mpAnm); }\n\nprivate:\n    /* 0x14 */ J3DAnmColor* mpAnm;\n};  // Size: 0x18\n\nSTATIC_ASSERT(sizeof(mDoExt_bpkAnm) == 0x18);\n\nclass mDoExt_bckAnm : public mDoExt_baseAnm {\npublic:\n    mDoExt_bckAnm() { mpMtxCalc = NULL; }\n    /* 8000D7DC */ int init(J3DAnmTransform* i_bck, int i_play, int i_attr, f32 i_rate,\n                            s16 i_startF, s16 i_endF, bool i_modify);\n    /* 8000D990 */ void changeBckOnly(J3DAnmTransform* i_bck);\n    /* 8000D9CC */ void entry(J3DModelData* i_modelData, f32 i_frame);\n    /* 8000D9E8 */ void entryJoint(J3DModelData* i_modelData, u16 i_jntNo, f32 i_frame);\n\n    void entry(J3DModelData* i_modelData) { entry(i_modelData, getFrame()); }\n\n    void remove(J3DModelData* i_modelData) { i_modelData->getJointNodePointer(0)->setMtxCalc(NULL); }\n\n    J3DAnmTransform* getBckAnm() { return mAnm; }\n\n    void removeJoint(J3DModelData* i_modelData, u16 i_idx) {\n        J3DJoint* mpJnt = i_modelData->getJointNodePointer(i_idx);\n        mpJnt->setMtxCalc(0);\n    }\n\nprivate:\n    /* 0x14 */ J3DAnmTransform* mAnm;\n    /* 0x18 */ J3DMtxCalc* mpMtxCalc;\n};  // Size: 0x1C\n\nSTATIC_ASSERT(sizeof(mDoExt_bckAnm) == 0x1C);\n\nclass mDoExt_btpAnm : public mDoExt_baseAnm {\npublic:\n    mDoExt_btpAnm() { mpAnm = NULL; }\n    /* 8000D54C */ int init(J3DMaterialTable* i_matTable, J3DAnmTexPattern* i_btk, int i_anmPlay,\n                            int i_attribute, f32 i_rate, s16 i_start, s16 param_6);\n    /* 8000D5E8 */ void entry(J3DMaterialTable* i_matTable, s16 i_frame);\n\n    void entry(J3DModelData* i_modelData) { entry(i_modelData, getFrame()); }\n    void entry(J3DModelData* i_modelData, s16 i_frame) {\n        entry(&i_modelData->getMaterialTable(), i_frame);\n    }\n\n    int init(J3DModelData* i_modelData, J3DAnmTexPattern* i_btk, int i_anmPlay, int i_attribute,\n             f32 i_rate, s16 i_start, s16 param_6) {\n        return init(&i_modelData->getMaterialTable(), i_btk, i_anmPlay, i_attribute, i_rate,\n                    i_start, param_6);\n    }\n\n    int remove(J3DModelData* i_modelData) { return i_modelData->removeTexNoAnimator(mpAnm); }\n\nprivate:\n    /* 0x14 */ J3DAnmTexPattern* mpAnm;\n};\n\nclass mDoExt_blkAnm : public mDoExt_baseAnm {\npublic:\n    /* 8000DA08 */ int init(J3DDeformData* i_deformData, J3DAnmCluster* i_blk, int i_anmPlay,\n                            int i_attribute, f32 i_rate, s16 i_start, s16 param_6);\n\n    J3DAnmCluster* getBlkAnm() { return mpAnm; }\n\nprivate:\n    /* 0x14 */ J3DAnmCluster* mpAnm;\n};\n\nclass J3DTransformInfo;\n\nclass mDoExt_AnmRatioPack {\npublic:\n    /* 80140DF0 */ ~mDoExt_AnmRatioPack();\n    /* 80140E2C */ mDoExt_AnmRatioPack();\n\n    void setRatio(f32 ratio) { mRatio = ratio; }\n    f32 getRatio() { return mRatio; }\n    J3DAnmTransform* getAnmTransform() { return mAnmTransform; }\n    void setAnmTransform(J3DAnmTransform* anm) { mAnmTransform = anm; }\n\nprivate:\n    /* 0x0 */ f32 mRatio;\n    /* 0x4 */ J3DAnmTransform* mAnmTransform;\n};  // Size: 0x8\n\nclass mDoExt_invJntPacket : public J3DPacket {\npublic:\n    /* 8000E654 */ mDoExt_invJntPacket();\n\n    /* 80012220 */ virtual void draw();\n    /* 8000E5F8 */ virtual ~mDoExt_invJntPacket();\n\n    void setJoint(J3DModel* i_model, u16 param_1, u8 param_2) {\n        field_0x10 = i_model;\n        field_0x14 = param_1;\n        field_0x16 = param_2;\n    }\n\nprivate:\n    /* 0x10 */ J3DModel* field_0x10;\n    /* 0x14 */ u16 field_0x14;\n    /* 0x16 */ u8 field_0x16;\n};  // Size: 0x18\n\nclass mDoExt_invisibleModel {\npublic:\n    /* 8000E53C */ int create(J3DModel* i_model, u8 param_1);\n    /* 8000E6C8 */ void entryJoint(cXyz*);\n    /* 8000E7C0 */ void entryDL(cXyz*);\n\n    /* 0x0 */ J3DModel* mModel;\n    /* 0x4 */ mDoExt_invJntPacket* mpPackets;\n};\n\nclass mDoExt_zelAnime : public Z2SoundObjAnime {\npublic:\n    void* field_0x48;\n};\n\nclass mDoExt_McaMorfCallBack1_c {\npublic:\n    virtual int execute(u16, J3DTransformInfo*) = 0;\n};\n\nclass mDoExt_McaMorfCallBack2_c {\npublic:\n    virtual void execute(u16) = 0;\n};\n\nclass mDoExt_morf_c : public J3DMtxCalcNoAnm<J3DMtxCalcCalcTransformMaya, J3DMtxCalcJ3DSysInitMaya> {\npublic:\n    /* 8000F950 */ mDoExt_morf_c();\n    /* 8000FB7C */ void setMorf(f32 i_morf);\n    /* 8000FBC0 */ void frameUpdate();\n\n    /* 8000FAE8 */ virtual ~mDoExt_morf_c();\n\n    J3DAnmTransform* getAnm() { return mpAnm; }\n    void changeAnm(J3DAnmTransform* anm) { mpAnm = anm; }\n    u8 getPlayMode() { return mFrameCtrl.getAttribute(); }\n    void setPlayMode(int mode) { mFrameCtrl.setAttribute(mode); }\n    bool isStop() {\n        bool stopped = true;\n        if (!mFrameCtrl.checkState(1) && mFrameCtrl.getRate() != 0.0f) {\n            stopped = false;\n        }\n        return stopped;\n    }\n    bool isLoop() { return mFrameCtrl.checkState(2); }\n    f32 getStartFrame() { return mFrameCtrl.getStart(); }\n    void setStartFrame(f32 frame) { mFrameCtrl.setStart(frame); }\n    f32 getEndFrame() { return mFrameCtrl.getEnd(); }\n    void setEndFrame(f32 frame) { mFrameCtrl.setEnd(frame); }\n    f32 getLoopFrame() { return mFrameCtrl.getLoop(); }\n    void setLoopFrame(f32 frame) { mFrameCtrl.setLoop(frame); }\n    f32 getPlaySpeed() { return mFrameCtrl.getRate(); }\n    void setPlaySpeed(f32 speed) { mFrameCtrl.setRate(speed); }\n    f32 getFrame() { return mFrameCtrl.getFrame(); }\n    void setFrame(f32 frame) { mFrameCtrl.setFrame((s16)frame); }\n    void setFrameF(f32 frame) { mFrameCtrl.setFrame(frame); }\n    BOOL checkFrame(f32 frame) { return mFrameCtrl.checkPass(frame); }\n\n    /* 0x04 */ J3DModel* mpModel;\n    /* 0x08 */ J3DAnmTransform* mpAnm;\n    /* 0x0C */ J3DFrameCtrl mFrameCtrl;\n    /* 0x20 */ J3DTransformInfo* mpTransformInfo;\n    /* 0x24 */ Quaternion* mpQuat;\n    /* 0x28 */ f32 mCurMorf;\n    /* 0x2C */ f32 mPrevMorf;\n    /* 0x30 */ f32 mMorfStep;\n    /* 0x34 */ f32 field_0x34;\n};\n\nclass mDoExt_McaMorfSO : public mDoExt_morf_c {\npublic:\n    /* 800107D0 */ mDoExt_McaMorfSO(J3DModelData*, mDoExt_McaMorfCallBack1_c*,\n                                    mDoExt_McaMorfCallBack2_c*, J3DAnmTransform*, int, f32, int,\n                                    int, Z2Creature*, u32, u32);\n    /* 800108F0 */ int create(J3DModelData*, mDoExt_McaMorfCallBack1_c*, mDoExt_McaMorfCallBack2_c*,\n                              J3DAnmTransform*, int, f32, int, int, Z2Creature*, u32, u32);\n    /* 80010E70 */ void setAnm(J3DAnmTransform* i_anm, int i_attr, f32 i_morf, f32 i_rate, f32 i_start, f32 i_end);\n    /* 800110B0 */ int play(u32, s8);\n    /* 80011154 */ void updateDL();\n    /* 800111C0 */ void entryDL();\n    /* 800111EC */ void modelCalc();\n    /* 80011250 */ void getTransform(u16, J3DTransformInfo*);\n    /* 80011310 */ void stopZelAnime();\n\n    /* 80010888 */ virtual ~mDoExt_McaMorfSO();\n    /* 80010B68 */ virtual void calc();\n\n    J3DModel* getModel() { return mpModel; }\n    void offMorfNone() { mMorfNone = false; }\n    void onMorfNone() { mMorfNone = true; }\n\nprivate:\n    /* 0x38 */ mDoExt_McaMorfCallBack1_c* mpCallback1;\n    /* 0x3C */ mDoExt_McaMorfCallBack2_c* mpCallback2;\n    /* 0x40 */ cXyz mTranslateScale;\n    /* 0x4C */ Z2Creature* mpSound;\n    /* 0x50 */ void* mpBas;\n    /* 0x54 */ bool mTranslate;\n    /* 0x55 */ bool mMorfNone;\n};\n\nclass mDoExt_McaMorf : public mDoExt_morf_c {\npublic:\n    /* 8000FC4C */ mDoExt_McaMorf(J3DModelData*, mDoExt_McaMorfCallBack1_c*,\n                                  mDoExt_McaMorfCallBack2_c*, J3DAnmTransform*, int, f32, int, int,\n                                  int, void*, u32, u32);\n    /* 8000FD94 */ int create(J3DModelData*, mDoExt_McaMorfCallBack1_c*,\n                               mDoExt_McaMorfCallBack2_c*, J3DAnmTransform*, int, f32, int, int,\n                               int, void*, u32, u32);\n    /* 8001037C */ void setAnm(J3DAnmTransform*, int, f32, f32, f32, f32, void*);\n    /* 800105C8 */ u32 play(Vec*, u32, s8);\n    /* 80010680 */ void entryDL();\n    /* 800106AC */ void modelCalc();\n    /* 80010710 */ void getTransform(u16, J3DTransformInfo*);\n\n    /* 8000FD10 */ virtual ~mDoExt_McaMorf();\n    /* 80010074 */ virtual void calc();\n\n    J3DModel* getModel() { return mpModel; }\n\nprivate:\n    /* 0x38 */ mDoExt_McaMorfCallBack1_c* mpCallback1;\n    /* 0x3C */ mDoExt_McaMorfCallBack2_c* mpCallback2;\n    /* 0x40 */ cXyz mTranslateScale;\n    /* 0x4C */ mDoExt_zelAnime* mpSound;\n    /* 0x50 */ bool field_0x50;\n    /* 0x51 */ bool field_0x51;\n    /* 0x52 */ bool field_0x52;\n};\n\nclass mDoExt_McaMorf2 : public mDoExt_morf_c {\npublic:\n    /* 80011348 */ mDoExt_McaMorf2(J3DModelData*, mDoExt_McaMorfCallBack1_c*,\n                                   mDoExt_McaMorfCallBack2_c*, J3DAnmTransform*, J3DAnmTransform*,\n                                   int, f32, int, int, Z2Creature*, u32, u32);\n    /* 80011464 */ void create(J3DModelData*, mDoExt_McaMorfCallBack1_c*,\n                               mDoExt_McaMorfCallBack2_c*, J3DAnmTransform*, J3DAnmTransform*, int,\n                               f32, int, int, Z2Creature*, u32, u32);\n    /* 800116B4 */ void ERROR_EXIT();\n    /* 80011D70 */ void setAnm(J3DAnmTransform*, J3DAnmTransform*, f32, int, f32, f32, f32, f32);\n    /* 80011FCC */ void setAnmRate(f32);\n    /* 800120A0 */ int play(u32, s8);\n    /* 80012144 */ void entryDL();\n    /* 80012170 */ void modelCalc();\n    /* 800121E8 */ void stopZelAnime();\n\n    /* 800113FC */ virtual ~mDoExt_McaMorf2();\n    /* 800116F4 */ virtual void calc();\n\nprivate:\n    /* 0x38 */ mDoExt_McaMorfCallBack1_c* mpCallback1;\n    /* 0x3C */ mDoExt_McaMorfCallBack2_c* mpCallback2;\n    /* 0x40 */ J3DAnmTransform* field_0x40;\n    /* 0x44 */ f32 field_0x44;\n    /* 0x48 */ Z2Creature* mpSound;\n    /* 0x4C */ void* mpBas;\n};\n\nclass mDoExt_MtxCalcOldFrame {\npublic:\n    /* 8000F848 */ void initOldFrameMorf(f32, u16, u16);\n    /* 8000F8CC */ void decOldFrameMorfCounter();\n\n    bool getOldFrameFlg() { return mOldFrameFlg; }\n    void onOldFrameFlg() { mOldFrameFlg = true; }\n    void offOldFrameFlg() { mOldFrameFlg = false; }\n    f32 getOldFrameRate() { return mOldFrameRate; }\n    J3DTransformInfo* getOldFrameTransInfo(int i) { return &mOldFrameTransInfo[i]; }\n    u16 getOldFrameStartJoint() { return mOldFrameStartJoint; }\n    u16 getOldFrameEndJoint() { return mOldFrameEndJoint; }\n    Quaternion* getOldFrameQuaternion(int i_no) { return &mOldFrameQuaternion[i_no]; }\n\nprivate:\n    /* 0x00 */ bool mOldFrameFlg;\n    /* 0x04 */ f32 mOldFrameMorfCounter;\n    /* 0x08 */ f32 field_0x8;\n    /* 0x0C */ f32 mOldFrameRate;\n    /* 0x10 */ f32 field_0x10;\n    /* 0x14 */ f32 field_0x14;\n    /* 0x18 */ u16 mOldFrameStartJoint;\n    /* 0x1A */ u16 mOldFrameEndJoint;\n    /* 0x1C */ J3DTransformInfo* mOldFrameTransInfo;\n    /* 0x20 */ Quaternion* mOldFrameQuaternion;\n};  // Size: 0x24\n\nstruct mDoExt_MtxCalcAnmBlendTbl : public J3DMtxCalcNoAnm<J3DMtxCalcCalcTransformMaya, J3DMtxCalcJ3DSysInitMaya> {\n    mDoExt_MtxCalcAnmBlendTbl(int num, mDoExt_AnmRatioPack* anmRatio) {\n        mNum = num;\n        mAnmRatio = anmRatio;\n        for (int i = 0; i < mNum; i++) {\n            if (!mAnmRatio[i].getAnmTransform()) {\n                mAnmRatio[i].setRatio(0.0f);\n            }\n        }\n    }\n\n    /* 800D00BC */ J3DAnmTransform* getAnm(int);\n\n    /* 80014F3C */ virtual ~mDoExt_MtxCalcAnmBlendTbl();\n    /* 8000F26C */ virtual void calc();\n\n    /* 0x4 */ int mNum;\n    /* 0x8 */ mDoExt_AnmRatioPack* mAnmRatio;\n};  // Size: 0x0C\n\nSTATIC_ASSERT(sizeof(mDoExt_MtxCalcAnmBlendTbl) == 0x0C);\n\nstruct mDoExt_MtxCalcAnmBlendTblOld : public mDoExt_MtxCalcAnmBlendTbl {\n    mDoExt_MtxCalcAnmBlendTblOld(mDoExt_MtxCalcOldFrame* oldFrame, int num, mDoExt_AnmRatioPack* anmRatio) : mDoExt_MtxCalcAnmBlendTbl(num, anmRatio) {\n        mOldFrame = oldFrame;\n    }\n    /* 80014EB0 */ virtual ~mDoExt_MtxCalcAnmBlendTblOld();\n    /* 8000F4B0 */ virtual void calc();\n\n    /* 0xC */ mDoExt_MtxCalcOldFrame* mOldFrame;\n};  // Size: 0x10\n\nSTATIC_ASSERT(sizeof(mDoExt_MtxCalcAnmBlendTblOld) == 0x10);\n\nclass mDoExt_3Dline_c {\npublic:\n    /* 800123D0 */ void init(u16, int, int);\n    /* 800126BC */ mDoExt_3Dline_c();\n\n    /* 0x00 */ cXyz* field_0x0;\n    /* 0x04 */ void* field_0x4;\n    /* 0x08 */ cXyz* field_0x8;\n    /* 0x0C */ cXyz* field_0xc;\n    /* 0x10 */ void* field_0x10;\n    /* 0x14 */ void* field_0x14;\n    /* 0x18 */ f32* field_0x18;\n    /* 0x1C */ f32* field_0x1c;\n};\n\nclass mDoExt_3DlineMat_c {\npublic:\n    #ifndef NON_VIRTUAL_3DLINEMAT\n    virtual int getMaterialID();\n    virtual void setMaterial();\n    virtual void draw();\n    #else\n    /* 0x0 */ void* field_0x0;\n    #endif\n    /* 0x4 */ mDoExt_3DlineMat_c* field_0x4;\n};\n\nclass mDoExt_3DlineMatSortPacket : public J3DPacket {\npublic:\n    mDoExt_3DlineMatSortPacket() { mp3DlineMat = NULL; }\n\n    void reset() { mp3DlineMat = NULL; }\n\n    /* 80014738 */ void setMat(mDoExt_3DlineMat_c*);\n    virtual void draw();\n    virtual ~mDoExt_3DlineMatSortPacket();\n\nprivate:\n    /* 0x10 */ mDoExt_3DlineMat_c* mp3DlineMat;\n};\n\nclass dKy_tevstr_c;\nclass mDoExt_3DlineMat1_c : public mDoExt_3DlineMat_c {\npublic:\n    /* 80013360 */ void init(u16, u16, ResTIMG*, int);\n    /* 80013FB0 */ void update(int, GXColor&, dKy_tevstr_c*);\n    /* 8001373C */ void update(int, f32, GXColor&, u16, dKy_tevstr_c*);\n    /* 80014E7C */ int getMaterialID();\n    /* 800134F8 */ void setMaterial();\n    /* 800135D0 */ void draw();\n\n    cXyz* getPos(int i_idx) { return field_0x38[i_idx].field_0x0; }\n\nprivate:\n    /* 0x08 */ GXTexObj field_0x8;\n    /* 0x28 */ GXColor field_0x28;\n    /* 0x2C */ dKy_tevstr_c* field_0x2c;\n    /* 0x30 */ u16 field_0x30;\n    /* 0x32 */ u16 field_0x32;\n    /* 0x34 */ u16 field_0x34;\n    /* 0x36 */ u8 field_0x36;\n    /* 0x38 */ mDoExt_3Dline_c* field_0x38;\n};\n\nclass mDoExt_3DlineMat0_c : public mDoExt_3DlineMat_c {\npublic:\n    /* 800125E0 */ void init(u16, u16, int);\n    /* 800126C0 */ void setMaterial();\n    /* 80012774 */ void draw();\n    /* 80012874 */ void update(int, f32, _GXColor&, u16, dKy_tevstr_c*);\n    /* 80012E3C */ void update(int, _GXColor&, dKy_tevstr_c*);\n    /* 80014E84 */ int getMaterialID();\n\n    cXyz* getPos(int param_0) { return field_0x18[param_0].field_0x0; }\n\nprivate:\n    /* 0x08 */ GXColor field_0x8;\n    /* 0x0C */ dKy_tevstr_c* field_0xc;\n    /* 0x10 */ u16 field_0x10;\n    /* 0x12 */ u16 field_0x12;\n    /* 0x14 */ u16 field_0x14;\n    /* 0x16 */ u8 field_0x16;\n    /* 0x18 */ mDoExt_3Dline_c* field_0x18;\n};\n\nclass mDoExt_cubePacket : public J3DPacket {\npublic:\n    mDoExt_cubePacket(cXyz& i_position, cXyz& i_size, csXyz& i_angle, const GXColor& i_color) {\n        mPosition = i_position;\n        mSize = i_size;\n        mAngle = i_angle;\n        mColor = i_color;\n    }\n\n    virtual void draw();\n    virtual ~mDoExt_cubePacket() {}\n\n    /* 0x10 */ cXyz mPosition;\n    /* 0x1C */ cXyz mSize;\n    /* 0x28 */ csXyz mAngle;\n    /* 0x2E */ GXColor mColor;\n};\n\nclass mDoExt_cylinderPacket : public J3DPacket {\npublic:\n    mDoExt_cylinderPacket(cXyz& i_position, f32 i_radius, f32 i_height, const GXColor& i_color,\n                          u8 param_4) {\n        mPosition = i_position;\n        mRadius = i_radius;\n        mHeight = i_height;\n        mColor = i_color;\n        field_0x28 = param_4;\n    }\n\n    virtual void draw();\n    virtual ~mDoExt_cylinderPacket() {}\n\n    /* 0x10 */ cXyz mPosition;\n    /* 0x1C */ f32 mRadius;\n    /* 0x20 */ f32 mHeight;\n    /* 0x24 */ GXColor mColor;\n    /* 0x28 */ u8 field_0x28;\n};\n\nJKRSolidHeap* mDoExt_createSolidHeapFromGame(u32 i_size, u32 i_alignment);\nvoid mDoExt_destroySolidHeap(JKRSolidHeap* i_heap);\nu32 mDoExt_adjustSolidHeap(JKRSolidHeap* i_heap);\nvoid mDoExt_restoreCurrentHeap();\nJKRExpHeap* mDoExt_getGameHeap();\nvoid mDoExt_destroySolidHeap(JKRSolidHeap* i_heap);\nJKRHeap* mDoExt_setCurrentHeap(JKRHeap* i_heap);\nJKRExpHeap* mDoExt_getArchiveHeap();\nJKRExpHeap* mDoExt_getArchiveHeapPtr();\nvoid mDoExt_destroyExpHeap(JKRExpHeap* i_heap);\nJKRAssertHeap* mDoExt_getAssertHeap();\nJKRExpHeap* mDoExt_getCommandHeap();\nJKRExpHeap* mDoExt_getZeldaHeap();\nJKRExpHeap* mDoExt_getJ2dHeap();\nJKRExpHeap* mDoExt_getHostIOHeap();\nJKRExpHeap* mDoExt_getDbPrintHeap();\nJKRExpHeap* mDoExt_createDbPrintHeap(u32 heapSize, JKRHeap* i_heap);\nJKRAssertHeap* mDoExt_createAssertHeap(JKRHeap* i_heap);\nJKRExpHeap* mDoExt_createCommandHeap(u32 heapSize, JKRHeap* i_heap);\nJKRExpHeap* mDoExt_createArchiveHeap(u32 heapSize, JKRHeap* i_heap);\nJKRExpHeap* mDoExt_createJ2dHeap(u32 heapSize, JKRHeap* i_heap);\nJKRExpHeap* mDoExt_createZeldaHeap(u32 heapSize, JKRHeap* i_heap);\nJKRExpHeap* mDoExt_createGameHeap(u32 heapSize, JKRHeap* i_heap);\nJKRSolidHeap* mDoExt_createSolidHeapToCurrent(JKRHeap** o_heap, u32 i_size, JKRHeap* i_parent,\n                                              u32 i_alignment);\nJKRSolidHeap* mDoExt_createSolidHeapToCurrent(u32 i_size, JKRHeap* i_parent, u32 i_alignment);\nJKRSolidHeap* mDoExt_createSolidHeapFromGameToCurrent(u32 i_size, u32 i_alignment);\nJKRSolidHeap* mDoExt_createSolidHeapFromGameToCurrent(JKRHeap** o_heap, u32 i_size,\n                                                      u32 i_alignment);\nJKRSolidHeap* mDoExt_createSolidHeapFromSystem(u32 i_size, u32 i_alignment);\nu32 mDoExt_adjustSolidHeapToSystem(JKRSolidHeap* i_heap);\nJKRHeap* mDoExt_getCurrentHeap();\nvoid mDoExt_removeMesgFont();\nvoid mDoExt_modelUpdate(J3DModel* i_model);\nvoid mDoExt_modelUpdateDL(J3DModel* i_model);\nJ3DModel* mDoExt_J3DModel__create(J3DModelData* i_modelData, u32 i_modelFlag, u32 i_differedDlistFlag);\nvoid mDoExt_setAraCacheSize(u32 size);\nint mDoExt_resIDToIndex(JKRArchive* p_archive, u16 id);\nvoid mDoExt_modelEntryDL(J3DModel* i_model);\nvoid mDoExt_brkAnmRemove(J3DModelData* i_modelData);\nvoid mDoExt_setupStageTexture(J3DModelData* i_modelData);\nOSThread* mDoExt_GetCurrentRunningThread();\nvoid mDoExt_setupShareTexture(J3DModelData* i_modelData, J3DModelData* i_shareModelData);\n\nstruct JUTFont;\nJUTFont* mDoExt_getMesgFont();\nJUTFont* mDoExt_getSubFont();\nJUTFont* mDoExt_getRubyFont();\nvoid mDoExt_removeSubFont();\n\nextern JKRExpHeap* zeldaHeap;\nextern JKRExpHeap* gameHeap;\nextern JKRExpHeap* archiveHeap;\nextern JKRExpHeap* commandHeap;\n\n#endif /* M_DO_M_DO_EXT_H */\n/* end \"m_Do/m_Do_ext.h\" */\n\nclass fopAc_ac_c;\n\nclass dAttHint_c {\npublic:\n    dAttHint_c() {}\n    /* 800738B4 */ u32 getPId(void*);\n    /* 800738CC */ fopAc_ac_c* convPId(unsigned int);\n    /* 800738FC */ int request(fopAc_ac_c*, int);\n    /* 80073958 */ void init();\n    /* 80073970 */ void proc();\n\nprivate:\n    /* 0x0 */ u32 mHintActorID;\n    /* 0x4 */ int mPriority;\n    /* 0x8 */ u32 field_0x8;\n};\n\nclass dAttCatch_c {\npublic:\n    dAttCatch_c() {}\n    fopAc_ac_c* convPId(unsigned int);\n    void init();\n    void proc();\n    int request(fopAc_ac_c*, u8, f32, f32, f32, s16, int);\n\n    fopAc_ac_c* getCatghTarget() { return convPId(mCatghTargetID); }\n    u8 getChangeItem() { return mChangeItem; }\n\nprivate:\n    /* 0x00 */ u32 field_0x0;\n    /* 0x04 */ int field_0x4;\n    /* 0x08 */ f32 field_0x8;\n    /* 0x0C */ u8 field_0xc;\n    /* 0x0D */ u8 field_0xd;\n    /* 0x0E */ u8 field_0xe;\n    /* 0x0F */ u8 field_0xf;\n    /* 0x10 */ u32 mCatghTargetID;\n    /* 0x14 */ u8 mChangeItem;\n};  // Size: 0x18\n\nclass dAttParam_c {\npublic:\n    /* 0x00 */ u16 mFlags;\n    /* 0x04 */ f32 field_0x4;\n    /* 0x08 */ f32 field_0x8;\n    /* 0x0C */ f32 field_0xc;\n    /* 0x10 */ f32 mDangerBGMDistance;\n    /* 0x14 */ f32 mBGMDistMargin;\n    /* 0x18 */ f32 mSWModeDisable;\n    /* 0x1C */ f32 mSelCursorScaleX;\n    /* 0x20 */ f32 mSelCursorScaleY;\n    /* 0x24 */ f32 mAttnCursorScaleX;\n    /* 0x28 */ f32 mAttnCursorScaleY;\n    /* 0x2C */ f32 mSelCursorOffsetY;\n    /* 0x30 */ f32 mAttnCursorOffsetY;\n    /* 0x34 */ u8 mAttnCursorAppearFrames;\n    /* 0x35 */ u8 mAttnCursorDisappearFrames;\n    /* 0x38 */ f32 field_0x38;\n    /* 0x3C */ f32 field_0x3c;\n\npublic:\n    dAttParam_c() {}\n    /* 80070038 */ dAttParam_c(s32);\n\n    /* 80070110 */ virtual ~dAttParam_c();\n\n    bool CheckFlag(u16 flag) { return mFlags & flag; }\n\n    /* 0x40 vtable */\n};  // Size: 0x44\n\nclass dAttLook_c {\npublic:\n    /* 80073CA4 */ fopAc_ac_c* convPId(unsigned int);\n    /* 80073CD4 */ void init();\n    /* 80073CEC */ void proc();\n    /* 80073D08 */ void request(fopAc_ac_c*, f32, f32, f32, s16, int);\n\nprivate:\n    u32 field_0x0;\n    u32 field_0x4;\n    f32 field_0x8;\n    u32 mLookTargetID;\n};  // Size: 0x10\n\nclass dAttList_c {\npublic:\n    /* 800304D0 */ ~dAttList_c() {}\n    /* 8003050C */ dAttList_c() {}\n    /* 80073864 */ fopAc_ac_c* getActor();\n    /* 80073898 */ void setActor(fopAc_ac_c*);\n\n    u32 getPid() { return mActorID; }\n\n    /* 0x00 */ f32 mWeight;\n    /* 0x04 */ f32 mDistance;\n    /* 0x08 */ cSAngle mAngle;\n    /* 0x0C */ u32 mType;\n    /* 0x10 */ u32 mActorID;\n};  // Size: 0x14\n\nclass dAttDraw_c {\npublic:\n    /* 8003054C */ ~dAttDraw_c() {}\n    /* 800307F0 */ dAttDraw_c() {}\n    /* 80072DD8 */ void setAnm(u8, f32);\n    /* 80072FE8 */ void setAlphaAnm(u8, u8);\n    /* 80073004 */ void alphaAnm();\n    /* 800732B0 */ void draw(cXyz&, f32 (*)[4]);\n\n    /* 0x000 */ J3DModel* mModel[2];\n    /* 0x008 */ mDoExt_bckAnm mNoticeCursorBck[2];\n    /* 0x040 */ mDoExt_bpkAnm mNoticeCursorBpk[2];\n    /* 0x070 */ mDoExt_brkAnm mNoticeCursorBrk[2];\n    /* 0x0A0 */ mDoExt_brkAnm mNoticeCursor02Brk[2];\n    /* 0x0D0 */ mDoExt_btkAnm mNoticeCursorBtk[2];\n    /* 0x100 */ mDoExt_bckAnm mImpactBck;\n    /* 0x11C */ mDoExt_bpkAnm mImpactBpk;\n    /* 0x134 */ mDoExt_brkAnm mImpactBrk;\n    /* 0x14C */ mDoExt_btkAnm mImpactBtk;\n    /* 0x164 */ cXyz field_0x164;\n    /* 0x170 */ u8 field_0x170;\n    /* 0x171 */ u8 field_0x171;\n    /* 0x172 */ u8 field_0x172;\n    /* 0x173 */ u8 field_0x173;\n    /* 0x174 */ u8 field_0x174;\n    /* 0x175 */ u8 field_0x175;\n};\n\nSTATIC_ASSERT(sizeof(dAttDraw_c) == 0x178);\n\nclass dAttDraw_CallBack_c : public mDoExt_McaMorfCallBack1_c {\npublic:\n    /* 80070178 */ virtual int execute(u16, J3DTransformInfo*);\n};\n\nstruct dist_entry {\n    f32 field_0x0;\n    f32 field_0x4;\n    f32 field_0x8;\n    f32 field_0xc;\n    f32 field_0x10;\n    f32 field_0x14;\n    u32 field_0x18;\n};  // Size: 0x1C\n\nstruct type_tbl_entry {\n    s16 field_0x0;\n    u16 field_0x2;\n};\n\nclass dAttention_c {\npublic:\n    enum EState {\n        ST_NONE,\n        ST_LOCK,\n        ST_RELEASE,\n    };\n\n    dAttention_c() {}\n    /* 80070198 */ dAttention_c(fopAc_ac_c*, u32);\n    /* 80070774 */ ~dAttention_c();\n    /* 80070844 */ dAttList_c* GetLockonList(s32);\n    /* 80070880 */ dAttList_c* getActionBtnB();\n    /* 80070974 */ dAttList_c* getActionBtnXY();\n    /* 80070A70 */ int chkAttMask(u32, u32);\n    /* 80070E90 */ f32 calcWeight(int, fopAc_ac_c*, f32, s16, s16, u32*);\n    /* 800710C0 */ void setList(int, fopAc_ac_c*, f32, f32, cSAngle, u32);\n    /* 80071240 */ void initList(u32);\n    /* 800713CC */ int makeList();\n    /* 80071424 */ void setOwnerAttentionPos();\n    /* 80071488 */ int SelectAttention(fopAc_ac_c*);\n    /* 800716B8 */ void sortList();\n    /* 800718A4 */ void stockAttention();\n    /* 80071960 */ fopAc_ac_c* nextAttention();\n    /* 80071A68 */ int freeAttention();\n    /* 80071A98 */ bool chaseAttention();\n    /* 80071CC0 */ f32 EnemyDistance(fopAc_ac_c*);\n    /* 80071DEC */ void runSoundProc();\n    /* 80071E84 */ void runDrawProc();\n    /* 800720F4 */ void runDebugDisp();\n    /* 800720F8 */ void checkButton();\n    /* 800722A0 */ bool triggerProc();\n    /* 800722EC */ int lostCheck();\n    /* 80072344 */ void judgementStatus4Hold();\n    /* 800725F0 */ void judgementStatus4Switch();\n    /* 80072924 */ int Run();\n    /* 80072BD4 */ void Draw();\n    /* 80072D80 */ void lockSoundStart(u32);\n    /* 8007353C */ fopAc_ac_c* LockonTarget(s32);\n    /* 800735DC */ f32 LockonReleaseDistanse();\n    /* 800736CC */ u32 LockonTargetPId(s32);\n    /* 80073734 */ fopAc_ac_c* ActionTarget(s32);\n    /* 8007378C */ fopAc_ac_c* CheckObjectTarget(s32);\n    /* 800737E4 */ bool LockonTruth();\n    /* 80073838 */ int checkDistance(cXyz*, s16, cXyz*, f32, f32, f32, f32);\n    /* 8016E424 */ void LockEdge();\n    /* 80182994 */ void GetCheckObjectCount();\n    /* 80182AD0 */ void keepLock(int);\n    /* 8014B010 */ static dist_entry& getDistTable(int);\n\n    fopAc_ac_c* getCatghTarget() { return mCatghTarget.getCatghTarget(); }\n    u8 getCatchChgItem() { return mCatghTarget.getChangeItem(); }\n    BOOL chkFlag(u32 flag) { return (mFlags & flag) ? TRUE : FALSE; }\n    void setFlag(u32 flag) { mFlags |= flag; }\n    void clrFlag(u32 flag) { mFlags &= ~flag; }\n    int GetActionCount() { return mActionCount; }\n    int GetLockonCount() { return mLockonCount; }\n    bool Lockon() { return LockonTruth() || chkFlag(0x20000000); }  // only matches with -O2?\n    int ZHintRequest(fopAc_ac_c* param_1, int param_2) {\n        return mZHintTarget.request(param_1, param_2);\n    }\n\n    void LookRequest(fopAc_ac_c* param_0, f32 i_horizontalDist, f32 i_upDist, f32 i_downDist,\n                     s16 i_angle, int param_5) {\n        mLookTarget.request(param_0, i_horizontalDist, i_upDist, i_downDist, i_angle, param_5);\n    }\n\n    void CatchRequest(fopAc_ac_c* param_0, u8 param_1, f32 i_horizontalDist, f32 i_upDist,\n                      f32 i_downDist, s16 i_angle, int param_5) {\n        mCatghTarget.request(param_0, param_1, i_horizontalDist, i_upDist, i_downDist, i_angle,\n                             param_5);\n    }\n\n    static dist_entry& i_getDistTable(int i_no) { return dist_table[i_no]; }\n\n    static type_tbl_entry loc_type_tbl[3];\n    static type_tbl_entry act_type_tbl[5];\n    static dist_entry dist_table[234];\n    static int loc_type_num;\n    static int act_type_num;\n    static type_tbl_entry chk_type_tbl[1];\n    static int chk_type_num;\n\npublic:\n    /* 0x000 */ fopAc_ac_c* mpPlayer;\n    /* 0x004 */ u32 mLockTargetID;\n    /* 0x008 */ dAttDraw_CallBack_c mpDrawCallback;\n    /* 0x00C */ u32 mPadNo;\n    /* 0x010 */ u32 mPlayerAttentionFlags;\n    /* 0x014 */ u8 field_0x14[4];\n    /* 0x018 */ JKRSolidHeap* heap;\n    /* 0x01C */ cXyz mDrawAttnPos;\n    /* 0x028 */ dAttDraw_c draw[2];\n    /* 0x318 */ u32 mTargetActorID;\n    /* 0x31C */ cXyz mOwnerAttnPos;\n    /* 0x328 */ s8 field_0x328;\n    /* 0x329 */ u8 mAttnStatus;\n    /* 0x32A */ u8 field_0x32a;\n    /* 0x32B */ u8 field_0x32b;\n    /* 0x32C */ u8 field_0x32c;\n    /* 0x32D */ u8 field_0x32d;\n    /* 0x32E */ u8 field_0x32e;\n    /* 0x32F */ u8 field_0x32f;\n    /* 0x330 */ u8 field_0x330;\n    /* 0x331 */ u8 field_0x331;\n    /* 0x332 */ u8 field_0x332;\n    /* 0x333 */ u8 field_0x333;\n    /* 0x334 */ u32 mFlags;\n    /* 0x338 */ dAttList_c mLockOnList[8];\n    /* 0x3D8 */ int mLockonCount;\n    /* 0x3DC */ int mLockOnOffset;\n    /* 0x3E0 */ dAttList_c mActionList[4];\n    /* 0x430 */ int mActionCount;\n    /* 0x434 */ int mActionOffset;\n    /* 0x438 */ dAttList_c mCheckObjectList[4];\n    /* 0x488 */ int mCheckObjectCount;\n    /* 0x48C */ int mCheckObjectOffset;\n    /* 0x490 */ dAttHint_c mZHintTarget;\n    /* 0x49C */ dAttCatch_c mCatghTarget;\n    /* 0x4B4 */ dAttLook_c mLookTarget;\n    /* 0x4C4 */ int mAttnBlockTimer;\n    /* 0x4C8 */ dAttParam_c mAttParam;\n    /* 0x50C */ u8 field_0x50c[0x514 - 0x50c];\n    /* 0x514 */ u32 mEnemyActorID;\n    /* 0x518 */ f32 mEnemyDist;\n};  // Size: 0x51C\n\nSTATIC_ASSERT(sizeof(dAttention_c) == 0x51C);\n\n#endif /* D_D_ATTENTION_H */\n/* end \"d/d_attention.h\" */\n/* \"src/d/d_attention.cpp\" line 6 \"JSystem/J3DGraphBase/J3DMatBlock.h\" */\n#ifndef J3DMATBLOCK_H\n#define J3DMATBLOCK_H\n\n/* \"include/JSystem/J3DGraphBase/J3DMatBlock.h\" line 3 \"JSystem/J3DGraphBase/J3DStruct.h\" */\n#ifndef J3DSTRUCT_H\n#define J3DSTRUCT_H\n\n/* \"include/JSystem/J3DGraphBase/J3DStruct.h\" line 3 \"dolphin/gx/GXStruct.h\" */\n/* end \"dolphin/gx/GXStruct.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DStruct.h\" line 4 \"dolphin/mtx/mtx.h\" */\n/* end \"dolphin/mtx/mtx.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DStruct.h\" line 5 \"dolphin/mtx/mtx44.h\" */\n/* end \"dolphin/mtx/mtx44.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DStruct.h\" line 6 \"dolphin/mtx/vec.h\" */\n/* end \"dolphin/mtx/vec.h\" */\n\nclass J3DLightInfo {\npublic:\n    /* 803256C4 */ J3DLightInfo& operator=(J3DLightInfo const&);\n\n    /* 0x00 */ Vec mLightPosition;\n    /* 0x0C */ Vec mLightDirection;\n    /* 0x18 */ GXColor mColor;\n    /* 0x1C */ Vec mCosAtten;\n    /* 0x28 */ Vec mDistAtten;\n};  // Size = 0x34\n\nextern \"C\" extern J3DLightInfo const j3dDefaultLightInfo;\n\nclass J3DLightObj {\npublic:\n    /* 80018C0C */ J3DLightObj() { mInfo = j3dDefaultLightInfo; }\n    /* 80323590 */ void load(u32) const;\n\n    J3DLightInfo& getLightInfo() { return mInfo; }\n    J3DLightObj& operator=(J3DLightObj const& other) {\n        mInfo = other.mInfo;\n        return *this;\n    }\n\n    /* 0x00 */ J3DLightInfo mInfo;\n    /* 0x34 */ u8 field_0x34[64];\n};  // Size = 0x74\n\nstruct J3DTextureSRTInfo {\n    /* 0x00 */ f32 mScaleX;\n    /* 0x04 */ f32 mScaleY;\n    /* 0x08 */ s16 mRotation;\n    /* 0x0C */ f32 mTranslationX;\n    /* 0x10 */ f32 mTranslationY;\n\n    inline void operator=(J3DTextureSRTInfo const& other) {\n        register const f32* src = &other.mScaleX;\n        register f32* dst = &mScaleX;\n        register f32 xy;\n        asm {\n            psq_l xy, 0(src), 0, 0\n            psq_st xy, 0(dst), 0, 0\n        };\n        // Unclear why there's a 4 byte copy here.\n        *(u32*)&mRotation = *(u32*)&other.mRotation;\n        src = &other.mTranslationX;\n        dst = &mTranslationX;\n        asm {\n            psq_l xy, 0(src), 0, 0\n            psq_st xy, 0(dst), 0, 0\n        };\n    }\n};  // Size: 0x14\n\nstruct J3DTexMtxInfo {\n    /* 80325718 */ J3DTexMtxInfo& operator=(J3DTexMtxInfo const&);\n    /* 80325794 */ void setEffectMtx(Mtx);\n\n    /* 0x00 */ u8 mProjection;\n    /* 0x01 */ u8 mInfo;\n    /* 0x04 */ Vec mCenter;\n    /* 0x10 */ J3DTextureSRTInfo mSRT;\n    /* 0x24 */ Mtx44 mEffectMtx;    \n};  // Size: 0x64\n\nstruct J3DIndTexMtxInfo {\n    J3DIndTexMtxInfo& operator=(J3DIndTexMtxInfo const&);\n    /* 0x00 */ Mtx23 field_0x0;\n    /* 0x18 */ u8 field_0x18;\n};  // Size: 0x1C\n\nstruct J3DFogInfo {\n    /* 80325800 */ J3DFogInfo& operator=(J3DFogInfo const&);\n\n    /* 0x00 */ u8 field_0x0;\n    /* 0x01 */ u8 field_0x1;\n    /* 0x02 */ u16 field_0x2;\n    /* 0x04 */ f32 field_0x4;\n    /* 0x08 */ f32 field_0x8;\n    /* 0x0C */ f32 field_0xc;\n    /* 0x10 */ f32 field_0x10;\n    /* 0x14 */ GXColor field_0x14;\n    /* 0x18 */ GXFogAdjTable field_0x18;\n};  // Size: 0x2C\n\nstruct J3DNBTScaleInfo {\n    /* 8032587C */ J3DNBTScaleInfo& operator=(J3DNBTScaleInfo const&);\n\n    /* 0x0 */ bool mbHasScale;\n    /* 0x4 */ Vec mScale;\n};  // Size: 0x10\n\n#endif /* J3DSTRUCT_H */\n/* end \"JSystem/J3DGraphBase/J3DStruct.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DMatBlock.h\" line 4 \"JSystem/J3DGraphBase/J3DTevs.h\" */\n#ifndef J3DTEVS_H\n#define J3DTEVS_H\n\n/* \"include/JSystem/J3DGraphBase/J3DTevs.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nstruct J3DTevStageInfo {\n    /* 0x0 */ u8 field_0x0;\n    /* 0x1 */ u8 mTevColorOp;\n    /* 0x2 */ u8 mTevColorAB;\n    /* 0x3 */ u8 mTevColorCD;\n    /* 0x4 */ u8 field_0x4;\n    /* 0x5 */ u8 mTevAlphaOp;\n    /* 0x6 */ u8 mTevAlphaAB;\n    /* 0x7 */ u8 mTevSwapModeInfo;\n    /* 0x8 */ u8 field_0x8[0xc];\n};\n\nextern J3DTevStageInfo const j3dDefaultTevStageInfo;\n\nstruct J3DTevStage {\n    /* 8000E230 */ J3DTevStage();\n    /* 8000E298 */ void setTevStageInfo(J3DTevStageInfo const&);\n    /* 8003AACC */ J3DTevStage(J3DTevStageInfo const&);\n\n    void setRasSel(u8 ras_sel) { mTevSwapModeInfo = (mTevSwapModeInfo & ~3) | ras_sel; }\n    void setTexSel(u8 tex_sel) { mTevSwapModeInfo = (mTevSwapModeInfo & ~0xc) | (tex_sel << 2); }\n\n    /* 0x0 */ u8 field_0x0;\n    /* 0x1 */ u8 mTevColorOp;\n    /* 0x2 */ u8 mTevColorAB;\n    /* 0x3 */ u8 mTevColorCD;\n    /* 0x4 */ u8 field_0x4;\n    /* 0x5 */ u8 mTevAlphaOp;\n    /* 0x6 */ u8 mTevAlphaAB;\n    /* 0x7 */ u8 mTevSwapModeInfo;\n};\n\nstruct J3DIndTevStageInfo {\n    /* 0x0 */ u8 mIndStage;\n    /* 0x1 */ u8 mIndFormat;\n    /* 0x2 */ u8 mBiasSel;\n    /* 0x3 */ u8 mMtxSel;\n    /* 0x4 */ u8 mWrapS;\n    /* 0x5 */ u8 mWrapT;\n    /* 0x6 */ u8 mPrev;\n    /* 0x7 */ u8 mLod;\n    /* 0x8 */ u8 mAlphaSel;\n    /* 0x9 */ u8 pad[3];\n};\n\nextern J3DIndTevStageInfo const j3dDefaultIndTevStageInfo;\n\nstruct J3DIndTevStage {\n    /* 8000E14C */ J3DIndTevStage() : mInfo(0) { setIndTevStageInfo(j3dDefaultIndTevStageInfo); }\n    J3DIndTevStage(J3DIndTevStageInfo const& info) : mInfo(0) { setIndTevStageInfo(info); }\n    void setIndTevStageInfo(J3DIndTevStageInfo const& info) {\n        setIndStage(info.mIndStage);\n        setIndFormat(info.mIndFormat);\n        setBiasSel(info.mBiasSel);\n        setMtxSel(info.mMtxSel);\n        setWrapS(info.mWrapS);\n        setWrapT(info.mWrapT);\n        setPrev(info.mPrev);\n        setLod(info.mLod);\n        setAlphaSel(info.mAlphaSel);\n    }\n    void setIndStage(u8 indStage) { mInfo = (mInfo & ~3) | indStage; }\n    void setIndFormat(u8 indFormat) { mInfo = (mInfo & ~0xc) | (indFormat << 2); }\n    void setBiasSel(u8 biasSel) { mInfo = (mInfo & ~0x70) | (biasSel << 4); }\n    void setMtxSel(u8 mtxSel) { mInfo = (mInfo & ~0x1e00) | (mtxSel << 9); }\n    void setWrapS(u8 wrapS) { mInfo = (mInfo & ~0xe000) | (wrapS << 13); }\n    void setWrapT(u8 wrapT) { mInfo = (mInfo & ~0x70000) | (wrapT << 16); }\n    void setPrev(u8 prev) { mInfo = (mInfo & ~0x100000) | (prev << 20); }\n    void setLod(u8 lod) { mInfo = (mInfo & ~0x80000) | (lod << 19); }\n    void setAlphaSel(u8 alphaSel) { mInfo = (mInfo & ~0x180) | (alphaSel << 7); }\n\n    /* 0x0 */ u32 mInfo;\n};\n\nstruct J3DTevOrderInfo {\n    void operator=(const J3DTevOrderInfo& other) {\n        *(u32*) this = *(u32*)&other;\n    }\n\n    /* 0x0 */ u8 field_0x0;\n    /* 0x1 */ u8 mTexMap;\n    /* 0x2 */ u8 field_0x2;\n    /* 0x3 */ u8 field_0x3; // Maybe padding\n};\n\nextern J3DTevOrderInfo j3dDefaultTevOrderInfoNull;\n\nstruct J3DTevOrder : public J3DTevOrderInfo {\n    /* 8000E140 */ J3DTevOrder() : J3DTevOrderInfo(j3dDefaultTevOrderInfoNull) {}\n    J3DTevOrder(const J3DTevOrderInfo& info) : J3DTevOrderInfo(info) {}\n\n    u8 getTexMap() { return mTexMap; }\n};\n\nstruct J3DTevSwapModeTableInfo {\n    /* 0x0 */ u8 field_0x0;\n    /* 0x1 */ u8 field_0x1;\n    /* 0x2 */ u8 field_0x2;\n    /* 0x3 */ u8 field_0x3;\n}; // Size: 0x4\n\nextern J3DTevSwapModeTableInfo j3dDefaultTevSwapModeTable;\n\nstruct J3DTevSwapModeTable {\n    /* 8000E134 */ J3DTevSwapModeTable();\n    J3DTevSwapModeTable(J3DTevSwapModeTableInfo const& info) {\n        field_0x0 = calcTevSwapTableID(info.field_0x0, info.field_0x1, info.field_0x2, info.field_0x3);\n    }\n    u8 calcTevSwapTableID(u8 param_0, u8 param_1, u8 param_2, u8 param_3) {\n        return 0x40 * param_0 + 0x10 * param_1 + 4 * param_2 + param_3;\n    }\n\n    /* 0x0 */ u8 field_0x0;\n};  // Size: 0x1\n\nstruct J3DTevSwapModeInfo {\n    /* 0x0 */ u8 mRasSel;\n    /* 0x1 */ u8 mTexSel;\n    /* 0x2 */ u8 field_0x2;\n    /* 0x3 */ u8 field_0x3;\n}; // Size: 0x4\n\nstruct J3DNBTScale;\nvoid loadNBTScale(J3DNBTScale& param_0);\n\n#endif /* J3DTEVS_H */\n/* end \"JSystem/J3DGraphBase/J3DTevs.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DMatBlock.h\" line 5 \"JSystem/J3DGraphBase/J3DTexture.h\" */\n#ifndef J3DTEXTURE_H\n#define J3DTEXTURE_H\n\n/* \"include/JSystem/J3DGraphBase/J3DTexture.h\" line 3 \"JSystem/J3DGraphBase/J3DStruct.h\" */\n/* end \"JSystem/J3DGraphBase/J3DStruct.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DTexture.h\" line 4 \"JSystem/JUtility/JUTTexture.h\" */\n#ifndef JUTTEXTURE_H\n#define JUTTEXTURE_H\n\n/* \"include/JSystem/JUtility/JUTTexture.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n/* \"include/JSystem/JUtility/JUTTexture.h\" line 4 \"dolphin/gx/GXStruct.h\" */\n/* end \"dolphin/gx/GXStruct.h\" */\n\nclass JUTPalette;\n\n/*\n * Acts as the header to image data. Usually texture data immediately follows it,\n * so any pointer arithmetic to go past the end of this structure is so that a\n * variable sized allocated buffer can be accessed.\n */\nstruct ResTIMG {\n    /* 0x00 */ u8 format;\n    /* 0x01 */ u8 alphaEnabled;\n    /* 0x02 */ u16 width;\n    /* 0x04 */ u16 height;\n    /* 0x06 */ u8 wrapS;\n    /* 0x07 */ u8 wrapT;\n    /* 0x08 */ u8 indexTexture;\n    /* 0x09 */ u8 colorFormat;\n    /* 0x0A */ u16 numColors;\n    /* 0x0C */ u32 paletteOffset;\n    /* 0x10 */ u8 mipmapEnabled;\n    /* 0x11 */ u8 doEdgeLOD;\n    /* 0x12 */ u8 biasClamp;\n    /* 0x13 */ u8 maxAnisotropy;\n    /* 0x14 */ u8 minFilter;\n    /* 0x15 */ u8 magFilter;\n    /* 0x16 */ s8 minLOD;\n    /* 0x17 */ s8 maxLOD;\n    /* 0x18 */ u8 mipmapCount;\n    /* 0x19 */ u8 unknown;\n    /* 0x1A */ s16 LODBias;\n    /* 0x1C */ u32 imageOffset;\n};  // Size: 0x20\n\nclass JUTTexture {\npublic:\n    JUTTexture() {\n        setCaptureFlag(false);\n        mEmbPalette = NULL;\n        mTexInfo = NULL;\n    }\n\n    JUTTexture(const ResTIMG* p_timg, u8 param_1) {\n        mEmbPalette = NULL;\n        storeTIMG(p_timg, param_1);\n        setCaptureFlag(false);\n    }\n\n    ~JUTTexture();\n    void storeTIMG(ResTIMG const*, JUTPalette*, _GXTlut);\n    void storeTIMG(ResTIMG const*, u8);\n    void storeTIMG(ResTIMG const*, JUTPalette*);\n    void attachPalette(JUTPalette*);\n    void init();\n    void initTexObj(_GXTlut);\n    void initTexObj();\n    void load(_GXTexMapID);\n\n    const ResTIMG* getTexInfo() const { return mTexInfo; }\n    u8 getFormat() const { return mTexInfo->format; }\n    s32 getTransparency() { return mTexInfo->alphaEnabled; }\n    s32 getWidth() const { return mTexInfo->width; }\n    s32 getHeight() const { return mTexInfo->height; }\n    void setCaptureFlag(bool flag) { mFlags &= 2 | flag; }\n    u8 getCaptureFlag() const { return mFlags & 1; }\n    u8 getEmbPaletteDelFlag() const { return mFlags & 2; }\n    void setEmbPaletteDelFlag(bool flag) { mFlags = (mFlags & 1) | (flag << 1);}\n    u8 getTlutName() const { return mTlutName; }\n    bool operator==(const JUTTexture& other) {\n        return mTexInfo == other.mTexInfo\n            && field_0x2c == other.field_0x2c\n            && mWrapS == other.mWrapS\n            && mWrapT == other.mWrapT\n            && mMinFilter == other.mMinFilter\n            && mMagFilter == other.mMagFilter\n            && mMinLOD == other.mMinLOD\n            && mMinLOD == other.mMinLOD\n            && mLODBias == other.mLODBias;\n    }\n    bool operator!=(const JUTTexture& other) {\n        return !operator==(other);\n    }\n\nprivate:\n    /* 0x00 */ GXTexObj mTexObj;\n    /* 0x20 */ const ResTIMG* mTexInfo;\n    /* 0x24 */ void* mTexData;\n    /* 0x28 */ JUTPalette* mEmbPalette;\n    /* 0x2C */ JUTPalette* field_0x2c;\n    /* 0x30 */ u8 mWrapS;\n    /* 0x31 */ u8 mWrapT;\n    /* 0x32 */ u8 mMinFilter;\n    /* 0x33 */ u8 mMagFilter;\n    /* 0x34 */ u16 mMinLOD;\n    /* 0x36 */ u16 mMaxLOD;\n    /* 0x38 */ s16 mLODBias;\n    /* 0x3A */ u8 mTlutName;\n    /* 0x3B */ u8 mFlags;\n    /* 0x3C */ void* field_0x3c;\n};\n\n#endif /* JUTTEXTURE_H */\n/* end \"JSystem/JUtility/JUTTexture.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DTexture.h\" line 5 \"dolphin/mtx/mtx.h\" */\n/* end \"dolphin/mtx/mtx.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DTexture.h\" line 6 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass J3DTexture {\nprivate:\n    /* 0x0 */ u16 mNum;\n    /* 0x2 */ u16 field_0x2;\n    /* 0x4 */ ResTIMG* mpRes;\n\npublic:\n    J3DTexture(u16 num, ResTIMG* res) : mNum(num), field_0x2(0), mpRes(res) {}\n    /* 8031204C */ void loadGX(u16, _GXTexMapID) const;\n    /* 803121A4 */ void entryNum(u16);\n    /* 8031221C */ void addResTIMG(u16, ResTIMG const*);\n    /* 803366A4 */ virtual ~J3DTexture() {}\n\n    u16 getNum() const { return mNum; }\n    ResTIMG* getResTIMG(u16 entry) const { return &mpRes[entry]; }\n    void setResTIMG(u16 entry, const ResTIMG& timg) {\n        mpRes[entry] = timg;\n        mpRes[entry].imageOffset = ((mpRes[entry].imageOffset + (u32)&timg - (u32)(mpRes + entry)));\n        mpRes[entry].paletteOffset = ((mpRes[entry].paletteOffset + (u32)&timg - (u32)(mpRes + entry)));\n    }\n};\n\nclass J3DTexMtx {\npublic:\n    J3DTexMtx(const J3DTexMtxInfo& info) {\n        mTexMtxInfo = info;\n    }\n    /* 803238C4 */ void load(u32) const;\n    /* 80323900 */ void calc(const Mtx);\n    /* 80323920 */ void calcTexMtx(const Mtx);\n    /* 80323C0C */ void calcPostTexMtx(const Mtx);\n    /* 80324358 */ void loadTexMtx(u32) const;\n    /* 803243BC */ void loadPostTexMtx(u32) const;\n\n    J3DTexMtxInfo& getTexMtxInfo() { return mTexMtxInfo; }\n    Mtx& getMtx() { return mMtx; }\n    void setEffectMtx(Mtx effectMtx) { mTexMtxInfo.setEffectMtx(effectMtx); }\n\nprivate:\n    /* 0x00 */ J3DTexMtxInfo mTexMtxInfo;\n    /* 0x64 */ Mtx mMtx;\n};  // Size: 0x94\n\nstruct J3DTexCoordInfo {\n    /* 0x0 */ u8 mTexGenType;\n    /* 0x1 */ u8 mTexGenSrc;\n    /* 0x2 */ u8 mTexGenMtx;\n    /* 0x3 */ u8 pad;\n};\n\nextern J3DTexCoordInfo const j3dDefaultTexCoordInfo[8];\n\nstruct J3DTexCoord : public J3DTexCoordInfo {\n    /* 8000E464 */ J3DTexCoord() {\n        setTexCoordInfo(j3dDefaultTexCoordInfo[0]);\n        resetTexMtxReg();\n    }\n    J3DTexCoord(J3DTexCoordInfo const& info) {\n        setTexCoordInfo(info);\n        resetTexMtxReg();\n    }\n    void setTexCoordInfo(J3DTexCoordInfo const& info) {\n        __memcpy(this, &info, sizeof(J3DTexCoordInfo));\n    }\n\n    u8 getTexGenType() { return mTexGenType; }\n    u8 getTexGenSrc() { return mTexGenSrc; }\n    u8 getTexGenMtx() { return mTexGenMtx & 0xff; }\n    u16 getTexMtxReg() { return mTexMtxReg & 0xff; }\n\n    void resetTexMtxReg() {\n        mTexMtxReg = mTexGenMtx;\n    }\n\n    /* 0x4 */ u16 mTexMtxReg;\n};  // Size: 0x6\n\n#endif /* J3DTEXTURE_H */\n/* end \"JSystem/J3DGraphBase/J3DTexture.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DMatBlock.h\" line 6 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nstruct J3DGXColorS10 : public GXColorS10 {\n    /* 8000E460 */ J3DGXColorS10() {}\n    J3DGXColorS10(J3DGXColorS10 const& other) { __memcpy(this, &other, sizeof(J3DGXColorS10)); }\n    J3DGXColorS10(GXColorS10 const& color) : GXColorS10(color) {}\n};\n\nstruct J3DGXColor : public GXColor {\n    /* 8000E538 */ J3DGXColor() {}\n    J3DGXColor(J3DGXColor const& other) { __memcpy(this, &other, sizeof(J3DGXColor)); }\n    J3DGXColor(GXColor const& color) : GXColor(color) {}\n};\n\nstruct J3DNBTScale : public J3DNBTScaleInfo {\n    J3DNBTScale() {}\n    J3DNBTScale(J3DNBTScaleInfo const& info) {\n        mbHasScale = info.mbHasScale;\n        mScale = info.mScale;\n    }\n    Vec* getScale() { return &mScale; }\n};\n\nextern const J3DNBTScaleInfo j3dDefaultNBTScaleInfo;\n\nclass J3DTexGenBlock {\npublic:\n    /* 80317354 */ virtual void reset(J3DTexGenBlock*);\n    virtual void calc(f32 const (*)[4]) = 0;\n    virtual void calcWithoutViewMtx(f32 const (*)[4]) = 0;\n    virtual void calcPostTexMtx(f32 const (*)[4]) = 0;\n    virtual void calcPostTexMtxWithoutViewMtx(f32 const (*)[4]) = 0;\n    virtual void load() = 0;\n    virtual void patch() = 0;\n    virtual void diff(u32) = 0;\n    virtual void diffTexMtx() = 0;\n    virtual void diffTexGen() = 0;\n    /* 803172FC */ virtual s32 countDLSize();\n    virtual u32 getType() = 0;\n    /* 8031741C */ virtual void setTexGenNum(u32 const*);\n    /* 8000E0D0 */ virtual void setTexGenNum(u32);\n    /* 8000DFE8 */ virtual u32 getTexGenNum() const;\n    /* 8000E0CC */ virtual void setTexCoord(u32, J3DTexCoord const*);\n    /* 8000DFE0 */ virtual J3DTexCoord* getTexCoord(u32);\n    /* 8003AB2C */ virtual void setTexMtx(u32, J3DTexMtx*);\n    /* 8000DFD8 */ virtual J3DTexMtx* getTexMtx(u32);\n    /* 80317424 */ virtual void setNBTScale(J3DNBTScale const*);\n    /* 80317420 */ virtual void setNBTScale(J3DNBTScale);\n    /* 80317334 */ virtual J3DNBTScale* getNBTScale();\n    /* 80317428 */ virtual bool getTexMtxOffset() const;\n    /* 80317430 */ virtual void setTexMtxOffset(u32);\n    /* 803171DC */ virtual ~J3DTexGenBlock() {}\n};\n\nstruct J3DTexGenBlockNull : public J3DTexGenBlock {\n    /* 80332AA0 */ virtual void calc(f32 const (*)[4]); // {}\n    /* 80332AA4 */ virtual void calcWithoutViewMtx(f32 const (*)[4]); // {}\n    /* 80332AA8 */ virtual void calcPostTexMtx(f32 const (*)[4]); // {}\n    /* 80332AAC */ virtual void calcPostTexMtxWithoutViewMtx(f32 const (*)[4]); // {}\n    /* 80332AB0 */ virtual void load(); // {}\n    /* 80332AB4 */ virtual void patch(); // {}\n    /* 80332AB8 */ virtual void diff(u32); // {}\n    /* 80332ABC */ virtual void diffTexMtx(); // {}\n    /* 80332AC0 */ virtual void diffTexGen(); // {}\n    /* 80332AC4 */ virtual u32 getType(); // { return 'TGNL'; }\n    /* 80332AD0 */ virtual ~J3DTexGenBlockNull(); // {}\n};\n\nclass J3DTexGenBlockPatched : public J3DTexGenBlock {\npublic:\n    J3DTexGenBlockPatched() {\n        initialize();\n    }\n    /* 80317644 */ void initialize();\n\n    /* 80320084 */ virtual void reset(J3DTexGenBlock*);\n    /* 803213C0 */ virtual void calc(f32 const (*)[4]);\n    /* 80321584 */ virtual void calcWithoutViewMtx(f32 const (*)[4]);\n    /* 803216D8 */ virtual void calcPostTexMtx(f32 const (*)[4]);\n    /* 8032181C */ virtual void calcPostTexMtxWithoutViewMtx(f32 const (*)[4]);\n    /* 80322E70 */ virtual void load();\n    /* 8031AA88 */ virtual void patch();\n    /* 8031AC68 */ virtual void diff(u32);\n    /* 8031ACD0 */ virtual void diffTexMtx();\n    /* 8031AD30 */ virtual void diffTexGen();\n    /* 80317B9C */ virtual s32 countDLSize();\n    /* 80322E74 */ virtual u32 getType();\n    /* 80322D3C */ virtual void setTexGenNum(u32 const*);\n    /* 80322D34 */ virtual void setTexGenNum(u32);\n    /* 80322D48 */ virtual u32 getTexGenNum() const;\n    /* 80322D50 */ virtual void setTexCoord(u32, J3DTexCoord const*);\n    /* 80322D64 */ virtual J3DTexCoord* getTexCoord(u32);\n    /* 80322D78 */ virtual void setTexMtx(u32, J3DTexMtx*);\n    /* 80322D88 */ virtual J3DTexMtx* getTexMtx(u32);\n    /* 80322D98 */ virtual bool getTexMtxOffset() const;\n    /* 80322DA0 */ virtual void setTexMtxOffset(u32);\n    /* 80317180 */ virtual ~J3DTexGenBlockPatched();\n\nprivate:\n    /* 0x04 */ u32 mTexGenNum;\n    /* 0x08 */ J3DTexCoord mTexCoord[8];\n    /* 0x38 */ J3DTexMtx* mTexMtx[8];\n    /* 0x58 */ u32 mTexMtxOffset;\n};  // Size: 0x5C\n\nclass J3DTexGenBlockBasic : public J3DTexGenBlockPatched {\npublic:\n    J3DTexGenBlockBasic() : mNBTScale(j3dDefaultNBTScaleInfo) {\n        initialize();\n    }\n    /* 803176A4 */ void initialize();\n\n    /* 803202DC */ virtual void reset(J3DTexGenBlock*);\n    /* 8031A9E8 */ virtual void load();\n    /* 8031ABC0 */ virtual void patch();\n    /* 80317BAC */ virtual s32 countDLSize();\n    /* 80322C6C */ virtual u32 getType();\n    /* 80322C9C */ virtual void setNBTScale(J3DNBTScale const*);\n    /* 80322C78 */ virtual void setNBTScale(J3DNBTScale);\n    /* 80322CC0 */ virtual J3DNBTScale* getNBTScale();\n    /* 80322CC8 */ virtual ~J3DTexGenBlockBasic();\n\nprivate:\n    /* 0x5C */ J3DNBTScale mNBTScale;\n};  // Size: 0x6C\n\nclass J3DTexGenBlock4 : public J3DTexGenBlockPatched {\npublic:\n    J3DTexGenBlock4() : mNBTScale(j3dDefaultNBTScaleInfo) {\n        initialize();\n    }\n    /* 80317674 */ void initialize();\n\n    /* 803201A0 */ virtual void reset(J3DTexGenBlock*);\n    /* 8031A948 */ virtual void load();\n    /* 8031AB18 */ virtual void patch();\n    /* 80317BA4 */ virtual s32 countDLSize();\n    /* 80322DA8 */ virtual u32 getType();\n    /* 80322DD8 */ virtual void setNBTScale(J3DNBTScale const*);\n    /* 80322DB4 */ virtual void setNBTScale(J3DNBTScale);\n    /* 80322DFC */ virtual J3DNBTScale* getNBTScale();\n    /* 80322E04 */ virtual ~J3DTexGenBlock4();\n\nprivate:\n    /* 0x5C */ J3DNBTScale mNBTScale;\n};  // Size: 0x6C\n\nclass J3DTevBlock {\npublic:\n    /* 80317350 */ virtual void reset(J3DTevBlock*);\n    /* 80317330 */ virtual void load();\n    /* 8031CD44 */ virtual void diff(u32);\n    /* 80321948 */ virtual void diffTexNo();\n    /* 80321938 */ virtual void diffTevReg();\n    /* 80321944 */ virtual void diffTexCoordScale();\n    /* 80321940 */ virtual void diffTevStage();\n    /* 8032193C */ virtual void diffTevStageIndirect();\n    /* 8000DBD4 */ virtual void patch();\n    /* 8032353C */ virtual void patchTexNo();\n    /* 80323540 */ virtual void patchTevReg();\n    /* 8000DBC8 */ virtual void patchTexNoAndTexCoordScale();\n    virtual void ptrToIndex() = 0;\n    virtual void indexToPtr() = 0;\n    virtual u32 getType() = 0;\n    /* 8031730C */ virtual s32 countDLSize();\n    /* 80323544 */ virtual void setTexNo(u32, u16 const*);\n    /* 8000E0AC */ virtual void setTexNo(u32, u16);\n    /* 8000DF94 */ virtual u16 getTexNo(u32) const;\n    /* 80323548 */ virtual void setTevOrder(u32, J3DTevOrder const*);\n    /* 8000E0BC */ virtual void setTevOrder(u32, J3DTevOrder);\n    /* 8000DFB8 */ virtual J3DTevOrder* getTevOrder(u32);\n    /* 80110E80 */ virtual void setTevColor(u32, J3DGXColorS10 const*);\n    /* 8000E0C4 */ virtual void setTevColor(u32, J3DGXColorS10);\n    /* 8000DFC8 */ virtual _GXColorS10* getTevColor(u32);\n    /* 800732AC */ virtual void setTevKColor(u32, J3DGXColor const*);\n    /* 8000E0C0 */ virtual void setTevKColor(u32, J3DGXColor);\n    /* 8000DFC0 */ virtual _GXColor* getTevKColor(u32);\n    /* 80322950 */ virtual void setTevKColorSel(u32, u8 const*);\n    /* 8000E0B8 */ virtual void setTevKColorSel(u32, u8);\n    /* 8000DFB0 */ virtual bool getTevKColorSel(u32);\n    /* 80322954 */ virtual void setTevKAlphaSel(u32, u8 const*);\n    /* 8000E0B4 */ virtual void setTevKAlphaSel(u32, u8);\n    /* 8000DFA8 */ virtual bool getTevKAlphaSel(u32);\n    /* 8032354C */ virtual void setTevStageNum(u8 const*);\n    /* 8000E0C8 */ virtual void setTevStageNum(u8);\n    /* 8000DFD0 */ virtual u8 getTevStageNum() const;\n    /* 80323550 */ virtual void setTevStage(u32, J3DTevStage const*);\n    /* 8000E0A8 */ virtual void setTevStage(u32, J3DTevStage);\n    /* 8000DF8C */ virtual J3DTevStage* getTevStage(u32);\n    /* 8032295C */ virtual void setTevSwapModeInfo(u32, J3DTevSwapModeInfo const*);\n    /* 80322958 */ virtual void setTevSwapModeInfo(u32, J3DTevSwapModeInfo);\n    /* 80322960 */ virtual void setTevSwapModeTable(u32, J3DTevSwapModeTable const*);\n    /* 8000E0B0 */ virtual void setTevSwapModeTable(u32, J3DTevSwapModeTable);\n    /* 8000DFA0 */ virtual bool getTevSwapModeTable(u32);\n    /* 80323554 */ virtual void setIndTevStage(u32, J3DIndTevStage const*);\n    /* 8000E0A4 */ virtual void setIndTevStage(u32, J3DIndTevStage);\n    /* 8000DF84 */ virtual bool getIndTevStage(u32);\n    /* 80323558 */ virtual bool getTexNoOffset() const;\n    /* 80322964 */ virtual bool getTevRegOffset() const;\n    /* 80321FE0 */ virtual void setTexNoOffset(u32);\n    /* 8032296C */ virtual void setTevRegOffset(u32);\n    /* 80317224 */ virtual ~J3DTevBlock() {}\n\nprotected:\n    /* 8031E098 */ void indexToPtr_private(u32);\n\n    /* 0x4 */ u32 mTexNoOffset;\n};\n\nclass J3DTevBlockNull : public J3DTevBlock {\npublic:\n    J3DTevBlockNull() { initialize(); }\n    /* 803176D4 */ void initialize();\n    /* 80332A0C */ virtual void reset(J3DTevBlock*); // {}\n    /* 80332A10 */ virtual void ptrToIndex(); // {}\n    /* 80332A14 */ virtual void indexToPtr(); // { indexToPtr_private(mTexNoOffset); }\n    /* 80332A38 */ virtual u32 getType(); // { return 'TVNL'; }\n    /* 80332A44 */ virtual ~J3DTevBlockNull(); // {}\n};\n\nclass J3DTevBlockPatched : public J3DTevBlock {\npublic:\n    J3DTevBlockPatched() {\n        initialize();\n    }\n    /* 803176E0 */ void initialize();\n\n    /* 80320418 */ virtual void reset(J3DTevBlock*);\n    /* 80322970 */ virtual void load();\n    /* 8031CE00 */ virtual void diffTexNo();\n    /* 8031D028 */ virtual void diffTevReg();\n    /* 8031D0C4 */ virtual void diffTexCoordScale();\n    /* 8031CE64 */ virtual void diffTevStage();\n    /* 8031CF78 */ virtual void diffTevStageIndirect();\n    /* 8031C228 */ virtual void patch();\n    /* 8031BF4C */ virtual void patchTexNo();\n    /* 8031BFE0 */ virtual void patchTevReg();\n    /* 8031C0AC */ virtual void patchTexNoAndTexCoordScale();\n    /* 8031DFB4 */ virtual void ptrToIndex();\n    /* 80322974 */ virtual void indexToPtr();\n    /* 80322998 */ virtual u32 getType();\n    /* 80317BB4 */ virtual s32 countDLSize();\n    /* 803229D0 */ virtual void setTexNo(u32, u16 const*);\n    /* 803229C0 */ virtual void setTexNo(u32, u16);\n    /* 803229E4 */ virtual u16 getTexNo(u32) const;\n    /* 80322A08 */ virtual void setTevOrder(u32, J3DTevOrder const*);\n    /* 803229F4 */ virtual void setTevOrder(u32, J3DTevOrder);\n    /* 80322A1C */ virtual J3DTevOrder* getTevOrder(u32);\n    /* 80322B24 */ virtual void setTevColor(u32, J3DGXColorS10 const*);\n    /* 80322AF8 */ virtual void setTevColor(u32, J3DGXColorS10);\n    /* 80322B50 */ virtual GXColorS10* getTevColor(u32);\n    /* 80322B90 */ virtual void setTevKColor(u32, J3DGXColor const*);\n    /* 80322B64 */ virtual void setTevKColor(u32, J3DGXColor);\n    /* 80322BBC */ virtual GXColor* getTevKColor(u32);\n    /* 80322BDC */ virtual void setTevKColorSel(u32, u8 const*);\n    /* 80322BD0 */ virtual void setTevKColorSel(u32, u8);\n    /* 80322BEC */ virtual bool getTevKColorSel(u32);\n    /* 803229AC */ virtual void setTevStageNum(u8 const*);\n    /* 803229A4 */ virtual void setTevStageNum(u8);\n    /* 803229B8 */ virtual u8 getTevStageNum() const;\n    /* 80322A6C */ virtual void setTevStage(u32, J3DTevStage const*);\n    /* 80322A30 */ virtual void setTevStage(u32, J3DTevStage);\n    /* 80322AA8 */ virtual J3DTevStage* getTevStage(u32);\n    /* 80322AD0 */ virtual void setIndTevStage(u32, J3DIndTevStage const*);\n    /* 80322ABC */ virtual void setIndTevStage(u32, J3DIndTevStage);\n    /* 80322AE4 */ virtual bool getIndTevStage(u32);\n    /* 80322BF8 */ virtual bool getTexNoOffset() const;\n    /* 80322C00 */ virtual bool getTevRegOffset() const;\n    /* 80322C08 */ virtual void setTevRegOffset(u32);\n    /* 80322C10 */ virtual ~J3DTevBlockPatched();\n\nprivate:\n    /* 0x08 */ u16 mTexNo[8];\n    /* 0x18 */ J3DTevOrder mTevOrder[8];\n    /* 0x38 */ J3DTevStage mTevStage[8];\n    /* 0x78 */ J3DIndTevStage mIndTevStage[8];\n    /* 0x98 */ J3DGXColorS10 mTevColor[4];\n    /* 0xB8 */ J3DGXColor mTevKColor[4];\n    /* 0xC8 */ u8 mTevKColorSel[8];\n    /* 0xD0 */ u8 mTevStageNum;\n    /* 0xD4 */ u32 mTevRegOffset;\n};  // Size: 0xD8\n\nclass J3DTevBlock4 : public J3DTevBlock {\npublic:\n    J3DTevBlock4() {\n        initialize();\n    }\n    /* 803178EC */ void initialize();\n\n    /* 8032098C */ virtual void reset(J3DTevBlock*);\n    /* 8031B4C0 */ virtual void load();\n    /* 8031D758 */ virtual void diffTexNo();\n    /* 8031D7BC */ virtual void diffTevReg();\n    /* 8031DA1C */ virtual void diffTexCoordScale();\n    /* 8031D858 */ virtual void diffTevStage();\n    /* 8031D96C */ virtual void diffTevStageIndirect();\n    /* 8031C9D0 */ virtual void patch();\n    /* 8031C6F4 */ virtual void patchTexNo();\n    /* 8031C788 */ virtual void patchTevReg();\n    /* 8031C854 */ virtual void patchTexNoAndTexCoordScale();\n    /* 80321FE8 */ virtual void ptrToIndex();\n    /* 80321FEC */ virtual void indexToPtr();\n    /* 80322010 */ virtual u32 getType();\n    /* 80317BCC */ virtual s32 countDLSize();\n    /* 8032202C */ virtual void setTexNo(u32, u16 const*);\n    /* 8032201C */ virtual void setTexNo(u32, u16);\n    /* 80322040 */ virtual u16 getTexNo(u32) const;\n    /* 80322064 */ virtual void setTevOrder(u32, J3DTevOrder const*);\n    /* 80322050 */ virtual void setTevOrder(u32, J3DTevOrder);\n    /* 80322078 */ virtual J3DTevOrder* getTevOrder(u32);\n    /* 803220B8 */ virtual void setTevColor(u32, J3DGXColorS10 const*);\n    /* 8032208C */ virtual void setTevColor(u32, J3DGXColorS10);\n    /* 803220E4 */ virtual GXColorS10* getTevColor(u32);\n    /* 80322124 */ virtual void setTevKColor(u32, J3DGXColor const*);\n    /* 803220F8 */ virtual void setTevKColor(u32, J3DGXColor);\n    /* 80322150 */ virtual GXColor* getTevKColor(u32);\n    /* 80322170 */ virtual void setTevKColorSel(u32, u8 const*);\n    /* 80322164 */ virtual void setTevKColorSel(u32, u8);\n    /* 80322180 */ virtual bool getTevKColorSel(u32);\n    /* 80322198 */ virtual void setTevKAlphaSel(u32, u8 const*);\n    /* 8032218C */ virtual void setTevKAlphaSel(u32, u8);\n    /* 803221A8 */ virtual bool getTevKAlphaSel(u32);\n    /* 803221BC */ virtual void setTevStageNum(u8 const*);\n    /* 803221B4 */ virtual void setTevStageNum(u8);\n    /* 803221C8 */ virtual u8 getTevStageNum() const;\n    /* 8032220C */ virtual void setTevStage(u32, J3DTevStage const*);\n    /* 803221D0 */ virtual void setTevStage(u32, J3DTevStage);\n    /* 80322248 */ virtual J3DTevStage* getTevStage(u32);\n    /* 80322294 */ virtual void setTevSwapModeInfo(u32, J3DTevSwapModeInfo const*);\n    /* 8032225C */ virtual void setTevSwapModeInfo(u32, J3DTevSwapModeInfo);\n    /* 803222DC */ virtual void setTevSwapModeTable(u32, J3DTevSwapModeTable const*);\n    /* 803222CC */ virtual void setTevSwapModeTable(u32, J3DTevSwapModeTable);\n    /* 803222EC */ virtual bool getTevSwapModeTable(u32);\n    /* 80322310 */ virtual void setIndTevStage(u32, J3DIndTevStage const*);\n    /* 803222FC */ virtual void setIndTevStage(u32, J3DIndTevStage);\n    /* 80322324 */ virtual bool getIndTevStage(u32);\n    /* 80322338 */ virtual bool getTexNoOffset() const;\n    /* 80322340 */ virtual bool getTevRegOffset() const;\n    /* 80322348 */ virtual void setTevRegOffset(u32);\n    /* 80322350 */ virtual ~J3DTevBlock4();\n\nprivate:\n    /* 0x08 */ u16 mTexNo[4];\n    /* 0x10 */ J3DTevOrder mTevOrder[4];\n    /* 0x20 */ u8 mTevStageNum;\n    /* 0x21 */ J3DTevStage mTevStage[4];\n    /* 0x42 */ J3DGXColorS10 mTevColor[4];\n    /* 0x62 */ J3DGXColor mTevKColor[4];\n    /* 0x72 */ u8 mTevKColorSel[4];\n    /* 0x76 */ u8 mTevKAlphaSel[4];\n    /* 0x7A */ J3DTevSwapModeTable mTevSwapModeTable[4];\n    /* 0x80 */ J3DIndTevStage mIndTevStage[4];\n    /* 0x90 */ u32 mTevRegOffset;\n};  // Size: 0x94\n\nclass J3DTevBlock2 : public J3DTevBlock {\npublic:\n    J3DTevBlock2() {\n        initialize();\n    }\n    /* 80317810 */ void initialize();\n\n    /* 803206AC */ virtual void reset(J3DTevBlock*);\n    /* 8031AFA4 */ virtual void load();\n    /* 8031D3D0 */ virtual void diffTexNo();\n    /* 8031D434 */ virtual void diffTevReg();\n    /* 8031D694 */ virtual void diffTexCoordScale();\n    /* 8031D4D0 */ virtual void diffTevStage();\n    /* 8031D5E4 */ virtual void diffTevStageIndirect();\n    /* 8031C6A8 */ virtual void patch();\n    /* 8031C3F8 */ virtual void patchTexNo();\n    /* 8031C48C */ virtual void patchTevReg();\n    /* 8031C558 */ virtual void patchTexNoAndTexCoordScale();\n    /* 803223AC */ virtual void ptrToIndex();\n    /* 803223B0 */ virtual void indexToPtr();\n    /* 803223D4 */ virtual u32 getType();\n    /* 80317BC4 */ virtual s32 countDLSize();\n    /* 803223F0 */ virtual void setTexNo(u32, u16 const*);\n    /* 803223E0 */ virtual void setTexNo(u32, u16);\n    /* 80322404 */ virtual u16 getTexNo(u32) const;\n    /* 80322428 */ virtual void setTevOrder(u32, J3DTevOrder const*);\n    /* 80322414 */ virtual void setTevOrder(u32, J3DTevOrder);\n    /* 8032243C */ virtual J3DTevOrder* getTevOrder(u32);\n    /* 8032247C */ virtual void setTevColor(u32, J3DGXColorS10 const*);\n    /* 80322450 */ virtual void setTevColor(u32, J3DGXColorS10);\n    /* 803224A8 */ virtual GXColorS10* getTevColor(u32);\n    /* 803224E8 */ virtual void setTevKColor(u32, J3DGXColor const*);\n    /* 803224BC */ virtual void setTevKColor(u32, J3DGXColor);\n    /* 80322514 */ virtual GXColor* getTevKColor(u32);\n    /* 80322534 */ virtual void setTevKColorSel(u32, u8 const*);\n    /* 80322528 */ virtual void setTevKColorSel(u32, u8);\n    /* 80322544 */ virtual bool getTevKColorSel(u32);\n    /* 8032255C */ virtual void setTevKAlphaSel(u32, u8 const*);\n    /* 80322550 */ virtual void setTevKAlphaSel(u32, u8);\n    /* 8032256C */ virtual bool getTevKAlphaSel(u32);\n    /* 80322580 */ virtual void setTevStageNum(u8 const*);\n    /* 80322578 */ virtual void setTevStageNum(u8);\n    /* 8032258C */ virtual u8 getTevStageNum() const;\n    /* 803225D0 */ virtual void setTevStage(u32, J3DTevStage const*);\n    /* 80322594 */ virtual void setTevStage(u32, J3DTevStage);\n    /* 8032260C */ virtual J3DTevStage* getTevStage(u32);\n    /* 80322658 */ virtual void setTevSwapModeInfo(u32, J3DTevSwapModeInfo const*);\n    /* 80322620 */ virtual void setTevSwapModeInfo(u32, J3DTevSwapModeInfo);\n    /* 803226A0 */ virtual void setTevSwapModeTable(u32, J3DTevSwapModeTable const*);\n    /* 80322690 */ virtual void setTevSwapModeTable(u32, J3DTevSwapModeTable);\n    /* 803226B0 */ virtual bool getTevSwapModeTable(u32);\n    /* 803226D4 */ virtual void setIndTevStage(u32, J3DIndTevStage const*);\n    /* 803226C0 */ virtual void setIndTevStage(u32, J3DIndTevStage);\n    /* 803226E8 */ virtual bool getIndTevStage(u32);\n    /* 803226FC */ virtual bool getTexNoOffset() const;\n    /* 80322704 */ virtual bool getTevRegOffset() const;\n    /* 8032270C */ virtual void setTevRegOffset(u32);\n    /* 80322714 */ virtual ~J3DTevBlock2();\n\nprivate:\n    /* 0x08 */ u16 mTexNo[2];\n    /* 0x0C */ J3DTevOrder mTevOrder[2];\n    /* 0x14 */ J3DGXColorS10 mTevColor[4];\n    /* 0x34 */ u8 mTevStageNum;\n    /* 0x35 */ J3DTevStage mTevStage[2];\n    /* 0x45 */ J3DGXColor mTevKColor[4];\n    /* 0x55 */ u8 mTevKColorSel[2];\n    /* 0x57 */ u8 mTevKAlphaSel[2];\n    /* 0x59 */ J3DTevSwapModeTable mTevSwapModeTable[4];\n    /* 0x60 */ J3DIndTevStage mIndTevStage[2];\n    /* 0x68 */ u32 mTevRegOffset;\n};  // Size: 0x6C\n\nclass J3DTevBlock16 : public J3DTevBlock {\npublic:\n    J3DTevBlock16() {\n        initialize();\n    }\n    /* 80317A00 */ void initialize();\n\n    /* 80320E24 */ virtual void reset(J3DTevBlock*);\n    /* 8031BA04 */ virtual void load();\n    /* 8031DB14 */ virtual void diffTexNo();\n    /* 8031DB78 */ virtual void diffTevReg();\n    /* 8031DDD8 */ virtual void diffTexCoordScale();\n    /* 8031DC14 */ virtual void diffTevStage();\n    /* 8031DD28 */ virtual void diffTevStageIndirect();\n    /* 8031CCF8 */ virtual void patch();\n    /* 8031CA1C */ virtual void patchTexNo();\n    /* 8031CAB0 */ virtual void patchTevReg();\n    /* 8031CB7C */ virtual void patchTexNoAndTexCoordScale();\n    /* 8031DED0 */ virtual void ptrToIndex();\n    /* 80321C20 */ virtual void indexToPtr();\n    /* 80321C44 */ virtual u32 getType();\n    /* 80317BD4 */ virtual s32 countDLSize();\n    /* 80321C60 */ virtual void setTexNo(u32, u16 const*);\n    /* 80321C50 */ virtual void setTexNo(u32, u16);\n    /* 80321C74 */ virtual u16 getTexNo(u32) const;\n    /* 80321C98 */ virtual void setTevOrder(u32, J3DTevOrder const*);\n    /* 80321C84 */ virtual void setTevOrder(u32, J3DTevOrder);\n    /* 80321CAC */ virtual J3DTevOrder* getTevOrder(u32);\n    /* 80321CEC */ virtual void setTevColor(u32, J3DGXColorS10 const*);\n    /* 80321CC0 */ virtual void setTevColor(u32, J3DGXColorS10);\n    /* 80321D18 */ virtual GXColorS10* getTevColor(u32);\n    /* 80321D58 */ virtual void setTevKColor(u32, J3DGXColor const*);\n    /* 80321D2C */ virtual void setTevKColor(u32, J3DGXColor);\n    /* 80321D84 */ virtual GXColor* getTevKColor(u32);\n    /* 80321DA4 */ virtual void setTevKColorSel(u32, u8 const*);\n    /* 80321D98 */ virtual void setTevKColorSel(u32, u8);\n    /* 80321DB4 */ virtual bool getTevKColorSel(u32);\n    /* 80321DCC */ virtual void setTevKAlphaSel(u32, u8 const*);\n    /* 80321DC0 */ virtual void setTevKAlphaSel(u32, u8);\n    /* 80321DDC */ virtual bool getTevKAlphaSel(u32);\n    /* 80321DE8 */ virtual void setTevStageNum(u8);\n    /* 80321DF0 */ virtual void setTevStageNum(u8 const*);\n    /* 80321DFC */ virtual u8 getTevStageNum() const;\n    /* 80321E40 */ virtual void setTevStage(u32, J3DTevStage const*);\n    /* 80321E04 */ virtual void setTevStage(u32, J3DTevStage);\n    /* 80321E7C */ virtual J3DTevStage* getTevStage(u32);\n    /* 80321EC8 */ virtual void setTevSwapModeInfo(u32, J3DTevSwapModeInfo const*);\n    /* 80321E90 */ virtual void setTevSwapModeInfo(u32, J3DTevSwapModeInfo);\n    /* 80321F10 */ virtual void setTevSwapModeTable(u32, J3DTevSwapModeTable const*);\n    /* 80321F00 */ virtual void setTevSwapModeTable(u32, J3DTevSwapModeTable);\n    /* 80321F20 */ virtual bool getTevSwapModeTable(u32);\n    /* 80321F44 */ virtual void setIndTevStage(u32, J3DIndTevStage const*);\n    /* 80321F30 */ virtual void setIndTevStage(u32, J3DIndTevStage);\n    /* 80321F58 */ virtual bool getIndTevStage(u32);\n    /* 80321F6C */ virtual bool getTexNoOffset() const;\n    /* 80321F74 */ virtual bool getTevRegOffset() const;\n    /* 80321F7C */ virtual void setTevRegOffset(u32);\n    /* 80321F84 */ virtual ~J3DTevBlock16();\n\nprivate:\n    /* 0x008 */ u16 mTexNo[8];\n    /* 0x018 */ J3DTevOrder mTevOrder[16];\n    /* 0x058 */ u8 mTevStageNum;\n    /* 0x059 */ J3DTevStage mTevStage[16];\n    /* 0x0DA */ J3DGXColorS10 mTevColor[4];\n    /* 0x0FA */ J3DGXColor mTevKColor[4];\n    /* 0x10A */ u8 mTevKColorSel[16];\n    /* 0x11A */ u8 mTevKAlphaSel[16];\n    /* 0x12A */ J3DTevSwapModeTable mTevSwapModeTable[4];\n    /* 0x130 */ J3DIndTevStage mIndTevStage[16];\n    /* 0x170 */ u32 mTevRegOffset;\n};  // Size: 0x174\n\nclass J3DTevBlock1 : public J3DTevBlock {\npublic:\n    J3DTevBlock1() {\n        initialize();\n    }\n    /* 803177E8 */ void initialize();\n\n    /* 803205D4 */ virtual void reset(J3DTevBlock*);\n    /* 8031AD64 */ virtual void load();\n    /* 8031D1BC */ virtual void diffTexNo();\n    /* 8031D1F4 */ virtual void diffTevReg();\n    /* 8031D368 */ virtual void diffTexCoordScale();\n    /* 8031D1F8 */ virtual void diffTevStage();\n    /* 8031D2E8 */ virtual void diffTevStageIndirect();\n    /* 8031C3CC */ virtual void patch();\n    /* 8031C274 */ virtual void patchTexNo();\n    /* 8031C2E4 */ virtual void patchTevReg();\n    /* 8031C2E8 */ virtual void patchTexNoAndTexCoordScale();\n    /* 80322770 */ virtual void ptrToIndex();\n    /* 80322774 */ virtual void indexToPtr();\n    /* 80322798 */ virtual u32 getType();\n    /* 80317BBC */ virtual s32 countDLSize();\n    /* 803227B4 */ virtual void setTexNo(u32, u16 const*);\n    /* 803227A4 */ virtual void setTexNo(u32, u16);\n    /* 803227C8 */ virtual u16 getTexNo(u32) const;\n    /* 803227EC */ virtual void setTevOrder(u32, J3DTevOrder const*);\n    /* 803227D8 */ virtual void setTevOrder(u32, J3DTevOrder);\n    /* 80322800 */ virtual J3DTevOrder* getTevOrder(u32);\n    /* 80322818 */ virtual void setTevStageNum(u8 const*);\n    /* 80322814 */ virtual void setTevStageNum(u8);\n    /* 8032281C */ virtual u8 getTevStageNum() const;\n    /* 80322860 */ virtual void setTevStage(u32, J3DTevStage const*);\n    /* 80322824 */ virtual void setTevStage(u32, J3DTevStage);\n    /* 8032289C */ virtual J3DTevStage* getTevStage(u32);\n    /* 803228C4 */ virtual void setIndTevStage(u32, J3DIndTevStage const*);\n    /* 803228B0 */ virtual void setIndTevStage(u32, J3DIndTevStage);\n    /* 803228D8 */ virtual bool getIndTevStage(u32);\n    /* 803228EC */ virtual bool getTexNoOffset() const;\n    /* 803228F4 */ virtual ~J3DTevBlock1();\n\nprivate:\n    /* 0x08 */ u16 mTexNo[1];\n    /* 0x0A */ J3DTevOrder mTevOrder[1];\n    /* 0x0E */ J3DTevStage mTevStage[1];\n    /* 0x18 */ J3DIndTevStage mIndTevStage[1];\n};  // Size: 0x1C\n\nextern const u16 j3dDefaultZModeID;\n\ninline u16 calcZModeID(u8 param_0, u8 param_1, u8 param_2) {\n    return param_1 * 2 + param_0 * 0x10 + param_2;\n}\n\nstruct J3DZModeInfo {\n    /* 0x0 */ u8 field_0x0;\n    /* 0x1 */ u8 field_0x1;\n    /* 0x2 */ u8 field_0x2;\n    /* 0x3 */ u8 pad;\n};\n\nstruct J3DZMode {\n    J3DZMode() : mZModeID(j3dDefaultZModeID) {}\n    J3DZMode(J3DZModeInfo const& info) : mZModeID(calcZModeID(info.field_0x0, info.field_0x1, info.field_0x2)) {}\n\n    void setZModeInfo(const J3DZModeInfo& info) {\n        mZModeID = calcZModeID(info.field_0x0, info.field_0x1, info.field_0x2);\n    }\n\n    /* 0x0 */ u16 mZModeID;\n};\n\nstruct J3DBlendInfo {\n    void operator=(J3DBlendInfo const& other) {\n        *(int*)&mType = *(int*)&other.mType;\n    }\n    /* 0x0 */ u8 mType;\n    /* 0x1 */ u8 mSrcFactor;\n    /* 0x2 */ u8 mDstFactor;\n    /* 0x3 */ u8 mOp;\n};\n\nextern const J3DBlendInfo j3dDefaultBlendInfo;\n\nstruct J3DBlend : public J3DBlendInfo {\n    J3DBlend() : J3DBlendInfo(j3dDefaultBlendInfo) {}\n    J3DBlend(J3DBlendInfo const& info) : J3DBlendInfo(info) {}\n};\n\nextern const J3DFogInfo j3dDefaultFogInfo;\n\nstruct J3DFog : public J3DFogInfo {\n    J3DFog() { *(J3DFogInfo*)this = j3dDefaultFogInfo; }\n    J3DFogInfo* getFogInfo() { return this; }\n    void setFogInfo(J3DFogInfo info) { *(J3DFogInfo*)this = info; }\n};\n\nstruct J3DAlphaCompInfo {\n    /* 0x0 */ u8 field_0x0;\n    /* 0x1 */ u8 field_0x1;\n    /* 0x2 */ u8 mRef0;\n    /* 0x3 */ u8 mRef1;\n    /* 0x4 */ u8 field_0x4;\n    /* 0x5 */ u8 field_0x5;\n    /* 0x6 */ u8 field_0x6;\n    /* 0x7 */ u8 field_0x7;\n};\n\nextern const u16 j3dDefaultAlphaCmpID;\n\ninline u32 calcAlphaCmpID(u32 param_1, u32 param_2, u32 param_3) {\n    return ((param_1 & 0xff) << 5) + ((param_2 & 0xff) << 3) + (param_3 & 0xff);\n}\n\n// matches for `J3DMaterialFactory::newAlphaComp` but fails for `d_resorce::addWarpMaterial`\n// inline u32 calcAlphaCmpID(u8 param_1, u8 param_2, u8 param_3) {\n//     return param_1 * 0x20 + param_2 * 8 + param_3;\n// }\n\nstruct J3DAlphaComp {\n    J3DAlphaComp() : mID(j3dDefaultAlphaCmpID), mRef0(0), mRef1(0) {}\n    J3DAlphaComp(u16 id) : mID(id), mRef0(0), mRef1(0) {}\n    J3DAlphaComp(J3DAlphaCompInfo const& info) :\n        mID(calcAlphaCmpID(info.field_0x0, info.mRef0, info.mRef1)),\n        mRef0(info.field_0x1),\n        mRef1(info.field_0x4)\n        {}\n\n    void setAlphaCompInfo(const J3DAlphaCompInfo& param_1) {\n        mRef0 = param_1.field_0x1;\n        mRef1 = param_1.field_0x4;\n        u32 p1_mref1 = param_1.mRef1;\n        mID = calcAlphaCmpID(param_1.field_0x0, param_1.mRef0, p1_mref1);\n\n        // this matches for `dKy_bg_MAxx_proc` but causes `addWarpMaterial` to fail,\n        // while the above matches for `addWarpMaterial` but causes `dKy_bg_MAxx_proc` to fail?\n        // mID = calcAlphaCmpID(param_1.field_0x0, param_1.mRef0, param_1.mRef1);\n    }\n\n    /* 0x00 */ u16 mID;\n    /* 0x02 */ u8 mRef0;\n    /* 0x03 */ u8 mRef1;\n};  // Size: 0x4\n\nclass J3DPEBlock {\npublic:\n    /* 80317348 */ virtual void reset(J3DPEBlock*);\n    virtual void load() = 0;\n    /* 8000DBCC */ virtual void patch();\n    /* 80317344 */ virtual void diff(u32);\n    /* 8031735C */ virtual void diffFog();\n    /* 80317360 */ virtual void diffBlend();\n    virtual s32 countDLSize();\n    virtual u32 getType() = 0;\n    /* 80317368 */ virtual void setFog(J3DFog);\n    /* 80317364 */ virtual void setFog(J3DFog*);\n    /* 8000DF5C */ virtual J3DFog* getFog();\n    /* 8031736C */ virtual void setAlphaComp(J3DAlphaComp const*);\n    /* 8000E01C */ virtual void setAlphaComp(J3DAlphaComp const&);\n    /* 8000DF54 */ virtual J3DAlphaComp* getAlphaComp();\n    /* 80317370 */ virtual void setBlend(J3DBlend const*);\n    /* 8000E018 */ virtual void setBlend(J3DBlend const&);\n    /* 8000DF4C */ virtual bool getBlend();\n    /* 80317374 */ virtual void setZMode(J3DZMode const*);\n    /* 8000E014 */ virtual void setZMode(J3DZMode);\n    /* 8000DF44 */ virtual J3DZMode* getZMode();\n    /* 80317378 */ virtual void setZCompLoc(u8 const*);\n    /* 8000E010 */ virtual void setZCompLoc(u8);\n    /* 8000DF3C */ virtual bool getZCompLoc() const;\n    /* 80317380 */ virtual void setDither(u8 const*);\n    /* 8031737C */ virtual void setDither(u8);\n    /* 80317384 */ virtual bool getDither() const;\n    /* 8031738C */ virtual bool getFogOffset() const;\n    /* 80317394 */ virtual void setFogOffset(u32);\n    virtual ~J3DPEBlock() {}\n};\n\nstruct J3DPEBlockNull : public J3DPEBlock {\n    /* 803329A0 */ virtual void load(); // {}\n    /* 803329A4 */ virtual u32 getType(); // { return 'PENL'; }\n    /* 803329B0 */ virtual ~J3DPEBlockNull(); // {}\n};\n\nclass J3DPEBlockXlu : public J3DPEBlock {\npublic:\n    /* 8031E98C */ virtual void load();\n    /* 80317BF4 */ virtual s32 countDLSize();\n    /* 80323258 */ virtual u32 getType();\n    /* 80323264 */ virtual ~J3DPEBlockXlu();\n};\n\nclass J3DPEBlockTexEdge : public J3DPEBlock {\npublic:\n    /* 8031E6C8 */ virtual void load();\n    /* 80317BEC */ virtual s32 countDLSize();\n    /* 803232C0 */ virtual u32 getType();\n    /* 803232CC */ virtual ~J3DPEBlockTexEdge();\n};\n\nclass J3DPEBlockOpa : public J3DPEBlock {\npublic:\n    /* 8031E408 */ virtual void load();\n    /* 80317BE4 */ virtual s32 countDLSize();\n    /* 80323328 */ virtual u32 getType();\n    /* 80323334 */ virtual ~J3DPEBlockOpa();\n};\n\nclass J3DPEBlockFull : public J3DPEBlock {\npublic:\n    J3DPEBlockFull() {\n        initialize();\n    }\n    /* 80317B58 */ void initialize();\n\n    /* 8032129C */ virtual void reset(J3DPEBlock*);\n    /* 8031F3C0 */ virtual void load();\n    /* 8031F890 */ virtual void patch();\n    /* 8031FCA0 */ virtual void diff(u32);\n    /* 8031F940 */ virtual void diffFog();\n    /* 8031F9B8 */ virtual void diffBlend();\n    /* 80317C04 */ virtual s32 countDLSize();\n    /* 8032194C */ virtual u32 getType();\n    /* 8032197C */ virtual void setFog(J3DFog);\n    /* 80321958 */ virtual void setFog(J3DFog*);\n    /* 803219A0 */ virtual J3DFog* getFog();\n    /* 803219C4 */ virtual void setAlphaComp(J3DAlphaComp const*);\n    /* 803219A8 */ virtual void setAlphaComp(J3DAlphaComp const&);\n    /* 803219E0 */ virtual J3DAlphaComp* getAlphaComp();\n    /* 803219F4 */ virtual void setBlend(J3DBlend const*);\n    /* 803219E8 */ virtual void setBlend(J3DBlend const&);\n    /* 80321A00 */ virtual bool getBlend();\n    /* 80321A14 */ virtual void setZMode(J3DZMode const*);\n    /* 80321A08 */ virtual void setZMode(J3DZMode);\n    /* 80321A20 */ virtual J3DZMode* getZMode();\n    /* 80321A30 */ virtual void setZCompLoc(u8 const*);\n    /* 80321A28 */ virtual void setZCompLoc(u8);\n    /* 80321A3C */ virtual bool getZCompLoc() const;\n    /* 80321A4C */ virtual void setDither(u8 const*);\n    /* 80321A44 */ virtual void setDither(u8);\n    /* 80321A58 */ virtual bool getDither() const;\n    /* 80321A60 */ virtual bool getFogOffset() const;\n    /* 80321A68 */ virtual void setFogOffset(u32);\n    /* 80321A70 */ virtual ~J3DPEBlockFull();\n\nprivate:\n    /* 0x04 */ J3DFog mFog;\n    /* 0x30 */ J3DAlphaComp mAlphaComp;\n    /* 0x34 */ J3DBlend mBlend;\n    /* 0x38 */ J3DZMode mZMode;\n    /* 0x3A */ u8 mZCompLoc;\n    /* 0x3B */ u8 mDither;\n    /* 0x3C */ u32 mFogOffset;\n};  // Size: 0x40\n\nclass J3DPEBlockFogOff : public J3DPEBlock {\npublic:\n    J3DPEBlockFogOff() {\n        initialize();\n    }\n    /* 80317B34 */ void initialize();\n\n    /* 803211B4 */ virtual void reset(J3DPEBlock*);\n    /* 8031EC50 */ virtual void load();\n    /* 80321ACC */ virtual void diff(u32);\n    /* 8031F0D8 */ virtual void diffBlend();\n    /* 80317BFC */ virtual s32 countDLSize();\n    /* 80321B00 */ virtual u32 getType();\n    /* 80321B28 */ virtual void setAlphaComp(J3DAlphaComp const*);\n    /* 80321B0C */ virtual void setAlphaComp(J3DAlphaComp const&);\n    /* 80321B44 */ virtual J3DAlphaComp* getAlphaComp();\n    /* 80321B58 */ virtual void setBlend(J3DBlend const*);\n    /* 80321B4C */ virtual void setBlend(J3DBlend const&);\n    /* 80321B64 */ virtual bool getBlend();\n    /* 80321B78 */ virtual void setZMode(J3DZMode const*);\n    /* 80321B6C */ virtual void setZMode(J3DZMode);\n    /* 80321B84 */ virtual J3DZMode* getZMode();\n    /* 80321B94 */ virtual void setZCompLoc(u8 const*);\n    /* 80321B8C */ virtual void setZCompLoc(u8);\n    /* 80321BA0 */ virtual bool getZCompLoc() const;\n    /* 80321BB0 */ virtual void setDither(u8 const*);\n    /* 80321BA8 */ virtual void setDither(u8);\n    /* 80321BBC */ virtual bool getDither() const;\n    /* 80321BC4 */ virtual ~J3DPEBlockFogOff();\n\nprivate:\n    /* 0x04 */ J3DAlphaComp mAlphaComp;\n    /* 0x08 */ J3DBlend mBlend;\n    /* 0x0C */ J3DZMode mZMode;\n    /* 0x0E */ u8 mZCompLoc;\n    /* 0x0F */ u8 mDither;\n};  // Size: 0x10\n\nstruct J3DIndTexCoordScaleInfo {\n    /* 0x0 */ u8 mScaleS;\n    /* 0x1 */ u8 mScaleT;\n    /* 0x2 */ u8 field_0x2;\n    /* 0x3 */ u8 field_0x3;\n};  // Size: 0x4\n\nextern J3DIndTexCoordScaleInfo j3dDefaultIndTexCoordScaleInfo;\n\nstruct J3DIndTexCoordScale : public J3DIndTexCoordScaleInfo {\n    /* 8000E0E4 */ J3DIndTexCoordScale() : J3DIndTexCoordScaleInfo(j3dDefaultIndTexCoordScaleInfo) {}\n    J3DIndTexCoordScale(J3DIndTexCoordScaleInfo const& info) : J3DIndTexCoordScaleInfo(info) {}\n    /* 8000E024 */ ~J3DIndTexCoordScale() {}\n};  // Size: 0x4\n\nextern J3DIndTexMtxInfo const j3dDefaultIndTexMtxInfo;\n\nstruct J3DIndTexMtx : public J3DIndTexMtxInfo {\n    /* 8000E0F0 */ J3DIndTexMtx() { *(J3DIndTexMtxInfo*)this = j3dDefaultIndTexMtxInfo; }\n    J3DIndTexMtx(J3DIndTexMtxInfo const& info) { *(J3DIndTexMtxInfo*)this = info; }\n    /* 8000E064 */ ~J3DIndTexMtx() {}\n};  // Size: 0x1C\n\nstruct J3DIndTexOrderInfo {\n    /* 0x0 */ u8 mMap;\n    /* 0x1 */ u8 mCoord;\n    /* 0x2 */ u8 field_0x2;\n    /* 0x3 */ u8 field_0x3;\n};  // Size: 0x04\n\nextern J3DIndTexOrderInfo j3dDefaultIndTexOrderNull;\n\nstruct J3DIndTexOrder : public J3DIndTexOrderInfo {\n    /* 8000E128 */ J3DIndTexOrder() : J3DIndTexOrderInfo(j3dDefaultIndTexOrderNull) {}\n    J3DIndTexOrder(J3DIndTexOrderInfo const& info) : J3DIndTexOrderInfo(info) {}\n};  // Size: 0x04\n\nclass J3DIndBlock {\npublic:\n    /* 8031734C */ virtual void reset(J3DIndBlock*);\n    virtual void diff(u32) = 0;\n    virtual void load() = 0;\n    /* 80317314 */ virtual s32 countDLSize();\n    virtual u32 getType() = 0;\n    /* 8000E0A0 */ virtual void setIndTexStageNum(u8);\n    /* 8000DF7C */ virtual u8 getIndTexStageNum() const;\n    /* 80317410 */ virtual void setIndTexOrder(u32, J3DIndTexOrder);\n    /* 8031740C */ virtual void setIndTexOrder(u32, J3DIndTexOrder const*);\n    /* 8000DF74 */ virtual bool getIndTexOrder(u32);\n    /* 80317414 */ virtual void setIndTexMtx(u32, J3DIndTexMtx const*);\n    /* 8000E060 */ virtual void setIndTexMtx(u32, J3DIndTexMtx);\n    /* 8000DF6C */ virtual bool getIndTexMtx(u32);\n    /* 8000E020 */ virtual void setIndTexCoordScale(u32, J3DIndTexCoordScale);\n    /* 80317418 */ virtual void setIndTexCoordScale(u32, J3DIndTexCoordScale const*);\n    /* 8000DF64 */ virtual bool getIndTexCoordScale(u32);\n    /* 8031726C */ virtual ~J3DIndBlock();\n};\n\nclass J3DIndBlockNull : public J3DIndBlock {\npublic:\n    /* 803173A0 */ virtual void reset(J3DIndBlock*);\n    /* 80317398 */ virtual void diff(u32);\n    /* 8031739C */ virtual void load();\n    /* 803173A4 */ virtual u32 getType();\n    /* 803173B0 */ virtual ~J3DIndBlockNull();\n};\n\nclass J3DIndBlockFull : public J3DIndBlock {\npublic:\n    J3DIndBlockFull() {\n        initialize();\n    }\n    /* 80317B28 */ void initialize();\n\n    /* 803210B0 */ virtual void reset(J3DIndBlock*);\n    /* 8031E328 */ virtual void diff(u32);\n    /* 8031E12C */ virtual void load();\n    /* 80317BDC */ virtual s32 countDLSize();\n    /* 80323390 */ virtual u32 getType();\n    /* 8032339C */ virtual void setIndTexStageNum(u8);\n    /* 803233A4 */ virtual u8 getIndTexStageNum() const;\n    /* 803233AC */ virtual void setIndTexOrder(u32, J3DIndTexOrder);\n    /* 803233C0 */ virtual void setIndTexOrder(u32, J3DIndTexOrder const*);\n    /* 803233D4 */ virtual bool getIndTexOrder(u32);\n    /* 8032341C */ virtual void setIndTexMtx(u32, J3DIndTexMtx const*);\n    /* 803233E8 */ virtual void setIndTexMtx(u32, J3DIndTexMtx);\n    /* 80323450 */ virtual bool getIndTexMtx(u32);\n    /* 80323478 */ virtual void setIndTexCoordScale(u32, J3DIndTexCoordScale const*);\n    /* 80323464 */ virtual void setIndTexCoordScale(u32, J3DIndTexCoordScale);\n    /* 8032348C */ virtual bool getIndTexCoordScale(u32);\n    /* 803234A0 */ virtual ~J3DIndBlockFull();\n\nprivate:\n    /* 0x04 */ u8 mIndTexStageNum;\n    /* 0x05 */ J3DIndTexOrder mIndTexOrder[4];\n    /* 0x18 */ J3DIndTexMtx mIndTexMtx[3];\n    /* 0x6C */ J3DIndTexCoordScale mIndTexCoordScale[4];\n};  // Size: 0x7C\n\nstruct J3DColorChanInfo {\n    /* 0x0 */ u8 field_0x0;\n    /* 0x1 */ u8 field_0x1;\n    /* 0x2 */ u8 field_0x2;\n    /* 0x3 */ u8 field_0x3;\n    /* 0x4 */ u8 field_0x4;\n    /* 0x5 */ u8 field_0x5;\n    /* 0x6 */ u8 pad[2];\n};\n\nextern J3DColorChanInfo j3dDefaultColorChanInfo;\n\nstruct J3DColorChan {\n    /* 8000E47C */ J3DColorChan() {\n        setColorChanInfo(j3dDefaultColorChanInfo);\n    }\n    J3DColorChan(J3DColorChanInfo const& info) {\n        setColorChanInfo(info);\n    }\n    void setColorChanInfo(J3DColorChanInfo const& info) {\n        mColorChanID = calcColorChanID(info.field_0x0, info.field_0x1, info.field_0x2,\n            info.field_0x3, info.field_0x4, info.field_0x5 == 0xff ? 0 : info.field_0x5);\n    }\n    u16 calcColorChanID(u16 param_0, u8 param_1, u8 param_2, u8 param_3, u8 param_4, u8 param_5) {\n        // if (param_4 == 0) {\n        //     param_3 = 0;\n        // }\n        u32 b0 = ((param_2 & 1) != 0);\n        u32 b1 = ((param_2 & 2) != 0);\n        u32 b2 = ((param_2 & 4) != 0);\n        u32 b3 = ((param_2 & 8) != 0);\n        u32 b4 = ((param_2 & 0x10) != 0);\n        u32 b5 = ((param_2 & 0x20) != 0);\n        u32 b6 = ((param_2 & 0x40) != 0);\n        u32 b7 = ((param_2 & 0x80) != 0);\n        return param_1 | (param_0 << 1) | (b0 << 2) | (b1 << 3) | (b2 << 4) | (b3 << 5) |\n            (param_5 << 6) | (param_3 << 7) | ((param_4 != 2) << 9) | ((param_4 != 0) << 10) |\n            (b4 << 11) | (b5 << 12) | (b6 << 13) | (b7 << 14);\n        // return (b7 << 14) | (b6 << 13) | (b5 << 12) | (b4 << 11) |\n        //     ((param_4 != 0) << 10) | ((param_4 != 2) << 9) | ((param_3 != 0) << 7) | ((param_5 != 0) << 6) |\n        //     (b3 << 5) | (b2 << 4) | (b1 << 3) | (b0 << 2) | ((param_0 != 0) << 1) | param_1;\n    }\n    u8 getLightMask() { return (((mColorChanID & 0x7800) >> 7) | (mColorChanID & 0x3c) >> 2); }\n    void setLightMask(u8 param_1) {\n        mColorChanID = (mColorChanID & ~0x3c) | ((param_1 & 0xf) << 2);\n        mColorChanID = (mColorChanID & ~0x7800) | ((param_1 & 0xf0) << 7);\n    }\n\n    /* 0x0 */ u16 mColorChanID;\n};\n\nclass J3DColorBlock {\npublic:\n    /* 80317324 */ virtual void load();\n    /* 80317358 */ virtual void reset(J3DColorBlock*);\n    /* 8031733C */ virtual void patch();\n    /* 80317434 */ virtual void patchMatColor();\n    /* 8000DBD0 */ virtual void patchLight();\n    /* 80317340 */ virtual void diff(u32);\n    /* 80317438 */ virtual void diffAmbColor();\n    /* 8031743C */ virtual void diffMatColor();\n    /* 80317440 */ virtual void diffColorChan();\n    /* 80317444 */ virtual void diffLightObj(u32);\n    /* 80317304 */ virtual s32 countDLSize();\n    virtual u32 getType() = 0;\n    /* 80317448 */ virtual void setMatColor(u32, J3DGXColor const*);\n    /* 8000E0DC */ virtual void setMatColor(u32, J3DGXColor);\n    /* 8000E000 */ virtual _GXColor* getMatColor(u32);\n    /* 801A4C0C */ virtual void setAmbColor(u32, J3DGXColor const*);\n    /* 8000E0D4 */ virtual void setAmbColor(u32, J3DGXColor);\n    /* 8000DFF0 */ virtual bool getAmbColor(u32);\n    /* 8000E0E0 */ virtual void setColorChanNum(u8);\n    /* 8031744C */ virtual void setColorChanNum(u8 const*);\n    /* 8000E008 */ virtual u8 getColorChanNum() const;\n    /* 8000E0D8 */ virtual void setColorChan(u32, J3DColorChan const&);\n    /* 80317450 */ virtual void setColorChan(u32, J3DColorChan const*);\n    /* 8000DFF8 */ virtual J3DColorChan* getColorChan(u32);\n    /* 801A4C08 */ virtual void setLight(u32, J3DLightObj*);\n    /* 80317454 */ virtual bool getLight(u32);\n    /* 80317460 */ virtual void setCullMode(u8 const*);\n    /* 8031745C */ virtual void setCullMode(u8);\n    /* 80317328 */ virtual s32 getCullMode() const;\n    /* 80317464 */ virtual bool getMatColorOffset() const;\n    /* 8031746C */ virtual bool getColorChanOffset() const;\n    /* 80317474 */ virtual void setMatColorOffset(u32);\n    /* 80317478 */ virtual void setColorChanOffset(u32);\n    /* 80317138 */ virtual ~J3DColorBlock() {}\n};\n\nstruct J3DColorBlockNull : public J3DColorBlock {\n    /* 80332B2C */ virtual u32 getType(); // { return 'CLNL'; }\n    /* 80332B38 */ virtual ~J3DColorBlockNull(); // {}\n};\n\nclass J3DColorBlockLightOn : public J3DColorBlock {\npublic:\n    J3DColorBlockLightOn() {\n        initialize();\n    }\n    /* 80317580 */ void initialize();\n\n    /* 803187F4 */ virtual void load();\n    /* 8031FF34 */ virtual void reset(J3DColorBlock*);\n    /* 803194E8 */ virtual void patch();\n    /* 80319534 */ virtual void patchMatColor();\n    /* 803196E0 */ virtual void patchLight();\n    /* 8031A13C */ virtual void diff(u32);\n    /* 8031A1DC */ virtual void diffAmbColor();\n    /* 8031A358 */ virtual void diffMatColor();\n    /* 8031A4D4 */ virtual void diffColorChan();\n    /* 8031A8E0 */ virtual void diffLightObj(u32);\n    /* 80317B94 */ virtual s32 countDLSize();\n    /* 80322E80 */ virtual u32 getType();\n    /* 80322EB8 */ virtual void setMatColor(u32, J3DGXColor const*);\n    /* 80322E8C */ virtual void setMatColor(u32, J3DGXColor);\n    /* 80322EE4 */ virtual GXColor* getMatColor(u32);\n    /* 80322F24 */ virtual void setAmbColor(u32, J3DGXColor const*);\n    /* 80322EF8 */ virtual void setAmbColor(u32, J3DGXColor);\n    /* 80322F50 */ virtual bool getAmbColor(u32);\n    /* 80322F70 */ virtual void setColorChanNum(u8);\n    /* 80322F64 */ virtual void setColorChanNum(u8 const*);\n    /* 80322F78 */ virtual u8 getColorChanNum() const;\n    /* 80322F94 */ virtual void setColorChan(u32, J3DColorChan const&);\n    /* 80322F80 */ virtual void setColorChan(u32, J3DColorChan const*);\n    /* 80322FA8 */ virtual J3DColorChan* getColorChan(u32);\n    /* 80322FBC */ virtual void setLight(u32, J3DLightObj*);\n    /* 80322FCC */ virtual bool getLight(u32);\n    /* 80322FE4 */ virtual void setCullMode(u8 const*);\n    /* 80322FDC */ virtual void setCullMode(u8);\n    /* 80322FF0 */ virtual s32 getCullMode() const;\n    /* 80322FF8 */ virtual bool getMatColorOffset() const;\n    /* 80323000 */ virtual bool getColorChanOffset() const;\n    /* 80323008 */ virtual void setMatColorOffset(u32);\n    /* 80323010 */ virtual void setColorChanOffset(u32);\n    /* 80323018 */ virtual ~J3DColorBlockLightOn();\n\nprivate:\n    /* 0x04 */ J3DGXColor mMatColor[2];\n    /* 0x0C */ J3DGXColor mAmbColor[2];\n    /* 0x14 */ u8 mColorChanNum;\n    /* 0x16 */ J3DColorChan mColorChan[4];\n    /* 0x20 */ J3DLightObj* mLight[8];\n    /* 0x40 */ u8 mCullMode;\n    /* 0x44 */ u32 mMatColorOffset;\n    /* 0x48 */ u32 mColorChanOffset;\n};  // Size: 0x4C\n\nclass J3DColorBlockLightOff : public J3DColorBlock {\npublic:\n    J3DColorBlockLightOff() {\n        initialize();\n    }\n    /* 8031747C */ void initialize();\n\n    /* 80317C0C */ virtual void load();\n    /* 8031FD08 */ virtual void reset(J3DColorBlock*);\n    /* 80318EB4 */ virtual void patch();\n    /* 80318F00 */ virtual void patchMatColor();\n    /* 803190AC */ virtual void patchLight();\n    /* 80319B4C */ virtual void diff(u32);\n    /* 80319BB4 */ virtual void diffMatColor();\n    /* 80319D30 */ virtual void diffColorChan();\n    /* 80317B84 */ virtual s32 countDLSize();\n    /* 80323560 */ virtual u32 getType();\n    /* 80323184 */ virtual void setMatColor(u32, J3DGXColor const*);\n    /* 80323158 */ virtual void setMatColor(u32, J3DGXColor);\n    /* 803231B0 */ virtual GXColor* getMatColor(u32);\n    /* 803231D0 */ virtual void setColorChanNum(u8);\n    /* 803231C4 */ virtual void setColorChanNum(u8 const*);\n    /* 803231D8 */ virtual u8 getColorChanNum() const;\n    /* 803231F4 */ virtual void setColorChan(u32, J3DColorChan const&);\n    /* 803231E0 */ virtual void setColorChan(u32, J3DColorChan const*);\n    /* 80323208 */ virtual J3DColorChan* getColorChan(u32);\n    /* 80323224 */ virtual void setCullMode(u8 const*);\n    /* 8032321C */ virtual void setCullMode(u8);\n    /* 80323230 */ virtual s32 getCullMode() const;\n    /* 80323238 */ virtual bool getMatColorOffset() const;\n    /* 80323240 */ virtual bool getColorChanOffset() const;\n    /* 80323248 */ virtual void setMatColorOffset(u32);\n    /* 80323250 */ virtual void setColorChanOffset(u32);\n    /* 803170DC */ virtual ~J3DColorBlockLightOff();\n\nprivate:\n    /* 0x04 */ J3DGXColor mMatColor[2];\n    /* 0x0C */ u8 mColorChanNum;\n    /* 0x0E */ J3DColorChan mColorChan[4];\n    /* 0x16 */ u8 mCullMode;\n    /* 0x18 */ u32 mMatColorOffset;\n    /* 0x1C */ u32 mColorChanOffset;\n};  // Size: 0x20\n\nclass J3DColorBlockAmbientOn : public J3DColorBlockLightOff {\npublic:\n    J3DColorBlockAmbientOn() {\n        initialize();\n    }\n    /* 803174DC */ void initialize();\n\n    /* 8031816C */ virtual void load();\n    /* 8031FDE4 */ virtual void reset(J3DColorBlock*);\n    /* 80317B8C */ virtual s32 countDLSize();\n    /* 80323074 */ virtual u32 getType();\n    /* 803230AC */ virtual void setAmbColor(u32, J3DGXColor const*);\n    /* 80323080 */ virtual void setAmbColor(u32, J3DGXColor);\n    /* 803230D8 */ virtual bool getAmbColor(u32);\n    /* 803230EC */ virtual ~J3DColorBlockAmbientOn();\n\nprivate:\n    /* 0x20 */ J3DGXColor mAmbColor[2];\n};  // Size: 0x28\n\n#endif /* J3DMATBLOCK_H */\n/* end \"JSystem/J3DGraphBase/J3DMatBlock.h\" */\n/* \"src/d/d_attention.cpp\" line 7 \"JSystem/J3DGraphBase/J3DMaterial.h\" */\n#ifndef J3DMATERIAL_H\n#define J3DMATERIAL_H\n\n/* \"include/JSystem/J3DGraphBase/J3DMaterial.h\" line 3 \"JSystem/J3DGraphBase/J3DMatBlock.h\" */\n/* end \"JSystem/J3DGraphBase/J3DMatBlock.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DMaterial.h\" line 4 \"JSystem/J3DGraphBase/J3DPacket.h\" */\n/* end \"JSystem/J3DGraphBase/J3DPacket.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DMaterial.h\" line 5 \"JSystem/J3DGraphBase/J3DShape.h\" */\n/* end \"JSystem/J3DGraphBase/J3DShape.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DMaterial.h\" line 6 \"JSystem/J3DGraphBase/J3DTexture.h\" */\n/* end \"JSystem/J3DGraphBase/J3DTexture.h\" */\n/* \"include/JSystem/J3DGraphBase/J3DMaterial.h\" line 7 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass J3DJoint;\nclass J3DMaterialAnm;\n\nclass J3DMaterial {\npublic:\n    /* 803157A0 */ static J3DColorBlock* createColorBlock(u32);\n    /* 803159A0 */ static J3DTexGenBlock* createTexGenBlock(u32);\n    /* 80315B04 */ static J3DTevBlock* createTevBlock(int);\n    /* 80315E78 */ static J3DIndBlock* createIndBlock(int);\n    /* 80315F60 */ static J3DPEBlock* createPEBlock(u32, u32);\n    /* 80316100 */ static u32 calcSizeColorBlock(u32);\n    /* 80316150 */ static u32 calcSizeTexGenBlock(u32);\n    /* 8031617C */ static u32 calcSizeTevBlock(int);\n    /* 803161C4 */ static u32 calcSizeIndBlock(int);\n    /* 803161D8 */ static u32 calcSizePEBlock(u32, u32);\n    /* 80316240 */ void initialize();\n    /* 80316290 */ u32 countDLSize();\n    /* 80316344 */ void makeDisplayList_private(J3DDisplayListObj*);\n    /* 80316AB0 */ void setCurrentMtx();\n    /* 80316AC8 */ void calcCurrentMtx();\n    /* 80316D68 */ void copy(J3DMaterial*);\n    /* 80316E90 */ s32 newSharedDisplayList(u32);\n    /* 80316F24 */ s32 newSingleSharedDisplayList(u32);\n\n    /* 803169DC */ virtual void calc(f32 const (*)[4]);\n    /* 80316A54 */ virtual void calcDiffTexMtx(f32 const (*)[4]);\n    /* 80316620 */ virtual void makeDisplayList();\n    /* 80316668 */ virtual void makeSharedDisplayList();\n    /* 8031668C */ virtual void load();\n    /* 803166DC */ virtual void loadSharedDL();\n    /* 80316740 */ virtual void patch();\n    /* 803167D8 */ virtual void diff(u32);\n    /* 80316E14 */ virtual void reset();\n    /* 80316E70 */ virtual void change();\n\n    J3DMaterial() { initialize(); }\n    ~J3DMaterial() {}\n    J3DMaterial* getNext() const { return mNext; }\n    J3DShape* getShape() const { return mShape; }\n    J3DTevBlock* getTevBlock() const { return mTevBlock; }\n    J3DColorBlock* getColorBlock() const { return mColorBlock; }\n    J3DTexGenBlock* getTexGenBlock() const { return mTexGenBlock; }\n    J3DDisplayListObj* getSharedDisplayListObj() const { return mSharedDLObj; }\n    J3DIndBlock* getIndBlock() const { return mIndBlock; }\n    J3DShape* getShape() { return mShape; }\n    J3DJoint* getJoint() { return mJoint; }\n    J3DMaterialAnm* getMaterialAnm() const {\n        if ((u32)mMaterialAnm < 0xC0000000) {\n            return mMaterialAnm;\n        } else {\n            return NULL;\n        }\n    }\n    J3DNBTScale* getNBTScale() const { return mTexGenBlock->getNBTScale(); }\n    u16 getTexNo(u32 idx) const { return mTevBlock->getTexNo(idx); }\n    GXColor* getTevKColor(u32 param_0) { return mTevBlock->getTevKColor(param_0); }\n    GXColorS10* getTevColor(u32 param_0) { return mTevBlock->getTevColor(param_0); }\n    J3DFog* getFog() { return mPEBlock->getFog(); }\n    J3DTexMtx* getTexMtx(u32 idx) { return mTexGenBlock->getTexMtx(idx); }\n    u16 getIndex() { return mIndex; }\n    bool isDrawModeOpaTexEdge() { return (mMaterialMode & 3) == 0; }\n    J3DPEBlock* getPEBlock() { return mPEBlock; }\n    void onInvalid() { mInvalid = 1; }\n    u32 getTexGenNum() const { return mTexGenBlock->getTexGenNum(); }\n    u8 getTevStageNum() const { return mTevBlock->getTevStageNum(); }\n\n    void setTevColor(u32 i, const J3DGXColorS10* i_color) { mTevBlock->setTevColor(i, i_color); }\n    void setTevKColor(u32 i, const J3DGXColor* i_color) { mTevBlock->setTevKColor(i, i_color); }\n    void setMaterialAnm(J3DMaterialAnm* i_anm) { mMaterialAnm = i_anm; }\n    void setCullMode(u8 i_mode) { mColorBlock->setCullMode(i_mode); }\n\npublic:\n    /* 0x04 */ J3DMaterial* mNext;\n    /* 0x08 */ J3DShape* mShape;\n    /* 0x0C */ J3DJoint* mJoint;\n    /* 0x10 */ u32 mMaterialMode;\n    /* 0x14 */ u16 mIndex;\n    /* 0x18 */ u32 mInvalid;\n    /* 0x1C */ u32 field_0x1c;\n    /* 0x20 */ u32 mDiffFlag;\n    /* 0x24 */ J3DColorBlock* mColorBlock;\n    /* 0x28 */ J3DTexGenBlock* mTexGenBlock;\n    /* 0x2C */ J3DTevBlock* mTevBlock;\n    /* 0x30 */ J3DIndBlock* mIndBlock;\n    /* 0x34 */ J3DPEBlock* mPEBlock;\n    /* 0x38 */ J3DMaterial* mpOrigMaterial;\n    /* 0x3C */ J3DMaterialAnm* mMaterialAnm;\n    /* 0x40 */ J3DCurrentMtx mCurrentMtx;\n    /* 0x48 */ J3DDisplayListObj* mSharedDLObj;\n};\n\nclass J3DPatchedMaterial : public J3DMaterial {\npublic:\n    /* 80316FB8 */ void initialize();\n\n    /* 80316FD8 */ virtual void makeDisplayList();\n    /* 80316FDC */ virtual void makeSharedDisplayList();\n    /* 80316FE0 */ virtual void load();\n    /* 80316FFC */ virtual void loadSharedDL();\n    /* 8031703C */ virtual void reset();\n    /* 80317040 */ virtual void change();\n};\n\nclass J3DLockedMaterial : public J3DMaterial {\npublic:\n    J3DLockedMaterial() { initialize(); }\n    /* 80317044 */ void initialize();\n\n    /* 803170D0 */ virtual void calc(f32 const (*)[4]);\n    /* 80317064 */ virtual void makeDisplayList();\n    /* 80317068 */ virtual void makeSharedDisplayList();\n    /* 8031706C */ virtual void load();\n    /* 80317088 */ virtual void loadSharedDL();\n    /* 803170C8 */ virtual void patch();\n    /* 803170CC */ virtual void diff(u32);\n    /* 803170D4 */ virtual void reset();\n    /* 803170D8 */ virtual void change();\n};\n\n#endif /* J3DMATERIAL_H */\n/* end \"JSystem/J3DGraphBase/J3DMaterial.h\" */\n/* \"src/d/d_attention.cpp\" line 8 \"d/a/d_a_player.h\" */\n#ifndef D_A_D_A_PLAYER_H\n#define D_A_D_A_PLAYER_H\n\n/* \"include/d/a/d_a_player.h\" line 3 \"d/d_drawlist.h\" */\n#ifndef D_D_DRAWLIST_H\n#define D_D_DRAWLIST_H\n\n/* \"include/d/d_drawlist.h\" line 3 \"JSystem/J2DGraph/J2DPicture.h\" */\n#ifndef J2DPICTURE_H\n#define J2DPICTURE_H\n\n/* \"include/JSystem/J2DGraph/J2DPicture.h\" line 3 \"JSystem/J2DGraph/J2DPane.h\" */\n#ifndef J2DPANE_H\n#define J2DPANE_H\n\n/* \"include/JSystem/J2DGraph/J2DPane.h\" line 3 \"JSystem/JGeometry.h\" */\n/* end \"JSystem/JGeometry.h\" */\n/* \"include/JSystem/J2DGraph/J2DPane.h\" line 4 \"JSystem/JSupport/JSUList.h\" */\n/* end \"JSystem/JSupport/JSUList.h\" */\n/* \"include/JSystem/J2DGraph/J2DPane.h\" line 5 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n/* \"include/JSystem/J2DGraph/J2DPane.h\" line 6 \"dolphin/mtx/mtx.h\" */\n/* end \"dolphin/mtx/mtx.h\" */\n\nclass J2DAnmBase;\nclass J2DAnmColor;\nclass J2DAnmTransform;\nclass J2DAnmTevRegKey;\nclass J2DAnmTextureSRTKey;\nclass J2DAnmVisibilityFull;\nclass J2DAnmVtxColor;\nclass J2DGrafContext;\nclass J2DScreen;\nclass J2DAnmTexPattern;\nclass JKRArchive;\nclass JSURandomInputStream;\nstruct ResFONT;\nstruct ResTIMG;\n\nenum J2DRotateAxis {\n    /* 0x78 */ ROTATE_X = 'x',\n    /* 0x79 */ ROTATE_Y = 'y',\n    /* 0x7A */ ROTATE_Z = 'z'\n};\n\nenum J2DBasePosition {\n    J2DBasePosition_0,\n    J2DBasePosition_1,\n    J2DBasePosition_2,\n    J2DBasePosition_3,\n    J2DBasePosition_4,\n};\n\nstruct J2DPaneHeader {\n    /* 0x0 */ u32 mKind;\n    /* 0x4 */ u32 mSize;\n};\n\nclass J2DPane {\npublic:\n    J2DPane();\n    J2DPane(J2DPane*, bool, u64, const JGeometry::TBox2<f32>&);\n    J2DPane(u64, const JGeometry::TBox2<f32>&);\n    J2DPane(J2DPane* other, JSURandomInputStream* stream, u8 arg3);\n    void initiate();\n    void initialize(J2DPane*, bool, u64, const JGeometry::TBox2<f32>&);\n    void initialize(u64 tag, const JGeometry::TBox2<f32>& dim);\n    void makePaneStream(J2DPane* other, JSURandomInputStream* stream);\n    void changeUseTrans(J2DPane* other);\n    bool appendChild(J2DPane* child);\n    bool insertChild(J2DPane* before, J2DPane* child);\n    void draw(f32 a1, f32 a2, const J2DGrafContext* ctx, bool a4, bool a5);\n    void place(const JGeometry::TBox2<f32>& dim);\n    JGeometry::TBox2<f32>& getBounds();\n    void rotate(f32 offsetX, f32 offsetY, J2DRotateAxis axis, f32 angle);\n    void rotate(f32 angle);\n    void clip(const JGeometry::TBox2<f32>& bounds);\n    void setBasePosition(J2DBasePosition position);\n    void setInfluencedAlpha(bool arg1, bool arg2);\n    JGeometry::TVec3<f32> getGlbVtx(u8 arg1) const;\n    J2DPane* getFirstChildPane();\n    J2DPane* getNextChildPane();\n    J2DPane* getParentPane();\n    void makePaneExStream(J2DPane* other, JSURandomInputStream* stream);\n    void* getPointer(JSURandomInputStream* stream, u32 size, JKRArchive* archive);\n    void animationTransform();\n    void updateTransform(const J2DAnmTransform* transform);\n\n    virtual ~J2DPane();\n\n    /* vt 0x0C */ virtual u16 getTypeID() const { return 16; }\n    /* vt 0x10 */ virtual void move(f32 x, f32 y);\n    /* vt 0x14 */ virtual void add(f32 x, f32 y);\n    /* vt 0x18 */ virtual void resize(f32 x, f32 y);\n    /* vt 0x1C */ virtual void setCullBack(bool cull);\n    /* vt 0x20 */ virtual void setCullBack(_GXCullMode cmode);\n    /* vt 0x24 */ virtual void setAlpha(u8);\n    /* vt 0x28 */ virtual bool setConnectParent(bool connected);\n    /* vt 0x2C */ virtual void calcMtx();\n    /* vt 0x30 */ virtual void update();\n    /* vt 0x34 */ virtual void drawSelf(f32 arg1, f32 arg2);\n    /* vt 0x38 */ virtual void drawSelf(f32 arg1, f32 arg2, Mtx* mtx);\n    /* vt 0x3C */ virtual J2DPane* search(u64 tag);\n    /* vt 0x40 */ virtual J2DPane* searchUserInfo(u64 tag);\n    /* vt 0x44 */ virtual void makeMatrix(f32, f32);\n    /* vt 0x48 */ virtual void makeMatrix(f32 a, f32 b, f32 c, f32 d);\n    /* vt 0x4C */ virtual bool isUsed(const ResTIMG* timg);\n    /* vt 0x50 */ virtual bool isUsed(const ResFONT* font);\n    /* vt 0x54 */ virtual void clearAnmTransform();\n    /* vt 0x58 */ virtual void rewriteAlpha();\n    /* vt 0x5C */ virtual void setAnimation(J2DAnmBase* anm);\n    /* vt 0x60 */ virtual void setAnimation(J2DAnmTransform* anm);\n    /* vt 0x64 */ virtual void setAnimation(J2DAnmColor* anm) {}\n    /* vt 0x68 */ virtual void setAnimation(J2DAnmTexPattern* anm) {}\n    /* vt 0x6C */ virtual void setAnimation(J2DAnmTextureSRTKey* anm) {}\n    /* vt 0x70 */ virtual void setAnimation(J2DAnmTevRegKey* anm) {}\n    /* vt 0x74 */ virtual void setAnimation(J2DAnmVisibilityFull* anm) {}\n    /* vt 0x78 */ virtual void setAnimation(J2DAnmVtxColor* anm) {}\n    /* vt 0x7C */ virtual const J2DAnmTransform* animationTransform(const J2DAnmTransform* transform);\n    /* vt 0x80 */ virtual void setVisibileAnimation(J2DAnmVisibilityFull* visibility);\n    /* vt 0x84 */ virtual void setAnimationVF(J2DAnmVisibilityFull* visibility);\n    /* vt 0x88 */ virtual void setVtxColorAnimation(J2DAnmVtxColor* vtx_color);\n    /* vt 0x8C */ virtual void setAnimationVC(J2DAnmVtxColor* vtx_color);\n    /* vt 0x90 */ virtual const J2DAnmTransform* animationPane(const J2DAnmTransform* transform);\n\n    f32 getHeight() const { return mBounds.getHeight(); }\n    f32 getWidth() const { return mBounds.getWidth(); }\n    JSUTree<J2DPane>* getFirstChild() { return mPaneTree.getFirstChild(); }\n    JSUTree<J2DPane>* getEndChild() { return mPaneTree.getEndChild(); }\n    const JSUTree<J2DPane>* getPaneTree() { return &mPaneTree; }\n    u8 getAlpha() const { return mAlpha; }\n\n    f32 getScaleX() const { return mScaleX; }\n\n    f32 getScaleY() const { return mScaleY; }\n\n    f32 getTranslateX() const { return mTranslateX; }\n\n    f32 getTranslateY() const { return mTranslateY; }\n\n    f32 getRotateZ() const { return mRotateZ; }\n\n    f32 getRotOffsetX() const { return mRotateOffsetX; }\n\n    f32 getRotOffsetY() const { return mRotateOffsetY; }\n\n    MtxP getGlbMtx() { return mGlobalMtx; }\n\n    void setMtx(Mtx m) { MTXCopy(m, mPositionMtx); }\n\n    void translate(f32 transX, f32 transY) {\n        mTranslateX = transX;\n        mTranslateY = transY;\n        calcMtx();\n    }\n\n    void scale(f32 scaleH, f32 scaleV) {\n        mScaleX = scaleH;\n        mScaleY = scaleV;\n        calcMtx();\n    }\n\n    int getKind() const { return mKind; }\n\n    bool isVisible() const { return mVisible; }\n\n    void show() { mVisible = true; }\n    void hide() { mVisible = false; }\n\n    bool isConnectParent() const { return mConnected; }\n\n    void setUserInfo(u64 info) { mUserInfoTag = info; }\n    const Mtx* getMtx() const { return &mPositionMtx; }\n\n    static s16 J2DCast_F32_to_S16(f32 value, u8 arg2);\n\n    static JGeometry::TBox2<f32> static_mBounds;\n\npublic:\n    /* 0x04 */ u16 field_0x4;\n    /* 0x08 */ int mKind;\n    /* 0x10 */ u64 mInfoTag;\n    /* 0x18 */ u64 mUserInfoTag;\n    /* 0x20 */ JGeometry::TBox2<f32> mBounds;\n    /* 0x30 */ JGeometry::TBox2<f32> mGlobalBounds;\n    /* 0x40 */ JGeometry::TBox2<f32> mClipRect;\n    /* 0x50 */ Mtx mPositionMtx;\n    /* 0x80 */ Mtx mGlobalMtx;\n    /* 0xB0 */ bool mVisible;\n    /* 0xB1 */ u8 mCullMode;\n    /* 0xB2 */ u8 mAlpha;\n    /* 0xB3 */ u8 mColorAlpha;\n    /* 0xB4 */ bool mIsInfluencedAlpha;\n    /* 0xB5 */ bool mConnected;\n    /* 0xB6 */ char mRotAxis;\n    /* 0xB7 */ u8 mBasePosition;\n    /* 0xB8 */ f32 mRotateX;\n    /* 0xBC */ f32 mRotateY;\n    /* 0xC0 */ f32 mRotateZ;\n    /* 0xC4 */ f32 mRotateOffsetX;\n    /* 0xC8 */ f32 mRotateOffsetY;\n    /* 0xCC */ f32 mScaleX;\n    /* 0xD0 */ f32 mScaleY;\n    /* 0xD4 */ f32 mTranslateX;\n    /* 0xD8 */ f32 mTranslateY;\n    /* 0xDC */ JSUTree<J2DPane> mPaneTree;\n    /* 0xF8 */ const J2DAnmTransform* mTransform;\n    /* 0xFC */ u32 _fc;\n};\n\n#endif /* J2DPANE_H */\n/* end \"JSystem/J2DGraph/J2DPane.h\" */\n/* \"include/JSystem/J2DGraph/J2DPicture.h\" line 4 \"JSystem/JUtility/TColor.h\" */\n#ifndef TCOLOR_H\n#define TCOLOR_H\n\n/* \"include/JSystem/JUtility/TColor.h\" line 3 \"dolphin/gx/GXStruct.h\" */\n/* end \"dolphin/gx/GXStruct.h\" */\n\nnamespace JUtility {\nstruct TColor : public GXColor {\n    TColor(u8 r, u8 g, u8 b, u8 a) { set(r, g, b, a); }\n    TColor() { set(0xffffffff); }\n    TColor(u32 u32Color) { set(u32Color); }\n    TColor(GXColor color) { set(color); }\n\n    // TColor(const TColor& other) { set(other.toUInt32()); }\n    TColor& operator=(const TColor& other) {\n        ((GXColor*)this)->operator=(other);\n        return *this;\n    }\n\n    operator u32() const { return toUInt32(); }\n    u32 toUInt32() const { return *(u32*)&r; }\n\n    void set(u8 cR, u8 cG, u8 cB, u8 cA) {\n        r = cR;\n        g = cG;\n        b = cB;\n        a = cA;\n    }\n\n    void set(u32 u32Color) { *(u32*)&r = u32Color; }\n    void set(GXColor gxColor) { *(GXColor*)&r = gxColor; }\n};\n}  // namespace JUtility\n\n#endif/* end \"JSystem/JUtility/TColor.h\" */\n/* \"include/JSystem/J2DGraph/J2DPicture.h\" line 5 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass J2DMaterial;\nclass JUTPalette;\nclass JUTTexture;\nstruct ResTIMG;\nstruct ResTLUT;\n\nenum J2DMirror {\n    /* 0x0 */ MIRROR0,  // temp, figure out later\n};\n\nenum J2DBinding {\n    /* 0xF */ BIND15 = 15,  // temp, figure out later\n};\n\nstruct J2DPicHeader {\n    /* 0x0 */ u32 mTag;\n    /* 0x4 */ u32 mSize;\n};\n\nstruct J2DScrnBlockPictureParameter {\n    /* 0x00 */ u16 field_0x0;\n    /* 0x02 */ u16 mMaterialNum;\n    /* 0x04 */ u16 field_0x4;\n    /* 0x06 */ u16 field_0x6;\n    /* 0x08 */ u16 field_0x8[4];\n    /* 0x10 */ JGeometry::TVec2<s16> field_0x10[4];\n    /* 0x20 */ u32 mCornerColor[4];\n};  // Size: 0x30\n\nclass J2DPicture : public J2DPane {\npublic:\n    /* 802FCFF0 */ virtual ~J2DPicture();\n    /* 802FF2E8 */ virtual u16 getTypeID() const;\n    /* 802FDB28 */ virtual void drawSelf(f32, f32);\n    /* 802FDB90 */ virtual void drawSelf(f32, f32, Mtx*);\n    /* 802FF09C */ virtual bool isUsed(ResTIMG const*);\n    /* 802FF63C */ virtual bool isUsed(ResFONT const*);\n    /* 802FF65C */ virtual void rewriteAlpha();\n    /* 802FCCDC */ virtual void initiate(ResTIMG const*, ResTLUT const*);\n    /* 802FD098 */ virtual bool prepareTexture(u8);\n    /* 801BDD40 */ virtual bool append(ResTIMG const*, f32);\n    /* 802FF238 */ virtual bool append(ResTIMG const*, JUTPalette*, f32);\n    /* 80020338 */ virtual bool append(char const*, f32);\n    /* 802FF2F0 */ virtual bool append(char const*, JUTPalette*, f32);\n    /* 802FF208 */ virtual bool append(JUTTexture*, f32);\n    /* 802FF3E0 */ virtual void prepend(ResTIMG const*, f32);\n    /* 802FF3B0 */ virtual void prepend(ResTIMG const*, JUTPalette*, f32);\n    /* 802FF380 */ virtual void prepend(char const*, f32);\n    /* 802FF350 */ virtual void prepend(char const*, JUTPalette*, f32);\n    /* 802FF320 */ virtual void prepend(JUTTexture*, f32);\n    /* 801BDD70 */ virtual void insert(ResTIMG const*, u8, f32);\n    /* 802FD168 */ virtual bool insert(ResTIMG const*, JUTPalette*, u8, f32);\n    /* 80020368 */ virtual bool insert(char const*, u8, f32);\n    /* 802FD4B4 */ virtual bool insert(char const*, JUTPalette*, u8, f32);\n    /* 802FD524 */ virtual bool insert(JUTTexture*, u8, f32);\n    /* 802FD6F4 */ virtual bool remove(u8);\n    /* 802FF410 */ virtual bool remove();\n    /* 802FD814 */ virtual bool remove(JUTTexture*);\n    /* 802FF4E0 */ virtual void draw(f32, f32, bool, bool, bool);\n    /* 802FF448 */ virtual void draw(f32, f32, u8, bool, bool, bool);\n    /* 802FDC70 */ virtual void draw(f32, f32, f32, f32, bool, bool, bool);\n    /* 802FF588 */ virtual void drawOut(f32, f32, f32, f32, f32, f32);\n    /* 802FF524 */ virtual void drawOut(f32, f32, f32, f32, f32, f32, f32, f32);\n    /* 802FDF88 */ virtual void drawOut(JGeometry::TBox2<f32> const&, JGeometry::TBox2<f32> const&);\n    /* 802FF29C */ virtual void load(_GXTexMapID, u8);\n    /* 802FF268 */ virtual void load(u8);\n    /* 800202CC */ virtual void setBlendRatio(f32, f32);\n    /* 802FEA74 */ virtual void setBlendColorRatio(f32, f32);\n    /* 802FEA9C */ virtual void setBlendAlphaRatio(f32, f32);\n    /* 802FD874 */ virtual const ResTIMG* changeTexture(ResTIMG const*, u8);\n    /* 802FD964 */ virtual const ResTIMG* changeTexture(char const*, u8);\n    /* 802FD9BC */ virtual const ResTIMG* changeTexture(ResTIMG const*, u8, JUTPalette*);\n    /* 802FDAC8 */ virtual const ResTIMG* changeTexture(char const*, u8, JUTPalette*);\n    /* 800539DC */ virtual JUTTexture* getTexture(u8) const;\n    /* 802FF634 */ virtual u8 getTextureCount() const;\n    /* 80053C6C */ virtual bool setBlack(JUtility::TColor);\n    /* 80053C44 */ virtual bool setWhite(JUtility::TColor);\n    /* 8018BEE0 */ virtual bool setBlackWhite(JUtility::TColor, JUtility::TColor);\n    /* 801DFA4C */ virtual JUtility::TColor getBlack() const;\n    /* 801DFA40 */ virtual JUtility::TColor getWhite() const;\n    /* 8025603C */ virtual bool getMaterial() const;\n    /* 802FDBFC */ virtual void drawFullSet(f32, f32, f32, f32, Mtx*);\n    /* 802FE380 */ virtual void drawTexCoord(f32, f32, f32, f32, s16, s16, s16, s16, s16, s16, s16,\n                                             s16, Mtx*);\n    /* 802FF100 */ virtual u8 getUsableTlut(u8);\n\n    /* 802FC800 */ J2DPicture(u64, JGeometry::TBox2<f32> const&, ResTIMG const*, ResTLUT const*);\n    /* 802FC708 */ J2DPicture(ResTIMG const*);\n    /* 802FC118 */ J2DPicture(J2DPane*, JSURandomInputStream*, JKRArchive*);\n    /* 802FC050 */ J2DPicture();\n    /* 802FC1D4 */ J2DPicture(J2DPane*, JSURandomInputStream*, J2DMaterial*);\n    /* 802FC8E8 */ void private_readStream(J2DPane*, JSURandomInputStream*, JKRArchive*);\n    /* 802FCD70 */ void private_initiate(ResTIMG const*, ResTLUT const*);\n    /* 802FCE9C */ void initinfo();\n    /* 802FE5D0 */ void setTevMode();\n    /* 802FEA60 */ static void swap(f32&, f32&);\n    /* 802FEAC4 */ void setBlendKonstColor();\n    /* 802FEB94 */ void setBlendKonstAlpha();\n    /* 802FEC64 */ void getNewColor(JUtility::TColor*);\n    /* 802FED84 */ void setTexCoord(JGeometry::TVec2<s16>*, JUTTexture const*, J2DBinding,\n                                    J2DMirror, bool);\n    /* 802FED44 */ void setTexCoord(JUTTexture const*, J2DBinding, J2DMirror, bool);\n    /* 802FF1D0 */ GXTlut getTlutID(ResTIMG const*, u8);\n\n    void setCornerColor(JUtility::TColor c0, JUtility::TColor c1, JUtility::TColor c2,\n                        JUtility::TColor c3) {\n        mCornerColor[0] = c0;\n        mCornerColor[1] = c1;\n        mCornerColor[2] = c2;\n        mCornerColor[3] = c3;\n    }\n\nprotected:\n    /* 0x100 */ JUTTexture* mTexture[2];\n    /* 0x108 */ u8 mTextureCount;\n    /* 0x109 */ u8 field_0x109;\n    /* 0x10A */ JGeometry::TVec2<s16> field_0x10a[4];\n    /* 0x11C */ f32 field_0x11c[2];\n    /* 0x124 */ f32 field_0x124[2];\n    /* 0x12C */ JUTPalette* mPalette;\n    /* 0x130 */ JUtility::TColor mWhite;\n    /* 0x134 */ JUtility::TColor mBlack;\n    /* 0x138 */ JUtility::TColor mCornerColor[4];\n    /* 0x148 */ JUtility::TColor field_0x148;\n    /* 0x14C */ JUtility::TColor field_0x14c;\n};\n\n#endif /* J2DPICTURE_H */\n/* end \"JSystem/J2DGraph/J2DPicture.h\" */\n/* \"include/d/d_drawlist.h\" line 4 \"SSystem/SComponent/c_m3d_g_pla.h\" */\n#ifndef C_M3C_G_PLA_H_\n#define C_M3C_G_PLA_H_\n\n/* \"include/SSystem/SComponent/c_m3d_g_pla.h\" line 3 \"SSystem/SComponent/c_xyz.h\" */\n/* end \"SSystem/SComponent/c_xyz.h\" */\n/* \"include/SSystem/SComponent/c_m3d_g_pla.h\" line 4 \"SSystem/SComponent/c_m3d.h\" */\n#ifndef C_M3D_H_\n#define C_M3D_H_\n\n/* \"include/SSystem/SComponent/c_m3d.h\" line 3 \"math.h\" */\n/* end \"math.h\" */\n/* \"include/SSystem/SComponent/c_m3d.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n/* \"include/SSystem/SComponent/c_m3d.h\" line 5 \"dolphin/mtx/vec.h\" */\n/* end \"dolphin/mtx/vec.h\" */\n\nclass cM3dGAab;\nclass cM3dGCps;\nclass cM3dGCyl;\nclass cM3dGLin;\nclass cM3dGPla;\nclass cM3dGSph;\nclass cM3dGTri;\nclass csXyz;\nclass cXyz;\n\nstruct cM3d_Range;\nstruct Vec;\n\nextern f32 G_CM3D_F_ABS_MIN;\n\nstatic void cM3d_InDivPos1(const Vec*, const Vec*, f32, Vec*);\nvoid cM3d_InDivPos2(const Vec*, const Vec*, f32, Vec*);\nf32 cM3d_Len2dSq(f32, f32, f32, f32);\nbool cM3d_Len2dSqPntAndSegLine(f32, f32, f32, f32, f32, f32, f32*, f32*, f32*);\nbool cM3d_Len3dSqPntAndSegLine(const cM3dGLin*, const Vec*, Vec*, f32*);\nf32 cM3d_SignedLenPlaAndPos(const cM3dGPla*, const Vec*);\nf32 cM3d_VectorProduct2d(f32, f32, f32, f32, f32, f32);\nvoid cM3d_VectorProduct(const cXyz*, const cXyz*, const cXyz*, cXyz*);\nvoid cM3d_CalcPla(const Vec*, const Vec*, const Vec*, Vec*, f32*);\nbool cM3d_Cross_AabAab(const cM3dGAab*, const cM3dGAab*);\nbool cM3d_Cross_AabCyl(const cM3dGAab*, const cM3dGCyl*);\nbool cM3d_Cross_AabSph(const cM3dGAab*, const cM3dGSph*);\nstatic int cM3d_Check_LinLin(const cM3dGLin*, const cM3dGLin*, f32*, f32*);\nstatic bool cM3d_CrossInfLineVsInfPlane_proc(f32, f32, const Vec*, const Vec*, Vec*);\nbool cM3d_Cross_LinPla(const cM3dGLin*, const cM3dGPla*, Vec*, bool, bool);\nbool cM3d_Cross_MinMaxBoxLine(const Vec*, const Vec*, const Vec*, const Vec*);\nstatic bool cM3d_InclusionCheckPosIn3PosBox3d(const Vec*, const Vec*, const Vec*, const Vec*, f32);\nstatic bool cM3d_InclusionCheckPosIn3PosBox2d(f32, f32, f32, f32, f32, f32, f32, f32, f32);\nstatic bool cM3d_CrossX_Tri(const cM3dGTri*, const Vec*, f32);\nstatic bool cM3d_CrossX_Tri(const cM3dGTri*, const Vec*);\nstatic bool cM3d_CrossX_LinTri_proc(const cM3dGTri*, const Vec*);\nbool cM3d_CrossY_Tri(const cM3dGTri*, const Vec*);\nstatic bool cM3d_CrossY_LinTri_proc(const cM3dGTri*, const Vec*);\nbool cM3d_CrossY_Tri(const Vec&, const Vec&, const Vec&, const cM3dGPla&, const Vec*);\nbool cM3d_CrossY_Tri_Front(const Vec&, const Vec&, const Vec&, const Vec*);\nstatic bool cM3d_CrossY_Tri(const cM3dGTri*, const Vec*, f32*);\nstatic bool cM3d_CrossY_Tri(const cM3dGTri*, const Vec*, f32);\nstatic bool cM3d_CrossY_Tri(const cM3dGTri*, const Vec*, const cM3d_Range*, f32*);\nstatic bool cM3d_CrossZ_Tri(const cM3dGTri*, const Vec*, f32);\nstatic bool cM3d_CrossZ_Tri(const cM3dGTri*, const Vec*);\nstatic bool cM3d_CrossZ_LinTri_proc(const cM3dGTri*, const Vec*);\nbool cM3d_Cross_LinTri(const cM3dGLin*, const cM3dGTri*, Vec*, bool, bool);\nstatic bool cM3d_Cross_LinTri_Easy(const cM3dGTri*, const Vec*);\nstatic bool cM3d_Cross_SphPnt(const cM3dGSph*, const Vec*);\nbool cM3d_Cross_LinSph(const cM3dGLin*, const cM3dGSph*, Vec*);\nint cM3d_Cross_LinSph_CrossPos(const cM3dGSph&, const cM3dGLin&, Vec*, Vec*);\nbool cM3d_Cross_CylSph(const cM3dGCyl*, const cM3dGSph*, f32*);\nbool cM3d_Cross_CylSph(const cM3dGCyl*, const cM3dGSph*, Vec*, f32*);\nbool cM3d_Cross_SphSph(const cM3dGSph*, const cM3dGSph*, f32*);\nstatic bool cM3d_Cross_SphSph(const cM3dGSph*, const cM3dGSph*, f32*, f32*);\nbool cM3d_Cross_SphSph(const cM3dGSph*, const cM3dGSph*, Vec*);\nstatic void cM3d_CalcSphVsTriCrossPoint(const cM3dGSph*, const cM3dGTri*, Vec*);\nbool cM3d_Cross_SphTri(const cM3dGSph*, const cM3dGTri*, Vec*);\ninline bool cM3d_Cross_SphTri(const cM3dGSph* param_0, const cM3dGTri* param_1) {\n    return cM3d_Cross_SphTri(param_0, param_1, NULL);\n}\nbool cM3d_Cross_CylCyl(const cM3dGCyl*, const cM3dGCyl*, f32*);\nbool cM3d_Cross_CylCyl(const cM3dGCyl*, const cM3dGCyl*, Vec*);\nbool cM3d_Cross_CylTri(const cM3dGCyl*, const cM3dGTri*, Vec*);\nint cM3d_Cross_CylLin(const cM3dGCyl*, const cM3dGLin*, Vec*, Vec*);\nstatic int cM3d_Cross_CylPntPnt(const cM3dGCyl*, const Vec*, const Vec*, Vec*, Vec*);\nstatic bool cM3d_Cross_CylPnt(const cM3dGCyl*, const Vec*);\nbool cM3d_Cross_CpsCps(const cM3dGCps&, const cM3dGCps&, Vec*);\nbool cM3d_Cross_CpsCyl(const cM3dGCps&, const cM3dGCyl&, Vec*);\nstatic bool cM3d_Cross_CpsSph_CrossPos(const cM3dGCps&, const cM3dGSph&, const Vec&, Vec*);\nbool cM3d_Cross_CpsSph(const cM3dGCps&, const cM3dGSph&, Vec*);\nbool cM3d_Cross_TriTri(const cM3dGTri&, const cM3dGTri&, Vec*);\nbool cM3d_Cross_CpsTri(const cM3dGCps&, cM3dGTri, Vec*);\nvoid cM3d_CalcVecAngle(const Vec&, short*, short*);\nvoid cM3d_CalcVecZAngle(const Vec&, csXyz*);\nstatic void cM3d_PlaneCrossLineProcWork(f32, f32, f32, f32, f32, f32, f32, f32*, f32*);\nstatic int cM3d_2PlaneCrossLine(const cM3dGPla&, const cM3dGPla&, cM3dGLin*);\nbool cM3d_3PlaneCrossPos(const cM3dGPla&, const cM3dGPla&, const cM3dGPla&, Vec*);\nf32 cM3d_lineVsPosSuisenCross(const cM3dGLin*, const Vec*, Vec*);\nf32 cM3d_lineVsPosSuisenCross(const Vec&, const Vec&, const Vec&, Vec*);\nint cM3d_2PlaneLinePosNearPos(const cM3dGPla&, const cM3dGPla&, const Vec*, Vec*);\nvoid cM3d_CrawVec(const Vec&, const Vec&, Vec*);\n\ninline bool cM3d_IsZero(f32 f) {\n    return fabsf(f) < G_CM3D_F_ABS_MIN;\n}\n// this is the inline cM3d_IsZero but inverted. Sometimes this will get a match where the regular cM3d_IsZero inline won't\ninline bool cM3d_IsZero_inverted(f32 param_0) {\n    return !(fabsf(param_0) < G_CM3D_F_ABS_MIN);\n}\n\ninline f32 cM3d_LenSq(const Vec* a, const Vec* b) {\n    return VECSquareDistance(a, b);\n}\n\n#endif/* end \"SSystem/SComponent/c_m3d.h\" */\n\n// Plane with a normal\nclass cM3dGPla {\npublic:\n    /* 0x00 */ cXyz mNormal;\n    /* 0x0C */ f32 mD;\n    /* 0x10   vtable */\n\n    cM3dGPla() {}\n    cM3dGPla(const cXyz*, f32);\n    bool crossInfLin(const cXyz&, const cXyz&, cXyz&) const;\n    void SetupNP0(const Vec&, const Vec&);\n    void SetupNP(const Vec&, const Vec&);\n    bool getCrossY(const cXyz&, f32*) const;\n    bool getCrossYLessD(const Vec&, f32*) const;\n    void Set(const cM3dGPla*);\n    void GetNP();\n\n    virtual ~cM3dGPla() {}\n\n    f32 getPlaneFunc(const Vec* pPoint) const { return mD + VECDotProduct(&mNormal, pPoint); }\n    const cXyz& GetNP() const { return mNormal; }\n    const cXyz* i_GetNP() const { return &mNormal; }\n    f32 GetD() const { return mD; }\n    void SetupFrom3Vtx(const Vec* v1, const Vec* v2, const Vec* v3) {\n        cM3d_CalcPla(v1, v2, v3, &mNormal, &mD);\n    }\n    f32 getCrossY_NonIsZero(const cXyz *param_1) {\n        return ((-mNormal.x * param_1->x - mNormal.z * param_1->z) - mD) / mNormal.y;\n    }\n};\n\n#endif/* end \"SSystem/SComponent/c_m3d_g_pla.h\" */\n/* \"include/d/d_drawlist.h\" line 5 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n/* \"include/d/d_drawlist.h\" line 6 \"f_op/f_op_view.h\" */\n#ifndef F_F_OP_VIEW_H_\n#define F_F_OP_VIEW_H_\n\n/* \"include/f_op/f_op_view.h\" line 3 \"SSystem/SComponent/c_xyz.h\" */\n/* end \"SSystem/SComponent/c_xyz.h\" */\n/* \"include/f_op/f_op_view.h\" line 4 \"dolphin/mtx/mtx.h\" */\n/* end \"dolphin/mtx/mtx.h\" */\n/* \"include/f_op/f_op_view.h\" line 5 \"f_pc/f_pc_leaf.h\" */\n\n#ifndef F_PC_LEAF_H_\n#define F_PC_LEAF_H_\n\n/* \"include/f_pc/f_pc_leaf.h\" line 4 \"f_pc/f_pc_base.h\" */\n\n#ifndef F_PC_BASE_H_\n#define F_PC_BASE_H_\n\n/* \"include/f_pc/f_pc_base.h\" line 4 \"f_pc/f_pc_delete_tag.h\" */\n\n#ifndef F_PC_DELETE_TAG_H_\n#define F_PC_DELETE_TAG_H_\n\n/* \"include/f_pc/f_pc_delete_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n#ifndef C_TAG_H\n#define C_TAG_H\n\n/* \"include/SSystem/SComponent/c_tag.h\" line 3 \"SSystem/SComponent/c_node.h\" */\n#ifndef C_NODE_H\n#define C_NODE_H\n\n\ntypedef struct node_class {\n    struct node_class* mpPrevNode;\n    void* mpData;\n    struct node_class* mpNextNode;\n} node_class;\n\nvoid cNd_Join(node_class* pA, node_class* pB);\nint cNd_LengthOf(node_class* pNode);\nnode_class* cNd_First(node_class* pNode);\nnode_class* cNd_Last(node_class* pNode);\nnode_class* cNd_Order(node_class* pNode, int idx);\nvoid cNd_SingleCut(node_class* pNode);\nvoid cNd_Cut(node_class* pNode);\nvoid cNd_Addition(node_class* pA, node_class* pB);\nvoid cNd_Insert(node_class* pA, node_class* pB);\nvoid cNd_SetObject(node_class* pNode, void* pData);\nvoid cNd_ClearObject(node_class* pNode);\nvoid cNd_ForcedClear(node_class* pNode);\nvoid cNd_Create(node_class* pNode, void* pData);\n\n#define NODE_GET_PREV(pNode) (pNode ? pNode->mpPrevNode : NULL)\n#define NODE_GET_NEXT(pNode) (pNode ? pNode->mpNextNode : NULL)\n\n#endif /* C_NODE_H */\n/* end \"SSystem/SComponent/c_node.h\" */\n/* \"include/SSystem/SComponent/c_tag.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef struct node_list_class node_list_class;\ntypedef struct node_lists_tree_class node_lists_tree_class;\n\ntypedef struct create_tag_class {\n    node_class mpNode;\n    void* mpTagData;\n    s8 mbIsUse;\n} create_tag_class;\n\nint cTg_IsUse(create_tag_class* pTag);\nint cTg_SingleCutFromTree(create_tag_class* pTag);\nint cTg_AdditionToTree(node_lists_tree_class* pTree, int listIdx, create_tag_class* pTag);\nint cTg_InsertToTree(node_lists_tree_class* pTree, int listIdx, create_tag_class* pTag, int idx);\nnode_class* cTg_GetFirst(node_list_class* pTag);\nint cTg_SingleCut(create_tag_class* pTag);\nint cTg_Addition(node_list_class* pList, create_tag_class* pTag);\nvoid cTg_Create(create_tag_class* pTag, void* pData);\n\n#endif /* C_TAG_H */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef struct layer_class layer_class;\n\ntypedef int (*delete_tag_func)(void*);\n\ntypedef struct delete_tag_class {\n    create_tag_class mBase;\n    layer_class* mpLayer;\n    s16 mTimer;\n} delete_tag_class;\n\nBOOL fpcDtTg_IsEmpty(void);\nvoid fpcDtTg_ToDeleteQ(delete_tag_class* pTag);\nvoid fpcDtTg_DeleteQTo(delete_tag_class* pTag);\ns32 fpcDtTg_Do(delete_tag_class* pTag, delete_tag_func pFunc);\ns32 fpcDtTg_Init(delete_tag_class* pTag, void* pUserData);\n\nextern node_list_class g_fpcDtTg_Queue;\n\n#endif\n/* end \"f_pc/f_pc_delete_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 5 \"f_pc/f_pc_layer_tag.h\" */\n\n#ifndef F_PC_LAYER_TAG_H_\n#define F_PC_LAYER_TAG_H_\n\n/* \"include/f_pc/f_pc_layer_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\nenum {\n    fpcLy_ROOT_e    = 0,\n    fpcLy_CURRENT_e = 0xFFFFFFFD,\n    fpcLy_SPECIAL_e = 0xFFFFFFFE,\n    fpcLy_NONE_e    = 0xFFFFFFFF,\n};\n\ntypedef struct layer_class layer_class;\n\n\ntypedef struct layer_management_tag_class {\n    create_tag_class mCreateTag;\n    layer_class* mpLayer;\n    u16 mNodeListID;\n    u16 mNodeListIdx;\n} layer_management_tag_class;\n\ns32 fpcLyTg_QueueTo(layer_management_tag_class* pTag);\ns32 fpcLyTg_ToQueue(layer_management_tag_class* pTag, unsigned int layerID, u16 listID,\n                    u16 listPrio);\ns32 fpcLyTg_Move(layer_management_tag_class*, unsigned int, u16, u16);\ns32 fpcLyTg_Init(layer_management_tag_class*, unsigned int, void*);\n\n#endif\n/* end \"f_pc/f_pc_layer_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 6 \"f_pc/f_pc_line_tag.h\" */\n\n#ifndef F_PC_LINE_TAG_H_\n#define F_PC_LINE_TAG_H_\n\n/* \"include/f_pc/f_pc_line_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef struct line_tag {\n    create_tag_class mBase;\n    s32 mLineListID;\n} line_tag;\n\ns32 fpcLnTg_Move(line_tag* pLineTag, int newLineListID);\nvoid fpcLnTg_QueueTo(line_tag* pLineTag);\ns32 fpcLnTg_ToQueue(line_tag* pLineTag, int lineListID);\nvoid fpcLnTg_Init(line_tag* pLineTag, void* pData);\n\n#endif\n/* end \"f_pc/f_pc_line_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 7 \"f_pc/f_pc_priority.h\" */\n\n#ifndef F_PC_PRIORITY_H_\n#define F_PC_PRIORITY_H_\n\n/* \"include/f_pc/f_pc_priority.h\" line 4 \"f_pc/f_pc_method_tag.h\" */\n\n#ifndef F_PC_METHOD_TAG_H_\n#define F_PC_METHOD_TAG_H_\n\n/* \"include/f_pc/f_pc_method_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef int (*process_method_tag_func)(void*);\n\ntypedef struct process_method_tag_class {\n    create_tag_class mCreateTag;\n    process_method_tag_func mpFunc;\n    void* mpMthdData;\n} process_method_tag_class;\n\ns32 fpcMtdTg_Do(process_method_tag_class* pMthd);\ns32 fpcMtdTg_ToMethodQ(node_list_class* pList, process_method_tag_class* pMthd);\nvoid fpcMtdTg_MethodQTo(process_method_tag_class* pMthd);\ns32 fpcMtdTg_Init(process_method_tag_class* pMthd, process_method_tag_func pFunc, void* pMthdData);\n\n#endif\n/* end \"f_pc/f_pc_method_tag.h\" */\n\nenum {\n    fpcPi_CURRENT_e = 0xFFFD,\n    fpcPi_SPECIAL_e = 0xFFFE,\n};\n\ntypedef struct process_priority_queue_info {\n    u32 mLayer;\n    u16 mListID;\n    u16 mListPrio;\n} process_priority_queue_info;\n\ntypedef struct process_priority_class {\n    /* 0x00 */ create_tag_class mBase;\n    /* 0x14 */ process_method_tag_class mMtdTag;\n    /* 0x30 */ process_priority_queue_info mInfoQ;\n    /* 0x38 */ process_priority_queue_info mInfoCurr;\n} process_priority_class;\n\ns32 fpcPi_IsInQueue(process_priority_class* pPi);\ns32 fpcPi_QueueTo(process_priority_class* pPi);\ns32 fpcPi_ToQueue(process_priority_class* pPi);\nprocess_priority_class* fpcPi_GetFromQueue(void);\ns32 fpcPi_Delete(process_priority_class* pPi);\ns32 fpcPi_IsNormal(unsigned int layer, u16 listID, u16 priority);\ns32 fpcPi_Change(process_priority_class* pPi, unsigned int layer, u16 listID, u16 priority);\ns32 fpcPi_Handler(void);\ns32 fpcPi_Init(process_priority_class* pPi, void* pUserData, unsigned int layer, u16 listID,\n               u16 priority);\n\nextern s8 data_804505F0;  // roomReadId\n\n#endif\n/* end \"f_pc/f_pc_priority.h\" */\n\ntypedef struct create_request create_request;\ntypedef struct process_method_class process_method_class; \ntypedef struct process_profile_definition process_profile_definition;\ntypedef struct profile_method_class profile_method_class;\n\ntypedef struct base_process_class {\n    /* 0x00 */ u32 mBsType;\n    /* 0x04 */ u32 mBsPcId;\n    /* 0x08 */ s16 mProcName;\n    /* 0x0A */ s8 mUnk0;\n    /* 0x0B */ u8 mPauseFlag;\n    /* 0x0C */ s8 mInitState;\n    /* 0x0D */ u8 mUnk2;\n    /* 0x0E */ s16 mBsTypeId;\n    /* 0x10 */ process_profile_definition* mpProf;\n    /* 0x14 */ struct create_request* mpCtRq;\n    /* 0x18 */ layer_management_tag_class mLyTg;\n    /* 0x34 */ line_tag mLnTg;\n    /* 0x4C */ delete_tag_class mDtTg;\n    /* 0x68 */ process_priority_class mPi;\n    /* 0xA8 */ process_method_class* mpPcMtd;\n    /* 0xAC */ void* mpUserData;\n    /* 0xB0 */ u32 mParameters;\n    /* 0xB4 */ u32 mSubType;\n} base_process_class;  // Size: 0xB8\n\ns32 fpcBs_Is_JustOfType(int pType1, int pType2);\ns32 fpcBs_MakeOfType(int* pType);\ns32 fpcBs_MakeOfId(void);\ns32 fpcBs_Execute(base_process_class* pProc);\nvoid fpcBs_DeleteAppend(base_process_class* pProc);\ns32 fpcBs_IsDelete(base_process_class* pProc);\ns32 fpcBs_Delete(base_process_class* pProc);\nbase_process_class* fpcBs_Create(s16 pProcTypeID, unsigned int pProcID, void* pData);\ns32 fpcBs_SubCreate(base_process_class* pProc);\n\nextern \"C\" {\nvoid fpcBs_MakeOfType__FPi(void);\nvoid fpcBs_Is_JustOfType__Fii(void);\n}\n\n#endif\n/* end \"f_pc/f_pc_base.h\" */\n/* \"include/f_pc/f_pc_leaf.h\" line 5 \"f_pc/f_pc_draw_priority.h\" */\n\n#ifndef F_PC_DRAW_PRIORITY_H_\n#define F_PC_DRAW_PRIORITY_H_\n\n/* \"include/f_pc/f_pc_draw_priority.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef struct draw_priority_class {\n    s16 mPriority;\n} draw_priority_class;\n\ns16 fpcDwPi_Get(const draw_priority_class* pDwPi);\nvoid fpcDwPi_Set(draw_priority_class* pDwPi, s16 p);\nvoid fpcDwPi_Init(draw_priority_class* pDwPi, s16 p);\n\n#endif\n/* end \"f_pc/f_pc_draw_priority.h\" */\n/* \"include/f_pc/f_pc_leaf.h\" line 6 \"f_pc/f_pc_method.h\" */\n\n#ifndef F_PC_METHOD_H_\n#define F_PC_METHOD_H_\n\n/* \"include/f_pc/f_pc_method.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef int (*process_method_func)(void*);\n\ntypedef struct process_method_class {\n    process_method_func mpCreateFunc;\n    process_method_func mpDeleteFunc;\n    process_method_func mpExecuteFunc;\n    process_method_func mpIsDeleteFunc;\n} process_method_class;\n\ns32 fpcMtd_Method(process_method_func pFunc, void* pUserData);\ns32 fpcMtd_Execute(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_IsDelete(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_Delete(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_Create(process_method_class* pMthd, void* pUserData);\n\nextern \"C\" {\nvoid fpcMtd_Execute__FP20process_method_classPv(void);\nvoid fpcMtd_Create__FP20process_method_classPv(void);\n}\n\n#endif\n/* end \"f_pc/f_pc_method.h\" */\n/* \"include/f_pc/f_pc_leaf.h\" line 7 \"f_pc/f_pc_profile.h\" */\n\n#ifndef F_PC_PROFILE_H_\n#define F_PC_PROFILE_H_\n\n/* \"include/f_pc/f_pc_profile.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef struct nodedraw_method_class nodedraw_method_class;\ntypedef struct leafdraw_method_class leafdraw_method_class;\ntypedef struct process_method_class process_method_class;\n\ntypedef struct process_profile_definition {\n    /* 0x00 */ s32 mLayerID;\n    /* 0x04 */ u16 mListID;\n    /* 0x06 */ u16 mListPrio;\n    /* 0x08 */ s16 mProcName;\n    /* 0x0C */ process_method_class* mSubMtd; // Subclass methods\n    /* 0x10 */ s32 mSize;\n    /* 0x14 */ s32 mSizeOther;\n    /* 0x18 */ s32 mParameters;\n} process_profile_definition;\n\n#define LAYER_DEFAULT (-2)\n\nstruct leaf_process_profile_definition;\nprocess_profile_definition* fpcPf_Get(s16 profileID);\nextern process_profile_definition** g_fpcPf_ProfileList_p;\n\n#endif\n/* end \"f_pc/f_pc_profile.h\" */\n\ntypedef struct leafdraw_method_class {\n    /* 0x00 */ process_method_class mBase;\n    /* 0x10 */ process_method_func mpDrawFunc;\n} leafdraw_method_class;\n\ntypedef struct leafdraw_class {\n    /* 0x00 */ base_process_class mBase;\n    /* 0xB8 */ leafdraw_method_class* mpDrawMtd;\n    /* 0xBC */ s8 mbUnk0;\n    /* 0xBD */ u8 mbUnk1;\n    /* 0xBE */ draw_priority_class mDwPi;\n} leafdraw_class;\n\ntypedef struct leaf_process_profile_definition {\n    /* 0x00 */ process_profile_definition mBase;\n    /* 0x1C */ leafdraw_method_class* mSubMtd; // Subclass methods\n    /* 0x20 */ s16 mPriority; // mDrawPriority\n} leaf_process_profile_definition;\n\ns16 fpcLf_GetPriority(const leafdraw_class* pLeaf);\ns32 fpcLf_DrawMethod(leafdraw_method_class* pMthd, void* pUserData);\ns32 fpcLf_Draw(leafdraw_class* pMthd);\ns32 fpcLf_Execute(leafdraw_class* pLeaf);\ns32 fpcLf_IsDelete(leafdraw_class* pLeaf);\ns32 fpcLf_Delete(leafdraw_class* pLeaf);\ns32 fpcLf_Create(leafdraw_class* pLeaf);\n\nextern int g_fpcLf_type;\nextern leafdraw_method_class g_fpcLf_Method;\n\n#endif\n/* end \"f_pc/f_pc_leaf.h\" */\n\nstruct view_process_profile_definition {\n    /* 0x00 */ leaf_process_profile_definition mBase;\n    /* 0x24 */ leafdraw_method_class* mSubMtd; // Subclass methods\n    /* 0x28 */ u8 unk28;\n    /* 0x29 */ u8 unk29[3]; // pad\n    /* 0x2C */ u32 unk2C;\n    /* 0x30 */ u32 unk30;\n    /* 0x34 */ u32 unk34;\n    /* 0x38 */ u32 unk38;\n};\n\nclass lookat_class {\npublic:\n    /* 0x00 */ cXyz mEye;\n    /* 0x0C */ cXyz mCenter;\n    /* 0x18 */ cXyz mUp;\n};\n\nstruct scissor_class {\n    /* 0x0 */ f32 mXOrig;\n    /* 0x4 */ f32 mYOrig;\n    /* 0x8 */ f32 mWidth;\n    /* 0xC */ f32 mHeight;\n};\n\nstruct view_port_class {\n    /* 0x00 */ f32 mXOrig;\n    /* 0x04 */ f32 mYOrig;\n    /* 0x08 */ f32 mWidth;\n    /* 0x0C */ f32 mHeight;\n    /* 0x10 */ f32 mNearZ;\n    /* 0x14 */ f32 mFarZ;\n    /* 0x18 */ scissor_class mScissor;\n};\n\nstruct view_class : public leafdraw_class {\n    /* 0x0C0 */ leafdraw_method_class* mSubMtd;\n    /* 0x0C4 */ u8 field_0xc4;\n    /* 0x0C8 */ f32 mNear;\n    /* 0x0CC */ f32 mFar;\n    /* 0x0D0 */ f32 mFovy;\n    /* 0x0D4 */ f32 mAspect;\n    /* 0x0D8 */ lookat_class mLookat;\n    /* 0x0FC */ s16 mBank;\n    /* 0x100 */ Mtx44 mProjMtx;\n    /* 0x140 */ Mtx mViewMtx;\n    /* 0x170 */ Mtx mInvViewMtx;\n    /* 0x1A0 */ Mtx44 mProjViewMtx;\n    /* 0x1E0 */ Mtx mViewMtxNoTrans;\n};\n\n#endif/* end \"f_op/f_op_view.h\" */\n/* \"include/d/d_drawlist.h\" line 7 \"m_Do/m_Do_ext.h\" */\n/* end \"m_Do/m_Do_ext.h\" */\n/* \"include/d/d_drawlist.h\" line 8 \"global.h\" */\n/* end \"global.h\" */\n\nclass J3DDrawBuffer;\nclass J3DModel;\nclass J3DPacket;\nclass JUTFont;\nclass dKy_tevstr_c;\n\nclass cM_rnd_c {\npublic:\n    /* 80053CDC */ void init(int, int, int);\n    /* 80053CEC */ f32 get();\n    /* 80053DE0 */ f32 getF(f32);\n    /* 80053E18 */ f32 getFX(f32);\n    /* 80053E60 */ f32 getValue(f32, f32);\n\n    /* 0x0 */ int seed0;\n    /* 0x4 */ int seed1;\n    /* 0x8 */ int seed2;\n};\n\nclass dDlst_base_c {\npublic:\n    dDlst_base_c() {}\n    virtual void draw();\n};\n\nclass dDlst_effectLine_c : public dDlst_base_c {\npublic:\n    /* 80053E9C */ virtual void draw();\n    /* 800541F4 */ void update(cXyz&, _GXColor&, u16, u16, u16, u16, f32, f32, f32, f32);\n\n    f32 getRndValue(f32 param_0, f32 param_1) { return mRnd.getValue(param_0, param_1); }\n    f32 getRndFX(f32 param_0) { return mRnd.getFX(param_0); }\n\nprivate:\n    /* 0x04 */ cM_rnd_c mRnd;\n    /* 0x10 */ cXyz field_0x10;\n    /* 0x1C */ GXColor mLineColor;\n    /* 0x20 */ u16 field_0x20;\n    /* 0x22 */ u16 field_0x22;\n    /* 0x24 */ u16 field_0x24;\n    /* 0x26 */ u16 field_0x26;\n    /* 0x28 */ f32 field_0x28;\n    /* 0x2C */ f32 field_0x2c;\n    /* 0x30 */ f32 field_0x30;\n    /* 0x34 */ f32 field_0x34;\n};  // Size: 0x38\n\nclass dDlst_FileInfo_c : public dDlst_base_c {\npublic:\n    dDlst_FileInfo_c() {}\n    virtual void draw();\n    virtual ~dDlst_FileInfo_c();  // inlined\n\n    /* 0x04 */ J2DScreen* Scr;\n    /* 0x08 */ JUTFont* mFont;\n    /* 0x0C */ J2DPane* mBasePane;\n    /* 0x10 */ J2DPane* field_0x10;\n};\n\nclass dDlst_2D_c : public dDlst_base_c {\npublic:\n    /* 80053A00 */ dDlst_2D_c(ResTIMG* image, s16 posX, s16 posY, s16 width, s16 height, u8 alpha);\n    /* 80053A9C */ virtual void draw();\n\n    void setAlpha(u8 alpha) { mAlpha = alpha; }\n    J2DPicture* getPicture() { return &mpPicture; }\n\nprivate:\n    /* 0x004 */ u8 field_0x4;\n    /* 0x008 */ J2DPicture mpPicture;\n    /* 0x158 */ s16 mPosX;\n    /* 0x15A */ s16 mPosY;\n    /* 0x15C */ s16 mSizeX;\n    /* 0x15E */ s16 mSizeY;\n    /* 0x160 */ u8 mAlpha;\n};\n\nclass dDlst_2DT2_c : public dDlst_base_c {\npublic:\n    /* 80052354 */ virtual void draw();\n    /* 80052B00 */ dDlst_2DT2_c();\n    /* 80052B4C */ void init(ResTIMG*, f32, f32, f32, f32, u8, u8, u8, f32, f32);\n\n    f32 getScaleX() { return mScaleX; }\n    void setScaleX(f32 scale) { mScaleX = scale; }\n    void setScaleY(f32 scale) { mScaleY = scale; }\n\n    /* 0x04 */ GXTexObj mTexObj;\n    /* 0x24 */ f32 field_0x24;\n    /* 0x28 */ f32 field_0x28;\n    /* 0x2C */ f32 field_0x2c;\n    /* 0x30 */ f32 field_0x30;\n    /* 0x34 */ f32 mScaleX;\n    /* 0x38 */ f32 mScaleY;\n    /* 0x3C */ GXColor field_0x3c;\n    /* 0x40 */ GXColor field_0x40;\n    /* 0x44 */ u8 field_0x44;\n    /* 0x45 */ u8 field_0x45;\n    /* 0x46 */ u8 field_0x46;\n};  // Size: 0x48\n\nclass dDlst_peekZ_c {\npublic:\n    struct dDlst_peekZ_entry {\n        /* 0x0 */ s16 x;\n        /* 0x2 */ s16 y;\n        /* 0x4 */ u32* dst;\n    };\n\n    dDlst_peekZ_c() { mCount = 0; }\n    /* 80056018 */ int newData(s16, s16, u32*);\n    /* 80056080 */ void peekData();\n\n    /* 0x0 */ u8 mCount;\n    /* 0x4 */ dDlst_peekZ_entry mEntries[0x40];\n};\n\nclass dDlst_shadowSimple_c {\npublic:\n    /* 8005520C */ void draw();\n    /* 800553EC */ void set(cXyz*, f32, f32, cXyz*, s16, f32, _GXTexObj*);\n    /* 8005638C */ dDlst_shadowSimple_c();\n\n    /* 0x00 */ u8 mAlpha;\n    /* 0x04 */ _GXTexObj* mpTexObj;\n    /* 0x08 */ Mtx mVolumeMtx;\n    /* 0x38 */ Mtx mMtx;\n};  // Size: 0x68\n\nstruct cBgD_Vtx_t;\n\nclass dDlst_shadowTri_c {\npublic:\n    /* 80056270 */ ~dDlst_shadowTri_c() {}\n    /* 80056344 */ dDlst_shadowTri_c() {}\n\n    /* 0x0 */ cXyz mPos[3];\n};\n\nclass dDlst_shadowPoly_c {\npublic:\n    dDlst_shadowPoly_c() {\n        reset();\n    }\n\n    void reset() { mCount = 0; }\n\n    /* 80054288 */ int set(cBgD_Vtx_t*, u16, u16, u16, cM3dGPla*);\n    /* 800543B4 */ void draw();\n\n    virtual dDlst_shadowTri_c* getTri() = 0;\n    virtual s32 getTriMax() = 0;\n\n    /* 0x4 */ u16 mCount;\n    /* 0x6 */ u8 field_0x6[2];\n};\n\nclass dDlst_shadowRealPoly_c : public dDlst_shadowPoly_c {\npublic:\n    /* 800569A0 */ virtual dDlst_shadowTri_c* getTri();\n    /* 800569A8 */ virtual s32 getTriMax();\n\n    /* 0x8 */ dDlst_shadowTri_c mShadowTri[256];\n};\n\nclass dDlst_shadowReal_c {\npublic:\n    /* 800544F0 */ void reset();\n    /* 80054500 */ void imageDraw(f32 (*)[4]);\n    /* 800545D4 */ void draw();\n    /* 80054BD0 */ u8 setShadowRealMtx(cXyz*, cXyz*, f32, f32, f32, dKy_tevstr_c*);\n    /* 80055028 */ u32 set(u32, J3DModel*, cXyz*, f32, f32, dKy_tevstr_c*, f32, f32);\n    /* 800551D4 */ bool add(J3DModel*);\n    /* 800561F8 */ ~dDlst_shadowReal_c() {}\n    /* 800562D0 */ dDlst_shadowReal_c() { mState = 0; }\n\n    dDlst_shadowReal_c* getZsortNext() { return mZsortNext; }\n    bool isNoUse() { return mState == 0; }\n    bool isUse() { return mState == 1; }\n    bool checkKey(u32 i_key) { return mKey == i_key; }\n\nprivate:\n    /* 0x0000 */ u8 mState;\n    /* 0x0001 */ u8 field_0x1;\n    /* 0x0002 */ u8 mModelNum;\n    /* 0x0003 */ u8 field_0x3;\n    /* 0x0004 */ u32 mKey;\n    /* 0x0008 */ Mtx mViewMtx;\n    /* 0x0038 */ Mtx44 mRenderProjMtx;\n    /* 0x0078 */ Mtx mReceiverProjMtx;\n    /* 0x00A8 */ dDlst_shadowRealPoly_c mShadowRealPoly;\n    /* 0x24B0 */ J3DModel* mpModels[38];\n    /* 0x2548 */ f32 mCameraZ;\n    /* 0x254C */ dDlst_shadowReal_c* mZsortPre;\n    /* 0x2550 */ dDlst_shadowReal_c* mZsortNext;\n};  // Size: 0x2554\n\nclass dDlst_shadowControl_c {\npublic:\n    dDlst_shadowControl_c() { field_0x0 = 0; }\n    /* 80055684 */ void init();\n    /* 80055768 */ void reset();\n    /* 800557C8 */ void imageDraw(f32 (*)[4]);\n    /* 80055A14 */ void draw(f32 (*)[4]);\n    /* 80055C74 */ int setReal(u32, s8, J3DModel*, cXyz*, f32, f32, dKy_tevstr_c*);\n    /* 80055F1C */ bool addReal(u32, J3DModel*);\n    /* 80055F84 */ int setSimple(cXyz*, f32, f32, cXyz*, s16, f32, _GXTexObj*);\n    /* 80055FE8 */ static void setSimpleTex(ResTIMG const*);\n\n    static GXTexObj* getSimpleTex() { return &mSimpleTexObj; }\n\n    static GXTexObj mSimpleTexObj;\n\nprivate:\n    /* 0x00000 */ u8 field_0x0;\n    /* 0x00001 */ u8 mRealNum;\n    /* 0x00002 */ u8 mSimpleNum;\n    /* 0x00004 */ dDlst_shadowReal_c* field_0x4;\n    /* 0x00008 */ dDlst_shadowReal_c* field_0x8;\n    /* 0x0000C */ dDlst_shadowSimple_c mSimple[128];\n    /* 0x0340C */ int mNextID;\n    /* 0x03410 */ dDlst_shadowReal_c mReal[8];\n    /* 0x15EB0 */ _GXTexObj field_0x15eb0[2];\n    /* 0x15EF0 */ void* field_0x15ef0[2];\n};\n\nclass dDlst_window_c {\npublic:\n    dDlst_window_c() {}\n    ~dDlst_window_c() {}\n    /* 80051AC0 */ void setViewPort(f32, f32, f32, f32, f32, f32);\n    /* 80051ADC */ void setScissor(f32, f32, f32, f32);\n\n    void setCameraID(int id) { mCameraID = id; }\n    s8 getCameraID() { return mCameraID; }\n    void setMode(int mode) { mMode = mode; }\n    view_port_class* getViewPort() { return &mViewport; }\n\nprivate:\n    /* 0x00 */ view_port_class mViewport;\n    /* 0x28 */ s8 mCameraID;\n    /* 0x29 */ s8 mMode;\n};\n\nSTATIC_ASSERT(sizeof(dDlst_window_c) == 0x2C);\n\nextern u8 mWipe__12dDlst_list_c;  // Wipe\n\nstruct view_port_class;\nstruct view_class;\n\nclass dDlst_list_c {\npublic:\n    /* 800560F0 */ dDlst_list_c();\n    /* 80056390 */ void init();\n    /* 8005648C */ ~dDlst_list_c();\n    /* 80056538 */ void reset();\n    /* 800565EC */ void entryZSortXluDrawList(J3DDrawBuffer*, J3DPacket*, cXyz&);\n    /* 800566D4 */ void drawOpaDrawList(J3DDrawBuffer*);\n    /* 80056710 */ void drawXluDrawList(J3DDrawBuffer*);\n    /* 8005674C */ void drawOpaListItem3d();\n    /* 80056770 */ void drawXluListItem3d();\n    /* 80056794 */ int set(dDlst_base_c**&, dDlst_base_c**&, dDlst_base_c*);\n    /* 800567C4 */ void draw(dDlst_base_c**, dDlst_base_c**);\n    /* 8005681C */ static void wipeIn(f32 i_wipeSpeed, GXColor& i_wipeColor);\n    /* 800568D8 */ static void wipeIn(f32 i_wipeSpeed);\n    /* 80056900 */ static void calcWipe();\n\n    enum DrawBuffer {\n        /* 0x00 */ DB_OPA_LIST_SKY,\n        /* 0x01 */ DB_XLU_LIST_SKY,\n        /* 0x02 */ DB_LIST_P0,\n        /* 0x03 */ DB_OPA_LIST_BG,\n        /* 0x04 */ DB_XLU_LIST_BG,\n        /* 0x05 */ DB_OPA_LIST_DARK_BG,\n        /* 0x06 */ DB_XLU_LIST_DARK_BG,\n        /* 0x07 */ DB_OPA_LIST,\n        /* 0x08 */ DB_XLU_LIST,\n        /* 0x09 */ DB_OPA_LIST_DARK,\n        /* 0x0A */ DB_XLU_LIST_DARK,\n        /* 0x0B */ DB_OPA_LIST_PACKET,\n        /* 0x0C */ DB_LIST_FILTER,\n        /* 0x0D */ DB_OPA_LIST_ITEM3D,\n        /* 0x0E */ DB_XLU_LIST_ITEM3D,\n        /* 0x0F */ DB_OPA_LIST_INVISIBLE,\n        /* 0x10 */ DB_XLU_LIST_INVISIBLE,\n        /* 0x11 */ DB_LIST_Z_XLU,\n        /* 0x12 */ DB_LIST_2D_SCREEN,\n        /* 0x13 */ DB_LIST_MIDDLE,\n        /* 0x14 */ DB_LIST_3D_LAST,\n    };\n\n    void set2DOpa(dDlst_base_c* dlst) { set(mp2DOpaStart, mp2DOpaEnd, dlst); }\n    void set2DOpaTop(dDlst_base_c* dlst) { set(mp2DOpaTopStart, mp2DOpaTopEnd, dlst); }\n    void set2DXlu(dDlst_base_c* dlst) { set(mp2DXluStart, mp2DXluEnd, dlst); }\n    void setCopy2D(dDlst_base_c* dlst) { set(mpCopy2DStart, mpCopy2DEnd, dlst); }\n    view_class* getView() { return mView; }\n    void setView(view_class* view) { mView = view; }\n    void setWindow(dDlst_window_c* window) { mWindow = window; }\n    void setViewport(view_port_class* port) { mViewport = port; }\n    J3DDrawBuffer* getOpaListFilter() { return mDrawBuffers[DB_LIST_FILTER]; }\n    J3DDrawBuffer* getOpaListP0() { return mDrawBuffers[DB_LIST_P0]; }\n    J3DDrawBuffer* getOpaListPacket() { return mDrawBuffers[DB_OPA_LIST_PACKET]; }\n    J3DDrawBuffer* getOpaListBG() { return mDrawBuffers[DB_OPA_LIST_BG]; }\n    J3DDrawBuffer* getOpaListDark() { return mDrawBuffers[DB_OPA_LIST_DARK]; }\n    void setXluDrawList(J3DDrawBuffer* buffer) { j3dSys.setDrawBuffer(buffer, J3DSys_XLU_BUFFER_e); }\n    void setOpaDrawList(J3DDrawBuffer* buffer) { j3dSys.setDrawBuffer(buffer, J3DSys_OPA_BUFFER_e); }\n    void setXluListSky() { setXluDrawList(mDrawBuffers[DB_XLU_LIST_SKY]); }\n    void setOpaListSky() { setOpaDrawList(mDrawBuffers[DB_OPA_LIST_SKY]); }\n    void setXluListDark() { setXluDrawList(mDrawBuffers[DB_XLU_LIST_DARK]); }\n    void setOpaListDark() { setOpaDrawList(mDrawBuffers[DB_OPA_LIST_DARK]); }\n    void setOpaListInvisible() { setOpaDrawList(mDrawBuffers[DB_OPA_LIST_INVISIBLE]); }\n    void setXluListInvisible() { setXluDrawList(mDrawBuffers[DB_XLU_LIST_INVISIBLE]); }\n    void setXluListDarkBG() { setXluDrawList(mDrawBuffers[DB_XLU_LIST_DARK_BG]); }\n    void setOpaListDarkBG() { setOpaDrawList(mDrawBuffers[DB_OPA_LIST_DARK_BG]); }\n    void setOpaList() { setOpaDrawList(mDrawBuffers[DB_OPA_LIST]); }\n    void setXluList() { setXluDrawList(mDrawBuffers[DB_XLU_LIST]); }\n    void setOpaListItem3D() { setOpaDrawList(mDrawBuffers[DB_OPA_LIST_ITEM3D]); }\n    void setXluListItem3D() { setXluDrawList(mDrawBuffers[DB_XLU_LIST_ITEM3D]); }\n    void setXluListBG() { setXluDrawList(mDrawBuffers[DB_XLU_LIST_BG]); }\n    void setOpaListBG() { setOpaDrawList(mDrawBuffers[DB_OPA_LIST_BG]); }\n    void setOpaList3Dlast() { setOpaDrawList(mDrawBuffers[DB_LIST_3D_LAST]); }\n    void setXluList3Dlast() { setXluDrawList(mDrawBuffers[DB_LIST_3D_LAST]); }\n    void setXluList2DScreen() { setXluDrawList(mDrawBuffers[DB_LIST_2D_SCREEN]); }\n    void setXluListP0() { setXluDrawList(mDrawBuffers[DB_LIST_P0]); }\n    void setOpaListP0() { setOpaDrawList(mDrawBuffers[DB_LIST_P0]); }\n    void setXluListMiddle() { setXluDrawList(mDrawBuffers[DB_LIST_MIDDLE]); }\n    void setOpaListMiddle() { setOpaDrawList(mDrawBuffers[DB_LIST_MIDDLE]); }\n    void setOpaListZxlu() { setOpaDrawList(mDrawBuffers[DB_LIST_Z_XLU]); }\n    void setXluListZxlu() { setXluDrawList(mDrawBuffers[DB_LIST_Z_XLU]); }\n    void set3DlineMat(mDoExt_3DlineMat_c *param_1) { \n        #ifndef NON_VIRTUAL_3DLINEMAT\n        m3DLineMatSortPacket[param_1->getMaterialID()].setMat(param_1);\n        #endif\n    }\n\n    void peekZdata() { mPeekZ.peekData(); }\n    void entryZSortListZxlu(J3DPacket* i_packet, cXyz& param_1) {\n        entryZSortXluDrawList(mDrawBuffers[DB_LIST_Z_XLU], i_packet, param_1);\n    }\n\n    void entryZSortXluList(J3DPacket* i_packet, cXyz& param_1) {\n        entryZSortXluDrawList(mDrawBuffers[DB_XLU_LIST], i_packet, param_1);\n    }\n\n    int setSimpleShadow(cXyz* param_0, f32 param_1, f32 param_2, cXyz* param_3, s16 param_4,\n                        f32 param_5, _GXTexObj* param_6) {\n        return mShadowControl.setSimple(param_0, param_1, param_2, param_3, param_4, param_5,\n                                        param_6);\n    }\n\n    int setRealShadow(u32 param_0, s8 param_1, J3DModel* param_2, cXyz* param_3, f32 param_4,\n                      f32 param_5, dKy_tevstr_c* param_6) {\n        return mShadowControl.setReal(param_0, param_1, param_2, param_3, param_4, param_5,\n                                      param_6);\n    }\n\n    void newPeekZdata(s16 param_0, s16 param_1, u32* param_2) {\n        mPeekZ.newData(param_0, param_1, param_2);\n    }\n\n    view_port_class* getViewport() { return mViewport; }\n\n    void drawCopy2D() { draw(mpCopy2DDrawLists, mpCopy2DStart); }\n    void drawOpaListSky() { drawOpaDrawList(mDrawBuffers[DB_OPA_LIST_SKY]); }\n    void drawXluListSky() { drawXluDrawList(mDrawBuffers[DB_XLU_LIST_SKY]); }\n    void drawOpaListBG() { drawOpaDrawList(mDrawBuffers[DB_OPA_LIST_BG]); }\n    void drawOpaListDarkBG() { drawOpaDrawList(mDrawBuffers[DB_OPA_LIST_DARK_BG]); }\n    void drawOpaListMiddle() { drawOpaDrawList(mDrawBuffers[DB_LIST_MIDDLE]); }\n    void drawOpaList() { drawOpaDrawList(mDrawBuffers[DB_OPA_LIST]); }\n    void drawOpaListDark() { drawOpaDrawList(mDrawBuffers[DB_OPA_LIST_DARK]); }\n    void drawOpaListPacket() { drawOpaDrawList(mDrawBuffers[DB_OPA_LIST_PACKET]); }\n    void drawXluListBG() { drawXluDrawList(mDrawBuffers[DB_XLU_LIST_BG]); }\n    void drawXluListDarkBG() { drawXluDrawList(mDrawBuffers[DB_XLU_LIST_DARK_BG]); }\n    void drawXluList() { drawXluDrawList(mDrawBuffers[DB_XLU_LIST]); }\n    void drawXluListDark() { drawXluDrawList(mDrawBuffers[DB_XLU_LIST_DARK]); }\n    void drawXluListInvisible() { drawXluDrawList(mDrawBuffers[DB_XLU_LIST_INVISIBLE]); }\n    void drawOpaListInvisible() { drawOpaDrawList(mDrawBuffers[DB_OPA_LIST_INVISIBLE]); }\n    void drawXluListZxlu() { drawXluDrawList(mDrawBuffers[DB_LIST_Z_XLU]); }\n    void drawXluList2DScreen() { drawXluDrawList(mDrawBuffers[DB_LIST_2D_SCREEN]); }\n    void drawOpaList3Dlast() { drawOpaDrawList(mDrawBuffers[DB_LIST_3D_LAST]); }\n    void drawOpaListFilter() { drawOpaDrawList(mDrawBuffers[DB_LIST_FILTER]); }\n    void drawOpaListP0() { drawOpaDrawList(mDrawBuffers[DB_LIST_P0]); }\n    void draw2DOpa() { draw(mp2DOpaDrawLists, mp2DOpaStart); }\n    void draw2DOpaTop() { draw(mp2DOpaTopDrawLists, mp2DOpaTopStart); }\n    void draw2DXlu() { draw(mp2DXluDrawLists, mp2DXluStart); }\n\n    void imageDrawShadow(Mtx param_0) { mShadowControl.imageDraw(param_0); }\n    void drawShadow(Mtx param_0) { mShadowControl.draw(param_0); }\n\n    static void offWipe() { mWipe = 0; }\n    static f32 getWipeRate() { return mWipeRate; }\n\n    static dDlst_2DT2_c mWipeDlst;\n    static GXColor mWipeColor;\n    static f32 mWipeRate;\n    static f32 mWipeSpeed;\n    static u8 mWipe;\n\nprivate:\n    /* 0x00000 */ J3DDrawBuffer* mDrawBuffers[21];\n    /* 0x00054 */ dDlst_base_c* mpCopy2DDrawLists[4];\n    /* 0x00064 */ dDlst_base_c** mpCopy2DStart;\n    /* 0x00068 */ dDlst_base_c** mpCopy2DEnd;\n    /* 0x0006C */ dDlst_base_c* mp2DOpaTopDrawLists[16];\n    /* 0x000AC */ dDlst_base_c** mp2DOpaTopStart;\n    /* 0x000B0 */ dDlst_base_c** mp2DOpaTopEnd;\n    /* 0x000B4 */ dDlst_base_c* mp2DOpaDrawLists[64];\n    /* 0x001B4 */ dDlst_base_c** mp2DOpaStart;\n    /* 0x001B8 */ dDlst_base_c** mp2DOpaEnd;\n    /* 0x001BC */ dDlst_base_c* mp2DXluDrawLists[32];\n    /* 0x0023C */ dDlst_base_c** mp2DXluStart;\n    /* 0x00240 */ dDlst_base_c** mp2DXluEnd;\n    /* 0x00244 */ dDlst_window_c* mWindow;\n    /* 0x00248 */ view_port_class* mViewport;\n    /* 0x0024C */ view_class* mView;\n    /* 0x00250 */ u8 field_0x250[0xC];\n    /* 0x0025C */ dDlst_shadowControl_c mShadowControl;\n    /* 0x16154 */ mDoExt_3DlineMatSortPacket m3DLineMatSortPacket[3];\n    /* 0x16190 */ dDlst_peekZ_c mPeekZ;\n};  // Size: 0x16394\n\nSTATIC_ASSERT(sizeof(dDlst_list_c) == 0x16394);\n\n#endif /* D_D_DRAWLIST_H */\n/* end \"d/d_drawlist.h\" */\n/* \"include/d/a/d_a_player.h\" line 4 \"f_op/f_op_actor.h\" */\n#ifndef F_OP_ACTOR_H_\n#define F_OP_ACTOR_H_\n\n/* \"include/f_op/f_op_actor.h\" line 3 \"d/kankyo/d_kankyo.h\" */\n#ifndef D_KANKYO_D_KANKYO_H\n#define D_KANKYO_D_KANKYO_H\n\n/* \"include/d/kankyo/d_kankyo.h\" line 3 \"JSystem/J3DGraphBase/J3DStruct.h\" */\n/* end \"JSystem/J3DGraphBase/J3DStruct.h\" */\n/* \"include/d/kankyo/d_kankyo.h\" line 4 \"d/kankyo/d_kankyo_wether.h\" */\n#ifndef D_KANKYO_D_KANKYO_WETHER_H\n#define D_KANKYO_D_KANKYO_WETHER_H\n\n/* \"include/d/kankyo/d_kankyo_wether.h\" line 3 \"JSystem/J3DGraphBase/J3DPacket.h\" */\n/* end \"JSystem/J3DGraphBase/J3DPacket.h\" */\n/* \"include/d/kankyo/d_kankyo_wether.h\" line 4 \"SSystem/SComponent/c_sxyz.h\" */\n/* end \"SSystem/SComponent/c_sxyz.h\" */\n/* \"include/d/kankyo/d_kankyo_wether.h\" line 5 \"SSystem/SComponent/c_xyz.h\" */\n/* end \"SSystem/SComponent/c_xyz.h\" */\n\nclass WIND_INFLUENCE;\n\nvoid dKyw_wether_draw();\nvoid dKyw_wether_delete();\nvoid dKyw_wether_move();\nvoid dKyw_wether_move_draw();\nvoid dKyw_wether_move_draw2();\nvoid dKyw_wether_draw2();\nvoid dKyw_wether_delete2();\nvoid dKyw_wether_init();\nvoid dKyw_wether_init2();\nstatic void dKyw_wind_init();\nstatic void dKyw_pntwind_init();\nf32 dKyw_get_wind_pow();\nstatic void squal_proc();\nvoid dKyw_rain_set(int count);\nvoid dKyw_wind_set();\ncXyz* dKyw_get_wind_vec();\ncXyz dKyw_get_wind_vecpow();\nvoid dKyw_evt_wind_set(s16 angleX, s16 angleY);\nvoid dKyw_custom_windpower(f32 pow);\nvoid dKyw_evt_wind_set_go();\nvoid dKyw_wether_proc();\nvoid dKyw_get_AllWind_vec(cXyz* param_0, cXyz* param_1, f32* param_2);\nvoid dKyw_pntwind_cut(WIND_INFLUENCE* i_pntwind);\ncXyz dKyw_pntwind_get_vecpow(cXyz* param_0);\n\nclass dKankyo_sun_Packet : public J3DPacket {\npublic:\n    virtual void draw();\n    virtual ~dKankyo_sun_Packet();\n\n    /* 0x10 */ cXyz mPos[2];\n    /* 0x28 */ u8 field_0x28;\n    /* 0x29 */ u8 field_0x29;\n    /* 0x2C */ u8* mpResMoon;\n    /* 0x30 */ u8* mpResMoon_A;\n    /* 0x34 */ u8* mpResMoon_A_A00;\n    /* 0x38 */ u8* mpResMoon_A_A01;\n    /* 0x3C */ u8* mpResMoon_A_A02;\n    /* 0x40 */ u8* mpResMoon_A_A03;\n    /* 0x44 */ u32 field_0x44[5];\n    /* 0x58 */ int field_0x58;\n    /* 0x5C */ f32 mVisibility;\n    /* 0x60 */ f32 mSunAlpha;\n    /* 0x64 */ f32 field_0x64;\n    /* 0x68 */ f32 field_0x68;\n    /* 0x6C */ f32 field_0x6c;\n    /* 0x70 */ GXColor mColor;\n    /* 0x74 */ GXColor field_0x74;\n};  // Size: 0x78\n\nclass dKankyo_sunlenz_Packet : public J3DPacket {\npublic:\n    virtual void draw();\n    virtual ~dKankyo_sunlenz_Packet();\n\n    /* 0x10 */ GXColor mColor;\n    /* 0x14 */ u8* mpResBall;\n    /* 0x18 */ u8 field_0x18[4];\n    /* 0x1C */ u8* mpResRing_A;\n    /* 0x20 */ u8* mpResLenz;\n    /* 0x24 */ cXyz mPositions[8];\n    /* 0x84 */ f32 field_0x84;\n    /* 0x88 */ f32 field_0x88;\n    /* 0x8C */ f32 field_0x8c;\n    /* 0x90 */ f32 field_0x90;\n    /* 0x94 */ f32 field_0x94;\n    /* 0x98 */ f32 mDistFalloff;\n    /* 0x9C */ u8 field_0x9c[2];\n    /* 0x9E */ bool mDrawLenzInSky;\n};  // Size: 0xA0\n\nstruct RAIN_EFF {\n    /* 80056CD0 */ ~RAIN_EFF();\n    /* 80056D0C */ RAIN_EFF();\n\n    /* 0x00 */ s8 mStatus;\n    /* 0x04 */ cXyz mPosition;\n    /* 0x10 */ cXyz mBasePos;\n    /* 0x1C */ f32 field_0x1c;\n    /* 0x20 */ f32 field_0x20;\n    /* 0x24 */ f32 field_0x24;\n    /* 0x28 */ f32 mAlpha;\n    /* 0x2C */ f32 field_0x2c;\n    /* 0x30 */ f32 field_0x30;\n    /* 0x34 */ s16 mTimer;\n};  // Size: 0x38\n\nclass dKankyo_rain_Packet : public J3DPacket {\npublic:\n    virtual void draw();\n    virtual ~dKankyo_rain_Packet();\n\n    /* 0x0010 */ u8* mpTex;\n    /* 0x0014 */ u8* mpTex2;\n    /* 0x0018 */ RAIN_EFF mRainEff[250];\n    /* 0x36C8 */ f32 field_0x36c8;\n    /* 0x36CC */ f32 field_0x36cc;\n    /* 0x36D0 */ s16 mRainCount;\n    /* 0x36D2 */ u8 field_0x36D2[6];\n    /* 0x36D8 */ cXyz mCamEyePos;\n    /* 0x36E4 */ cXyz mCamCenterPos;\n    /* 0x36F0 */ cXyz mCenterDelta;\n    /* 0x36FC */ f32 mCenterDeltaMul;\n    /* 0x3700 */ f32 field_0x3700;\n    /* 0x3704 */ f32 mSibukiAlpha;\n    /* 0x3708 */ f32 mOverheadFade;\n    /* 0x370C */ f32 mFwdFade1;\n    /* 0x3710 */ f32 mFwdFade2;\n    /* 0x3714 */ u8 mStatus;\n};  // Size: 0x3718\n\nstruct SNOW_EFF {\n    /* 80056D58 */ ~SNOW_EFF();\n    /* 80056D94 */ SNOW_EFF();\n\n    /* 0x00 */ s8 mStatus;\n    /* 0x04 */ cXyz mPosition;\n    /* 0x10 */ cXyz mBasePos;\n    /* 0x1C */ f32 mPosWaveX;\n    /* 0x20 */ f32 mPosWaveZ;\n    /* 0x24 */ f32 mGravity;\n    /* 0x28 */ f32 mWindSpeed;\n    /* 0x2C */ f32 mScale;\n    /* 0x30 */ f32 field_0x30;\n    /* 0x34 */ s16 mTimer;\n};  // Size: 0x38\n\nclass dKankyo_snow_Packet : public J3DPacket {\npublic:\n    virtual void draw();\n    virtual ~dKankyo_snow_Packet();\n\n    /* 0x0010 */ u8* mpTex;\n    /* 0x0014 */ SNOW_EFF mSnowEff[500];\n    /* 0x6D74 */ cXyz field_0x6d74;\n    /* 0x6D80 */ f32 field_0x6d80;\n    /* 0x6D84 */ f32 field_0x6d84;\n    /* 0x6D88 */ s16 field_0x6d88;\n    /* 0x6D8A */ u16 field_0x6d8a;\n    /* 0x6D8C */ u32 field_0x6d8c;\n    /* 0x6D90 */ u8 field_0x6d90;\n    /* 0x6D91 */ u8 field_0x6d91;\n    /* 0x6D92 */ u8 field_0x6d92;\n    /* 0x6D93 */ u8 field_0x6d93;\n};\n\nstruct STAR_EFF {\n    /* 80056DC8 */ ~STAR_EFF();\n    /* 80056E04 */ STAR_EFF();\n\n    /* 0x00 */ u8 field_0x0[4];\n    /* 0x04 */ cXyz field_0x04;\n    /* 0x10 */ cXyz field_0x10;\n    /* 0x1C */ u8 field_0x1c[12];\n    /* 0x28 */ f32 field_0x28;\n    /* 0x2C */ u8 field_0x2c[8];\n};  // Size: 0x34\n\nclass dKankyo_star_Packet : public J3DPacket {\npublic:\n    virtual void draw();\n    virtual ~dKankyo_star_Packet();\n\n    /* 0x10 */ u8* field_0x10;\n    /* 0x14 */ STAR_EFF mEffect[1];\n    /* 0x48 */ s16 mEffectNum;\n};\n\nstruct HOUSI_EFF {\n    /* 80056EA8 */ ~HOUSI_EFF();\n    /* 80056EE4 */ HOUSI_EFF();\n\n    /* 0x00 */ s8 mStatus;\n    /* 0x04 */ cXyz mPosition;\n    /* 0x10 */ cXyz mBasePos;\n    /* 0x1C */ cXyz mSpeed;\n    /* 0x28 */ cXyz mScale;\n    /* 0x34 */ f32 field_0x34;\n    /* 0x38 */ f32 field_0x38;\n    /* 0x3C */ u16 field_0x3c;\n    /* 0x40 */ f32 mAlpha;\n    /* 0x44 */ f32 field_0x44;\n    /* 0x48 */ f32 field_0x48;\n    /* 0x4C */ u16 field_0x4c;\n};  // Size: 0x50\n\nclass dKankyo_housi_Packet : public J3DPacket {\npublic:\n    virtual void draw();\n    virtual ~dKankyo_housi_Packet();\n\n    /* 0x0010 */ cXyz field_0x10;\n    /* 0x001C */ u8* mpResTex;\n    /* 0x0020 */ HOUSI_EFF mHousiEff[300];\n    /* 0x5DE0 */ u8 field_0x5de0[8];\n    /* 0x5DE8 */ f32 field_0x5de8;\n    /* 0x5DEC */ s16 field_0x5dec;\n};  // Size: 0x5DF0\n\nstruct CLOUD_EFF {\n    /* 80056E38 */ ~CLOUD_EFF();\n    /* 80056E74 */ CLOUD_EFF();\n\n    /* 0x00 */ u8 mStatus;\n    /* 0x04 */ cXyz mPosition;\n    /* 0x10 */ cXyz mBasePos;\n    /* 0x1C */ cXyz mPntWindSpeed;\n    /* 0x28 */ u8 field_0x28[0x10];\n};  // Size: 0x38\n\nclass dKankyo_cloud_Packet : public J3DPacket {\npublic:\n    virtual void draw();\n    virtual ~dKankyo_cloud_Packet();\n\n    /* 0x10 */ u8* mpResTex;\n    /* 0x14 */ int mCount;\n    /* 0x18 */ CLOUD_EFF mCloudEff[50];\n};  // Size: 0xB08\n\nstruct VRKUMO_EFF {\n    /* 80056F18 */ ~VRKUMO_EFF();\n    /* 80056F54 */ VRKUMO_EFF();\n\n    /* 0x00 */ u8 mStatus;\n    /* 0x04 */ cXyz mPosition;\n    /* 0x10 */ cXyz mBasePos;\n    /* 0x1C */ f32 mHeight;\n    /* 0x20 */ f32 mAlpha;\n    /* 0x24 */ f32 mDistFalloff;\n    /* 0x28 */ f32 mSpeed;\n};  // Size: 0x2C\n\nclass dKankyo_vrkumo_Packet : public J3DPacket {\npublic:\n    virtual void draw();\n    virtual ~dKankyo_vrkumo_Packet();\n\n    /* 0x0010 */ GXColor mColor;\n    /* 0x0014 */ u8* mpResCloudtx_01;\n    /* 0x0018 */ u8* mpResCloudtx_02;\n    /* 0x001C */ u8* mpResCloudtx_03;\n    /* 0x0020 */ VRKUMO_EFF mVrkumoEff[100];\n    /* 0x1150 */ f32 field_0x1150;\n    /* 0x1154 */ f32 field_0x1154;\n};  // Size: 0x1158\n\n// might be fake\nclass dKankyo_shstar_Packet : public J3DPacket {};\n\nstruct EF_ODOUR_EFF {\n    /* 80056F8C */ ~EF_ODOUR_EFF();\n    /* 80056FC8 */ EF_ODOUR_EFF();\n\n    /* 0x00 */ u8 mStatus;\n    /* 0x04 */ cXyz mPosition;\n    /* 0x10 */ cXyz mBasePos;\n    /* 0x1C */ u8 field_0x1c[0x24 - 0x1C];\n    /* 0x24 */ f32 field_0x24;\n    /* 0x28 */ f32 field_0x28;\n    /* 0x2C */ f32 field_0x2c;\n};  // Size: 0x30\n\nclass dKankyo_odour_Packet : public J3DPacket {\npublic:\n    virtual void draw();\n    virtual ~dKankyo_odour_Packet();\n\n    /* 0x00010 */ u8* mpResTex;\n    /* 0x00014 */ EF_ODOUR_EFF mOdourEff[2000];\n    /* 0x17714 */ u8 field_0x17714[0x14];\n};  // Size: 0x17728\n\nstruct EF_MUD_EFF {\n    /* 80056FFC */ ~EF_MUD_EFF();\n    /* 80057038 */ EF_MUD_EFF();\n\n    /* 0x00 */ u8 mStatus;\n    /* 0x04 */ cXyz mPosition;\n    /* 0x10 */ cXyz mBasePos;\n    /* 0x1C */ cXyz field_0x1c;\n    /* 0x28 */ u8 field_0x28[0x20];\n};  // Size: 0x48\n\nclass dKankyo_mud_Packet : public J3DPacket {\npublic:\n    virtual void draw();\n    virtual ~dKankyo_mud_Packet();\n\n    /* 0x0010 */ int mEffectNum;\n    /* 0x0014 */ u8* mpMoyaRes;\n    /* 0x0018 */ EF_MUD_EFF mEffect[100];\n    /* 0x1C38 */ u8 field_0x1c38[4];\n    /* 0x1C3C */ f32 field_0x1c3c;\n};\n\nstruct EF_EVIL_EFF {\n    /* 8005706C */ ~EF_EVIL_EFF();\n    /* 800570A8 */ EF_EVIL_EFF();\n\n    /* 0x00 */ u8 mStatus;\n    /* 0x04 */ cXyz mPosition;\n    /* 0x10 */ cXyz mBasePos;\n    /* 0x1C */ csXyz field_0x1c;\n    /* 0x22 */ u8 field_0x22[0x22];\n};  // Size: 0x44\n\nclass dKankyo_evil_Packet : public J3DPacket {\npublic:\n    virtual void draw();\n    virtual ~dKankyo_evil_Packet();\n\n    /* 0x00010 */ int mEffectNum;\n    /* 0x00014 */ u8* mpMoyaRes;\n    /* 0x00018 */ u8* mpKumoLightRes;\n    /* 0x0001C */ EF_EVIL_EFF mEffect[2000];\n    /* 0x2135C */ u8 field_0x2135c[8];\n};\n\n#endif /* D_KANKYO_D_KANKYO_WETHER_H */\n/* end \"d/kankyo/d_kankyo_wether.h\" */\n/* \"include/d/kankyo/d_kankyo.h\" line 5 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n/* \"include/d/kankyo/d_kankyo.h\" line 6 \"global.h\" */\n/* end \"global.h\" */\n/* \"include/d/kankyo/d_kankyo.h\" line 7 \"m_Do/m_Do_ext.h\" */\n/* end \"m_Do/m_Do_ext.h\" */\n\nclass JPABaseEmitter;\nclass cBgS_PolyInfo;\nclass color_RGB_class;\n\nvoid dKankyo_DayProc();\nvoid dKy_set_nexttime(f32);\nvoid dKy_itudemo_se();\nBOOL dKy_darkworld_spot_check(char const* stageName, int roomNo);\nvoid dKy_darkworld_Area_set(char const* stageName, int roomNo);\nvoid dKy_FiveSenses_fullthrottle_dark();\ns32 dKy_daynight_check();\nvoid dKy_clear_game_init();\nvoid dKy_setLight_init();\nu8 dKy_pol_sound_get(cBgS_PolyInfo const* param_0);\nvoid dKy_depth_dist_set(void* param_0);\nvoid dKy_instant_rainchg();\nvoid dKy_instant_timechg(f32);\nstatic void dKy_set_vrboxsoracol_ratio(f32 ratio);\nstatic void dKy_set_vrboxkumocol_ratio(f32 ratio);\nvoid dKy_actor_addcol_set(s16 param_0, s16 param_1, s16 param_2, f32 param_3);\nvoid dKy_fog_startendz_set(f32 param_0, f32 param_1, f32 param_2);\nstatic void dKy_vrbox_addcol_set(s16 param_0, s16 param_1, s16 param_2, f32 param_3);\nvoid dKy_GxFog_set();\nstatic void GxFog_set();\nstatic void GxXFog_set();\nu8 dKy_pol_argument_get(cBgS_PolyInfo const* i_poly);\nvoid dKy_Sound_set(cXyz i_pos, int param_1, unsigned int i_actorID, int param_3);\nvoid dKy_bg_MAxx_proc(void* param_0);\nvoid dKy_change_colpat(u8 colpat);\nvoid dKy_BossLight_set(cXyz* param_0, _GXColor* param_1, f32 param_2, u8 param_3);\nvoid dKy_custom_colset(u8 prevGather, u8 curGather, f32 blend);\nvoid dKy_setLight();\ncXyz dKy_plight_near_pos();\nvoid dKy_BossSpotLight_set(cXyz* param_0, f32 param_1, f32 param_2, f32 param_3, _GXColor* param_4,\n                           f32 param_5, u8 param_6, u8 param_7);\nstatic void dKy_calc_color_set(_GXColorS10* param_0, color_RGB_class* param_1,\n                               color_RGB_class* param_2, color_RGB_class* param_3,\n                               color_RGB_class* param_4, f32 param_5, f32 param_6,\n                               _GXColorS10 param_7, f32 param_8);\nstatic void dKy_twilight_camelight_set();\nu8 dKy_shadow_mode_check(u8 mode);\nvoid dKy_shadow_mode_set(u8 mode);\nvoid dKy_shadow_mode_reset(u8 mode);\nvoid dKy_Itemgetcol_chg_on();\n\nstruct LIGHT_INFLUENCE {\n    /* 0x00 */ cXyz mPosition;\n    /* 0x0C */ GXColorS10 mColor;\n    /* 0x14 */ f32 mPow;\n    /* 0x18 */ f32 mFluctuation;\n    /* 0x1C */ int mIndex;\n};\n\nstruct WIND_INFLUENCE {\n    /* 0x00 */ cXyz position;\n    /* 0x0C */ cXyz mDirection;\n    /* 0x18 */ f32 mRadius;\n    /* 0x1C */ f32 mStrength;\n    /* 0x20 */ f32 field_0x20;\n    /* 0x24 */ int field_0x24;\n    /* 0x28 */ u8 mConstant;\n    /* 0x29 */ u8 field_0x29;\n};\n\nstruct WIND_INF_ENTITY {\n    /* 0x00 */ u8 mInUse;\n    /* 0x04 */ f32 mMinRadius;\n    /* 0x08 */ f32 mSpeed;\n    /* 0x0C */ f32 mStrengthMaxVel;\n    /* 0x10 */ WIND_INFLUENCE mInfluence;\n};  // Size: 0x3C\n\nstruct EFLIGHT_PROC {\n    /* 0x00 */ u8 mState;\n    /* 0x01 */ u8 mFrame;\n    /* 0x04 */ int mLightType;\n    /* 0x08 */ LIGHT_INFLUENCE field_0x8;\n};\n\nstruct SND_INFLUENCE {\n    /* 0x00 */ cXyz field_0x0;\n    /* 0x0C */ int field_0xc;\n    /* 0x10 */ int field_0x10;\n    /* 0x14 */ u32 field_0x14;\n};\n\nstruct DALKMIST_INFLUENCE {\n    /* 0x00 */ cXyz mPos;\n    /* 0x0C */ f32 field_0xc;\n    /* 0x10 */ s8 mIndex;\n};\n\nstruct DUNGEON_LIGHT {\n    /* 0x00 */ cXyz mPosition;\n    /* 0x0C */ GXColor mColor;\n    /* 0x10 */ f32 mRefDistance;\n    /* 0x14 */ f32 field_0x14;\n    /* 0x18 */ f32 mCutoffAngle;\n    /* 0x1C */ f32 mAngleX;\n    /* 0x20 */ f32 mAngleY;\n    /* 0x24 */ u8 mAngleAttenuation;\n    /* 0x25 */ u8 mDistAttenuation;\n    /* 0x26 */ u8 field_0x26[6];\n    /* 0x2C */ LIGHT_INFLUENCE mInfluence;\n};  // Size: 0x4C\n\nstruct BOSS_LIGHT {\n    /* 0x00 */ cXyz mPos;\n    /* 0x0C */ GXColor mColor;\n    /* 0x10 */ f32 mRefDistance;\n    /* 0x14 */ f32 field_0x14;\n    /* 0x18 */ f32 mCutoffAngle;\n    /* 0x1C */ f32 mAngleX;\n    /* 0x20 */ f32 mAngleY;\n    /* 0x24 */ u8 mAngleAttenuation;\n    /* 0x25 */ u8 mDistAttenuation;\n    /* 0x26 */ u8 field_0x26;\n};  // Size: 0x28\n\nstruct GB_WIND_INFLUENCE {\n    /* 0x00 */ cXyz vec;\n    /* 0x0C */ cXyz* vec_override;\n    /* 0x10 */ f32 pow;\n};\n\nstruct EF_THUNDER {\n    /* 0x00 */ u8 mStatus;\n    /* 0x01 */ u8 mStateTimer;\n    /* 0x02 */ u8 field_0x2;\n    /* 0x04 */ int mMode;\n    /* 0x08 */ f32 field_0x8;\n    /* 0x0C */ f32 field_0xc;\n    /* 0x10 */ f32 field_0x10;\n    /* 0x14 */ f32 field_0x14;\n    /* 0x18 */ f32 field_0x18;\n    /* 0x1C */ f32 field_0x1c;\n    /* 0x20 */ u8 field_0x20[4];\n    /* 0x24 */ LIGHT_INFLUENCE mLightInfluence;\n};\n\nstruct GB_MAPLE_COL_CHANGE {\n    /* 0x00 */ J3DLightObj field_0x0;\n};  // Size: 0x74\n\n// most of these members are guesses, fix later\nstruct LightStatus {\n    /* 0x00 */ Vec field_0x0;\n    /* 0x0C */ Vec field_0xc;\n    /* 0x18 */ GXColor field_0x18;\n    /* 0x1C */ Vec field_0x1c;\n    /* 0x28 */ Vec field_0x28;\n    /* 0x34 */ f32 field_0x34;\n    /* 0x38 */ Vec mLightDir;\n    /* 0x44 */ f32 mCutoff;\n    /* 0x48 */ GXSpotFn mSpotFn;\n    /* 0x4C */ f32 mRefDist;\n    /* 0x50 */ f32 mRefBrightness;\n    /* 0x54 */ GXDistAttnFn mDistFn;\n    /* 0x58 */ u32 field_0x58[2][6];  //?\n    /* 0x88 */ f32 field_0x88;\n    /* 0x8C */ f32 field_0x8c;\n    /* 0x90 */ f32 field_0x90;\n    /* 0x94 */ f32 field_0x94;\n    /* 0x98 */ u32 field_0x98[2][8];  //?\n    /* 0xD8 */ f32 field_0xd8;\n    /* 0xDC */ f32 field_0xdc;\n    /* 0xE0 */ f32 field_0xe0;\n    /* 0xE4 */ f32 field_0xe4;\n};  // Size: 0xE8\n\nclass dKy_tevstr_c {\npublic:\n    // Supposedly exists but didn't work. Might be too big to inline.\n    // See dPa_modelEcallBack::model_c::set.\n    //inline dKy_tevstr_c& operator=(const dKy_tevstr_c& b);   \n    \n    /* 0x000 */ J3DLightObj mLightObj;\n    /* 0x074 */ J3DLightObj mLights[6];\n    /* 0x32C */ cXyz field_0x32c;\n    /* 0x338 */ cXyz mLightPosWorld;\n    /* 0x344 */ f32 field_0x344;\n    /* 0x348 */ GXColorS10 mColorC0;\n    /* 0x350 */ GXColorS10 mColorK0;\n    /* 0x358 */ GXColorS10 mFogColor;\n    /* 0x360 */ u8 field_0x360;\n    /* 0x361 */ u8 field_0x361;\n    /* 0x362 */ u8 field_0x362;\n    /* 0x363 */ u8 field_0x363;\n    /* 0x364 */ u8 field_0x364;\n    /* 0x365 */ u8 field_0x365;\n    /* 0x366 */ u8 field_0x366;\n    /* 0x367 */ u8 field_0x367;\n    /* 0x368 */ f32 mFogStartZ;\n    /* 0x36C */ f32 mFogEndZ;\n    /* 0x370 */ f32 mColpatBlend;\n    /* 0x374 */ f32 field_0x374;\n    /* 0x378 */ u16 field_0x378;\n    /* 0x37A */ u8 field_0x37a;\n    /* 0x37B */ u8 mInitTimer;\n    /* 0x37C */ u8 mEnvrIdxCurr;\n    /* 0x37D */ u8 mEnvrIdxPrev;\n    /* 0x37E */ u8 mColpatCurr;\n    /* 0x37F */ u8 mColpatPrev;\n    /* 0x380 */ s8 mRoomNo;\n    /* 0x381 */ u8 mEnvrIdxOverride;\n    /* 0x382 */ u8 mLightMode;\n    /* 0x383 */ u8 mInitType;\n    /* 0x384 */ u8 field_0x384;\n    /* 0x385 */ u8 field_0x385;\n};  // Size = 0x388\n\nSTATIC_ASSERT(sizeof(dKy_tevstr_c) == 0x388);\n\nclass fopAc_ac_c;\nclass dKyd_lightSchejule;\nclass stage_palette_info_class;\nclass stage_pselect_info_class;\nclass stage_envr_info_class;\nclass stage_vrbox_info_class;\nclass stage_plight_info_class;\nclass kytag08_class;\n\nstruct dKy_pol_arg_struct {\n    u8 data[8];\n};\n\nstruct dKy_color_data_struct {\n    u8 data[8];\n};\n\nstruct dKy_pol_efftbl_struct {\n    u8 data[8];\n};\n\nstruct dKy_pol_effcol_struct {\n    u8 data[8];\n};\n\nstruct dKy_pol_sound_struct {\n    u8 data[8];\n};\n\nclass dScnKy_env_light_c {\npublic:\n    /* 8019F2E8 */ dScnKy_env_light_c();\n    /* 8019F4FC */ void setDaytime();\n    /* 8019F788 */ void setSunpos();\n    /* 8019FA08 */ f32 getDaytime();\n    /* 8019FBCC */ f32 getDarkDaytime();\n    /* 8019FBD4 */ void setLight_palno_get(u8*, u8*, u8*, u8*, u8*, u8*, u8*, u8*, f32*, int*, int*,\n                                           f32*, u8*);\n    /* 801A040C */ void setLight();\n    /* 801A133C */ void setLight_bg(dKy_tevstr_c*, _GXColorS10*, _GXColorS10*, f32*, f32*);\n    /* 801A16C0 */ void setLight_actor(dKy_tevstr_c*, _GXColorS10*, f32*, f32*);\n    /* 801A1D64 */ void settingTevStruct_colget_actor(cXyz*, dKy_tevstr_c*, _GXColorS10*,\n                                                      _GXColorS10*, f32*, f32*);\n    /* 801A1F58 */ void settingTevStruct_colget_player(dKy_tevstr_c*);\n    /* 801A2128 */ void settingTevStruct_plightcol_plus(cXyz*, dKy_tevstr_c*, _GXColorS10,\n                                                        _GXColorS10, u8);\n    /* 801A37C4 */ void settingTevStruct(int, cXyz*, dKy_tevstr_c*);\n    /* 801A441C */ void setLightTevColorType(J3DModelData*, dKy_tevstr_c*);\n    /* 801A4DA0 */ void setLightTevColorType_MAJI(J3DModelData*, dKy_tevstr_c*);\n    /* 801A4E90 */ void CalcTevColor();\n    /* 801A4F24 */ void Sndpos();\n    /* 801A4F64 */ void Eflight_flush_proc();\n    /* 801A516C */ void SetBaseLight();\n    /* 801A5288 */ void exeKankyo();\n    /* 801A56DC */ void drawKankyo();\n\n    /* 801ADBBC */ virtual ~dScnKy_env_light_c();\n\n    void setLightTevColorType_MAJI(J3DModel* i_model, dKy_tevstr_c* tevstr) {\n        setLightTevColorType_MAJI(i_model->getModelData(), tevstr);\n    }\n\npublic:\n    /* 0x0000 */  // vtable\n    /* 0x0004 */ stage_palette_info_class* mpDmPalet;\n    /* 0x0008 */ stage_pselect_info_class* mpDmPselect;\n    /* 0x000C */ stage_envr_info_class* mpDmEnvr;\n    /* 0x0010 */ stage_vrbox_info_class* mpDmVrbox;\n    /* 0x0014 */ dKyd_lightSchejule* mpSchedule;\n    /* 0x0018 */ LIGHT_INFLUENCE mBaseLightInfluence;\n    /* 0x0038 */ LIGHT_INFLUENCE mLightInfluence[30];\n    /* 0x03F8 */ LIGHT_INFLUENCE* mPointLight[100];\n    /* 0x0588 */ LIGHT_INFLUENCE* mEfPLight[5];\n    /* 0x059C */ u8 field_0x59c[400];\n    /* 0x072C */ LIGHT_INFLUENCE* field_0x72c[5];\n    /* 0x0740 */ LIGHT_INFLUENCE field_0x740;\n    /* 0x0760 */ u8 field_0x760[4];\n    /* 0x0764 */ LIGHT_INFLUENCE mBGpartsActiveLight[2];\n    /* 0x07A4 */ EFLIGHT_PROC mSwordLight;\n    /* 0x07CC */ stage_plight_info_class* stagPlightInfo;  // might be part of EFLIGHT_PROC\n    /* 0x07D0 */ WIND_INFLUENCE* mPntWind[30];\n    /* 0x0848 */ WIND_INF_ENTITY mWindInfluenceEntity[5];\n    /* 0x0974 */ SND_INFLUENCE mSound;\n    /* 0x098C */ u8 field_0x98c;  // often set to room no\n    /* 0x0990 */ DALKMIST_INFLUENCE* mDalkmistInf[10];\n    /* 0x09B8 */ DUNGEON_LIGHT mDungeonLights[8];\n    /* 0x0C18 */ BOSS_LIGHT field_0x0c18[8];\n    /* 0x0D58 */ BOSS_LIGHT field_0x0d58[6];\n    /* 0x0E48 */ GB_WIND_INFLUENCE mWind;\n    /* 0x0E5C */ f32 custom_windpower;\n    /* 0x0E60 */ f32 field_0xe60;\n    /* 0x0E64 */ u16 field_0xe64;\n    /* 0x0E66 */ u16 field_0xe66;\n    /* 0x0E68 */ s16 mEvtWindAngleX;\n    /* 0x0E6A */ s16 mEvtWindAngleY;\n    /* 0x0E6C */ u8 field_0xe6c;\n    /* 0x0E6D */ u8 mEvtWindSet;\n    /* 0x0E6E */ u8 mTeachWindExist;\n    /* 0x0E6F */ u8 field_0xe6f;\n    /* 0x0E70 */ bool mSunInitialized;\n    /* 0x0E74 */ dKankyo_sun_Packet* mpSunPacket;\n    /* 0x0E78 */ dKankyo_sunlenz_Packet* mpSunLenzPacket;\n    /* 0x0E7C */ bool mRainInitialized;\n    /* 0x0E80 */ int mRainCount;\n    /* 0x0E84 */ dKankyo_rain_Packet* mpRainPacket;\n    /* 0x0E88 */ bool mSnowInitialized;\n    /* 0x0E8C */ int mSnowCount;\n    /* 0x0E90 */ u8 field_0xe90;\n    /* 0x0E91 */ u8 field_0xe91;\n    /* 0x0E92 */ bool field_0xe92;\n    /* 0x0E94 */ dKankyo_snow_Packet* mpSnowPacket;\n    /* 0x0E98 */ bool mStarInitialized;\n    /* 0x0E9C */ int mStarCount;\n    /* 0x0EA0 */ f32 mStarDensity;\n    /* 0x0EA4 */ dKankyo_star_Packet* mpStarPacket;\n    /* 0x0EA8 */ bool mHousiInitialized;\n    /* 0x0EA9 */ u8 field_0xea9;\n    /* 0x0EAC */ int mHousiCount;\n    /* 0x0EB0 */ dKankyo_housi_Packet* mpHousiPacket;\n    /* 0x0EB4 */ u8 mCloudInitialized;\n    /* 0x0EB5 */ u8 mMoyaMode;\n    /* 0x0EB8 */ int mMoyaCount;\n    /* 0x0EBC */ f32 field_0xebc;\n    /* 0x0EC0 */ dKankyo_cloud_Packet* mpCloudPacket;\n    /* 0x0EC4 */ u8 mVrkumoStatus;\n    /* 0x0EC8 */ int mVrkumoCount;\n    /* 0x0ECC */ f32 mVrkumoStrength;\n    /* 0x0ED0 */ dKankyo_vrkumo_Packet* mpVrkumoPacket;\n    /* 0x0ED4 */ EF_THUNDER mThunderEff;\n    /* 0x0F18 */ u8 field_0xf18[4];\n    /* 0x0F1C */ dKankyo_shstar_Packet* mpShstarPacket;\n    /* 0x0F20 */ u8 mOdourPacketStatus;\n    /* 0x0F21 */ u8 field_0xf21;\n    /* 0x0F24 */ int field_0xf24;\n    /* 0x0F28 */ dKankyo_odour_Packet* mpOdourPacket;\n    /* 0x0F2C */ u8 field_0xf2c;\n    /* 0x0F30 */ J3DModel* mpUndwaterEfModel;\n    /* 0x0F34 */ f32 field_0xf34;\n    /* 0x0F38 */ JKRSolidHeap* mpUndwaterEfHeap;\n    /* 0x0F3C */ u8 field_0xf3c;\n    /* 0x0F3D */ u8 field_0xf3d;\n    /* 0x0F40 */ f32 field_0xf40;\n    /* 0x0F44 */ JPABaseEmitter* field_0xf44;\n    /* 0x0F48 */ JPABaseEmitter* field_0xf48;\n    /* 0x0F4C */ JPABaseEmitter* field_0xf4c;\n    /* 0x0F50 */ GB_MAPLE_COL_CHANGE field_0xf50[2];\n    /* 0x1038 */ u8 field_0x1038;\n    /* 0x103C */ int field_0x103c;\n    /* 0x1040 */ u8 field_0x1040[4];\n    /* 0x1044 */ u8 mMudInitialized;\n    /* 0x1048 */ int field_0x1048;\n    /* 0x104C */ dKankyo_mud_Packet* mpMudPacket;\n    /* 0x1050 */ u8 mEvilInitialized;\n    /* 0x1051 */ u8 field_0x1051;\n    /* 0x1054 */ int field_0x1054;\n    /* 0x1058 */ dKankyo_evil_Packet* mpEvilPacket;\n    /* 0x105C */ mDoExt_btkAnm* mpUndwaterBtk;\n    /* 0x1060 */ kytag08_class* field_0x1060;\n    /* 0x1064 */ Vec field_0x1064;\n    /* 0x1070 */ cXyz mSunPos2;\n    /* 0x107C */ cXyz mPLightNearPos;\n    /* 0x1088 */ cXyz mSunPos;\n    /* 0x1094 */ cXyz mMoonPos;\n    /* 0x10A0 */ cXyz field_0x10a0;\n    /* 0x10AC */ GXFogAdjTable mXFogTbl;\n    /* 0x10C0 */ GXColorS10 mVrSkyCol;\n    /* 0x10C8 */ GXColorS10 mVrkumoCol;\n    /* 0x10D0 */ GXColorS10 mVrShitaGumoCol;\n    /* 0x10D8 */ GXColorS10 mVrShitaUneiCol;\n    /* 0x10E0 */ GXColorS10 mVrKasumiCol;\n    /* 0x10E8 */ GXColorS10 mVrOkuKasumiCol;\n    /* 0x10F0 */ GXColorS10 field_0x10f0;\n    /* 0x10F8 */ GXColorS10 field_0x10f8;\n    /* 0x1100 */ GXColorS10 mActorAmbience;\n    /* 0x1108 */ GXColorS10 mTerrainAmbienceBG[4];\n    /* 0x1128 */ GXColorS10 field_0x1128[6];\n    /* 0x1158 */ GXColorS10 mFogColor;\n    /* 0x1160 */ GXColorS10 mActorAddColAmb;\n    /* 0x1168 */ u8 field_0x1168[8];\n    /* 0x1170 */ GXColorS10 mBgAddColAmb;\n    /* 0x1178 */ u8 field_0x1178[8];\n    /* 0x1180 */ GXColorS10 mBg1AddColAmb;\n    /* 0x1188 */ u8 field_0x1188[8];\n    /* 0x1190 */ GXColorS10 mBg2AddColAmb;\n    /* 0x1198 */ u8 field_0x1198[8];\n    /* 0x11A0 */ GXColorS10 mBg3AddColAmb;\n    /* 0x11A8 */ u8 field_0x11a8[8];\n    /* 0x11B0 */ GXColorS10 mFogAddCol;\n    /* 0x11B8 */ GXColorS10 mVrboxAddcolSky0;\n    /* 0x11C0 */ GXColorS10 mVrboxAddcolKasumi;\n    /* 0x11C8 */ f32 field_0x11c8;\n    /* 0x11CC */ f32 field_0x11cc;\n    /* 0x11D0 */ f32 field_0x11d0;\n    /* 0x11D4 */ f32 mDiceWeatherChangeTime;\n    /* 0x11D8 */ f32 mDiceWeatherTime;\n    /* 0x11DC */ f32 mColPatBlend;\n    /* 0x11E0 */ f32 mColPatBlendGather;\n    /* 0x11E4 */ f32 mFogNear;\n    /* 0x11E8 */ f32 mFogFar;\n    /* 0x11EC */ f32 field_0x11ec;\n    /* 0x11F0 */ f32 field_0x11f0;\n    /* 0x11F4 */ f32 field_0x11f4;\n    /* 0x11F8 */ f32 mColAllcolRatio;\n    /* 0x11FC */ f32 mColActColRatio;\n    /* 0x1200 */ f32 mColBgColRatio;\n    /* 0x1204 */ f32 mColFogColRatio;\n    /* 0x1208 */ f32 mColVrboxSoraColRatio;\n    /* 0x120C */ f32 mColVrboxKumocolRatio;\n    /* 0x1210 */ f32 field_0x1210;\n    /* 0x1214 */ f32 mAllcolRatio;\n    /* 0x1218 */ f32 mActcolRatio;\n    /* 0x121C */ f32 mBgcolRatio;\n    /* 0x1220 */ f32 mFogcolRatio;\n    /* 0x1224 */ f32 mVrboxSoracolRatio;\n    /* 0x1228 */ f32 mVrboxKumocolRatio;\n    /* 0x122C */ f32 field_0x122c;\n    /* 0x1230 */ f32 field_0x1230;\n    /* 0x1234 */ f32 field_0x1234;\n    /* 0x1238 */ f32 field_0x1238;\n    /* 0x123C */ f32 field_0x123c;\n    /* 0x1240 */ f32 field_0x1240;\n    /* 0x1244 */ f32 mDaytime;\n    /* 0x1248 */ f32 mNexttime;\n    /* 0x124C */ f32 mTimeSpeed;\n    /* 0x1250 */ f32 mDarkDaytime;\n    /* 0x1254 */ f32 field_0x1254;\n    /* 0x1258 */ f32 field_0x1258;\n    /* 0x125C */ f32 mPaletteTerrainLightEffect;\n    /* 0x1260 */ f32 mGrassLightEffectRate;\n    /* 0x1264 */ f32 field_0x1264;\n    /* 0x1268 */ f32 field_0x1268;\n    /* 0x126C */ f32 field_0x126c;\n    /* 0x1270 */ f32 mDemoAttentionPoint;\n    /* 0x1274 */ f32 mTime;  // ?\n    /* 0x1278 */ f32 field_0x1278;\n    /* 0x127C */ f32 field_0x127c;\n    /* 0x1280 */ int field_0x1280;\n    /* 0x1284 */ u8 field_0x1284[4];\n    /* 0x1288 */ u32 mMoyaSE;\n    /* 0x128C */ u8 field_0x128c[12];\n    /* 0x1298 */ int mDiceWeatherCounter;\n    /* 0x129C */ int mRainCountOrig;\n    /* 0x12A0 */ int field_0x12a0;\n    /* 0x12A4 */ int mPlayerPLightIdx;\n    /* 0x12A8 */ int mPlayerEfLightIdx;\n    /* 0x12AC */ u8 field_0x12ac[4];\n    /* 0x12B0 */ int field_0x12b0;\n    /* 0x12B4 */ int mSchbitTimer;\n    /* 0x12B8 */ u8 field_0x12b8[4];\n    /* 0x12BC */ u16 mFogAdjCenter;\n    /* 0x12BE */ u16 mDate;\n    /* 0x12C0 */ s16 mActorLightEffect;\n    /* 0x12C2 */ u8 mColPatPrev;\n    /* 0x12C3 */ u8 mColPatCurr;\n    /* 0x12C4 */ u8 mColpatPrevGather;\n    /* 0x12C5 */ u8 mColpatCurrGather;\n    /* 0x12C6 */ u8 mEnvrIdxPrev;\n    /* 0x12C7 */ u8 mEnvrIdxCurr;\n    /* 0x12C8 */ u8 mColpatWeather;\n    /* 0x12C9 */ u8 mDiceWeatherMode;\n    /* 0x12CA */ u8 mDiceWeatherState;\n    /* 0x12CB */ u8 mDiceWeatherCurrPattern;\n    /* 0x12CC */ u8 field_0x12cc;\n    /* 0x12CD */ u8 mColPatMode;\n    /* 0x12CE */ u8 mColPatModeGather;\n    /* 0x12CF */ u8 mFogAdjEnable;\n    /* 0x12D0 */ u8 mFogAdjTableType;\n    /* 0x12D1 */ u8 mItemGetCol_chg;\n    /* 0x12D2 */ u8 mInitAnmTimer;\n    /* 0x12D3 */ u8 mSchBit;\n    /* 0x12D4 */ bool mVrboxInvisible;\n    /* 0x12D5 */ u8 mContrastFlag;\n    /* 0x12D6 */ u8 field_0x12d6;\n    /* 0x12D7 */ u8 mShadowMode;\n    /* 0x12D8 */ u8 mCameraInWater;\n    /* 0x12DC */ dKy_pol_efftbl_struct* mResPolEfftbl;\n    /* 0x12E0 */ dKy_pol_effcol_struct* mResPolEffcol;\n    /* 0x12E4 */ dKy_pol_efftbl_struct* mResPolEfftbl2;\n    /* 0x12E8 */ dKy_pol_effcol_struct* mResPolEffcol2;\n    /* 0x12EC */ dKy_pol_sound_struct* mResPolSound;\n    /* 0x12F0 */ dKy_pol_arg_struct* mResPolArg;\n    /* 0x12F4 */ dKy_color_data_struct* mResColorDataTbl;\n    /* 0x12F8 */ s8 mFogDensity;\n    /* 0x12F9 */ u8 field_0x12f9;\n    /* 0x12FA */ u8 mIsBlure;\n    /* 0x12FB */ u8 field_0x12fb;\n    /* 0x12FC */ s8 field_0x12fc;\n    /* 0x12FD */ u8 mDarktimeWeek;\n    /* 0x12FE */ u8 mPondSeason;\n    /* 0x1300 */ s16 field_0x1300;\n    /* 0x1302 */ s16 field_0x1302;\n    /* 0x1304 */ f32 mWaterSurfaceShineRate;\n    /* 0x1308 */ u8 field_0x1308;\n    /* 0x1309 */ u8 field_0x1309;\n    /* 0x130A */ u8 field_0x130a;\n    /* 0x130B */ u8 field_0x130b;\n    /* 0x130C */ u8 field_0x130c;\n};  // Size: 0x1310\n\nextern dScnKy_env_light_c g_env_light;\n\nSTATIC_ASSERT(sizeof(dScnKy_env_light_c) == 4880);\n\ninline dScnKy_env_light_c* i_dKy_getEnvlight() {\n    return &g_env_light;\n}\n\nenum dKy_dice_wether_mode {\n    DICE_MODE_SUNNY_e,\n    DICE_MODE_CLOUDY_e,\n    DICE_MODE_RAIN_LIGHT_e,\n    DICE_MODE_RAIN_HEAVY_e,\n    DICE_MODE_THUNDER_LIGHT_e,\n    DICE_MODE_THUNDER_HEAVY_e,\n    DICE_MODE_UNK6_e,\n    DICE_MODE_DONE_e = 0xFF,\n};\n\nenum dKy_dice_wether_state {\n    DICE_STATE_RESET_e,\n    DICE_STATE_INIT_e,\n    DICE_STATE_EXEC_e,\n    DICE_STATE_NEXT_e,\n};\n\nu8 dKy_darkworld_stage_check(char const*, int);\nBOOL dKy_withwarp_capture_check();\nbool dKy_darkworld_check();\nvoid dKy_undwater_filter_draw();\nBOOL dKy_camera_water_in_status_check();\nstatic int dKy_Outdoor_check();\ns32 dKy_getdaytime_hour();\ns32 dKy_getdaytime_minute();\ns32 dKy_get_dayofweek();\nstatic void dKy_Sound_init();\nvoid dKy_setLight_nowroom(char);\nvoid dKy_setLight_nowroom_actor(dKy_tevstr_c*);\nvoid dKy_setLight_again();\nvoid dKy_GxFog_tevstr_set(dKy_tevstr_c*);\nvoid dKy_plight_set(LIGHT_INFLUENCE* param_0);\nvoid dKy_plight_priority_set(LIGHT_INFLUENCE* param_0);\nvoid dKy_efplight_set(LIGHT_INFLUENCE* param_0);\nvoid dKy_efplight_cut(LIGHT_INFLUENCE* param_0);\nvoid dKy_tevstr_init(dKy_tevstr_c* param_0, s8 param_1, u8 param_2);\nSND_INFLUENCE* dKy_Sound_get();\nvoid dKy_plight_cut(LIGHT_INFLUENCE* param_0);\nvoid dKy_dalkmist_inf_set(DALKMIST_INFLUENCE*);\nvoid dKy_dalkmist_inf_cut(DALKMIST_INFLUENCE*);\nint dKy_rain_check();\nvoid dKy_set_allcol_ratio(f32 ratio);\nvoid dKy_set_actcol_ratio(f32 ratio);\nvoid dKy_set_bgcol_ratio(f32 ratio);\nvoid dKy_set_fogcol_ratio(f32 ratio);\nvoid dKy_set_vrboxcol_ratio(f32 ratio);\nf32 dKy_get_parcent(f32 param_0, f32 param_1, f32 param_2);\nvoid dKy_setLight_nowroom_grass(char param_0, f32 param_1);\nvoid dKy_Global_amb_set(dKy_tevstr_c* i_tevstr);\nu8 dKy_pol_eff_prim_get(cBgS_PolyInfo const* param_0, _GXColor* param_1);\nvoid dKy_pol_eff_env_get(cBgS_PolyInfo const* param_0, _GXColor* param_1);\nu8 dKy_pol_eff_alpha_get(cBgS_PolyInfo const* param_0);\nf32 dKy_pol_eff_ratio_get(cBgS_PolyInfo const* param_0);\nvoid dKy_pol_eff2_prim_get(cBgS_PolyInfo const* param_0, _GXColor* param_1);\nvoid dKy_pol_eff2_env_get(cBgS_PolyInfo const* param_0, _GXColor* param_1);\nu8 dKy_pol_eff2_alpha_get(cBgS_PolyInfo const* param_0);\nf32 dKy_pol_eff2_ratio_get(cBgS_PolyInfo const* param_0);\nu8 dKy_pol_efftype_get(cBgS_PolyInfo const* param_0);\nu8 dKy_pol_efftype2_get(cBgS_PolyInfo const* param_0);\nvoid dKy_ParticleColor_get_actor(cXyz* param_0, dKy_tevstr_c* param_1, _GXColor* param_2,\n                                 _GXColor* param_3, _GXColor* param_4, _GXColor* param_5,\n                                 f32 param_6);\nvoid dKy_ParticleColor_get_bg(cXyz* param_0, dKy_tevstr_c* param_1, _GXColor* param_2,\n                              _GXColor* param_3, _GXColor* param_4, _GXColor* param_5,\n                              f32 param_6);\n_GXColor dKy_light_influence_col(_GXColor* param_0, f32 param_1);\nstatic void dKy_WaterIn_Light_set();\n\n\n#endif /* D_KANKYO_D_KANKYO_H */\n/* end \"d/kankyo/d_kankyo.h\" */\n/* \"include/f_op/f_op_actor.h\" line 4 \"f_pc/f_pc_leaf.h\" */\n\n#ifndef F_PC_LEAF_H_\n#define F_PC_LEAF_H_\n\n/* \"include/f_pc/f_pc_leaf.h\" line 4 \"f_pc/f_pc_base.h\" */\n\n#ifndef F_PC_BASE_H_\n#define F_PC_BASE_H_\n\n/* \"include/f_pc/f_pc_base.h\" line 4 \"f_pc/f_pc_delete_tag.h\" */\n\n#ifndef F_PC_DELETE_TAG_H_\n#define F_PC_DELETE_TAG_H_\n\n/* \"include/f_pc/f_pc_delete_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef struct layer_class layer_class;\n\ntypedef int (*delete_tag_func)(void*);\n\ntypedef struct delete_tag_class {\n    create_tag_class mBase;\n    layer_class* mpLayer;\n    s16 mTimer;\n} delete_tag_class;\n\nBOOL fpcDtTg_IsEmpty(void);\nvoid fpcDtTg_ToDeleteQ(delete_tag_class* pTag);\nvoid fpcDtTg_DeleteQTo(delete_tag_class* pTag);\ns32 fpcDtTg_Do(delete_tag_class* pTag, delete_tag_func pFunc);\ns32 fpcDtTg_Init(delete_tag_class* pTag, void* pUserData);\n\nextern node_list_class g_fpcDtTg_Queue;\n\n#endif\n/* end \"f_pc/f_pc_delete_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 5 \"f_pc/f_pc_layer_tag.h\" */\n\n#ifndef F_PC_LAYER_TAG_H_\n#define F_PC_LAYER_TAG_H_\n\n/* \"include/f_pc/f_pc_layer_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\nenum {\n    fpcLy_ROOT_e    = 0,\n    fpcLy_CURRENT_e = 0xFFFFFFFD,\n    fpcLy_SPECIAL_e = 0xFFFFFFFE,\n    fpcLy_NONE_e    = 0xFFFFFFFF,\n};\n\ntypedef struct layer_class layer_class;\n\n\ntypedef struct layer_management_tag_class {\n    create_tag_class mCreateTag;\n    layer_class* mpLayer;\n    u16 mNodeListID;\n    u16 mNodeListIdx;\n} layer_management_tag_class;\n\ns32 fpcLyTg_QueueTo(layer_management_tag_class* pTag);\ns32 fpcLyTg_ToQueue(layer_management_tag_class* pTag, unsigned int layerID, u16 listID,\n                    u16 listPrio);\ns32 fpcLyTg_Move(layer_management_tag_class*, unsigned int, u16, u16);\ns32 fpcLyTg_Init(layer_management_tag_class*, unsigned int, void*);\n\n#endif\n/* end \"f_pc/f_pc_layer_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 6 \"f_pc/f_pc_line_tag.h\" */\n\n#ifndef F_PC_LINE_TAG_H_\n#define F_PC_LINE_TAG_H_\n\n/* \"include/f_pc/f_pc_line_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef struct line_tag {\n    create_tag_class mBase;\n    s32 mLineListID;\n} line_tag;\n\ns32 fpcLnTg_Move(line_tag* pLineTag, int newLineListID);\nvoid fpcLnTg_QueueTo(line_tag* pLineTag);\ns32 fpcLnTg_ToQueue(line_tag* pLineTag, int lineListID);\nvoid fpcLnTg_Init(line_tag* pLineTag, void* pData);\n\n#endif\n/* end \"f_pc/f_pc_line_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 7 \"f_pc/f_pc_priority.h\" */\n\n#ifndef F_PC_PRIORITY_H_\n#define F_PC_PRIORITY_H_\n\n/* \"include/f_pc/f_pc_priority.h\" line 4 \"f_pc/f_pc_method_tag.h\" */\n\n#ifndef F_PC_METHOD_TAG_H_\n#define F_PC_METHOD_TAG_H_\n\n/* \"include/f_pc/f_pc_method_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef int (*process_method_tag_func)(void*);\n\ntypedef struct process_method_tag_class {\n    create_tag_class mCreateTag;\n    process_method_tag_func mpFunc;\n    void* mpMthdData;\n} process_method_tag_class;\n\ns32 fpcMtdTg_Do(process_method_tag_class* pMthd);\ns32 fpcMtdTg_ToMethodQ(node_list_class* pList, process_method_tag_class* pMthd);\nvoid fpcMtdTg_MethodQTo(process_method_tag_class* pMthd);\ns32 fpcMtdTg_Init(process_method_tag_class* pMthd, process_method_tag_func pFunc, void* pMthdData);\n\n#endif\n/* end \"f_pc/f_pc_method_tag.h\" */\n\nenum {\n    fpcPi_CURRENT_e = 0xFFFD,\n    fpcPi_SPECIAL_e = 0xFFFE,\n};\n\ntypedef struct process_priority_queue_info {\n    u32 mLayer;\n    u16 mListID;\n    u16 mListPrio;\n} process_priority_queue_info;\n\ntypedef struct process_priority_class {\n    /* 0x00 */ create_tag_class mBase;\n    /* 0x14 */ process_method_tag_class mMtdTag;\n    /* 0x30 */ process_priority_queue_info mInfoQ;\n    /* 0x38 */ process_priority_queue_info mInfoCurr;\n} process_priority_class;\n\ns32 fpcPi_IsInQueue(process_priority_class* pPi);\ns32 fpcPi_QueueTo(process_priority_class* pPi);\ns32 fpcPi_ToQueue(process_priority_class* pPi);\nprocess_priority_class* fpcPi_GetFromQueue(void);\ns32 fpcPi_Delete(process_priority_class* pPi);\ns32 fpcPi_IsNormal(unsigned int layer, u16 listID, u16 priority);\ns32 fpcPi_Change(process_priority_class* pPi, unsigned int layer, u16 listID, u16 priority);\ns32 fpcPi_Handler(void);\ns32 fpcPi_Init(process_priority_class* pPi, void* pUserData, unsigned int layer, u16 listID,\n               u16 priority);\n\nextern s8 data_804505F0;  // roomReadId\n\n#endif\n/* end \"f_pc/f_pc_priority.h\" */\n\ntypedef struct create_request create_request;\ntypedef struct process_method_class process_method_class; \ntypedef struct process_profile_definition process_profile_definition;\ntypedef struct profile_method_class profile_method_class;\n\ntypedef struct base_process_class {\n    /* 0x00 */ u32 mBsType;\n    /* 0x04 */ u32 mBsPcId;\n    /* 0x08 */ s16 mProcName;\n    /* 0x0A */ s8 mUnk0;\n    /* 0x0B */ u8 mPauseFlag;\n    /* 0x0C */ s8 mInitState;\n    /* 0x0D */ u8 mUnk2;\n    /* 0x0E */ s16 mBsTypeId;\n    /* 0x10 */ process_profile_definition* mpProf;\n    /* 0x14 */ struct create_request* mpCtRq;\n    /* 0x18 */ layer_management_tag_class mLyTg;\n    /* 0x34 */ line_tag mLnTg;\n    /* 0x4C */ delete_tag_class mDtTg;\n    /* 0x68 */ process_priority_class mPi;\n    /* 0xA8 */ process_method_class* mpPcMtd;\n    /* 0xAC */ void* mpUserData;\n    /* 0xB0 */ u32 mParameters;\n    /* 0xB4 */ u32 mSubType;\n} base_process_class;  // Size: 0xB8\n\ns32 fpcBs_Is_JustOfType(int pType1, int pType2);\ns32 fpcBs_MakeOfType(int* pType);\ns32 fpcBs_MakeOfId(void);\ns32 fpcBs_Execute(base_process_class* pProc);\nvoid fpcBs_DeleteAppend(base_process_class* pProc);\ns32 fpcBs_IsDelete(base_process_class* pProc);\ns32 fpcBs_Delete(base_process_class* pProc);\nbase_process_class* fpcBs_Create(s16 pProcTypeID, unsigned int pProcID, void* pData);\ns32 fpcBs_SubCreate(base_process_class* pProc);\n\nextern \"C\" {\nvoid fpcBs_MakeOfType__FPi(void);\nvoid fpcBs_Is_JustOfType__Fii(void);\n}\n\n#endif\n/* end \"f_pc/f_pc_base.h\" */\n/* \"include/f_pc/f_pc_leaf.h\" line 5 \"f_pc/f_pc_draw_priority.h\" */\n\n#ifndef F_PC_DRAW_PRIORITY_H_\n#define F_PC_DRAW_PRIORITY_H_\n\n/* \"include/f_pc/f_pc_draw_priority.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef struct draw_priority_class {\n    s16 mPriority;\n} draw_priority_class;\n\ns16 fpcDwPi_Get(const draw_priority_class* pDwPi);\nvoid fpcDwPi_Set(draw_priority_class* pDwPi, s16 p);\nvoid fpcDwPi_Init(draw_priority_class* pDwPi, s16 p);\n\n#endif\n/* end \"f_pc/f_pc_draw_priority.h\" */\n/* \"include/f_pc/f_pc_leaf.h\" line 6 \"f_pc/f_pc_method.h\" */\n\n#ifndef F_PC_METHOD_H_\n#define F_PC_METHOD_H_\n\n/* \"include/f_pc/f_pc_method.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef int (*process_method_func)(void*);\n\ntypedef struct process_method_class {\n    process_method_func mpCreateFunc;\n    process_method_func mpDeleteFunc;\n    process_method_func mpExecuteFunc;\n    process_method_func mpIsDeleteFunc;\n} process_method_class;\n\ns32 fpcMtd_Method(process_method_func pFunc, void* pUserData);\ns32 fpcMtd_Execute(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_IsDelete(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_Delete(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_Create(process_method_class* pMthd, void* pUserData);\n\nextern \"C\" {\nvoid fpcMtd_Execute__FP20process_method_classPv(void);\nvoid fpcMtd_Create__FP20process_method_classPv(void);\n}\n\n#endif\n/* end \"f_pc/f_pc_method.h\" */\n/* \"include/f_pc/f_pc_leaf.h\" line 7 \"f_pc/f_pc_profile.h\" */\n\n#ifndef F_PC_PROFILE_H_\n#define F_PC_PROFILE_H_\n\n/* \"include/f_pc/f_pc_profile.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef struct nodedraw_method_class nodedraw_method_class;\ntypedef struct leafdraw_method_class leafdraw_method_class;\ntypedef struct process_method_class process_method_class;\n\ntypedef struct process_profile_definition {\n    /* 0x00 */ s32 mLayerID;\n    /* 0x04 */ u16 mListID;\n    /* 0x06 */ u16 mListPrio;\n    /* 0x08 */ s16 mProcName;\n    /* 0x0C */ process_method_class* mSubMtd; // Subclass methods\n    /* 0x10 */ s32 mSize;\n    /* 0x14 */ s32 mSizeOther;\n    /* 0x18 */ s32 mParameters;\n} process_profile_definition;\n\n#define LAYER_DEFAULT (-2)\n\nstruct leaf_process_profile_definition;\nprocess_profile_definition* fpcPf_Get(s16 profileID);\nextern process_profile_definition** g_fpcPf_ProfileList_p;\n\n#endif\n/* end \"f_pc/f_pc_profile.h\" */\n\ntypedef struct leafdraw_method_class {\n    /* 0x00 */ process_method_class mBase;\n    /* 0x10 */ process_method_func mpDrawFunc;\n} leafdraw_method_class;\n\ntypedef struct leafdraw_class {\n    /* 0x00 */ base_process_class mBase;\n    /* 0xB8 */ leafdraw_method_class* mpDrawMtd;\n    /* 0xBC */ s8 mbUnk0;\n    /* 0xBD */ u8 mbUnk1;\n    /* 0xBE */ draw_priority_class mDwPi;\n} leafdraw_class;\n\ntypedef struct leaf_process_profile_definition {\n    /* 0x00 */ process_profile_definition mBase;\n    /* 0x1C */ leafdraw_method_class* mSubMtd; // Subclass methods\n    /* 0x20 */ s16 mPriority; // mDrawPriority\n} leaf_process_profile_definition;\n\ns16 fpcLf_GetPriority(const leafdraw_class* pLeaf);\ns32 fpcLf_DrawMethod(leafdraw_method_class* pMthd, void* pUserData);\ns32 fpcLf_Draw(leafdraw_class* pMthd);\ns32 fpcLf_Execute(leafdraw_class* pLeaf);\ns32 fpcLf_IsDelete(leafdraw_class* pLeaf);\ns32 fpcLf_Delete(leafdraw_class* pLeaf);\ns32 fpcLf_Create(leafdraw_class* pLeaf);\n\nextern int g_fpcLf_type;\nextern leafdraw_method_class g_fpcLf_Method;\n\n#endif\n/* end \"f_pc/f_pc_leaf.h\" */\n/* \"include/f_op/f_op_actor.h\" line 5 \"global.h\" */\n/* end \"global.h\" */\n\nstruct actor_method_class {\n    /* 0x00 */ leafdraw_method_class base;\n    /* 0x14 */ u8 field_0x14[0xC];  // Likely padding\n};\n\nstruct actor_process_profile_definition {\n    /* 0x00 */ leaf_process_profile_definition mBase;\n    /* 0x24 */ actor_method_class* mSubMtd;\n    /* 0x28 */ u32 mStatus;\n    /* 0x2C */ u8 mActorType;\n    /* 0x2D */ u8 mCullType;\n};\n\n// Unclear what this is. Only appears in 4 profiles (BG,DSHUTTER,PATH,SCENE_EXIT)\nstruct actor_process_profile_definition2 {\n    /* 0x00 */ actor_process_profile_definition def;\n    /* 0x30 */ u32 field_0x30;\n};\n\nenum fopAc_Status_e {\n    fopAcStts_NOEXEC_e = 0x00000080,\n    fopAcStts_CULL_e = 0x00000100,\n    fopAcStts_FREEZE_e = 0x00000400,\n    fopAcStts_CARRY_e = 0x00002000,\n    fopAcStts_NOPAUSE_e = 0x00020000,\n    fopAcStts_NODRAW_e = 0x01000000,\n    fopAcStts_BOSS_e = 0x04000000,\n};\n\nenum fopAc_Group_e {\n    /* 0 */ fopAc_ACTOR_e,\n    /* 1 */ fopAc_PLAYER_e,\n    /* 2 */ fopAc_ENEMY_e,\n    /* 3 */ fopAc_ENV_e,  // is this correct?\n    /* 4 */ fopAc_NPC_e,\n};\n\nenum fopAc_Condition_e {\n    fopAcCnd_NOEXEC_e = 0x02,\n    fopAcCnd_NODRAW_e = 0x04,\n    fopAcCnd_INIT_e = 0x08,\n};\n\nenum fopAc_Cull_e {\n    fopAc_CULLBOX_0_e,\n    fopAc_CULLBOX_1_e,\n    fopAc_CULLBOX_2_e,\n    fopAc_CULLBOX_3_e,\n    fopAc_CULLBOX_4_e,\n    fopAc_CULLBOX_5_e,\n    fopAc_CULLBOX_6_e,\n    fopAc_CULLBOX_7_e,\n    fopAc_CULLBOX_8_e,\n    fopAc_CULLBOX_9_e,\n    fopAc_CULLBOX_10_e,\n    fopAc_CULLBOX_11_e,\n    fopAc_CULLBOX_12_e,\n    fopAc_CULLBOX_13_e,\n    fopAc_CULLBOX_CUSTOM_e,\n    fopAc_CULLSPHERE_0_e,\n    fopAc_CULLSPHERE_1_e,\n    fopAc_CULLSPHERE_2_e,\n    fopAc_CULLSPHERE_3_e,\n    fopAc_CULLSPHERE_4_e,\n    fopAc_CULLSPHERE_5_e,\n    fopAc_CULLSPHERE_6_e,\n    fopAc_CULLSPHERE_7_e,\n    fopAc_CULLSPHERE_8_e,\n    fopAc_CULLSPHERE_9_e,\n    fopAc_CULLSPHERE_10_e,\n    fopAc_CULLSPHERE_11_e,\n    fopAc_CULLSPHERE_12_e,\n    fopAc_CULLSPHERE_13_e,\n    fopAc_CULLSPHERE_CUSTOM_e,\n};\n\nclass JKRSolidHeap;\n\nenum dEvt_Command_e {\n    dEvtCmd_NONE_e,\n    dEvtCmd_INTALK_e,\n    dEvtCmd_INDEMO_e,\n    dEvtCmd_INDOOR_e,\n    dEvtCmd_INGETITEM_e,\n    dEvtCmd_INCATCH_e = 6,\n    dEvtCmd_DUMMY = 0xFFFF,\n};\n\nenum dEvt_Condition_e {\n    dEvtCnd_NONE_e = 0x0000,\n    dEvtCnd_CANTALK_e = 0x0001,\n    dEvtCnd_CANDOOR_e = 0x0004,\n    dEvtCnd_CANGETITEM_e = 0x0008,\n    dEvtCnd_CANTALKITEM_e = 0x0020,\n    dEvtCnd_DUMMY = 0x8000,\n};\n\nclass dEvt_info_c {\npublic:\n    dEvt_info_c();\n    virtual ~dEvt_info_c() {}\n    void setEventName(char*);\n    char* getEventName();\n    void beforeProc();\n    void onCondition(u16);\n    void offCondition(u16);\n    bool checkCommandCatch();\n    BOOL checkCommandDoor();\n    BOOL checkCommandDemoAccrpt() { return mCommand == dEvtCmd_INDEMO_e; }\n\n    void setCommand(u16 command) { mCommand = command; }\n    void setMapToolId(u8 id) { mMapToolId = id; }\n    void setEventId(s16 id) { mEventId = id; }\n    void setCondition(u16 condition) { mCondition = condition; }\n    u16 getCondition() { return mCondition; }\n    void setArchiveName(char* name) { mArchiveName = name; }\n    u8 getMapToolId() { return mMapToolId; }\n    s16 getEventId() { return mEventId; }\n    s16 getIdx() { return mIndex; }\n    void setIdx(u8 i_idx) { mIndex = i_idx; }\n    char* getArchiveName() { return mArchiveName; }\n    BOOL chkCondition(u16 condition) { return (mCondition & condition) == condition; }\n    void i_onCondition(u16 cond) { mCondition |= cond; }\n    void i_offCondition(u16 cond) { mCondition &= ~cond; }\n\n    bool checkCommandTalk() { return mCommand == dEvtCmd_INTALK_e; }\n    bool checkCommandItem() { return mCommand == dEvtCmd_INGETITEM_e; }\n    BOOL i_checkCommandDoor() { return mCommand == dEvtCmd_INDOOR_e; }\n    bool i_checkCommandDemoAccrpt() { return mCommand == dEvtCmd_INDEMO_e; }\n    bool i_checkCommandCatch() { return mCommand == dEvtCmd_INCATCH_e; }\n\n    void suspendProc(void* actor) {\n        if (field_0x10 != NULL) {\n            field_0x14(actor);\n        }\n    }\n\n    /* 0x04 */ u16 mCommand;\n    /* 0x06 */ u16 mCondition;\n    /* 0x08 */ s16 mEventId;\n    /* 0x0A */ u8 mMapToolId;\n    /* 0x0B */ s8 mIndex;\n    /* 0x0C */ char* mArchiveName;\n    /* 0x10 */ u8 field_0x10;\n    /* 0x14 */ void (*field_0x14)(void*);\n};  // Size = 0x18\n\nstruct actor_place {\n    /* 807E2468 */  // void operator=(actor_place const&);\n\n    /* 0x00 */ cXyz pos;\n    /* 0x0C */ csXyz angle;\n    /* 0x12 */ s8 roomNo;\n    /* 0x13 */ u8 field_0x13;\n};\n\nstruct actor_attention_types {\n    void setFlag(u32 flags) { mFlags |= flags; }\n\n    /* 0x00 */ u8 field_0x0[9];\n    /* 0x0A */ s16 field_0xa;\n    /* 0x0C */ cXyz mPosition;\n    /* 0x18 */ u32 mFlags;\n};  // Size = 0x1C\n\nclass dJntCol_c;\n\nstruct cull_sphere {\n    /* 0x0 */ Vec mCenter;\n    /* 0xC */ f32 mRadius;\n};\n\nstruct cull_box {\n    /* 0x0 */ Vec mMin;\n    /* 0xC */ Vec mMax;\n};\n\nclass fopAc_ac_c : public leafdraw_class {\npublic:\n    /* 0x0C0 */ int mAcType;\n    /* 0x0C4 */ create_tag_class mAcTg;\n    /* 0x0D8 */ create_tag_class mDwTg;\n    /* 0x0EC */ profile_method_class* mSubMtd;\n    /* 0x0F0 */ JKRSolidHeap* mHeap;\n    /* 0x0F4 */ dEvt_info_c mEvtInfo;\n    /* 0x10C */ dKy_tevstr_c mTevStr;\n    /* 0x494 */ u16 mSetID;\n    /* 0x496 */ u8 mGroup;\n    /* 0x497 */ s8 mCullType;\n    /* 0x498 */ u8 mDemoActorId;\n    /* 0x499 */ s8 mSubtype;\n    /* 0x49A */ u8 mCarryType;\n    /* 0x49C */ u32 mStatus;\n    /* 0x4A0 */ u32 mCondition;\n    /* 0x4A4 */ u32 mParentPcId;\n    /* 0x4A8 */ actor_place orig;\n    /* 0x4BC */ actor_place next;\n    /* 0x4D0 */ actor_place current;\n    /* 0x4E4 */ csXyz shape_angle;\n    /* 0x4EC */ cXyz mScale;\n    /* 0x4F8 */ cXyz speed;\n    /* 0x504 */ MtxP mCullMtx;\n    union {\n        /* 0x508 */ cull_box mBox;\n        /* 0x508 */ cull_sphere mSphere;\n    } mCull;\n    /* 0x520 */ f32 mCullSizeFar;\n    /* 0x524 */ J3DModel* model;\n    /* 0x528 */ dJntCol_c* mJntCol;\n    /* 0x52C */ f32 speedF;\n    /* 0x530 */ f32 mGravity;\n    /* 0x534 */ f32 mMaxFallSpeed;\n    /* 0x538 */ cXyz mEyePos;\n    /* 0x544 */ actor_attention_types mAttentionInfo;\n    /* 0x560 */ s16 field_0x560;\n    /* 0x562 */ s16 mHealth;\n    /* 0x564 */ u8 field_0x564;\n    /* 0x565 */ u8 field_0x565;\n    /* 0x566 */ u8 field_0x566;\n    /* 0x567 */ s8 field_0x567;\n\n    fopAc_ac_c();\n    ~fopAc_ac_c();\n\n    static u32 stopStatus;\n\n    const cXyz& getPosition() const { return current.pos; }\n    const csXyz& getAngle() const { return current.angle; }\n    s8 getRoomNo() const { return current.roomNo; }\n};  // Size: 0x568\n\nSTATIC_ASSERT(sizeof(fopAc_ac_c) == 0x568);\n\nclass fopEn_enemy_c : public fopAc_ac_c {\npublic:\n    /* 80019404 */ bool initBallModel();\n    /* 800194FC */ bool checkBallModelDraw();\n    /* 80019520 */ void setBallModelEffect(dKy_tevstr_c*);\n    /* 800196A0 */ void drawBallModel(dKy_tevstr_c*);\n\n    bool checkWolfNoLock() const { return mFlags & 0x200; }\n    bool checkHeadLockFlg() const { return mFlags & 0x80; }\n    bool checkDownFlg() const { return mFlags & 0x1; }\n    bool checkDeadFlg() const { return mFlags & 0x8; }\n    cXyz& getDownPos() { return mDownPos; }\n    cXyz& getHeadLockPos() { return mHeadLockPos; }\n\n    void onCutDownHitFlg() { mFlags |= 2; }\n    void onWolfBiteDamage() { mFlags |= 0x40; }\n    void onWolfDownStartFlg() { mFlags |= 0x14; }\n    void onWolfDownPullEndFlg() { mFlags |= 0x20; }\n\n    void setThrowModeCatch() { mThrowMode |= 2; }\n    void setThrowModeDash() { mThrowMode |= 4; }\n    void setThrowModeThrowRight() { mThrowMode |= 0x10; }\n    void setThrowModeThrowLeft() { mThrowMode |= 8; }\n    \n    /* 0x568 */ cXyz mDownPos;\n    /* 0x574 */ cXyz mHeadLockPos;\n    /* 0x580 */ J3DModel* mBallModel;\n    /* 0x584 */ J3DAnmTextureSRTKey* mBtk;\n    /* 0x588 */ J3DAnmTevRegKey* mBrk;\n    /* 0x58C */ u8 field_0x58c;\n    /* 0x58D */ u8 mThrowMode;\n    /* 0x58E */ u16 mFlags;\n    /* 0x590 */ f32 field_0x590;\n    /* 0x594 */ u32 mEffectID1;\n    /* 0x598 */ u32 mEffectID2;\n    /* 0x59C */ u32 mMidnaBindID[3];\n    /* 0x5A8 */ u8 field_0x5a8;\n};  // Size: 0x5AC\n\ns32 fopAc_IsActor(void* actor);\n\nextern actor_method_class g_fopAc_Method;\n\n#endif\n/* end \"f_op/f_op_actor.h\" */\n\nstruct ResTIMG;\n\nclass daPy_sightPacket_c : public dDlst_base_c {\npublic:\n    daPy_sightPacket_c() {}\n    /* 8015F1A0 */ virtual void draw();\n    /* 80140CDC */ virtual ~daPy_sightPacket_c() {}\n\n    /* 8015F2FC */ void setSight();\n    /* 8015F384 */ void setSightImage(ResTIMG*);\n\n    bool getDrawFlg() { return mDrawFlag; }\n    void onDrawFlg() { mDrawFlag = true; }\n    void offDrawFlg() { mDrawFlag = false; }\n    void setPos(const cXyz* i_pos) { mPos = *i_pos; }\n\nprivate:\n    /* 0x04 */ bool mDrawFlag;\n    /* 0x05 */ u8 field_0x5[3];\n    /* 0x08 */ cXyz mPos;\n    /* 0x14 */ Mtx field_0x14;\n    /* 0x44 */ ResTIMG* mpImg;\n    /* 0x48 */ u8* mpData;\n};\n\nclass daPy_boomerangMove_c {\npublic:\n    /* 8015E5B0 */ void initOffset(cXyz const*);\n    /* 8015E654 */ int posMove(cXyz*, s16*, fopAc_ac_c*, s16);\n    /* 8015E87C */ void bgCheckAfterOffset(cXyz const*);\n\n    static void initDropAngleY() { m_dropAngleY = 0x4000; }\n    static void offEventKeepFlg() { m_eventKeepFlg = 0; }\n\n    static s16 m_dropAngleY;\n    static s16 m_eventKeepFlg;\n\nprivate:\n    /* 0x0 */ u8 field_0x0;\n    /* 0x2 */ s16 field_0x2;\n    /* 0x4 */ f32 field_0x4;\n    /* 0x8 */ f32 field_0x8;\n};  // Size: 0xC\n\nclass daPy_anmHeap_c {\npublic:\n    enum daAlinkHEAP_TYPE {\n        HEAP_TYPE_1 = 1,\n        HEAP_TYPE_2,\n        HEAP_TYPE_3,\n        HEAP_TYPE_4,\n        HEAP_TYPE_5,\n    };\n\n    /* 80140DCC */ void __defctor();  // compiler generated due to ctor with default param\n\n    daPy_anmHeap_c(u32 param_0 = 0);\n    ~daPy_anmHeap_c();\n    void initData();\n    void* mallocBuffer();\n    void createHeap(daPy_anmHeap_c::daAlinkHEAP_TYPE);\n    void* loadData(u16);\n    void* loadDataIdx(u16);\n    void* loadDataPriIdx(u16);\n    void* loadDataDemoRID(u16, u16);\n    JKRHeap* setAnimeHeap();\n\n    u16 getIdx() const { return mIdx; }\n    void resetIdx() { mIdx = 0xffff; }\n    void resetPriIdx() { mPriIdx = 0xffff; }\n    void resetArcNo() { mArcNo = 0xffff; }\n    bool checkNoSetArcNo() const { return mArcNo == 0xFFFF; }\n    void setBufferSize(u32 size) { mBufferSize = size; }\n    void setBuffer(u8* buf) { mBuffer = buf; }\n    u8* getBuffer() { return mBuffer; }\n    bool checkNoSetIdx() const { return mIdx == 0xFFFF; }\n    bool checkNoSetPriIdx() const { return mPriIdx == 0xFFFF; }\n\nprivate:\n    /* 0x00 */ u16 mIdx;\n    /* 0x02 */ u16 mPriIdx;\n    /* 0x04 */ u16 mArcNo;\n    /* 0x06 */ u16 field_0x06;\n    /* 0x08 */ u32 mBufferSize;\n    /* 0x0C */ u8* mBuffer;\n    /* 0x10 */ JKRSolidHeap* mAnimeHeap;\n};  // Size = 0x14\n\nclass daPy_actorKeep_c {\npublic:\n    daPy_actorKeep_c() { clearData(); }\n\n    void setActor();\n    void setData(fopAc_ac_c*);\n    void clearData();\n\n    u32 getID() const { return mID; }\n    void setID(u32 id) { mID = id; }\n    fopAc_ac_c* getActor() const { return mActor; }\n    fopAc_ac_c* getActorConst() const { return mActor; }\n\nprivate:\n    /* 0x0 */ u32 mID;\n    /* 0x4 */ fopAc_ac_c* mActor;\n};  // Size: 0x8\n\nclass daPy_frameCtrl_c : public J3DFrameCtrl {\npublic:\n    /* 80140D24 */ ~daPy_frameCtrl_c();\n    /* 80140D80 */ daPy_frameCtrl_c();\n    bool checkAnmEnd();\n    void updateFrame();\n    void setFrameCtrl(u8, short, short, f32, f32);\n\n    u16 getEndFlg() { return mEndFlg; }\n    u16 getNowSetFlg() { return mNowSetFlg; }\n    void onEndFlg() { mEndFlg = 1; }\n    void onNowSetFlg() { mNowSetFlg = 1; }\n    void offNowSetFlg() { mNowSetFlg = 0; }\n    void offEndFlg() {\n        mEndFlg = 0;\n        mNowSetFlg = 0;\n    }\n\nprivate:\n    /* 0x14 */ u16 mEndFlg;\n    /* 0x16 */ u16 mNowSetFlg;\n};\n\nclass Z2WolfHowlMgr;\nclass daBoomerang_c;\n\nclass daPy_demo_c {\npublic:\n    enum {\n        DEMO_LAST_e = 0x5F,\n        DEMO_NEW_ANM0_e = 0x200,\n    };\n\n    void setSpecialDemoType();\n\n    void setDemoType(u16 pType) { mDemoType = pType; }\n    int getDemoType() const { return mDemoType; }\n    void setDemoMode(u32 mode) { mDemoMode = mode; }\n    u32 getDemoMode() const { return mDemoMode; }\n    int getParam1() const { return mParam1; }\n    s16 getParam2() const { return mParam2; }\n    void setOriginalDemoType() { setDemoType(3); }\n    void i_setSpecialDemoType() { setDemoType(5); }\n    void setSystemDemoType() { setDemoType(2); }\n    void setStick(f32 stick) { mStick = stick; }\n    void setMoveAngle(s16 angle) { mDemoMoveAngle = angle; }\n    s16 getMoveAngle() const { return mDemoMoveAngle; }\n    f32 getStick() { return mStick; }\n    int getParam0() const { return mParam0; }\n    void setParam0(int value) { mParam0 = value; }\n    void setParam1(int value) { mParam1 = value; }\n    void setParam2(int value) { mParam2 = value; }\n    void setPos0(const cXyz* pos) { mDemoPos0 = *pos; }\n    void setToolDemoType() { setDemoType(1); }\n    s16 getTimer() const { return mTimer; }\n    void decTimer() { mTimer--; }\n    void setTimer(s16 i_timer) { mTimer = i_timer; }\n    cXyz* getPos0() { return &mDemoPos0; }\n    void resetDemoType() { setDemoType(0); }\n\nprivate:\n    /* 0x00 */ u16 mDemoType;\n    /* 0x02 */ s16 mDemoMoveAngle;\n    /* 0x04 */ s16 mTimer;\n    /* 0x06 */ s16 mParam2;\n    /* 0x08 */ int mParam0;\n    /* 0x0C */ int mParam1;\n    /* 0x10 */ u32 mDemoMode;\n    /* 0x14 */ f32 mStick;\n    /* 0x18 */ cXyz mDemoPos0;\n};  // Size: 0x24\n\nclass daMidna_c;\nclass daPy_py_c;\ninline daPy_py_c* dComIfGp_getLinkPlayer();\ninline BOOL i_dComIfGs_isEventBit(const u16);\n\nclass daPy_py_c : public fopAc_ac_c {\npublic:\n    /* 0x0568 */ u8 mCutType;\n    /* 0x0569 */ u8 mComboCutCount;\n    /* 0x056A */ u8 mSpecialMode;  // maybe needs better name\n    /* 0x056B */ u8 field_0x56b;\n    /* 0x056C */ s16 mDamageTimer;\n    /* 0x056E */ u16 mSwordUpTimer;\n    /* 0x0570 */ u32 mNoResetFlg0;\n    /* 0x0574 */ u32 mNoResetFlg1;\n    /* 0x0578 */ u32 mNoResetFlg2;\n    /* 0x057C */ u32 mNoResetFlg3;\n    /* 0x0580 */ u32 mResetFlg0;\n    /* 0x0584 */ u32 mResetFlg1;\n    /* 0x0588 */ u32 mEndResetFlg0;\n    /* 0x058C */ u32 mEndResetFlg1;\n    /* 0x0590 */ u32 mEndResetFlg2;\n    /* 0x0594 */ f32 field_0x594;\n    /* 0x0598 */ f32 field_0x598;\n    /* 0x059C */ csXyz mBodyAngle;\n    /* 0x05A4 */ cXyz mHeadTopPos;\n    /* 0x05B0 */ cXyz mItemPos;\n    /* 0x05BC */ cXyz mSwordTopPos;\n    /* 0x05C8 */ cXyz mLeftHandPos;\n    /* 0x05D4 */ cXyz mRightHandPos;\n    /* 0x05E0 */ cXyz mLeftFootPos;\n    /* 0x05EC */ cXyz mRightFootPos;\n    /* 0x05F8 */ u8 field_0x5f8[0xC];\n    /* 0x0604 */ daPy_demo_c mDemo;\n\npublic:\n    enum daPy_FLG0 {\n        FLG0_UNK_40000000 = 0x40000000,\n        FLG0_EQUIP_HVY_BOOTS = 0x2000000,\n        FLG0_PLAYER_NO_DRAW = 0x8000000,\n        FLG0_UNK_10000000 = 0x10000000,\n        FLG0_UNK_1000000 = 0x1000000,\n        FLG0_UNDERWATER = 0x800000,\n        FLG0_UNK_200000 = 0x200000,\n        FLG0_UNK_100000 = 0x100000,\n        FLG0_UNK_80000 = 0x80000,\n        FLG0_UNK_40000 = 0x40000,\n        FLG0_UNK_20000 = 0x20000,\n        FLG0_UNK_8000 = 0x8000,\n        FLG0_UNK_4000 = 0x4000,\n        FLG0_UNK_2000 = 0x2000,\n        FLG0_MAGNE_BOOTS_ON = 0x1000,\n        FLG0_PUSH_PULL_KEEP = 0x800,\n        FLG0_UNK_400 = 0x400,\n        FLG0_UNK_100 = 0x100,\n        FLG0_UNK_80 = 0x80,\n        FLG0_UNK_40 = 0x40,\n        FLG0_UNK_20 = 0x20,\n        FLG0_UNK_10 = 0x10,\n        FLG0_UNK_8 = 0x8,\n        FLG0_MIDNA_RIDE = 4,\n        FLG0_UNK_2 = 2,\n\n        FLG0_HVY_STATE = FLG0_UNK_40000000 | FLG0_EQUIP_HVY_BOOTS | FLG0_UNK_20000,\n        FLG0_UNK_14000 = 0x14000,\n        FLG0_UNK_10400 = 0x10400,\n        FLG0_UNK_18 = FLG0_UNK_10 | FLG0_UNK_8,\n    };\n\n    enum daPy_FLG1 {\n        FLG1_UNK_40000000 = 0x40000000,\n        FLG1_UNK_20000000 = 0x20000000,\n        FLG1_UNK_10000000 = 0x10000000,\n        FLG1_UNK_4000000 = 0x4000000,\n        FLG1_IS_WOLF = 0x2000000,\n        FLG1_UNK_800000 = 0x800000,\n        FLG1_DASH_MODE = 0x400000,\n        FLG1_UNK_10000 = 0x10000,\n        FLG1_UNK_8000 = 0x8000,\n        FLG1_THROW_DAMAGE = 0x4000,\n        FLG1_UNK_2000 = 0x2000,\n        FLG1_UNK_1000 = 0x1000,\n        FLG1_UNK_800 = 0x800,\n        FLG1_UNK_200 = 0x200,\n        FLG1_UNK_80 = 0x80,\n        FLG1_UNK_40 = 0x40,\n        FLG1_UNK_20 = 0x20,\n        FLG1_UNK_10 = 0x10,\n        FLG1_UNK_4 = 4,\n        FLG1_UNK_2 = 2,\n        FLG1_UNK_1 = 1,\n\n        FLG1_UNK_1800 = 0x1800,\n    };\n\n    enum daPy_FLG2 {\n        FLG2_UNK_20000000 = 0x20000000,\n        FLG2_UNK_10000000 = 0x10000000,\n        FLG2_UNK_4080000 = 0x4080000,\n        FLG2_UNK_2080000 = 0x2080000,\n        FLG2_BOAR_SINGLE_BATTLE = 0x1800000,\n        FLG2_UNK_8000000 = 0x8000000,\n        FLG2_UNK_1000000 = 0x1000000,\n        FLG2_UNK_800000 = 0x800000,\n        FLG2_STATUS_WINDOW_DRAW = 0x400000,\n        FLG2_UNK_280000 = 0x280000,\n        FLG2_UNK_200000 = 0x200000,\n        FLG2_UNK_100000 = 0x100000,\n        FLG2_UNK_80000 = 0x80000,\n        FLG2_UNK_40000 = 0x40000,\n        FLG2_UNK_20000 = 0x20000,\n        FLG2_UNK_10000 = 0x10000,\n        FLG2_SCN_CHG_START = 0x8000,\n        FLG2_UNK_4000 = 0x4000,\n        FLG2_UNK_2000 = 0x2000,\n        FLG2_UNK_1000 = 0x1000,\n        FLG2_UNK_400 = 0x400,\n        FLG2_UNK_200 = 0x200,\n        FLG2_UNK_80 = 0x80,\n        FLG2_UNK_40 = 0x40,\n        FLG2_WOLF_ENEMY_LEFT_THROW = 0x20,\n        FLG2_UNK_10 = 0x10,\n        FLG2_UNK_8 = 8,\n        FLG2_UNK_2 = 2,\n        FLG2_UNK_1 = 1,\n\n        FLG2_UNK_58 = FLG2_UNK_40 | FLG2_UNK_10 | FLG2_UNK_8,\n    };\n\n    enum daPy_FLG3 {\n        FLG3_UNK_80000000 = 0x80000000,\n        FLG3_UNK_40000000 = 0x40000000,\n        FLG3_UNK_20000000 = 0x20000000,\n        FLG3_UNK_4000000 = 0x4000000,\n        FLG3_UNK_2000000 = 0x2000000,\n        FLG3_UNK_1000000 = 0x1000000,\n        FLG3_UNK_800000 = 0x800000,\n        FLG3_UNK_400000 = 0x400000,\n        FLG3_UNK_200000 = 0x200000,\n        FLG3_UNK_100000 = 0x100000,\n        FLG3_UNK_80000 = 0x80000,\n        FLG3_COPY_ROD_THROW_AFTER = 0x40000,\n        FLG3_UNK_4000 = 0x4000,\n        FLG3_UNK_400 = 0x400,\n        FLG3_UNK_200 = 0x200,\n        FLG3_UNK_100 = 0x100,\n        FLG3_UNK_80 = 0x80,\n        FLG3_UNK_40 = 0x40,\n        FLG3_UNK_20 = 0x20,\n        FLG3_UNK_10 = 0x10,\n        FLG3_UNK_4 = 4,\n    };\n\n    enum daPy_ERFLG0 {\n        ERFLG0_UNK_40000000 = 0x40000000,\n        ERFLG0_UNK_20000000 = 0x20000000,\n        ERFLG0_UNK_10000000 = 0x10000000,\n        ERFLG0_UNK_8000000 = 0x8000000,\n        ERFLG0_UNK_2000000 = 0x2000000,\n        ERFLG0_UNK_1000000 = 0x1000000,\n        ERFLG0_UNK_800000 = 0x800000,\n        ERFLG0_UNK_400000 = 0x400000,\n        ERFLG0_UNK_200000 = 0x200000,\n        ERFLG0_UNK_100000 = 0x100000,\n        ERFLG0_UNK_2000 = 0x2000,\n        ERFLG0_UNK_1000 = 0x1000,\n        ERFLG0_UNK_400 = 0x400,\n        ERFLG0_FORCE_AUTO_JUMP = 0x200,\n        ERFLG0_UNK_100 = 0x100,\n        ERFLG0_UNK_80 = 0x80,\n        ERFLG0_UNK_40 = 0x40,\n        ERFLG0_NOT_AUTO_JUMP = 0x20,\n        ERFLG0_NOT_HANG = 0x10,\n        ERFLG0_UNK_8 = 8,\n        ERFLG0_UNK_4 = 4,\n        ERFLG0_UNK_2 = 2,\n        ERFLG0_UNK_1 = 1,\n    };\n\n    enum daPy_ERFLG1 {\n        ERFLG1_GANON_FINISH = 0x80000000,\n        ERFLG1_UNK_40000000 = 0x40000000,\n        ERFLG1_UNK_20000000 = 0x20000000,\n        ERFLG1_UNK_10000000 = 0x10000000,\n        ERFLG1_UNK_4000000 = 0x4000000,\n        ERFLG1_UNK_200000 = 0x200000,\n        ERFLG1_UNK_100000 = 0x100000,\n        ERFLG1_UNK_40000 = 0x40000,\n        ERFLG1_UNK_10000 = 0x10000,\n        ERFLG1_UNK_2000 = 0x2000,\n        ERFLG1_UNK_800 = 0x800,\n        ERFLG1_UNK_400 = 0x400,\n        ERFLG1_WOLF_EYE_KEEP = 0x200,\n        ERFLG1_UNK_100 = 0x100,\n        ERFLG1_UNK_80 = 0x80,\n        ERFLG1_UNK_40 = 0x40,\n        ERFLG1_UNK_20 = 0x20,\n        ERFLG1_UNK_10 = 0x10,\n        ERFLG1_UNK_8 = 8,\n        ERFLG1_UNK_4 = 4,\n        ERFLG1_UNK_2 = 2,\n        ERFLG1_UNK_1 = 1,\n    };\n\n    enum daPy_ERFLG2 {\n        ERFLG2_UNK_100 = 0x100,\n        ERFLG2_UNK_40 = 0x40,\n        ERFLG2_UNK_20 = 0x20,\n        ERFLG2_UNK_2 = 2,\n    };\n\n    enum daPy_RFLG0 {\n        RFLG0_UNK_40000000 = 0x40000000,\n        RFLG0_UNK_20000000 = 0x20000000,\n        RFLG0_UNK_8000000 = 0x8000000,\n        RFLG0_UNK_4000000 = 0x4000000,\n        RFLG0_UNK_20000 = 0x20000,\n        RFLG0_UNK_8000 = 0x8000,\n        RFLG0_UNK_4000 = 0x4000,\n        RFLG0_FRONT_ROLL_CRASH = 0x2000,\n        RFLG0_ENEMY_ATTN_LOCK = 0x1000,\n        RFLG0_UNK_400 = 0x400,\n        RFLG0_UNK_200 = 0x200,\n        RFLG0_UNK_100 = 0x100,\n        RFLG0_UNK_80 = 0x80,\n        RFLG0_UNK_40 = 0x40,\n        RFLG0_GRAB_UP_END = 0x20,\n        RFLG0_UNK_10 = 0x10,\n        RFLG0_UNK_8 = 0x8,\n        RFLG0_UNK_2 = 0x2,\n    };\n\n    enum daPy_RFLG1 {\n        RFLG1_UNK_100 = 0x100,\n        RFLG1_UNK_30 = 0x30,\n        RFLG1_UNK_2 = 0x2,\n        RFLG1_WOLF_ATTACK_REVERSE = 0x1,\n\n        RFLG1_UNK_C = 0xC,\n    };\n\n    enum {\n        /* 0x01 */ SMODE_SUMO_READY = 1,\n        /* 0x25 */ SMODE_SUMO_LOSE = 37,\n        /* 0x27 */ SMODE_WOLF_PUZZLE = 39,\n        /* 0x2A */ SMODE_GOAT_STOP = 42,\n        /* 0x2B */ SMODE_GORON_THROW,\n        /* 0x2C */ SMODE_CARGO_CARRY,\n    };\n\n    enum CutType {\n        /* 0x01 */ CUT_TYPE_NM_VERTICAL = 1,\n        /* 0x02 */ CUT_TYPE_NM_STAB,\n        /* 0x03 */ CUT_TYPE_NM_RIGHT,\n        /* 0x04 */ CUT_TYPE_NM_LEFT,\n        /* 0x05 */ CUT_TYPE_HEAD_JUMP,  // Helm Splitter\n        /* 0x06 */ CUT_TYPE_FINISH_LEFT,\n        /* 0x07 */ CUT_TYPE_FINISH_VERTICAL,\n        /* 0x08 */ CUT_TYPE_TURN_RIGHT,\n        /* 0x0A */ CUT_TYPE_JUMP = 10,\n        /* 0x0B */ CUT_TYPE_DASH_UNK_B,\n        /* 0x0C */ CUT_TYPE_DASH_UNK_C,\n        /* 0x0D */ CUT_TYPE_DASH_UNK_D,\n        /* 0x10 */ CUT_TYPE_AIR = 0x10,\n        /* 0x11 */ CUT_TYPE_DASH_UNK_11,\n        /* 0x12 */ CUT_TYPE_LARGE_JUMP_INIT,\n        /* 0x13 */ CUT_TYPE_LARGE_JUMP,\n        /* 0x14 */ CUT_TYPE_LARGE_JUMP_FINISH,\n        /* 0x15 */ CUT_TYPE_FINISH_RIGHT,\n        /* 0x16 */ CUT_TYPE_TURN_LEFT,\n        /* 0x17 */ CUT_TYPE_LARGE_TURN_LEFT,\n        /* 0x18 */ CUT_TYPE_LARGE_TURN_RIGHT,\n        /* 0x1A */ CUT_TYPE_MORTAL_DRAW_A = 0x1A,\n        /* 0x1E */ CUT_TYPE_TWIRL = 0x1E,  // Back Slice\n        /* 0x1F */ CUT_TYPE_MORTAL_DRAW_B,\n        /* 0x20 */ CUT_TYPE_FINISH_STAB,\n        /* 0x21 */ CUT_TYPE_COMBO_STAB,\n        /* 0x22 */ CUT_TYPE_HORSE_UNK_22,\n        /* 0x23 */ CUT_TYPE_HORSE_UNK_23,\n        /* 0x25 */ CUT_TYPE_DASH_UNK_25 = 0x25,\n        /* 0x26 */ CUT_TYPE_DASH_UNK_26 = 0x26,\n        /* 0x27 */ CUT_TYPE_DOWN,\n        /* 0x29 */ CUT_TYPE_GUARD_ATTACK = 0x29,\n        /* 0x2A */ CUT_TYPE_HORSE_UNK_2A,\n        /* 0x2B */ CUT_TYPE_HORSE_TURN,\n        /* 0x2C */ CUT_TYPE_WOLF_B_LEFT,\n        /* 0x2D */ CUT_TYPE_WOLF_B_RIGHT,\n        /* 0x2E */ CUT_TYPE_WOLF_B_FRONT,\n        /* 0x2F */ CUT_TYPE_WOLF_B_BACK,\n        /* 0x31 */ CUT_TYPE_WOLF_UNK_31 = 0x31,\n        /* 0x32 */ CUT_TYPE_WOLF_UNK_32,\n        /* 0x33 */ CUT_TYPE_WOLF_TURN_LEFT,\n        /* 0x34 */ CUT_TYPE_WOLF_TURN_RIGHT,\n        /* 0x36 */ CUT_TYPE_WOLF_LOCK = 0x36,\n        /* 0x38 */ CUT_TYPE_DASH_UNK_38 = 0x38,\n        /* 0x39 */ CUT_TYPE_WOLF_UNK_39,\n    };\n\n    static u32 setParamData(int, int, int, int);\n    static BOOL checkFishingRodItem(int);\n    static BOOL checkBombItem(int);\n    static BOOL checkBottleItem(int);\n    static BOOL checkDrinkBottleItem(int);\n    static BOOL checkOilBottleItem(int);\n    static BOOL checkOpenBottleItem(int);\n    static BOOL checkBowItem(int);\n    static BOOL checkHookshotItem(int);\n    static BOOL checkTradeItem(int);\n    static BOOL checkDungeonWarpItem(int);\n    static BOOL checkMasterSwordEquip();\n    static BOOL checkWoodShieldEquip();\n    static f32 getAttentionOffsetY();\n    static int checkNowWolfEyeUp();\n    static void forceRestartRoom(int, u32, int);\n    static void setFmChainPos(fopAc_ac_c*, cXyz*, int);\n    static void cancelFmChainGrab();\n    static void setLookPos(cXyz*);\n    static void setPlayerSe(u32);\n    static bool linkGrabSubjectNoDraw(fopAc_ac_c*);\n    static bool wolfGrabSubjectNoDraw(fopAc_ac_c*);\n    static bool checkRoomRestartStart();\n    static u32 checkCarryStartLightBallA();\n    static u32 checkCarryStartLightBallB();\n    f32 getSpinnerRideSpeed() const;\n    bool checkSpinnerReflectEffect();\n    static bool checkBoomerangCharge();\n    int checkBoomerangChargeTime();\n    static daBoomerang_c* getThrowBoomerangActor();\n    static void cancelBoomerangLockActor(fopAc_ac_c*);\n    static void setPlayerDamage(int, int);\n    static void setMidnaMotionNum(int);\n    static void setMidnaFaceNum(int);\n    u32 checkNoResetFlg0(daPy_FLG0) const;\n    u32 checkEquipHeavyBoots() const;\n    u32 checkBoarSingleBattle() const;\n    u32 checkEndResetFlg0(daPy_ERFLG0) const;\n    void onNoResetFlg2(daPy_py_c::daPy_FLG2);\n    void offNoResetFlg0(daPy_py_c::daPy_FLG0);\n    int checkEndResetFlg2(daPy_py_c::daPy_ERFLG2) const;\n    bool getSumouMode() const;\n    int checkNoResetFlg3(daPy_py_c::daPy_FLG3) const;\n    BOOL checkShieldGet();\n    void onNoResetFlg0(daPy_py_c::daPy_FLG0);\n    u32 checkEndResetFlg1(daPy_py_c::daPy_ERFLG1) const;\n    void offNoResetFlg1(daPy_py_c::daPy_FLG1);\n    void offNoResetFlg2(daPy_py_c::daPy_FLG2);\n    u32 checkWolf() const;\n    BOOL checkSwordGet();\n    u32 checkResetFlg0(daPy_py_c::daPy_RFLG0) const;\n    u32 checkNoResetFlg2(daPy_py_c::daPy_FLG2) const;\n    u32 checkMagneBootsOn() const;\n    void changeDemoPos0(cXyz const*);\n    void changeDemoMode(u32, int, int, s16);\n    void changeDemoParam2(s16);\n    void cancelOriginalDemo();\n    void changeOriginalDemo();\n    cXyz getHeadTopPos() const;\n    /* 801829E0 */ void checkThrowDamage() const;\n    /* 80182A10 */ void checkGoronSideMove() const;\n    /* 80182AAC */ void getRightFootPosP();\n    /* 80182AB4 */ void getLeftFootPosP();\n    /* 80182ABC */  // u32 getMidnaActor();\n    /* 80182AC4 */ void checkCopyRodThrowAfter() const;\n    /* 80182AD8 */ void checkRide() const;\n    /* 80182B9C */ void getRightHandPos() const;\n    /* 8015DFD8 */ const cXyz getItemPos() const;\n    /* 8015DFF4 */ const cXyz& getLeftHandPos() const;\n    /* 800977B4 */ bool checkMidnaRide() const;\n\n    /* const cXyz* getItemPos() const {\n        return &mItemPos;\n    }\n    const cXyz* getLeftHandPos() const {\n        return &mLeftHandPos;\n    } */\n\n    virtual cXyz* getMidnaAtnPos() const;\n    virtual void setMidnaMsgNum(fopAc_ac_c*, u16);\n    virtual MtxP getModelMtx();\n    virtual MtxP getInvMtx();\n    virtual cXyz* getShadowTalkAtnPos();\n    virtual f32 getGroundY();\n    virtual MtxP getLeftItemMatrix();\n    virtual MtxP getRightItemMatrix();\n    virtual MtxP getLeftHandMatrix();\n    virtual MtxP getRightHandMatrix();\n    virtual MtxP getLinkBackBone1Matrix();\n    virtual MtxP getWolfMouthMatrix();\n    virtual MtxP getWolfBackbone2Matrix();\n    virtual MtxP getBottleMtx();\n    virtual BOOL checkPlayerGuard() const;\n    virtual u32 checkPlayerFly() const;\n    virtual BOOL checkFrontRoll() const;\n    virtual BOOL checkWolfDash() const;\n    virtual BOOL checkAutoJump() const;\n    virtual bool checkSideStep() const;\n    virtual bool checkWolfTriggerJump() const;\n    virtual BOOL checkGuardBreakMode() const;\n    virtual bool checkLv3Slide() const;\n    virtual bool checkWolfHowlDemoMode() const;\n    virtual bool checkChainBlockPushPull();\n    virtual BOOL checkElecDamage() const;\n    virtual BOOL checkEmptyBottleSwing() const;\n    virtual BOOL checkBottleSwingMode() const;\n    virtual BOOL checkHawkWait() const;\n    virtual BOOL checkGoatThrow() const;\n    virtual BOOL checkGoatThrowAfter() const;\n    virtual BOOL checkWolfTagLockJump() const;\n    virtual BOOL checkWolfTagLockJumpLand() const;\n    virtual BOOL checkWolfRope();\n    virtual BOOL checkWolfRopeHang() const;\n    virtual BOOL checkRollJump() const;\n    virtual BOOL checkGoronRideWait() const;\n    virtual BOOL checkWolfChain() const;\n    virtual BOOL checkWolfWait() const;\n    virtual BOOL checkWolfJumpAttack() const;\n    virtual BOOL checkWolfRSit() const;\n    virtual bool checkBubbleFly() const;\n    virtual BOOL checkBottleDrinkEnd() const;\n    virtual BOOL checkWolfDig() const;\n    virtual BOOL checkCutCharge() const;\n    virtual BOOL checkCutTurnCharge() const;\n    virtual BOOL checkCutLargeJumpCharge() const;\n    virtual bool getBokoFlamePos(cXyz*);\n    virtual BOOL checkComboCutTurn() const;\n    virtual BOOL checkClimbMove() const;\n    virtual BOOL checkGrassWhistle() const;\n    virtual BOOL checkBoarRun() const;\n    virtual bool checkFmChainPut() const;\n    virtual bool checkHorseElecDamage() const;\n    virtual f32 getBaseAnimeFrameRate() const;\n    virtual f32 getBaseAnimeFrame() const;\n    virtual void setAnimeFrame(f32);\n    virtual bool checkWolfLock(fopAc_ac_c*) const;\n    virtual bool cancelWolfLock(fopAc_ac_c*);\n    virtual s32 getAtnActorID() const;\n    virtual s32 getItemID() const;\n    virtual s32 getGrabActorID() const;\n    virtual bool exchangeGrabActor(fopAc_ac_c*);\n    virtual bool setForceGrab(fopAc_ac_c*, int, int);\n    virtual void setForcePutPos(cXyz const&);\n    virtual u32 checkPlayerNoDraw();\n    virtual bool checkRopeTag();\n    virtual void voiceStart(u32);\n    virtual void seStartOnlyReverb(u32);\n    virtual void seStartOnlyReverbLevel(u32);\n    virtual void setOutPower(f32, short, int);\n    virtual void setGrabCollisionOffset(f32, f32, cBgS_PolyInfo*);\n    virtual void onMagneGrab(f32, f32);\n    virtual void onFrollCrashFlg(u8, int);\n    virtual MtxP getModelJointMtx(u16);\n    virtual MtxP getHeadMtx();\n    virtual bool setHookshotCarryOffset(unsigned int, cXyz const*);\n    virtual BOOL checkCutJumpCancelTurn() const;\n    virtual bool checkIronBallReturn() const;\n    virtual bool checkIronBallGroundStop() const;\n    virtual BOOL checkSingleBoarBattleSecondBowReady() const;\n    virtual bool checkPointSubWindowMode() const;\n    virtual void setClothesChange(int);\n    virtual void setPlayerPosAndAngle(cXyz const*, short, int);\n    virtual void setPlayerPosAndAngle(cXyz const*, csXyz const*);\n    virtual void setPlayerPosAndAngle(f32 (*)[4]);\n    virtual bool setThrowDamage(short, f32, f32, int, int, int);\n    virtual bool checkSetNpcTks(cXyz*, int, int);\n    virtual int setRollJump(f32, f32, short);\n    virtual void playerStartCollisionSE(u32, u32);\n    virtual void changeTextureAnime(u16, u16, int);\n    virtual void cancelChangeTextureAnime();\n    virtual void cancelDungeonWarpReadyNeck();\n    virtual void onSceneChangeArea(u8, u8, fopAc_ac_c*);\n    virtual void onSceneChangeAreaJump(u8, u8, fopAc_ac_c*);\n    virtual void onSceneChangeDead(u8, int);\n    virtual u32 checkHorseRide() const;\n    virtual u32 checkBoarRide() const;\n    virtual u32 checkCanoeRide() const;\n    virtual u32 checkBoardRide() const;\n    virtual u32 checkSpinnerRide() const;\n    virtual fopAc_ac_c* getSpinnerActor();\n    virtual BOOL checkHorseRideNotReady() const;\n    virtual bool checkArrowChargeEnd() const;\n    virtual f32 getSearchBallScale() const;\n    virtual s16 checkFastShotTime();\n    virtual bool checkNoEquipItem() const;\n    virtual bool checkFireMaterial() const;\n    virtual bool checkKandelaarSwing(int) const;\n    virtual s16 getBoardCutTurnOffsetAngleY() const;\n    virtual cXyz* getMagneHitPos();\n    virtual cXyz* getMagneBootsTopVec();\n    virtual cXyz* getKandelaarFlamePos();\n    virtual bool checkUseKandelaar(int);\n    virtual void setDkCaught(fopAc_ac_c*);\n    virtual void onPressedDamage(cXyz const&, short);\n    virtual bool checkPriActorOwn(fopAc_ac_c const*) const;\n    virtual bool onWolfEnemyBiteAll(fopAc_ac_c*, daPy_FLG2);\n    virtual bool checkWolfEnemyBiteAllOwn(fopAc_ac_c const*) const;\n    virtual void setWolfEnemyHangBiteAngle(short);\n    virtual void setKandelaarMtx(f32 (*)[4], int, int);\n    virtual bool getStickAngleFromPlayerShape(short*) const;\n    virtual bool checkSpinnerPathMove();\n    virtual bool checkSpinnerTriggerAttack();\n    virtual void onSpinnerPathForceRemove();\n    virtual s16 getIronBallBgHit() const;\n    virtual cXyz* getIronBallCenterPos();\n    virtual bool checkCanoeFishingGetLeft() const;\n    virtual bool checkCanoeFishingGetRight() const;\n    virtual u8 checkBeeChildDrink() const;\n    virtual void skipPortalObjWarp();\n    virtual BOOL checkTreasureRupeeReturn(int) const;\n    virtual void setSumouReady(fopAc_ac_c*);\n    virtual bool checkAcceptDungeonWarpAlink(int);\n    virtual s16 getSumouCounter() const;\n    virtual s16 checkSumouWithstand() const;\n    virtual void cancelGoronThrowEvent();\n    virtual void setSumouGraspCancelCount(int);\n    virtual void setSumouPushBackDirection(short);\n    virtual void setSumouLoseHeadUp();\n    virtual s16 getGiantPuzzleAimAngle() const;\n    virtual void setGoronSideMove(fopAc_ac_c*);\n    virtual void setCargoCarry(fopAc_ac_c*);\n    virtual bool getDpdFarFlg() const;\n    virtual cXyz* getHookshotTopPos();\n    virtual bool checkHookshotReturnMode() const;\n    virtual bool checkHookshotShootReturnMode() const;\n    virtual bool checkOctaIealHang() const;\n    virtual void cancelOctaIealHang();\n    virtual void cancelDragonHangBackJump();\n    virtual void setOctaIealWildHang();\n    virtual bool checkDragonHangRide() const;\n    virtual void changeDragonActor(fopAc_ac_c*);\n    virtual u8 getClothesChangeWaitTimer() const;\n    virtual u8 getShieldChangeWaitTimer() const;\n    virtual u8 getSwordChangeWaitTimer() const;\n    virtual BOOL checkMetamorphose() const;\n    virtual BOOL checkWolfDownAttackPullOut() const;\n    virtual BOOL checkBootsOrArmorHeavy() const;\n    virtual s32 getBottleOpenAppearItem() const;\n    virtual bool checkItemSwordEquip() const;\n    virtual f32 getSinkShapeOffset() const;\n    virtual BOOL checkSinkDead() const;\n    virtual BOOL checkHorseStart();\n    virtual Z2WolfHowlMgr* getWolfHowlMgrP();\n    virtual BOOL checkWolfHowlSuccessAnime() const;\n    virtual BOOL checkCopyRodTopUse();\n    virtual bool checkCopyRodEquip() const;\n    virtual BOOL checkCutJumpMode() const;\n\n    f32 getSpeedF() const { return speedF; }\n\n    bool getSumouCameraMode() const {\n        bool sumouCameraMode = false;\n        if (mSpecialMode != 0 && mSpecialMode < 0x26) {\n            sumouCameraMode = true;\n        }\n        return sumouCameraMode;\n    }\n\n    bool i_getSumouMode() const { return getSumouCameraMode(); }\n    void i_cancelOriginalDemo() {\n        mDemo.setSystemDemoType();\n        mDemo.setDemoMode(1);\n    }\n\n    bool checkStatusWindowDraw() { return i_checkNoResetFlg2(FLG2_STATUS_WINDOW_DRAW); }\n    bool checkCargoCarry() const { return mSpecialMode == SMODE_CARGO_CARRY; }\n    bool getHeavyStateAndBoots() { return i_checkNoResetFlg0(FLG0_HVY_STATE); }\n    bool checkEnemyAttentionLock() const { return i_checkResetFlg0(RFLG0_ENEMY_ATTN_LOCK); }\n    bool checkCanoeSlider() const { return mSpecialMode == 0x2D; }\n    bool checkGoatStopGame() const { return mSpecialMode == 0x2A; }\n    bool i_checkGoronSideMove() const { return mSpecialMode == 0x2B; }\n    u8 getCutType() const { return mCutType; }\n    u16 getSwordAtUpTime() const { return mSwordUpTimer; }\n    bool checkWaterInMove() const { return i_checkNoResetFlg0(FLG0_UNDERWATER); }\n    bool checkSceneChangeAreaStart() const { return i_checkNoResetFlg2(FLG2_SCN_CHG_START); }\n    bool checkFrontRollCrash() const { return i_checkResetFlg0(RFLG0_FRONT_ROLL_CRASH); }\n    bool checkWolfAttackReverse() const { return checkResetFlg1(RFLG1_WOLF_ATTACK_REVERSE); }\n    bool checkFreezeDamage() const { return i_checkNoResetFlg1(FLG1_UNK_40000000); }\n    bool checkWolfTagLockJumpReady() const { return i_checkResetFlg0(RFLG0_UNK_20000); }\n    bool getGrabUpEnd() const { return i_checkResetFlg0(RFLG0_GRAB_UP_END); }\n\n    void onForceAutoJump() { i_onEndResetFlg0(ERFLG0_FORCE_AUTO_JUMP); }\n    void onNotAutoJump() { i_onEndResetFlg0(ERFLG0_NOT_AUTO_JUMP); }\n    void onNotHang() { i_onEndResetFlg0(ERFLG0_NOT_HANG); }\n    void onShieldBackBone() { i_onEndResetFlg1(ERFLG1_GANON_FINISH); }\n    void onWolfEyeKeep() { i_onEndResetFlg1(ERFLG1_WOLF_EYE_KEEP); }\n    void onFogFade() { i_onNoResetFlg2(FLG2_UNK_4000); }\n\n    void offCargoCarry() {\n        if (checkCargoCarry()) {\n            mSpecialMode = 0;\n        }\n    }\n\n    void offGoronSideMove() {\n        if (i_checkGoronSideMove()) {\n            mSpecialMode = 0;\n        }\n    }\n\n    s16 getBodyAngleX() const { return mBodyAngle.x; }\n    s16 getBodyAngleY() const { return mBodyAngle.y; }\n\n    BOOL checkMidnaWarp() const { return 0; }\n\n    // some functions use these function as an inline\n    // is there a better way to handle this?\n    u32 i_checkNoResetFlg0(daPy_FLG0 i_flag) const { return mNoResetFlg0 & i_flag; }\n    u32 i_checkNoResetFlg1(daPy_FLG1 i_flag) const { return mNoResetFlg1 & i_flag; }\n    u32 i_checkNoResetFlg2(daPy_FLG2 i_flag) const { return mNoResetFlg2 & i_flag; }\n    u32 i_checkNoResetFlg3(daPy_FLG3 i_flag) const { return mNoResetFlg3 & i_flag; }\n\n    void i_onNoResetFlg0(int i_flag) { mNoResetFlg0 |= i_flag; }\n    void i_onNoResetFlg1(int i_flag) { mNoResetFlg1 |= i_flag; }\n    void i_onNoResetFlg2(int i_flag) { mNoResetFlg2 |= i_flag; }\n    void i_onNoResetFlg3(int i_flag) { mNoResetFlg3 |= i_flag; }\n\n    void i_offNoResetFlg0(int i_flag) { mNoResetFlg0 &= ~i_flag; }\n    void i_offNoResetFlg1(int i_flag) { mNoResetFlg1 &= ~i_flag; }\n    void i_offNoResetFlg2(int i_flag) { mNoResetFlg2 &= ~i_flag; }\n    void i_offNoResetFlg3(int i_flag) { mNoResetFlg3 &= ~i_flag; }\n\n    void i_offResetFlg0(int flag) { mResetFlg0 &= ~flag; }\n    void i_offResetFlg1(int flag) { mResetFlg1 &= ~flag; }\n    void i_onResetFlg0(int flag) { mResetFlg0 |= flag; }\n    void i_onResetFlg1(int flag) { mResetFlg1 |= flag; }\n\n    void i_onEndResetFlg0(int i_flag) { mEndResetFlg0 |= i_flag; }\n    void i_onEndResetFlg2(int i_flag) { mEndResetFlg2 |= i_flag; }\n    void i_offEndResetFlg2(daPy_ERFLG2 i_flag) { mEndResetFlg2 &= ~i_flag; }\n\n    u32 i_checkResetFlg0(daPy_py_c::daPy_RFLG0 i_flag) const { return mResetFlg0 & i_flag; }\n    u32 checkResetFlg1(daPy_py_c::daPy_RFLG1 i_flag) const { return mResetFlg1 & i_flag; }\n\n    u32 i_checkEndResetFlg0(daPy_py_c::daPy_ERFLG0 i_flag) const { return mEndResetFlg0 & i_flag; }\n    u32 i_checkEndResetFlg1(daPy_py_c::daPy_ERFLG1 i_flag) const { return mEndResetFlg1 & i_flag; }\n    u32 i_checkEndResetFlg2(daPy_py_c::daPy_ERFLG2 i_flag) const { return mEndResetFlg2 & i_flag; }\n\n    void i_onEndResetFlg1(daPy_ERFLG1 i_flag) { mEndResetFlg1 |= i_flag; }\n\n    u32 i_checkWolf() const { return i_checkNoResetFlg1(FLG1_IS_WOLF); }\n    BOOL i_checkEquipHeavyBoots() const { return i_checkNoResetFlg0(FLG0_EQUIP_HVY_BOOTS); }\n    BOOL i_checkMagneBootsOn() const { return i_checkNoResetFlg0(FLG0_MAGNE_BOOTS_ON); }\n    bool i_checkMidnaRide() const { return i_checkNoResetFlg0(FLG0_MIDNA_RIDE); }\n    void i_onPlayerNoDraw() { i_onNoResetFlg0(FLG0_PLAYER_NO_DRAW); }\n    void i_offPlayerNoDraw() { i_offNoResetFlg0(FLG0_PLAYER_NO_DRAW); }\n    void i_onPushPullKeep() { i_onNoResetFlg0(FLG0_PUSH_PULL_KEEP); }\n    void i_offPushPullKeep() { i_offNoResetFlg0(FLG0_PUSH_PULL_KEEP); }\n\n    u32 i_checkBoarSingleBattle() const { return i_checkNoResetFlg2(FLG2_BOAR_SINGLE_BATTLE); }\n\n    void i_changeOriginalDemo() {\n        mDemo.setOriginalDemoType();\n        mDemo.setParam0(0);\n    }\n\n    void i_changeDemoMode(u32 i_demoMode, int i_param0, int i_param1, s16 i_param2) {\n        mDemo.setDemoMode(i_demoMode);\n        mDemo.setParam0(i_param0);\n        mDemo.setParam1(i_param1);\n        mDemo.setParam2(i_param2);\n    }\n\n    void i_changeDemoPos0(const cXyz* i_posP) { mDemo.setPos0(i_posP); }\n\n    void changeDemoMoveAngle(s16 i_angle) { mDemo.setMoveAngle(i_angle); }\n\n    inline static u32 i_getLastSceneMode();\n    inline static u32 getLastSceneMode();\n    inline static bool checkWoodSwordEquip();\n    inline static bool checkLightMasterSwordEquip();\n    inline BOOL i_checkSwordGet();\n    inline bool i_checkShieldGet() const;\n    inline static BOOL checkNowWolf();\n    inline static BOOL i_checkNowWolf() { return dComIfGp_getLinkPlayer()->i_checkWolf(); }\n    inline bool checkZoraWearFlg() const;\n    inline bool checkMagicArmorWearFlg() const;\n    inline static BOOL i_checkFirstMidnaDemo() { return i_dComIfGs_isEventBit(0xc10); }\n    static int checkNowWolfPowerUp() { return checkNowWolfEyeUp(); }\n\n    static daMidna_c* getMidnaActor() { return m_midnaActor; }\n\n    // not sure how to define this properly\n    // static void onWolfEnemyCatch(fopAc_ac_c* i_actorP) { onWolfEnemyBiteAll(i_actorP,8);}\n\n    bool checkWolfEnemyCatchOwn(fopAc_ac_c* i_actorP) { return checkWolfEnemyBiteAllOwn(i_actorP); }\n    bool checkWolfEnemyLeftThrow() const { return i_checkNoResetFlg2(FLG2_WOLF_ENEMY_LEFT_THROW); }\n\n    static daMidna_c* m_midnaActor;\n};\n\nint daPy_addCalcShort(s16* param_0, s16 param_1, s16 param_2, s16 param_3, s16 param_4);\n\n#endif /* D_A_D_A_PLAYER_H */\n/* end \"d/a/d_a_player.h\" */\n/* \"src/d/d_attention.cpp\" line 9 \"d/com/d_com_inf_game.h\" */\n#ifndef D_COM_D_COM_INF_GAME_H\n#define D_COM_D_COM_INF_GAME_H\n\n/* \"include/d/com/d_com_inf_game.h\" line 3 \"d/bg/d_bg_s.h\" */\n#ifndef D_BG_D_BG_S_H\n#define D_BG_D_BG_S_H\n\n/* \"include/d/bg/d_bg_s.h\" line 3 \"d/bg/d_bg_w_base.h\" */\n#ifndef D_BG_D_BG_W_BASE_H\n#define D_BG_D_BG_W_BASE_H\n\n/* \"include/d/bg/d_bg_w_base.h\" line 3 \"SSystem/SComponent/c_bg_s_poly_info.h\" */\n#ifndef C_BG_S_POLY_INFO_H\n#define C_BG_S_POLY_INFO_H\n\n/* \"include/SSystem/SComponent/c_bg_s_poly_info.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass cBgS_PolyInfo {\nprivate:\n    /* 0x00 */ u16 mPolyIndex;\n    /* 0x02 */ u16 mBgIndex;\n    /* 0x04 */ void* unk_0x04;\n    /* 0x08 */ unsigned int mActorId;\n\npublic:\n    cBgS_PolyInfo();\n    bool ChkSetInfo() const;\n    void ClearPi();\n    void SetPolyInfo(const cBgS_PolyInfo&);\n    void SetActorInfo(int, void*, unsigned int);\n    bool ChkSafe(const void*, unsigned int) const;\n    void SetPolyIndex(int);\n    bool ChkBgIndex() const;\n\n    virtual ~cBgS_PolyInfo();\n\n    u16 GetPolyIndex() const { return mPolyIndex; }\n    u16 GetBgIndex() const { return mBgIndex; }\n};  // Size: 0x10\n\n#endif /* C_BG_S_POLY_INFO_H */\n/* end \"SSystem/SComponent/c_bg_s_poly_info.h\" */\n/* \"include/d/bg/d_bg_w_base.h\" line 4 \"SSystem/SComponent/c_bg_w.h\" */\n#ifndef C_BG_W_H\n#define C_BG_W_H\n\n/* \"include/SSystem/SComponent/c_bg_w.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass cBgW_BgId {\nprivate:\n    /* 0x0 */ u16 m_id;\n    /* 0x4 vtable */\n\npublic:\n    /* 802681C8 */ void Release();\n    /* 802681D4 */ bool ChkUsed() const;\n    /* 802681C0 */ void Regist(int);\n\n    /* 8007E5F8 */ virtual ~cBgW_BgId() {}\n\n    cBgW_BgId() { Ct(); }\n    void Ct() { m_id = 0x100; }\n\n    u16 GetId() const { return m_id; }\n};\n\nbool cBgW_CheckBGround(float a1);\nbool cBgW_CheckBRoof(float a1);\nbool cBgW_CheckBWall(float a1);\n\n#endif /* C_BG_W_H */\n/* end \"SSystem/SComponent/c_bg_w.h\" */\n/* \"include/d/bg/d_bg_w_base.h\" line 5 \"SSystem/SComponent/c_m3d_g_pla.h\" */\n/* end \"SSystem/SComponent/c_m3d_g_pla.h\" */\n\nclass cBgS_GndChk;\nclass cBgS_LinChk;\nclass cBgS_ShdwDraw;\nclass dBgS_Acch;\nstruct dBgS_CaptPoly;\nclass dBgS_RoofChk;\nclass dBgS_SphChk;\nclass dBgS_SplGrpChk;\nclass fopAc_ac_c;\n\nclass dBgW_Base : public cBgW_BgId {\npublic:\n    enum PushPullLabel {\n        PUSHPULL_LABEL1 = 1,\n    };\n\n    enum PRIORITY {\n        PRIORITY_0,\n    };\n\n    typedef bool (*PushPull_CallBack)(fopAc_ac_c*, fopAc_ac_c*, s16,\n                                     dBgW_Base::PushPullLabel);\n\n    /* 8007E5A8 */ dBgW_Base();\n    /* 8007E69C */ void ClrDBgWBase();\n    /* 8007E6E0 */ void CalcDiffShapeAngleY(s16);\n\n    /* 8007E640 */ virtual ~dBgW_Base();\n    /* 8007E6D0 */ virtual bool ChkMemoryError();\n    virtual bool ChkNotReady() const = 0;\n    virtual bool ChkLock() const = 0;\n    virtual bool ChkMoveBg() const = 0;\n    virtual u32 ChkMoveFlag() const = 0;\n    virtual cM3dGPla GetTriPla(cBgS_PolyInfo const&) const = 0;\n    virtual bool GetTriPnt(cBgS_PolyInfo const&, cXyz*, cXyz*, cXyz*) const = 0;\n    virtual cM3dGAab* GetBnd() const = 0;\n    virtual u32 GetGrpInf(cBgS_PolyInfo const&) const = 0;\n    virtual void OffMoveFlag() = 0;\n    virtual void GetTopUnder(f32*, f32*) const = 0;\n    /* 80074AB4 */ virtual void SetOldShapeAngleY(s16);\n    virtual bool LineCheck(cBgS_LinChk*) = 0;\n    virtual bool GroundCross(cBgS_GndChk*) = 0;\n    virtual void ShdwDraw(cBgS_ShdwDraw*) = 0;\n    virtual void CaptPoly(dBgS_CaptPoly&) = 0;\n    virtual bool WallCorrect(dBgS_Acch*) = 0;\n    virtual void WallCorrectSort(dBgS_Acch*) = 0;\n    virtual bool RoofChk(dBgS_RoofChk*) = 0;\n    virtual bool SplGrpChk(dBgS_SplGrpChk*) = 0;\n    virtual bool SphChk(dBgS_SphChk*, void*) = 0;\n    virtual s32 GetGrpRoomIndex(cBgS_PolyInfo const&) const = 0;\n    virtual s32 GetExitId(cBgS_PolyInfo const&) = 0;\n    virtual s32 GetPolyColor(cBgS_PolyInfo const&) = 0;\n    virtual BOOL GetHorseNoEntry(cBgS_PolyInfo const&) = 0;\n    virtual int GetSpecialCode(cBgS_PolyInfo const&) = 0;\n    virtual int GetSpecialCode(int) = 0;\n    virtual int GetMagnetCode(cBgS_PolyInfo const&) = 0;\n    virtual u32 GetPolyObjThrough(int) = 0;\n    virtual u32 GetPolyCamThrough(int) = 0;\n    virtual u32 GetPolyLinkThrough(int) = 0;\n    virtual u32 GetPolyArrowThrough(int) = 0;\n    virtual u32 GetPolyHSStick(int) = 0;\n    virtual u32 GetPolyBoomerangThrough(int) = 0;\n    virtual u32 GetPolyRopeThrough(int) = 0;\n    virtual u32 GetPolyBombThrough(int) = 0;\n    virtual bool GetShdwThrough(int) = 0;\n    virtual u32 GetUnderwaterRoofCode(int) = 0;\n    virtual int GetMonkeyBarsCode(cBgS_PolyInfo const&) = 0;\n    virtual int GetLinkNo(cBgS_PolyInfo const&) = 0;\n    virtual s32 GetWallCode(cBgS_PolyInfo const&) = 0;\n    virtual int GetPolyAtt0(cBgS_PolyInfo const&) = 0;\n    virtual int GetPolyAtt1(cBgS_PolyInfo const&) = 0;\n    virtual int GetGroundCode(cBgS_PolyInfo const&) = 0;\n    virtual u32 GetIronBallThrough(int) = 0;\n    virtual u32 GetAttackThrough(int) = 0;\n    virtual s32 GetCamMoveBG(cBgS_PolyInfo const&) = 0;\n    virtual s32 GetRoomCamId(cBgS_PolyInfo const&) = 0;\n    virtual s32 GetRoomPathId(cBgS_PolyInfo const&) = 0;\n    virtual s32 GetRoomPathPntNo(cBgS_PolyInfo const&) = 0;\n    virtual u8 GetPolyGrpRoomInfId(cBgS_PolyInfo const&) = 0;\n    virtual u8 GetGrpSoundId(cBgS_PolyInfo const&) = 0;\n    virtual void CrrPos(cBgS_PolyInfo const&, void*, bool, cXyz*, csXyz*, csXyz*) = 0;\n    virtual void TransPos(cBgS_PolyInfo const&, void*, bool, cXyz*, csXyz*, csXyz*) = 0;\n    virtual void MatrixCrrPos(cBgS_PolyInfo const&, void*, bool, cXyz*, csXyz*, csXyz*) = 0;\n    /* 8007E6D8 */ virtual void CallRideCallBack(fopAc_ac_c*, fopAc_ac_c*);\n    /* 8007E6DC */ virtual void CallArrowStickCallBack(fopAc_ac_c*, fopAc_ac_c*, cXyz&);\n\n    PushPull_CallBack GetPushPullCallback() const { return m_pushPull_Callback; }\n    s16 GetDiffShapeAngleY() { return m_diff_ShapeAngleY; }\n    int GetRoomId() { return m_roomId; }\n    bool chkStickWall() { return field_0xb & 1; }\n    bool chkStickRoof() { return field_0xb & 2; }\n    bool ChkPushPullOk() const { return m_pushPull_Ok; }\n    void SetPushPullCallback(PushPull_CallBack i_callBack) { m_pushPull_Callback = i_callBack; }\n    void SetRoomId(int id) { m_roomId = id; }\n    bool ChkPriority(int prio) { return m_priority == prio; }\n    void SetPriority(PRIORITY priority) { m_priority = priority; }\n    void onStickWall() { field_0xb |= 1; }\n    void onStickRoof() { field_0xb |= 2; }\n\nprivate:\n    /* 0x08 */ u8 m_priority;\n    /* 0x09 */ u8 m_roomId;\n    /* 0x0A */ u8 field_0xa;\n    /* 0x0B */ u8 field_0xb;\n    /* 0x0C */ s16 m_old_ShapeAngleY;\n    /* 0x0E */ s16 m_diff_ShapeAngleY;\n    /* 0x10 */ PushPull_CallBack m_pushPull_Callback;\n    /* 0x14 */ bool m_pushPull_Ok;\n};  // Size: 0x18\n\n#endif /* D_BG_D_BG_W_BASE_H */\n/* end \"d/bg/d_bg_w_base.h\" */\n/* \"include/d/bg/d_bg_s.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n/* \"include/d/bg/d_bg_s.h\" line 5 \"global.h\" */\n/* end \"global.h\" */\n\nclass dBgW;\nclass fopAc_ac_c;\n\nclass cBgS_ChkElm {\npublic:\n    /* 0x00 */ dBgW_Base* m_bgw_base_ptr;\n    /* 0x04 */ bool m_used;\n    /* 0x08 */ u32 m_actor_id;\n    /* 0x0C */ fopAc_ac_c* m_actor_ptr;\n    /* 0x10 vtable */\n\npublic:\n    cBgS_ChkElm() { this->Init(); }\n    void Init();\n    void Release();\n\n    virtual ~cBgS_ChkElm() {}\n    virtual void Regist2(dBgW_Base*, unsigned int, void*);\n\n    bool ChkUsed() const { return m_used; }\n};  // Size: 0x14\n\nSTATIC_ASSERT(sizeof(cBgS_ChkElm) == 0x14);\n\nclass cBgS {\npublic:\n    /* 0x0000 */ cBgS_ChkElm m_chk_element[256];\n    /* 0x1400 vtable */\n\npublic:\n    cBgS() {}\n    bool Regist(dBgW_Base*, unsigned int, void*);\n    int Release(dBgW_Base*);\n    bool LineCross(cBgS_LinChk*);\n    f32 GroundCross(cBgS_GndChk*);\n    static void* ConvDzb(void*);\n    fopAc_ac_c* GetActorPointer(int) const;\n    dBgW_Base* GetBgWBasePointer(cBgS_PolyInfo const&) const;\n    bool ChkPolySafe(cBgS_PolyInfo const&);\n    s32 GetGrpRoomId(cBgS_PolyInfo const&) const;\n    bool GetTriPla(cBgS_PolyInfo const&, cM3dGPla*) const;\n    bool GetTriPnt(cBgS_PolyInfo const&, cXyz*, cXyz*, cXyz*) const;\n    void ShdwDraw(cBgS_ShdwDraw*);\n    u32 GetGrpInf(cBgS_PolyInfo const&) const;\n\n    virtual ~cBgS() {}\n    virtual void Ct();\n    virtual void Dt();\n\n    fopAc_ac_c* GetActorPointer(cBgS_PolyInfo const& info) const {\n        return GetActorPointer(info.GetBgIndex());\n    }\n};  // Size: 0x1404\n\nclass dBgS_Acch;\n\nu8 dKy_pol_sound_get(cBgS_PolyInfo const* param_0);\n\nclass dBgS : public cBgS {\npublic:\n    dBgS() {}\n    ~dBgS() {}\n    void Ct();\n    void Dt();\n    void ClrMoveFlag();\n    void Move();\n    bool Regist(dBgW_Base*, fopAc_ac_c*);\n    bool ChkMoveBG(cBgS_PolyInfo const&);\n    bool ChkMoveBG_NoDABg(cBgS_PolyInfo const&);\n    s32 GetExitId(cBgS_PolyInfo const&);\n    s32 GetPolyColor(cBgS_PolyInfo const&);\n    BOOL GetHorseNoEntry(cBgS_PolyInfo const&);\n    int GetSpecialCode(cBgS_PolyInfo const&);\n    int GetMagnetCode(cBgS_PolyInfo const&);\n    int GetMonkeyBarsCode(cBgS_PolyInfo const&);\n    u32 GetUnderwaterRoofCode(cBgS_PolyInfo const&);\n    s32 GetWallCode(cBgS_PolyInfo const&);\n    int GetPolyAtt0(cBgS_PolyInfo const&);\n    int GetPolyAtt1(cBgS_PolyInfo const&);\n    int GetGroundCode(cBgS_PolyInfo const&);\n    s32 GetCamMoveBG(cBgS_PolyInfo const&);\n    s32 GetRoomCamId(cBgS_PolyInfo const&);\n    s32 GetRoomPathId(cBgS_PolyInfo const&);\n    s32 GetRoomPathPntNo(cBgS_PolyInfo const&);\n    u8 GetGrpSoundId(cBgS_PolyInfo const&);\n    u32 ChkGrpInf(cBgS_PolyInfo const&, u32);\n    s32 GetRoomId(cBgS_PolyInfo const&);\n    bool GetPolyAttackThrough(cBgS_PolyInfo const&);\n    u32 ChkPolyHSStick(cBgS_PolyInfo const&);\n    void WallCorrect(dBgS_Acch*);\n    void WallCorrectSort(dBgS_Acch*);\n    f32 RoofChk(dBgS_RoofChk*);\n    bool SplGrpChk(dBgS_SplGrpChk*);\n    bool SphChk(dBgS_SphChk*, void*);\n    void MoveBgCrrPos(cBgS_PolyInfo const& i_poly, bool param_1, cXyz* i_pos, csXyz* i_angle,\n                      csXyz* i_shapeAngle, bool param_5, bool param_6);\n    void MoveBgTransPos(cBgS_PolyInfo const& i_poly, bool param_1, cXyz* i_pos, csXyz* i_angle,\n                        csXyz* i_shapeAngle);\n    void MoveBgMatrixCrrPos(cBgS_PolyInfo const&, bool, cXyz*, csXyz*, csXyz*);\n    void RideCallBack(cBgS_PolyInfo const&, fopAc_ac_c*);\n    void ArrowStickCallBack(cBgS_PolyInfo const&, fopAc_ac_c*, cXyz&);\n    bool PushPullCallBack(cBgS_PolyInfo const&, fopAc_ac_c*, s16, dBgW_Base::PushPullLabel);\n\n    bool WaterChk(dBgS_SplGrpChk* chk) { return SplGrpChk(chk); }\n    u32 GetMtrlSndId(cBgS_PolyInfo* param_0) { return dKy_pol_sound_get(param_0); }\n};  // Size: 0x1404\n\nbool dBgS_CheckBGroundPoly(cBgS_PolyInfo const&);\nbool dBgS_CheckBRoofPoly(cBgS_PolyInfo const&);\nbool dBgS_CheckBWallPoly(cBgS_PolyInfo const&);\nvoid dBgS_MoveBGProc_Typical(dBgW* param_0, void* param_1, cBgS_PolyInfo const& param_2,\n                             bool param_3, cXyz* param_4, csXyz* param_5, csXyz* param_6);\nvoid dBgS_MoveBGProc_TypicalRotY(dBgW* param_0, void* param_1, cBgS_PolyInfo const& param_2,\n                                 bool param_3, cXyz* param_4, csXyz* param_5, csXyz* param_6);\nvoid dBgS_MoveBGProc_Trans(dBgW* i_bgw, void* i_actor_ptr, cBgS_PolyInfo const& i_poly,\n                           bool param_3, cXyz* i_pos, csXyz* i_angle, csXyz* i_shapeAngle);\nf32 dBgS_GetNY(cBgS_PolyInfo const& poly);\n\n#endif /* D_BG_D_BG_S_H */\n/* end \"d/bg/d_bg_s.h\" */\n/* \"include/d/com/d_com_inf_game.h\" line 4 \"d/cc/d_cc_s.h\" */\n#ifndef D_CC_D_CC_S_H\n#define D_CC_D_CC_S_H\n\n/* \"include/d/cc/d_cc_s.h\" line 3 \"SSystem/SComponent/c_cc_s.h\" */\n#ifndef C_CC_S_H\n#define C_CC_S_H\n\n/* \"include/SSystem/SComponent/c_cc_s.h\" line 3 \"SSystem/SComponent/c_cc_d.h\" */\n#ifndef C_CC_D_H\n#define C_CC_D_H\n\n/* \"include/SSystem/SComponent/c_cc_d.h\" line 3 \"SSystem/SComponent/c_m3d_g_aab.h\" */\n#ifndef C_M3D_G_AAB_H\n#define C_M3D_G_AAB_H\n\n/* \"include/SSystem/SComponent/c_m3d_g_aab.h\" line 3 \"SSystem/SComponent/c_xyz.h\" */\n/* end \"SSystem/SComponent/c_xyz.h\" */\n/* \"include/SSystem/SComponent/c_m3d_g_aab.h\" line 4 \"SSystem/SComponent/c_m3d_g_lin.h\" */\n#ifndef C_M3D_G_LIN_H\n#define C_M3D_G_LIN_H\n\n/* \"include/SSystem/SComponent/c_m3d_g_lin.h\" line 3 \"SSystem/SComponent/c_xyz.h\" */\n/* end \"SSystem/SComponent/c_xyz.h\" */\n/* \"include/SSystem/SComponent/c_m3d_g_lin.h\" line 4 \"global.h\" */\n/* end \"global.h\" */\n\n// Line\nclass cM3dGLin {\n    // private:\npublic:\n    /* 0x00 */ cXyz mStart;\n    /* 0x0C */ cXyz mEnd;\n    /* 0x18 vtable */\n\n    cM3dGLin() {}\n    cM3dGLin(const cXyz&, const cXyz&);\n    virtual ~cM3dGLin() {}\n    void SetStartEnd(const cXyz&, const cXyz&);\n    void SetStartEnd(const Vec&, const Vec&);\n    void CalcPos(Vec*, f32) const;\n    void CalcVec(Vec* pOut) const { VECSubtract(&this->mEnd, &this->mStart, pOut); }\n    void SetEnd(const cXyz&);\n\n    void set(const Vec& i_start, const Vec& i_end) { SetStartEnd(i_start, i_end); }\n    const cXyz& GetStartP(void) const { return mStart; }\n    cXyz& GetStartP(void) { return mStart; }\n    const cXyz& GetEndP(void) const { return mEnd; }\n    cXyz& GetEndP(void) { return mEnd; }\n    cXyz& GetEnd() { return mEnd; }\n};  // Size = 0x1C\n\nSTATIC_ASSERT(0x1C == sizeof(cM3dGLin));\n\n#endif /* C_M3D_G_LIN_H */\n/* end \"SSystem/SComponent/c_m3d_g_lin.h\" */\n/* \"include/SSystem/SComponent/c_m3d_g_aab.h\" line 5 \"SSystem/SComponent/c_m3d.h\" */\n/* end \"SSystem/SComponent/c_m3d.h\" */\n/* \"include/SSystem/SComponent/c_m3d_g_aab.h\" line 6 \"global.h\" */\n/* end \"global.h\" */\n\n// Axis aligned bounding box\nclass cM3dGAab {\nprivate:\npublic:\n    /* 0x00 */ cXyz mMin;\n    /* 0x0C */ cXyz mMax;\n    /* 0x18 vtable */\n\n    virtual ~cM3dGAab() {}\n    void Set(const cXyz*, const cXyz*);\n    bool CrossY(const cXyz*) const;\n    bool UnderPlaneYUnder(f32) const;\n    bool TopPlaneYUnder(f32) const;\n    void ClearForMinMax(void);\n    void SetMinMax(const cXyz&);\n    void SetMinMax(const cM3dGAab&);\n    void SetMin(const cXyz&);\n    void SetMax(const cXyz&);\n    void CalcCenter(cXyz*) const;\n    void PlusR(f32);\n    const cXyz* GetMaxP(void) const { return &mMax; }\n    const cXyz* GetMinP(void) const { return &mMin; }\n    const f32 GetMaxX(void) const { return mMax.x; }\n    const f32 GetMaxY(void) const { return mMax.y; }\n    const f32 GetMaxZ(void) const { return mMax.z; }\n    const f32 GetMinX(void) const { return mMin.x; }\n    const f32 GetMinY(void) const { return mMin.y; }\n    const f32 GetMinZ(void) const { return mMin.z; }\n    bool Cross(const cM3dGLin *param_1) {\n        return cM3d_Cross_MinMaxBoxLine(GetMinP(), GetMaxP(), (Vec*)&param_1->GetStartP(), (Vec*)&param_1->GetEndP());\n    }\n    bool Cross(const cM3dGAab *param_1) {\n        return cM3d_Cross_AabAab(this, param_1);\n    }\n    bool Cross(const cM3dGCyl *param_1) {\n        return cM3d_Cross_AabCyl(this, param_1);\n    }\n    bool Cross(const cM3dGSph *param_1) {\n        return cM3d_Cross_AabSph(this, param_1);\n    }\n};  // Size = 0x1C\n\nSTATIC_ASSERT(0x1C == sizeof(cM3dGAab));\n\n#endif /* C_M3D_G_AAB_H */\n/* end \"SSystem/SComponent/c_m3d_g_aab.h\" */\n/* \"include/SSystem/SComponent/c_cc_d.h\" line 4 \"SSystem/SComponent/c_m3d_g_cps.h\" */\n#ifndef C_M3D_G_CPS_H\n#define C_M3D_G_CPS_H\n\n/* \"include/SSystem/SComponent/c_m3d_g_cps.h\" line 3 \"SSystem/SComponent/c_m3d.h\" */\n/* end \"SSystem/SComponent/c_m3d.h\" */\n/* \"include/SSystem/SComponent/c_m3d_g_cps.h\" line 4 \"SSystem/SComponent/c_m3d_g_lin.h\" */\n/* end \"SSystem/SComponent/c_m3d_g_lin.h\" */\n/* \"include/SSystem/SComponent/c_m3d_g_cps.h\" line 5 \"global.h\" */\n/* end \"global.h\" */\n\nstruct cM3dGCpsS {\n    /* 0x00 */ Vec mStart;\n    /* 0x0C */ Vec mEnd;\n    /* 0x18 */ f32 mRadius;\n};  // Size: 0x1C\n\nclass cM3dGCps : public cM3dGLin {\npublic:\n    /* 0x1C */ f32 mRadius;\n\n    cM3dGCps(void);\n    virtual ~cM3dGCps(void);\n    void Set(const cXyz&, const cXyz&, f32);\n    void Set(const cM3dGCpsS&);\n    void SetCps(const cM3dGCps&);\n    bool Cross(cM3dGCps const* other, cXyz* xyz) const {\n        return cM3d_Cross_CpsCps(*this, *other, xyz);\n    }\n    bool Cross(cM3dGCyl const* cyl, cXyz* xyz) const { return cM3d_Cross_CpsCyl(*this, *cyl, xyz); }\n    bool Cross(cM3dGSph const* sph, cXyz* xyz) const { return cM3d_Cross_CpsSph(*this, *sph, xyz); }\n    void SetR(f32 r) { mRadius = r; }\n\n};  // Size = 0x20\n\nSTATIC_ASSERT(0x20 == sizeof(cM3dGCps));\n\n#endif /* C_M3D_G_CPS_H */\n/* end \"SSystem/SComponent/c_m3d_g_cps.h\" */\n/* \"include/SSystem/SComponent/c_cc_d.h\" line 5 \"SSystem/SComponent/c_m3d_g_cyl.h\" */\n#ifndef C_M3D_G_CYL_H\n#define C_M3D_G_CYL_H\n\n/* \"include/SSystem/SComponent/c_m3d_g_cyl.h\" line 3 \"SSystem/SComponent/c_m3d.h\" */\n/* end \"SSystem/SComponent/c_m3d.h\" */\n/* \"include/SSystem/SComponent/c_m3d_g_cyl.h\" line 4 \"SSystem/SComponent/c_xyz.h\" */\n/* end \"SSystem/SComponent/c_xyz.h\" */\n/* \"include/SSystem/SComponent/c_m3d_g_cyl.h\" line 5 \"global.h\" */\n/* end \"global.h\" */\n\n// Cylinder\nstruct cM3dGCylS {\n    /* 0x00 */ Vec mCenter;\n    /* 0x0C */ f32 mRadius;\n    /* 0x10 */ f32 mHeight;\n};  // Size = 0x14\nclass cM3dGSph;\n\nclass cM3dGCyl {\npublic:\n    /* 0x00 */ cXyz mCenter;\n    /* 0x0C */ f32 mRadius;\n    /* 0x10 */ f32 mHeight;\n    /* 0x14 vtable */\n    cM3dGCyl() {}\n    cM3dGCyl(const cXyz*, f32, f32);\n    virtual ~cM3dGCyl() {}\n    void Set(const cM3dGCylS&);\n    void Set(const cXyz&, f32, f32);\n    void SetC(const cXyz& pos);\n    void SetH(f32 h);\n    void SetR(f32 r);\n    bool cross(const cM3dGSph*, cXyz*) const;\n    bool cross(const cM3dGCyl*, cXyz*) const;\n    void calcMinMax(cXyz*, cXyz*);\n    const cXyz* GetCP(void) const { return &mCenter; }\n    f32 GetR(void) const { return mRadius; }\n    f32* GetRP() { return &mRadius; }\n    f32 GetH(void) const { return mHeight; }\n    cXyz& GetC() { return mCenter; }\n\n    bool Cross(const cM3dGCps* cps, cXyz* xyz) const { return cM3d_Cross_CpsCyl(*cps, *this, xyz); }\n    bool Cross(const cM3dGTri& tri, cXyz* xyz) const { return cM3d_Cross_CylTri(this, &tri, xyz); }\n    bool Cross(const cM3dGCyl* other, f32* f) const { return cM3d_Cross_CylCyl(this, other, f); }\n    bool Cross(const cM3dGSph* sph, f32* f) const { return cM3d_Cross_CylSph(this, sph, f); }\n};  // Size = 0x18\n\nSTATIC_ASSERT(0x18 == sizeof(cM3dGCyl));\n\n#endif /* C_M3D_G_CYL_H */\n/* end \"SSystem/SComponent/c_m3d_g_cyl.h\" */\n/* \"include/SSystem/SComponent/c_cc_d.h\" line 6 \"SSystem/SComponent/c_m3d_g_sph.h\" */\n#ifndef C_M3D_G_SPH_H_\n#define C_M3D_G_SPH_H_\n\n/* \"include/SSystem/SComponent/c_m3d_g_sph.h\" line 3 \"SSystem/SComponent/c_m3d.h\" */\n/* end \"SSystem/SComponent/c_m3d.h\" */\n/* \"include/SSystem/SComponent/c_m3d_g_sph.h\" line 4 \"SSystem/SComponent/c_xyz.h\" */\n/* end \"SSystem/SComponent/c_xyz.h\" */\n/* \"include/SSystem/SComponent/c_m3d_g_sph.h\" line 5 \"global.h\" */\n/* end \"global.h\" */\n\nclass cM3dGCyl;\n\nstruct cM3dGSphS {\n    /* 0x0 */ Vec mCenter;\n    /* 0xC */ f32 mRadius;\n};  // Size: 0x10\n\nclass cM3dGSph {\nprivate:\npublic:\n    /* 0x00 */ cXyz mCenter;\n    /* 0x0C */ f32 mRadius;\n    /* 0x10 vtable */\n\n    cM3dGSph() {}\n    virtual ~cM3dGSph() {}\n    void SetC(const cXyz&);\n    void Set(const cXyz&, f32);\n    void Set(const cM3dGSphS&);\n    void SetR(f32);\n    bool cross(const cM3dGSph*, cXyz*) const;\n    bool cross(const cM3dGCyl*, cXyz*) const;\n    inline bool cross(const cM3dGTri *param_1) const {\n        return cM3d_Cross_SphTri(this, param_1);\n    }\n    void GetMinMaxCube(cXyz&, cXyz&) const;\n    const cXyz& GetC(void) const { return mCenter; }\n    const cXyz* GetCP() const { return &mCenter; }\n    const f32 GetR(void) const { return mRadius; }\n    f32 GetCX(void) const { return mCenter.x; }\n    f32 GetCY(void) const { return mCenter.y; }\n    f32 GetCZ(void) const { return mCenter.z; }\n\n    bool Cross(const cM3dGSph* other, f32* f) const { return cM3d_Cross_SphSph(this, other, f); }\n    bool Cross(const cM3dGCps* cps, cXyz* xyz) const { return cM3d_Cross_CpsSph(*cps, *this, xyz); }\n    bool Cross(const cM3dGCyl* cyl, f32* f) const { return cM3d_Cross_CylSph(cyl, this, f); }\n};  // Size = 0x14\n\nSTATIC_ASSERT(0x14 == sizeof(cM3dGSph));\n\n// additional symbols needed for cM3dGSph\nextern \"C\" {\nvoid Set__8cM3dGSphFRC4cXyzf(void);\n}\n\n#endif/* end \"SSystem/SComponent/c_m3d_g_sph.h\" */\n/* \"include/SSystem/SComponent/c_cc_d.h\" line 7 \"SSystem/SComponent/c_m3d_g_tri.h\" */\n#ifndef C_M3D_G_TRI_H_\n#define C_M3D_G_TRI_H_\n\n/* \"include/SSystem/SComponent/c_m3d_g_tri.h\" line 3 \"SSystem/SComponent/c_m3d_g_pla.h\" */\n/* end \"SSystem/SComponent/c_m3d_g_pla.h\" */\n/* \"include/SSystem/SComponent/c_m3d_g_tri.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass cM3dGCyl;\n\nstruct cM3dGTriS {\n    Vec a;\n    Vec b;\n    Vec c;\n};\n\nclass cM3dGTri : public cM3dGPla {\n    // private:\npublic:\n    // cM3dGPla mPlane;\n    Vec mA;\n    Vec mB;\n    Vec mC;\n\n    cM3dGTri() {}\n    virtual ~cM3dGTri() {}\n    bool cross(const cM3dGCyl*, Vec*) const;\n    void setPos(const Vec*, const Vec*, const Vec*);\n    void setBg(const Vec*, const Vec*, const Vec*, const cM3dGPla*);\n    void set(const Vec*, const Vec*, const Vec*, const Vec*);\n    bool Cross(cM3dGCps const& cps, cXyz* xyz) const { return cM3d_Cross_CpsTri(cps, *this, xyz); }\n    bool Cross(cM3dGCyl const& cyl, cXyz* xyz) const { return this->cross(&cyl, xyz); }\n    bool Cross(cM3dGSph const& sph, cXyz* xyz) const { return cM3d_Cross_SphTri(&sph, this, xyz); }\n    bool Cross(cM3dGTri const& other, cXyz* xyz) const {\n        return cM3d_Cross_TriTri(*this, other, xyz);\n    }\n    bool cross(const cM3dGLin* lin, Vec* xyz, bool param_2, bool param_3) const {\n        return cM3d_Cross_LinTri(lin, this, xyz, param_2, param_3);\n    }\n};\n\n#endif/* end \"SSystem/SComponent/c_m3d_g_tri.h\" */\n\ntypedef struct _GXColor GXColor;\nclass fopAc_ac_c;\n\nenum CcG_Tg_HitMark {\n    CcG_Tg_UNK_MARK_6 = 6,\n    CcG_Tg_UNK_MARK_8 = 8,\n};\n\nclass cCcD_PntAttr;\nclass cCcD_CpsAttr;\nclass cCcD_TriAttr;\nclass cCcD_AabAttr;\nclass cCcD_CylAttr;\nclass cCcD_SphAttr;\n\nenum cCcD_ObjAtType {\n    /* 0x00000002 */ AT_TYPE_NORMAL_SWORD = (1 << 1),  // wooden or ordon\n    /* 0x00000004 */ AT_TYPE_HORSE = (1 << 2),\n    /* 0x00000008 */ AT_TYPE_THROW_OBJ = (1 << 3),\n    /* 0x00000010 */ AT_TYPE_SHIELD_ATTACK = (1 << 4),\n    /* 0x00000020 */ AT_TYPE_BOMB = (1 << 5),\n    /* 0x00000040 */ AT_TYPE_40 = (1 << 6),\n    /* 0x00000080 */ AT_TYPE_SLINGSHOT = (1 << 7),\n    /* 0x00000200 */ AT_TYPE_LANTERN_SWING = (1 << 9),\n    /* 0x00000400 */ AT_TYPE_CSTATUE_SWING = (1 << 10),\n    /* 0x00000800 */ AT_TYPE_800 = (1 << 11),\n    /* 0x00001000 */ AT_TYPE_1000 = (1 << 12),\n    /* 0x00002000 */ AT_TYPE_ARROW = (1 << 13),\n    /* 0x00004000 */ AT_TYPE_HOOKSHOT = (1 << 14),\n    /* 0x00010000 */ AT_TYPE_BOOMERANG = (1 << 16),\n    /* 0x00040000 */ AT_TYPE_40000 = (1 << 18),\n    /* 0x00080000 */ AT_TYPE_SPINNER = (1 << 19),\n    /* 0x00100000 */ AT_TYPE_CSTATUE_BOSS_SWING = (1 << 20),\n    /* 0x00200000 */ AT_TYPE_HEAVY_BOOTS = (1 << 21),\n    /* 0x00400000 */ AT_TYPE_IRON_BALL = (1 << 22),\n    /* 0x00800000 */ AT_TYPE_COPY_ROD = (1 << 23),\n    /* 0x01000000 */ AT_TYPE_1000000 = (1 << 24),\n    /* 0x04000000 */ AT_TYPE_MASTER_SWORD = (1 << 26),\n    /* 0x08000000 */ AT_TYPE_MIDNA_LOCK = (1 << 27),\n    /* 0x10000000 */ AT_TYPE_10000000 = (1 << 28),\n    /* 0x40000000 */ AT_TYPE_WOLF_CUT_TURN = (1 << 30),\n    /* 0x80000000 */ AT_TYPE_WOLF_ATTACK = (1 << 31),\n    /* 0xD8000000 */ AT_TYPE_UNK = 0xD8000000\n};\n\nclass cCcD_ShapeAttr {\npublic:\n    /* 0x00 */ cM3dGAab mAab;\n    /* 0x1C vtable */\n\n    struct Shape {\n        /* 80167BBC */ ~Shape();\n\n        /* 0x00 */ int _0;\n        /* 0x04 */ f32 _4;\n        /* 0x08 */ f32 _8;\n        /* 0x0C */ f32 _C;\n        /* 0x10 */ f32 _10;\n        /* 0x14 */ f32 _14;\n    };\n    cCcD_ShapeAttr() {}\n    /* 8008556C vt[2] */ virtual ~cCcD_ShapeAttr() {}\n    /* 802649D8 vt[3] */ virtual bool CrossAtTg(cCcD_ShapeAttr const&, cXyz*) const {\n        return false;\n    }\n    /*          vt[4] */ virtual bool CrossAtTg(cCcD_PntAttr const&, cXyz*) const = 0;\n    /*          vt[5] */ virtual bool CrossAtTg(cCcD_CpsAttr const&, cXyz*) const = 0;\n    /*          vt[6] */ virtual bool CrossAtTg(cCcD_TriAttr const&, cXyz*) const = 0;\n    /*          vt[7] */ virtual bool CrossAtTg(cCcD_AabAttr const&, cXyz*) const = 0;\n    /*          vt[8] */ virtual bool CrossAtTg(cCcD_CylAttr const&, cXyz*) const = 0;\n    /*          vt[9] */ virtual bool CrossAtTg(cCcD_SphAttr const&, cXyz*) const = 0;\n    /* 802649E0 vt[10]*/ virtual bool CrossCo(cCcD_ShapeAttr const&, f32*) const { return false; }\n    /*          vt[11]*/ virtual bool CrossCo(cCcD_PntAttr const&, f32*) const = 0;\n    /*          vt[12]*/ virtual bool CrossCo(cCcD_CpsAttr const&, f32*) const = 0;\n    /*          vt[13]*/ virtual bool CrossCo(cCcD_TriAttr const&, f32*) const = 0;\n    /*          vt[14]*/ virtual bool CrossCo(cCcD_AabAttr const&, f32*) const = 0;\n    /*          vt[15]*/ virtual bool CrossCo(cCcD_CylAttr const&, f32*) const = 0;\n    /*          vt[16]*/ virtual bool CrossCo(cCcD_SphAttr const&, f32*) const = 0;\n    /* 80084E38 vt[17]*/ virtual const cXyz& GetCoCP() const { return m_virtual_center; }\n    /* 80084E2C vt[18]*/ virtual cXyz& GetCoCP() { return m_virtual_center; }\n    /*          vt[19]*/ virtual void CalcAabBox() = 0;\n    /*          vt[20]*/ virtual bool GetNVec(cXyz const&, cXyz*) const = 0;\n    /* 80263A64 vt[21]*/ virtual void getShapeAccess(cCcD_ShapeAttr::Shape*) const;\n\n    cM3dGAab& GetWorkAab() { return mAab; }\n    cM3dGAab const& GetWorkAab() const { return mAab; }\n\n    static cXyz m_virtual_center;\n};\n\nSTATIC_ASSERT(0x20 == sizeof(cCcD_ShapeAttr));\n\nstruct cCcD_SrcTriAttr {\n    cM3dGTriS mTri;\n};\n\nclass cCcD_TriAttr : public cCcD_ShapeAttr, public cM3dGTri {\npublic:\n    /* 80263C04 */ virtual void CalcAabBox();\n    /* 80263C9C */ virtual bool GetNVec(cXyz const&, cXyz*) const;\n    /* 80263A88 */ virtual bool CrossAtTg(cCcD_CpsAttr const&, cXyz*) const;\n    /* 80263BCC */ virtual bool CrossAtTg(cCcD_TriAttr const&, cXyz*) const;\n    /* 80263B90 */ virtual bool CrossAtTg(cCcD_SphAttr const&, cXyz*) const;\n    /* 80084E54 */ virtual bool CrossAtTg(cCcD_ShapeAttr const& shape, cXyz* xyz) const {\n        return shape.CrossAtTg(*this, xyz);\n    }\n    /* 80084E4C */ virtual bool CrossAtTg(cCcD_PntAttr const&, cXyz*) const { return false; }\n    /* 80084E44 */ virtual bool CrossAtTg(cCcD_AabAttr const&, cXyz*) const { return false; }\n    /* 80263B58 */ virtual bool CrossAtTg(cCcD_CylAttr const&, cXyz*) const;\n    /* 80084EBC */ virtual bool CrossCo(cCcD_ShapeAttr const& shape, f32* f) const {\n        return shape.CrossCo(*this, f);\n    }\n    /* 80084EB4 */ virtual bool CrossCo(cCcD_PntAttr const&, f32*) const { return false; }\n    /* 80084EAC */ virtual bool CrossCo(cCcD_CpsAttr const&, f32*) const { return false; }\n    /* 80084EA4 */ virtual bool CrossCo(cCcD_TriAttr const&, f32*) const { return false; }\n    /* 80084E9C */ virtual bool CrossCo(cCcD_AabAttr const&, f32*) const { return false; }\n    /* 80084E94 */ virtual bool CrossCo(cCcD_CylAttr const&, f32*) const { return false; }\n    /* 80084E8C */ virtual bool CrossCo(cCcD_SphAttr const&, f32*) const { return false; }\n    /* 80264938 */ virtual ~cCcD_TriAttr() {}\n    cCcD_TriAttr() {}\n};\n\nstruct cCcD_SrcCpsAttr {\n    cM3dGCpsS mCps;\n};\n\nclass cCcD_CpsAttr : public cCcD_ShapeAttr, public cM3dGCps {\npublic:\n    cCcD_CpsAttr() {}\n    void Set(const cCcD_SrcCpsAttr& pSrc) { cM3dGCps::Set(pSrc.mCps); }\n    void Set(const cXyz& pStart, const cXyz& pEnd, float radius) {\n        cM3dGCps::Set(pStart, pEnd, radius);\n    }\n\n    /* 80085450 */ virtual ~cCcD_CpsAttr() {}\n    /* 80263DC0 */ virtual bool CrossAtTg(cCcD_SphAttr const&, cXyz*) const;\n    /* 80263E04 */ virtual bool CrossAtTg(cCcD_TriAttr const&, cXyz*) const;\n    /* 80084FE4 */ virtual bool CrossAtTg(cCcD_ShapeAttr const& shape, cXyz* xyz) const {\n        return shape.CrossAtTg(*this, xyz);\n    }\n    /* 80084FDC */ virtual bool CrossAtTg(cCcD_PntAttr const&, cXyz*) const { return false; }\n    /* 80084FD4 */ virtual bool CrossAtTg(cCcD_AabAttr const&, cXyz*) const { return false; }\n    /* 80263D38 */ virtual bool CrossAtTg(cCcD_CpsAttr const&, cXyz*) const;\n    /* 80263D7C */ virtual bool CrossAtTg(cCcD_CylAttr const&, cXyz*) const;\n    /* 80263F24 */ virtual bool CrossCo(cCcD_CylAttr const&, f32*) const;\n    /* 80263ED4 */ virtual bool CrossCo(cCcD_CpsAttr const&, f32*) const;\n    /* 80263F74 */ virtual bool CrossCo(cCcD_SphAttr const&, f32*) const;\n    /* 80085034 */ virtual bool CrossCo(cCcD_ShapeAttr const& shape, f32* f) const {\n        return shape.CrossCo(*this, f);\n    }\n    /* 8008502C */ virtual bool CrossCo(cCcD_PntAttr const&, f32*) const { return false; }\n    /* 80085024 */ virtual bool CrossCo(cCcD_TriAttr const&, f32*) const { return false; }\n    /* 8008501C */ virtual bool CrossCo(cCcD_AabAttr const&, f32*) const { return false; }\n    /* 80263FC4 */ virtual void CalcAabBox();\n    /* 80264014 */ virtual bool GetNVec(cXyz const&, cXyz*) const;\n};\n\nSTATIC_ASSERT(0x40 == sizeof(cCcD_CpsAttr));\n\nstruct cCcD_SrcSphAttr {\n    cM3dGSphS mSph;\n};\n\nclass cCcD_SphAttr : public cCcD_ShapeAttr, public cM3dGSph {\npublic:\n    cCcD_SphAttr() {}\n    void Set(const cCcD_SrcSphAttr& src) { cM3dGSph::Set(src.mSph); }\n\n    /* 8008721C */ virtual ~cCcD_SphAttr() {}\n    /* 80084B44 */ virtual const cXyz& GetCoCP() const { return mCenter; }\n    /* 80037A54 */ virtual cXyz& GetCoCP() { return mCenter; }\n    /* 80084B5C */ virtual bool CrossAtTg(cCcD_ShapeAttr const& shape, cXyz* xyz) const {\n        return shape.CrossAtTg(*this, xyz);\n    }\n    /* 80084B54 */ virtual bool CrossAtTg(cCcD_PntAttr const&, cXyz*) const { return false; }\n    /* 80084B4C */ virtual bool CrossAtTg(cCcD_AabAttr const&, cXyz*) const { return false; }\n    /* 80084BAC */ virtual bool CrossCo(cCcD_ShapeAttr const& shape, f32* f) const {\n        return shape.CrossCo(*this, f);\n    }\n    /* 80084BA4 */ virtual bool CrossCo(cCcD_PntAttr const&, f32*) const { return false; }\n    /* 80084B9C */ virtual bool CrossCo(cCcD_TriAttr const&, f32*) const { return false; }\n    /* 80084B94 */ virtual bool CrossCo(cCcD_AabAttr const&, f32*) const { return false; }\n    /* 80264538 */ virtual bool CrossAtTg(cCcD_CylAttr const&, cXyz*) const;\n    /* 802645C0 */ virtual bool CrossAtTg(cCcD_TriAttr const&, cXyz*) const;\n    /* 802644EC */ virtual bool CrossAtTg(cCcD_CpsAttr const&, cXyz*) const;\n    /* 8026457C */ virtual bool CrossAtTg(cCcD_SphAttr const&, cXyz*) const;\n    /* 80264688 */ virtual bool CrossCo(cCcD_CpsAttr const&, f32*) const;\n    /* 80264644 */ virtual bool CrossCo(cCcD_SphAttr const&, f32*) const;\n    /* 802645F8 */ virtual bool CrossCo(cCcD_CylAttr const&, f32*) const;\n    /* 802646E0 */ virtual void CalcAabBox();\n    /* 8026476C */ virtual bool GetNVec(cXyz const&, cXyz*) const;\n    /* 80264808 */ virtual void getShapeAccess(cCcD_ShapeAttr::Shape*) const;\n\n};  // Size = 0x34\n\nSTATIC_ASSERT(0x34 == sizeof(cCcD_SphAttr));\n\nclass cCcD_CylAttr : public cCcD_ShapeAttr, public cM3dGCyl {\npublic:\n    cCcD_CylAttr() {}\n    /* 800854E0 */ virtual ~cCcD_CylAttr() {}\n    /* 80084CC0 */ virtual const cXyz& GetCoCP() const { return mCenter; }\n    /* 8026420C */ virtual bool CrossAtTg(cCcD_SphAttr const&, cXyz*) const;\n    /* 802641C8 */ virtual bool CrossAtTg(cCcD_CylAttr const&, cXyz*) const;\n    /* 80264250 */ virtual bool CrossAtTg(cCcD_TriAttr const&, cXyz*) const;\n    /* 80084CD8 */ virtual bool CrossAtTg(cCcD_ShapeAttr const& shape, cXyz* xyz) const {\n        return shape.CrossAtTg(*this, xyz);\n    }\n    /* 80084CD0 */ virtual bool CrossAtTg(cCcD_PntAttr const&, cXyz*) const { return false; }\n    /* 80084CC8 */ virtual bool CrossAtTg(cCcD_AabAttr const&, cXyz*) const { return false; }\n    /* 8026417C */ virtual bool CrossAtTg(cCcD_CpsAttr const&, cXyz*) const;\n    /* 80264288 */ virtual bool CrossCo(cCcD_CylAttr const&, f32*) const;\n    /* 80264310 */ virtual bool CrossCo(cCcD_CpsAttr const&, f32*) const;\n    /* 80084D28 */ virtual bool CrossCo(cCcD_ShapeAttr const& shape, f32* f) const {\n        return shape.CrossCo(*this, f);\n    }\n    /* 80084D20 */ virtual bool CrossCo(cCcD_PntAttr const&, f32*) const { return false; }\n    /* 80084D18 */ virtual bool CrossCo(cCcD_TriAttr const&, f32*) const { return false; }\n    /* 80084D10 */ virtual bool CrossCo(cCcD_AabAttr const&, f32*) const { return false; }\n    /* 802642CC */ virtual bool CrossCo(cCcD_SphAttr const&, f32*) const;\n    /* 80037A4C */ virtual cXyz& GetCoCP() { return mCenter; }\n    /* 80264368 */ virtual void CalcAabBox();\n    /* 802643D0 */ virtual bool GetNVec(cXyz const&, cXyz*) const;\n    /* 802644B8 */ virtual void getShapeAccess(cCcD_ShapeAttr::Shape*) const;\n\n};  // Size = 0x38\n\nSTATIC_ASSERT(0x38 == sizeof(cCcD_CylAttr));\n\nclass cCcD_DivideInfo {\nprivate:\n    /* 0x00 */ u32 mXDivInfo;\n    /* 0x04 */ u32 mYDivInfo;\n    /* 0x08 */ u32 mZDivInfo;\n    /* 0x0C vtable */\npublic:\n    cCcD_DivideInfo() {}\n    virtual ~cCcD_DivideInfo() {}\n    /* 80263358 */ void Set(u32, u32, u32);\n    /* 80263368 */ bool Chk(cCcD_DivideInfo const&) const;\n};  // Size = 0x10\n\nSTATIC_ASSERT(0x10 == sizeof(cCcD_DivideInfo));\n\nclass cCcD_DivideArea : public cM3dGAab {\nprivate:\n    /* 0x1C */ bool mXDiffIsZero;\n    /* 0x20 */ f32 mScaledXDiff;\n    /* 0x24 */ f32 mInvScaledXDiff;\n    /* 0x28 */ bool mYDiffIsZero;\n    /* 0x2C */ f32 mScaledYDiff;\n    /* 0x30 */ f32 mInvScaledYDiff;\n    /* 0x34 */ bool mZDiffIsZero;\n    /* 0x38 */ f32 mScaledZDiff;\n    /* 0x3C */ f32 mInvScaledZDiff;\n\npublic:\n    cCcD_DivideArea() {}\n    virtual ~cCcD_DivideArea() {}\n    /* 802633A8 */ void SetArea(cM3dGAab const&);\n    /* 802634D4 */ void CalcDivideInfo(cCcD_DivideInfo*, cM3dGAab const&, u32);\n    /* 802636A0 */ void CalcDivideInfoOverArea(cCcD_DivideInfo*, cM3dGAab const&);\n};  // Size = 0x40\n\nSTATIC_ASSERT(0x40 == sizeof(cCcD_DivideArea));\n\nstruct cCcD_SrcObjCommonBase {\n    /* 0x0 */ s32 mSPrm;\n};\n\nstruct cCcD_SrcObjTg {\n    /* 0x0 */ s32 mType;\n    /* 0x4 */ cCcD_SrcObjCommonBase mBase;\n};  // Size: 0x8\n\nstruct cCcD_SrcObjAt {\n    /* 0x0 */ s32 mType;\n    /* 0x4 */ u8 mAtp;\n    /* 0x8 */ cCcD_SrcObjCommonBase mBase;\n};  // Size: 0xC\n\nstruct cCcD_SrcObjCo {\n    /* 0x0 */ cCcD_SrcObjCommonBase mBase;\n};  // Size: 0x4\n\nstruct cCcD_SrcObjHitInf {\n    /* 0x00 */ cCcD_SrcObjAt mObjAt;\n    /* 0x0C */ cCcD_SrcObjTg mObjTg;\n    /* 0x14 */ cCcD_SrcObjCo mObjCo;\n};  // Size: 0x18\n\nstruct cCcD_SrcObj {\n    /* 0x0 */ int mFlags;\n    /* 0x4 */ cCcD_SrcObjHitInf mSrcObjHitInf;\n};  // Size: 0x1C\n\nclass cCcD_GStts {\npublic:\n    /* 800837B0 */ virtual ~cCcD_GStts() {}\n\nprivate:\n    /* 0x00 vtable */\n};  // Size = 0x4\n\nclass cCcD_Stts {\nprivate:\n    /* 0x00 */ cXyz mXyz;\n    /* 0x0C */ fopAc_ac_c* mActor;\n    /* 0x10 */ int mApid;\n    /* 0x14 */ u8 mWeight;\n    /* 0x15 */ u8 field_0x15;\n    /* 0x16 */ u8 mTg;\n\npublic:\n    cCcD_Stts() {}\n    /* 801410A4 vt[3] */ virtual ~cCcD_Stts() {}\n    /* 80263894 vt[4] */ virtual const cCcD_GStts* GetGStts() const;\n    /* 8026389C vt[5] */ virtual cCcD_GStts* GetGStts();\n    /* 802638A4 */ void Init(int, int, void*, unsigned int);\n    /* 80263904 vt[6] */ virtual void Ct();\n    /* 80263934 */ void PlusCcMove(f32, f32, f32);\n    /* 8026395C */ void ClrCcMove();\n    /* 80263970 */ void PlusDmg(int);\n    /* 80263984 */ f32 GetWeightF() const;\n    /* 802649E8 vt[7] */ virtual void ClrAt() {}\n    /* 802649EC vt[8] */ virtual void ClrTg() { mTg = 0; }\n\n    u8 GetWeightUc() const { return mWeight; }\n    void SetWeight(u8 weight) { mWeight = weight; }\n    fopAc_ac_c* GetAc() { return mActor; }\n    fopAc_ac_c* GetActor() const { return mActor; }\n    void SetActor(void* ac) { mActor = (fopAc_ac_c*)ac; }\n    cXyz* GetCCMoveP() { return &mXyz; }\n    unsigned int GetApid() const { return mApid; }\n};  // Size = 0x1C\n\nSTATIC_ASSERT(0x1C == sizeof(cCcD_Stts));\n\nclass cCcD_Obj;  // placeholder\n\nclass cCcD_ObjCommonBase {\nprotected:\n    /* 0x00 */ u32 mSPrm;\n    /* 0x04 */ u32 mRPrm;\n    /* 0x08 */ cCcD_Obj* mHitObj;\n    /* 0x0C vtable */\npublic:\n    enum CoSPrm_e {\n        CO_SPRM_SET = 1,\n        CO_SPRM_NO_CRR = 0x100,\n        CO_SPRM_NO_CO_HIT_INF_SET = 0x200,\n        CO_SPRM_SAME_ACTOR_HIT = 0x400,\n    };\n\n    cCcD_ObjCommonBase() { ct(); }\n    /* 8008409C */ virtual ~cCcD_ObjCommonBase() {}\n    /* 802639B0 */ void ct();\n    void SetSPrm(u32 sprm) { mSPrm = sprm; }\n    s32 getSPrm() const { return mSPrm; }\n    void setRPrm(s32 rprm) { mRPrm = rprm; }\n    s32 getRPrm() const { return mRPrm; }\n    cCcD_Obj* GetHitObj() { return mHitObj; }\n    u32 MskSPrm(u32 mask) const { return mSPrm & mask; }\n    u32 MskRPrm(u32 mask) { return mRPrm & mask; }\n    void OnSPrmBit(u32 flag) { mSPrm |= flag; }\n    void OffSPrmBit(u32 flag) { mSPrm &= ~flag; }\n\n    void Set(cCcD_SrcObjCommonBase const& src) { mSPrm = src.mSPrm; }\n};\n\nSTATIC_ASSERT(0x10 == sizeof(cCcD_ObjCommonBase));\n\nclass cCcD_ObjAt : public cCcD_ObjCommonBase {\npublic:\n    cCcD_ObjAt() { mType = 0; }\n    /* 80084040 */ virtual ~cCcD_ObjAt() {}\n    /* 8026483C */ void SetHit(cCcD_Obj*);\n    /* 8026484C */ void Set(cCcD_SrcObjAt const&);\n    /* 80264868 */ void ClrHit();\n    int GetType() const { return mType; }\n    u32 GetGrp() const { return MskSPrm(0x1E); }\n    bool ChkSet() const { return MskSPrm(1); }\n    u8 GetAtp() const { return mAtp; }\n    u32 MskType(u32 msk) const { return mType & msk; }\n    void SetType(u32 type) { mType = type; }\n    void SetAtp(int atp) { mAtp = atp; }\n    void ClrSet() { OffSPrmBit(1); }\n    u32 ChkHit() { return MskRPrm(1); }\n\nprotected:\n    /* 0x10 */ int mType;\n    /* 0x14 */ u8 mAtp;\n};\n\nSTATIC_ASSERT(0x18 == sizeof(cCcD_ObjAt));\n\nclass cCcD_ObjTg : public cCcD_ObjCommonBase {\npublic:\n    cCcD_ObjTg() { ct(); }\n    /* 80083FE4 */ virtual ~cCcD_ObjTg() {}\n    /* 80264880 */ void Set(cCcD_SrcObjTg const&);\n    /* 80264894 */ void SetGrp(u32);\n    /* 802648B0 */ void ClrHit();\n    /* 802648C8 */ void SetHit(cCcD_Obj*);\n    int GetType() const { return mType; }\n    void SetType(u32 type) { mType = type; }\n    u32 GetGrp() const { return MskSPrm(0x1E); }\n    bool ChkSet() const { return MskSPrm(1); }\n    void ClrSet() { OffSPrmBit(1); }\n    u32 ChkHit() { return MskRPrm(1); }\n\nprivate:\n    /* 0x10 */ int mType;\n};\n\nSTATIC_ASSERT(0x14 == sizeof(cCcD_ObjTg));\n\nclass cCcD_ObjCo : public cCcD_ObjCommonBase {\npublic:\n    /* 80083F88 */ virtual ~cCcD_ObjCo() {}\n    /* 802648D8 */ void SetHit(cCcD_Obj*);\n    /* 802648E8 */ void ClrHit();\n    /* 80264900 */ void SetIGrp(u32);\n    /* 8026491C */ void SetVsGrp(u32);\n    u32 GetGrp() const { return MskSPrm(0x1E); }\n    bool ChkSet() const { return MskSPrm(1); }\n    u32 GetVsGrp() const { return MskSPrm(0x70); }\n    u32 GetIGrp() const { return MskSPrm(0xE); }\n    u32 ChkNoCrr() const { return MskSPrm(0x100); }\n    u32 ChkSph3DCrr() const { return MskSPrm(0x80); }\n    void ClrSet() { OffSPrmBit(1); }\n    u32 ChkHit() { return MskRPrm(1); }\n\n    void Set(cCcD_SrcObjCo const& src) { cCcD_ObjCommonBase::Set(src.mBase); }\n};\n\nSTATIC_ASSERT(0x10 == sizeof(cCcD_ObjCo));\n\nclass cCcD_ObjHitInf {\nprotected:\n    /* 0x000 */ cCcD_ObjAt mObjAt;\n    /* 0x018 */ cCcD_ObjTg mObjTg;\n    /* 0x02C */ cCcD_ObjCo mObjCo;\n    /* 0x03C vtable */\npublic:\n    /* 80083EC8 */ virtual ~cCcD_ObjHitInf() {}\n    /* 802639C4 */ void Set(cCcD_SrcObjHitInf const&);\n    cCcD_ObjAt& GetObjAt() { return mObjAt; }\n    cCcD_ObjTg& GetObjTg() { return mObjTg; }\n    cCcD_ObjCo& GetObjCo() { return mObjCo; }\n    u32 GetTgGrp() const { return mObjTg.GetGrp(); }\n    u32 GetAtGrp() const { return mObjAt.GetGrp(); }\n    u32 GetCoGrp() const { return mObjCo.GetGrp(); }\n    int GetTgType() const { return mObjTg.GetType(); }\n    u32 GetAtType() const { return mObjAt.GetType(); }\n    bool ChkTgSet() const { return mObjTg.ChkSet(); }\n    bool ChkAtSet() const { return mObjAt.ChkSet(); }\n    bool ChkCoSet() const { return mObjCo.ChkSet(); }\n    u32 ChkCoSameActorHit() const { return mObjCo.MskSPrm(0x400); }\n    u32 GetCoVsGrp() const { return mObjCo.GetVsGrp(); }\n    u32 GetCoIGrp() const { return mObjCo.GetIGrp(); }\n    u8 GetAtAtp() const { return mObjAt.GetAtp(); }\n    u32 ChkAtNoTgHitInfSet() const { return mObjAt.MskSPrm(0x20); }\n    u32 ChkTgNoAtHitInfSet() const { return mObjTg.MskSPrm(0x20); }\n    u32 ChkCoNoCoHitInfSet() const { return mObjCo.MskSPrm(0x200); }\n    bool ChkTgNoSlingHitInfSet() const { return mObjTg.MskSPrm(0x40); }\n    void SetAtHit(cCcD_Obj* obj) { mObjAt.SetHit(obj); }\n    void SetTgHit(cCcD_Obj* obj) { mObjTg.SetHit(obj); }\n    void SetCoHit(cCcD_Obj* obj) { mObjCo.SetHit(obj); }\n    bool ChkAtType(u32 type) const { return mObjAt.MskType(type); }\n    u32 ChkCoNoCrr() const { return mObjCo.ChkNoCrr(); }\n    u32 ChkCoSph3DCrr() const { return mObjCo.ChkSph3DCrr(); }\n    void OnAtSPrmBit(u32 flag) { mObjAt.OnSPrmBit(flag); }\n    void OffAtSPrmBit(u32 flag) { mObjAt.OffSPrmBit(flag); }\n    void OffTgSPrmBit(u32 flag) { mObjTg.OffSPrmBit(flag); }\n    void OffCoSPrmBit(u32 flag) { mObjCo.OffSPrmBit(flag); }\n    void SetAtType(u32 type) { mObjAt.SetType(type); }\n    void OnAtSetBit() { mObjAt.OnSPrmBit(1); }\n    u32 MskTgSPrm(u32 mask) const { return mObjTg.MskSPrm(mask); }\n    void SetAtAtp(int atp) { mObjAt.SetAtp(atp); }\n    void OffCoSetBit() { mObjCo.ClrSet(); }\n    void SetTgType(u32 type) { mObjTg.SetType(type); }\n    void OnTgSPrmBit(u32 flag) { mObjTg.OnSPrmBit(flag); }\n    void OffAtSetBit() { mObjAt.ClrSet(); }\n    void OnTgSetBit() { mObjTg.OnSPrmBit(1); }\n    void OffTgSetBit() { mObjTg.ClrSet(); }\n    void OnCoSetBit() { mObjCo.OnSPrmBit(1); }\n    void OffAtVsPlayerBit() { mObjAt.OffSPrmBit(0xC); }\n    void OnAtVsPlayerBit() { mObjAt.OnSPrmBit(0xC); }\n    void OnCoSPrmBit(u32 flag) { mObjCo.OnSPrmBit(flag); }\n    void SetAtSprm(u32 prm) { mObjAt.SetSPrm(prm); }\n    void SetTgSPrm(u32 prm) { mObjTg.SetSPrm(prm); }\n    void SetCoSPrm(u32 prm) { mObjCo.SetSPrm(prm); }\n    void ClrAtHit() { mObjAt.ClrHit(); }\n    void ClrTgHit() { mObjTg.ClrHit(); }\n    void ClrCoHit() { mObjCo.ClrHit(); }\n    u32 ChkAtHit() { return mObjAt.ChkHit(); }\n    u32 ChkTgHit() { return mObjTg.ChkHit(); }\n    u32 ChkCoHit() { return mObjCo.ChkHit(); }\n    cCcD_Obj* GetAtHitObj() { return mObjAt.GetHitObj(); }\n    cCcD_Obj* GetTgHitObj() { return mObjTg.GetHitObj(); }\n    cCcD_Obj* GetCoHitObj() { return mObjCo.GetHitObj(); }\n\n};  // Size = 0x40\n\nSTATIC_ASSERT(0x40 == sizeof(cCcD_ObjHitInf));\n\nclass cCcD_GObjInf;\n\nclass cCcD_Obj : public cCcD_ObjHitInf {\npublic:\n    cCcD_Obj() { ct(); }\n    /* 80083DE0 */ virtual ~cCcD_Obj() {}\n    /* 800851A4 */ virtual cCcD_GObjInf const* GetGObjInf() const { return NULL; }\n    /* 800847C8 */ virtual cCcD_GObjInf* GetGObjInf() { return NULL; }\n    /* 80084BE8 */ virtual cCcD_ShapeAttr const* GetShapeAttr() const { return NULL; }\n    /* 80085130 */ virtual cCcD_ShapeAttr* GetShapeAttr() { return NULL; }\n    /* 80084BF0 */ virtual void Draw(_GXColor const&) {}\n    /* 80263A10 */ void ct();\n    /* 80263A1C */ void Set(cCcD_SrcObj const&);\n    fopAc_ac_c* GetAc();\n\n    cCcD_Stts* GetStts() { return mStts; }\n    void SetStts(cCcD_Stts* stts) { mStts = stts; }\n    cCcD_DivideInfo& GetDivideInfo() { return mDivideInfo; }\n    cCcD_DivideInfo* GetPDivideInfo() { return &mDivideInfo; }\n    int ChkBsRevHit() const { return mFlags & 2; }\n\nprivate:\n    /* 0x040 */ int mFlags;\n    /* 0x044 */ cCcD_Stts* mStts;\n    /* 0x048 */ cCcD_DivideInfo mDivideInfo;\n};  // Size = 0x58\n\nSTATIC_ASSERT(0x58 == sizeof(cCcD_Obj));\n\nclass cCcD_GObjInf : public cCcD_Obj {\npublic:\n    cCcD_GObjInf() {}\n    /* 80083CE8 */ virtual ~cCcD_GObjInf() {}\n    /* 80085138 */ virtual void ClrAtHit() { mObjAt.ClrHit(); }\n    /* 80085158 */ virtual void ClrTgHit() { mObjTg.ClrHit(); }\n    /* 8008517C */ virtual void ClrCoHit() { mObjCo.ClrHit(); }\n    /* 80084BE4 */ virtual cCcD_GObjInf const* GetGObjInf() const { return this; }\n    /* 800851A0 */ virtual cCcD_GObjInf* GetGObjInf() { return this; }\n};\n\nSTATIC_ASSERT(0x58 == sizeof(cCcD_GObjInf));\n\n#endif /* C_CC_D_H */\n/* end \"SSystem/SComponent/c_cc_d.h\" */\n/* \"include/SSystem/SComponent/c_cc_s.h\" line 4 \"global.h\" */\n/* end \"global.h\" */\n\nenum WeightType {\n    WeightType_0 = 0,\n    WeightType_1 = 1,\n    WeightType_2 = 2,\n};\n\nclass cCcS {\npublic:\n    /* 0x0000 */ cCcD_Obj* mpObjAt[0x100];\n    /* 0x0400 */ cCcD_Obj* mpObjTg[0x300];\n    /* 0x1000 */ cCcD_Obj* mpObjCo[0x100];\n    /* 0x1400 */ cCcD_Obj* mpObj[0x500];\n    /* 0x2800 */ u16 mObjAtCount;\n    /* 0x2802 */ u16 mObjTgCount;\n    /* 0x2804 */ u16 mObjCoCount;\n    /* 0x2806 */ u16 mObjCount;\n    /* 0x2808 */ cCcD_DivideArea mDivideArea;\n    /* 0x2848 vtable */\n\n    /* 80264A6C */ cCcS();\n    /* 80264A94 */ void Ct();\n    /* 80264B60 */ void Dt();\n    /* 80264B80 */ WeightType GetWt(u8) const;\n    /* 80264BA8 */ void Set(cCcD_Obj*);\n    /* 80264C5C */ void ClrCoHitInf();\n    /* 80264CF0 */ void ClrTgHitInf();\n    /* 80264D90 */ void ClrAtHitInf();\n    /* 80264E2C */ bool ChkNoHitAtTg(cCcD_Obj*, cCcD_Obj*);\n    /* 80264F40 */ void ChkAtTg();\n    /* 8026515C */ bool ChkNoHitCo(cCcD_Obj*, cCcD_Obj*);\n    /* 80265230 */ void ChkCo();\n    /* 802653A0 vt[2] */ virtual void CalcTgPlusDmg(cCcD_Obj*, cCcD_Obj*, cCcD_Stts*, cCcD_Stts*);\n    /* 802653C8 */ void SetAtTgCommonHitInf(cCcD_Obj*, cCcD_Obj*, cXyz*);\n    /* 802655E4 */ void SetCoCommonHitInf(cCcD_Obj*, cXyz*, cCcD_Obj*, cXyz*, f32);\n    /* 80265750 vt[3]*/ virtual void SetPosCorrect(cCcD_Obj*, cXyz*, cCcD_Obj*, cXyz*, f32);\n    /* 80265BB4 */ void CalcArea();\n    /* 80265CCC */ void Move();\n    /* 80265D30 */ void DrawClear();\n    /* 80265DF8 vt[4] */ virtual void SetCoGObjInf(bool, bool, cCcD_GObjInf*, cCcD_GObjInf*,\n                                                   cCcD_Stts*, cCcD_Stts*, cCcD_GStts*,\n                                                   cCcD_GStts*);\n    /* 80265DFC vt[5] */ virtual void SetAtTgGObjInf(bool, bool, cCcD_Obj*, cCcD_Obj*,\n                                                     cCcD_GObjInf*, cCcD_GObjInf*, cCcD_Stts*,\n                                                     cCcD_Stts*, cCcD_GStts*, cCcD_GStts*, cXyz*);\n    /* 80265E00 vt[6] */ virtual bool ChkNoHitGAtTg(cCcD_GObjInf const*, cCcD_GObjInf const*,\n                                                    cCcD_GStts*, cCcD_GStts*);\n    /* 80265E08 vt[7] */ virtual bool ChkAtTgHitAfterCross(bool, bool, cCcD_GObjInf const*,\n                                                           cCcD_GObjInf const*, cCcD_Stts*,\n                                                           cCcD_Stts*, cCcD_GStts*, cCcD_GStts*);\n    /* 80265E10 vt[8] */ virtual bool ChkNoHitGCo(cCcD_Obj*, cCcD_Obj*);\n    /* 80030BDC vt[9] */ virtual ~cCcS() {}\n    /* 80265E18 vt[10] */ virtual void MoveAfterCheck();\n    /* 80265DF4 vt[11] */ virtual void SetCoGCorrectProc(cCcD_Obj*, cCcD_Obj*);\n};  // Size = 0x284C\n\nSTATIC_ASSERT(sizeof(cCcS) == 0x284C);\n\n#endif /* C_CC_S_H */\n/* end \"SSystem/SComponent/c_cc_s.h\" */\n/* \"include/d/cc/d_cc_s.h\" line 4 \"d/cc/d_cc_mass_s.h\" */\n#ifndef D_CC_D_CC_MASS_S_H\n#define D_CC_D_CC_MASS_S_H\n\n/* \"include/d/cc/d_cc_mass_s.h\" line 3 \"SSystem/SComponent/c_cc_d.h\" */\n/* end \"SSystem/SComponent/c_cc_d.h\" */\n/* \"include/d/cc/d_cc_mass_s.h\" line 4 \"global.h\" */\n/* end \"global.h\" */\n\ntypedef void (*dCcMassS_ObjCallback)(fopAc_ac_c*, cXyz*, u32);\n\nclass dCcMassS_Obj {\nprivate:\n    /* 0x00 */ cCcD_Obj* mpObj;\n    /* 0x04 */ u8 mPriority;\n    /* 0x08 */ dCcMassS_ObjCallback mpCallback;\n    /* 0x0C */ cCcD_DivideInfo mDivideInfo;\n    /* 0x1C vtable */\n\npublic:\n    dCcMassS_Obj();\n    virtual ~dCcMassS_Obj() {}\n    void Set(cCcD_Obj* p_obj, u8 priority, dCcMassS_ObjCallback callback);\n    void Clear();\n\n    cCcD_Obj* GetObj() { return mpObj; }\n    u8 GetPriority() const { return mPriority; }\n    dCcMassS_ObjCallback GetCallback() const { return mpCallback; }\n    cCcD_DivideInfo& GetDivideInfo() { return mDivideInfo; }\n};  // Size = 0x20\n\nSTATIC_ASSERT(0x20 == sizeof(dCcMassS_Obj));\n\nclass dCcMassS_HitInf {\nprivate:\n    /* 0x00 */ cCcD_Obj* mpArea;\n    /* 0x04 */ cCcD_Obj* mpAtObj;\n    /* 0x08 */ cCcD_Obj* mpCoObj;\n    /* 0x0C */ f32 mCoHitLen;\n\npublic:\n    void ClearPointer();\n    void SetAreaHitObj(cCcD_Obj* obj) { mpArea = obj; }\n    void SetCoHitObj(cCcD_Obj* obj) { mpCoObj = obj; }\n    void SetAtHitObj(cCcD_Obj* obj) { mpAtObj = obj; }\n    void SetCoHitLen(f32 len) { mCoHitLen = len; }\n    cCcD_Obj* GetAtHitObj() const { return mpAtObj; }\n};\n\nclass dCcMassS_Mng {\npublic:\n    /* 0x0000 */ cCcD_DivideArea mDivideArea;\n    /* 0x0040 */ s32 mMassObjCount;\n    /* 0x0044 */ dCcMassS_Obj mMassObjs[10];\n    /* 0x0184 */ s32 mMassAreaCount;\n    /* 0x0188 */ dCcMassS_Obj mMassAreas[2];\n    /* 0x01C8 */ cCcD_CylAttr mCylAttr;\n    /* 0x0200 */ u8 field_0x200;\n    /* 0x0200 */ u8 field_0x201;\n    /* 0x0202 */ u8 field_0x202;\n    /* 0x0203 */ u8 mResultCam;\n    /* 0x0204 */ Vec mCamTopPos;\n    /* 0x0210 */ f32 mCamTopDist;\n    /* 0x0214 */ Vec mCamBottomPos;\n    /* 0x0220 */ f32 mCamBottomDist;\n    /* 0x0224 */ cCcD_CpsAttr mCpsAttr;\n    /* 0x0264 */ cCcD_DivideInfo mDivideInfo;\n    /* 0x0274 vtable */\n\npublic:\n    dCcMassS_Mng();\n    virtual ~dCcMassS_Mng() {}\n    /* 800855E4 */ void Ct();\n    /* 80085630 */ void SetAttr(f32 radius, f32 height, u8 param_2, u8 param_3);\n    /* 80085690 */ void Prepare();\n    /* 800858AC */ u32 Chk(cXyz* p_xyz, fopAc_ac_c** p_actor, dCcMassS_HitInf* p_hitInf);\n    /* 80085CF0 */ void Clear();\n    /* 80085D98 */ void Set(cCcD_Obj* p_obj, u8 priority);\n    /* 80085E6C */ void SetCam(cM3dGCps const& cps);\n    /* 80085EB0 */ u8 GetResultCam() const;\n    /* 80085EB8 */ void GetCamTopPos(Vec* p_out);\n};\n\nSTATIC_ASSERT(sizeof(dCcMassS_Mng) == 0x278);\n\n#endif /* D_CC_D_CC_MASS_S_H */\n/* end \"d/cc/d_cc_mass_s.h\" */\n/* \"include/d/cc/d_cc_s.h\" line 5 \"global.h\" */\n/* end \"global.h\" */\n\nclass dCcD_GObjInf;\nclass dCcD_GStts;\n\nclass dCcS : public cCcS {\npublic:\n    dCcS() {}\n    /* 80085ED4 */ void Ct();\n    /* 80085F08 */ void Dt();\n    /* 80085F28 */ bool ChkShieldFrontRange(cCcD_Obj*, cCcD_Obj*, int, cXyz const*);\n    /* 800860F8 */ bool ChkShield(cCcD_Obj*, cCcD_Obj*, dCcD_GObjInf*, dCcD_GObjInf*, cXyz const*);\n    /* 800861B0 */ void CalcTgPlusDmg(cCcD_Obj*, cCcD_Obj*, cCcD_Stts*, cCcD_Stts*);\n    /* 80086360 */ int GetRank(u8);\n    /* 8008685C */ void ProcAtTgHitmark(bool, bool, cCcD_Obj*, cCcD_Obj*, dCcD_GObjInf*,\n                                        dCcD_GObjInf*, cCcD_Stts*, cCcD_Stts*, dCcD_GStts*,\n                                        dCcD_GStts*, cXyz*, bool);\n    /* 80086D8C */ bool ChkCamera(cXyz&, cXyz&, f32, fopAc_ac_c*, fopAc_ac_c*, fopAc_ac_c*);\n    /* 80086FBC */ bool chkCameraPoint(cXyz const&, cCcD_ShapeAttr::Shape*, fopAc_ac_c*,\n                                       fopAc_ac_c*);\n    /* 800872AC */ void DrawAfter();\n    /* 800872B0 */ void Move();\n    /* 800872D0 */ void Draw();\n    /* 8008730C */ void MassClear();\n    /* 80087330 */ int ChkAtTgMtrlHit(u8, u8);\n\n    /* 8008640C */ virtual void SetPosCorrect(cCcD_Obj*, cXyz*, cCcD_Obj*, cXyz*, f32);\n    /* 80086240 */ virtual void SetCoGObjInf(bool, bool, cCcD_GObjInf*, cCcD_GObjInf*, cCcD_Stts*,\n                                             cCcD_Stts*, cCcD_GStts*, cCcD_GStts*);\n    /* 80086AC0 */ virtual void SetAtTgGObjInf(bool, bool, cCcD_Obj*, cCcD_Obj*, cCcD_GObjInf*,\n                                               cCcD_GObjInf*, cCcD_Stts*, cCcD_Stts*, cCcD_GStts*,\n                                               cCcD_GStts*, cXyz*);\n    /* 8008734C */ virtual bool ChkNoHitGAtTg(cCcD_GObjInf const*, cCcD_GObjInf const*, cCcD_GStts*,\n                                              cCcD_GStts*);\n    /* 800861B4 */ virtual bool ChkAtTgHitAfterCross(bool, bool, cCcD_GObjInf const*,\n                                                     cCcD_GObjInf const*, cCcD_Stts*, cCcD_Stts*,\n                                                     cCcD_GStts*, cCcD_GStts*);\n    /* 80086404 */ virtual bool ChkNoHitGCo(cCcD_Obj*, cCcD_Obj*);\n    /* 8002FF40 */ virtual ~dCcS() {}\n    /* 800872A8 */ virtual void MoveAfterCheck();\n    /* 80086754 */ virtual void CalcParticleAngle(dCcD_GObjInf*, cCcD_Stts*, cCcD_Stts*, csXyz*);\n\n    void SetMass(cCcD_Obj* i_obj, u8 i_priority) { mMass_Mng.Set(i_obj, i_priority); }\n    void PrepareMass() { mMass_Mng.Prepare(); }\n\n    static u8 m_mtrl_hit_tbl[64];\n\n    // /* 0x0000 */ cCcS mCCcS;\n    /* 0x284C */ dCcMassS_Mng mMass_Mng;\n};  // Size = 0x2AC4\n\nSTATIC_ASSERT(sizeof(dCcS) == 0x2AC4);\n\n#endif /* D_CC_D_CC_S_H */\n/* end \"d/cc/d_cc_s.h\" */\n/* \"include/d/com/d_com_inf_game.h\" line 5 \"d/d_attention.h\" */\n/* end \"d/d_attention.h\" */\n/* \"include/d/com/d_com_inf_game.h\" line 6 \"d/d_resorce.h\" */\n#ifndef D_D_RESORCE_H\n#define D_D_RESORCE_H\n\n/* \"include/d/d_resorce.h\" line 3 \"m_Do/m_Do_dvd_thread.h\" */\n#ifndef M_DO_M_DO_DVD_THREAD_H\n#define M_DO_M_DO_DVD_THREAD_H\n\n/* \"include/m_Do/m_Do_dvd_thread.h\" line 3 \"JSystem/JKernel/JKRArchive.h\" */\n#ifndef JKRARCHIVE_H\n#define JKRARCHIVE_H\n\n/* \"include/JSystem/JKernel/JKRArchive.h\" line 3 \"JSystem/JKernel/JKRCompression.h\" */\n#ifndef JKRCOMPREESION_H_\n#define JKRCOMPREESION_H_\n\ntypedef int JKRCompression;\nconst JKRCompression COMPRESSION_NONE = 0;\nconst JKRCompression COMPRESSION_YAY0 = 1;\nconst JKRCompression COMPRESSION_YAZ0 = 2;\nconst JKRCompression COMPRESSION_ASR = 3;\n\n#endif/* end \"JSystem/JKernel/JKRCompression.h\" */\n/* \"include/JSystem/JKernel/JKRArchive.h\" line 4 \"JSystem/JKernel/JKRFileLoader.h\" */\n#ifndef JKRFILELOADER_H\n#define JKRFILELOADER_H\n\n/* \"include/JSystem/JKernel/JKRFileLoader.h\" line 3 \"JSystem/JKernel/JKRDisposer.h\" */\n#ifndef JKRDISPOSER_H\n#define JKRDISPOSER_H\n\n/* \"include/JSystem/JKernel/JKRDisposer.h\" line 3 \"JSystem/JSupport/JSUList.h\" */\n/* end \"JSystem/JSupport/JSUList.h\" */\n\nclass JKRHeap;\nclass JKRDisposer {\npublic:\n    JKRDisposer();\n    virtual ~JKRDisposer();\n\npublic:\n    /* 0x00 */  // vtable\n    /* 0x04 */ JKRHeap* mHeap;\n    /* 0x08 */ JSULink<JKRDisposer> mLink;\n    /* 0x18 */\n};\n\n#endif /* JKRDISPOSER_H */\n/* end \"JSystem/JKernel/JKRDisposer.h\" */\n/* \"include/JSystem/JKernel/JKRFileLoader.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass JKRFileFinder;\nclass JKRFileLoader : public JKRDisposer {\npublic:\n    JKRFileLoader(void);\n    virtual ~JKRFileLoader();\n\n    bool isMounted() const { return this->mIsMounted; }\n    u32 getVolumeType() const { return this->mVolumeType; }\n\npublic:\n    /* vt[03] */ virtual void unmount(void);\n    /* vt[04] */ virtual bool becomeCurrent(const char*) = 0;\n    /* vt[05] */ virtual void* getResource(const char*) = 0;\n    /* vt[06] */ virtual void* getResource(u32, const char*) = 0;\n    /* vt[07] */ virtual u32 readResource(void*, u32, const char*) = 0;\n    /* vt[08] */ virtual u32 readResource(void*, u32, u32, const char*) = 0;\n    /* vt[09] */ virtual void removeResourceAll(void) = 0;\n    /* vt[10] */ virtual bool removeResource(void*) = 0;\n    /* vt[11] */ virtual bool detachResource(void*) = 0;\n    /* vt[12] */ virtual u32 getResSize(const void*) const = 0;\n    /* vt[13] */ virtual u32 countFile(const char*) const = 0;\n    /* vt[14] */ virtual JKRFileFinder* getFirstFile(const char*) const = 0;\n\nprotected:\n    /* 0x00 */  // vtable\n    /* 0x04 */  // JKRDisposer\n    /* 0x18 */ JSULink<JKRFileLoader> mFileLoaderLink;\n    /* 0x28 */ const char* mVolumeName;\n    /* 0x2C */ u32 mVolumeType;\n    /* 0x30 */ bool mIsMounted;\n    /* 0x31 */ u8 field_0x31[3];\n    /* 0x34 */ u32 mMountCount;\n\npublic:\n    static void* getGlbResource(const char*);\n    static void* getGlbResource(const char*, JKRFileLoader*);\n    static bool removeResource(void*, JKRFileLoader*);\n    static bool detachResource(void*, JKRFileLoader*);\n    static JKRFileLoader* findVolume(const char**);\n    static const char* fetchVolumeName(char*, s32, const char*);\n\n    static JKRFileLoader* getCurrentVolume() { return sCurrentVolume; }\n    static void setCurrentVolume(JKRFileLoader* fileLoader) { sCurrentVolume = fileLoader; }\n    static JSUList<JKRFileLoader>& getVolumeList() { return sVolumeList; }\n\n    static JKRFileLoader* sCurrentVolume;\n    static JSUList<JKRFileLoader> sVolumeList;\n};\n\ninline bool JKRDetachResource(void* resource, JKRFileLoader* fileLoader) {\n    return JKRFileLoader::detachResource(resource, fileLoader);\n}\n\ninline void* JKRGetNameResource(const char* name, JKRFileLoader* loader) {\n    return JKRFileLoader::getGlbResource(name, loader);\n}\n\ninline void* JKRGetResource(const char* name) {\n    return JKRFileLoader::getGlbResource(name);\n}\n\n#endif /* JKRFILELOADER_H */\n/* end \"JSystem/JKernel/JKRFileLoader.h\" */\n/* \"include/JSystem/JKernel/JKRArchive.h\" line 5 \"global.h\" */\n/* end \"global.h\" */\n\nclass JKRHeap;\n\nstruct SArcHeader {\n    /* 0x00 */ u32 signature;\n    /* 0x04 */ u32 file_length;\n    /* 0x08 */ u32 header_length;\n    /* 0x0C */ u32 file_data_offset;\n    /* 0x10 */ u32 file_data_length;\n    /* 0x14 */ u32 field_0x14;\n    /* 0x18 */ u32 field_0x18;\n    /* 0x1C */ u32 field_0x1c;\n};\n\nstruct SArcDataInfo {\n    /* 0x00 */ u32 num_nodes;\n    /* 0x04 */ u32 node_offset;\n    /* 0x08 */ u32 num_file_entries;\n    /* 0x0C */ u32 file_entry_offset;\n    /* 0x10 */ u32 string_table_length;\n    /* 0x14 */ u32 string_table_offset;\n    /* 0x18 */ u16 next_free_file_id;\n    /* 0x1A */ bool sync_file_ids_and_indices;\n    /* 0x1B */ u8 field_1b[5];\n};\n\ninline u32 read_big_endian_u32(void* ptr) {\n    u8* uptr = (u8*)ptr;\n    return ((u32)uptr[0] << 0x18) | ((u32)uptr[1] << 0x10) | ((u32)uptr[2] << 8) | (u32)uptr[3];\n}\n\ninline u16 read_big_endian_u16(void* ptr) {\n    u8* uptr = (u8*)ptr;\n    return ((u16)uptr[0] << 8) | ((u16)uptr[1]);\n}\n\nextern u32 sCurrentDirID__10JKRArchive;  // JKRArchive::sCurrentDirID\n\nclass JKRArchive : public JKRFileLoader {\npublic:\n    struct SDirEntry {\n        u8 flags;\n        u8 padding;\n        u16 id;\n        const char* name;\n    };\n\n    struct SDIDirEntry {\n        u32 type;\n        u32 name_offset;\n        u16 field_0x8;\n        u16 num_entries;\n        u32 first_file_index;\n    };\n\n    struct SDIFileEntry {\n        u16 file_id;\n        u16 name_hash;\n        u32 type_flags_and_name_offset;\n        u32 data_offset;\n        u32 data_size;\n        void* data;\n\n        u32 getNameOffset() const { return type_flags_and_name_offset & 0xFFFFFF; }\n        u16 getNameHash() const { return name_hash; }\n        u32 getFlags() const { return type_flags_and_name_offset >> 24; }\n        u32 getAttr() const { return getFlags(); }\n        u16 getFileID() const { return file_id; }\n        bool isDirectory() const { return (getFlags() & 0x02) != 0; }\n        bool isUnknownFlag1() const { return (getFlags() & 0x01) != 0; }\n        bool isCompressed() const { return (getFlags() & 0x04) != 0; }\n        // was needed for open__14JKRAramArchiveFl\n        u8 getCompressFlag() const { return (getFlags() & 0x04); }\n        bool isYAZ0Compressed() const { return (getFlags() & 0x80) != 0; }\n        u32 getSize() const { return data_size; }\n    };\n\n    enum EMountMode {\n        UNKNOWN_MOUNT_MODE = 0,\n        MOUNT_MEM = 1,\n        MOUNT_ARAM = 2,\n        MOUNT_DVD = 3,\n        MOUNT_COMP = 4,\n    };\n\n    enum EMountDirection {\n        UNKNOWN_MOUNT_DIRECTION = 0,\n        MOUNT_DIRECTION_HEAD = 1,\n        MOUNT_DIRECTION_TAIL = 2,\n    };\n\n    class CArcName {\n    public:\n        CArcName() {}\n        CArcName(char const* data) { this->store(data); }\n        CArcName(char const** data, char endChar) { *data = this->store(*data, endChar); }\n\n        void store(char const* data);\n        const char* store(char const* data, char endChar);\n\n        u16 getHash() const { return mHash; }\n\n        const char* getString() const { return mData; }\n\n    private:\n        u16 mHash;\n        u16 mLength;\n        char mData[256];\n    };\n\nprotected:\n    JKRArchive();\n    JKRArchive(s32, EMountMode);\n    virtual ~JKRArchive();\n\npublic:\n    bool getDirEntry(SDirEntry*, u32) const;\n    void* getIdxResource(u32);\n    void* getResource(u16);\n    u32 readIdxResource(void*, u32, u32);\n    u32 readResource(void*, u32, u16);\n    u32 countResource(void) const;\n    u32 getFileAttribute(u32) const;\n\n    SDIFileEntry* findNameResource(const char*) const;\n    bool isSameName(CArcName&, u32, u16) const;\n    SDIDirEntry* findResType(u32) const;\n    SDIDirEntry* findDirectory(const char*, u32) const;\n    SDIFileEntry* findTypeResource(u32, const char*) const;\n    SDIFileEntry* findFsResource(const char*, u32) const;\n    SDIFileEntry* findIdxResource(u32) const;\n    SDIFileEntry* findPtrResource(const void*) const;\n    SDIFileEntry* findIdResource(u16) const;\n\npublic:\n    /* vt[04] */ virtual bool becomeCurrent(const char*);                /* override */\n    /* vt[05] */ virtual void* getResource(const char*);                 /* override */\n    /* vt[06] */ virtual void* getResource(u32, const char*);            /* override */\n    /* vt[07] */ virtual u32 readResource(void*, u32, const char*);      /* override */\n    /* vt[08] */ virtual u32 readResource(void*, u32, u32, const char*); /* override */\n    /* vt[09] */ virtual void removeResourceAll(void);                   /* override */\n    /* vt[10] */ virtual bool removeResource(void*);                     /* override */\n    /* vt[11] */ virtual bool detachResource(void*);                     /* override */\n    /* vt[12] */ virtual u32 getResSize(const void*) const;              /* override */\n    /* vt[13] */ virtual u32 countFile(const char*) const;               /* override */\n    /* vt[14] */ virtual JKRFileFinder* getFirstFile(const char*) const; /* override */\n    /* vt[15] */ virtual u32 getExpandedResSize(const void*) const;\n    /* vt[16] */ virtual void* fetchResource(SDIFileEntry*, u32*) = 0;\n    /* vt[17] */ virtual void* fetchResource(void*, u32, SDIFileEntry*, u32*) = 0;\n    /* vt[18] */ virtual void setExpandSize(SDIFileEntry*, u32);\n    /* vt[19] */ virtual u32 getExpandSize(SDIFileEntry*) const;\n\n    u32 countFile() const { return mArcInfoBlock->num_file_entries; }\n    s32 countDirectory() const { return mArcInfoBlock->num_nodes; }\n    u8 getMountMode() const { return mMountMode; }\n    bool isFileEntry(u32 param_0) {\n        return getFileAttribute(param_0) & 1;\n    }\n\npublic:\n    /* 0x00 */  // vtable\n    /* 0x04 */  // JKRFileLoader\n    /* 0x38 */ JKRHeap* mHeap;\n    /* 0x3C */ u8 mMountMode;\n    /* 0x3D */ u8 field_0x3d[3];\n    /* 0x40 */ s32 mEntryNum;\n    /* 0x44 */ SArcDataInfo* mArcInfoBlock;\n    /* 0x48 */ SDIDirEntry* mNodes;\n    /* 0x4C */ SDIFileEntry* mFiles;\n    /* 0x50 */ s32* mExpandedSize;\n    /* 0x54 */ char* mStringTable;\n\nprotected:\n    /* 0x58 */ u32 field_0x58;\n    /* 0x5C */ JKRCompression mCompression;\n    /* 0x60 */ EMountDirection mMountDirection;\n\npublic:\n    static JKRArchive* check_mount_already(s32, JKRHeap*);\n    static JKRArchive* mount(const char*, EMountMode, JKRHeap*, EMountDirection);\n    static JKRArchive* mount(void*, JKRHeap*, EMountDirection);\n    static JKRArchive* mount(s32, EMountMode, JKRHeap*, EMountDirection);\n    static void* getGlbResource(u32, const char*, JKRArchive*);\n\n    static JKRCompression convertAttrToCompressionType(u32 attr) {\n#define JKRARCHIVE_ATTR_COMPRESSION 0x04\n#define JKRARCHIVE_ATTR_YAY0 0x80\n\n        JKRCompression compression;\n        if (FLAG_ON(attr, JKRARCHIVE_ATTR_COMPRESSION)) {\n            compression = COMPRESSION_NONE;\n        } else if (!FLAG_ON(attr, JKRARCHIVE_ATTR_YAY0)) {\n            compression = COMPRESSION_YAZ0;\n        } else {\n            compression = COMPRESSION_YAY0;\n        }\n        return compression;\n    }\n\n    static u32 getCurrentDirID() { return sCurrentDirID; }\n    static void setCurrentDirID(u32 dirID) { sCurrentDirID = dirID; }\n\nprivate:\n    static u32 sCurrentDirID;\n};\n\ninline JKRCompression JKRConvertAttrToCompressionType(u32 attr) {\n    return JKRArchive::convertAttrToCompressionType(attr);\n}\n\ninline void* JKRGetResource(u32 node, const char* path, JKRArchive* archive) {\n    return JKRArchive::getGlbResource(node, path, archive);\n}\n\ninline void* JKRGetTypeResource(u32 tag, const char* name, JKRArchive* arc) {\n    return JKRArchive::getGlbResource(tag, name, arc);\n}\n\ninline bool JKRRemoveResource(void* resource, JKRFileLoader* fileLoader) {\n    return JKRFileLoader::removeResource(resource, fileLoader);\n}\n\n#endif/* end \"JSystem/JKernel/JKRArchive.h\" */\n/* \"include/m_Do/m_Do_dvd_thread.h\" line 4 \"dolphin/os/OSMessage.h\" */\n/* end \"dolphin/os/OSMessage.h\" */\n/* \"include/m_Do/m_Do_dvd_thread.h\" line 5 \"dolphin/os/OSMutex.h\" */\n/* end \"dolphin/os/OSMutex.h\" */\n/* \"include/m_Do/m_Do_dvd_thread.h\" line 6 \"f_pc/f_pc_node.h\" */\n\n#ifndef F_PC_NODE_H_\n#define F_PC_NODE_H_\n\n/* \"include/f_pc/f_pc_node.h\" line 4 \"f_pc/f_pc_base.h\" */\n\n#ifndef F_PC_BASE_H_\n#define F_PC_BASE_H_\n\n/* \"include/f_pc/f_pc_base.h\" line 4 \"f_pc/f_pc_delete_tag.h\" */\n\n#ifndef F_PC_DELETE_TAG_H_\n#define F_PC_DELETE_TAG_H_\n\n/* \"include/f_pc/f_pc_delete_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef struct layer_class layer_class;\n\ntypedef int (*delete_tag_func)(void*);\n\ntypedef struct delete_tag_class {\n    create_tag_class mBase;\n    layer_class* mpLayer;\n    s16 mTimer;\n} delete_tag_class;\n\nBOOL fpcDtTg_IsEmpty(void);\nvoid fpcDtTg_ToDeleteQ(delete_tag_class* pTag);\nvoid fpcDtTg_DeleteQTo(delete_tag_class* pTag);\ns32 fpcDtTg_Do(delete_tag_class* pTag, delete_tag_func pFunc);\ns32 fpcDtTg_Init(delete_tag_class* pTag, void* pUserData);\n\nextern node_list_class g_fpcDtTg_Queue;\n\n#endif\n/* end \"f_pc/f_pc_delete_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 5 \"f_pc/f_pc_layer_tag.h\" */\n\n#ifndef F_PC_LAYER_TAG_H_\n#define F_PC_LAYER_TAG_H_\n\n/* \"include/f_pc/f_pc_layer_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\nenum {\n    fpcLy_ROOT_e    = 0,\n    fpcLy_CURRENT_e = 0xFFFFFFFD,\n    fpcLy_SPECIAL_e = 0xFFFFFFFE,\n    fpcLy_NONE_e    = 0xFFFFFFFF,\n};\n\ntypedef struct layer_class layer_class;\n\n\ntypedef struct layer_management_tag_class {\n    create_tag_class mCreateTag;\n    layer_class* mpLayer;\n    u16 mNodeListID;\n    u16 mNodeListIdx;\n} layer_management_tag_class;\n\ns32 fpcLyTg_QueueTo(layer_management_tag_class* pTag);\ns32 fpcLyTg_ToQueue(layer_management_tag_class* pTag, unsigned int layerID, u16 listID,\n                    u16 listPrio);\ns32 fpcLyTg_Move(layer_management_tag_class*, unsigned int, u16, u16);\ns32 fpcLyTg_Init(layer_management_tag_class*, unsigned int, void*);\n\n#endif\n/* end \"f_pc/f_pc_layer_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 6 \"f_pc/f_pc_line_tag.h\" */\n\n#ifndef F_PC_LINE_TAG_H_\n#define F_PC_LINE_TAG_H_\n\n/* \"include/f_pc/f_pc_line_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef struct line_tag {\n    create_tag_class mBase;\n    s32 mLineListID;\n} line_tag;\n\ns32 fpcLnTg_Move(line_tag* pLineTag, int newLineListID);\nvoid fpcLnTg_QueueTo(line_tag* pLineTag);\ns32 fpcLnTg_ToQueue(line_tag* pLineTag, int lineListID);\nvoid fpcLnTg_Init(line_tag* pLineTag, void* pData);\n\n#endif\n/* end \"f_pc/f_pc_line_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 7 \"f_pc/f_pc_priority.h\" */\n\n#ifndef F_PC_PRIORITY_H_\n#define F_PC_PRIORITY_H_\n\n/* \"include/f_pc/f_pc_priority.h\" line 4 \"f_pc/f_pc_method_tag.h\" */\n\n#ifndef F_PC_METHOD_TAG_H_\n#define F_PC_METHOD_TAG_H_\n\n/* \"include/f_pc/f_pc_method_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef int (*process_method_tag_func)(void*);\n\ntypedef struct process_method_tag_class {\n    create_tag_class mCreateTag;\n    process_method_tag_func mpFunc;\n    void* mpMthdData;\n} process_method_tag_class;\n\ns32 fpcMtdTg_Do(process_method_tag_class* pMthd);\ns32 fpcMtdTg_ToMethodQ(node_list_class* pList, process_method_tag_class* pMthd);\nvoid fpcMtdTg_MethodQTo(process_method_tag_class* pMthd);\ns32 fpcMtdTg_Init(process_method_tag_class* pMthd, process_method_tag_func pFunc, void* pMthdData);\n\n#endif\n/* end \"f_pc/f_pc_method_tag.h\" */\n\nenum {\n    fpcPi_CURRENT_e = 0xFFFD,\n    fpcPi_SPECIAL_e = 0xFFFE,\n};\n\ntypedef struct process_priority_queue_info {\n    u32 mLayer;\n    u16 mListID;\n    u16 mListPrio;\n} process_priority_queue_info;\n\ntypedef struct process_priority_class {\n    /* 0x00 */ create_tag_class mBase;\n    /* 0x14 */ process_method_tag_class mMtdTag;\n    /* 0x30 */ process_priority_queue_info mInfoQ;\n    /* 0x38 */ process_priority_queue_info mInfoCurr;\n} process_priority_class;\n\ns32 fpcPi_IsInQueue(process_priority_class* pPi);\ns32 fpcPi_QueueTo(process_priority_class* pPi);\ns32 fpcPi_ToQueue(process_priority_class* pPi);\nprocess_priority_class* fpcPi_GetFromQueue(void);\ns32 fpcPi_Delete(process_priority_class* pPi);\ns32 fpcPi_IsNormal(unsigned int layer, u16 listID, u16 priority);\ns32 fpcPi_Change(process_priority_class* pPi, unsigned int layer, u16 listID, u16 priority);\ns32 fpcPi_Handler(void);\ns32 fpcPi_Init(process_priority_class* pPi, void* pUserData, unsigned int layer, u16 listID,\n               u16 priority);\n\nextern s8 data_804505F0;  // roomReadId\n\n#endif\n/* end \"f_pc/f_pc_priority.h\" */\n\ntypedef struct create_request create_request;\ntypedef struct process_method_class process_method_class; \ntypedef struct process_profile_definition process_profile_definition;\ntypedef struct profile_method_class profile_method_class;\n\ntypedef struct base_process_class {\n    /* 0x00 */ u32 mBsType;\n    /* 0x04 */ u32 mBsPcId;\n    /* 0x08 */ s16 mProcName;\n    /* 0x0A */ s8 mUnk0;\n    /* 0x0B */ u8 mPauseFlag;\n    /* 0x0C */ s8 mInitState;\n    /* 0x0D */ u8 mUnk2;\n    /* 0x0E */ s16 mBsTypeId;\n    /* 0x10 */ process_profile_definition* mpProf;\n    /* 0x14 */ struct create_request* mpCtRq;\n    /* 0x18 */ layer_management_tag_class mLyTg;\n    /* 0x34 */ line_tag mLnTg;\n    /* 0x4C */ delete_tag_class mDtTg;\n    /* 0x68 */ process_priority_class mPi;\n    /* 0xA8 */ process_method_class* mpPcMtd;\n    /* 0xAC */ void* mpUserData;\n    /* 0xB0 */ u32 mParameters;\n    /* 0xB4 */ u32 mSubType;\n} base_process_class;  // Size: 0xB8\n\ns32 fpcBs_Is_JustOfType(int pType1, int pType2);\ns32 fpcBs_MakeOfType(int* pType);\ns32 fpcBs_MakeOfId(void);\ns32 fpcBs_Execute(base_process_class* pProc);\nvoid fpcBs_DeleteAppend(base_process_class* pProc);\ns32 fpcBs_IsDelete(base_process_class* pProc);\ns32 fpcBs_Delete(base_process_class* pProc);\nbase_process_class* fpcBs_Create(s16 pProcTypeID, unsigned int pProcID, void* pData);\ns32 fpcBs_SubCreate(base_process_class* pProc);\n\nextern \"C\" {\nvoid fpcBs_MakeOfType__FPi(void);\nvoid fpcBs_Is_JustOfType__Fii(void);\n}\n\n#endif\n/* end \"f_pc/f_pc_base.h\" */\n/* \"include/f_pc/f_pc_node.h\" line 5 \"f_pc/f_pc_layer.h\" */\n\n#ifndef F_PC_LAYER_H_\n#define F_PC_LAYER_H_\n\n/* \"include/f_pc/f_pc_layer.h\" line 4 \"SSystem/SComponent/c_list.h\" */\n#ifndef C_LIST_H\n#define C_LIST_H\n\n\ntypedef struct node_class node_class;\n\ntypedef struct node_list_class {\n    node_class* mpHead;\n    node_class* mpTail;\n    int mSize;\n} node_list_class;\n\nvoid cLs_Init(node_list_class* pList);\nint cLs_SingleCut(node_class* pNode);\nint cLs_Addition(node_list_class* pList, node_class* pNode);\nint cLs_Insert(node_list_class* pList, int idx, node_class* pNode);\nnode_class* cLs_GetFirst(node_list_class* pList);\nvoid cLs_Create(node_list_class* pList);\n\n#endif /* C_LIST_H */\n/* end \"SSystem/SComponent/c_list.h\" */\n/* \"include/f_pc/f_pc_layer.h\" line 5 \"SSystem/SComponent/c_node.h\" */\n/* end \"SSystem/SComponent/c_node.h\" */\n/* \"include/f_pc/f_pc_layer.h\" line 6 \"SSystem/SComponent/c_tree.h\" */\n#ifndef C_TREE_H\n#define C_TREE_H\n\n\ntypedef struct node_class node_class;\ntypedef struct node_list_class node_list_class;\n\ntypedef struct node_lists_tree_class {\n    node_list_class* mpLists;\n    int mNumLists;\n} node_lists_tree_class;\n\nint cTr_SingleCut(node_class* pNode);\nint cTr_Addition(node_lists_tree_class* pTree, int listIdx, node_class* pNode);\nint cTr_Insert(node_lists_tree_class* pTree, int listIdx, node_class* pNode, int idx);\nvoid cTr_Create(node_lists_tree_class* pTree, node_list_class* pLists, int numLists);\n\n#endif /* C_TREE_H */\n/* end \"SSystem/SComponent/c_tree.h\" */\n/* \"include/f_pc/f_pc_layer.h\" line 7 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef struct create_tag_class create_tag_class;\ntypedef struct process_method_tag_class process_method_tag_class;\ntypedef struct process_node_class process_node_class;\n\ntypedef struct layer_class {\n    /* 0x00 */ node_class mNode;\n    /* 0x0C */ u32 mLayerID;\n    /* 0x10 */ node_lists_tree_class mNodeListTree;\n    /* 0x18 */ process_node_class* mpPcNode;\n    /* 0x1C */ node_list_class mCancelList;\n    struct {\n        /* 0x28 */ s16 mCreatingCount;\n        /* 0x2A */ s16 mDeletingCount;\n    } counts;\n} layer_class;\n\nvoid fpcLy_SetCurrentLayer(layer_class* pLayer);\nlayer_class* fpcLy_CurrentLayer(void);\nlayer_class* fpcLy_RootLayer(void);\nlayer_class* fpcLy_Layer(unsigned int id);\nlayer_class* fpcLy_Search(unsigned int id);\nvoid fpcLy_Regist(layer_class* pLayer);\n\nvoid fpcLy_CreatedMesg(layer_class* pLayer);\nvoid fpcLy_CreatingMesg(layer_class* pLayer);\nvoid fpcLy_DeletedMesg(layer_class* pLayer);\nvoid fpcLy_DeletingMesg(layer_class* pLayer);\nBOOL fpcLy_IsCreatingMesg(layer_class* pLayer);\nBOOL fpcLy_IsDeletingMesg(layer_class* pLayer);\n\ns32 fpcLy_IntoQueue(layer_class* pLayer, int treeListIdx, create_tag_class* pTag, int idx);\ns32 fpcLy_ToQueue(layer_class* pLayer, int treeListIdx, create_tag_class* pTag);\ns32 fpcLy_QueueTo(layer_class* pLayer, create_tag_class* pTag);\n\nvoid fpcLy_Cancel(layer_class* pLayer);\nbool fpcLy_CancelMethod(process_method_tag_class* pLayer);\n\nvoid fpcLy_CancelQTo(process_method_tag_class* pMthd);\ns32 fpcLy_ToCancelQ(layer_class* pLayer, process_method_tag_class* pMthd);\n\nvoid fpcLy_Create(layer_class* pLayer, void* pPcNode, node_list_class* pLists, int listNum);\n\ns32 fpcLy_Delete(layer_class* pLayer);\n\n#endif\n/* end \"f_pc/f_pc_layer.h\" */\n/* \"include/f_pc/f_pc_node.h\" line 6 \"f_pc/f_pc_method.h\" */\n\n#ifndef F_PC_METHOD_H_\n#define F_PC_METHOD_H_\n\n/* \"include/f_pc/f_pc_method.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef int (*process_method_func)(void*);\n\ntypedef struct process_method_class {\n    process_method_func mpCreateFunc;\n    process_method_func mpDeleteFunc;\n    process_method_func mpExecuteFunc;\n    process_method_func mpIsDeleteFunc;\n} process_method_class;\n\ns32 fpcMtd_Method(process_method_func pFunc, void* pUserData);\ns32 fpcMtd_Execute(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_IsDelete(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_Delete(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_Create(process_method_class* pMthd, void* pUserData);\n\nextern \"C\" {\nvoid fpcMtd_Execute__FP20process_method_classPv(void);\nvoid fpcMtd_Create__FP20process_method_classPv(void);\n}\n\n#endif\n/* end \"f_pc/f_pc_method.h\" */\n/* \"include/f_pc/f_pc_node.h\" line 7 \"f_pc/f_pc_profile.h\" */\n\n#ifndef F_PC_PROFILE_H_\n#define F_PC_PROFILE_H_\n\n/* \"include/f_pc/f_pc_profile.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef struct nodedraw_method_class nodedraw_method_class;\ntypedef struct leafdraw_method_class leafdraw_method_class;\ntypedef struct process_method_class process_method_class;\n\ntypedef struct process_profile_definition {\n    /* 0x00 */ s32 mLayerID;\n    /* 0x04 */ u16 mListID;\n    /* 0x06 */ u16 mListPrio;\n    /* 0x08 */ s16 mProcName;\n    /* 0x0C */ process_method_class* mSubMtd; // Subclass methods\n    /* 0x10 */ s32 mSize;\n    /* 0x14 */ s32 mSizeOther;\n    /* 0x18 */ s32 mParameters;\n} process_profile_definition;\n\n#define LAYER_DEFAULT (-2)\n\nstruct leaf_process_profile_definition;\nprocess_profile_definition* fpcPf_Get(s16 profileID);\nextern process_profile_definition** g_fpcPf_ProfileList_p;\n\n#endif\n/* end \"f_pc/f_pc_profile.h\" */\n\ntypedef struct nodedraw_method_class {\n    process_method_class mBase;\n    process_method_func mpDrawFunc;\n} nodedraw_method_class;\n\ntypedef struct process_node_class {\n    /* 0x00 */ base_process_class mBase;\n    /* 0xB8 */ nodedraw_method_class* mpNodeMtd;\n    /* 0xBC */ layer_class mLayer;\n    /* 0xE8 */ node_list_class mLayerNodeLists[16];\n    /* 0x1A8 */ s8 mUnk0;\n} process_node_class;\n\ntypedef struct node_process_profile_definition {\n    /* 0x00 */ process_profile_definition mBase;\n    /* 0x1C */ process_method_class* mSubMtd; // Subclass methods\n} node_process_profile_definition;\n\ns32 fpcNd_DrawMethod(nodedraw_method_class* pNodeMethod, void* pData);\ns32 fpcNd_Draw(process_node_class* pProcNode);\ns32 fpcNd_Execute(process_node_class* pProcNode);\nvoid* fpcNd_IsCreatingFromUnder(void* pProcNode);\ns32 fpcNd_IsDeleteTiming(process_node_class* pProcNode);\ns32 fpcNd_IsDelete(process_node_class* pProcNode);\ns32 fpcNd_Delete(process_node_class* pProcNode);\ns32 fpcNd_Create(process_node_class* pProcNode);\n\nextern int g_fpcNd_type;\nextern nodedraw_method_class g_fpcNd_Method;\n\n#endif\n/* end \"f_pc/f_pc_node.h\" */\n\nclass JKRHeap;\nclass JKRMemArchive;\n\ntypedef void* (*mDoDvdThd_callback_func)(void*);\n\nclass mDoDvdThd_command_c : public node_class {\npublic:\n    /* 0x0C */ bool mIsDone;\n    /* 0x10  vtable*/\npublic:\n    /* 800158FC */ virtual ~mDoDvdThd_command_c();\n    /* 80015B74 */ mDoDvdThd_command_c();\n    inline s32 sync() { return mIsDone; }\n    inline void destroy() { delete this; }\n    virtual s32 execute() = 0;\n};  // Size = 0x14\n\nclass mDoDvdThd_toMainRam_c : public mDoDvdThd_command_c {\npublic:\n    /* 80016338 */ mDoDvdThd_toMainRam_c(u8);\n    /* 80016394 */ static mDoDvdThd_toMainRam_c* create(char const*, u8, JKRHeap*);\n    /* 8001645C */ virtual ~mDoDvdThd_toMainRam_c();\n    /* 800164BC */ virtual s32 execute();\n\n    void* getMemAddress() const { return mData; }\n\nprivate:\n    /* 0x14 */ u8 mMountDirection;\n    /* 0x18 */ s32 mEntryNum;\n    /* 0x1C */ void* mData;\n    /* 0x20 */ s32 mDataSize;\n    /* 0x24 */ JKRHeap* mHeap;\n};  // Size = 0x28\n\nclass mDoDvdThd_param_c {\npublic:\n    /* 80015944 */ mDoDvdThd_param_c();\n    /* 8001598C */ void kick();\n    /* 800159B4 */ s32 waitForKick();\n    /* 800159DC */ mDoDvdThd_command_c* getFirstCommand();\n    /* 800159E4 */ void addition(mDoDvdThd_command_c*);\n    /* 80015A3C */ void cut(mDoDvdThd_command_c*);\n    /* 80015AD8 */ void mainLoop();\n\nprivate:\n    /* 0x00 */ OSMessageQueue mMessageQueue;\n    /* 0x20 */ void* mMessageQueueMessages;\n    /* 0x24 */ node_list_class mNodeList;\n    /* 0x30 */ OSMutex mMutext;\n};  // Size = 0x48\n\nclass mDoDvdThd_mountXArchive_c : public mDoDvdThd_command_c {\npublic:\n    /* 80016108 */ virtual ~mDoDvdThd_mountXArchive_c();\n    /* 80016168 */ mDoDvdThd_mountXArchive_c(u8 mountDirection, JKRArchive::EMountMode mountMode);\n    /* 800161E0 */ static mDoDvdThd_mountXArchive_c* create(char const*, u8, JKRArchive::EMountMode,\n                                                            JKRHeap*);\n    /* 800162B0 */ virtual s32 execute();\n\n    JKRArchive* getArchive() const { return mArchive; }\n\nprivate:\n    /* 0x14 */ u8 mMountDirection;\n    /* 0x18 */ s32 mEntryNum;\n    /* 0x1C */ JKRArchive* mArchive;\n    /* 0x20 */ JKRArchive::EMountMode mMountMode;\n    /* 0x24 */ JKRHeap* mHeap;\n};  // Size = 0x28\n\nclass mDoDvdThd_mountArchive_c : public mDoDvdThd_command_c {\npublic:\n    /* 80015D44 */ virtual ~mDoDvdThd_mountArchive_c();\n    /* 80015DA4 */ mDoDvdThd_mountArchive_c(u8);\n    /* 80015E14 */ static mDoDvdThd_mountArchive_c* create(char const*, u8, JKRHeap*);\n    /* 80015EDC */ virtual s32 execute();\n\n    JKRMemArchive* getArchive() const { return mArchive; }\n    JKRHeap* getHeap() const { return mHeap; }\n\nprivate:\n    /* 0x14 */ u8 mMountDirection;\n    /* 0x18 */ s32 mEntryNumber;\n    /* 0x1C */ JKRMemArchive* mArchive;\n    /* 0x20 */ JKRHeap* mHeap;\n};  // Size = 0x24\n\nclass mDoDvdThd_callback_c : public mDoDvdThd_command_c {\npublic:\n    /* 80015BB8 */ virtual ~mDoDvdThd_callback_c();\n    /* 80015C18 */ mDoDvdThd_callback_c(mDoDvdThd_callback_func, void*);\n    /* 80015C74 */ static mDoDvdThd_callback_c* create(mDoDvdThd_callback_func, void*);\n    /* 80015CF0 */ virtual s32 execute();\n\nprivate:\n    /* 0x14 */ mDoDvdThd_callback_func mFunction;\n    /* 0x18 */ void* mData;\n    /* 0x1C */ void* mResult;\n};\n\nstruct mDoDvdThdStack {\n    u8 stack[4096];\n} __attribute__((aligned(16)));\n\nstruct mDoDvdThd {\n    /* 800157FC */ static s32 main(void*);\n    /* 80015858 */ static void create(s32);\n    /* 800158B4 */ static void suspend();\n\n    static OSThread l_thread;\n    static mDoDvdThdStack l_threadStack;\n    static mDoDvdThd_param_c l_param;\n};\n\n#endif /* M_DO_M_DO_DVD_THREAD_H */\n/* end \"m_Do/m_Do_dvd_thread.h\" */\n/* \"include/d/d_resorce.h\" line 4 \"m_Do/m_Do_ext.h\" */\n/* end \"m_Do/m_Do_ext.h\" */\n\nclass JKRArchive;\nclass JKRHeap;\nclass JKRSolidHeap;\n\nclass dRes_info_c {\npublic:\n    /* 8003A260 */ dRes_info_c();\n    /* 8003A280 */ ~dRes_info_c();\n    /* 8003A348 */ int set(char const*, char const*, u8, JKRHeap*);\n    /* 8003AB30 */ static void onWarpMaterial(J3DModelData*);\n    /* 8003AC1C */ static void offWarpMaterial(J3DModelData*);\n    /* 8003AD08 */ static void setWarpSRT(J3DModelData*, cXyz const&, f32, f32);\n    /* 8003AE14 */ static J3DModelData* loaderBasicBmd(u32, void*);\n    /* 8003B30C */ int loadResource();\n    /* 8003B998 */ void deleteArchiveRes();\n    /* 8003BAC4 */ int setRes(JKRArchive*, JKRHeap*);\n    /* 8003BAF8 */ int setRes();\n    /* 8003BD2C */ static void dump_long(dRes_info_c*, int);\n    /* 8003BE38 */ static void dump(dRes_info_c*, int);\n\n    void* getRes(u32 resIdx) { return *(mRes + resIdx); }\n    int getCount() { return mCount; }\n    char* getArchiveName() { return mArchiveName; }\n    mDoDvdThd_mountArchive_c* getDMCommand() { return mDMCommand; }\n    JKRArchive* getArchive() { return mArchive; }\n    void incCount() { mCount++; }\n    u16 decCount() {\n        return --mCount;\n    }\n\nprivate:\n    /* 0x00 */ char mArchiveName[11];\n    /* 0x0C */ u16 mCount;\n    /* 0x10 */ mDoDvdThd_mountArchive_c* mDMCommand;\n    /* 0x14 */ JKRArchive* mArchive;\n    /* 0x18 */ JKRHeap* heap;\n    /* 0x1C */ JKRSolidHeap* mDataHeap;\n    /* 0x20 */ void** mRes;\n};  // Size: 0x24\n\nSTATIC_ASSERT(sizeof(dRes_info_c) == 0x24);\n\nclass dRes_control_c {\npublic:\n    dRes_control_c() {}\n    /* 8003BFB0 */ ~dRes_control_c();\n    /* 8003C078 */ static int setRes(char const*, dRes_info_c*, int, char const*, u8, JKRHeap*);\n    /* 8003C160 */ static int syncRes(char const*, dRes_info_c*, int);\n    /* 8003C194 */ static int deleteRes(char const*, dRes_info_c*, int);\n    /* 8003C37C */ static void* getRes(char const*, char const*, dRes_info_c*, int);\n    /* 8003C1E4 */ static dRes_info_c* getResInfo(char const*, dRes_info_c*, int);\n    /* 8003C260 */ static dRes_info_c* newResInfo(dRes_info_c*, int);\n    /* 8003C288 */ static dRes_info_c* getResInfoLoaded(char const*, dRes_info_c*, int);\n    /* 8003C2EC */ static void* getRes(char const*, s32, dRes_info_c*, int);\n    /* 8003C400 */ static void* getIDRes(char const*, u16, dRes_info_c*, int);\n    /* 8003C470 */ static int syncAllRes(dRes_info_c*, int);\n    /* 8003C4E4 */ int setObjectRes(char const*, void*, u32, JKRHeap*);\n    /* 8003C5BC */ int setStageRes(char const*, JKRHeap*);\n    /* 8003C638 */ void dump();\n    /* 8003C6B8 */ int getObjectResName2Index(char const*, char const*);\n\n    int setObjectRes(const char* name, u8 param_1, JKRHeap* heap) {\n        return setRes(name, &mObjectInfo[0], ARRAY_SIZE(mObjectInfo), \"/res/Object/\", param_1,\n                      heap);\n    }\n\n    void* getObjectRes(const char* arcName, const char* resName) {\n        return getRes(arcName, resName, &mObjectInfo[0], ARRAY_SIZE(mObjectInfo));\n    }\n\n    void* getObjectRes(const char* arcName, s32 param_1) {\n        return getRes(arcName, param_1, &mObjectInfo[0], ARRAY_SIZE(mObjectInfo));\n    }\n\n    void* getObjectIDRes(const char* arcName, u16 id) {\n        return getIDRes(arcName, id, &mObjectInfo[0], ARRAY_SIZE(mObjectInfo));\n    }\n\n    int syncObjectRes(const char* name) {\n        return syncRes(name, &mObjectInfo[0], ARRAY_SIZE(mObjectInfo));\n    }\n\n    int syncStageRes(const char* name) {\n        return syncRes(name, &mStageInfo[0], ARRAY_SIZE(mStageInfo));\n    }\n\n    int syncAllObjectRes() { return syncAllRes(&mObjectInfo[0], ARRAY_SIZE(mObjectInfo)); }\n\n    int deleteObjectRes(const char* name) {\n        return deleteRes(name, &mObjectInfo[0], ARRAY_SIZE(mObjectInfo));\n    }\n\n    int deleteStageRes(const char* name) {\n        return deleteRes(name, &mStageInfo[0], ARRAY_SIZE(mStageInfo));\n    }\n\n    void* getStageRes(const char* arcName, const char* resName) {\n        return getRes(arcName, resName, &mStageInfo[0], ARRAY_SIZE(mStageInfo));\n    }\n\n    dRes_info_c* getObjectResInfo(const char* arcName) {\n        return getResInfo(arcName, &mObjectInfo[0], ARRAY_SIZE(mObjectInfo));\n    }\n\n    dRes_info_c* getStageResInfo(const char* arcName) {\n        return getResInfo(arcName, &mStageInfo[0], ARRAY_SIZE(mStageInfo));\n    }\n\n    /* 0x0000 */ dRes_info_c mObjectInfo[0x80];\n    /* 0x1200 */ dRes_info_c mStageInfo[0x40];\n};  // Size: 0x1B00\n\n#endif /* D_D_RESORCE_H */\n/* end \"d/d_resorce.h\" */\n/* \"include/d/com/d_com_inf_game.h\" line 7 \"d/d_vibration.h\" */\n#ifndef D_D_VIBRATION_H\n#define D_D_VIBRATION_H\n\n/* \"include/d/d_vibration.h\" line 3 \"SSystem/SComponent/c_xyz.h\" */\n/* end \"SSystem/SComponent/c_xyz.h\" */\n/* \"include/d/d_vibration.h\" line 4 \"d/d_vib_pattern.h\" */\n#ifndef D_D_VIB_PATTERN_H\n#define D_D_VIB_PATTERN_H\n\n/* \"include/d/d_vib_pattern.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass dVibration_pattern {\npublic:\n    u16 field_0x00;\n    u16 field_0x02;\n    u32 field_0x04;\n};\n\n#endif /* D_D_VIB_PATTERN_H */\n/* end \"d/d_vib_pattern.h\" */\n\nclass dVibration_c {\npublic:\n    /* 8006F268 */ int Run();\n    /* 8006FA24 */ bool StartShock(int i_strength, int, cXyz);\n    /* 8006FC0C */ bool StartQuake(u8 const*, int, int, cXyz);\n    /* 8006FB10 */ bool StartQuake(int, int, cXyz);\n    /* 8006FD94 */ int StopQuake(int);\n    /* 8006FE00 */ void Kill();\n    /* 8006FE5C */ bool CheckQuake();\n    /* 8006FE84 */ void setDefault();\n    /* 8006FF04 */ void Init();\n    /* 8006FF38 */ void Pause();\n    /* 8006FFF8 */ void Remove();\n\n    static dVibration_pattern const MS_patt[11];\n    static dVibration_pattern const CS_patt[11];\n    static dVibration_pattern const MQ_patt[10];\n    static dVibration_pattern const CQ_patt[10];\n\nprivate:\n    class {\n    public:\n        class {\n        public:\n            /* 0x00 */ u32 field_0x0; \n            /* 0x04 */ s32 field_0x4;\n            /* 0x08 */ s32 field_0x8;\n            /* 0x0C */ s32 field_0xc;\n            /* 0x10 */ s32 field_0x10;\n            /* 0x14 */ s32 field_0x14;\n            /* 0x18 */ cXyz field_0x18;\n            /* 0x24 */ s32 field_0x24;\n        } mShock, mQuake;\n    } /* 0x00 */ field_0x0;\n    /* 0x50 */ u32 field_0x50;\n    /* 0x54 */ int field_0x54;\n    /* 0x58 */ s32 field_0x58;\n    /* 0x5C */ s32 field_0x5c;\n    /* 0x60 */ s32 field_0x60;\n    /* 0x64 */ s32 field_0x64;\n    /* 0x68 */ s32 field_0x68;\n    /* 0x6C */ u32 field_0x6c;\n    /* 0x70 */ s32 field_0x70;\n    /* 0x74 */ u32 field_0x74;\n    /* 0x78 */ u32 field_0x78;\n    /* 0x7C */ s32 field_0x7c;\n    /* 0x80 */ s32 field_0x80;\n    /* 0x84 */ s32 field_0x84;\n    /* 0x88 */ s32 field_0x88;\n    /* 0x8C */ s32 field_0x8c;\n};  // Size: 0x90\n\n#endif /* D_D_VIBRATION_H */\n/* end \"d/d_vibration.h\" */\n/* \"include/d/com/d_com_inf_game.h\" line 8 \"d/event/d_event.h\" */\n#ifndef D_EVENT_D_EVENT_H\n#define D_EVENT_D_EVENT_H\n\n/* \"include/d/event/d_event.h\" line 3 \"d/a/d_a_itembase.h\" */\n#ifndef D_A_D_A_ITEMBASE_H\n#define D_A_D_A_ITEMBASE_H\n\n/* \"include/d/a/d_a_itembase.h\" line 3 \"SSystem/SComponent/c_phase.h\" */\n#ifndef C_PHASE_H\n#define C_PHASE_H\n\n/* \"include/SSystem/SComponent/c_phase.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef int (*cPhs__Handler)(void*);\n\nenum cPhs__Step {\n    /* 0x0 */ cPhs_INIT_e,\n    /* 0x1 */ cPhs_LOADING_e,\n    /* 0x2 */ cPhs_NEXT_e,\n    /* 0x3 */ cPhs_UNK3_e,  // appears to be an alternate error code, unsure how it differs\n    /* 0x4 */ cPhs_COMPLEATE_e,\n    /* 0x5 */ cPhs_ERROR_e,\n};\n\ntypedef struct request_of_phase_process_class {\n    cPhs__Handler* mpHandlerTable;\n    int id;\n} request_of_phase_process_class;\n\ntypedef int (*request_of_phase_process_fn)(void*);\n\nvoid cPhs_Reset(request_of_phase_process_class* pPhase);\nvoid cPhs_Set(request_of_phase_process_class* pPhase, cPhs__Handler* pHandlerTable);\nvoid cPhs_UnCompleate(request_of_phase_process_class* pPhase);\nint cPhs_Compleate(request_of_phase_process_class* pPhase);\nint cPhs_Next(request_of_phase_process_class* pPhase);\nint cPhs_Do(request_of_phase_process_class* pPhase, void* pUserData);\nint cPhs_Handler(request_of_phase_process_class* pPhase, cPhs__Handler* pHandlerTable,\n                 void* pUserData);\n\n#endif /* C_PHASE_H */\n/* end \"SSystem/SComponent/c_phase.h\" */\n/* \"include/d/a/d_a_itembase.h\" line 4 \"d/bg/d_bg_s_acch.h\" */\n#ifndef D_BG_D_BG_S_ACCH_H\n#define D_BG_D_BG_S_ACCH_H\n\n/* \"include/d/bg/d_bg_s_acch.h\" line 3 \"SSystem/SComponent/c_m3d_g_cir.h\" */\n#ifndef C_M3D_G_CIR_H\n#define C_M3D_G_CIR_H\n\n/* \"include/SSystem/SComponent/c_m3d_g_cir.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass cM2dGCir {\npublic:\n    f32 mPosX;\n    f32 mPosY;\n    f32 mRadius;\n    \n    f32 GetCx() const { return mPosX; }\n    f32 GetCy() const { return mPosY; }\n    f32 GetR() const { return mRadius; }\n\n    cM2dGCir() {}\n    virtual ~cM2dGCir() {}\n};\n\nclass cM3dGCir : public cM2dGCir {\n    f32 mPosZ;\n\npublic:\n    cM3dGCir(void);\n    virtual ~cM3dGCir(void);\n    void Set(f32, f32, f32, f32);\n};\n\n#endif /* C_M3D_G_CIR_H */\n/* end \"SSystem/SComponent/c_m3d_g_cir.h\" */\n/* \"include/d/bg/d_bg_s_acch.h\" line 4 \"SSystem/SComponent/c_m3d_g_cyl.h\" */\n/* end \"SSystem/SComponent/c_m3d_g_cyl.h\" */\n/* \"include/d/bg/d_bg_s_acch.h\" line 5 \"SSystem/SComponent/c_m3d_g_lin.h\" */\n/* end \"SSystem/SComponent/c_m3d_g_lin.h\" */\n/* \"include/d/bg/d_bg_s_acch.h\" line 6 \"SSystem/SComponent/c_m3d_g_pla.h\" */\n/* end \"SSystem/SComponent/c_m3d_g_pla.h\" */\n/* \"include/d/bg/d_bg_s_acch.h\" line 7 \"d/bg/d_bg_s_gnd_chk.h\" */\n#ifndef D_BG_D_BG_S_GND_CHK_H\n#define D_BG_D_BG_S_GND_CHK_H\n\n/* \"include/d/bg/d_bg_s_gnd_chk.h\" line 3 \"SSystem/SComponent/c_bg_s_gnd_chk.h\" */\n#ifndef C_BG_S_GND_CHK_H\n#define C_BG_S_GND_CHK_H\n\n/* \"include/SSystem/SComponent/c_bg_s_gnd_chk.h\" line 3 \"SSystem/SComponent/c_bg_s_chk.h\" */\n#ifndef C_BG_S_CHK_H\n#define C_BG_S_CHK_H\n\n/* \"include/SSystem/SComponent/c_bg_s_chk.h\" line 3 \"dolphin/mtx/vec.h\" */\n/* end \"dolphin/mtx/vec.h\" */\n\nstruct cBgD_Vtx_t : public Vec {};\n\nclass cBgS_GrpPassChk {\npublic:\n    virtual ~cBgS_GrpPassChk();\n};\n\nclass cBgS_PolyPassChk;\n\nclass cBgS_Chk {\nprivate:\n    /* 0x0 */ cBgS_PolyPassChk* mPolyPassChk;\n    /* 0x4 */ cBgS_GrpPassChk* mGrpPassChk;\n    /* 0x8 */ u32 mActorPid;\n    /* 0xC */ u8 unk_0x0C;\n    /* 0x10 */  // __vtable__\n\npublic:\n    cBgS_Chk();\n    void SetExtChk(cBgS_Chk&);\n    bool ChkSameActorPid(unsigned int) const;\n\n    void SetActorPid(u32 pid) { mActorPid = pid; }\n    u32 GetActorPid() const { return mActorPid; }\n    void SetPolyPassChk(cBgS_PolyPassChk* p_chk) { mPolyPassChk = p_chk; }\n    void SetGrpPassChk(cBgS_GrpPassChk* p_chk) { mGrpPassChk = p_chk; }\n    cBgS_PolyPassChk* GetPolyPassChk() const { return mPolyPassChk; }\n    cBgS_GrpPassChk* GetGrpPassChk() const { return mGrpPassChk; }\n\n    virtual ~cBgS_Chk(void);\n};  // Size: 0x14\n\n#endif /* C_BG_S_CHK_H */\n/* end \"SSystem/SComponent/c_bg_s_chk.h\" */\n/* \"include/SSystem/SComponent/c_bg_s_gnd_chk.h\" line 4 \"SSystem/SComponent/c_bg_s_poly_info.h\" */\n/* end \"SSystem/SComponent/c_bg_s_poly_info.h\" */\n/* \"include/SSystem/SComponent/c_bg_s_gnd_chk.h\" line 5 \"SSystem/SComponent/c_xyz.h\" */\n/* end \"SSystem/SComponent/c_xyz.h\" */\n\nclass cBgS_GndChk : public cBgS_Chk, public cBgS_PolyInfo {\npublic:\n    /* 80267C1C */ cBgS_GndChk();\n    /* 80267D28 */ void SetPos(cXyz const*);\n    /* 80267D0C */ void SetPos(Vec const*);\n    /* 80267D44 */ void PreCheck();\n\n    /* 80267C94 */ virtual ~cBgS_GndChk();\n\n    f32 GetNowY() const { return mNowY; }\n    void SetNowY(f32 y) { mNowY = y; }\n    const cXyz& GetPointP() { return m_pos; }\n    u32 GetWallPrecheck() const { return mWallPrecheck; }\n    void OffWall() { mFlags &= ~2; }\n\n    /* 0x24 */ cXyz m_pos;\n    /* 0x30 */ u32 mFlags;\n    /* 0x34 */ f32 mNowY;\n    /* 0x38 */ u32 mWallPrecheck;\n};\n\n#endif /* C_BG_S_GND_CHK_H */\n/* end \"SSystem/SComponent/c_bg_s_gnd_chk.h\" */\n/* \"include/d/bg/d_bg_s_gnd_chk.h\" line 4 \"d/bg/d_bg_s_chk.h\" */\n#ifndef D_BG_D_BG_S_CHK_H\n#define D_BG_D_BG_S_CHK_H\n\n/* \"include/d/bg/d_bg_s_chk.h\" line 3 \"d/bg/d_bg_s_grp_pass_chk.h\" */\n#ifndef D_BG_D_BG_S_GRP_PASS_CHK_H\n#define D_BG_D_BG_S_GRP_PASS_CHK_H\n\n/* \"include/d/bg/d_bg_s_grp_pass_chk.h\" line 3 \"SSystem/SComponent/c_bg_s_chk.h\" */\n/* end \"SSystem/SComponent/c_bg_s_chk.h\" */\n\nclass dBgS_GrpPassChk : public cBgS_GrpPassChk {\npublic:\n    enum {\n        /* 0x1 */ NORMAL_GRP = 1,\n        /* 0x2 */ WATER_GRP,\n        /* 0x3 */ FULL_GRP\n    };\n\n    /* 80077BA0 */ dBgS_GrpPassChk();\n\n    /* 80077BC4 */ virtual ~dBgS_GrpPassChk();\n\n    void OnWaterGrp() { mGrp |= WATER_GRP; }\n    void OnSpl() { mGrp |= WATER_GRP; }\n    void OnNormalGrp() { mGrp |= NORMAL_GRP; }\n    void OffNormalGrp() { mGrp &= ~NORMAL_GRP; }\n    void OffFullGrp() { mGrp &= ~FULL_GRP; }\n    void OnAll() { mGrp |= FULL_GRP; }\n    u32 MaskNormalGrp() const {return mGrp & 1; }\n    u32 MaskWaterGrp() const {return mGrp & 2; }\nprivate:\n    /* 0x4 */ u32 mGrp;\n};\n\n#endif /* D_BG_D_BG_S_GRP_PASS_CHK_H */\n/* end \"d/bg/d_bg_s_grp_pass_chk.h\" */\n/* \"include/d/bg/d_bg_s_chk.h\" line 4 \"d/bg/d_bg_s_poly_pass_chk.h\" */\n#ifndef D_BG_D_BG_S_POLY_PASS_CHK_H\n#define D_BG_D_BG_S_POLY_PASS_CHK_H\n\n/* \"include/d/bg/d_bg_s_poly_pass_chk.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass cBgS_PolyPassChk {\npublic:\n    virtual ~cBgS_PolyPassChk();\n};\n\nclass dBgS_PolyPassChk : public cBgS_PolyPassChk {\npublic:\n    dBgS_PolyPassChk();\n    virtual ~dBgS_PolyPassChk();\n\n    bool ChkArrow() { return mArrow; }\n    bool ChkBomb() { return mBomb; }\n    bool ChkBoomerang() { return mBoomerang; }\n    bool ChkCam() { return mCamera; }\n    bool ChkHorse() { return mHorse; }\n    bool ChkIronBall() { return mIronBall; }\n    bool ChkLink() { return mLink; }\n    bool ChkNoHorse();\n    bool ChkObj() { return mObject; }\n    bool ChkRope() { return mRope; }\n    bool ChkStatue() { return mStatue; }\n    bool ChkUnderwaterRoof() { return mUnderwaterRoof; }\n\n    void ClrBomb();\n    void ClrCam();\n    void ClrIronBall();\n    void ClrLink();\n    void ClrObj();\n    void ClrStatue();\n\n    void SetArrow();\n    void SetBomb();\n    void SetBoomerang();\n    void SetCam();\n    void SetHorse();\n    void SetIronBall();\n    void SetLink();\n    void SetObj();\n    void SetPassChkInfo(dBgS_PolyPassChk& chk);\n    void SetRope();\n    void SetStatue();\n    void SetUnderwaterRoof();\n\nprivate:\n    /* 0x4 */ bool mObject;\n    /* 0x5 */ bool mCamera;\n    /* 0x6 */ bool mLink;\n    /* 0x7 */ bool mArrow;\n    /* 0x8 */ bool mBomb;\n    /* 0x9 */ bool mBoomerang;\n    /* 0xA */ bool mRope;\n    /* 0xB */ bool mUnderwaterRoof;\n    /* 0xC */ bool mHorse;\n    /* 0xD */ bool mStatue;\n    /* 0xE */ bool mIronBall;\n};\n\n#endif /* D_BG_D_BG_S_POLY_PASS_CHK_H */\n/* end \"d/bg/d_bg_s_poly_pass_chk.h\" */\n\nclass dBgS_Chk : public dBgS_PolyPassChk, public dBgS_GrpPassChk {\npublic:\n    /* 8007749C */ dBgS_Chk();\n    /* 80077560 */ cBgS_PolyPassChk* GetPolyPassChkInfo();\n    /* 80077564 */ cBgS_GrpPassChk* GetGrpPassChkInfo();\n\n    /* 800774E8 */ virtual ~dBgS_Chk();\n};  // Size: 0x18\n\n#endif /* D_BG_D_BG_S_CHK_H */\n/* end \"d/bg/d_bg_s_chk.h\" */\n\nclass dBgS_GndChk : public cBgS_GndChk, public dBgS_Chk {\npublic:\n    /* 8007757C */ dBgS_GndChk();\n    /* 800775F0 */ virtual ~dBgS_GndChk();\n};  // Size: 0x54\n\nclass dBgS_LinkGndChk : public dBgS_GndChk {\npublic:\n    dBgS_LinkGndChk() { SetLink(); }\n    /* 80140EB8 */ virtual ~dBgS_LinkGndChk() {}\n};\n\nclass dBgS_ObjGndChk : public dBgS_GndChk {\npublic:\n    dBgS_ObjGndChk() { SetObj(); }\n\n    /* 8001E020 */ virtual ~dBgS_ObjGndChk(); // should be inlined\n};\n\nclass dBgS_ObjGndChk_Wtr : public dBgS_ObjGndChk {\npublic:\n    /* 80077678 */ dBgS_ObjGndChk_Wtr();\n\n    /* 80077710 */ virtual ~dBgS_ObjGndChk_Wtr();\n};\n\nclass dBgS_ObjGndChk_Spl : public dBgS_ObjGndChk {\npublic:\n    /* 800777B0 */ dBgS_ObjGndChk_Spl();\n\n    /* 80077848 */ virtual ~dBgS_ObjGndChk_Spl();\n};\n\nclass dBgS_ObjGndChk_All : public dBgS_ObjGndChk {\npublic:\n    /* 800778E8 */ virtual ~dBgS_ObjGndChk_All();\n\n    dBgS_ObjGndChk_All() { OnAll(); }\n};\n\nclass dBgS_CamGndChk : public dBgS_GndChk {\npublic:\n    dBgS_CamGndChk() { SetCam(); }\n\n    /* 80077988 */ virtual ~dBgS_CamGndChk();\n};\n\nclass dBgS_CamGndChk_Wtr : public dBgS_CamGndChk {\npublic:\n    /* 80077A00 */ dBgS_CamGndChk_Wtr();\n\n    /* 80077A98 */ virtual ~dBgS_CamGndChk_Wtr();\n};\n\n#endif /* D_BG_D_BG_S_GND_CHK_H */\n/* end \"d/bg/d_bg_s_gnd_chk.h\" */\n/* \"include/d/bg/d_bg_s_acch.h\" line 8 \"d/bg/d_bg_s_roof_chk.h\" */\n#ifndef D_BG_D_BG_S_ROOF_CHK_H\n#define D_BG_D_BG_S_ROOF_CHK_H\n\n/* \"include/d/bg/d_bg_s_roof_chk.h\" line 3 \"SSystem/SComponent/c_bg_s_poly_info.h\" */\n/* end \"SSystem/SComponent/c_bg_s_poly_info.h\" */\n/* \"include/d/bg/d_bg_s_roof_chk.h\" line 4 \"SSystem/SComponent/c_xyz.h\" */\n/* end \"SSystem/SComponent/c_xyz.h\" */\n/* \"include/d/bg/d_bg_s_roof_chk.h\" line 5 \"d/bg/d_bg_s_chk.h\" */\n/* end \"d/bg/d_bg_s_chk.h\" */\n/* \"include/d/bg/d_bg_s_roof_chk.h\" line 6 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass dBgS_RoofChk : public cBgS_PolyInfo, public cBgS_Chk, public dBgS_Chk {\npublic:\n    /* 80078FF4 */ dBgS_RoofChk();\n    /* 80079124 */ void Init();\n    /* 800B146C */ void SetPos(cXyz const&);\n\n    /* 80079090 */ virtual ~dBgS_RoofChk();\n\n    void SetNowY(f32 y) { mNowY = y; }\n    void i_SetPos(cXyz const& pos) { m_pos = pos; }\n    f32 GetNowY() { return mNowY; }\n    cXyz* GetPosP() { return &m_pos; }\n\nprivate:\n    /* 0x3C */ cXyz m_pos;\n    /* 0x48 */ int field_0x48;\n    /* 0x4C */ f32 mNowY;\n};  // Size: 0x50\n\nclass dBgS_LinkRoofChk : public dBgS_RoofChk {\npublic:\n    dBgS_LinkRoofChk() { SetLink(); }\n    /* 80140E40 */ virtual ~dBgS_LinkRoofChk() {}\n};\n\n#endif /* D_BG_D_BG_S_ROOF_CHK_H */\n/* end \"d/bg/d_bg_s_roof_chk.h\" */\n/* \"include/d/bg/d_bg_s_acch.h\" line 9 \"d/bg/d_bg_s_wtr_chk.h\" */\n#ifndef D_BG_D_BG_S_WTR_CHK_H\n#define D_BG_D_BG_S_WTR_CHK_H\n\n/* \"include/d/bg/d_bg_s_wtr_chk.h\" line 3 \"d/bg/d_bg_s_spl_grp_chk.h\" */\n#ifndef D_BG_D_BG_S_SPL_GRP_CHK_H\n#define D_BG_D_BG_S_SPL_GRP_CHK_H\n\n/* \"include/d/bg/d_bg_s_spl_grp_chk.h\" line 3 \"SSystem/SComponent/c_bg_s_poly_info.h\" */\n/* end \"SSystem/SComponent/c_bg_s_poly_info.h\" */\n/* \"include/d/bg/d_bg_s_spl_grp_chk.h\" line 4 \"SSystem/SComponent/c_xyz.h\" */\n/* end \"SSystem/SComponent/c_xyz.h\" */\n/* \"include/d/bg/d_bg_s_spl_grp_chk.h\" line 5 \"d/bg/d_bg_s_chk.h\" */\n/* end \"d/bg/d_bg_s_chk.h\" */\n/* \"include/d/bg/d_bg_s_spl_grp_chk.h\" line 6 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass dBgS_SplGrpChk : public cBgS_PolyInfo, public cBgS_Chk, public dBgS_Chk {\npublic:\n    enum {\n        /* 0x1 */ FIND = 1,\n        /* 0x2 */ IN = 2,\n        /* 0x4 */ MOVE_BG_ONLY = 4\n    };\n\n    /* 80078B90 */ void Set(cXyz&, f32);\n    /* 80078BB0 */ dBgS_SplGrpChk();\n    /* 80078D0C */ void Init();\n\n    /* 80078C78 */ virtual ~dBgS_SplGrpChk();\n\n    void OffFind() { m_flags &= ~FIND; }\n    void OffIn() { m_flags &= ~IN; }\n    void OffMoveBGOnly() { m_flags &= ~MOVE_BG_ONLY; }\n    void OnMoveBGOnly() { m_flags |= MOVE_BG_ONLY; }\n    void OnFind() { m_flags |= FIND; }\n    bool ChkMoveBGOnly() { return m_flags & MOVE_BG_ONLY; }\n    void SetHeight(f32 height) { m_height = height; }\n    f32 GetHeight() { return m_height; }\n    cXyz& GetPosP() { return m_ground; }\n    f32 GetRoof() const { return m_roof; }\n\nprivate:\n    /* 0x3C */ cXyz m_ground;\n    /* 0x48 */ f32 m_roof;\n    /* 0x4C */ f32 m_height;\n    /* 0x50 */ u32 m_flags;\n};  // Size: 0x54\n\n#endif /* D_BG_D_BG_S_SPL_GRP_CHK_H */\n/* end \"d/bg/d_bg_s_spl_grp_chk.h\" */\n\nclass dBgS_WtrChk : public dBgS_SplGrpChk {\npublic:\n    /* 80079164 */ dBgS_WtrChk();\n\n    /* 8001DF30 */ virtual ~dBgS_WtrChk();\n};  // Size: 0x54\n\n#endif /* D_BG_D_BG_S_WTR_CHK_H */\n/* end \"d/bg/d_bg_s_wtr_chk.h\" */\n/* \"include/d/bg/d_bg_s_acch.h\" line 10 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass fopAc_ac_c;\n\nclass dBgS_AcchCir : public cBgS_PolyInfo {\nprivate:\n    /* 0x10 */ u32 m_flags;\n    /* 0x14 */ cM3dGCir m_cir;\n    /* 0x28 */ f32 m_wall_rr;\n    /* 0x2C */ f32 field_0x2c;\n    /* 0x30 */ f32 m_wall_h;\n    /* 0x34 */ f32 m_wall_r;\n    /* 0x38 */ f32 m_wall_h_direct;\n    /* 0x3C */ s16 m_wall_angle_y;\n\npublic:\n    enum {\n        /* 0x2 */ WALL_HIT = 2,\n        /* 0x4 */ WALL_H_DIRECT = 4,\n    };\n\n    /* 80075EAC */ dBgS_AcchCir();\n    /* 80075F14 */ void ClrWallHit();\n    /* 80075F40 */ void SetWallR(f32);\n    /* 80075F48 */ void CalcWallRR();\n    /* 80075F58 */ void SetWall(f32, f32);\n    /* 80075F80 */ void SetWallHDirect(f32);\n\n    #ifdef __dt__12dBgS_AcchCirFv_DEFINED\n    /* 80077414 */ virtual ~dBgS_AcchCir();\n    #else\n    /* 80077414 */ virtual ~dBgS_AcchCir() {}\n    #endif\n\n    f32 GetWallH() { return m_wall_h; }\n    f32 GetWallR() { return m_wall_r; }\n    void SetWallH(f32 h) { m_wall_h = h; }\n    void ClrWallHDirect() { m_flags &= ~WALL_H_DIRECT; }\n    bool ChkWallHit() { return m_flags & WALL_HIT; }\n    s16 GetWallAngleY() { return m_wall_angle_y; }\n\n    void SetCir(cXyz& pos) { m_cir.Set(pos.x, pos.z, pos.y + GetWallH(), m_wall_r); }\n};  // Size: 0x40\n\nclass dBgS;\nclass dBgS_Acch : public cBgS_Chk, public dBgS_Chk {\npublic:\n    enum {\n        /* 0x000002 */ GRND_NONE = (1 << 1),\n        /* 0x000004 */ WALL_NONE = (1 << 2),\n        /* 0x000008 */ ROOF_NONE = (1 << 3),\n        /* 0x000010 */ WALL_HIT = (1 << 4),\n        /* 0x000020 */ GROUND_HIT = (1 << 5),\n        /* 0x000040 */ GROUND_FIND = (1 << 6),\n        /* 0x000080 */ GROUND_LANDING = (1 << 7),\n        /* 0x000100 */ GROUND_AWAY = (1 << 8),\n        /* 0x000200 */ ROOF_HIT = (1 << 9),\n        /* 0x000400 */ WATER_NONE = (1 << 10),\n        /* 0x000800 */ WATER_HIT = (1 << 11),\n        /* 0x001000 */ WATER_IN = (1 << 12),\n        /* 0x002000 */ LINE_CHECK = (1 << 13),\n        /* 0x004000 */ LINE_CHECK_NONE = (1 << 14),\n        /* 0x008000 */ CLR_SPEED_Y = (1 << 15),\n        /* 0x010000 */ LINE_CHECK_HIT = (1 << 16),\n        /* 0x100000 */ MOVE_BG_ONLY = (1 << 20),\n        /* 0x200000 */ GND_THIN_CELLING_OFF = (1 << 21),\n        /* 0x400000 */ WALL_SORT = (1 << 22),\n        /* 0x800000 */ LINE_DOWN = (1 << 23),\n    };\n\n    /* 800760A0 */ dBgS_Acch();\n    /* 800761CC */ void Init();\n    /* 80076288 */ void Set(fopAc_ac_c*, int, dBgS_AcchCir*);\n    /* 80076248 */ void Set(cXyz*, cXyz*, fopAc_ac_c*, int, dBgS_AcchCir*, cXyz*, csXyz*, csXyz*);\n    /* 800762D8 */ void GroundCheckInit(dBgS&);\n    /* 80076350 */ void GroundCheck(dBgS&);\n    /* 8007654C */ void GroundRoofProc(dBgS&);\n    /* 80076624 */ void LineCheck(dBgS&);\n    /* 80076AAC */ void CrrPos(dBgS&);\n    /* 80076F84 */ f32 GetWallAllR();\n    /* 80076FC0 */ void SetWallCir();\n    /* 8007703C */ void CalcWallBmdCyl();\n    /* 80077114 */ void SetGroundUpY(f32);\n    /* 80077128 */ f32 GetWallAllLowH();\n    /* 80077178 */ f32 GetWallAllLowH_R();\n    /* 800771E4 */ f32 GetSpeedY();\n    /* 80077200 */ f32 GetWallAddY(Vec&);\n    /* 80077278 */ void SetNowActorInfo(int, void*, unsigned int);\n    /* 80077288 */ void SetWallPolyIndex(int, int);\n    /* 800772E8 */ void CalcMovePosWork();\n    /* 8007732C */ void CalcWallRR();\n    /* 80077388 */ void SetMoveBGOnly();\n    /* 800773A4 */ void ClrMoveBGOnly();\n    /* 800773C0 */ void SetGndThinCellingOff();\n    /* 800773D0 */ void ClrGndThinCellingOff();\n    /* 800773E0 */ bool ChkGndThinCellingOff();\n    /* 800773EC */ void OnWallSort();\n    /* 800773FC */ bool ChkWallSort();\n    /* 80077408 */ bool ChkLineDown();\n    /* 800D00D0 */ bool ChkRoofHit() const;\n    /* 800D00DC */ void ClrGroundHit();\n    /* 80141404 */ bool ChkGroundHit() const;\n\n    /* 80075F94 */ virtual ~dBgS_Acch();\n\n    cXyz* GetPos() { return pm_pos; }\n    cXyz* GetOldPos() { return pm_old_pos; }\n    f32 GetGroundH() const { return m_ground_h; }\n    f32 GetRoofHeight() const { return m_roof_height; }\n    void SetLin() { m_lin.SetStartEnd(*pm_old_pos, *pm_pos); }\n    bool ChkGroundFind() { return m_flags & GROUND_FIND; }\n    bool ChkGroundHit() { return m_flags & GROUND_HIT; }\n    bool ChkGroundLanding() { return m_flags & GROUND_LANDING; }\n    void ClrGroundLanding() { m_flags &= ~GROUND_LANDING; }\n    void ClrGroundAway() { m_flags &= ~GROUND_AWAY; }\n    void ClrWallHit() { m_flags &= ~WALL_HIT; }\n    void SetRoofNone() { m_flags |= ROOF_NONE; }\n    void SetRoofHit() { m_flags |= ROOF_HIT; }\n    void SetWaterNone() { m_flags |= WATER_NONE; }\n    bool ChkWallHit() { return m_flags & WALL_HIT; }\n    void OffLineCheckHit() { m_flags &= ~LINE_CHECK_HIT; }\n    void OffLineCheck() { m_flags &= ~LINE_CHECK; }\n    bool ChkLineCheckNone() { return m_flags & LINE_CHECK_NONE; }\n    bool ChkLineCheck() { return m_flags & LINE_CHECK; }\n    void ClrRoofHit() { m_flags &= ~ROOF_HIT; }\n    void ClrWaterHit() { m_flags &= ~WATER_HIT; }\n    void SetWaterHit() { m_flags |= WATER_HIT; }\n    void ClrWaterIn() { m_flags &= ~WATER_IN; }\n    void SetWaterIn() { m_flags |= WATER_IN; }\n    const u32 MaskWaterIn() { return m_flags & WATER_IN; }\n    const bool ChkWaterIn() { return MaskWaterIn();}\n    void ClrGroundFind() { m_flags &= ~GROUND_FIND; }\n    u32 MaskRoofHit() { return m_flags & ROOF_HIT; }\n    bool ChkRoofHit() { return MaskRoofHit(); }\n    bool ChkClrSpeedY() { return m_flags & CLR_SPEED_Y; }\n    void SetGroundFind() { m_flags |= GROUND_FIND; }\n    void SetGroundHit() { m_flags |= GROUND_HIT; }\n    void SetGroundLanding() { m_flags |= GROUND_LANDING; }\n    void SetGroundAway() { m_flags |= GROUND_AWAY; }\n    const u32 MaskWaterHit() { return m_flags & WATER_HIT; }\n    const bool ChkWaterHit() { return MaskWaterHit(); }\n    void ClrWaterNone() { m_flags &= ~WATER_NONE; }\n    void SetWaterCheckOffset(f32 offset) { m_wtr_chk_offset = offset; }\n    void OnLineCheck() { m_flags |= LINE_CHECK; }\n    void ClrRoofNone() { m_flags &= ~ROOF_NONE; }\n    void SetRoofCrrHeight(f32 height) { m_roof_crr_height = height; }\n    void SetWtrChkMode(int mode) { m_wtr_mode = mode; }\n    void SetGrndNone() { m_flags |= GRND_NONE; }\n    void ClrGrndNone() { m_flags &= ~GRND_NONE; }\n    bool ChkMoveBGOnly() const { return m_flags & MOVE_BG_ONLY; }\n    void SetWallHit() { m_flags |= WALL_HIT; }\n    void ClrWallNone() { m_flags &= ~WALL_NONE; }\n    void OnLineCheckNone() { m_flags |= LINE_CHECK_NONE; }\n    void OffLineCheckNone() { m_flags &= ~LINE_CHECK_NONE; }\n    void SetWallNone() { m_flags |= WALL_NONE; }\n    cM3dGCyl* GetWallBmdCylP() { return &m_wall_cyl; }\n\n    // inline dupe\n    void i_ClrGroundHit() { m_flags &= ~GROUND_HIT; }\n    bool i_ChkGroundHit() const { return m_flags & GROUND_HIT; }\n\npublic:\n    /* 0x02C */ u32 m_flags;\n    /* 0x030 */ cXyz* pm_pos;\n    /* 0x034 */ cXyz* pm_old_pos;\n    /* 0x038 */ cXyz* pm_speed;\n    /* 0x03C */ csXyz* pm_angle;\n    /* 0x040 */ csXyz* pm_shape_angle;\n    /* 0x044 */ cM3dGLin m_lin;\n    /* 0x060 */ cM3dGCyl m_wall_cyl;\n    /* 0x078 */ int m_bg_index;\n    /* 0x07C */ void* field_0x7c;\n    /* 0x080 */ u32 field_0x80;\n    /* 0x084 */ fopAc_ac_c* m_my_ac;\n    /* 0x088 */ int m_tbl_size;\n    /* 0x08C */ dBgS_AcchCir* field_0x8c;\n    /* 0x090 */ f32 field_0x90;\n    /* 0x094 */ f32 field_0x94;\n    /* 0x098 */ f32 m_ground_h;\n    /* 0x09C */ f32 field_0x9c;\n    /* 0x0A0 */ cM3dGPla field_0xa0;\n    /* 0x0B4 */ u8 field_0xb4;\n    /* 0x0B8 */ f32 field_0xb8;\n    /* 0x0BC */ f32 field_0xbc;\n    /* 0x0C0 */ u8 field_0xc0;\n    /* 0x0C4 */ f32 m_roof_height;\n    /* 0x0C8 */ f32 m_roof_crr_height;\n    /* 0x0CC */ f32 field_0xcc;\n    /* 0x0D0 */ f32 m_wtr_chk_offset;\n    /* 0x0D4 */ int field_0xd4;\n    /* 0x0D8 */ f32 field_0xd8;\n    /* 0x0DC */ dBgS_GndChk m_gnd;\n    /* 0x130 */ dBgS_RoofChk m_roof;\n    /* 0x180 */ dBgS_WtrChk m_wtr;\n    /* 0x1D4 */ u8 m_wtr_mode;\n};\n\nclass dBgS_LinkAcch : public dBgS_Acch {\npublic:\n    dBgS_LinkAcch() { SetLink(); }\n\n    /* 80140F30 */ virtual ~dBgS_LinkAcch() {}\n};\n\nclass dBgS_ObjAcch : public dBgS_Acch {\npublic:\n    dBgS_ObjAcch() {\n        SetObj();\n    }\n\n    /* 80BB336C */ virtual ~dBgS_ObjAcch() {}\n};\n\nclass dBgS_StatueAcch : public dBgS_Acch {\npublic:\n    dBgS_StatueAcch() {\n        SetStatue();\n    }\n\n    /* 806646F8 */ virtual ~dBgS_StatueAcch();\n};\n\n#endif /* D_BG_D_BG_S_ACCH_H */\n/* end \"d/bg/d_bg_s_acch.h\" */\n/* \"include/d/a/d_a_itembase.h\" line 5 \"d/cc/d_cc_d.h\" */\n#ifndef D_CC_D_CC_D_H\n#define D_CC_D_CC_D_H\n\n/**\n * d_cc_d.h\n * Actor Collision\n */\n\n/* \"include/d/cc/d_cc_d.h\" line 8 \"SSystem/SComponent/c_cc_d.h\" */\n/* end \"SSystem/SComponent/c_cc_d.h\" */\n/* \"include/d/cc/d_cc_d.h\" line 9 \"Z2AudioLib/Z2SeMgr.h\" */\n/* end \"Z2AudioLib/Z2SeMgr.h\" */\n\nenum dCcD_hitSe {\n    /* 0  */ dCcD_SE_NONE,\n    /* 1  */ dCcD_SE_SWORD,\n    /* 2  */ dCcD_SE_SHIELD_ATTACK,\n    /* 3  */ dCcD_SE_WOLF_KICK,\n    /* 4  */ dCcD_SE_WOLF_BITE,\n    /* 5  */ dCcD_SE_WOOD,\n    /* 6  */ dCcD_SE_HAMMER,\n    /* 7  */ dCcD_SE_ARROW_STICK,\n    /* 8  */ dCcD_SE_HOOKSHOT_STICK,\n    /* 9  */ dCcD_SE_METAL,\n    /* 10 */ dCcD_SE_STONE,\n    /* 11 */ dCcD_SE_HARD_BODY,\n    /* 12 */ dCcD_SE_SOFT_BODY,\n    /* 13 */ dCcD_SE_13,\n    /* 14 */ dCcD_SE_SWORD_STAB,\n    /* 15 */ dCcD_SE_15,\n    /* 16 */ dCcD_SE_SWORD_RUN,\n    /* 17 */ dCcD_SE_17,\n    /* 18 */ dCcD_SE_THROW_OBJ,\n    /* 19 */ dCcD_SE_SPINNER,\n    /* 20 */ dCcD_SE_COPYROD,\n    /* 21 */ dCcD_SE_STATUE_HAMMER,\n    /* 22 */ dCcD_SE_PACHINKO,\n    /* 23 */ dCcD_SE_23,\n};\n\nenum dCcG_At_Spl {\n    /* 0x0 */ dCcG_At_Spl_UNK_0,\n    /* 0x1 */ dCcG_At_Spl_UNK_1,\n};\n\nenum dCcG_Tg_Spl {\n    /* 0x0 */ dCcG_Tg_Spl_UNK_0,\n    /* 0x1 */ dCcG_Tg_Spl_UNK_1,\n};\n\nstruct dCcD_SrcGAtTgCoCommonBase {\n    /* 0x0 */ u32 mGFlag;\n};  // Size: 0x4\n\nstruct dCcD_SrcGObjAt {\n    /* 0x0 */ u8 mSe;       // Sound Effect ID\n    /* 0x1 */ u8 mHitMark;  // Hit Mark particle ID\n    /* 0x2 */ u8 mSpl;\n    /* 0x3 */ u8 mMtrl;\n    /* 0x4 */ dCcD_SrcGAtTgCoCommonBase mBase;\n};  // Size: 0x8\n\nstruct dCcD_SrcGObjTg {\n    /* 0x0 */ u8 mSe;       // Sound Effect ID\n    /* 0x1 */ u8 mHitMark;  // Hit Mark particle ID\n    /* 0x2 */ u8 mSpl;\n    /* 0x3 */ u8 mMtrl;\n    /* 0x4 */ dCcD_SrcGAtTgCoCommonBase mBase;\n};  // Size: 0x8\n\nstruct dCcD_SrcGObjCo {\n    /* 0x0 */ dCcD_SrcGAtTgCoCommonBase mBase;\n};  // Size: 0x4\n\nstruct dCcD_SrcGObjInf {\n    /* 0x00 */ cCcD_SrcObj mObj;\n    /* 0x1C */ dCcD_SrcGObjAt mGObjAt;\n    /* 0x24 */ dCcD_SrcGObjTg mGObjTg;\n    /* 0x2C */ dCcD_SrcGObjCo mGObjCo;\n};  // Size: 0x30\n\nstruct dCcD_SrcSph {\n    /* 0x00 */ dCcD_SrcGObjInf mObjInf;\n    /* 0x30 */ cCcD_SrcSphAttr mSphAttr;\n};  // Size: 0x40\n\nstruct dCcD_SrcTri {\n    /* 0x00 */ dCcD_SrcGObjInf mObjInf;\n    /* 0x30 */ cCcD_SrcTriAttr mTriAttr;\n};  // Size: 0x54\n\nstruct dCcD_SrcCyl {\n    /* 0x00 */ dCcD_SrcGObjInf mObjInf;\n    /* 0x30 */ cM3dGCylS mCyl;\n};  // Size: 0x44\n\nstruct dCcD_SrcCps {\n    /* 0x00 */ dCcD_SrcGObjInf mObjInf;\n    /* 0x30 */ cCcD_SrcCpsAttr mCpsAttr;\n};  // Size: 0x4C\n\nclass dCcD_GStts : public cCcD_GStts {\npublic:\n    /* 80083760 */ dCcD_GStts();\n    /* 800837F8 */ void Ct();\n    /* 80083830 */ void Move();\n    /* 8008523C */ virtual ~dCcD_GStts() {}\n    void ClrAt() { mAt = 0; }\n    void ClrTg() { mTg = 0; }\n    void SetAtApid(unsigned int id) { mAtApid = id; }\n    void SetTgApid(unsigned int id) { mTgApid = id; }\n    u8 GetRoomId() { return mRoomId; }\n    void SetRoomId(int id) { mRoomId = id; }\n    unsigned int GetAtOldApid() { return mAtOldApid; }\n    unsigned int GetTgOldApid() { return mTgOldApid; }\n    bool ChkNoActor() { return field_0x1C & 1;}\n    bool ChkNoneActorPerfTblId() { return field_0x08 == 0xFFFF; }\n    dCcG_At_Spl GetAtSpl() { return (dCcG_At_Spl)mAt; }\n    void SetAtSpl(dCcG_At_Spl spl) { mAt = spl; }\n    dCcG_Tg_Spl GetTgSpl() { return (dCcG_Tg_Spl)mTg; }\n    void SetTgSpl(dCcG_Tg_Spl spl) { mTg = spl; }\n    void OnNoActor() { field_0x1C |= 1; }\n\n    // private:\n    /* 0x04 */ u8 mAt;\n    /* 0x05 */ u8 mTg;\n    /* 0x06 */ u8 mRoomId;\n    /* 0x08 */ u16 field_0x08;\n    /* 0x0C */ int mAtApid;\n    /* 0x10 */ int mAtOldApid;\n    /* 0x14 */ int mTgApid;\n    /* 0x18 */ int mTgOldApid;\n    /* 0x1C */ int field_0x1C;\n};  // Size = 0x20\n\nclass dCcD_Stts : public cCcD_Stts, public dCcD_GStts {\npublic:\n    dCcD_Stts() {}\n    /* 80083850 */ virtual cCcD_GStts* GetGStts();\n    /* 80083860 */ void Init(int, int, fopAc_ac_c*);\n    /* 800838F4 */ virtual void Ct();\n    /* 80083928 */ virtual void ClrAt();\n    /* 80083934 */ virtual void ClrTg();\n    /* 800851AC */ virtual ~dCcD_Stts() {}\n\n};  // Size = 0x3C\n\nclass dCcD_GObjInf;\ntypedef void (*dCcD_HitCallback)(fopAc_ac_c* i_actorA, dCcD_GObjInf* i_objInfA, fopAc_ac_c* i_actorB, dCcD_GObjInf* i_objInfB);\n\n\n// Attack/Defense/Correction Collider Common Base\nclass dCcD_GAtTgCoCommonBase {\npublic:\n    /* 0x00 */ u32 mGFlag;\n    /* 0x04 */ u32 mRPrm;\n    /* 0x08 */ dCcD_HitCallback mHitCallback;\n    /* 0x0C */ u32 mApid;\n    /* 0x10 */ fopAc_ac_c* mAc;\n    /* 0x14 */ s8 mEffCounter;\n    /* 0x15 */ u8 field_0x15[3];\n    /* 0x18 vtable */\n\npublic:\n    dCcD_GAtTgCoCommonBase() { ct(); }\n    /* 8008364C */ void ClrActorInfo();\n    /* 80083660 */ void ct();\n    /* 80083678 */ void SetHitApid(unsigned int);\n    /* 80083688 */ fopAc_ac_c* GetAc();\n    /* 80083704 */ void Set(dCcD_SrcGAtTgCoCommonBase const&);\n    /* 80083718 */ void SetEffCounterTimer();\n    /* 80083724 */ void SubtractEffCounter();\n    /* 80083748 */ bool ChkEffCounter();\n    /* 80083CA0 */ virtual ~dCcD_GAtTgCoCommonBase() {}\n\n    void ClrEffCounter() { mEffCounter = 0; }\n    u32 GetGFlag() const { return mGFlag; }\n    u32 GetRPrm() const { return mRPrm; }\n    u32 MskSPrm(u32 mask) const { return mGFlag & mask; }\n    u32 MskRPrm(u32 mask) const { return mRPrm & mask; }\n    bool ChkSPrm(u32 mask) const { return MskSPrm(mask); }\n    void OnSPrm(u32 flag) { mGFlag |= flag; }\n    void OnRPrm(u32 flag) { mRPrm |= flag; }\n    void OffSPrm(u32 flag) { mGFlag &= ~flag; }\n    void OffRPrm(u32 flag) { mRPrm &= ~flag; }\n    bool ChkRPrm(u32 flag) const { return MskRPrm(flag); }\n    void SetHitCallback(dCcD_HitCallback callback) { mHitCallback = callback; }\n    dCcD_HitCallback GetHitCallback() { return mHitCallback; }\n    void ClrHit() { ClrActorInfo(); }\n};  // Size = 0x1C\n\n\n// Attack (At) Collider\nclass dCcD_GObjAt : public dCcD_GAtTgCoCommonBase {\npublic:\n    /* 80083944 */ void Set(dCcD_SrcGObjAt const&);\n    /* 80083C44 */ virtual ~dCcD_GObjAt() {}\n    void SetVec(cXyz& vec) { mVec = vec; }\n    cXyz& GetVec() { return mVec; }\n    cXyz* GetVecP() { return &mVec; }\n    void SetHitMark(u8 mark) { mHitMark = mark; }\n    void SetSe(u8 se) { mSe = se; }\n    void SetMtrl(u8 mtrl) { mMtrl = mtrl; }\n    void SetAtSpl(dCcG_At_Spl spl) { mSpl = spl; }\n    u8 GetSe() { return mSe; }\n    u8 GetSpl() { return mSpl; }\n    u8 GetMtrl() { return mMtrl; }\n    u8 GetHitMark() { return mHitMark; }\n    void SetRVec(cXyz& vec) { mRVec = vec; }\n    void SetHitPos(cXyz& pos) { mHitPos = pos; }\n    cXyz* GetHitPosP() { return &mHitPos; }\n\n    // private:\n    /* 0x1C */ u8 mSe;\n    /* 0x1D */ u8 mMtrl;\n    /* 0x1E */ u8 mHitMark;\n    /* 0x1F */ u8 mSpl;\n    /* 0x20 */ cXyz mHitPos;\n    /* 0x2C */ cXyz mVec;\n    /* 0x38 */ cXyz mRVec;\n};  // Size = 0x44\n\n// Defense (Tg) Collider\nclass dCcD_GObjTg : public dCcD_GAtTgCoCommonBase {\npublic:\n    /* 800839A0 */ void Set(dCcD_SrcGObjTg const&);\n    /* 80083BE8 */ virtual ~dCcD_GObjTg() {}\n    void SetSe(u8 se) { mSe = se; }\n    void SetVec(cXyz& vec) { mVec = vec; }\n    cXyz& GetVec() { return mVec; }\n    void SetShieldFrontRangeYAngle(s16* angle) { mShieldFrontRangeYAngle = angle; }\n    void SetMtrl(u8 mtrl) { mMtrl = mtrl; }\n    u8 GetMtrl() { return mMtrl; }\n    void SetHitMark(CcG_Tg_HitMark mark) { mHitMark = mark; }\n    s16* GetShieldFrontRangeYAngle() { return mShieldFrontRangeYAngle; }\n    s16 GetShieldRange() { return mShieldRange; }\n    u8 GetSpl() { return mSpl; }\n    u8 GetHitMark() { return mHitMark; }\n    void SetRVec(cXyz& vec) { mRVec = vec; }\n    cXyz* GetVecP() { return &mVec; }\n    void SetHitPos(cXyz& pos) { mHitPos = pos; }\n\nprivate:\n    /* 0x1C */ u8 mSe;\n    /* 0x1D */ u8 mMtrl;\n    /* 0x1E */ u8 mHitMark;\n    /* 0x1F */ u8 mSpl;\n    /* 0x20 */ cXyz mVec;\n    /* 0x2C */ cXyz mRVec;\n    /* 0x38 */ cXyz mHitPos;\n    /* 0x44 */ s16* mShieldFrontRangeYAngle;\n    /* 0x48 */ s16 mShieldRange;\n};  // Size = 0x4A ?\n\n// Correction (Co) Collider\nclass dCcD_GObjCo : public dCcD_GAtTgCoCommonBase {\npublic:\n    /* 80083B8C */ virtual ~dCcD_GObjCo() {}\n    void Set(dCcD_SrcGObjCo const& pSrc) { dCcD_GAtTgCoCommonBase::Set(pSrc.mBase); }\n};  // Size = 0x1C ?\n\n// Object Info\nclass dCcD_GObjInf : public cCcD_GObjInf {\npublic:\n    /* 80083A28 */ dCcD_GObjInf();\n    /* 800840E4 */ virtual ~dCcD_GObjInf();\n    /* 80084268 */ virtual cCcD_GObjInf* GetGObjInf();\n    /* 8008426C */ virtual void ClrAtHit();\n    /* 800842C0 */ u32 ChkAtHit();\n    /* 80084318 */ void ResetAtHit();\n    /* 80084358 */ cCcD_Obj* GetAtHitObj();\n    /* 800843A8 */ cCcD_GObjInf* GetAtHitGObj();\n    /* 800843DC */ u8 ChkAtNoGuard();\n    /* 800843FC */ virtual void ClrTgHit();\n    /* 80084460 */ u32 ChkTgHit();\n    /* 800844B8 */ void ResetTgHit();\n    /* 800844F8 */ cCcD_Obj* GetTgHitObj();\n    /* 80084548 */ dCcD_GObjInf* GetTgHitGObj();\n    /* 8008457C */ u8 GetTgHitObjSe();\n    /* 800845B0 */ static Z2SoundID getHitSeID(u8, int);\n    /* 8008460C */ virtual void ClrCoHit();\n    /* 80084658 */ u32 ChkCoHit();\n    /* 800846B0 */ void ResetCoHit();\n    /* 800846F0 */ cCcD_Obj* GetCoHitObj();\n    /* 80084740 */ void Set(dCcD_SrcGObjInf const&);\n\n    fopAc_ac_c* GetCoHitAc() { return mGObjCo.GetAc(); }\n\n    void SetAtVec(cXyz& vec) { mGObjAt.SetVec(vec); }\n    void SetTgVec(cXyz& vec) { mGObjTg.SetVec(vec); }\n    bool ChkAtNoMass() const { return mGObjAt.ChkSPrm(8); }\n    void OnAtNoHitMark() { mGObjAt.OnSPrm(2); }\n    void OffAtNoHitMark() { mGObjAt.OffSPrm(2); }\n    void OnTgNoHitMark() { mGObjTg.OnSPrm(4); }\n    void OffTgNoHitMark() { mGObjTg.OffSPrm(4); }\n    void OnAtNoConHit() { mGObjAt.OnSPrm(1); }\n    void OffAtNoConHit() { mGObjAt.OffSPrm(1); }\n    void OnTgNoConHit() { mGObjTg.OnSPrm(2); }\n    void SetAtHitMark(u8 mark) { mGObjAt.SetHitMark(mark); }\n    void SetAtSe(u8 se) { mGObjAt.SetSe(se); }\n    void SetTgSe(u8 se) { mGObjTg.SetSe(se); }\n    void SetAtMtrl(u8 mtrl) { mGObjAt.SetMtrl(mtrl); }\n    void SetTgMtrl(u8 mtrl) { mGObjTg.SetMtrl(mtrl); }\n    fopAc_ac_c* GetAtHitAc() { return mGObjAt.GetAc(); }\n    bool ChkAtShieldHit() { return mGObjAt.ChkRPrm(1); }\n    cXyz* GetAtVecP() { return mGObjAt.GetVecP(); }\n    cXyz* GetTgVecP() { return mGObjTg.GetVecP(); }\n    void SetAtSpl(dCcG_At_Spl spl) { mGObjAt.SetAtSpl(spl); }\n    void SetAtHitCallback(dCcD_HitCallback callback) { mGObjAt.SetHitCallback(callback); }\n    void SetTgHitCallback(dCcD_HitCallback callback) { mGObjTg.SetHitCallback(callback); }\n    void SetCoHitCallback(dCcD_HitCallback callback) { mGObjCo.SetHitCallback(callback); }\n    u8 GetAtSe() { return mGObjAt.GetSe(); }\n    dCcG_At_Spl GetAtSpl() { return (dCcG_At_Spl)mGObjAt.GetSpl(); }\n    u8 GetAtMtrl() { return mGObjAt.GetMtrl(); }\n    u8 GetTgMtrl() { return mGObjTg.GetMtrl(); }\n    fopAc_ac_c* GetTgHitAc() { return mGObjTg.GetAc(); }\n    void SetTgShieldFrontRangeYAngle(s16* angle) { mGObjTg.SetShieldFrontRangeYAngle(angle); }\n    void OffTgWolfSpNoDamage() { mGObjTg.OffSPrm(0x800); }\n    void OnTgWolfSpNoDamage() { mGObjTg.OnSPrm(0x800); }\n    void SetTgHitMark(CcG_Tg_HitMark mark) { mGObjTg.SetHitMark(mark); }\n    void OnTgSpShield() { mGObjTg.OnSPrm(0x40); }\n    void OffTgSpShield() { mGObjTg.OffSPrm(0x40); }\n    void OnTgShield() { mGObjTg.OnSPrm(0x1); }\n    void OffTgShield() { mGObjTg.OffSPrm(0x1); }\n    void OnTgShieldFrontRange() { mGObjTg.OnSPrm(0x8); }\n    void OffTgShieldFrontRange() { mGObjTg.OffSPrm(0x8); }\n    void OnTgSmallShield() { mGObjTg.OnSPrm(0x10); }\n    void OffTgSmallShield() { mGObjTg.OffSPrm(0x10); }\n    bool ChkTgIronBallRebound() { return mGObjTg.ChkSPrm(0x100); }\n    s16* GetTgShieldFrontRangeYAngle() { return mGObjTg.GetShieldFrontRangeYAngle(); }\n    s16 GetTgShieldRange() { return mGObjTg.GetShieldRange(); }\n    bool ChkTgShield() { return mGObjTg.ChkSPrm(1); }\n    bool ChkTgSpShield() { return mGObjTg.ChkSPrm(0x40); }\n    bool ChkTgSmallShield() { return mGObjTg.ChkSPrm(0x10); }\n    bool ChkTgShieldFrontRange() { return mGObjTg.ChkSPrm(8); }\n    bool ChkAtNoConHit() { return mGObjAt.ChkSPrm(1); }\n    bool ChkAtStopNoConHit() { return mGObjAt.ChkSPrm(0x4); }\n    bool ChkTgNoConHit() { return mGObjTg.ChkSPrm(2); }\n    bool ChkTgStopNoConHit() { return mGObjTg.ChkSPrm(0x2000); }\n    bool ChkCoNoCamHit() { return mGObjCo.ChkSPrm(2); }\n    dCcD_HitCallback GetCoHitCallback() { return mGObjCo.GetHitCallback(); }\n    dCcD_HitCallback GetAtHitCallback() { return mGObjAt.GetHitCallback(); }\n    dCcD_HitCallback GetTgHitCallback() { return mGObjTg.GetHitCallback(); }\n    void SetCoHitApid(unsigned int apid) { mGObjCo.SetHitApid(apid); }\n    void SetAtHitApid(unsigned int apid) { mGObjAt.SetHitApid(apid); }\n    void SetTgHitApid(unsigned int apid) { mGObjTg.SetHitApid(apid); }\n    void OnCoHitNoActor() { mGObjCo.OnRPrm(1); }\n    void OffCoHitNoActor() { mGObjCo.OffRPrm(1); }\n    void OnAtHitNoActor() { mGObjAt.OnRPrm(2); }\n    void OffAtHitNoActor() { mGObjAt.OffRPrm(2); }\n    void OnTgHitNoActor() { mGObjTg.OnRPrm(1); }\n    void OffTgHitNoActor() { mGObjTg.OffRPrm(1); }\n    bool ChkCoHitNoActor() const { return mGObjCo.ChkRPrm(1); }\n    bool ChkAtHitNoActor() const { return mGObjAt.ChkRPrm(2); }\n    bool ChkTgHitNoActor() const { return mGObjTg.ChkRPrm(1); }\n    bool ChkTgWolfSpNoDamage() { return mGObjTg.ChkSPrm(0x800); }\n    bool ChkAtNoHitMark() { return mGObjAt.ChkSPrm(2); }\n    bool ChkTgNoHitMark() { return mGObjTg.ChkSPrm(4); }\n    bool ChkTgHookShotNoHitMark() { return mGObjTg.ChkSPrm(0x400); }\n    bool ChkTgArrowNoHitMark() { return mGObjTg.ChkSPrm(0x1000); }\n    dCcG_Tg_Spl GetTgSpl() { return (dCcG_Tg_Spl)mGObjTg.GetSpl(); }\n    int GetTgHitMark() { return mGObjTg.GetHitMark(); }\n    int GetAtHitMark() { return mGObjAt.GetHitMark(); }\n    bool ChkAtEffCounter() { return mGObjAt.ChkEffCounter(); }\n    bool ChkTgEffCounter() { return mGObjTg.ChkEffCounter(); }\n    void ClrAtEffCounter() { mGObjAt.ClrEffCounter(); }\n    void ClrTgEffCounter() { mGObjTg.ClrEffCounter(); }\n    void ClrCoEffCounter() { mGObjCo.ClrEffCounter(); }\n    void SetAtEffCounterTimer() { mGObjAt.SetEffCounterTimer(); }\n    void SetTgEffCounterTimer() { mGObjTg.SetEffCounterTimer(); }\n    void SubtractAtEffCounter() { mGObjAt.SubtractEffCounter(); }\n    void SubtractTgEffCounter() { mGObjTg.SubtractEffCounter(); }\n    void SubtractCoEffCounter() { mGObjCo.SubtractEffCounter(); }\n    void OnTgShieldHit() { mGObjTg.OnRPrm(2); }\n    void OffTgShieldHit() { mGObjTg.OffRPrm(2); }\n    void OnAtShieldHit() { mGObjAt.OnRPrm(1); }\n    void OffAtShieldHit() { mGObjAt.OffRPrm(1); }\n    void OffTgMagneHit() { mGObjTg.OffRPrm(4); }\n    void SetTgRVec(cXyz& vec) { mGObjTg.SetRVec(vec); }\n    void SetAtRVec(cXyz& vec) { mGObjAt.SetRVec(vec); }\n    void SetTgHitPos(cXyz& pos) { mGObjTg.SetHitPos(pos); }\n    void SetAtHitPos(cXyz& pos) { mGObjAt.SetHitPos(pos); }\n    u32 GetTgHitObjHitSeID(int i_soundID) { return getHitSeID(GetTgHitObjSe(),i_soundID); }\n    cXyz* GetAtHitPosP() { return mGObjAt.GetHitPosP(); }\n    bool ChkTgHookshotThrough() { return mGObjTg.ChkSPrm(0x80); }\n    \n    static const Z2SoundID m_hitSeID[24];\n\nprotected:\n    /* 0x058 */ dCcD_GObjAt mGObjAt;\n    /* 0x09C */ dCcD_GObjTg mGObjTg;\n    /* 0x0E8 */ dCcD_GObjCo mGObjCo;\n};  // Size = 0x104\n\n// Cylinder\nclass dCcD_Cyl : public dCcD_GObjInf, public cCcD_CylAttr {\npublic:\n    /* 800848B4 */ void Set(dCcD_SrcCyl const&);\n    /* 800848F8 */ cCcD_ShapeAttr* GetShapeAttr();\n    /* 80084908 */ void StartCAt(cXyz&);\n    /* 80084954 */ void MoveCAt(cXyz&);\n    /* 800849C4 */ void MoveCTg(cXyz&);\n    /* 80084D60 */ virtual ~dCcD_Cyl() {}\n    dCcD_Cyl() {}\n};  // Size = 0x13C\n\n// Sphere\nclass dCcD_Sph : public dCcD_GObjInf, public cCcD_SphAttr {\npublic:\n    dCcD_Sph() {}\n    /* 80084A34 */ void Set(dCcD_SrcSph const&);\n    /* 80084A78 */ void StartCAt(cXyz&);\n    /* 80084AC4 */ void MoveCAt(cXyz&);\n    /* 80084B34 */ virtual cCcD_ShapeAttr* GetShapeAttr();\n    /* 80084BF4 */ virtual ~dCcD_Sph() {}\n};  // Size = 0x138\n\n\n// Capsule\nclass dCcD_Cps : public dCcD_GObjInf, public cCcD_CpsAttr {\npublic:\n    /* 800847D0 */ void Set(dCcD_SrcCps const&);\n    /* 80084814 */ cCcD_ShapeAttr* GetShapeAttr();\n    /* 80084824 */ void CalcAtVec();\n    /* 80084854 */ void CalcTgVec();\n    /* 8008506C */ virtual ~dCcD_Cps() {}\n    dCcD_Cps() {}\n};  // Size = 0x144\n\n// Triangle\nclass dCcD_Tri : public dCcD_GObjInf, public cCcD_TriAttr {\npublic:\n    /* 80084884 */ void Set(dCcD_SrcTri const&);\n    /* 800848A4 */ cCcD_ShapeAttr* GetShapeAttr();\n    /* 80084EF4 */ virtual ~dCcD_Tri() {}\n    dCcD_Tri() {}\n};\n\ndCcD_GObjInf* dCcD_GetGObjInf(cCcD_Obj* param_0);\n\n#endif /* D_CC_D_CC_D_H */\n/* end \"d/cc/d_cc_d.h\" */\n/* \"include/d/a/d_a_itembase.h\" line 6 \"f_op/f_op_actor.h\" */\n/* end \"f_op/f_op_actor.h\" */\n\nstruct daItemBase_data {\n    /* 0x00 */ f32 mGravity;\n    /* 0x04 */ f32 field_0x4;\n    /* 0x08 */ f32 field_0x8;\n    /* 0x0C */ f32 field_0xc;\n    /* 0x10 */ f32 field_0x10;\n    /* 0x14 */ s16 field_0x14;\n    /* 0x16 */ s16 field_0x16;\n    /* 0x18 */ s16 field_0x18;\n    /* 0x1A */ s16 field_0x1a;\n    /* 0x1C */ s16 field_0x1c;\n    /* 0x20 */ f32 field_0x20;\n    /* 0x24 */ f32 field_0x24;\n    /* 0x28 */ s16 field_0x28;\n    /* 0x2A */ s16 field_0x2a;\n    /* 0x2C */ f32 field_0x2c;\n    /* 0x30 */ f32 field_0x30;\n    /* 0x34 */ s16 field_0x34;\n    /* 0x36 */ s16 field_0x36;\n};\n\nclass daItemBase_c : public fopAc_ac_c {\npublic:\n    u8 getItemNo();\n    void hide();\n    void show();\n    void changeDraw();\n    u8 chkDraw();\n    void dead();\n    u8 chkDead();\n    int CreateItemHeap(char const*, s16, s16, s16, s16, s16, s16, s16);\n    int DeleteBase(char const*);\n    void setListEnd();\n    void animPlay(f32, f32, f32, f32, f32, f32);\n    const daItemBase_data& getData();\n\n    virtual int DrawBase();\n    virtual void setListStart();\n    virtual void settingBeforeDraw();\n    virtual void setTevStr();\n    virtual void setShadow();\n    virtual void animEntry();\n    virtual void RotateYBase();\n    virtual int clothCreate();\n    virtual int __CreateHeap();\n    virtual BOOL chkFlag(int);\n    virtual s8 getTevFrm();\n    virtual s8 getBtpFrm();\n    virtual u8 getShadowSize();\n    virtual u8 getCollisionH();\n    virtual u8 getCollisionR();\n\n    static daItemBase_data const m_data;\n\n    /* 0x56C */ request_of_phase_process_class mPhase;\n    /* 0x574 */ J3DModel* mpModel;\n    /* 0x578 */ mDoExt_btkAnm* mpBtkAnm;\n    /* 0x57C */ mDoExt_bpkAnm* mpBpkAnm;\n    /* 0x580 */ mDoExt_brkAnm* mpBrkAnm;\n    /* 0x584 */ mDoExt_bckAnm* mpBckAnm;\n    /* 0x588 */ mDoExt_btpAnm* mpBtpAnm;\n    /* 0x58C */ dBgS_ObjAcch mAcch;\n    /* 0x764 */ dBgS_AcchCir mAcchCir;\n    /* 0x7A4 */ dCcD_Stts mColStatus;\n    /* 0x7E0 */ dCcD_Cyl mCollider;\n    /* 0x91C */ u32 field_0x91c;\n    /* 0x920 */ u32 field_0x920;\n    /* 0x924 */ int field_0x924;\n    /* 0x928 */ s16 field_0x928;\n    /* 0x92A */ u8 m_itemNo;\n    /* 0x92B */ u8 field_0x92b;\n};\n\n#endif /* D_A_D_A_ITEMBASE_H */\n/* end \"d/a/d_a_itembase.h\" */\n/* \"include/d/event/d_event.h\" line 4 \"global.h\" */\n/* end \"global.h\" */\n\nint dEv_noFinishSkipProc(void*, int);\n\nstruct dStage_MapEvent_dt_c;\nclass fopAc_ac_c;\n\n#ifdef DEBUG\nclass dEvDb_bit_c {\npublic:\n    /* 0x00 */ char* mFlagName;\n    /* 0x04 */ char* mFlagDescription;\n    /* 0x08 */ char* mFlagAuthor;\n    /* 0x0C */ u16 mFlagValue;\n    /* 0x10 */ char* mArea; // Area in the game where flag is used\n    /* 0x14 */ u8 field_0x14;\n    /* 0x15 */ u8 field_0x15;\n};\n\nclass dEvDb_reg_c {\npublic:\n    /* 0x00 */ char* mFlagName;\n    /* 0x04 */ char* mFlagDescription;\n    /* 0x08 */ char* mFlagAuthor;\n    /* 0x0C */ u16 mFlagValue;\n    /* 0x10 */ char* mArea; // Area in the game where flag is used\n    /* 0x14 */ u8 field_0x14;\n    /* 0x15 */ u8 field_0x15;\n};\n\nclass dEvDb_flag_base_c {\npublic:\n    /* 0x00 */ dEvDb_bit_c* mBitTable;\n    /* 0x04 */ dEvDb_reg_c* mRegTable;\n    /* 0x08 */ int mBitNum;\n    /* 0x0C */ int mRegNum;\n    /* 0x10 */ int field_0x10;\n    /* 0x14 */ int field_0x14;\n};\n#endif\n\nclass dEvt_order_c {\npublic:\n    ~dEvt_order_c() {}\n    dEvt_order_c();\n\n    /* 0x00 */ u16 mEventType;\n    /* 0x02 */ u16 mFlag;\n    /* 0x04 */ u16 mHindFlag;\n    /* 0x08 */ fopAc_ac_c* mActor1;\n    /* 0x0C */ fopAc_ac_c* mActor2;\n    /* 0x10 */ s16 mEventId;\n    /* 0x12 */ u16 mPriority;\n    /* 0x14 */ s8 mNextOrderIdx;\n    /* 0x15 */ u8 mEventInfoIdx;\n};  // Size = 0x18\n\nSTATIC_ASSERT(sizeof(dEvt_order_c) == 0x18);\n\ntypedef int (*SkipFunc)(void*, int);\n\nenum EventMode {\n    /* 0x0 */ EVT_MODE_NONE,\n    /* 0x1 */ EVT_MODE_TALK,\n    /* 0x2 */ EVT_MODE_DEMO,\n    /* 0x3 */\n};\n\nenum EventType {\n    /* 0x0 */ EVT_TYPE_TALK,\n    /* 0x1 */ EVT_TYPE_DOOR,\n    /* 0x2 */ EVT_TYPE_OTHER,\n    /* 0x3 */ EVT_TYPE_COMPULSORY,\n    /* 0x4 */ EVT_TYPE_POTENTIAL,\n    /* 0x5 */ EVT_TYPE_ITEM,\n    /* 0x6 */ EVT_TYPE_SHOWITEM_X,\n    /* 0x7 */ EVT_TYPE_SHOWITEM_Y,\n    /* 0xA */ EVT_TYPE_CATCH = 10,\n    /* 0xB */ EVT_TYPE_TREASURE,\n};\n\nenum EventStatus {\n    /* 0x0 */ STATUS_NONE,\n};\n\nclass dEvt_control_c {\npublic:\n    dEvt_control_c();\n    s32 orderOld(u16 eventType, u16 priority, u16 flag, u16 param_3, void* param_4, void* param_5,\n                 void const* param_6);\n    s32 order(u16 eventType, u16 priority, u16 flag, u16 param_3, void* param_4, void* param_5,\n              s16 eventID, u8 infoIdx);\n    void setParam(dEvt_order_c* p_order);\n    s32 beforeFlagProc(dEvt_order_c* p_order);\n    void afterFlagProc(dEvt_order_c* p_order);\n    int commonCheck(dEvt_order_c* p_order, u16 condition, u16 command);\n    int talkCheck(dEvt_order_c* p_order);\n    int talkXyCheck(dEvt_order_c* p_order);\n    int catchCheck(dEvt_order_c* p_order);\n    int talkEnd();\n    int demoCheck(dEvt_order_c* p_order);\n    int demoEnd();\n    int potentialCheck(dEvt_order_c* p_order);\n    int doorCheck(dEvt_order_c* p_order);\n    int itemCheck(dEvt_order_c* p_order);\n    int endProc();\n    int change();\n    int entry();\n    void reset(void*);\n    void reset();\n    void clearSkipSystem();\n    char* getSkipEventName();\n    void setSkipProc(void*, SkipFunc, int);\n    void setSkipZev(void*, char*);\n    void onSkipFade();\n    void offSkipFade();\n    bool skipper();\n    int Step();\n    int moveApproval(void*);\n    BOOL compulsory(void*, char const*, u16);\n    void remove();\n    dStage_MapEvent_dt_c* getStageEventDt();\n    void sceneChange(int exitId);\n    u32 getPId(void*);\n    fopAc_ac_c* convPId(unsigned int);\n    void* getStbDemoData(char* resName);\n    static dStage_MapEvent_dt_c* searchMapEventData(u8 mapToolID, s32 roomNo);\n    static dStage_MapEvent_dt_c* searchMapEventData(u8 mapToolID);\n    s16 runningEventID(s16 eventID);\n    void setPt1(void* ptr);\n    void setPt2(void* ptr);\n    void setPtT(void* ptr);\n    void setPtI(void* ptr);\n    void setPtI_Id(unsigned int id);\n    void setPtD(void* ptr);\n    void setGtItm(u8 itemNo);\n    BOOL isOrderOK();\n    /* 807DFAD8 */ void checkSkipEdge();\n    /* 807E2908 */ void startCheckSkipEdge(void*);\n\n    u16 chkFlag2(u16 flag) { return flag & mFlag2; }\n    bool runCheck() { return mEventStatus != 0; }\n    f32 getCullRate() { return mCullRate; }\n    u16 chkEventFlag(u16 flag) { return flag & mEventFlag; }\n    void onEventFlag(u16 flag) { mEventFlag |= flag; }\n    void offEventFlag(u16 flag) { mEventFlag &= ~flag; }\n    u8 getMode() const { return mMode; }\n    void onHindFlag(u16 flag) { mHindFlag |= flag; }\n    u16 checkHind(u16 flag) { return flag & mHindFlag; }\n    u8 checkCompulsory() { return mCompulsory; }\n    u8 getMapToolId() { return mMapToolId; }\n    void onFlag2(u16 flag) { mFlag2 |= flag; }\n    void offFlag2(u16 flag) { mFlag2 &= ~flag; }\n    void setCullRate(f32 f) { mCullRate = f; }\n    BOOL chkTalkXY() { return field_0xed == 1 || field_0xed == 2; }\n\n    bool i_isOrderOK() { return mEventStatus == 0 || mEventStatus == 2; }\n    fopAc_ac_c* getPt1() { return convPId(mPt1); }\n    fopAc_ac_c* getPt2() { return convPId(mPt2); }\n    fopAc_ac_c* getPtT() { return convPId(mPtT); }\n    bool isChangeOK(void* param_0) { return mChangeOK == param_0; }\n    u8 getPreItemNo() { return mPreItemNo; }\n    u8 getGtItm() { return mGtItm; }\n    void i_startCheckSkipEdge(void* param_0) { setSkipProc(param_0, dEv_noFinishSkipProc, 0); }\n    bool i_checkSkipEdge() { return chkFlag2(8) != false; }\n\npublic:\n    /* 0x000 */ u8 field_0x0[4];\n    /* 0x004 */ dEvt_order_c mOrder[8];\n    /* 0x0C4 */ u32 mPt1;\n    /* 0x0C8 */ u32 mPt2;\n    /* 0x0CC */ u32 mPtT;\n    /* 0x0D0 */ u32 mPtI;\n    /* 0x0D4 */ u32 mPtd;\n    /* 0x0D8 */ u16 mEventFlag;\n    /* 0x0DA */ u16 mFlag2;\n    /* 0x0DC */ u16 mHindFlag;\n    /* 0x0DE */ s16 mSpecifiedEvent;  // name maybe wrong\n    /* 0x0E0 */ s16 mEventID;\n    /* 0x0E2 */ s8 mNum;\n    /* 0x0E3 */ s8 mOrderIdx;\n    /* 0x0E4 */ u8 mMode;\n    /* 0x0E5 */ u8 mEventStatus;\n    /* 0x0E6 */ u8 field_0xe6;\n    /* 0x0E7 */ u8 field_0xe7;\n    /* 0x0E8 */ u8 field_0xe8;\n    /* 0x0E9 */ u8 mDebugStb;\n    /* 0x0EA */ u8 field_0xea;\n    /* 0x0EB */ u8 mMapToolId;\n    /* 0x0EC */ u8 field_0xec;\n    /* 0x0ED */ u8 field_0xed;\n    /* 0x0EE */ u8 mPreItemNo;\n    /* 0x0EF */ u8 mGtItm;\n    /* 0x0F0 */ f32 mCullRate;\n    /* 0x0F4 */ dStage_MapEvent_dt_c* mStageEventDt;\n    /* 0x0F8 */ void* mChangeOK;\n    /* 0x0FC */ u8 field_0xfc[4];\n    /* 0x100 */ SkipFunc mSkipFunc;\n    /* 0x104 */ u32 field_0x104;\n    /* 0x108 */ int mSkipTimer;\n    /* 0x10C */ int field_0x10c;\n    /* 0x110 */ int mSkipFade;\n    /* 0x114 */ char mSkipEventName[20];\n    /* 0x128 */ u8 mCompulsory;\n    /* 0x129 */ bool mRoomInfoSet;\n    /* 0x12C */ int mRoomNo;\n};  // Size = 0x130\n\nint dEv_defaultSkipProc(void* param_0, int param_1);\nint dEv_defaultSkipZev(void* param_0, int param_1);\nint dEv_defaultSkipStb(void* param_0, int param_1);\nint dEv_noFinishSkipProc(void* param_0, int param_1);\n\n#endif /* D_EVENT_D_EVENT_H */\n/* end \"d/event/d_event.h\" */\n/* \"include/d/com/d_com_inf_game.h\" line 9 \"d/event/d_event_manager.h\" */\n#ifndef D_EVENT_D_EVENT_MANAGER_H\n#define D_EVENT_D_EVENT_MANAGER_H\n\n/* \"include/d/event/d_event_manager.h\" line 3 \"SSystem/SComponent/c_xyz.h\" */\n/* end \"SSystem/SComponent/c_xyz.h\" */\n/* \"include/d/event/d_event_manager.h\" line 4 \"d/event/d_event_data.h\" */\n#ifndef D_EVENT_D_EVENT_DATA_H\n#define D_EVENT_D_EVENT_DATA_H\n\n/* \"include/d/event/d_event_data.h\" line 3 \"global.h\" */\n/* end \"global.h\" */\n\nclass msg_class;\n\nstruct event_binary_data_header {\n    /* 0x00 */ u32 eventTop;  // offset to Event chunk\n    /* 0x04 */ s32 eventNum;\n    /* 0x08 */ u32 staffTop;  // offset to Staff chunk\n    /* 0x0C */ s32 staffNum;\n    /* 0x10 */ u32 cutTop;  // offset to Cut chunk\n    /* 0x14 */ s32 cutNum;\n    /* 0x18 */ u32 dataTop;  // offset to Data chunk\n    /* 0x1C */ s32 dataNum;\n    /* 0x20 */ u32 fDataTop;  // offset to FData chunk\n    /* 0x24 */ s32 fDataNum;\n    /* 0x28 */ u32 iDataTop;  // offset to IData chunk\n    /* 0x2C */ s32 iDataNum;\n    /* 0x30 */ u32 sDataTop;  // offset to SData chunk\n    /* 0x34 */ s32 sDataNum;\n    /* 0x38 */ u8 unk[8];\n};  // Size: 0x40\n\nclass dEvDtData_c {\npublic:\n    enum DataType {\n        /* 0x0 */ TYPE_FLOAT,\n        /* 0x1 */ TYPE_VEC,\n        /* 0x3 */ TYPE_INT = 3,\n        /* 0x4 */ TYPE_STRING\n    };\n\n    int getIndex() { return mDataIndex; }\n    int getNumber() { return mNumber; }\n    int getType() { return mType; }\n    int getNext() { return mNext; }\n    char* getName() { return mName; }\n\n    /* 0x00 */ char mName[32];\n    /* 0x20 */ u32 mIndex;\n    /* 0x24 */ int mType;\n    /* 0x28 */ int mDataIndex;\n    /* 0x2C */ int mNumber;\n    /* 0x30 */ int mNext;\n    /* 0x34 */ u8 field_0x34[12];\n};  // Size: 0x40\n\nclass dEvDtCut_c {\npublic:\n    int startCheck();\n\n    int getDataTop() { return mDataTop; }\n    int getFlagId() { return mFlagId; }\n    char* getName() { return mName; }\n    int getNext() { return mNext; }\n    int getStartFlag(int idx) { return mFlags[idx]; }\n\nprivate:\n    /* 0x00 */ char mName[32];\n    /* 0x20 */ u32 mTagID;\n    /* 0x24 */ u32 mIndex;\n    /* 0x28 */ int mFlags[3];\n    /* 0x34 */ u32 mFlagId;\n    /* 0x38 */ int mDataTop;\n    /* 0x3C */ int mNext;\n    /* 0x40 */ u8 field_0x40[0x10];\n};  // Size: 0x50\n\nclass dEvDtStaff_c {\npublic:\n    enum StaffType {\n        /* 0x0 */ TYPE_DEFAULT,\n        /* 0x1 */ TYPE_ALL,\n        /* 0x2 */ TYPE_CAMERA,\n        /* 0x3 */ TYPE_EFFECT,\n        /* 0x4 */ TYPE_TIMEKEEPER,\n        /* 0x6 */ TYPE_DIRECTOR = 6,\n        /* 0x7 */ TYPE_MESSAGE,\n        /* 0x8 */ TYPE_SOUND,\n        /* 0x9 */ TYPE_LIGHT,\n        /* 0xB */ TYPE_PACKAGE = 11,\n        /* 0xC */ TYPE_CREATE,\n    };\n\n    struct StaffWork {\n        unsigned int _0;\n        msg_class* mLMsg;\n        unsigned int mMsgNo;\n        s32 mMsgSubstanceNum;\n        int* mMsgSubstanceP;\n    };\n\n    struct MessageData {\n        s16 unk;\n    };\n\n    struct SoundData {\n        s16 unk;\n        s16 timer;\n    };\n\n    struct TimerKeeperData {\n        s32 timer;\n    };\n\n    struct DirectorData {\n        s16 unk;\n        s16 unk2;\n    };\n\n    struct EffectData {\n        u8 pad[8];\n        s32 unk;\n    };\n\n    void specialProc_WaitStart(int index);\n    void specialProc_WaitProc(int);\n    void specialProc();\n    void init();\n    void advanceCut(int cut);\n    void specialProcLight();\n    void specialProcMessage();\n    void specialProcSound();\n    void specialProcCreate();\n    void specialProcDirector();\n    void specialProcPackage();\n    void specialProcTimekeeper();\n    void specialProcEffect();\n\n    int getType() { return mType; }\n    char* getName() { return mName; }\n    int getCurrentCut() { return mCurrentCut; }\n    int getStartCut() { return mStartCut; }\n\n    // private:\n    /* 0x00 */ char mName[8];\n    /* 0x08 */ StaffWork mWork;\n    /* 0x0C */ u8 field_0x1C[0x20 - 0x1C];\n    /* 0x20 */ s32 mTagID;\n    /* 0x24 */ u32 mIndex;\n    /* 0x28 */ u32 mFlagID;\n    /* 0x2C */ int mType;\n    /* 0x30 */ int mStartCut;\n    /* 0x34 */ u8 field_0x34[2];\n    /* 0x36 */ s16 mWaitTimer;\n    /* 0x38 */ int mCurrentCut;\n    /* 0x3C */ s32 field_0x3c;\n    /* 0x40 */ bool field_0x40;\n    /* 0x41 */ bool field_0x41;\n    /* 0x42 */ u8 mData[0x50 - 0x42];\n};  // Size: 0x50\n\nSTATIC_ASSERT(sizeof(dEvDtStaff_c) == 0x50);\n\nclass dEvDtEvent_c {\npublic:\n    int finishCheck();\n    int forceFinish();\n    void specialStaffProc(dEvDtStaff_c* p_staff);\n    int getNStaff() { return mNStaff; }\n    int getStaff(int idx) { return mStaff[idx]; }\n    char* getName() { return mName; }\n    int getPriority() { return mPriority; }\n\n    /* 0x00 */ char mName[32];\n    /* 0x20 */ u32 mIndex;\n    /* 0x24 */ int field_0x24;\n    /* 0x28 */ int mPriority;\n    /* 0x2C */ int mStaff[20];\n    /* 0x7C */ int mNStaff;\n    /* 0x80 */ u8 field_0x80[4];\n    /* 0x84 */ int field_0x84;\n    /* 0x88 */ int field_0x88[3];\n    /* 0x94 */ bool mPlaySound;\n    /* 0x95 */ u8 field_0x95[0xF];\n    /* 0xA4 */ int mEventState;\n    /* 0xA8 */ u8 field_0xa8[8];\n};  // Size: 0xB0\n\nclass dEvDtFlag_c {\npublic:\n    dEvDtFlag_c() {}\n    BOOL flagCheck(int flag);\n    BOOL flagSet(int flag);\n    BOOL flagMaxCheck(int flag);\n    void init();\n\n#define FlagMax 0x2800\n\nprivate:\n    u32 mFlags[320];\n};  // Size = 0x500\n\nclass dEvDtBase_c {\npublic:\n    dEvDtBase_c() { init(); }\n    ~dEvDtBase_c() {}\n    int init();\n    int init(char* p_data, int roomNo);\n    void advanceCut(dEvDtEvent_c* p_event);\n    BOOL advanceCutLocal(dEvDtStaff_c* p_staff);\n\n    event_binary_data_header* getHeaderP() { return mHeaderP; }\n    dEvDtStaff_c* getStaffP(int i) { return &mStaffP[i]; }\n    dEvDtEvent_c* getEventP(int i) { return &mEventP[i]; }\n    dEvDtData_c* getDataP(int i) { return &mDataP[i]; }\n    dEvDtCut_c* getCutP(int i) { return &mCutP[i]; }\n    char* getEventName(int i) { return mEventP[i].getName(); }\n    int getStaffCurrentCut(int i) { return mStaffP[i].getCurrentCut(); }\n    dEvDtCut_c* getCutStaffCurrentCutP(int i) { return getCutP(getStaffCurrentCut(i)); }\n    int getStaffStartCut(int i) { return mStaffP[i].getStartCut(); }\n    dEvDtCut_c* getCutStaffStartCutP(int i) { return getCutP(getStaffStartCut(i)); }\n    int* getIDataP(int i) { return &mIDataP[i]; }\n    f32* getFDataP(int i) { return &mFDataP[i]; }\n    char* getSDataP(int i) { return &mSDataP[i]; }\n    u32 getEventTop() { return mHeaderP->eventTop; }\n    s32 getEventNum() { return mHeaderP->eventNum; }\n    u32 getStaffTop() { return mHeaderP->staffTop; }\n    s32 getStaffNum() { return mHeaderP->staffNum; }\n    u32 getCutTop() { return mHeaderP->cutTop; }\n    s32 getCutNum() { return mHeaderP->cutNum; }\n    u32 getDataTop() { return mHeaderP->dataTop; }\n    s32 getDataNum() { return mHeaderP->dataNum; }\n    u32 getFDataTop() { return mHeaderP->fDataTop; }\n    s32 getFDataNum() { return mHeaderP->fDataNum; }\n    u32 getIDataTop() { return mHeaderP->iDataTop; }\n    s32 getIDataNum() { return mHeaderP->iDataNum; }\n    u32 getSDataTop() { return mHeaderP->sDataTop; }\n    s32 getSDataNum() { return mHeaderP->sDataNum; }\n    s32 roomNo() { return mRoomNo; }\n\n    void setHeaderP(event_binary_data_header* p_header) { mHeaderP = p_header; }\n    void setEventP(dEvDtEvent_c* p_event) { mEventP = p_event; }\n    void setStaffP(dEvDtStaff_c* p_staff) { mStaffP = p_staff; }\n    void setCutP(dEvDtCut_c* p_cut) { mCutP = p_cut; }\n    void setDataP(dEvDtData_c* p_data) { mDataP = p_data; }\n    void setFDataP(f32* p_fdata) { mFDataP = p_fdata; }\n    void setIDataP(int* p_idata) { mIDataP = p_idata; }\n    void setSDataP(char* p_sdata) { mSDataP = p_sdata; }\n\n    // private:\n    /* 0x00 */ event_binary_data_header* mHeaderP;\n    /* 0x04 */ dEvDtEvent_c* mEventP;\n    /* 0x08 */ dEvDtStaff_c* mStaffP;\n    /* 0x0C */ dEvDtCut_c* mCutP;\n    /* 0x10 */ dEvDtData_c* mDataP;\n    /* 0x14 */ f32* mFDataP;\n    /* 0x18 */ int* mIDataP;\n    /* 0x1C */ char* mSDataP;\n    /* 0x20 */ s32 mRoomNo;\n};  // Size = 0x24\n\nSTATIC_ASSERT(sizeof(dEvDtBase_c) == 0x24);\n\n#endif /* D_EVENT_D_EVENT_DATA_H */\n/* end \"d/event/d_event_data.h\" */\n\nclass fopAc_ac_c;\n\nclass dEvent_exception_c {\npublic:\n    dEvent_exception_c() { mEventInfoIdx = -1; }\n    void init();\n    s32 setStartDemo(int mapToolID);\n    const char* getEventName();\n\n    // private:\n    /* 0x0 */ s32 mEventInfoIdx;\n    /* 0x4 */ u8 field_0x4;\n    /* 0x5 */ u8 field_0x5;\n    /* 0x6 */ u8 field_0x6;\n    /* 0x7 */ u8 field_0x7;\n    /* 0x8 */ s32 mState;\n};\n\n#define EVT_SE_RIDDLE_A 1\n#define EVT_SE_RIDDLE_B 2\n\nclass dEvent_manager_c {\npublic:\n    void* getSubstance(dEvDtData_c* p_data, int type);\n    dEvent_manager_c();\n    ~dEvent_manager_c() {}\n    int create();\n    bool setObjectArchive(char* arcName);\n    void demoInit();\n    void roomInit(int roomNo);\n    void roomFinish(int roomNo);\n    int orderStartDemo();\n    void remove();\n    void startProc(dEvDtEvent_c* p_evnt);\n    void closeProc(dEvDtEvent_c* p_evnt);\n    void endProc(s16 eventID, int close);\n    void Sequencer();\n    void Experts();\n    dEvDtEvent_c* getEventData(s16 eventCompositId);\n    dEvDtEvent_c* getEventData(s16, int);\n    s16 getEventIdx(char const* eventName, u8 mapToolID, s32 roomNo);\n    s16 getEventIdx(fopAc_ac_c* pActor, u8 mapToolID);\n    s16 getEventIdx(fopAc_ac_c* pActor, char const* eventName, u8 mapToolID);\n    int isMapToolCamera(u8 mapToolID, s32 roomNo);\n    int order(s16 eventCompositId);\n    int startCheck(s16 eventCompositId);\n    int startCheckOld(char const* name);\n    int endCheck(s16);\n    int endCheckOld(char const* name);\n    int getMyStaffId(char const* staffName, fopAc_ac_c* pActor, int tagId);\n    int getIsAddvance(int staffIdx);\n    int getMyActIdx(int staffIdx, char const* const* param_1, int param_2, int param_3,\n                    int param_4);\n    char* getMyNowCutName(int cutIndex);\n    dEvDtData_c* getMyDataP(int index, char const* name, int type);\n    void* getMySubstanceP(int index, char const* name, int type);\n    int getMySubstanceNum(int index, char const* name);\n    void cutEnd(int cutIndex);\n    int getEventPrio(fopAc_ac_c* pActor, s16 eventCompositId);\n    void issueStaff(char const* name);\n    void cancelStaff(char const* name);\n    void setGoal(cXyz* p_goal);\n    cXyz* getGoal();\n    const char* getRunEventName();\n    fopAc_ac_c* specialCast_Shutter(s16 bsTypeId, int param_1);\n    fopAc_ac_c* specialCast(char const* name, int param_1);\n    int ChkPresentEnd();\n    int checkStartDemo();\n\n    int setStartDemo(int param_0) { return mEventException.setStartDemo(param_0); }\n    void setCameraPlay(int status) { mCameraPlay = status; }\n    dEvDtBase_c& getBase() { return mEventList[mCurrentEventType]; }\n    void setFlag(int flag) { mFlags.flagSet(flag); }\n    bool dataLoaded() { return mDataLoaded; }\n    int flagCheck(int flag) { return mFlags.flagCheck(flag); }\n\n    inline static s16 getIndexCompositId(s16 param_0) { return param_0 != -1 ? (s16)(param_0 & 0xff) : (s16)-1; }\n    static int getTypeCompositId(s16 param_0) { return param_0 == -1 ? 0 : param_0 >> 8; }\n\n    static s16 makeCompositId(s16 a, int b) { return a | (b << 8); }\n\nprivate:\n    /* 0x0000 */ dEvDtBase_c mEventList[11];\n    /* 0x018C */ s32 mCameraPlay;\n    /* 0x0190 */ dEvent_exception_c mEventException;\n    /* 0x019C */ cXyz mGoal;\n    /* 0x01A8 */ u8 field_0x1a8[2];\n    /* 0x01AA */ s16 mCurrentEventCompositId;\n    /* 0x01AC */ u8 field_0x1ac[4];\n    /* 0x01B0 */ int mRoomNo;\n    /* 0x01B4 */ u32 mCurrentEventType;\n    /* 0x01B8 */ s32 field_0x1b8;\n    /* 0x01BC */ dEvDtFlag_c mFlags;\n    /* 0x06BC */ bool mDataLoaded;\n};\n\n#endif /* D_EVENT_D_EVENT_MANAGER_H */\n/* end \"d/event/d_event_manager.h\" */\n/* \"include/d/com/d_com_inf_game.h\" line 10 \"d/particle/d_particle.h\" */\n#ifndef D_PARTICLE_D_PARTICLE_H\n#define D_PARTICLE_D_PARTICLE_H\n\n/* \"include/d/particle/d_particle.h\" line 3 \"JSystem/JParticle/JPAParticle.h\" */\n#ifndef JPAPARTICLE_H\n#define JPAPARTICLE_H\n\n/* \"include/JSystem/JParticle/JPAParticle.h\" line 3 \"dolphin/gx/GXStruct.h\" */\n/* end \"dolphin/gx/GXStruct.h\" */\n/* \"include/JSystem/JParticle/JPAParticle.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n/* \"include/JSystem/JParticle/JPAParticle.h\" line 6 \"JSystem/JGeometry.h\" */\n/* end \"JSystem/JGeometry.h\" */\n\n/* \"include/JSystem/JParticle/JPAParticle.h\" line 8 \"JSystem/JParticle/JPAList.h\" */\n#ifndef JPALIST_H\n#define JPALIST_H\n\n\ntemplate <class T>\nstruct JPANode {\n    JPANode() {\n        mpPrev = NULL;\n        mpNext = NULL;\n    }\n    ~JPANode() {}\n    JPANode<T>* getPrev() { return mpPrev; }\n    JPANode<T>* getNext() { return mpNext; }\n    T* getObject() { return &mData; }\n    JPANode<T>* mpPrev;\n    JPANode<T>* mpNext;\n    T mData;\n};\n\ntemplate <class T>\nstruct JPAList {\n    JPANode<T>* mpFirst;\n    JPANode<T>* mpLast;\n    u32 mNum;\n\n    JPAList() : mpFirst(NULL), mpLast(NULL), mNum() {}\n\n    JPANode<T>* getEnd() { return NULL; }\n    JPANode<T>* getFirst() const { return mpFirst; }\n    JPANode<T>* getLast() const { return mpLast; }\n    u32 getNum() const { return mNum; }\n\n    void push_front(JPANode<T>* node) {\n        if (mpFirst != NULL) {\n            node->mpPrev = NULL;\n            node->mpNext = mpFirst;\n            mpFirst->mpPrev = node;\n            mpFirst = node;\n        } else {\n            mpLast = node;\n            mpFirst = node;\n            node->mpPrev = NULL;\n            node->mpNext = NULL;\n        }\n\n        mNum++;\n    }\n\n    void push_back(JPANode<T>* node) {\n        if (mpLast != NULL) {\n            node->mpPrev = mpLast;\n            node->mpNext = NULL;\n            mpLast->mpNext = node;\n            mpLast = node;\n        } else {\n            mpFirst = node;\n            mpLast = node;\n            node->mpPrev = NULL;\n            node->mpNext = NULL;\n        }\n\n        mNum++;\n    }\n\n    JPANode<T>* pop_front() {\n        JPANode<T>* ret = NULL;\n\n        if (mNum == 1) {\n            ret = mpFirst;\n            mpLast = NULL;\n            mpFirst = NULL;\n            mNum--;\n        } else if (mNum) {\n            ret = mpFirst;\n            ret->mpNext->mpPrev = NULL;\n            mpFirst = ret->mpNext;\n            mNum--;\n        }\n\n        return ret;\n    }\n\n    JPANode<T>* pop_back() {\n        JPANode<T>* ret = NULL;\n\n        if (mNum == 1) {\n            ret = mpLast;\n            mpLast = NULL;\n            mpFirst = NULL;\n            mNum--;\n        } else if (mNum) {\n            ret = mpLast;\n            ret->mpPrev->mpNext = NULL;\n            mpLast = ret->mpPrev;\n            mNum--;\n        }\n\n        return ret;\n    }\n};\n\n#endif/* end \"JSystem/JParticle/JPAList.h\" */\n\nclass JKRHeap;\nclass JPABaseEmitter;\nclass JPABaseParticle;\nclass JPAEmitterCallBack;\nclass JPAEmitterManager;\nclass JPAParticleCallBack;\nclass JPAResourceManager;\nstruct JPAEmitterWorkData;\n\nclass JPABaseParticle {\npublic:\n    /* 8027EFEC */ void init_p(JPAEmitterWorkData*);\n    /* 8027F8C8 */ void init_c(JPAEmitterWorkData*, JPABaseParticle*);\n    /* 8027FFD0 */ void calc_p(JPAEmitterWorkData*);\n    /* 80280260 */ void calc_c(JPAEmitterWorkData*);\n    /* 802804C8 */ void canCreateChild(JPAEmitterWorkData*);\n    /* 80280548 */ f32 getWidth(JPABaseEmitter const*) const;\n    /* 80280568 */ f32 getHeight(JPABaseEmitter const*) const;\n    int getAge() { return mAge; }\n    void setOffsetPosition(const JGeometry::TVec3<f32>& pos) { mOffsetPosition.set(pos); }\n    void setOffsetPosition(f32 x, f32 y, f32 z) { mOffsetPosition.set(x, y, z); }\n    void getOffsetPosition(JGeometry::TVec3<f32>& pos) { pos.set(mOffsetPosition); }\n    u16 getRotateAngle() const { return mRotateAngle; }\n    void getGlobalPosition(JGeometry::TVec3<f32>& pos) const { pos.set(mPosition); }\n    f32 getParticleScaleX() const { return mParticleScaleX; }\n    f32 getParticleScaleY() const { return mParticleScaleY; }\n    void setStatus(u32 flag) { mStatus |= flag; }\n    u32 checkStatus(u32 flag) { return mStatus & flag; }\n    void setInvisibleParticleFlag() { setStatus(8); }\n    void setDeleteParticleFlag() { setStatus(2); }\n    void getVelVec(JGeometry::TVec3<f32>& vec) const { vec.set(mVelocity); }\n    void getLocalPosition(JGeometry::TVec3<f32>& vec) const { vec.set(mLocalPosition); }\n\npublic:\n    /* 0x00 */ JGeometry::TVec3<f32> mPosition;\n    /* 0x0C */ JGeometry::TVec3<f32> mLocalPosition;\n    /* 0x18 */ JGeometry::TVec3<f32> mOffsetPosition;\n    /* 0x24 */ JGeometry::TVec3<f32> mVelocity;\n    /* 0x30 */ Vec mVelType1;\n    /* 0x3C */ Vec mVelType0;\n    /* 0x48 */ Vec mVelType2;\n    /* 0x54 */ JGeometry::TVec3<f32> mBaseAxis;\n    /* 0x60 */ f32 mParticleScaleX;\n    /* 0x64 */ f32 mParticleScaleY;\n    /* 0x68 */ f32 mScaleOut;\n    /* 0x6C */ f32 mAlphaWaveRandom;\n    /* 0x70 */ f32 mMoment;\n    /* 0x74 */ f32 mDrag;\n    /* 0x78 */ u32 field_0x78;\n    /* 0x7C */ u32 mStatus;\n    /* 0x80 */ s16 mAge;\n    /* 0x82 */ u16 mLifeTime;\n    /* 0x84 */ f32 mTime;\n    /* 0x88 */ u16 mRotateAngle;\n    /* 0x8A */ u16 mRotateSpeed;\n    /* 0x8C */ GXColor mPrmClr;\n    /* 0x90 */ GXColor mEnvClr;\n    /* 0x94 */ u8 mTexAnmIdx;\n    /* 0x95 */ u8 mAnmRandom;\n    /* 0x96 */ u8 mPrmColorAlphaAnm;\n};\n\nclass JPAParticleCallBack {\npublic:\n    JPAParticleCallBack() {}\n    virtual ~JPAParticleCallBack();\n    virtual void execute(JPABaseEmitter*, JPABaseParticle*);\n    virtual void draw(JPABaseEmitter*, JPABaseParticle*);\n};\n\n// not sure where this belongs\nstatic inline u32 COLOR_MULTI(u32 a, u32 b) {\n    return ((a * (b + 1)) * 0x10000) >> 24;\n}\n\n#endif /* JPAPARTICLE_H */\n/* end \"JSystem/JParticle/JPAParticle.h\" */\n/* \"include/d/particle/d_particle.h\" line 4 \"JSystem/JParticle/JPAEmitter.h\" */\n#ifndef JPAEMITTER_H\n#define JPAEMITTER_H\n\n/* \"include/JSystem/JParticle/JPAEmitter.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n/* \"include/JSystem/JParticle/JPAEmitter.h\" line 4 \"dolphin/gx/GXStruct.h\" */\n/* end \"dolphin/gx/GXStruct.h\" */\n/* \"include/JSystem/JParticle/JPAEmitter.h\" line 5 \"JSystem/JParticle/JPAResource.h\" */\n#ifndef JPARESOURCE_H\n#define JPARESOURCE_H\n\n/* \"include/JSystem/JParticle/JPAResource.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass JKRHeap;\nclass JPAEmitterWorkData;\nclass JPABaseEmitter;\nclass JPABaseParticle;\n\nclass JPABaseShape;\nclass JPAExtraShape;\nclass JPAChildShape;\nclass JPAExTexShape;\nclass JPADynamicsBlock;\nclass JPAFieldBlock;\nclass JPAKeyBlock;\n\nclass JPAResource {\npublic:\n    /* 80274010 */ JPAResource();\n    /* 80274080 */ void init(JKRHeap*);\n    /* 802755E8 */ bool calc(JPAEmitterWorkData*, JPABaseEmitter*);\n    /* 80275A94 */ void draw(JPAEmitterWorkData*, JPABaseEmitter*);\n    /* 80275B74 */ void drawP(JPAEmitterWorkData*);\n    /* 80275EB0 */ void drawC(JPAEmitterWorkData*);\n    /* 802761A8 */ void setPTev();\n    /* 8027642C */ void setCTev(JPAEmitterWorkData*);\n    /* 8027658C */ void calc_p(JPAEmitterWorkData*, JPABaseParticle*);\n    /* 80276608 */ void calc_c(JPAEmitterWorkData*, JPABaseParticle*);\n    /* 80276684 */ void calcField(JPAEmitterWorkData*, JPABaseParticle*);\n    /* 80276700 */ void calcKey(JPAEmitterWorkData*);\n    /* 80276840 */ void calcWorkData_c(JPAEmitterWorkData*);\n    /* 80276A0C */ void calcWorkData_d(JPAEmitterWorkData*);\n\n    JPABaseShape* getBsp() const { return mpBaseShape; }\n    JPAExtraShape* getEsp() const { return mpExtraShape; }\n    JPAChildShape* getCsp() const { return mpChildShape; }\n    JPAExTexShape* getEts() const { return mpExTexShape; }\n    JPADynamicsBlock* getDyn() const { return mpDynamicsBlock; }\n\n    u32 getTexIdx(u32 idx) const { return mpTDB1[idx]; }\n    u16 getUsrIdx() const { return mUsrIdx; }\n\npublic:\n    /* 0x00 */ void** mpCalcEmitterFuncList;\n    /* 0x04 */ void** mpDrawEmitterFuncList;\n    /* 0x08 */ void** mpDrawEmitterChildFuncList;\n    /* 0x0C */ void** mpCalcParticleFuncList;\n    /* 0x10 */ void** mpDrawParticleFuncList;\n    /* 0x14 */ void** mpCalcParticleChildFuncList;\n    /* 0x18 */ void** mpDrawParticleChildFuncList;\n\n    /* 0x1C */ JPABaseShape* mpBaseShape;\n    /* 0x20 */ JPAExtraShape* mpExtraShape;\n    /* 0x24 */ JPAChildShape* mpChildShape;\n    /* 0x28 */ JPAExTexShape* mpExTexShape;\n    /* 0x2C */ JPADynamicsBlock* mpDynamicsBlock;\n    /* 0x30 */ JPAFieldBlock** mpFieldBlocks;\n    /* 0x34 */ JPAKeyBlock** mpKeyBlocks;\n    /* 0x38 */ u16 const* mpTDB1;\n    /* 0x3C */ u16 mUsrIdx;\n    /* 0x3E */ u8 mFieldBlockNum;\n    /* 0x3F */ u8 mKeyBlockNum;\n    /* 0x40 */ u8 mTDB1Num;\n    /* 0x41 */ u8 mpCalcEmitterFuncListNum;\n    /* 0x42 */ u8 mpDrawEmitterFuncListNum;\n    /* 0x43 */ u8 mpDrawEmitterChildFuncListNum;\n    /* 0x44 */ u8 mpCalcParticleFuncListNum;\n    /* 0x45 */ u8 mpDrawParticleFuncListNum;\n    /* 0x46 */ u8 mpCalcParticleChildFuncListNum;\n    /* 0x47 */ u8 mpDrawParticleChildFuncListNum;\n};\n\n#endif /* JPARESOURCE_H */\n/* end \"JSystem/JParticle/JPAResource.h\" */\n/* \"include/JSystem/JParticle/JPAEmitter.h\" line 6 \"JSystem/JParticle/JPAList.h\" */\n/* end \"JSystem/JParticle/JPAList.h\" */\n/* \"include/JSystem/JParticle/JPAEmitter.h\" line 7 \"JSystem/JParticle/JPARandom.h\" */\n#ifndef JPARANDOM_H\n#define JPARANDOM_H\n\n\nstruct JPARandom {\npublic:\n    JPARandom() { mSeed = 0; }\n    void set_seed(u32 seed) { mSeed = seed; }\n\n    u32 get_rndm_u() { return mSeed = mSeed * 0x19660du + 0x3c6ef35fu; }\n\n    f32 get_rndm_f() {\n        union {\n            u32 u;\n            f32 f;\n        } a;\n        a.u = ((get_rndm_u() >> 9) | 0x3f800000);\n        return a.f - 1.0f;\n    }\n\n    f32 get_rndm_zp() {\n        f32 f = get_rndm_f();\n        return (f + f) - 1.0f;\n    }\n\n    f32 get_rndm_zh() {\n        f32 f = get_rndm_f();\n        return f - 0.5f;\n    }\n\n    s16 get_rndm_ss() { return (s16)(get_rndm_u() >> 16); }\n\npublic:\n    u32 mSeed;\n};\n\n#endif/* end \"JSystem/JParticle/JPARandom.h\" */\n/* \"include/JSystem/JParticle/JPAEmitter.h\" line 8 \"JSystem/JParticle/JPAMath.h\" */\n#ifndef JPAMATH_H\n#define JPAMATH_H\n\n/* \"include/JSystem/JParticle/JPAMath.h\" line 3 \"dolphin/mtx/mtx.h\" */\n/* end \"dolphin/mtx/mtx.h\" */\n/* \"include/JSystem/JParticle/JPAMath.h\" line 4 \"JSystem/JGeometry.h\" */\n/* end \"JSystem/JGeometry.h\" */\n\nvoid JPAGetDirMtx(JGeometry::TVec3<f32> const& param_0, f32 (*param_1)[4]);\nvoid JPAGetYZRotateMtx(s16 angleY, s16 angleZ, f32 (*param_2)[4]);\nvoid JPAGetXYZRotateMtx(s16 x, s16 y, s16 z, Mtx dst);\nvoid JPASetRMtxTVecfromMtx(f32 const (*param_0)[4], f32 (*param_1)[4],\n                               JGeometry::TVec3<f32>* param_2);\nf32 JPACalcKeyAnmValue(f32 param_0, u16 param_1, f32 const* param_2);\nvoid JPASetRMtxSTVecfromMtx(f32 const (*param_0)[4], f32 (*param_1)[4],\n                                JGeometry::TVec3<f32>* param_2, JGeometry::TVec3<f32>* param_3);\n\n#endif /* JPAMATH_H */\n/* end \"JSystem/JParticle/JPAMath.h\" */\n/* \"include/JSystem/JParticle/JPAEmitter.h\" line 9 \"JSystem/JParticle/JPADynamicsBlock.h\" */\n#ifndef JPADYNAMICSBLOCK_H\n#define JPADYNAMICSBLOCK_H\n\n/* \"include/JSystem/JParticle/JPADynamicsBlock.h\" line 3 \"JSystem/JGeometry.h\" */\n/* end \"JSystem/JGeometry.h\" */\n\n/* \"include/JSystem/JParticle/JPADynamicsBlock.h\" line 5 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass JPAEmitterWorkData;\n\nstruct JPADynamicsBlockData {\n    // Common header.\n    /* 0x00 */ u8 mMagic[4];\n    /* 0x04 */ u32 mSize;\n\n    /* 0x08 */ u32 mFlags;\n    /* 0x0C */ u32 mResUserWork;\n    /* 0x10 */ JGeometry::TVec3<f32> mEmitterScl;\n    /* 0x1C */ JGeometry::TVec3<f32> mEmitterTrs;\n    /* 0x28 */ JGeometry::TVec3<f32> mEmitterDir;\n    /* 0x34 */ f32 mInitialVelOmni;\n    /* 0x38 */ f32 mInitialVelAxis;\n    /* 0x3C */ f32 mInitialVelRndm;\n    /* 0x40 */ f32 mInitialVelDir;\n    /* 0x44 */ f32 mSpread;\n    /* 0x48 */ f32 mInitialVelRatio;\n    /* 0x4C */ f32 mRate;\n    /* 0x50 */ f32 mRateRndm;\n    /* 0x54 */ f32 mLifeTimeRndm;\n    /* 0x58 */ f32 mVolumeSweep;\n    /* 0x5C */ f32 mVolumeMinRad;\n    /* 0x60 */ f32 mAirResist;\n    /* 0x64 */ f32 mMoment;\n    /* 0x68 */ JGeometry::TVec3<s16> mEmitterRot;\n    /* 0x6E */ s16 mMaxFrame;\n    /* 0x70 */ s16 mStartFrame;\n    /* 0x72 */ s16 mLifeTime;\n    /* 0x74 */ u16 mVolumeSize;\n    /* 0x76 */ u16 mDivNumber;\n    /* 0x78 */ u8 mRateStep;\n    /* 0x7C */ u32 field_0x7c;\n};\n\ntypedef void (*JPADynamicsCalcVolumeFunc)(JPAEmitterWorkData*);\n\nenum {\n    JPADynFlag_FixedDensity = 0x01,\n    JPADynFlag_FixedInterval = 0x02,\n    JPADynFlag_InheritScale = 0x04,\n    JPADynFlag_FollowEmtr = 0x08,\n    JPADynFlag_FollowEmtrChld = 0x10,\n};\n\nclass JPADynamicsBlock {\npublic:\n    /* 8027BB18 */ JPADynamicsBlock(u8 const*);\n    /* 8027BB4C */ void init();\n    /* 8027BBE8 */ void create(JPAEmitterWorkData*);\n\n    void calc(JPAEmitterWorkData* work) { mpCalcVolumeFunc(work); }\n\n    s16 getStartFrame() const { return mpData->mStartFrame; }\n    u32 getResUserWork() const { return mpData->mResUserWork; }\n    u32 getFlag() const { return mpData->mFlags; }\n    u32 getVolumeType() const { return (mpData->mFlags >> 8) & 0x07; }\n    u16 getDivNumber() const { return mpData->mDivNumber; }\n    f32 getRateRndm() const { return mpData->mRateRndm; }\n    void getEmitterScl(JGeometry::TVec3<f32>* vec) const { \n        vec->set(mpData->mEmitterScl.x, mpData->mEmitterScl.y, mpData->mEmitterScl.z); \n    }\n    void getEmitterTrs(JGeometry::TVec3<f32>* vec) const { \n        vec->set(mpData->mEmitterTrs.x, mpData->mEmitterTrs.y, mpData->mEmitterTrs.z); \n    }\n    void getEmitterDir(JGeometry::TVec3<f32>* vec) const { \n        vec->set(mpData->mEmitterDir.x, mpData->mEmitterDir.y, mpData->mEmitterDir.z); \n    }\n    void getEmitterRot(JGeometry::TVec3<s16>* vec) const { \n        vec->set(mpData->mEmitterRot.x, mpData->mEmitterRot.y, mpData->mEmitterRot.z); \n    } \n    s16 getMaxFrame() { return mpData->mMaxFrame; }\n    s16 getLifetime() { return mpData->mLifeTime; }\n    u16 getVolumeSize() { return mpData->mVolumeSize; }\n    f32 getRate() { return mpData->mRate; }\n    u8 getRateStep() { return mpData->mRateStep; }\n    f32 getVolumeSweep() { return mpData->mVolumeSweep; }\n    f32 getVolumeMinRad() { return mpData->mVolumeMinRad; }\n    f32 getInitVelOmni() { return mpData->mInitialVelOmni; }\n    f32 getInitVelAxis() { return mpData->mInitialVelAxis; }\n    f32 getInitVelDir() { return mpData->mInitialVelDir; }\n    f32 getInitVelDirSp() { return mpData->mSpread; }\n    f32 getInitVelRndm() { return mpData->mInitialVelRndm; }\n    f32 getAirRes() { return mpData->mAirResist; }\n\npublic:\n    /* 0x00 */ const JPADynamicsBlockData* mpData;\n    /* 0x04 */ JPADynamicsCalcVolumeFunc mpCalcVolumeFunc;\n};\n\n#endif /* JPADYNAMICSBLOCK_H */\n/* end \"JSystem/JParticle/JPADynamicsBlock.h\" */\n/* \"include/JSystem/JParticle/JPAEmitter.h\" line 10 \"JSystem/JSupport/JSUList.h\" */\n/* end \"JSystem/JSupport/JSUList.h\" */\n\nclass JPAResourceManager;\nclass JPABaseEmitter;\nclass JPAEmitterManager;\nclass JPAParticleCallBack;\n\nstruct JPAEmitterWorkData {\n    /* 0x00 */ JPABaseEmitter* mpEmtr;\n    /* 0x04 */ JPAResource* mpRes;\n    /* 0x08 */ JPAResourceManager* mpResMgr;\n    /* 0x0C */ JPARandom mRndm;\n    /* 0x10 */ JGeometry::TVec3<f32> mVolumePos;\n    /* 0x1C */ JGeometry::TVec3<f32> mVelOmni;\n    /* 0x28 */ JGeometry::TVec3<f32> mVelAxis;\n    /* 0x34 */ f32 mVolumeSize;\n    /* 0x38 */ f32 mVolumeMinRad;\n    /* 0x3C */ f32 mVolumeSweep;\n    /* 0x40 */ s32 mEmitCount;\n    /* 0x44 */ s32 mVolumeEmitIdx;\n    /* 0x48 */ Mtx mDirectionMtx;\n    /* 0x78 */ Mtx mRotationMtx;\n    /* 0xA8 */ Mtx mGlobalRot;\n    /* 0xD8 */ Mtx mGlobalSR;\n    /* 0x108 */ JGeometry::TVec3<f32> mEmitterPos;\n    /* 0x114 */ JGeometry::TVec3<f32> mGlobalScl;\n    /* 0x120 */ JGeometry::TVec3<f32> mGlobalEmtrDir;\n    /* 0x12C */ JGeometry::TVec3<f32> mPublicScale;\n    /* 0x138 */ JGeometry::TVec3<f32> mGlobalPos;\n    /* 0x144 */ JGeometry::TVec2<f32> mGlobalPtclScl;\n    /* 0x14C */ JGeometry::TVec2<f32> mPivot;\n    /* 0x154 */ Mtx mYBBCamMtx;\n    /* 0x184 */ Mtx mPosCamMtx;\n    /* 0x1B4 */ Mtx mPrjMtx;\n    /* 0x1E4 */ JPAList<JPABaseParticle>* mpAlivePtcl;\n    /* 0x1E8 */ JPANode<JPABaseParticle>* mpCurNode;\n    /* 0x1EC */ u32 mVolumeAngleNum;\n    /* 0x1F0 */ u32 mVolumeAngleMax;\n    /* 0x1F4 */ u32 mVolumeX;\n    /* 0x1F8 */ u32 mDivNumber;\n    /* 0x1FC */ f32 mScaleAnm;\n    /* 0x200 */ u32 mDirType;\n    /* 0x204 */ u32 mRotType;\n    /* 0x208 */ u32 mPlaneType;\n    /* 0x20C */ u32 mDLType;\n    /* 0x210 */ u32 mPrjType;\n    /* 0x214 */ s16 mClrKeyFrame;\n    /* 0x216 */ u8 mDrawCount;\n};\n\nclass JPAEmitterCallBack {\npublic:\n    /* 80050368 */ virtual void execute(JPABaseEmitter*);\n    /* 80050374 */ virtual void executeAfter(JPABaseEmitter*);\n    /* 8005036C */ virtual void draw(JPABaseEmitter*);\n    /* 80050370 */ virtual void drawAfter(JPABaseEmitter*);\n    \n    /* 8027E6A4 */ ~JPAEmitterCallBack();\n};\n\nenum {\n    JPAEmtrStts_StopEmit = 0x01,\n    JPAEmtrStts_StopCalc = 0x02,\n    JPAEmtrStts_StopDraw = 0x04,\n    JPAEmtrStts_EnableDeleteEmitter = 0x08,\n    JPAEmtrStts_FirstEmit = 0x10,\n    JPAEmtrStts_RateStepEmit = 0x20,\n    JPAEmtrStts_Immortal = 0x40,\n};\n\nclass JPABaseEmitter {\npublic:\n    /* 8027E5EC */ ~JPABaseEmitter();\n    /* 8027E64C */ JPABaseEmitter();\n    /* 8027E6EC */ void init(JPAEmitterManager*, JPAResource*);\n    /* 8027EDD4 */ bool processTillStartFrame();\n    /* 8027EE14 */ bool processTermination();\n    /* 8027EEB0 */ void calcEmitterGlobalPosition(JGeometry::TVec3<f32>*) const;\n    /* 8027EC60 */ void deleteAllParticle();\n    /* 8027EB60 */ JPABaseParticle* createChild(JPABaseParticle*);\n    /* 8027EA40 */ JPABaseParticle* createParticle();\n    /* 8027EF30 */ u32 getCurrentCreateNumber() const;\n    /* 8027EF40 */ u8 getDrawCount() const;\n    /* 8027EF50 */ bool loadTexture(u8, GXTexMapID);\n\n    void initStatus(u32 status) { mStatus = status; }\n    void setStatus(u32 status) { mStatus |= status; }\n    void clearStatus(u32 status) { mStatus &= ~status; }\n    u32 checkStatus(u32 status) { return (mStatus & status); }\n    bool checkFlag(u32 flag) { return !!(mpRes->getDyn()->getFlag() & flag); }\n    u8 getResourceManagerID() const { return mResMgrID; }\n    u8 getGroupID() const { return mGroupID; }\n    u8 getDrawTimes() const { return mDrawTimes; }\n    void setRate(f32 rate) { mRate = rate; }\n    void setEmitterCallBackPtr(JPAEmitterCallBack* ptr) { mpEmtrCallBack = ptr; }\n    void setGlobalRTMatrix(const Mtx m) { JPASetRMtxTVecfromMtx(m, mGlobalRot, &mGlobalTrs); }\n    void setGlobalTranslation(f32 x, f32 y, f32 z) { mGlobalTrs.set(x, y, z); }\n    void getLocalTranslation(JGeometry::TVec3<f32>& vec) { vec.set(mLocalTrs); }\n    void setGlobalRotation(const JGeometry::TVec3<s16>& rot) {\n        JPAGetXYZRotateMtx(rot.x, rot.y, rot.z, mGlobalRot); \n    }\n    void setGlobalAlpha(u8 alpha) { mGlobalPrmClr.a = alpha; }\n    u8 getGlobalAlpha() { return mGlobalPrmClr.a; }\n    void getGlobalPrmColor(GXColor& color) { color = mGlobalPrmClr; }\n    void setGlobalPrmColor(u8 r, u8 g, u8 b) { mGlobalPrmClr.r = r; mGlobalPrmClr.g = g; mGlobalPrmClr.b = b; }\n    void setGlobalEnvColor(u8 r, u8 g, u8 b) { mGlobalEnvClr.r = r; mGlobalEnvClr.g = g; mGlobalEnvClr.b = b; }\n    void setVolumeSize(u16 size) { mVolumeSize = size; }\n    void setLifeTime(s16 lifetime) { mLifeTime = lifetime; }\n\n    void setGlobalParticleScale(const JGeometry::TVec3<f32>& scale) {\n        mGlobalPScl.set(scale.x, scale.y);\n    }\n    void getGlobalParticleScale(JGeometry::TVec3<f32>& scale) {\n        scale.set(mGlobalPScl.x, mGlobalPScl.y, 1.0f);\n    }\n    void setGlobalScale(const JGeometry::TVec3<f32>& scale) {\n        mGlobalScl.set(scale);\n        mGlobalPScl.set(scale.x ,scale.y);\n    }\n\n    f32 get_r_f() { return mRndm.get_rndm_f(); }\n    f32 get_r_zp() { return mRndm.get_rndm_zp(); }\n    f32 get_r_zh() { return mRndm.get_rndm_zh(); }\n    s16 get_r_ss() { return mRndm.get_rndm_ss(); }\n\n    void stopCreateParticle() { setStatus(JPAEmtrStts_StopEmit); }\n    void playCreateParticle() { clearStatus(JPAEmtrStts_StopEmit); }\n    void becomeImmortalEmitter() { setStatus(JPAEmtrStts_Immortal); }\n    void becomeContinuousParticle() { mMaxFrame = 0; }\n    void becomeInvalidEmitter() {\n        stopCreateParticle();\n        mMaxFrame = 1;\n    }\n\n    void quitImmortalEmitter() { clearStatus(JPAEmtrStts_Immortal); }\n    void stopCalcEmitter() { setStatus(JPAEmtrStts_StopCalc); }\n    void playCalcEmitter() { clearStatus(JPAEmtrStts_StopCalc); }\n    void stopDrawParticle() { setStatus(JPAEmtrStts_StopDraw); }\n    void playDrawParticle() { clearStatus(JPAEmtrStts_StopDraw); }\n\n    u32 getUserWork() { return mpUserWork; }\n    void setUserWork(u32 userWork) { mpUserWork = userWork; }\n    u32 getParticleNumber() {\n        return mAlivePtclBase.getNum() + mAlivePtclChld.getNum();\n    }\n    bool isEnableDeleteEmitter() {\n        return checkStatus(JPAEmtrStts_EnableDeleteEmitter) && getParticleNumber() == 0;\n    }\n    void setDrawTimes(u8 drawTimes) { mDrawTimes = drawTimes; }\n    void setParticleCallBackPtr(JPAParticleCallBack* cb) { mpPtclCallBack = cb; }\n    JPAParticleCallBack* getParticleCallBackPtr() { return mpPtclCallBack; }\n    JPAEmitterCallBack* getEmitterCallBackPtr() const { return mpEmtrCallBack; }\n    u32 getAge() const { return mTick; }\n\npublic:\n    /* 0x00 */ JGeometry::TVec3<f32> mLocalScl;\n    /* 0x0C */ JGeometry::TVec3<f32> mLocalTrs;\n    /* 0x18 */ JGeometry::TVec3<f32> mLocalDir;\n    /* 0x24 */ s32 mMaxFrame;\n    /* 0x28 */ f32 mRate;\n    /* 0x2C */ f32 mVolumeSweep;\n    /* 0x30 */ f32 mVolumeMinRad;\n    /* 0x34 */ f32 mAwayFromCenterSpeed;\n    /* 0x38 */ f32 mAwayFromAxisSpeed;\n    /* 0x3C */ f32 mDirSpeed;\n    /* 0x40 */ f32 mSpread;\n    /* 0x44 */ f32 mRndmDirSpeed;\n    /* 0x48 */ f32 mAirResist;\n    /* 0x4C */ JGeometry::TVec3<s16> mLocalRot;\n    /* 0x52 */ u16 mLifeTime;\n    /* 0x54 */ u16 mVolumeSize;\n    /* 0x56 */ u8 mRateStep;\n    /* 0x58 */ JSULink<JPABaseEmitter> mLink;\n    /* 0x68 */ Mtx mGlobalRot;\n    /* 0x98 */ JGeometry::TVec3<f32> mGlobalScl;\n    /* 0xA4 */ JGeometry::TVec3<f32> mGlobalTrs;\n    /* 0xB0 */ JGeometry::TVec2<f32> mGlobalPScl;\n    /* 0xB8 */ GXColor mGlobalPrmClr;\n    /* 0xBC */ GXColor mGlobalEnvClr;\n    /* 0xC0 */ s32 mpUserWork;\n    /* 0xC4 */ JPARandom mRndm;\n    /* 0xC8 */ JPAList<JPABaseParticle> mAlivePtclBase;\n    /* 0xD4 */ JPAList<JPABaseParticle> mAlivePtclChld;\n    /* 0xE0 */ JPAList<JPABaseParticle>* mpPtclPool;\n    /* 0xE4 */ JPAEmitterManager* mpEmtrMgr;\n    /* 0xE8 */ JPAResource* mpRes;\n    /* 0xEC */ JPAEmitterCallBack* mpEmtrCallBack;\n    /* 0xF0 */ JPAParticleCallBack* mpPtclCallBack;\n    /* 0xF4 */ volatile u32 mStatus;\n    /* 0xF8 */ f32 mEmitCount;\n    /* 0xFC */ f32 mScaleOut;\n    /* 0x100 */ u32 mTick;\n    /* 0x104 */ s16 mWaitTime;\n    /* 0x106 */ s16 mRateStepTimer;\n    /* 0x108 */ GXColor mPrmClr;\n    /* 0x10C */ GXColor mEnvClr;\n    /* 0x110 */ u8 mDrawTimes;\n    /* 0x111 */ u8 mTexAnmIdx;\n    /* 0x112 */ u8 mGroupID;\n    /* 0x113 */ u8 mResMgrID;\n};\n\nenum {\n    JPAPtclStts_Invisible = 0x08,\n};\n\n#endif /* JPAEMITTER_H */\n/* end \"JSystem/JParticle/JPAEmitter.h\" */\n/* \"include/d/particle/d_particle.h\" line 5 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n/* \"include/d/particle/d_particle.h\" line 6 \"d/kankyo/d_kankyo.h\" */\n/* end \"d/kankyo/d_kankyo.h\" */\n\nclass J3DAnmTexPattern;\nclass J3DModel;\nclass J3DModelData;\nclass JKRExpHeap;\nclass JKRSolidHeap;\nclass dKy_tevstr_c;\nclass fopAc_ac_c;\n\nclass dPa_levelEcallBack : public JPAEmitterCallBack {\npublic:\n    /* 8004FB18 */ virtual ~dPa_levelEcallBack(); /* { cleanup(); } */ // should be inlined\n    virtual void setup(JPABaseEmitter*, const cXyz*, const csXyz*, s8) = 0;\n    /* 8004FB8C */ virtual void cleanup();\n};\n\nclass dPa_hermiteEcallBack_c : public dPa_levelEcallBack {\npublic:\n    dPa_hermiteEcallBack_c() {}\n\n    /* 8004F6B8 */ void setOldPosP(cXyz const*, cXyz const*);\n\n    /* 8004FCC8 */ virtual ~dPa_hermiteEcallBack_c(); // should be inlined\n    /* 8004F6C4 */ virtual void executeAfter(JPABaseEmitter*);\n    /* 8004FABC */ virtual void setup(JPABaseEmitter*, cXyz const*, csXyz const*, s8);\n\nprivate:\n    /* 0x04 */ f32 mRate;\n    /* 0x08 */ int mMaxCnt;\n    /* 0x0C */ cXyz const* field_0xc;\n    /* 0x10 */ cXyz const* field_0x10;\n    /* 0x14 */ cXyz const* field_0x14;\n};\n\nclass mDoDvdThd_toMainRam_c;\nclass cBgS_PolyInfo;\nclass JPAEmitterManager;\nclass JPADrawInfo;\nclass J3DAnmBase;\n\nclass dPa_simpleEcallBack : public JPAEmitterCallBack {\npublic:\n    /* 8004ADF4 */ dPa_simpleEcallBack();\n    /* 8004AF98 */ JPABaseEmitter* create(JPAEmitterManager*, u16, u8);\n    /* 8004B064 */ JPABaseEmitter* createEmitter(JPAEmitterManager*);\n    /* 8004B168 */ u32 set(cXyz const*, dKy_tevstr_c const*, u8, _GXColor const&, _GXColor const&,\n                            int, f32);\n\n    /* 8004FC08 */ virtual ~dPa_simpleEcallBack();\n    /* 8004AE1C */ virtual void executeAfter(JPABaseEmitter*);\n    /* 8004AF94 */ virtual void draw(JPABaseEmitter*);\n\n    void removeEmitter() { mEmitter = NULL; }\n    u16 getID() const { return mID; }\n\n    /* 0x04 */ JPABaseEmitter* mEmitter;\n    /* 0x08 */ u16 mID;\n    /* 0x0A */ u8 field_0xa;\n    /* 0x0C */ s16 field_0xc;\n    /* 0x0C */ u16 field_0xe;\n    /* 0x10 */ void* mData;\n};  // Size: 0x14\n\nclass dPa_followEcallBack : public dPa_levelEcallBack {\npublic:\n    /* 80049580 */ dPa_followEcallBack(u8, u8);\n    /* 80D22230 */ void __defctor();  // compiler generated\n\n    /* 80050200 */ virtual ~dPa_followEcallBack();\n    /* 800495BC */ virtual void execute(JPABaseEmitter*);\n    /* 800496B0 */ virtual void draw(JPABaseEmitter*);\n    /* 800496B4 */ virtual void setup(JPABaseEmitter*, cXyz const*, csXyz const*, s8);\n    /* 80050284 */ virtual void cleanup();\n    /* 8004974C */ virtual void end();\n\n    void remove() { end(); }\n    JPABaseEmitter* getEmitter() { return mpEmitter; }\n    bool isEnd() {\n        return field_0x10 & 1;\n    }\n\n    /* 0x04 */ JPABaseEmitter* mpEmitter;\n    /* 0x08 */ const cXyz* field_0x8;\n    /* 0x0C */ const csXyz* field_0xc;\n    /* 0x10 */ u8 field_0x10;\n    /* 0x11 */ u8 field_0x11;\n    /* 0x12 */ u8 field_0x12;\n    /* 0x13 */ u8 field_0x13;\n};\n\nclass dPa_windPcallBack : public JPAParticleCallBack {\npublic:\n    /* 8004FF2C */ virtual ~dPa_windPcallBack();\n    /* 8004B4E0 */ virtual void execute(JPABaseEmitter*, JPABaseParticle*);\n};\n\nclass dPa_wbPcallBack_c : public JPAParticleCallBack {\npublic:\n    /* 8004FECC */ virtual ~dPa_wbPcallBack_c();\n    /* 8004DC28 */ virtual void execute(JPABaseEmitter*, JPABaseParticle*);\n};\n\nclass dPa_setColorEcallBack : public dPa_levelEcallBack {\npublic:\n    dPa_setColorEcallBack(const GXColor& color) { mColor = color; }\n\n    /* 800502E4 */ virtual ~dPa_setColorEcallBack();\n    /* 800502B0 */ virtual void draw(JPABaseEmitter*);\n    /* 800502E0 */ virtual void setup(JPABaseEmitter*, cXyz const*, csXyz const*, s8);\n\n    /* 0x4 */ GXColor mColor;\n};\n\nclass dPa_selectTexEcallBack : public dPa_levelEcallBack {\npublic:\n    dPa_selectTexEcallBack(u8 param_0) { field_0x4 = param_0; }\n\n    /* 8004FF8C */ virtual ~dPa_selectTexEcallBack();\n    /* 8004ADC4 */ virtual void draw(JPABaseEmitter*);\n    /* 80050010 */ virtual void setup(JPABaseEmitter*, cXyz const*, csXyz const*, s8);\n\n    /* 0x4 */ u8 field_0x4;\n};\n\nclass dPa_particleTracePcallBack_c : public JPAParticleCallBack {\npublic:\n    /* 8004FC68 */ virtual ~dPa_particleTracePcallBack_c();\n    /* 8004FAD4 */ virtual void execute(JPABaseEmitter*, JPABaseParticle*);\n};\n\nclass dPa_modelPcallBack : public JPAParticleCallBack {\npublic:\n    /* 80050038 */ virtual ~dPa_modelPcallBack();\n    /* 8004A460 */ virtual void draw(JPABaseEmitter*, JPABaseParticle*);\n};\n\nclass dPa_modelEcallBack : public dPa_levelEcallBack {\npublic:\n    struct model_c {\n        /* 8004A608 */ bool set(J3DModelData*, dKy_tevstr_c const&, u8, void*, u8, u8);\n        /* 8004A7AC */ void setup();\n        /* 8004A88C */ void cleanup();\n        /* 8004A8DC */ void draw(f32 (*)[4]);\n        /* 8004AB88 */ ~model_c();\n        /* 8004FB90 */ model_c();\n\n        void reset() {\n            field_0x0 = 0;\n        }\n\n        u8 getRotAxis() { return mRotAxis; }\n        J3DModelData* getModelData() { return field_0x0; }\n\n        J3DModelData* field_0x0;\n        J3DAnmBase* field_0x4;\n        dKy_tevstr_c field_0x8;\n        u8 mRotAxis;\n        u8 field_0x391;\n        u8 field_0x392;\n        u8 field_0x393;\n    };\n\n    dPa_modelEcallBack() { mModel = NULL; }\n\n    /* 8004AB1C */ static void create(u8);\n    /* 8004ABC4 */ static void remove();\n    /* 8004AC00 */ static int setModel(JPABaseEmitter*, J3DModelData*, dKy_tevstr_c const&, u8,\n                                        void*, u8, u8);\n    /* 8004AC90 */ static void resetModel(JPABaseEmitter*);\n    /* 8004ACC0 */ static void setupModel(JPABaseEmitter*);\n    /* 8004ACEC */ static void drawModel(JPABaseEmitter*, f32 (*)[4]);\n    /* 8004AD28 */ static void cleanupModel(JPABaseEmitter*);\n    /* 8004AD58 */ static model_c* getModel(JPABaseEmitter*);\n    /* 8004AD90 */ static u8 getRotAxis(JPABaseEmitter*);\n\n    /* 80050378 */ virtual ~dPa_modelEcallBack();\n    /* 8004AA34 */ virtual void draw(JPABaseEmitter*);\n    /* 80050014 */ virtual void drawAfter(JPABaseEmitter*);\n    /* 8004AAA8 */ virtual void setup(JPABaseEmitter*, cXyz const*, csXyz const*, s8);\n\n    static void setModel(JPABaseEmitter* param_0, J3DModelData* param_1,\n                         const dKy_tevstr_c& param_2, u8 param_3, J3DAnmTexPattern* param_4,\n                         u8 param_5) {\n        setModel(param_0, param_1, param_2, param_3, param_4, param_5);\n    }\n\n    // Should be dPa_modelEcallBack\n    static dPa_modelEcallBack* getEcallback() { return mEcallback; }\n    static dPa_modelEcallBack* mEcallback;\n    static u8 mPcallback[4];\n    static model_c* mModel;\n};\n\nclass dPa_light8PcallBack : public JPAParticleCallBack {\npublic:\n    /* 8004FE0C */ virtual ~dPa_light8PcallBack();\n    /* 8004DD10 */ virtual void execute(JPABaseEmitter*, JPABaseParticle*);\n    /* 8004DD1C */ virtual void draw(JPABaseEmitter*, JPABaseParticle*);\n};\n\nclass dPa_light8EcallBack : public dPa_levelEcallBack {\npublic:\n    /* 8005015C */ virtual ~dPa_light8EcallBack();\n    /* 8004A340 */ virtual void draw(JPABaseEmitter*);\n    /* 800501E0 */ virtual void drawAfter(JPABaseEmitter*);\n    /* 8004979C */ virtual void setup(JPABaseEmitter*, cXyz const*, csXyz const*, s8);\n};\n\nclass dPa_gen_d_light8PcallBack : public JPAParticleCallBack {\npublic:\n    /* 8004FD4C */ virtual ~dPa_gen_d_light8PcallBack();\n    /* 8004DD18 */ virtual void execute(JPABaseEmitter*, JPABaseParticle*);\n    /* 8004ED44 */ virtual void draw(JPABaseEmitter*, JPABaseParticle*);\n};\n\nclass dPa_gen_d_light8EcallBack : public dPa_levelEcallBack {\npublic:\n    /* 800503FC */ virtual ~dPa_gen_d_light8EcallBack();\n    /* 8004A388 */ virtual void draw(JPABaseEmitter*);\n    /* 80050098 */ virtual void drawAfter(JPABaseEmitter*);\n    /* 800497CC */ virtual void setup(JPABaseEmitter*, cXyz const*, csXyz const*, s8);\n};\n\nclass dPa_gen_b_light8PcallBack : public JPAParticleCallBack {\npublic:\n    /* 8004FDAC */ virtual ~dPa_gen_b_light8PcallBack();\n    /* 8004DD14 */ virtual void execute(JPABaseEmitter*, JPABaseParticle*);\n    /* 8004E6A8 */ virtual void draw(JPABaseEmitter*, JPABaseParticle*);\n};\n\nclass dPa_gen_b_light8EcallBack : public dPa_levelEcallBack {\npublic:\n    /* 800500B8 */ virtual ~dPa_gen_b_light8EcallBack();\n    /* 8004A364 */ virtual void draw(JPABaseEmitter*);\n    /* 8005013C */ virtual void drawAfter(JPABaseEmitter*);\n    /* 800497B0 */ virtual void setup(JPABaseEmitter*, cXyz const*, csXyz const*, s8);\n};\n\nclass dPa_fsenthPcallBack : public JPAParticleCallBack {\npublic:\n    /* 8004FE6C */ virtual ~dPa_fsenthPcallBack();\n    /* 8004DCA0 */ virtual void execute(JPABaseEmitter*, JPABaseParticle*);\n    /* 8004DD0C */ virtual void draw(JPABaseEmitter*, JPABaseParticle*);\n};\n\nclass dPa_simpleData_c {\npublic:\n    /* 8004B024 */ ~dPa_simpleData_c();\n    /* 8004B060 */ dPa_simpleData_c();\n\n    u8 field_0x0[20];\n};\n\nclass dPa_control_c {\npublic:\n    class level_c {\n    public:\n        class emitter_c {\n        public:\n            /* 8004B504 */ void onActive();\n            /* 8004B544 */ void entry(u32, u16, JPABaseEmitter*, dPa_levelEcallBack*);\n            /* 8004B5AC */ void cleanup();\n            /* 8004FBFC */ emitter_c();\n\n            JPABaseEmitter* getEmitter() { return mEmitter; }\n            emitter_c* getPre() { return mPre; }\n            emitter_c* getNext() { return mNext; }\n            void setPre(emitter_c* pre) { mPre = pre; }\n            void setNext(emitter_c* next) { mNext = next; }\n\n            u32 getId() { return mId; }\n            void clearStatus() { mStatus = 0; }\n\n            void onEventMove() { mStatus |= 2; }\n            void offEventMove() { mStatus &= ~2; }\n            bool isEventMove() { return mStatus & 2; }\n\n            void offActive() { mStatus &= ~1; }\n            bool isActive() { return mStatus & 1; }\n            u16 getNameId() { return mNameId; }\n            dPa_levelEcallBack* getCallback() { return mCallback; }\n\n        private:\n            /* 0x00 */ u32 mId;\n            /* 0x04 */ u16 mNameId;\n            /* 0x06 */ u8 mStatus;\n            /* 0x08 */ JPABaseEmitter* mEmitter;\n            /* 0x0C */ dPa_levelEcallBack* mCallback;\n            /* 0x10 */ emitter_c* mPre;\n            /* 0x14 */ emitter_c* mNext;\n        };  // Size: 0x18\n\n        /* 8004B688 */ level_c();\n        /* 8004B7A8 */ void execute();\n        /* 8004B6F8 */ void execute(dPa_control_c::level_c::emitter_c*);\n        /* 8004B808 */ void cleanup();\n        /* 8004B874 */ emitter_c* get(u32);\n        /* 8004B8B4 */ void forceOnEventMove(u32);\n        /* 8004B8E8 */ void allForceOnEventMove();\n        /* 8004B918 */ JPABaseEmitter* getEmitter(u32);\n        /* 8004B94C */ u32 entry(u16, JPABaseEmitter*, dPa_levelEcallBack*);\n        /* 8004BA40 */ void addTable(dPa_control_c::level_c::emitter_c*);\n        /* 8004BA74 */ void cutTable(dPa_control_c::level_c::emitter_c*);\n\n        static const int EMITTER_MAX = 0x80;\n\n        /* 0x000 */ u32 field_0x0;\n        /* 0x004 */ u8 mFreeNo;\n        /* 0x005 */ u8 field_0x5;\n        /* 0x006 */ u8 field_0x6;\n        /* 0x008 */ emitter_c mEmitter[0x80];\n        /* 0xC08 */ emitter_c* mTable[0x100];\n    };  // Size: 0x1008\n\n    /* 8004BACC */ dPa_control_c();\n    /* 8004BB70 */ static u8 getRM_ID(u16);\n    /* 8004BB78 */ void createCommon(void const*);\n    /* 8004BCDC */ void createRoomScene();\n    /* 8004BDFC */ bool readScene(u8, mDoDvdThd_toMainRam_c**);\n    /* 8004BEB0 */ void createScene(void const*);\n    /* 8004BF3C */ bool removeRoomScene(bool);\n    /* 8004BFD4 */ void removeScene(bool);\n    /* 8004C054 */ void cleanup();\n    /* 8004C078 */ void calc3D();\n    /* 8004C0EC */ void calc2D();\n    /* 8004C134 */ void calcMenu();\n    /* 8004C188 */ void draw(JPADrawInfo*, u8);\n    /* 8004C218 */ void setHitMark(u16, fopAc_ac_c*, cXyz const*, csXyz const*, cXyz const*, u32);\n    /* 8004C838 */ void setWaterRipple(u32*, cBgS_PolyInfo&, cXyz const*, f32, dKy_tevstr_c const*,\n                                       cXyz const*, s8);\n    /* 8004CA90 */ JPABaseEmitter* set(u8, u16, cXyz const*, dKy_tevstr_c const*, csXyz const*, cXyz const*, u8,\n                           dPa_levelEcallBack*, s8, _GXColor const*, _GXColor const*, cXyz const*,\n                           f32);\n    /* 8004D4CC */ u32 set(u32, u8, u16, cXyz const*, dKy_tevstr_c const*, csXyz const*,\n                           cXyz const*, u8, dPa_levelEcallBack*, s8, _GXColor const*,\n                           _GXColor const*, cXyz const*, f32);\n    /* 8004CF90 */ static s32 getPolyColor(cBgS_PolyInfo&, int, _GXColor*, _GXColor*, u8*, f32*);\n    /* 8004D6A4 */ u32 setPoly(u32, u16, cBgS_PolyInfo&, cXyz const*, dKy_tevstr_c const*,\n                               csXyz const*, cXyz const*, int, dPa_levelEcallBack*, s8,\n                               cXyz const*);\n    /* 8004D068 */ JPABaseEmitter* setPoly(u16, cBgS_PolyInfo&, cXyz const*, dKy_tevstr_c const*, csXyz const*,\n                                cXyz const*, int, dPa_levelEcallBack*, s8, cXyz const*);\n    /* 8004D128 */ bool newSimple(u16, u8, u32*);\n    /* 8004D1B8 */ u32 setSimple(u16, cXyz const*, dKy_tevstr_c const*, u8, _GXColor const&,\n                                  _GXColor const&, int, f32);\n    /* 8004D23C */ dPa_simpleEcallBack* getSimple(u16);\n    /* 8004D770 */ u32 setStopContinue(u32);\n    /* 8004D7C4 */ u32 setSimpleFoot(u32, u32*, cBgS_PolyInfo&, cXyz const*, dKy_tevstr_c const*,\n                                      int, csXyz const*, cXyz const*, dPa_levelEcallBack*, s8,\n                                      cXyz const*);\n    /* 8004D988 */ u16 setCommonPoly(u32*, cBgS_PolyInfo*, cXyz const*, cXyz const*,\n                                      dKy_tevstr_c const*, u32, u32, csXyz const*, cXyz const*, s8);\n\n    void forceOnEventMove(u32 param_0) { field_0x210.forceOnEventMove(param_0); }\n    JPABaseEmitter* getEmitter(u32 param_0) { return field_0x210.getEmitter(param_0); }\n\n    u32 setNormal(u32 param_0, u16 param_1, const cXyz* param_2, const dKy_tevstr_c* param_3,\n                  const csXyz* param_4, const cXyz* param_5, u8 param_6,\n                  dPa_levelEcallBack* param_7, s8 param_8, const GXColor* param_9,\n                  const GXColor* param_10, const cXyz* param_11, f32 param_12) {\n        return set(param_0, 0, param_1, param_2, param_3, param_4, param_5, param_6, param_7,\n                   param_8, param_9, param_10, param_11, param_12);\n    }\n\n    JPABaseEmitter* setNormal(u16 param_1, const cXyz* param_2, const dKy_tevstr_c* param_3,\n                              const csXyz* param_4, const cXyz* param_5, u8 param_6,\n                              dPa_levelEcallBack* param_7, s8 param_8, const GXColor* param_9,\n                              const GXColor* param_10, const cXyz* param_11, f32 param_12) {\n        return set(0, param_1, param_2, param_3, param_4, param_5, param_6, param_7, param_8,\n                   param_9, param_10, param_11, param_12);\n    }\n\n    void drawFogPri0_B(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 7); }\n    void drawNormalPri0_B(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 5); }\n    void drawFogPri0_A(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 6); }\n    void drawNormalPri0_A(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 4); }\n    void drawFogPri4(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 11); }\n    void drawProjection(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 3); }\n    void drawFogPri1(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 8); }\n    void drawNormal(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 0); }\n    void drawFogPri2(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 9); }\n    void drawNormalFog(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 1); }\n    void drawFogPri3(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 10); }\n    void drawNormalP1(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 2); }\n    void drawDarkworld(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 12); }\n    void drawFogScreen(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 13); }\n    void draw2Dgame(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 14); }\n    void draw2Dfore(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 15); }\n    void draw2Dback(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 16); }\n    void draw2DmenuFore(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 17); }\n    void draw2DmenuBack(JPADrawInfo* i_drawInfo) { draw(i_drawInfo, 18); }\n\n    JKRExpHeap* getResHeap() { return m_resHeap; }\n\n    void levelAllForceOnEventMove() { field_0x210.allForceOnEventMove(); }\n\n    static void onStatus(u8 status) { mStatus |= status; }\n    static void offStatus(u8 status) { mStatus &= ~status; }\n    static bool isStatus(u8 status) { return mStatus & status; }\n\n    static dPa_selectTexEcallBack* getTsuboSelectTexEcallBack(int idx) {\n        return ((dPa_selectTexEcallBack*)mTsubo) + idx;\n    }\n\n    static JPAEmitterManager* getEmitterManager() { return mEmitterMng; }\n    static JPAParticleCallBack* getLight8PcallBack() { \n        return (JPAParticleCallBack*)mLight8PcallBack;\n        //return &mLight8PcallBack; \n    }\n    static JPAParticleCallBack* getGen_b_Light8PcallBack() {\n        return (JPAParticleCallBack*)m_b_Light8PcallBack;\n        //return &m_b_Light8PcallBack; \n    }\n    static JPAParticleCallBack* getGen_d_Light8PcallBack() {\n        return (JPAParticleCallBack*)m_d_Light8PcallBack;\n        //return &m_d_Light8PcallBack; \n    }\n    static dPa_gen_b_light8EcallBack* getGen_b_Light8EcallBack() {\n        return (dPa_gen_b_light8EcallBack*)m_b_Light8EcallBack;\n        //return &m_b_Light8EcallBack; \n    }\n    static dPa_gen_d_light8EcallBack* getGen_d_Light8EcallBack() {\n        return (dPa_gen_d_light8EcallBack*)m_d_Light8EcallBack;\n        //return &m_d_Light8PcallBack; \n    }\n    static dPa_light8EcallBack* getLight8EcallBack() {\n        return (dPa_light8EcallBack*)mLight8EcallBack;\n        //return &mLight8EcallBack; \n    }\n    static JPAParticleCallBack* getParticleTracePCB() {\n        return (JPAParticleCallBack*)mParticleTracePCB;\n        //return &mParticleTracePCB; \n    }\n    static JPAParticleCallBack* getFsenthPcallBack() {\n        return (JPAParticleCallBack*)mFsenthPcallBack;\n        //return &mFsenthPcallBack; \n    }\n\n    static u8 mTsubo[64];\n    static u8 mLifeBall[24];\n    static Mtx mWindViewMatrix;\n    static JPAEmitterManager* mEmitterMng;\n    static u8 mWaterBubblePcallBack[4];\n    static u8 mFsenthPcallBack[4];\n    static u8 mLight8EcallBack[4];\n    static u8 mLight8PcallBack[4];\n    static u8 m_b_Light8EcallBack[4];\n    static u8 m_b_Light8PcallBack[4];\n    static u8 m_d_Light8EcallBack[4];\n    static u8 m_d_Light8PcallBack[4];\n    static u8 mParticleTracePCB[4 + 4 /* padding */];\n    static u8 mStatus;\n\nprivate:\n    /* 0x000 */ JKRSolidHeap* mHeap;\n    /* 0x004 */ JPAResourceManager* mCommonResMng;\n    /* 0x008 */ JKRExpHeap* m_resHeap;\n    /* 0x00C */ JKRSolidHeap* m_sceneHeap;\n    /* 0x010 */ void* m_sceneRes;\n    /* 0x014 */ JPAResourceManager* mSceneResMng;\n    /* 0x018 */ u8 field_0x18;\n    /* 0x019 */ u8 field_0x19;\n    /* 0x01A */ u8 field_0x1a;\n    /* 0x01B */ u8 field_0x1b;\n    /* 0x01C */ dPa_simpleEcallBack field_0x1c[25];\n    /* 0x210 */ level_c field_0x210;\n};\n\n#endif /* D_PARTICLE_D_PARTICLE_H */\n/* end \"d/particle/d_particle.h\" */\n/* \"include/d/com/d_com_inf_game.h\" line 11 \"f_op/f_op_camera_mng.h\" */\n#ifndef F_F_OP_CAMERA_MNG_H_\n#define F_F_OP_CAMERA_MNG_H_\n\n/* \"include/f_op/f_op_camera_mng.h\" line 3 \"SSystem/SComponent/c_phase.h\" */\n/* end \"SSystem/SComponent/c_phase.h\" */\n/* \"include/f_op/f_op_camera_mng.h\" line 4 \"d/d_camera.h\" */\n#ifndef D_D_CAMERA_H\n#define D_D_CAMERA_H\n\n/* \"include/d/d_camera.h\" line 3 \"d/bg/d_bg_s_lin_chk.h\" */\n#ifndef D_BG_D_BG_S_LIN_CHK_H\n#define D_BG_D_BG_S_LIN_CHK_H\n\n/* \"include/d/bg/d_bg_s_lin_chk.h\" line 3 \"SSystem/SComponent/c_bg_s_lin_chk.h\" */\n#ifndef C_BG_S_LIN_CHK_H\n#define C_BG_S_LIN_CHK_H\n\n/* \"include/SSystem/SComponent/c_bg_s_lin_chk.h\" line 3 \"SSystem/SComponent/c_bg_s_chk.h\" */\n/* end \"SSystem/SComponent/c_bg_s_chk.h\" */\n/* \"include/SSystem/SComponent/c_bg_s_lin_chk.h\" line 4 \"SSystem/SComponent/c_bg_s_poly_info.h\" */\n/* end \"SSystem/SComponent/c_bg_s_poly_info.h\" */\n/* \"include/SSystem/SComponent/c_bg_s_lin_chk.h\" line 5 \"SSystem/SComponent/c_m3d_g_lin.h\" */\n/* end \"SSystem/SComponent/c_m3d_g_lin.h\" */\n/* \"include/SSystem/SComponent/c_bg_s_lin_chk.h\" line 6 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass cBgS_LinChk : public cBgS_Chk, public cBgS_PolyInfo {\npublic:\n    /* 0x024 */ cM3dGLin mLin;\n    /* 0x040 */ cXyz field_0x40;\n    /* 0x04C */ u32 field_0x4c;\n    /* 0x050 */ bool mPreWallChk;\n    /* 0x051 */ bool mPreGroundChk;\n    /* 0x052 */ bool mPreRoofChk;\n    /* 0x053 */ bool mFrontFlag;\n    /* 0x054 */ bool mBackFlag;\n\npublic:\n    cBgS_LinChk();\n    void ct();\n    void Set2(const cXyz*, const cXyz*, unsigned int);\n    void PreCalc();\n    void GetCross();\n\n    virtual ~cBgS_LinChk();\n\n    void ClrHit() { field_0x4c &= ~16; }\n    void SetHit() { field_0x4c |= 16; }\n    u32 ChkHit() const { return field_0x4c & 16; }\n    void SetCross(const cXyz& pos) { mLin.SetEnd(pos); }\n    cXyz& i_GetCross() { return mLin.GetEnd(); }\n    cXyz* GetCrossP() { return &mLin.GetEndP(); }\n    cM3dGLin* GetLinP() { return &mLin; }\n    bool ChkBackFlag() const { return mBackFlag; }\n    bool ChkFrontFlag() const { return mFrontFlag; }\n    bool GetPreWallChk() const { return mPreWallChk; }\n    bool GetPreGroundChk() const { return mPreGroundChk; }\n    bool GetPreRoofChk() const { return mPreRoofChk; }\n};\n\n#endif /* C_BG_S_LIN_CHK_H */\n/* end \"SSystem/SComponent/c_bg_s_lin_chk.h\" */\n/* \"include/d/bg/d_bg_s_lin_chk.h\" line 4 \"d/bg/d_bg_s_chk.h\" */\n/* end \"d/bg/d_bg_s_chk.h\" */\n\nclass fopAc_ac_c;\n\nclass dBgS_LinChk : public cBgS_LinChk, public dBgS_Chk {\npublic:\n    /* 80077C68 */ dBgS_LinChk();\n    /* 80077D64 */ void Set(cXyz const* pi_start, cXyz const* pi_end, fopAc_ac_c const*);\n\n    /* 80077CDC */ virtual ~dBgS_LinChk();\n\n    /* 0x00 cBgS_LinChk */;\n    /* 0x58 dBgS_Chk */;\n};\n\nclass dBgS_LinkLinChk : public dBgS_LinChk {\npublic:\n    /* 80078030 */ dBgS_LinkLinChk();\n\n    /* 8007808C */ virtual ~dBgS_LinkLinChk();\n};\n\nclass dBgS_RopeLinChk : public dBgS_LinChk {\npublic:\n    /* 8007838C */ dBgS_RopeLinChk();\n\n    /* 800783E8 */ virtual ~dBgS_RopeLinChk();\n};\n\nclass dBgS_BoomerangLinChk : public dBgS_LinChk {\npublic:\n    /* 800782B8 */ dBgS_BoomerangLinChk();\n\n    /* 80078314 */ virtual ~dBgS_BoomerangLinChk();\n};\n\nclass dBgS_ArrowLinChk : public dBgS_LinChk {\npublic:\n    /* 800781D8 */ dBgS_ArrowLinChk();\n\n    /* 80078240 */ virtual ~dBgS_ArrowLinChk();\n};\n\nclass dBgS_ObjLinChk : public dBgS_LinChk {\npublic:\n    /* 80077F5C */ dBgS_ObjLinChk();\n\n    /* 80077FB8 */ virtual ~dBgS_ObjLinChk();\n};\n\nclass dBgS_BombLinChk : public dBgS_LinChk {\npublic:\n    /* 80078104 */ dBgS_BombLinChk();\n\n    /* 80078160 */ virtual ~dBgS_BombLinChk();\n};\n\nclass dBgS_HorseLinChk : public dBgS_LinChk {\npublic:\n    /* 80078460 */ dBgS_HorseLinChk();\n\n    /* 800784BC */ virtual ~dBgS_HorseLinChk();\n};\n\nclass dBgS_CamLinChk : public dBgS_LinChk {\npublic:\n    /* 80077DA4 */ dBgS_CamLinChk();\n\n    /* 80077E00 */ virtual ~dBgS_CamLinChk();\n};\n\nclass dBgS_CamLinChk_NorWtr : public dBgS_CamLinChk {\npublic:\n    /* 80077E78 */ dBgS_CamLinChk_NorWtr();\n\n    /* 80077EE4 */ virtual ~dBgS_CamLinChk_NorWtr();\n};\n\n#endif /* D_BG_D_BG_S_LIN_CHK_H */\n/* end \"d/bg/d_bg_s_lin_chk.h\" */\n/* \"include/d/d_camera.h\" line 4 \"d/bg/d_bg_s_gnd_chk.h\" */\n/* end \"d/bg/d_bg_s_gnd_chk.h\" */\n/* \"include/d/d_camera.h\" line 5 \"d/d_cam_param.h\" */\n#ifndef D_D_CAM_PARAM_H\n#define D_D_CAM_PARAM_H\n\n/* \"include/d/d_cam_param.h\" line 3 \"SSystem/SComponent/c_angle.h\" */\n/* end \"SSystem/SComponent/c_angle.h\" */\n\nstruct dCamMath {\n    /* 8008813C */ static f32 rationalBezierRatio(f32, f32);\n    /* 80088284 */ static f32 zoomFovy(f32, f32);\n    /* 8008831C */ static cXyz xyzRotateX(cXyz&, cSAngle);\n    /* 80088384 */ static cXyz xyzRotateY(cXyz&, cSAngle);\n    /* 800883EC */ static f32 xyzHorizontalDistance(cXyz&, cXyz&);\n};\n\nclass dCstick_c {\npublic:\n    /* 80088434 */ dCstick_c();\n    /* 8008845C */ bool Shift(u32);\n\n    /* 0x0 */ f32 mThresholdLow;\n    /* 0x4 */ f32 mThresholdHigh;\n    /* 0x8 */ int mInputSpeed;\n    /* 0xC */ u8 field_0xc[4];\n\n    /* 800889B0 */ virtual ~dCstick_c();\n};\n\nclass dCamBGChk_c {\npublic:\n    /* 80088464 */ dCamBGChk_c();\n\n    // name is a guess for now\n    struct ChkInfo {\n        /* 0x0 */ f32 mDistance;\n        /* 0x4 */ f32 mChkAngle;\n        /* 0x8 */ f32 mWeightH;\n        /* 0xC */ f32 mWeightL;\n    };  // Size: 0x10\n\n    /* 0x00 */ f32 mFloorMargin;\n    /* 0x04 */ ChkInfo mChkInfo[2];\n    /* 0x24 */ f32 mFwdBackMargin;\n    /* 0x28 */ f32 mFwdCushion;\n    /* 0x2C */ f32 field_0x2c;\n    /* 0x30 */ f32 mGazeBackMargin;\n    /* 0x34 */ f32 mCornerCushion;\n    /* 0x38 */ f32 mWallCushion;\n    /* 0x3C */ f32 mWallUpDistance;\n    /* 0x40 */ f32 mWallBackCushion;\n    /* 0x44 */ f32 mCornerAngleMax;\n};\n\nstruct dCamStyleData {\n    struct StyleData {\n        /* 0x0 */ u32 field_0x0;\n        /* 0x4 */ u16 field_0x4;\n        /* 0x6 */ u8 field_0x6[0x78 - 0x6];\n    };  // Size: 0x78\n\n    /* 0x0 */ u8 field_0x0[4];\n    /* 0x4 */ int mStyleNum;\n    /* 0x8 */ StyleData* mStyleData;\n};\n\nclass dCamParam_c {\npublic:\n    /* 800884F0 */ dCamParam_c(s32);\n    /* 800885D4 */ int Change(s32);\n    /* 80088620 */ int SearchStyle(u32);\n    /* 80182C60 */ void Arg2(s16);\n    /* 80182C3C */ void Arg2();\n    /* 80182C48 */ void Arg1();\n    /* 80182C6C */ void Arg1(u8);\n    /* 80182C50 */ void Arg0();\n    /* 80182C74 */ void Arg0(u8);\n    /* 80182C7C */ void Fovy(u8);\n    /* 80182C58 */ void Fovy();\n    /* 80182C8C */ void Flag(s32, u16);\n    /* 80182CB4 */ void CheckFlag(u16);\n    /* 80182CD0 */ void Val(s32, int);\n\n    /* 0x00 */ u8 mMapToolFovy;\n    /* 0x01 */ u8 mMapToolArg0;\n    /* 0x02 */ u8 mMapToolArg1;\n    /* 0x04 */ int mMapToolArg2;\n    /* 0x08 */ dCamStyleData::StyleData* mCamStyleData;\n    /* 0x0C */ s32 mStyleNum;\n    /* 0x10 */ dCamStyleData::StyleData* mCurrentStyle;\n    /* 0x14 */ int mStyleID;\n    /* 0x18 */ u8 field_0x18[4];\n\n    u16 Algorythmn(s32 i_style) { return mCamStyleData[i_style].field_0x4; }\n\n    /* 8008858C */ virtual ~dCamParam_c();\n};\n\nclass dCamSetup_c {\npublic:\n    /* 80088668 */ dCamSetup_c();\n    /* 80088918 */ bool CheckLatitudeRange(s16*);\n    /* 80088988 */ f32 PlayerHideDist();\n    /* 80182BB8 */ void CheckFlag2(u16);\n    /* 80182BD0 */ void CheckFlag(u16);\n    /* 80182BE8 */ void WaitRollSpeed();\n    /* 80182BF0 */ void WaitRollTimer();\n    /* 80182C1C */ void ThrowTimer();\n    /* 80182C24 */ void ThrowCushion();\n    /* 80182C2C */ void ThrowVAngle();\n    /* 80182C34 */ void ThrowCtrAdjust();\n    /* 80182CEC */ void ChargeBRatio();\n    /* 80182CF4 */ void ChargeTimer();\n    /* 80182CFC */ void ChargeLatitude();\n\n    /* 0x000 */ f32 mDrawNear;\n    /* 0x004 */ f32 mDrawFar;\n    /* 0x008 */ u16 mDebugFlags;\n    /* 0x00A */ u16 field_0xa;\n    /* 0x00C */ int field_0xc;\n    /* 0x010 */ int mModeSwitchType;\n    /* 0x014 */ void* mTypeTable;\n    /* 0x018 */ int mTypeNum;\n    /* 0x01C */ int mForceType;\n    /* 0x020 */ f32 mCusCus;\n    /* 0x024 */ f32 field_0x24;\n    /* 0x028 */ f32 field_0x28;\n    /* 0x02C */ f32 field_0x2c;\n    /* 0x030 */ f32 field_0x30;\n    /* 0x034 */ f32 field_0x34;\n    /* 0x038 */ f32 mBaseCushion;\n    /* 0x03C */ f32 mJumpCushion;\n    /* 0x040 */ f32 mParallelDist;\n    /* 0x044 */ f32 field_0x44;\n    /* 0x048 */ f32 mSubjLinkCullDist;\n    /* 0x04C */ f32 mCurveWeight;\n    /* 0x050 */ f32 field_0x50;\n    /* 0x054 */ f32 field_0x54;\n    /* 0x058 */ f32 field_0x58;\n    /* 0x05C */ f32 field_0x5c;\n    /* 0x060 */ f32 field_0x60;\n    /* 0x064 */ f32 mTrimVistaHeight;\n    /* 0x068 */ f32 mTrimCineScopeHeight;\n    /* 0x06C */ f32 field_0x6c;\n    /* 0x070 */ f32 mForceLockOffDist;\n    /* 0x074 */ int mForceLockOffTimer;\n    /* 0x078 */ f32 field_0x78;\n    /* 0x07C */ f32 field_0x7c;\n    /* 0x080 */ f32 field_0x80;\n    /* 0x084 */ f32 field_0x84;\n    /* 0x088 */ f32 mThrowVAngle;\n    /* 0x08C */ f32 mThrowCtrOffset;\n    /* 0x090 */ f32 mThrowCushion;\n    /* 0x094 */ int mThrowTimer;\n    /* 0x098 */ f32 mWindShakeCtr;\n    /* 0x09C */ f32 field_0x9c;\n    /* 0x0A0 */ f32 mWindShakeFvy;\n    /* 0x0A4 */ f32 mFalseValue;\n    /* 0x0A8 */ f32 mFalseAngle;\n    /* 0x0AC */ f32 field_0xac;\n    /* 0x0B0 */ int field_0xb0;\n    /* 0x0B4 */ f32 field_0xb4;\n    /* 0x0B8 */ f32 mManualStartCThreshold;\n    /* 0x0BC */ f32 mManualEndVal;\n    /* 0x0C0 */ f32 mChargeLatitude;\n    /* 0x0C4 */ int mChargeTimer;\n    /* 0x0C8 */ f32 mChargeBRatio;\n    /* 0x0CC */ int mLockonChangeTimer;\n    /* 0x0D0 */ f32 mLockonChangeCushion;\n    /* 0x0D4 */ f32 field_0xd4;\n    /* 0x0D8 */ f32 field_0xd8;\n    /* 0x0DC */ u16 mMapToolCamShortTimer;\n    /* 0x0DE */ u16 mMapToolCamLongTimer;\n    /* 0x0E0 */ f32 field_0xe0;\n    /* 0x0E4 */ f32 field_0xe4;\n    /* 0x0E8 */ f32 field_0xe8;\n    /* 0x0EC */ int field_0xec;\n    /* 0x0F0 */ int field_0xf0;\n    /* 0x0F4 */ f32 field_0xf4;\n    /* 0x0F8 */ f32 field_0xf8;\n    /* 0x0FC vtable */\n\n    /* 800888B8 */ virtual ~dCamSetup_c();\n\n    /* 0x100 */ dCstick_c mCStick;\n    /* 0x114 */ dCamBGChk_c mBGChk;\n    /* 0x15C */ f32 field_0x15c;\n    /* 0x160 */ f32 field_0x160;\n    /* 0x164 */ int mWaitRollTimer;\n    /* 0x168 */ f32 mWaitRollSpeed;\n    /* 0x16C */ f32 field_0x16c;\n    /* 0x170 */ int mScreensaverFirstWaitTimer;\n    /* 0x174 */ int mScreensaverWaitTimer;\n    /* 0x178 */ int mScreensaverExecTimer;\n};\n\n#endif /* D_D_CAM_PARAM_H */\n/* end \"d/d_cam_param.h\" */\n/* \"include/d/d_camera.h\" line 6 \"d/d_drawlist.h\" */\n/* end \"d/d_drawlist.h\" */\n/* \"include/d/d_camera.h\" line 7 \"d/d_stage.h\" */\n#ifndef D_D_STAGE_H\n#define D_D_STAGE_H\n\n/* \"include/d/d_stage.h\" line 3 \"SSystem/SComponent/c_lib.h\" */\n#ifndef C_LIB_H_\n#define C_LIB_H_\n\n/* \"include/SSystem/SComponent/c_lib.h\" line 3 \"SSystem/SComponent/c_xyz.h\" */\n/* end \"SSystem/SComponent/c_xyz.h\" */\n/* \"include/SSystem/SComponent/c_lib.h\" line 4 \"dolphin/mtx/mtx.h\" */\n/* end \"dolphin/mtx/mtx.h\" */\n\ninline bool cLib_IsZero(f32 value) {\n    return fabsf(value) < 8e-11f;\n}\n\nvoid cLib_memCpy(void* dst, const void* src, unsigned long size);\nvoid cLib_memSet(void* ptr, int value, unsigned long size);\n\nf32 cLib_addCalc(f32* o_value, f32 target, f32 scale, f32 maxStep, f32 minStep);\nvoid cLib_addCalc2(f32* o_value, f32 target, f32 scale, f32 maxStep);\nvoid cLib_addCalc0(f32* o_value, f32 scale, f32 maxStep);\nf32 cLib_addCalcPos(cXyz* o_value, cXyz const& target, f32 scale, f32 maxStep, f32 minStep);\nf32 cLib_addCalcPosXZ(cXyz* o_value, cXyz const& target, f32 scale, f32 maxStep, f32 minStep);\nvoid cLib_addCalcPos2(cXyz* o_value, cXyz const& target, f32 scale, f32 maxStep);\nvoid cLib_addCalcPosXZ2(cXyz* o_value, cXyz const& target, f32 scale, f32 maxStep);\ns16 cLib_addCalcAngleS(s16* o_value, s16 target, s16 scale, s16 maxStep, s16 minStep);\nvoid cLib_addCalcAngleS2(s16* o_value, s16 target, s16 scale, s16 maxStep);\n\nint cLib_chaseUC(u8* o_value, u8 target, u8 step);\nint cLib_chaseS(s16* o_value, s16 target, s16 step);\nint cLib_chaseF(f32* o_value, f32 target, f32 step);\nint cLib_chasePos(cXyz* o_value, cXyz const& target, f32 step);\nint cLib_chasePosXZ(cXyz* o_value, cXyz const& target, f32 step);\nint cLib_chaseAngleS(s16* o_value, s16 target, s16 step);\n\ns16 cLib_targetAngleY(const Vec* lhs, const Vec* rhs);\ns16 cLib_targetAngleY(const Vec& lhs, const Vec& rhs);\ns16 cLib_targetAngleX(const cXyz*, const cXyz*);\n\nvoid cLib_offsetPos(cXyz* pDest, cXyz const* pSrc, s16 angle, cXyz const* vec);\ns32 cLib_distanceAngleS(s16 x, s16 y);\n\ntemplate <typename T>\ninline void cLib_offBit(T& value, u8 bit) {\n    value &= ~bit;\n}\n\ntemplate <typename T>\ninline void cLib_onBit(T& value, u8 bit) {\n    value |= bit;\n}\n\ntemplate <typename T>\ninline u8 cLib_checkBit(T& value, u8 bit) {\n    return value & bit;\n}\n\ntemplate <typename T>\ninline T cLib_minMaxLimit(T val, T min, T max) {\n    T ret;\n    T var_r30;\n\n    if (val < min) {\n        ret = min;\n    } else {\n        if (val > max) {\n            var_r30 = max;\n        } else {\n            var_r30 = val;\n        }\n\n        ret = var_r30;\n    }\n\n    return (T)ret;\n}\n\ntemplate <typename T>\ninline T cLib_maxLimit(T val, T max) {\n    T ret;\n    T var_r30;\n\n    if (val > max) {\n        var_r30 = max;\n    } else {\n        var_r30 = val;\n    }\n\n    ret = var_r30;\n    return (T)ret;\n}\n\ntemplate <typename T>\nT cLib_calcTimer(T* value) {\n    // Casting 0 to u16 may not be correct, but is matching for now\n    if (*value != (u16)0) {\n        *value = *value - 1;\n    }\n    return *value;\n}\n\ntemplate <typename T>\nT cLib_getRndValue(T min, T range) {\n    return (T)(min + cM_rndF((f32)range));\n}\n\nvoid MtxInit(void);\nvoid MtxTrans(f32, f32, f32, u8);\nvoid MtxScale(f32, f32, f32, u8);\nvoid MtxPosition(cXyz*, cXyz*);\nvoid MtxPush(void);\nMtx* MtxPull(void);\n\nextern Mtx* calc_mtx;\n\n#endif\n/* end \"SSystem/SComponent/c_lib.h\" */\n/* \"include/d/d_stage.h\" line 4 \"d/kankyo/d_kankyo.h\" */\n/* end \"d/kankyo/d_kankyo.h\" */\n/* \"include/d/d_stage.h\" line 5 \"d/kankyo/d_kankyo_data.h\" */\n#ifndef D_KANKYO_D_KANKYO_DATA_H\n#define D_KANKYO_D_KANKYO_DATA_H\n\n/* \"include/d/kankyo/d_kankyo_data.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nstruct color_RGB_class {\n    u8 r;\n    u8 g;\n    u8 b;\n};\n\n// Invented name; Used as u8 `darkLv` in dKydata_darkworldInfo_c.\nenum dKyd_DARKLV {\n    FARON = 0,\n    ELDIN = 1,\n    LANAYRU = 2,\n    TEST = 5,         // Only used with nonexistent test stages\n    UNCLEARABLE = 6,  // Default. Palace of Twilight stages use this\n    ALWAYS_DARK = 8,  // Unused. Forces Twilight\n};\n\nclass dKydata_darkworldInfo_c {\npublic:\n    /* 0x0 */ const char* stageName;\n    /* 0x4 */ u8 darkLv;\n};  // Size: 0x8\n\nclass dKydata_lightsizeInfo_c {\npublic:\n    /* 0x0 */ const char* stageName;\n    /* 0x4 */ u8 size;\n};  // Size: 0x8\n\n// Invented name; adjust as needed in the future.\n// Notes (needs more investigation):\n// startTime and endTime are in the range 0 to 360, which is the same as the current time of day.\n// l_time_attribute and l_time_attribute_boss are arrays of `dKyd_lightSchedjule` with their times\n// set up such that the current time of day will fall in the range of one dKyd_lightSchedjule. For\n// example, if the current time is 110.0f (7:20 AM), then the dKyd_lightSchedjule {105.0f, 135.0f,\n// 1, 2} would be selected. If the time was 105.0f, we would use light 1. If the time was 135.0f, we\n// would use light 2. Since 110.0f is closer to 105.0f than 135.0f, we get a blend of lights 1 and 2\n// which is mostly 1. Blending the lights over time is how we get a smooth day-night transition.\nstruct dKyd_lightSchejule {\n    float startTime;\n    float endTime;\n    u8 startTimeLight;\n    u8 endTimeLight;\n};  // Size: 0xC\n\nenum BloomType {\n    /* 0x0 */ BLOOM_CLEAR,\n    /* 0x1 */ BLOOM_SOFT\n};\n\n#define BLOOMINFO_MAX 64\nclass dkydata_bloomInfo_info_class {\npublic:\n    /* 0x0 */ u8 mType;\n    /* 0x1 */ u8 mThreshold;\n    /* 0x2 */ u8 mBlurAmount;\n    /* 0x3 */ u8 mDensity;\n    /* 0x4 */ u8 mColorR;\n    /* 0x5 */ u8 mColorG;\n    /* 0x6 */ u8 mColorB;\n    /* 0x7 */ u8 mOrigDensity;  // ?\n    /* 0x8 */ u8 mSaturateSubtractR;\n    /* 0x9 */ u8 mSaturateSubtractG;\n    /* 0xA */ u8 mSaturateSubtractB;\n    /* 0xB */ u8 mSaturateSubtractA;\n};  // Size: 0xC\n\nvoid* dKyd_dmpalet_getp();\nvoid* dKyd_dmpselect_getp();\nvoid* dKyd_dmenvr_getp();\nvoid* dKyd_dmvrbox_getp();\ndKyd_lightSchejule* dKyd_schejule_getp();\ndKyd_lightSchejule* dKyd_schejule_boss_getp();\nvoid dKyd_xfog_table_set(u8);\nvoid* dKyd_maple_col_getp();\ndKydata_darkworldInfo_c* dKyd_darkworld_tbl_getp();\ndKydata_lightsizeInfo_c* dKyd_light_size_tbl_getp();\ndKydata_lightsizeInfo_c* dKyd_light_tw_size_tbl_getp();\ndkydata_bloomInfo_info_class* dKyd_BloomInf_tbl_getp(int);\n\n#endif /* D_KANKYO_D_KANKYO_DATA_H */\n/* end \"d/kankyo/d_kankyo_data.h\" */\n/* \"include/d/d_stage.h\" line 6 \"d/save/d_save.h\" */\n#ifndef D_SAVE_D_SAVE_H\n#define D_SAVE_D_SAVE_H\n\n/* \"include/d/save/d_save.h\" line 3 \"string.h\" */\n/* end \"string.h\" */\n/* \"include/d/save/d_save.h\" line 4 \"SSystem/SComponent/c_xyz.h\" */\n/* end \"SSystem/SComponent/c_xyz.h\" */\n/* \"include/d/save/d_save.h\" line 5 \"dolphin/os/OSTime.h\" */\n/* end \"dolphin/os/OSTime.h\" */\n/* \"include/d/save/d_save.h\" line 6 \"global.h\" */\n/* end \"global.h\" */\n\n#define DEFAULT_SELECT_ITEM_INDEX 0\n#define MAX_SELECT_ITEM 4\n#define SELECT_ITEM_NUM 2\n#define MAX_EQUIPMENT 6\n#define MAX_EVENTS 256\n#define MAX_ITEM_SLOTS 24\n#define LIGHT_DROP_STAGE 4\n#define LETTER_INFO_BIT 64\n#define MAX_INSECT_NUM 24\n#define BOMB_BAG_MAX 3\n#define BOTTLE_MAX 4\n#define TBOX_MAX 64\n#define DSV_MEMBIT_ENUM_MAX 8\n#define ITEM_MAX_DAN 128\n#define SWITCH_ZONE_MAX 0x20\n#define SWITCH_ONE_ZONE_MAX 0x10\n#define ITEM_ZONE_MAX 0x20\n#define ITEM_ONE_ZONE_MAX 0x10\n#define QUEST_LOG_SIZE 0xA94\n\nenum Wallets {\n    /* 0x0 */ WALLET,\n    /* 0x1 */ BIG_WALLET,\n    /* 0x2 */ GIANT_WALLET\n};\n\nenum ItemSlots {\n    /* 0x00 */ SLOT_0,\n    /* 0x01 */ SLOT_1,\n    /* 0x02 */ SLOT_2,\n    /* 0x03 */ SLOT_3,\n    /* 0x04 */ SLOT_4,\n    /* 0x05 */ SLOT_5,\n    /* 0x06 */ SLOT_6,\n    /* 0x07 */ SLOT_7,\n    /* 0x08 */ SLOT_8,\n    /* 0x09 */ SLOT_9,\n    /* 0x0A */ SLOT_10,\n    /* 0x0B */ SLOT_11,\n    /* 0x0C */ SLOT_12,\n    /* 0x0D */ SLOT_13,\n    /* 0x0E */ SLOT_14,\n    /* 0x0F */ SLOT_15,\n    /* 0x10 */ SLOT_16,\n    /* 0x11 */ SLOT_17,\n    /* 0x12 */ SLOT_18,\n    /* 0x13 */ SLOT_19,\n    /* 0x14 */ SLOT_20,\n    /* 0x15 */ SLOT_21,\n    /* 0x16 */ SLOT_22,\n    /* 0x17 */ SLOT_23\n};\n\nenum ItemTable {\n    /* 0x0000 */ HEART,\n    /* 0x0001 */ GREEN_RUPEE,\n    /* 0x0002 */ BLUE_RUPEE,\n    /* 0x0003 */ YELLOW_RUPEE,\n    /* 0x0004 */ RED_RUPEE,\n    /* 0x0005 */ PURPLE_RUPEE,\n    /* 0x0006 */ ORANGE_RUPEE,\n    /* 0x0007 */ SILVER_RUPEE,\n    /* 0x0008 */ S_MAGIC,\n    /* 0x0009 */ L_MAGIC,\n    /* 0x000A */ BOMB_5,\n    /* 0x000B */ BOMB_10,\n    /* 0x000C */ BOMB_20,\n    /* 0x000D */ BOMB_30,\n    /* 0x000E */ ARROW_10,\n    /* 0x000F */ ARROW_20,\n    /* 0x0010 */ ARROW_30,\n    /* 0x0011 */ ARROW_1,\n    /* 0x0012 */ PACHINKO_SHOT,\n    /* 0x0013 */ noentry1,\n    /* 0x0014 */ noentry2,\n    /* 0x0015 */ noentry3,\n    /* 0x0016 */ WATER_BOMB_5,\n    /* 0x0017 */ WATER_BOMB_10,\n    /* 0x0018 */ WATER_BOMB_20,\n    /* 0x0019 */ WATER_BOMB_30,\n    /* 0x001A */ BOMB_INSECT_5,\n    /* 0x001B */ BOMB_INSECT_10,\n    /* 0x001C */ BOMB_INSECT_20,\n    /* 0x001D */ BOMB_INSECT_30,\n    /* 0x001E */ RECOVERY_FAILY,\n    /* 0x001F */ TRIPLE_HEART,\n    /* 0x0020 */ SMALL_KEY,\n    /* 0x0021 */ KAKERA_HEART,\n    /* 0x0022 */ UTAWA_HEART,\n    /* 0x0023 */ MAP,\n    /* 0x0024 */ COMPUS,\n    /* 0x0025 */ DUNGEON_EXIT,\n    /* 0x0026 */ BOSS_KEY,\n    /* 0x0027 */ DUNGEON_BACK,\n    /* 0x0028 */ SWORD,\n    /* 0x0029 */ MASTER_SWORD,\n    /* 0x002A */ WOOD_SHIELD,\n    /* 0x002B */ SHIELD,\n    /* 0x002C */ HYLIA_SHIELD,\n    /* 0x002D */ TKS_LETTER,\n    /* 0x002E */ WEAR_CASUAL,\n    /* 0x002F */ WEAR_KOKIRI,\n    /* 0x0030 */ ARMOR,\n    /* 0x0031 */ WEAR_ZORA,\n    /* 0x0032 */ MAGIC_LV1,\n    /* 0x0033 */ DUNGEON_EXIT_2,\n    /* 0x0034 */ WALLET_LV1,\n    /* 0x0035 */ WALLET_LV2,\n    /* 0x0036 */ WALLET_LV3,\n    /* 0x0037 */ noentry4,\n    /* 0x0038 */ noentry5,\n    /* 0x0039 */ noentry6,\n    /* 0x003A */ noentry7,\n    /* 0x003B */ noentry8,\n    /* 0x003C */ noentry9,\n    /* 0x003D */ ZORAS_JEWEL,\n    /* 0x003E */ HAWK_EYE,\n    /* 0x003F */ WOOD_STICK,\n    /* 0x0040 */ BOOMERANG,\n    /* 0x0041 */ SPINNER,\n    /* 0x0042 */ IRONBALL,\n    /* 0x0043 */ BOW,\n    /* 0x0044 */ HOOKSHOT,\n    /* 0x0045 */ HVY_BOOTS,\n    /* 0x0046 */ COPY_ROD,\n    /* 0x0047 */ W_HOOKSHOT,\n    /* 0x0048 */ KANTERA,\n    /* 0x0049 */ LIGHT_SWORD,\n    /* 0x004A */ FISHING_ROD_1,\n    /* 0x004B */ PACHINKO,\n    /* 0x004C */ COPY_ROD_2,\n    /* 0x004D */ noentry10,\n    /* 0x004E */ noentry11,\n    /* 0x004F */ BOMB_BAG_LV2,\n    /* 0x0050 */ BOMB_BAG_LV1,\n    /* 0x0051 */ BOMB_IN_BAG,\n    /* 0x0052 */ noentry12,\n    /* 0x0053 */ LIGHT_ARROW,\n    /* 0x0054 */ ARROW_LV1,\n    /* 0x0055 */ ARROW_LV2,\n    /* 0x0056 */ ARROW_LV3,\n    /* 0x0057 */ noentry13,\n    /* 0x0058 */ LURE_ROD,\n    /* 0x0059 */ BOMB_ARROW,\n    /* 0x005A */ HAWK_ARROW,\n    /* 0x005B */ BEE_ROD,\n    /* 0x005C */ JEWEL_ROD,\n    /* 0x005D */ WORM_ROD,\n    /* 0x005E */ JEWEL_BEE_ROD,\n    /* 0x005F */ JEWEL_WORM_ROD,\n    /* 0x0060 */ EMPTY_BOTTLE,\n    /* 0x0061 */ RED_BOTTLE,\n    /* 0x0062 */ GREEN_BOTTLE,\n    /* 0x0063 */ BLUE_BOTTLE,\n    /* 0x0064 */ MILK_BOTTLE,\n    /* 0x0065 */ HALF_MILK_BOTTLE,\n    /* 0x0066 */ OIL_BOTTLE,\n    /* 0x0067 */ WATER_BOTTLE,\n    /* 0x0068 */ OIL_BOTTLE_2,\n    /* 0x0069 */ RED_BOTTLE_2,\n    /* 0x006A */ UGLY_SOUP,\n    /* 0x006B */ HOT_SPRING,\n    /* 0x006C */ FAIRY,\n    /* 0x006D */ HOT_SPRING_2,\n    /* 0x006E */ OIL2,\n    /* 0x006F */ OIL,\n    /* 0x0070 */ NORMAL_BOMB,\n    /* 0x0071 */ WATER_BOMB,\n    /* 0x0072 */ POKE_BOMB,\n    /* 0x0073 */ FAIRY_DROP,\n    /* 0x0074 */ WORM,\n    /* 0x0075 */ DROP_BOTTLE,\n    /* 0x0076 */ BEE_CHILD,\n    /* 0x0077 */ CHUCHU_RARE,\n    /* 0x0078 */ CHUCHU_RED,\n    /* 0x0079 */ CHUCHU_BLUE,\n    /* 0x007A */ CHUCHU_GREEN,\n    /* 0x007B */ CHUCHU_YELLOW,\n    /* 0x007C */ CHUCHU_PURPLE,\n    /* 0x007D */ LV1_SOUP,\n    /* 0x007E */ LV2_SOUP,\n    /* 0x007F */ LV3_SOUP,\n    /* 0x0080 */ LETTER,\n    /* 0x0081 */ BILL,\n    /* 0x0082 */ WOOD_STATUE,\n    /* 0x0083 */ IRIAS_PENDANT,\n    /* 0x0084 */ HORSE_FLUTE,\n    /* 0x0085 */ noentry14,\n    /* 0x0086 */ noentry15,\n    /* 0x0087 */ noentry16,\n    /* 0x0088 */ noentry17,\n    /* 0x0089 */ noentry18,\n    /* 0x008A */ noentry19,\n    /* 0x008B */ noentry20,\n    /* 0x008C */ noentry21,\n    /* 0x008D */ noentry22,\n    /* 0x008E */ noentry23,\n    /* 0x008F */ noentry24,\n    /* 0x0090 */ RAFRELS_MEMO,\n    /* 0x0091 */ ASHS_SCRIBBLING,\n    /* 0x0092 */ noentry25,\n    /* 0x0093 */ noentry26,\n    /* 0x0094 */ noentry27,\n    /* 0x0095 */ noentry28,\n    /* 0x0096 */ noentry29,\n    /* 0x0097 */ noentry30,\n    /* 0x0098 */ noentry31,\n    /* 0x0099 */ noentry32,\n    /* 0x009A */ noentry33,\n    /* 0x009B */ noentry34,\n    /* 0x009C */ CHUCHU_YELLOW2,\n    /* 0x009D */ OIL_BOTTLE3,\n    /* 0x009E */ SHOP_BEE_CHILD,\n    /* 0x009F */ CHUCHU_BLACK,\n    /* 0x00A0 */ LIGHT_DROP,\n    /* 0x00A1 */ DROP_CONTAINER,\n    /* 0x00A2 */ DROP_CONTAINER02,\n    /* 0x00A3 */ DROP_CONTAINER03,\n    /* 0x00A4 */ FILLED_CONTAINER,\n    /* 0x00A5 */ MIRROR_PIECE_2,\n    /* 0x00A6 */ MIRROR_PIECE_3,\n    /* 0x00A7 */ MIRROR_PIECE_4,\n    /* 0x00A8 */ noentry35,\n    /* 0x00A9 */ noentry36,\n    /* 0x00AA */ noentry37,\n    /* 0x00AB */ noentry38,\n    /* 0x00AC */ noentry39,\n    /* 0x00AD */ noentry40,\n    /* 0x00AE */ noentry41,\n    /* 0x00AF */ noentry42,\n    /* 0x00B0 */ SMELL_YELIA_POUCH,\n    /* 0x00B1 */ SMELL_PUMPKIN,\n    /* 0x00B2 */ SMELL_POH,\n    /* 0x00B3 */ SMELL_FISH,\n    /* 0x00B4 */ SMELL_CHILDREN,\n    /* 0x00B5 */ SMELL_MEDICINE,\n    /* 0x00B6 */ noentry43,\n    /* 0x00B7 */ noentry44,\n    /* 0x00B8 */ noentry45,\n    /* 0x00B9 */ noentry46,\n    /* 0x00BA */ noentry47,\n    /* 0x00BB */ noentry48,\n    /* 0x00BC */ noentry49,\n    /* 0x00BD */ noentry50,\n    /* 0x00BE */ noentry51,\n    /* 0x00BF */ noentry52,\n    /* 0x00C0 */ M_BEETLE,\n    /* 0x00C1 */ F_BEETLE,\n    /* 0x00C2 */ M_BUTTERFLY,\n    /* 0x00C3 */ F_BUTTERFLY,\n    /* 0x00C4 */ M_STAG_BEETLE,\n    /* 0x00C5 */ F_STAG_BEETLE,\n    /* 0x00C6 */ M_GRASSHOPPER,\n    /* 0x00C7 */ F_GRASSHOPPER,\n    /* 0x00C8 */ M_NANAFUSHI,\n    /* 0x00C9 */ F_NANAFUSHI,\n    /* 0x00CA */ M_DANGOMUSHI,\n    /* 0x00CB */ F_DANGOMUSHI,\n    /* 0x00CC */ M_MANTIS,\n    /* 0x00CD */ F_MANTIS,\n    /* 0x00CE */ M_LADYBUG,\n    /* 0x00CF */ F_LADYBUG,\n    /* 0x00D0 */ M_SNAIL,\n    /* 0x00D1 */ F_SNAIL,\n    /* 0x00D2 */ M_DRAGONFLY,\n    /* 0x00D3 */ F_DRAGONFLY,\n    /* 0x00D4 */ M_ANT,\n    /* 0x00D5 */ F_ANT,\n    /* 0x00D6 */ M_MAYFLY,\n    /* 0x00D7 */ F_MAYFLY,\n    /* 0x00D8 */ noentry53,\n    /* 0x00D9 */ noentry54,\n    /* 0x00DA */ noentry55,\n    /* 0x00DB */ noentry56,\n    /* 0x00DC */ noentry57,\n    /* 0x00DD */ noentry58,\n    /* 0x00DE */ noentry59,\n    /* 0x00DF */ noentry60,\n    /* 0x00E0 */ POU_SPIRIT,\n    /* 0x00E1 */ noentry61,\n    /* 0x00E2 */ noentry62,\n    /* 0x00E3 */ noentry63,\n    /* 0x00E4 */ noentry64,\n    /* 0x00E5 */ noentry65,\n    /* 0x00E6 */ noentry66,\n    /* 0x00E7 */ noentry67,\n    /* 0x00E8 */ noentry68,\n    /* 0x00E9 */ ANCIENT_DOCUMENT,\n    /* 0x00EA */ AIR_LETTER,\n    /* 0x00EB */ ANCIENT_DOCUMENT2,\n    /* 0x00EC */ LV7_DUNGEON_EXIT,\n    /* 0x00ED */ LINKS_SAVINGS,\n    /* 0x00EE */ SMALL_KEY2,\n    /* 0x00EF */ POU_FIRE1,\n    /* 0x00F0 */ POU_FIRE2,\n    /* 0x00F1 */ POU_FIRE3,\n    /* 0x00F2 */ POU_FIRE4,\n    /* 0x00F3 */ BOSSRIDER_KEY,\n    /* 0x00F4 */ TOMATO_PUREE,\n    /* 0x00F5 */ TASTE,\n    /* 0x00F6 */ LV5_BOSS_KEY,\n    /* 0x00F7 */ SURFBOARD,\n    /* 0x00F8 */ KANTERA2,\n    /* 0x00F9 */ L2_KEY_PIECES1,\n    /* 0x00FA */ L2_KEY_PIECES2,\n    /* 0x00FB */ L2_KEY_PIECES3,\n    /* 0x00FC */ KEY_OF_CARAVAN,\n    /* 0x00FD */ LV2_BOSS_KEY,\n    /* 0x00FE */ KEY_OF_FILONE,\n    /* 0x00FF */ NO_ITEM,\n    /* 0x0100 */ noentry69,\n    /* 0x0101 */ noentry70,\n    /* 0x0102 */ noentry71,\n    /* 0x0103 */ EQUIP_SWORD,\n    /* 0x0104 */ noentry72,\n    /* 0x0105 */ noentry73,\n    /* 0x0106 */ noentry74,\n    /* 0x0107 */ noentry75,\n    /* 0x0108 */ noentry76,\n    /* 0x0109 */ noentry77,\n    /* 0x010A */ noentry78,\n    /* 0x010B */ noentry79,\n};\n\nenum CollectItem {\n    /* 0x0 */ COLLECT_CLOTHING,\n    /* 0x1 */ COLLECT_SWORD,\n    /* 0x2 */ COLLECT_SHIELD,\n    /* 0x3 */ COLLECT_SMELL,\n    /* 0x4 */ B_BUTTON_ITEM\n};\n\nenum Swords {\n    /* 0x0 */ COLLECT_ORDON_SWORD,\n    /* 0x1 */ COLLECT_MASTER_SWORD,\n    /* 0x2 */ COLLECT_WOODEN_SWORD,\n    /* 0x3 */ COLLECT_LIGHT_SWORD\n};\n\nenum Shields {\n    /* 0x0 */ COLLECT_WOODEN_SHIELD,\n    /* 0x1 */ COLLECT_ORDON_SHIELD,\n    /* 0x2 */ COLLECT_HYLIAN_SHIELD\n};\n\nenum Clothes {\n    /* 0x0 */ KOKIRI_CLOTHES_FLAG\n};\n\nenum LightDropStages {\n    /* 0x0 */ FARON_VESSEL,\n    /* 0x1 */ ELDIN_VESSEL,\n    /* 0x2 */ LANAYRU_VESSEL\n};\n\nenum ItemMax {\n    /* 0x0 */ ARROW_MAX,\n    /* 0x1 */ NORMAL_BOMB_MAX,\n    /* 0x2 */ WATER_BOMB_MAX,\n    /* 0x6 */ POKE_BOMB_MAX = 6\n};\n\nenum {\n    /* 0x0 */ SELECT_ITEM_LEFT,\n    /* 0x1 */ SELECT_ITEM_RIGHT,\n    /* 0x2 */ SELECT_ITEM_DOWN,\n    /* 0x3 */ SELECT_ITEM_B,\n    /* 0x0 */ SELECT_ITEM_X = SELECT_ITEM_LEFT,\n    /* 0x1 */ SELECT_ITEM_Y = SELECT_ITEM_RIGHT,\n};\n\nenum {\n    /* 0x0 */ TF_STATUS_HUMAN,\n    /* 0x1 */ TF_STATUS_WOLF,\n};\n\nclass dSv_player_status_a_c {\npublic:\n    void init();\n    void setSelectItemIndex(int i_no, u8 i_slotNo);\n    u8 getSelectItemIndex(int i_no) const;\n    void setMixItemIndex(int i_no, u8 i_slotNo);\n    u8 getMixItemIndex(int i_no) const;\n    u16 getRupeeMax() const;\n    int isMagicFlag(u8 i_magic) const;\n\n    u16 getMaxLife() const { return mMaxLife; }\n    u16 getLife() const { return mLife; }\n    u16 getRupee() const { return mRupee; }\n    u16 getOil() const { return mOil; }\n    u16 getMaxOil() const { return mMaxOil; }\n    u8 getMagic() const { return mMagic; }\n    u8 getMaxMagic() const { return mMaxMagic; }\n    u8 getSelectEquip(int item) const { return mSelectEquip[item]; }\n    u8 getTransformStatus() const { return mTransformStatus; }\n    u8 getWalletSize() const { return mWalletSize; }\n    void setOil(u16 i_oil) { mOil = i_oil; }\n    void setMaxOil(u16 i_maxOil) { mMaxOil = i_maxOil; }\n    void setWalletSize(u8 i_size) { mWalletSize = i_size; }\n    void setMagic(u8 i_magic) { mMagic = i_magic; }\n    void setMaxMagic(u8 i_maxMagic) { mMaxMagic = i_maxMagic; }\n    void setRupee(u16 i_rupees) { mRupee = i_rupees; }\n    void setLife(u16 i_life) { mLife = i_life; }\n    void setMaxLife(u8 i_maxLife) { mMaxLife = i_maxLife; }\n    void setSelectEquip(int i_equipId, u8 i_itemNo) { mSelectEquip[i_equipId] = i_itemNo; }\n    void setTransformStatus(u8 i_status) { mTransformStatus = i_status; }\n\nprivate:\n    /* 0x00 */ u16 mMaxLife;\n    /* 0x02 */ u16 mLife;\n    /* 0x04 */ u16 mRupee;\n    /* 0x06 */ u16 mMaxOil;\n    /* 0x08 */ u16 mOil;\n    /* 0x0A */ u8 unk10;\n    /* 0x0B */ u8 mSelectItem[MAX_SELECT_ITEM];  // For GC: first 2 are X & Y, others unused; For\n                                                 // Wii (in order): Left, Right, Down, B\n    /* 0x0F */ u8 mMixItem[MAX_SELECT_ITEM];     // Combo items; For GC: first 2 are X & Y, others\n                                                 // unused; For Wii (in order): Left, Right, Down, B\n    /* 0x13 */ u8 mSelectEquip[MAX_EQUIPMENT];\n    /* 0x19 */ u8 mWalletSize;\n    /* 0x1A */ u8 mMaxMagic;\n    /* 0x1B */ u8 mMagic;\n    /* 0x1C */ u8 mMagicFlag;\n    /* 0x1D */ u8 unk29;\n    /* 0x1E */ u8 mTransformStatus;\n    /* 0x1F */ u8 unk31[3];\n};  // Size: 0x28\n\nclass dSv_player_status_b_c {\npublic:\n    void init();\n    void onDarkClearLV(int i_no);\n    BOOL isDarkClearLV(int i_no) const;\n    void onTransformLV(int i_no);\n    BOOL isTransformLV(int i_no) const;\n\n    void setDateIpl(s64 i_time) { mDateIpl = i_time; }\n    u16 getDate() const { return mDate; }\n    f32 getTime() const { return mTime; }\n    void setDate(u16 i_date) { mDate = i_date; }\n    void setTime(f32 i_time) { mTime = i_time; }\n    OSTime getDateIpl() const { return mDateIpl; }\n\nprivate:\n    /* 0x00 */ OSTime mDateIpl;\n    /* 0x08 */ u8 mTransformLevelFlag;\n    /* 0x09 */ u8 mDarkClearLevelFlag;\n    /* 0x0A */ u8 unk10;\n    /* 0x0B */ u8 unk11;\n    /* 0x0C */ f32 mTime;\n    /* 0x10 */ u16 mDate;\n    /* 0x12 */ u8 unk18[3];\n};  // Size: 0x18\n\nclass dSv_horse_place_c {\npublic:\n    dSv_horse_place_c() {}\n\n    void init();\n    void set(const char* i_name, const cXyz& i_pos, s16 i_angle, s8 i_roomNo);\n\nprivate:\n    /* 0x00 */ cXyz mPos;\n    /* 0x0C */ u16 mAngleY;\n    /* 0x0E */ char mName[8];\n    /* 0x16 */ u8 mSpawnId;\n    /* 0x17 */ u8 mRoomNo;\n};  // Size: 0x18\n\nclass dSv_player_return_place_c {\npublic:\n    void init();\n    void set(const char* i_name, s8 i_roomNo, u8 i_status);\n    s8 getRoomNo() const { return mRoomNo; }\n    u8 getPlayerStatus() const { return mPlayerStatus; }\n    char* getName() { return mName; }\n\nprivate:\n    /* 0x00 */ char mName[8];\n    /* 0x08 */ u8 mPlayerStatus;\n    /* 0x09 */ s8 mRoomNo;\n    /* 0x0A */ u8 unk10;\n    /* 0x0B */ u8 unk11;\n};  // Size: 0xC\n\nclass dSv_player_field_last_stay_info_c {\npublic:\n    dSv_player_field_last_stay_info_c() {}\n\n    void init();\n    BOOL isRegionBit(int i_region) const;\n    void onRegionBit(int i_region);\n    void set(const char* i_name, const cXyz& i_pos, s16 i_angle, s8 i_spawn, u8 i_regionNo);\n\n    bool isFieldDataExistFlag() const { return mFieldDataExistFlag; }\n\nprivate:\n    /* 0x00 */ cXyz mPos;\n    /* 0x0C */ s16 mAngleY;\n    /* 0x0E */ char mName[8];\n    /* 0x16 */ u8 mLastSpawnId;\n    /* 0x17 */ u8 mRegionNo;\n    /* 0x18 */ bool mFieldDataExistFlag;\n    /* 0x19 */ u8 mRegion;\n    /* 0x1A */ u8 unk26[2];\n};  // Size: 0x1C\n\nclass dSv_player_last_mark_info_c {\npublic:\n    dSv_player_last_mark_info_c() {}\n\n    void init();\n    void setWarpItemData(const char* i_name, const cXyz& i_pos, s16 i_angle, s8 i_roomNo, u8, u8);\n\n    const char* getName() { return mName; }\n    cXyz& getPos() { return mPos; }\n    s16 getAngleY() { return mAngleY; }\n    s8 getRoomNo() { return mRoomNo; }\n    s8 getWarpAcceptStage() { return mWarpAcceptStage; }\n    void resetWarpAcceptStage() { mWarpAcceptStage = -1; }\n    void setWarpAcceptStage(s8 accept) { mWarpAcceptStage = accept; }\n\nprivate:\n    /* 0x00 */ cXyz mPos;\n    /* 0x0C */ s16 mAngleY;\n    /* 0x0E */ char mName[8];\n    /* 0x16 */ u8 mSpawnId;\n    /* 0x17 */ s8 mRoomNo;\n    /* 0x18 */ s8 mWarpAcceptStage;\n    /* 0x19 */ u8 unk25[3];\n};  // Size: 0x1C\n\nclass dSv_player_item_c {\npublic:\n    void init();\n    void setItem(int i_slotNo, u8 i_itemNo);\n    u8 getItem(int i_slotNo, bool i_checkCombo) const;\n    void setLineUpItem();\n    u8 getLineUpItem(int i_slotNo) const;\n    void setBottleItemIn(u8 curItemIn, u8 newItemIn);\n    void setEmptyBottleItemIn(u8 i_itemNo);\n    void setEmptyBottle();\n    void setEmptyBottle(u8 i_itemNo);\n    void setEquipBottleItemIn(u8 curItemIn, u8 newItemIn);\n    void setEquipBottleItemEmpty(u8 curItemIn);\n    u8 checkBottle(u8 i_itemNo);\n    int checkInsectBottle();\n    u8 checkEmptyBottle();\n    void setBombBagItemIn(u8 i_curBomb, u8 i_newBomb, bool i_setNum);\n    void setBombBagItemIn(u8 i_curBomb, u8 i_newBomb, u8 i_bombNum, bool i_setNum);\n    void setEmptyBombBagItemIn(u8 i_newBomb, bool i_setNum);\n    void setEmptyBombBagItemIn(u8 i_newBomb, u8 i_bombNum, bool i_setNum);\n    void setEmptyBombBag();\n    void setEmptyBombBag(u8 i_newBomb, u8 i_bombNum);\n    u8 checkBombBag(u8 i_itemNo);\n    void setWarashibeItem(u8 i_itemNo);\n    void setRodTypeLevelUp();\n    void setBaitItem(u8 i_itemNo);\n\nprivate:\n    /* 0x00 */ u8 mItems[24];\n    /* 0x18 */ u8 mItemSlots[24];\n};  // Size: 0x30\n\nclass dSv_player_get_item_c {\npublic:\n    void init();\n    void onFirstBit(u8 i_itemNo);\n    void offFirstBit(u8 i_itemNo);\n    int isFirstBit(u8 i_itemNo) const;\n\nprivate:\n    /* 0x0 */ u32 mItemFlags[8];\n};  // Size: 0x20\n\nclass dSv_player_item_record_c {\npublic:\n    void init();\n    void setBombNum(u8 i_bagIdx, u8 i_bombNum);\n    u8 getBombNum(u8 i_bagIdx) const;\n    void setBottleNum(u8 i_bottleIdx, u8 i_bottleNum);\n    u8 addBottleNum(u8 i_bottleIdx, s16 i_num);\n    u8 getBottleNum(u8 i_bottleIdx) const;\n\n    u8 getArrowNum() const { return mArrowNum; }\n    void setArrowNum(u8 i_num) { mArrowNum = i_num; }\n    u8 getPachinkoNum() const { return mPachinkoNum; }\n    void setPachinkoNum(u8 i_num) { mPachinkoNum = i_num; }\n\nprivate:\n    /* 0x0 */ u8 mArrowNum;\n    /* 0x1 */ u8 mBombNum[3];\n    /* 0x4 */ u8 mBottleNum[4];\n    /* 0x8 */ u8 mPachinkoNum;\n    /* 0x9 */ u8 unk5[3];\n};  // Size: 0xC\n\nclass dSv_player_item_max_c {\npublic:\n    void init();\n    void setBombNum(u8 i_bombType, u8 i_maxNum);\n    u8 getBombNum(u8 i_bombType) const;\n\n    void setArrowNum(u8 i_maxNum) { mItemMax[ARROW_MAX] = i_maxNum; }\n    u8 getArrowNum() const { return mItemMax[ARROW_MAX]; }\n\nprivate:\n    /* 0x0 */ u8 mItemMax[8];\n};  // Size: 0x8\n\nclass dSv_player_collect_c {\npublic:\n    void init();\n    void setCollect(int i_item_type, u8 i_item);\n    BOOL isCollect(int i_item_type, u8 i_item) const;\n    void onCollectCrystal(u8 i_item);\n    BOOL isCollectCrystal(u8 i_item) const;\n    void onCollectMirror(u8 i_item);\n    BOOL isCollectMirror(u8 i_item) const;\n\n    u8 getPohNum() { return mPohNum; }\n\nprivate:\n    /* 0x0 */ u8 mItem[8];\n    /* 0x8 */ u8 unk8;\n    /* 0x9 */ u8 mCrystal;\n    /* 0xA */ u8 mMirror;\n    /* 0xB */ u8 unk11;\n    /* 0xC */ u8 mPohNum;\n    /* 0xD */ u8 padding[3];\n};  // Size: 0x10\n\nclass dSv_player_wolf_c {\npublic:\n    void init();\n\nprivate:\n    /* 0x0 */ u8 unk0[3];\n    /* 0x3 */ u8 unk3;\n};  // Size: 0x4\n\nclass dSv_light_drop_c {\npublic:\n    void init();\n    void setLightDropNum(u8 i_nowLevel, u8 i_dropNum);\n    u8 getLightDropNum(u8 i_nowLevel) const;\n    void onLightDropGetFlag(u8 i_nowLevel);\n    BOOL isLightDropGetFlag(u8 i_nowLevel) const;\n\nprivate:\n    /* 0x0 */ u8 mLightDropNum[4];\n    /* 0x4 */ u8 mLightDropGetFlag;\n    /* 0x5 */ u8 unk5[3];\n};  // Size: 0x8\n\nclass dSv_letter_info_c {\npublic:\n    void init();\n    void onLetterGetFlag(int i_no);\n    BOOL isLetterGetFlag(int i_no) const;\n    void onLetterReadFlag(int i_no);\n    int isLetterReadFlag(int i_no) const;\n    u8 getGetNumber(int i_no) { return mGetNumber[i_no]; }\n    void setGetNumber(int i_no, u8 i_value) { mGetNumber[i_no] = i_value; }\n\nprivate:\n    /* 0x00 */ u32 mLetterGetFlags[2];\n    /* 0x08 */ u32 mLetterReadFlags[2];\n    /* 0x10 */ u8 mGetNumber[64];\n};  // Size: 0x50\n\nclass dSv_fishing_info_c {\npublic:\n    void init();\n    void addFishCount(u8 i_fishIndex);\n    u16 getFishCount(u8 i_fishIndex) const { return mFishCount[i_fishIndex]; }\n    u8 getMaxSize(s32 i_sizeIndex) { return mMaxSize[i_sizeIndex]; }\n    void setMaxSize(s32 i_sizeIndex, u8 i_size) { mMaxSize[i_sizeIndex] = i_size; }\n\nprivate:\n    /* 0x00 */ u16 mFishCount[16];\n    /* 0x20 */ u8 mMaxSize[16];\n};  // Size: 0x34\n\nclass dSv_player_info_c {\npublic:\n    void init();\n    char* getLinkName() { return mPlayerName; }\n    char* getHorseName() { return mHorseName; }\n    void setPlayerName(const char* i_name) { strcpy((char*)mPlayerName, i_name); }\n    void setHorseName(const char* i_name) { strcpy((char*)mHorseName, i_name); }\n    void setTotalTime(s64 i_time) { mTotalTime = i_time; }\n    s64 getTotalTime() const { return mTotalTime; }\n\n    void addDeathCount() {\n        if (mDeathCount < 0xFFFF) {\n            mDeathCount++;\n        }\n    }\n\nprivate:\n    /* 0x00 */ u32 unk0;\n    /* 0x04 */ u32 unk4;\n    /* 0x08 */ s64 mTotalTime;\n    /* 0x10 */ u16 unk16;\n    /* 0x12 */ u16 mDeathCount;\n    /* 0x14 */ char mPlayerName[16];\n    /* 0x24 */ u8 unk36;\n    /* 0x25 */ char mHorseName[16];\n    /* 0x35 */ u8 unk53;\n    /* 0x36 */ u8 mClearCount;\n    /* 0x37 */ u8 unk55[5];\n};  // Size: 0x40\n\nclass dSv_player_config_c {\npublic:\n    void init();\n    u32 checkVibration() const;\n    u8 getSound();\n    void setSound(u8 i_mode);\n    u8 getVibration();\n    void setVibration(u8 i_status);\n\n    u8 getAttentionType() { return mAttentionType; }\n    void setAttentionType(u8 i_mAttentionType) { mAttentionType = i_mAttentionType; }\n    u16 getCalibrateDist() { return mCalibrateDist; }\n    void setCalibrateDist(u16 i_mCalibrateDist) { mCalibrateDist = i_mCalibrateDist; }\n    u8 getCalValue() { return mCalValue; }\n    void setCalValue(u8 i_mCalValue) { mCalValue = i_mCalValue; }\n    bool getShortCut() { return mShortCut; }\n    void setShortCut(bool i_mShortCut) { mShortCut = i_mShortCut; }\n    u8 getCameraControl() { return mCameraControl; }\n    void setCameraControl(u8 i_mCameraControl) { mCameraControl = i_mCameraControl; }\n    bool getPointer() { return mPointer; }\n    void setPointer(bool i_mPointer) { mPointer = i_mPointer; }\n\nprivate:\n    /* 0x0 */ u8 unk0;\n    /* 0x1 */ u8 mSoundMode;\n    /* 0x2 */ u8 mAttentionType;  // Lock-On Type; 0 : hold, 1 : switch\n    /* 0x3 */ u8 mVibration;      // Rumble status\n    /* 0x4 */ u8 unk4;\n    /* 0x5 */ u8 unk5;\n    /* 0x6 */ u16 mCalibrateDist;  // Wii pointer horizontal calibration. Default is 0x015E\n    /* 0x8 */ u8 mCalValue;        // Wii pointer vertical calibration. Default is 0x00\n    /* 0x9 */ bool mShortCut;      // Wii icon shortcut enabled/disabled.\n    /* 0xA */ u8 mCameraControl;   // 0 : normal, 1 : inverted\n    /* 0xB */ bool mPointer;       // Wii pointer enabled/disabled.\n};                                 // Size: 0xC\n\nclass dSv_player_c {\npublic:\n    dSv_player_c() {}\n    void init();\n\n    dSv_player_info_c& getPlayerInfo() { return mPlayerInfo; }\n    dSv_player_status_a_c& getPlayerStatusA() { return mPlayerStatusA; }\n    dSv_player_status_b_c& getPlayerStatusB() { return mPlayerStatusB; }\n    dSv_player_item_c& getItem() { return mItem; }\n    dSv_player_collect_c& getCollect() { return mCollect; }\n    dSv_player_item_record_c& getItemRecord() { return mItemRecord; }\n    dSv_player_item_max_c& getItemMax() { return mItemMax; }\n    dSv_player_last_mark_info_c& getPlayerLastMarkInfo() { return mPlayerLastMarkInfo; }\n    dSv_player_return_place_c& getPlayerReturnPlace() { return mPlayerReturnPlace; }\n    dSv_light_drop_c& getLightDrop() { return mLightDrop; }\n    dSv_player_get_item_c& getGetItem() { return mGetItem; }\n    dSv_player_config_c& getConfig() { return mConfig; }\n    dSv_letter_info_c& getLetterInfo() { return mLetterInfo; }\n    dSv_fishing_info_c& getFishingInfo() { return mFishingInfo; }\n    dSv_player_field_last_stay_info_c& getPlayerFieldLastStayInfo() {\n        return mPlayerFieldLastStayInfo;\n    }\n\nprivate:\n    /* 0x000 */ dSv_player_status_a_c mPlayerStatusA;\n    /* 0x028 */ dSv_player_status_b_c mPlayerStatusB;\n    /* 0x040 */ dSv_horse_place_c mHorsePlace;\n    /* 0x058 */ dSv_player_return_place_c mPlayerReturnPlace;\n    /* 0x064 */ dSv_player_field_last_stay_info_c mPlayerFieldLastStayInfo;\n    /* 0x080 */ dSv_player_last_mark_info_c mPlayerLastMarkInfo;\n    /* 0x09C */ dSv_player_item_c mItem;\n    /* 0x0CC */ dSv_player_get_item_c mGetItem;\n    /* 0x0EC */ dSv_player_item_record_c mItemRecord;\n    /* 0x0F8 */ dSv_player_item_max_c mItemMax;\n    /* 0x100 */ dSv_player_collect_c mCollect;\n    /* 0x110 */ dSv_player_wolf_c mWolf;\n    /* 0x114 */ dSv_light_drop_c mLightDrop;\n    /* 0x11C */ dSv_letter_info_c mLetterInfo;\n    /* 0x16C */ dSv_fishing_info_c mFishingInfo;\n    /* 0x1A0 */ dSv_player_info_c mPlayerInfo;\n    /* 0x1E0 */ dSv_player_config_c mConfig;\n};  // Size: 0x1EC\n\nclass dSv_memBit_c {\npublic:\n    enum {\n        /* 0x0 */ MAP,\n        /* 0x1 */ COMPASS,\n        /* 0x2 */ BOSS_KEY,\n        /* 0x3 */ STAGE_BOSS_ENEMY,\n        /* 0x4 */ STAGE_LIFE,\n        /* 0x5 */ STAGE_BOSS_DEMO,\n        /* 0x6 */ OOCCOO_NOTE,\n        /* 0x7 */ STAGE_BOSS_ENEMY_2\n    };\n\n    void init();\n    void onTbox(int i_no);\n    void offTbox(int i_no);\n    BOOL isTbox(int i_no) const;\n    void onSwitch(int i_no);\n    void offSwitch(int i_no);\n    BOOL isSwitch(int i_no) const;\n    BOOL revSwitch(int i_no);\n    void onItem(int i_no);\n    BOOL isItem(int i_no) const;\n    void onDungeonItem(int i_no);\n    s32 isDungeonItem(int i_no) const;\n\n    u8 getKeyNum() { return mKeyNum; }\n    void setKeyNum(u8 i_keyNum) { mKeyNum = i_keyNum; }\n    void onDungeonItemMap() { onDungeonItem(MAP); }\n    s32 isDungeonItemMap() const { return isDungeonItem(MAP); }\n    void onDungeonItemCompass() { onDungeonItem(COMPASS); }\n    s32 isDungeonItemCompass() const { return isDungeonItem(COMPASS); }\n    void onDungeonItemWarp() { onDungeonItem(OOCCOO_NOTE); }\n    void onDungeonItemBossKey() { onDungeonItem(BOSS_KEY); }\n    s32 isDungeonItemBossKey() const { return isDungeonItem(BOSS_KEY); }\n    void onStageBossEnemy() {\n        onDungeonItem(STAGE_BOSS_ENEMY);\n        onDungeonItem(OOCCOO_NOTE);\n    }\n    s32 isStageBossEnemy() const { return isDungeonItem(STAGE_BOSS_ENEMY); }\n    s32 isStageBossEnemy2() const { return isDungeonItem(STAGE_BOSS_ENEMY_2); }\n    s32 isDungeonItemWarp() const { return isDungeonItem(OOCCOO_NOTE); }\n    void onStageLife() { onDungeonItem(STAGE_LIFE); }\n\nprivate:\n    /* 0x00 */ u32 mTbox[2];\n    /* 0x08 */ u32 mSwitch[4];\n    /* 0x18 */ u32 mItem[1];\n    /* 0x1C */ u8 mKeyNum;\n    /* 0x1D */ u8 mDungeonItem;\n};  // Size: 0x20\n\nclass dSv_event_c {\npublic:\n    void init();\n    void onEventBit(u16 i_no);\n    void offEventBit(u16 i_no);\n    int isEventBit(u16 i_no) const;\n    void setEventReg(u16 i_reg, u8 i_no);\n    u8 getEventReg(u16 i_reg) const;\n\n    void* getPEventBit() { return (void*)mEvent; }\n\nprivate:\n    /* 0x0 */ u8 mEvent[256];\n};  // Size: 0x100\n\nclass dSv_MiniGame_c {\npublic:\n    void init();\n\n    u32 getRaceGameTime() const { return mRaceGameTime; }\n    u32 getBalloonScore() const { return mBalloonScore; }\n\nprivate:\n    /* 0x00 */ u8 unk0;\n    /* 0x01 */ u8 unk1[3];\n    /* 0x04 */ u32 mStarTime;\n    /* 0x08 */ u32 mBalloonScore;\n    /* 0x0C */ u32 mRaceGameTime;\n    /* 0x10 */ u32 unk16;\n    /* 0x14 */ u32 unk20;\n};  // Size: 0x18\n\nclass dSv_memory_c {\npublic:\n    dSv_memory_c() { this->init(); }\n    void init();\n    dSv_memBit_c& getBit() { return mBit; }\n    const dSv_memBit_c& getBit() const { return mBit; }\n\nprivate:\n    /* 0x0 */ dSv_memBit_c mBit;\n};  // Size: 0x20\n\nSTATIC_ASSERT(sizeof(dSv_memory_c) == 0x20);\n\nclass dSv_memory2_c {\npublic:\n    dSv_memory2_c() { this->init(); }\n    void init();\n    void onVisitedRoom(int i_no);\n    void offVisitedRoom(int i_no);\n    BOOL isVisitedRoom(int i_no);\n\nprivate:\n    /* 0x0 */ u32 mVisitedRoom[2];\n};  // Size: 0x8\n\nSTATIC_ASSERT(sizeof(dSv_memory2_c) == 8);\n\nclass dSv_danBit_c {\npublic:\n    bool init(s8 i_stageNo);\n    void onSwitch(int i_no);\n    void offSwitch(int i_no);\n    BOOL isSwitch(int i_no) const;\n    BOOL revSwitch(int i_no);\n    void onItem(int i_no);\n    BOOL isItem(int i_no) const;\n\n    void reset() { mStageNo = -1; }\n\nprivate:\n    /* 0x00 */ s8 mStageNo;\n    /* 0x01 */ u8 unk1;\n    /* 0x02 */ u8 unk2[2];\n    /* 0x04 */ u32 mSwitch[2];\n    /* 0x0C */ u32 mItem[4];\n    /* 0x1C */ s16 unk28[16];\n};  // Size: 0x3C\n\nclass dSv_zoneBit_c {\npublic:\n    void init();\n    void clearRoomSwitch();\n    void clearRoomItem();\n    void onSwitch(int i_no);\n    void offSwitch(int i_no);\n    BOOL isSwitch(int i_no) const;\n    BOOL revSwitch(int i_no);\n    void onOneSwitch(int i_no);\n    void offOneSwitch(int i_no);\n    BOOL isOneSwitch(int i_no) const;\n    BOOL revOneSwitch(int i_no);\n    void onItem(int i_no);\n    BOOL isItem(int i_no) const;\n    void onOneItem(int i_no);\n    BOOL isOneItem(int i_no) const;\n\nprivate:\n    /* 0x00 */ u16 mSwitch[2];\n    /* 0x04 */ u16 mRoomSwitch;\n    /* 0x06 */ u16 mItem[2];\n    /* 0x0A */ u16 mRoomItem;\n    /* 0x0C */ u16 unk12;\n};  // Size: 0xE\n\nclass dSv_zoneActor_c {\npublic:\n    void init();\n    void on(int i_id);\n    void off(int i_id);\n    BOOL is(int i_id) const;\n\n    static const int ACTOR_MAX = 0xFFFF;\n\nprivate:\n    /* 0x00 */ u32 mActorFlags[4];\n};  // Size: 0x10\n\nclass dSv_zone_c {\npublic:\n    dSv_zone_c() { mRoomNo = -1; }\n    void init(int i_roomNo);\n\n    dSv_zoneBit_c& getZoneBit() { return mBit; }\n    const dSv_zoneBit_c& getBit() const { return mBit; }\n    dSv_zoneActor_c& getActor() { return mActor; }\n    const dSv_zoneActor_c& getActor() const { return mActor; }\n\n    s8& getRoomNo() { return mRoomNo; }\n    void reset() { mRoomNo = -1; }\n\nprivate:\n    /* 0x00 */ s8 mRoomNo;\n    /* 0x01 */ u8 unk1;\n    /* 0x02 */ dSv_zoneBit_c mBit;\n    /* 0x10 */ dSv_zoneActor_c mActor;\n};  // Size: 0x20\n\nSTATIC_ASSERT(sizeof(dSv_zone_c) == 0x20);\n\nclass dSv_restart_c {\npublic:\n    void setRoom(const cXyz& i_position, s16 i_angleY, s8 i_roomNo);\n\n    void setRoomParam(u32 param) { mRoomParam = param; }\n    void setStartPoint(s16 point) { mStartPoint = point; }\n    void setLastSceneInfo(f32 speed, u32 mode, s16 angle) {\n        mLastSpeedF = speed;\n        mLastMode = mode;\n        mLastAngleY = angle;\n    }\n\n    s16 getStartPoint() const { return mStartPoint; }\n    u32 getLastMode() const { return mLastMode; }\n    s8 getRoomNo() const { return mRoomNo; }\n    u32 getRoomParam() const { return mRoomParam; }\n    cXyz& getRoomPos() { return mRoomPos; }\n    s16 getRoomAngleY() const { return mRoomAngleY; }\n\nprivate:\n    /* 0x00 */ s8 mRoomNo;\n    /* 0x01 */ u8 field_0x01[3];\n    /* 0x04 */ s16 mStartPoint;\n    /* 0x06 */ s16 mRoomAngleY;\n    /* 0x08 */ cXyz mRoomPos;\n    /* 0x14 */ u32 mRoomParam;\n    /* 0x18 */ f32 mLastSpeedF;\n    /* 0x1C */ u32 mLastMode;\n    /* 0x20 */ s16 mLastAngleY;\n};  // Size: 0x24\n\nclass dSv_turnRestart_c {\npublic:\n    class dSv_turnRestart_camera_c {\n        /* 0x00 */ cXyz mCameraCtr;\n        /* 0x0C */ cXyz mCameraEye;\n        /* 0x18 */ cXyz mCameraUp;\n    };  // Size: 0x24\n\n    void set(const cXyz& i_position, s16 i_angleY, s8, u32 i_param);\n\n    u32 getParam() const { return mParam; }\n    cXyz& getPos() { return mPosition; }\n    s16 getAngleY() const { return mAngleY; }\n\nprivate:\n    /* 0x00 */ cXyz mPosition;\n    /* 0x0C */ u32 mParam;\n    /* 0x10 */ s16 mAngleY;\n    /* 0x12 */ s8 unk18;\n    /* 0x14 */ dSv_turnRestart_camera_c mCamera;\n    /* 0x38 */ f32 mCameraFvy;\n};  // Size: 0x3C\n\nclass dSv_reserve_c {\npublic:\nprivate:\n    u8 unk[80];\n};\n\nclass dSv_save_c {\npublic:\n    dSv_save_c() {}\n\n    void init();\n    dSv_memory2_c* getSave2(int i_stage2No);\n\n    dSv_player_c& getPlayer() { return mPlayer; }\n    dSv_event_c& getEvent() { return mEvent; }\n    dSv_memory_c& getSave(int i_stageNo) { return mSave[i_stageNo]; }\n    dSv_MiniGame_c& getMiniGame() { return mMiniGame; }\n    void putSave(int i_stageNo, dSv_memory_c mem) { mSave[i_stageNo] = mem; }\n\n    static const int STAGE_MAX = 32;\n    static const int STAGE2_MAX = 64;\n\n    // private:\n    /* 0x000 */ dSv_player_c mPlayer;\n    /* 0x1F0 */ dSv_memory_c mSave[STAGE_MAX];\n    /* 0x5F0 */ dSv_memory2_c mSave2[STAGE2_MAX];\n    /* 0x7F0 */ dSv_event_c mEvent;\n    /* 0x8F0 */ dSv_reserve_c reserve;\n    /* 0x940 */ dSv_MiniGame_c mMiniGame;\n};  // Size: 0x958\n\nclass dSv_info_c {\npublic:\n    void init();\n    void getSave(int i_stageNo);\n    void putSave(int i_stageNo);\n    void initZone();\n    u32 createZone(int i_roomNo);\n    void onSwitch(int i_no, int i_roomNo);\n    void offSwitch(int i_no, int i_roomNo);\n    BOOL isSwitch(int i_no, int i_roomNo) const;\n    BOOL revSwitch(int i_no, int i_roomNo);\n    void onItem(int i_no, int i_roomNo);\n    BOOL isItem(int i_no, int i_roomNo) const;\n    void onActor(int i_no, int i_roomNo);\n    void offActor(int i_no, int i_roomNo);\n    BOOL isActor(int i_no, int i_roomNo) const;\n    int memory_to_card(char* card_ptr, int dataNum);\n    int card_to_memory(char* card_ptr, int dataNum);\n    int initdata_to_card(char* card_ptr, int dataNum);\n\n    dSv_save_c& getSavedata() { return mSavedata; }\n    dSv_memory_c& getMemory() { return mMemory; }\n    dSv_zone_c* getZones() { return mZone; }\n    dSv_zone_c& getZone(int id) { return mZone[id]; }\n    dSv_player_c& getPlayer() { return mSavedata.getPlayer(); }\n    dSv_event_c& getTmp() { return mTmp; }\n    dSv_restart_c& getRestart() { return mRestart; }\n    dSv_turnRestart_c& getTurnRestart() { return mTurnRestart; }\n    dSv_event_c& getEvent() { return mSavedata.getEvent(); }\n    dSv_danBit_c& getDan() { return mDan; }\n    dSv_MiniGame_c& getMiniGame() { return mSavedata.getMiniGame(); }\n    s64 getStartTime() const { return mStartTime; }\n    s64 getSaveTotalTime() const { return mSaveTotalTime; }\n    void setStartTime(s64 time) { mStartTime = time; }\n    void setSaveTotalTime(s64 time) { mSaveTotalTime = time; }\n    void initDan(s8 i_stage) { mDan.init(i_stage); }\n    void resetDan() { mDan.reset(); }\n    u8 getDataNum() const { return mDataNum; }\n    void setDataNum(u8 num) { mDataNum = num; }\n    void removeZone(int zoneNo) { mZone[zoneNo].reset(); }\n    u8 getNoFile() const { return mNoFile; }\n    void setNoFile(u8 file) { mNoFile = file; }\n    u8 getNewFile() const { return mNewFile; }\n    void setNewFile(u8 file) { mNewFile = file; }\n\n    static const int MEMORY_SWITCH = 0x80;\n    static const int DAN_SWITCH = 0x40;\n    static const int ZONE_SWITCH = 0x20;\n    static const int ONEZONE_SWITCH = 0x10;\n\n    static const int MEMORY_ITEM = 0x80;\n    static const int DAN_ITEM = 0x20;\n    static const int ZONE_ITEM = 0x20;\n    static const int ONEZONE_ITEM = 0x10;\n\n    static const int ZONE_MAX = 0x20;\n\nprivate:\n    /* 0x000 */ dSv_save_c mSavedata;\n    /* 0x958 */ dSv_memory_c mMemory;\n    /* 0x978 */ dSv_danBit_c mDan;\n    /* 0x9B4 */ dSv_zone_c mZone[ZONE_MAX];\n    /* 0xDB4 */ dSv_restart_c mRestart;\n    /* 0xDD8 */ dSv_event_c mTmp;\n    /* 0xED8 */ dSv_turnRestart_c mTurnRestart;\n    /* 0xF14 */ u8 field_0xf14[4];\n    /* 0xF18 */ u8 mDataNum;\n    /* 0xF19 */ u8 mNewFile;\n    /* 0xF1A */ u8 mNoFile;\n    /* 0xF1B */ u8 field_0xf1b[13];\n    /* 0xF28 */ s64 mStartTime;\n    /* 0xF30 */ s64 mSaveTotalTime;\n};  // Size: 0xF38\n\nclass dSv_event_flag_c {\npublic:\n    enum {\n/* \"include/d/save/d_save.h\" line 1156 \"d/save/d_save_bit_labels.inc\" */\n/**\n * d_save_bit_labels.inc\n * Flag labels for dSv_event_flag_c::saveBitLabels\n *\n * Flag information comes from the debug table in d_event_debug.inc\n *\n */\n\n/* \nName                = Value         // Location                    - Description \n*/\n\nB_BTN_GUIDE         = 0x5c01,       // Misc.                       - B-button guide\nD_0001              = 0x0380,       // Ordon Village               - Stopped by squirrel in front of house at night\nF_0001              = 0x0008,       // Kakariko Village            - Spoke to Renado after Colin returns\nF_0002              = 0x0004,       // Death Mountain (room)       - Lost wrestling match to elder goron for first time\nF_0003              = 0x0002,       // Snowpeak Ruins              - Handed over tomato puree and left room\nF_0004              = 0x0001,       // Snowpeak Ruins              - Handed over secret ingredient and left room\nF_0005              = 0x0180,       // Misc.                       - Gathered 14 Tears of Light in area 4\nF_0006              = 0x0140,       // Snowpeak Ruins              - First conversation with Yeto in kitchen\nF_0007              = 0x0120,       // Snowpeak Ruins              - Spoke to Yeta while holding cheese\nF_0008              = 0x0110,       // Ordon Village               - First conversation with Fado at the farm on 1st day\nF_0009              = 0x0108,       // Ordon Woods                 - Approach secret entrance with Colin\nF_0010              = 0x0104,       // Ordon Village               - First convo with Colin blocking path (forced)\nF_0011              = 0x0102,       // Ordon Ranch                 - Fence jumping complete\nF_0012              = 0x0101,       // Ordon Village               - Get metal sword!\nF_0013              = 0x0280,       // Ordon Village               - 2nd day - First time rampaging goat escapes\nF_0014              = 0x0240,       // Ordon Village               - sword tutorial ends\nF_0015              = 0x0220,       // Ordon Village               - Slingshot tutorial ends\nF_0016              = 0x0210,       // Ordon Village               - On 3rd day, start following Colin who is blocking path\nF_0017              = 0x0208,       // Ordon Village               - Spoke to beth right after sword tutorial\nF_0018              = 0x0204,       // Ordon Ranch                 - Asked by Fado to jump fence\nF_0019              = 0x0202,       // Ordon Woods                 - Spoke with Ilia (Colin is there too) at the spring\nF_0020              = 0x0201,       // Ordon Village               - First convo with Sera while shop is closed\nF_0021              = 0x0340,       // Ordon Village               - 2nd day: spoke with Pergie\nF_0022              = 0x0320,       // Ordon Ranch                 - Start fence-jump on 1st day\nF_0023              = 0x0310,       // Ordon Village               - Called by Jaggle from below hill\nF_0024              = 0x0308,       // Ordon Village               - Spoke with Talo/Malo/Beth (before obtaining slingshot)\nF_0025              = 0x0304,       // Ordon Village               - Pass Uli's pick-up tutorial\nF_0026              = 0x0302,       // Ordon Village               - gave wooden sword to talo on 3rd day\nF_0027              = 0x0301,       // Ordon Village               - Uli tutorial ends (same whether pass or fail)\nF_0028              = 0x0480,       // Snowpeak Ruins              - Spoke to yeta while holding pumpkin\nF_0029              = 0x0440,       // Ordon Village               - 2nd day - refused sword tutorial\nF_0030              = 0x0420,       // Ordon Village               - before sword tutorial - first conversation with Beth\nF_0031              = 0x0410,       // Ordon Village               - 2nd day - Spoke to Uli bfore finding basket\nF_0032              = 0x0408,       // Ordon Ranch                 - 3rd day - First convo with fado (before forced goat chase)\nF_0033              = 0x0404,       // Ordon Village               - First day - spoke with Uli\nF_0034              = 0x1040,       // Ordon Village               - first conversation wtih Rusl\nF_0035              = 0x1020,       // Ordon Village               - F0003: Spoke to Colin while he is stopping hors (doesn't have fishing rod)\nF_0036              = 0x1004,       // Ordon Village               - Spoke to Jaggle using L-focus before climbing vines?\nF_0037              = 0x1002,       // Ordon Village               - Jaggle - Spoke on the hill?\nF_0038              = 0x1001,       // Ordon Village               - Opening (2nd day) cat returns home\nF_0039              = 0x1180,       // Ordon Village               - Warned by Hanch after climbing vines on 2nd day\nF_0040              = 0x1140,       // Ordon Village               - 2nd day: Spoke to Jaggle after blowing on whistle\nF_0041              = 0x1120,       // Ordon Village               - Opening 2nd day - After this is turned ON Hanch is attacked by bees\nF_0042              = 0x1110,       // Snowpeak Ruins              - Spoke with Yeta right after arriving at bedroom\nF_0043              = 0x1108,       // Kakariko Village            - First visit after fundrasing funds drop to 200\nF_0044              = 0x1104,       // Ordon Village               - Accepted sword tutorial first time\nF_0045              = 0x1102,       // Ordon Village               - Opening 3rd day - spoke with Uli\nF_0046              = 0x1101,       // Ordon Village               - Spoke with Sera after saving(lt;) failing(gt;) cat\nF_0047              = 0x1280,       // Ordon Village               - First visit after Ordon Village shop opens\nF_0048              = 0x1240,       // Ordon Village               - Uli's pick-up tutorial <fail>\nF_0049              = 0x1220,       // Ordon Village               - Uli's pick up tutorial <fail to throw>\nF_0050              = 0x1210,       // Ordon Village               - Saw cutscene for getting iron boots\nF_0051              = 0x1208,       // Ordon Village               - Spoke to Sera in the shop after saving cat\nF_0052              = 0x1204,       // Ordon Village               - Had 2nd conversaton with Sera before saving cat\nF_0053              = 0x1202,       // Faron Woods                 - Saw night stalker appearance cutscene\nF_0054              = 0x1201,       // Death Mountain              - Lost wrestling match with elder goron while wearing iron boots\nF_0055              = 0x1380,       // Faron Woods                 - Received Vessel of Light from Faron spirit\nF_0056              = 0x1340,       // Death Mountain              - Lost to elder goron 2+ times\nF_0057              = 0x1320,       // Cutscene                    - [cutscene: 17] Part with the children\nF_0058              = 0x1310,       // Castle Town                 - Listened to voices on other side of door in Telma's shop\nF_0059              = 0x1308,       // N/A                         - Conversation after getting spirit and tears of light (darkness cleared) <- probably unused ...\nF_0060              = 0x1304,       // Zora's River                - First conversation with Hozu in the World of Light\nF_0061              = 0x1302,       // Death Mountain              - Heard spring goron and shopkeeper rumers after winning wrestling match against elder goron\nF_0062              = 0x1301,       // Lake Hylia                  - Abandoned taking Fyer's cannon after paying\nF_0063              = 0x1480,       // Lake Hylia                  - Used Fyer's cannon for first time\nF_0064              = 0x1440,       // Snowpeak Ruins              - First convo with Yeta after obtaining tomato puree\nF_0065              = 0x1420,       // Snowpeak Ruins              - Yeta adds last symbol onto map\nF_0066              = 0x1410,       // Death Mountain              - First saw Goron cutscene on mountain path\nF_0067              = 0x1408,       // Ordon Village               - Recieved milk jar (1/2) from Sera\nF_0068              = 0x1404,       // N/A                         - N/A\nF_0069              = 0x1402,       // Ordon Village               - F0048: Thanked by Colen for clearing path\nF_0070              = 0x1401,       // Ordon Woods                 - Colin went deep into the woods\nF_0071              = 0x1540,       // Twilight Hyrule Field       - Cannot warp to Lanayru\nF_0072              = 0x1520,       // Ordon Village               - Knocked down large beehive with hawk\nF_0073              = 0x1510,       // Ordon Village               - Attacked after charging at large beehive\nF_0074              = 0x1508,       // Ordon Village               - Hanch attacked by bees\nF_0075              = 0x1504,       // Ordon Village               - Angered Jaggle by destroying pumpkin\nF_0076              = 0x1502,       // Ordon Village               - Spoke to Hanch in lake\nF_0077              = 0x1501,       // Castle Town                 - First converstaion with Agetha inside\nF_0078              = 0x1680,       // Ordon Village               - Hanch returned to land after jumping into lake\nF_0079              = 0x1640,       // Ordon Village               - 2nd Day - successful knocked down rampaging mountain goat\nF_0080              = 0x1620,       // Ordon Village               - Completed all of mountain goat rampage event\nF_0081              = 0x1610,       // Ordon Village               - 20 mountain goats rampaged\nF_0082              = 0x1608,       // Ordon Village               - Completed coversation with Bo after 20th mountain goat's rampage\nF_0083              = 0x1604,       // Letter                      - Deliver letter from Agetha\nF_0084              = 0x1602,       // Ordon Village               - Opening days 2&3: knocked down a beehive with slingshot\nF_0085              = 0x1601,       // Ordon Village               - Rusl appears at woods entrance\nF_0086              = 0x1780,       // Ordon Village               - Spoke with Hanch after knocking down beehive with hawk\nF_0087              = 0x1740,       // Ordon Village               - Left search area after first conversation with Pergie\nF_0088              = 0x1720,       // Ordon Village               - Spoke to Beth after quitting sword tutorial\nF_0089              = 0x1710,       // Ordon Village               - Talked to village chief for first time\nF_0090              = 0x1708,       // Castle Town                 - F:1126 - South - Spoke with Agetha's stalker (before talking with Agetha inside)\nF_0091              = 0x1704,       // Ordon Village               - F:1126 - South - Spoke with Agetha's stalker (after talking with Agetha inside)\nF_0092              = 0x1702,       // Castle Town                 - F:1127 - South - Spoke with the Hyrule soldier guide\nF_0093              = 0x1701,       // Castle Town                 - F:1128 - South - Spoke with female clerk at vegetable stand\nF_0094              = 0x1880,       // Ordon Village               - Talo went after the monkey\nF_0095              = 0x1840,       // Ordon Ranch                 - Spoke to Fado before mountain goat rampage\nF_0096              = 0x1820,       // Ordon Village               - Have spoken to Bo with 1 health\nF_0097              = 0x1810,       // Ordon Village               - First conversation with dog eavesdrop hint\nF_0202              = 0x1808,       // Ordon Village               - Rusl / Wolf fails to get sword\nF_0203              = 0x1804,       // Shop                        - First tried to steal from unnmaned shop (Havent checked donation box)\nF_0204              = 0x1802,       // Inside Hyrule Castle        - Talked to Midna from across the bars in the sewer\nF_0205              = 0x1801,       // Ordon Village               - Heard Rusl and Uli talking in Ordon village at night\nF_0206              = 0x1980,       // Ordon Woods                 - Barrier of darkness tag: tried to enter without getting sword and shield\nF_0207              = 0x1940,       // Ordon Village               - Viewed Hanch, the Hawker cutscene\nF_0208              = 0x1920,       // Ordon Village               - Hanch leapt after being startled by wolf\nF_0209              = 0x1910,       // Ordon Village               - Escape after failing to eavesdrop to Bo and Jaggle\nF_0210              = 0x1908,       // Ordon Village               - F0004: Try to get on horse when Colin is stopping horse\nF_0211              = 0x1904,       // Ordon Village               - Successfully eavesdrop on Bo and Jaggle\nF_0212              = 0x1902,       // Ordon Woods                 - Conversation wtih Colin in front of Ordon springs gate\nF_0213              = 0x1901,       // Kakariko Village            - Called by spirit after NS fight at Kakariko entrance\nF_0214              = 0x1a80,       // Inside Hyrule Castle        - First heard Midna's hint about Z\nF_0215              = 0x1a40,       // Ordon Village               - Spoke with cat on roof\nF_0216              = 0x1a20,       // Ordon Village               - Spoke with Ordon village cucco B (white)\nF_0217              = 0x1a10,       // Faron Woods                 - First conversation after speaking with Coro again after clearing up twilight\nF_0218              = 0x1a08,       // Faron Woods                 - Bought jar of oil from Coro\nF_0219              = 0x1a04,       // Castle Town                 - Heard Agetha say \"but you have some\"\nF_0220              = 0x1a02,       // Inside Hyrule Castle        - First time - Talked to one of the Hyrule soldiers underneath castle in Twilight\nF_0221              = 0x1a01,       // Kakariko Village            - Received vessel of light from spirit\nF_0222              = 0x1b80,       // Faron Woods                 - Finished Coro ignite event\nF_0223              = 0x1b40,       // Faron Woods (Coro's Shop)   - Listened to Coro's dialogue before defeating shadow bugs\nF_0224              = 0x1b20,       // Faron Woods                 - Flag for lantern guide monkey cutscene\nF_0225              = 0x1b10,       // Faron Woods                 - Lanter guide monkey doesn't come out a second time\nF_0226              = 0x1b08,       // Faron Woods                 - Get lantern back from monkey\nF_0227              = 0x1b04,       // Faron Woods                 - Try to leave mist woods after lantern taken\nF_0228              = 0x1b02,       // Death Mountain              - Listened to goron's complaint at the entrance to twilight mountain path\nF_0229              = 0x1b01,       // Faron Woods                 - Try to leave the mist woods area without lantern (after returning monkey)\nF_0230              = 0x1c80,       // Death Mountain              - Twilight - listened to goron B's complaints\nF_0231              = 0x1c40,       // Ordon Village               - Did first wrestle match with Bo\nF_0232              = 0x1c20,       // Ordon Village               - get iron boots from Bo\nF_0233              = 0x1c10,       // Ordon Village               - Win practice battle with Bo (before getting boots)\nF_0235              = 0x1c04,       // Sacred Grove                - Giant game clear\nF_0236              = 0x1c02,       // Misc.                       - Make Midna angry after doing wrong destination for Kakariko bridge warp\nF_0237              = 0x1c01,       // Kakariko Village            - Entered Malo Mart (chatted with Malo)\nF_0238              = 0x1d80,       // Faron Woods                 - Destroyed all puppets (monkey girl event before sacred grove)\nF_0240              = 0x1d20,       // Kakariko Village            - Speak with Barnes while heas making bombs\nF_0241              = 0x1d10,       // Kakariko Village            - First conversation with Barnes after bomb shop open\nF_0242              = 0x1d08,       // Goron Mines                 - Spoke with the dazed chief goron after Fyrus battle\nF_0243              = 0x1d04,       // Kakariko Village            - Speak with Luda wiping Colin's sweat\nF_0244              = 0x1d02,       // Kakariko Village            - Speak to Talo while COlin is wiping sweat\nF_0246              = 0x1e80,       // Kakariko Village            - Malo Mart fundraiser (and carying spring water) start\nF_0247              = 0x1e40,       // Kakariko Village            - First conversation with Malo (shopping complete) after helping Malo Mart fundraiser\nF_0248              = 0x1e20,       // Faron Woods                 - Speak with Coro after clearing Forest Temple\nF_0249              = 0x1e10,       // Lake Hylia                  - Try to leave after paying for Flight by Fowl (first time only)\nF_0250              = 0x1e08,       // Cutscene                    - [cutscene: 21] reunion with Zelda / Midna revived (Hyrule Castle barrier appears)\nF_0251              = 0x1e04,       // Ordon Village               - Speak again with Sera before finding kids (forced conversation)\nF_0252              = 0x1e02,       // Ordon Village               - Spoke to Sera while kids are missing (dealing with shop)\nF_0253              = 0x1e01,       // For E3 2006                 - Stuck to magnet lift at least once\nF_0254              = 0x1f80,       // For E3 2006                 - Hit boss's weak spot at least once\nF_0255              = 0x1f40,       // For E3 2006                 - Boss exhausted (grabbing chains) only on during state (normally off)\nF_0256              = 0x1f20,       // For E3 2006                 - Knocked down boss at leased once\nF_0257              = 0x1f10,       // For E3 2006                 - Only ON when boss is in hollow state (normally off, changes in real time)\nF_0258              = 0x1f08,       // For E3 2006                 - Heard hint right above heavy switch\nF_0259              = 0x1f04,       // For E3 2006                 - Heard first forced dialogue from Midna\nF_0260              = 0x1f02,       // Castle Town                 - First time speaking to Resistance Rusl\nF_0261              = 0x1f01,       // Castle Town                 - First conversation with Resistance Auru (made fun of)\nF_0262              = 0x2080,       // Castle Town                 - First conversation with Resistance Shad (made fun of)\nF_0263              = 0x2040,       // Castle Town                 - First conversation with Resistance Ashei (3) (made fun of)\nF_0264              = 0x2020,       // Cutscene                    - Get master sword\nF_0265              = 0x2010,       // Arbiter's Grounds           - Arbiter's Grounds clear\nF_0266              = 0x2008,       // Snowpeak Ruins              - Snowpeak Ruins clear\nF_0267              = 0x2004,       // Temple of Time              - Temple of Time clear\nF_0268              = 0x2002,       // City in the Sky             - City in the Sky clear\nF_0269              = 0x2001,       // Castle Town                 - First conversation with Telma after getting master sword\nF_0270              = 0x2180,       // Castle Town                 - Gave Renado's letter to Telma\nF_0271              = 0x2140,       // Castle Town                 - Talked with Telma again after the other conversation after getting master sword\nF_0272              = 0x2120,       // Castle Town                 - Saw Auru's location on map\nF_0273              = 0x2110,       // Castle Town                 - Saw Ashei's location on map\nF_0274              = 0x2108,       // Castle Town                 - Saw Rusl's location on map\nF_0275              = 0x2104,       // Castle Town                 - Saw Shad's location on map\nF_0276              = 0x2102,       // Castle Town                 - Heard conversation with Louise about stolen wood carving\nF_0277              = 0x2101,       // Castle Town                 - Hear conversation between Telma and Ilia in Telma's shop (Twilight)\nF_0278              = 0x2280,       // Hidden Village              - Received pendant from Impaz\nF_0279              = 0x2240,       // Hyrule Field                - Saw cutscene about scent of kids from wooden sword\nF_0280              = 0x2220,       // Hyrule Field                - Saw cutscene about Ilia's scent from pouch\nF_0281              = 0x2210,       // Shop                        - Malo Mart opens in Castle Town\nF_0292              = 0x2302,       // Castle Town                 - Star Game 2 first experience\nF_0293              = 0x2301,       // Castle Town                 - Star Game 2 cleared\nF_0294              = 0x2480,       // Castle Town                 - Shaman - Prayers reached the heavens (heart piece obtained complete)\nF_0295              = 0x2440,       // Castle Town                 - Watched meeting Louise event when sneaking into Telma's shop (wolf)\nF_0296              = 0x2420,       // Castle Town                 - Spoke with Louise after kicked being kicked out of Telma's shop\nF_0297              = 0x2410,       // Castle Town                 - First spoke with Chudley store clerk\nF_0298              = 0x2408,       // Castle Town                 - Spoke with Auru after completing Arbiter's Grounds\nF_0299              = 0x2404,       // Castle Town                 - Spoke with Shad at Telma's shop after getting master sword\nF_0300              = 0x2402,       // Castle Town                 - Heard about Sky People from Shad at Telma's shop\nF_0301              = 0x2401,       // Castle Town                 - Spoke with Shad after City in the Sky clear\nF_0302              = 0x2580,       // Kakariko Village            - Saw cutscene of Shad casting spells underneat Kakariko Village\nF_0303              = 0x2540,       // Kakariko Village            - Saw Shad's spell 2\nF_0304              = 0x2520,       // Lake Hylia                  - Spoke with Auru at Hylia Lake\nF_0305              = 0x2510,       // Lake Hylia                  - Heard about Fyer from Auru (desert cannon ON)\nF_0306              = 0x2508,       // Desert                      - Used Fyer's cannon to go to desert\nF_0307              = 0x2504,       // Snowpeak mountain           - Spoke with Yeto at top of mountain as wolf\nF_0308              = 0x2502,       // Snowpeak mountain           - Watched first meeting event with Yeto at top of mountain (human)\nF_0309              = 0x2501,       // Castle Town                 - First conversation with Agetha inside (gives golden bug capture quest)\nF_0310              = 0x2680,       // Lake Hylia                  - Hand Auru's note to Fyer\nF_0311              = 0x2640,       // Palace of Twilight          - Palace of Twilight use 1\nF_0312              = 0x2620,       // Palace of Twilight          - Palace of Twilight use 2\nF_0313              = 0x2610,       // Palace of Twilight          - Palace of Twilight use 3\nF_0314              = 0x2608,       // Palace of Twilight          - Palace of Twilight use 4\nF_0315              = 0x2604,       // Palace of Twilight          - Palace of Twilight use 5\nF_0316              = 0x2602,       // Palace of Twilight          - Palace of Twilight use 6\nF_0317              = 0x2601,       // Palace of Twilight          - Palace of Twilight use 7\nF_0318              = 0x2780,       // Palace of Twilight          - Palace of Twilight use 8\nF_0319              = 0x2740,       // Palace of Twilight          - Palace of Twilight use 9\nF_0320              = 0x2720,       // Palace of Twilight          - Palace of Twilight use 10\nF_0321              = 0x2710,       // Castle Town                 - Showed reciept to town doctor\nF_0322              = 0x2708,       // Zora's Domain               - Flow 0010 Spoke with Zora in Zora armor\nF_0323              = 0x2704,       // Zora's Domain               - Flow 0020 Spoke with Zora\nF_0324              = 0x2702,       // Zora's Domain               - Flow 0023 Speak with Zora before blowing up magma rock\nF_0325              = 0x2701,       // Zora's Domain               - Flow 0023 Speak with Zora after blowing up magma rock\nF_0326              = 0x2880,       // Palace of Twilight          - Mini-boss defeated flag\nF_0327              = 0x2840,       // Misc.                       - First time warped by Ooccoo Sr.\nF_0328              = 0x2820,       // Ordon Village               - Talk again with Jaggle after finding kids\nF_0329              = 0x2810,       // Ordon Village               - Jaggle brings up shield\nF_0330              = 0x2808,       // Ordon Village               - Meet again with Uli for the first time (first forced conversation)\nF_0331              = 0x2804,       // Ordon Village               - Meet again and talk with Uli after finding kids (1st time)\nF_0332              = 0x2802,       // Ordon Village               - Meet again and talk with Uli after finding kids (2nd time)\nF_0333              = 0x2801,       // Ordon Village               - Uli brings up the sword\nF_0334              = 0x2980,       // Castle Town                 - Spoke with Ashei at Telma's shop after getting master sword\nF_0335              = 0x2940,       // Snowpeak mountain           - Obtained scribble from Ashei at mountain pass\nF_0336              = 0x2920,       // Zora's Domain               - Blew up molten rock bomb\nF_0337              = 0x2910,       // Castle Town                 - Listened to old ladies A/B conversation (wolf / Ralis hint FLOW104)\nF_0338              = 0x2908,       // Secret techniques           - Obtained 1 secret techinques - Shield attack\nF_0339              = 0x2904,       // Secret techniques           - Obtained 2 secret techinques\nF_0340              = 0x2902,       // Secret techniques           - Obtained 3 secret techinques\nF_0341              = 0x2901,       // Secret techniques           - Obtained 4 secret techinques\nF_0342              = 0x2a80,       // Secret techniques           - Obtained 5 secret techinques\nF_0343              = 0x2a40,       // Secret techniques           - Obtained 6 secret techinques\nF_0344              = 0x2a20,       // Secret techniques           - Obtained 7 secret techinques\nF_0345              = 0x2a10,       // Faron Woods                 - Opening 2nd day - lit Coro's pot\nF_0346              = 0x2a08,       // Lake Hylia                  - Turned down Auru's request to go to the desert\nF_0347              = 0x2a04,       // Castle Town                 - Spoke with Ashei after Snowpeak Ruins clear\nF_0348              = 0x2a02,       // Lake Hylia                  - Spoke with Zora soldier in front of Lakebed Temple (before bombing entrance)\nF_0349              = 0x2a01,       // Lake Hylia                  - Spoke with Zora soldier in front of Lakebed Temple (after bombing entrance)\nF_0350              = 0x2b80,       // Kakariko Village            - Showed wood carving doll to Renado\nF_0351              = 0x2b40,       // Hyrule Field                - First meeting with Agether outside (haven't met inside yet) : gives bug even quest\nF_0352              = 0x2b20,       // Hyrule Field                - Second conversation with Agetha (outside)\nF_0353              = 0x2b10,       // Castle Town                 - Conversation with lady complaining about Chudley's shop\nF_0354              = 0x2b08,       // Cutscene                    - [cutscene] Mirror complete\nF_0355              = 0x2b04,       // Castle Town                 - Showed wood carving to village doctor\nF_0356              = 0x2b02,       // Castle Town                 - Spoke with village doctor after Ilia's memories restored\nF_0357              = 0x2b01,       // Death Mountain              - Spoke with Telma's guardian goron after she came back\nF_0358              = 0x2c80,       // Castle Town                 - Spoke with Telma after Ilia's memories restored\nF_0359              = 0x2c40,       // Kakariko Village            - Spoke with Ilia while she's watching over Ralis\nF_0360              = 0x2c20,       // Castle Town                 - Conversation with fortune teller as wolf\nF_0361              = 0x2c10,       // Arbiter's Grounds           - Spun the spinning pillars\nF_0362              = 0x2c08,       // Castle Town                 - Properly spoke with Resistance Rusl again (2nd time)\nF_0363              = 0x2c04,       // Ordon Village               - Stole sword from Rusl in Ordon Village at night (wolf)\nF_0364              = 0x2c02,       // Faron Woods                 - Listened to monkey girl's laments (Twilight)\nF_0365              = 0x2c01,       // Death Mountain (room)       - Spoke with Gor Liggs after LV dungeon clear\nF_0366              = 0x2d80,       // Death Mountain (room)       - Spoke with Gor Liggs after Ilia's memories restored\nF_0367              = 0x2d40,       // Death Mountain              - Spoke with goron blocking mountain path after Goron Mines clear\nF_0368              = 0x2d20,       // Kakariko Village            - First conversation wtih goron in front of hotel\nF_0369              = 0x2d10,       // Kakariko Village            - First conversation with goron in front of watch tower\nF_0370              = 0x2d08,       // Kakariko Village            - First converstaion with Karakiko springs goron (adult)\nF_0371              = 0x2d04,       // Kakariko Village            - First conversation wtih goron in front of bomb shop (while only selling bombs)\nF_0372              = 0x2d02,       // Ordon Village               - Tried to by milk before saving cat\nF_0373              = 0x2d01,       // Death Mountain              - Coversation with Darbus after Ilia's memories restored\nF_0374              = 0x2e80,       // Death Mountain              - Conversation with Darbus in wrestling room after Goron Mines clear\nF_0375              = 0x2e40,       // Kakariko Village            - First conversation with fundraising goron at Malo Mart\nF_0376              = 0x2e20,       // Kakariko Village            - Gathered funds for bridge repair! (set by program after raising funds)\nF_0377              = 0x2e10,       // Castle Town                 - Goron spring water shop open!\nF_0378              = 0x2e08,       // Hyrule Field                - Darbus destroyed hidden village boulder\nF_0379              = 0x2e04,       // N/A                         - Completed golden bugs\nF_0380              = 0x2e02,       // N/A                         - Complete first meeting with Agetha (Recieved bug collection quest)\nF_0381              = 0x2e01,       // Castle Town                 - First conversation with parent goron after spring water shop opens\nF_0382              = 0x2f80,       // Castle Town                 - Listened to laments of fallen goron (while bridge broken)\nF_0383              = 0x2f40,       // Castle Town                 - Spoke with child goron after spring water shop opens\nF_0384              = 0x2f20,       // Castle Town                 - Spring water shop - Spoke with child goron while shop closed\nF_0385              = 0x2f10,       // Kakariko Village            - First conversation with Barnes after stocking water bombs\nF_0386              = 0x2f08,       // Kakariko Village            - Conversation with Barnes after he starts selling Bomblings and landmines\nF_0387              = 0x2f04,       // Castle Town                 - Learned scent of medicine\nF_0388              = 0x2f02,       // Kakariko Village            - Graveyard - Spoke with Ralis after changing scene (before obtaining earrings)\nF_0389              = 0x2f01,       // Hyrule Field                - First conversation with goron digging hole in south\nF_0390              = 0x3080,       // Castle Town                 - First conversation after saving Jovani\nF_0391              = 0x3040,       // Hyrule Field                - Gave spring water to goron south of castle town\nF_0392              = 0x3020,       // Hyrule Field                - spoke with goron digging hole after opening caslt town south road\nF_0393              = 0x3010,       // Castle Town                 - First conversation at Poe shop (generic Poe appearance)\nF_0394              = 0x3008,       // Goron Mines                 - Received first key from chibi elder (204)\nF_0395              = 0x3004,       // Kakariko Village            - First conversation with Gor Liggs in Kakariko Village\nF_0396              = 0x3002,       // Kakariko Village            - Failed to carry hot spring water (speak with elder to reset)\nF_0397              = 0x3001,       // Kakariko Village            - Gor Liggs conversation sequence B\nF_0398              = 0x3180,       // Kakariko Village            - Gor Liggs conversation sequence C\nF_0399              = 0x3140,       // Kakariko Village            - Conversation with Gor Liggs - hot spring game available\nF_0400              = 0x3120,       // Kakariko Village            - Warped sky cannon to Lake Hylia\nF_0401              = 0x3110,       // Misc.                       - Beetle (M)\nF_0402              = 0x3108,       // Misc.                       - Beetle (F)\nF_0403              = 0x3104,       // Misc.                       - Butterfly (M)\nF_0404              = 0x3102,       // Misc.                       - Butterfly (F)\nF_0405              = 0x3101,       // Misc.                       - Stag beetle (M)\nF_0406              = 0x3280,       // Misc.                       - Stag beetle (F)\nF_0407              = 0x3240,       // Misc.                       - Grasshopper (M)\nF_0408              = 0x3220,       // Misc.                       - Grasshopper (F)\nF_0409              = 0x3210,       // Misc.                       - Phasmid (M)\nF_0410              = 0x3208,       // Misc.                       - Phasmid (F)\nF_0411              = 0x3204,       // Misc.                       - Pill bug (M)\nF_0412              = 0x3202,       // Misc.                       - Pill bug (F)\nF_0413              = 0x3201,       // Misc.                       - Mantis (M)\nF_0414              = 0x3380,       // Misc.                       - Mantis (F)\nF_0415              = 0x3340,       // Misc.                       - Ladybug (M)\nF_0416              = 0x3320,       // Misc.                       - Ladybug (F)\nF_0417              = 0x3310,       // Misc.                       - Snail (M)\nF_0418              = 0x3308,       // Misc.                       - Snail (F)\nF_0419              = 0x3304,       // Misc.                       - Dragonfly (M)\nF_0420              = 0x3302,       // Misc.                       - Dragonfly (F)\nF_0421              = 0x3301,       // Misc.                       - Ant (M)\nF_0422              = 0x3480,       // Misc.                       - Ant (F)\nF_0423              = 0x3440,       // Misc.                       - Dayfly (M)\nF_0424              = 0x3420,       // Misc.                       - Dayfly (F)\nF_0425              = 0x3410,       // Misc.                       - [Captured in bottle] Beetle (M)\nF_0426              = 0x3408,       // Misc.                       - [Captured in bottle] Beetle (F)\nF_0427              = 0x3404,       // Misc.                       - [Captured in bottle] Butterfly (M)\nF_0428              = 0x3402,       // Misc.                       - [Captured in bottle] Butterfly (F)\nF_0429              = 0x3401,       // Misc.                       - [Captured in bottle] Stag beetle (M)\nF_0430              = 0x3580,       // Misc.                       - [Captured in bottle] Stag beetle (F)\nF_0431              = 0x3540,       // Misc.                       - [Captured in bottle] Grasshopper (M)\nF_0432              = 0x3520,       // Misc.                       - [Captured in bottle] Grasshopper (F)\nF_0433              = 0x3510,       // Misc.                       - [Captured in bottle] Phasmid (M)\nF_0434              = 0x3508,       // Misc.                       - [Captured in bottle] Phasmid (F)\nF_0435              = 0x3504,       // Misc.                       - [Captured in bottle] Pill bug (M)\nF_0436              = 0x3502,       // Misc.                       - [Captured in bottle] Pill bug (F)\nF_0437              = 0x3501,       // Misc.                       - [Captured in bottle] Mantis (M)\nF_0438              = 0x3680,       // Misc.                       - [Captured in bottle] Mantis (F)\nF_0439              = 0x3640,       // Misc.                       - [Captured in bottle] Ladybug (M)\nF_0440              = 0x3620,       // Misc.                       - [Captured in bottle] Ladybug (F)\nF_0441              = 0x3610,       // Misc.                       - [Captured in bottle] Snail (M)\nF_0442              = 0x3608,       // Misc.                       - [Captured in bottle] Snail (F)\nF_0443              = 0x3604,       // Misc.                       - [Captured in bottle] Dragonfly (M)\nF_0444              = 0x3602,       // Misc.                       - [Captured in bottle] Dragonfly (F)\nF_0445              = 0x3601,       // Misc.                       - [Captured in bottle] Ant (M)\nF_0446              = 0x3780,       // Misc.                       - [Captured in bottle] Ant (F)\nF_0447              = 0x3740,       // Misc.                       - [Captured in bottle] Dayfly (M)\nF_0448              = 0x3720,       // Misc.                       - [Captured in bottle] Dayfly (F)\nF_0449              = 0x3710,       // Kakariko Village            - Talk with Gor Liggs again - first time after talking iwth Hot spring water parent goron (before fundraising)\nF_0450              = 0x3708,       // Castle Town                 - Double Clawshot shop final stage first conversation\nF_0453              = 0x3704,       // Hyrule Field                - Postman first appears\nF_0454              = 0x3702,       // Goron Mines                 - Recieved 3rd key from fundraising elder (206)\nF_0455              = 0x3701,       // Goron Mines                 - Recieved 3rd key from fundraising elder (205)\nF_0456              = 0x3880,       // Castle Town                 - First time meeting with Jovani\nF_0457              = 0x3840,       // Castle Town                 - Revived cat\nF_0458              = 0x3820,       // Castle Town                 - Coversation with Jovani after collecting 60 ghosts\nF_0459              = 0x3810,       // Castle Town                 - Coversation with Gengle after collecting 40 ghosts\nF_0460              = 0x3808,       // Castle Town                 - Coversation with Gengle after collecting 50 ghosts\nF_0461              = 0x3804,       // Fishing Pond                - First time entered fishing house\nF_0462              = 0x3802,       // Fishing Pond                - Reserved for fishing\nF_0463              = 0x3801,       // Fishing Pond                - Reserved for fishing\nF_0464              = 0x3980,       // Fishing Pond                - Reserved for fishing\nF_0465              = 0x3940,       // Fishing Pond                - Reserved for fishing\nF_0466              = 0x3920,       // Fishing Pond                - Reserved for fishing\nF_0467              = 0x3910,       // Fishing Pond                - N/A\nF_0468              = 0x3908,       // Fishing Pond                - Reserved for fishing\nF_0469              = 0x3904,       // Fishing Pond                - Reserved for fishing\nF_0470              = 0x3902,       // Fishing Pond                - Reserved for fishing\nF_0471              = 0x3901,       // Ordon Village               - Finished 2 wrestling matches against Bo\nF_0472              = 0x3a80,       // Secret techniques           - Distant howling complete (for secret technique 2)\nF_0473              = 0x3a40,       // Secret techniques           - Distant howling complete (for secret technique 3)\nF_0474              = 0x3a20,       // Secret techniques           - Distant howling complete (for secret technique 4)\nF_0475              = 0x3a10,       // Secret techniques           - Distant howling complete (for secret technique 5)\nF_0476              = 0x3a08,       // Secret techniques           - Distant howling complete (for secret technique 6)\nF_0477              = 0x3a04,       // Secret techniques           - Distant howling complete (for secret technique 7)\nF_0478              = 0x3a02,       // Zora's Domain               - Spoke to Ralis who returned to Zora's domain\nF_0479              = 0x3a01,       // Kakariko Village            - First conversation with Ralis in front of grave\nF_0480              = 0x3b80,       // Kakariko Village            - Received Coral Earrings from Ralis\nF_0481              = 0x3b40,       // Snowpeak Mountain           - Beat Yeta at snowboard first time\nF_0482              = 0x3b20,       // N/A                         - After beating Yeto, first conversation with Yeta at peak (challenged to a match)\nF_0483              = 0x3b10,       // Snowpeak Mountain           - First beat Yeta at snowboard (heart piece)\nF_0484              = 0x3b08,       // Lake Hylia                  - Completed sky canon repairs!\nF_0485              = 0x3b04,       // Lake Hylia                  - Heard Fyer talk about repairs 1 time\nF_0486              = 0x3b02,       // Kakariko Village            - Spoke with Luda while Ralis is visiting graveyard\nF_0487              = 0x3b01,       // Kakariko Village            - Spoke with Luda after Ralis returns home\nF_0488              = 0x3c80,       // Kakariko Village            - Conversation with goron in front of bomb shop - underwater bomb appears\nF_0489              = 0x3c40,       // Kakariko Village            - Conversation with goron in front of bomb shop - all bomb types appear\nF_0490              = 0x3c20,       // Ordon Village               - Spoke with cucco (thinks Link will eat him)\nF_0491              = 0x3c10,       // Goron Mines                 - Spoke with mini-boss (magnet goron) after Goron Mines clear\nF_0492              = 0x3c08,       // Secret techniques           - Gold wolf disappearance 2\nF_0493              = 0x3c04,       // Secret techniques           - Gold wolf disappearance 3\nF_0494              = 0x3c02,       // Secret techniques           - Gold wolf disappearance 4\nF_0495              = 0x3c01,       // Secret techniques           - Gold wolf disappearance 5\nF_0496              = 0x3d80,       // Secret techniques           - Gold wolf disappearance 6\nF_0497              = 0x3d40,       // Secret techniques           - Gold wolf disappearance 7\nF_0498              = 0x3d20,       // Kakariko Village            - Spoke with Beth after Lalis is revived\nF_0499              = 0x3d10,       // Zora's Domain               - Saved magma goron\nF_0500              = 0x3d08,       // Ordon Village               - Met Uli before finding kids (look at sleeping Rusl)\nF_0501              = 0x3d04,       // sub-dungeon                 - Cave of Ordeals - B10 first arrival\nF_0502              = 0x3d02,       // sub-dungeon                 - Cave of Ordeals - B20 first arrival\nF_0503              = 0x3d01,       // sub-dungeon                 - Cave of Ordeals - B30 first arrival\nF_0504              = 0x3e80,       // sub-dungeon                 - Cave of Ordeals - B40 first arrival\nF_0505              = 0x3e40,       // sub-dungeon                 - Cave of Ordeals - B50 first arrival (clear)\nF_0506              = 0x3e20,       // N/A                         - Only met Ooccoo Sr. - not yet son (shared Forest - Snowpeak)\nF_0507              = 0x3e10,       // N/A                         - Also met the son in dungeon with first Ooccoo Sr. meeting - turns 506 OFF (shared Forest - Snowpeak)\nF_0508              = 0x3e08,       // Ooccoo Sr. stuff            - Meb Ooccoo Sr. B - doesnt turn OFF (shared Forest - Snowpeak)\nF_0509              = 0x3e04,       // Ooccoo Sr. stuff            - Met Ooccoo Sr. second time\nF_0510              = 0x3e02,       // City in the Sky             - Watched City in the Sky start cutscene\nF_0513              = 0x3e01,       // Kakariko Village            - Spoke with Colin when neither Ilia nor Ralis are doing well\nF_0514              = 0x3f80,       // Kakariko Village            - Spoke with Colin after Ralis is revived but before Ilia is revived\nF_0515              = 0x3f40,       // Kakariko Village            - Spoke with Colin after Ilia and Ralis are revived\nF_0516              = 0x3f20,       // Ordon Village               - Told Uli directly about having found kids\nF_0517              = 0x3f10,       // Ordon Village               - Had normal conversation 1 with Uli after finding kids (before Colin kidnapped)\nF_0518              = 0x3f08,       // Ordon Village               - Colin kidnapped ~ Heard about giving letter to Colin from sleeping Uli\nF_0519              = 0x3f04,       // Ordon Village               - Spoke with Juggle after finding children\nF_0520              = 0x3f02,       // Ordon Village               - Spoke with Sera after finding children\nF_0521              = 0x3f01,       // Ordon Village               - Spoke with Sera across the counter after finding children (her script is shortened after this)\nF_0522              = 0x4080,       // Faron Woods                 - Heard about Sacred Grove from saved monkey girl\nF_0523              = 0x4040,       // Ordon Village               - Spoke with Hanch before finding children\nF_0524              = 0x4020,       // Ordon Village               - Spoke with Hanch after finding children\nF_0525              = 0x4010,       // Lake Hylia                  - First conversation with underwater Zora bomb seller\nF_0526              = 0x4008,       // Cutscene                    - [Cutscene: 23] Midna reveals her true form\nF_0527              = 0x4004,       // Faron Woods                 - Refused Resistance Rusl's request\nF_0528              = 0x4002,       // Faron Woods                 - Resistance Rusl summoned golden cucco\nF_0529              = 0x4001,       // Castle Town                 - Spoke with Rusl after clearing Temple of Time dungion\nF_0530              = 0x4180,       // Ordon Village               - Spoke with Pergie after finding children\nF_0531              = 0x4140,       // Ordon Village               - Spoke with Pergie while children are kidnapped\nF_0532              = 0x4120,       // Ordon Village               - Pergie butts in about a shield\nF_0533              = 0x4110,       // Ordon Village               - Spoke with Fado after finding children\nF_0534              = 0x4108,       // Ordon Village               - Spoke with Fado before finding children\nF_0535              = 0x4104,       // Zora's Domain               - Spoke with goron in water after recieving reward (bomb bag)\nF_0536              = 0x4102,       // Zora's Domain               - Spoke with goron in water before recieving reward\nF_0537              = 0x4101,       // Faron Woods                 - Had Coro and wolf conversation\nF_0538              = 0x4280,       // City in the Sky             - Spoke with sky person Oocoo Sr. after clearing City in the Sky\nF_0539              = 0x4240,       // Ordon Village               - Receieved heart piece from Fado for mountain goat chase\nF_0540              = 0x4220,       // Faron Woods                 - Heard hint from Midna right after first portal warp\nF_0541              = 0x4210,       // N/A                         - N/A\nF_0542              = 0x4208,       // Cutscene                    - [Cutscene] Hyrule Castle barrier disappears (Midna goes crazy)\nF_0543              = 0x4204,       // Faron Woods                 - Met Resistance Rusl again in the woods\nF_0544              = 0x4202,       // Faron Woods                 - Watched cutscene of monkey girl running away after being attacked by puppet\nF_0545              = 0x4201,       // Sacred Grove                - Watched cutscene of Ooccoo Sr. parting (after Temple of Time)\nF_0546              = 0x4380,       // Castle Town                 - East - Spoke with soldier in front of east gate about light (while bridge is broken)\nF_0547              = 0x4340,       // Castle Town                 - conversation with Jovani after collecting 40 ghosts\nF_0548              = 0x4320,       // Ordon Village               - Opening 3rd day - spoke with Jaggle\nF_0549              = 0x4310,       // Castle Town                 - Heard old lady A, B, soldier set (talking about water) (when there's no water)\nF_0550              = 0x4308,       // Main Event                  - Gain ability to use sense\nF_0551              = 0x4304,       // Palace of Twilight          - Palace of Twilight control use 1\nF_0552              = 0x4302,       // Palace of Twilight          - Palace of Twilight control use 2\nF_0553              = 0x4301,       // Palace of Twilight          - Palace of Twilight control use 3\nF_0554              = 0x4480,       // Palace of Twilight          - Palace of Twilight control use 4\nF_0555              = 0x4440,       // Palace of Twilight          - Palace of Twilight control use 5\nF_0556              = 0x4420,       // Palace of Twilight          - Palace of Twilight control use 6\nF_0557              = 0x4410,       // Palace of Twilight          - Palace of Twilight control use 7\nF_0558              = 0x4408,       // Palace of Twilight          - Palace of Twilight control use 8\nF_0559              = 0x4404,       // Palace of Twilight          - Palace of Twilight control use 9\nF_0560              = 0x4402,       // Palace of Twilight          - Palace of Twilight control use 10\nF_0561              = 0x4401,       // Palace of Twilight          - Palace of Twilight control use 11\nF_0562              = 0x4580,       // Palace of Twilight          - Palace of Twilight control use 12\nF_0563              = 0x4540,       // Misc.                       - Brought back Gengle (after getting 50 souls, dealt with by program)\nF_0564              = 0x4520,       // Castle Town                 - Heard story from solder at Telma's shop (during Twilight)\nF_0565              = 0x4510,       // N/A                         - 2nd Day Complete\nF_0566              = 0x4508,       // Ooccoo Sr. stuff            - Letter from Ooccoo Sr. came in OK (no son)\nF_0567              = 0x4504,       // Ooccoo Sr. stuff            - Letter from Ooccoo Sr. came in OK (yes son)\nF_0568              = 0x4502,       // Zora's River                - Broke Iza's pots (first offence)\nF_0569              = 0x4501,       // Zora's River                - Compensation demands from Iza (resets if paid)\nF_0570              = 0x4680,       // Palace of Twilight          - Cleared Palace of Twilight\nF_0571              = 0x4640,       // Ordon Village               - Refuse Talo's request (for wooden sword) on 3rd day (first time)\nF_0572              = 0x4620,       // Ordon Village               - Refuse Talo's request (for wooden sword) on 3rd day (again)\nF_0573              = 0x4610,       // Ordon Village               - 1st Day - Fado moves to the farm (disappears from in front of Link's house)\nF_0574              = 0x4608,       // Ordon Ranch                 - 1st Day - Start mountain goat chasing in evening\nF_0575              = 0x4604,       // Ordon Ranch                 - 1st Day - End mountain goat chasing in evening\nF_0576              = 0x4602,       // Ordon Village               - 2nd Day - Spoke with Fado\nF_0577              = 0x4601,       // Ordon Village               - 2nd Day - Retrieved basket from monkey (hit hawk)\nF_0578              = 0x4780,       // Ordon Village               - Spoke to Beth on 3rd day\nF_0579              = 0x4740,       // Ordon Village               - Opening (2nd day) First time talking with Hanch before being attacked by bees\nF_0580              = 0x4720,       // Ordon Village               - 1st Day - Blew on Epona's reed whistle at Ordon Spring\nF_0581              = 0x4710,       // Ordon Village               - 2nd Day - First time calling the hawk using the grass whistle\nF_0582              = 0x4708,       // Ordon Woods                 - 1st Day - spoke to Ilia before blowing the reed whistle\nF_0583              = 0x4704,       // Ordon Woods                 - 1st day - Spoke to Ilia after blowing the reed whistle\nF_0584              = 0x4702,       // Ordon Village               - 1st Day - spoke to Rusl\nF_0585              = 0x4701,       // Ordon Village               - 1st day - Spoke to Bo\nF_0586              = 0x4880,       // Ordon Village               - Spoke to Bo after defeating mountain goat\nF_0587              = 0x4840,       // Ordon Village               - successfully defeated rampaging mountain goat\nF_0588              = 0x4820,       // Ordon Village               - First time letting rampaging mountain goat escape\nF_0589              = 0x4810,       // Ordon Village               - Sera - spoke on first day\nF_0590              = 0x4808,       // Ordon Village               - 2nd Day - Spoke to Malo during Talo's disappearance  (after getting lantern)\nF_0591              = 0x4804,       // Ordon Woods                 - 2nd Day - Spoke to Malo right after Talo disappears\nF_0592              = 0x4802,       // Ordon Village               - 2nd Day - Spoke with Beth during Talo's disappearance (after getting lantern)\nF_0593              = 0x4801,       // Ordon Woods                 - 2nd Day - Conversation with Beth right after Talo's disappearance\nF_0594              = 0x4980,       // Ordon Village               - 2nd Day - Colin (conversation after receiving lantern from Coro)\nF_0595              = 0x4940,       // Ordon Village               - 2nd Day - Conversation with Colin after sword tutorial and after horse rejection\nF_0596              = 0x4920,       // Ordon Village               - 2nd Day - Conversation with Colin after sword tutorial, before horse rejection\nF_0597              = 0x4910,       // Ordon Village               - 2nd Day - First time speaking with Bo (after successfully defeating mountain goat)\nF_0598              = 0x4908,       // Ordon Village               - 2nd Day - First conversation with Bo\nF_0599              = 0x4904,       // Ordon Village               - 2nd Day - tried to enter Bo's house\nF_0600              = 0x4902,       // Ordon Village               - Purchase slingshot\nF_0601              = 0x4901,       // Faron Woods                 - Spoke to imprisoned Talo\nF_0606              = 0x4a08,       // Sacred Grove                - Giants switched places\nF_0607              = 0x4a04,       // Ordon Village               - Quit Slingshot tutorial\nF_0608              = 0x4a02,       // Ordon Village               - Began Slingshot tutorial\nF_0609              = 0x4a01,       // Ordon Village               - Slingshot Tutorial - First time hitting scarcrow torso\nF_0610              = 0x4b80,       // Ordon Village               - Slingshot Tutorial - Hit it without using focus\nF_0611              = 0x4b40,       // Ordon Village               - Slingshot Tutorial - Hit it using focusing\nF_0612              = 0x4b20,       // Ordon Village               - Pachinco Tutorial - Spoke before hitting target\nF_0613              = 0x4b10,       // Ordon Village               - Slingshot Tutorial - Spoke before getting 2 scarecrow heards\nF_0614              = 0x4b08,       // Ordon Village               - 2nd Day - Heard forced conversation immediately after the slignshot tutorial\nF_0615              = 0x4b04,       // Lake Hylia                  - Recieved vessel of light from Lanayru spirit\nF_0616              = 0x4b02,       // Ordon Village               - 3rd Day - Spoke to Talo/Malo after handing over wooden sword (1st time)\nF_0617              = 0x4b01,       // Ordon Village               - 3rd Day - Spoke to Talo/Malo after handing over wooden sword (2nd time)\nF_0618              = 0x4c80,       // Ordon Village               - Scooped bee larva into bottle on opening 2nd Day\nF_0619              = 0x4c40,       // Lake Hylia                  - Spoke to Zora soldier (near cannon) in Lake Hylia\nF_0620              = 0x4c20,       // Zora's Domain               - First caught a Reek Fish\nF_0621              = 0x4c10,       // Ordon Village               - Spoke to Hanch on 3rd day (knocked down beehive on 2nd day)\nF_0622              = 0x4c08,       // Ordon Village               - Opening 2nd day: Spoke to Hanch before being attacked by bees\nF_0623              = 0x4c04,       // Ordon Village               - Opening 3rd day: Spoke to Hanch before being attacked by bees\nF_0624              = 0x4c02,       // Ordon Village               - 3rd day: Warned by Hanch when climbing vines\nF_0625              = 0x4c01,       // Faron Woods                 - Saved Talo and a monkey\nF_0626              = 0x4d80,       // Castle Town                 - Received a heart piece from Jovani\nF_0627              = 0x4d40,       // Castle Town                 - Spoke with Jovani at the bar\nF_0628              = 0x4d20,       // Castle Town                 - Received 200 Rupees from Gengle\nF_0629              = 0x4d10,       // Castle Town                 - First conversation iwth Gengle after speaking with Jovani at the bar\nF_0630              = 0x4d08,       // Cutscene                    - (Cutscene 4 - ?) Right after Link is captured (wolf)\nF_0631              = 0x4a80,       // Fishing Pond (inside)       - Heard when zooming in on fish tank (1)\nF_0632              = 0x4d04,       // Fishing Pond (inside)       - Heard first time zooming in on fish tank (2)\nF_0633              = 0x4d02,       // Fishing Pond (inside)       - Heard second time zooming in on fish tank (2)\nF_0634              = 0x4d01,       // Fishing Pond (inside)       - Heard zooming in on lure (no frog)\nF_0635              = 0x4e80,       // Fishing Pond (inside)       - Heard zooming in on lure (yes frog)\nF_0636              = 0x4e40,       // Fishing Pond (inside)       - Heard first time zooming in on frog lure\nF_0637              = 0x4e20,       // Fishing Pond (inside)       - Cleard all of roll goal game (get frog lure)\nF_0638              = 0x4e10,       // Fishing Pond (inside)       - Heard first time zooming in on canoe\nF_0639              = 0x4e08,       // Fishing Pond (inside)       - Heard first time zooming in on hat\nF_0640              = 0x4e04,       // Fishing Pond (inside)       - Heard first time zooming in on pot\nF_0641              = 0x4e02,       // Fishing Pond (inside)       - Heard First time zooming in on rug\nF_0642              = 0x4e01,       // Fishing Pond (inside)       - Heard first time zooming in on book\nF_0643              = 0x4f80,       // Fishing Pond (inside)       - Heard first time zooming in on old man's photo\nF_0644              = 0x4f40,       // Fishing Pond (inside)       - Heard first time zooming in on Coro's photo\nF_0645              = 0x4f20,       // Fishing Pond (inside)       - Heard First time zoomin in on Iza's photo\nF_0646              = 0x4f10,       // Fishing Pond (inside)       - Heard first time zooming in on Hena's photo\nF_0647              = 0x4f08,       // Fishing Pond (inside)       - Heard second time zooming in on Hena's photo\nF_0648              = 0x4f04,       // Fishing Pond (inside)       - Heard Hena's photo 1,2 (additional story)\nF_0649              = 0x4f02,       // Fishing Pond (inside)       - Heard first time zooming in on Link's picture\nF_0650              = 0x4f01,       // Fishing Pond (inside)       - Heard second time zooming in on Link's picture\nF_0651              = 0x5080,       // Fishing Pond                - Caught Greengill with bobber first time\nF_0652              = 0x5040,       // Fishing Pond                - Caught Hylian Bass with bobber first time\nF_0653              = 0x5020,       // Fishing Pond                - Caught Hylian Pike with bobber first time\nF_0654              = 0x5010,       // Fishing Pond                - Caught Hylian Loach using bobber first time\nF_0655              = 0x5008,       // Fishing Pond                - Caught an Ordon Catfish using bobber first time\nF_0656              = 0x5004,       // Fishing Pond                - Caught something (any fish) using lure first time\nF_0657              = 0x5002,       // Fishing Pond                - Caught Hylian Loach in front of Hena first time\nF_0658              = 0x5001,       // Castle Town                 - Recieved large wallet from Agitha\nF_0659              = 0x5180,       // Castle Town                 - Hear information about spirit spring in Lake Hylia from Twilight Soldier or map\nF_0660              = 0x5140,       // Lake Hylia                  - Twilight Lake Hylia Listened to Zora soldier A talk\nF_0661              = 0x5120,       // Lake Hylia                  - Twilight Lake Hylia Listened to Zora soldier B&C talk\nF_0662              = 0x5110,       // Fishing Pond (inside)       - Omit rules after clearing roll goal game once\nF_0663              = 0x5108,       // Fishing Pond (inside)       - Listened to Purdy's unnecessary words\nF_0664              = 0x5104,       // Fishing Pond (inside)       - After clearing roll goal game / first attempt\nF_0665              = 0x5102,       // Fishing Pond (inside)       - First zoom in Roll goal game\nF_0666              = 0x5101,       // Zora's Domain               - Showed Yeto sketch to Zora soldier next to Snowpeak Mountain\nF_0667              = 0x5280,       // Zora's Domain               - Showed Yeto sketch to average Zora soldier (generic)\nF_0668              = 0x5240,       // Zora's Domain               - Showed Yeto sketch to Zora civilian (generic)\nF_0669              = 0x5220,       // Goron Mines                 - Pulled on Fyrus chains at least once\nF_0670              = 0x5210,       // Goron Mines                 - Hitting knocked-down Fyrus\nF_0671              = 0x5208,       // Goron Mines                 - Through magnet goron into lava once\nF_0672              = 0x5204,       // Goron Mines                 - First time seeing magnet goron tumbling\nF_0673              = 0x5202,       // Goron Mines                 - Heard hint about Fyrus's weakness (F0215)\nF_0674              = 0x5201,       // Castle Town                 - Light - Spoke with cafe table: townsperson A1\nF_0675              = 0x5380,       // Castle Town                 - Light - cafe counter: Spoke with townsgirl A1 (shop clerk)\nF_0676              = 0x5340,       // Castle Town                 - Light - Spoke with Cafe customer: Townsperson F1 (just the man)\nF_0677              = 0x5320,       // Castle Town                 - Light - Spoke with Cafe customer B: Townsperson D1 and Man B1\nF_0678              = 0x5310,       // Castle Town                 - Spoke with Group A (Town girl C2, Boy B1, Town girl D1) in front of fountain\nF_0679              = 0x5308,       // Fishing Pond (inside)       - Cheated during Roll goal game\nF_0680              = 0x5304,       // Arbiter's Grounds           - Heard Midna's hint after cutscene of ghost escaping\nF_0681              = 0x5302,       // Arbiter's Grounds           - Heard Midna's hint after defeating first ghost\nF_0682              = 0x5301,       // City in the Sky             - First conversation with Oocca Shopkeeper\nF_0683              = 0x5480,       // Castle Town                 - Spoke with Group B (Old lady A1, Boy A1, Town girl B1) in central square\nF_0684              = 0x5440,       // Temple of Time              - Look at R00 statue using sense\nF_0685              = 0x5420,       // Cutscene                    - (Cutscene 32) Sage appears, get first Mirror of Twilight shard\nF_0686              = 0x5410,       // Palace of Twilight          - Get fused shadow piece (final mask)\nF_0687              = 0x5408,       // Castle Town                 - Spoke with town girl D1 in front of south road hot spring shop (CLOSED)\nF_0688              = 0x5404,       // Castle Town                 - Spoke with town girl D1 in front of south road hot spring shop (OPEN)\nF_0689              = 0x5402,       // Castle Town                 - South Road - Spoke with meat shop villager man C1\nF_0690              = 0x5401,       // Castle Town                 - South Road - Spoke with woman A1 in front of fortune teller's shop\nF_0691              = 0x5580,       // Castle Town                 - Spoke with south alley children before guarding carriage\nF_0692              = 0x5540,       // Castle Town                 - Spoke with south alley children after guarding carriage\nF_0693              = 0x5520,       // Lake Hylia                  - First conversation with Plumm while human\nF_0694              = 0x5510,       // Castle Town                 - Conversation with Jovani after collecting 20 ghosts\nF_0695              = 0x5508,       // Fishing Pond                - First time frog lure slips out\nF_0696              = 0x5504,       // Castle Town                 - Spoke with inquiring Hyrule guard before saving Jovani\nF_0697              = 0x5502,       // N/A                         - Spoke with inquiring Hyrule guard after saving Jovani\nF_0698              = 0x5501,       // Castle Town                 - Spoke with woman B1 in front of south vegetable stand (before guarding carriage)\nF_0699              = 0x5680,       // Castle Town                 - Spoke with woman B1 in front of south vegetable stand (after guarding carriage)\nF_0700              = 0x4a40,       // N/A                         - First day ends\nF_0700B             = 0x5640,       // Castle Town                 - South Vegetable vendor - Spoke with Villager D2 (before guarding carriage)\nF_0701              = 0x4a20,       // N/A                         - Talo discovers monkey in Link's house garden\nF_0701B             = 0x5620,       // N/A                         - South Vegetable vendor - Spoke with Villager D2 (after guarding carriage)\nF_0702              = 0x4a10,       // Ordon Village               - Confirmed kidnapped Talo\nF_0702B             = 0x5610,       // Castle Town                 - South Baker - Spoke with Boy A2\nF_0703              = 0x5608,       // Fishing Pond                - Caught Reek fish for first time while fishing\nF_0704              = 0x5604,       // Zora's River                - Listened to Iza in Twilight before domain is thawed\nF_0705              = 0x5602,       // Castle Town                 - First conversation with Kaeru (frog) during Midna's desperate hour\nF_0706              = 0x5601,       // Castle Town                 - First conversation wtih Torako (cat) during Midna's desperate hour\nF_0707              = 0x5780,       // Castle Town                 - Midna's desperate hour, first conversation with Mii (cat)\nF_0708              = 0x5740,       // Castle Town                 - First conversaton with doctor after completing spirit\nF_0709              = 0x5720,       // Castle Town                 - Midna's desperate hour, first conversation wtih Stephanie (cat)\nF_0715              = 0x5710,       // Castle Town                 - Speak with dog to west\nF_0716              = 0x5708,       // Castle Town                 - Speak with dog to the east\nF_0717              = 0x5704,       // Castle Town                 - Wist - Speak to the dog owner\nF_0718              = 0x5702,       // Castle Town                 - South - Spoke to old lady at the vegetable stand (Chudley)\nF_0719              = 0x5701,       // Castle Town                 - South - Spoke to old lady at the vegetable stand (Malo Mart)\nF_0720              = 0x5880,       // Castle Town                 - South - Spoke to fruit stand vendor (before guarding carriage)\nF_0721              = 0x5840,       // Castle Town                 - South - Spoke to fruit stand vendor (after guarding carriage)\nF_0722              = 0x5820,       // Castle Town                 - East - Spoke to man at the T-shaped street\nF_0723              = 0x5810,       // Castle Town                 - East - Spoke to man in the alley\nF_0724              = 0x5808,       // Castle Town                 - East - Spoke to two ladies gossiping\nF_0725              = 0x5804,       // Kakariko Village            - Speak to Renado who is announcing Shad's visit\nF_0726              = 0x5802,       // Zora's River                - Talk to Iza as wolf\nF_0727              = 0x5801,       // Castle Town                 - First conversation with shoe-shine boy\nF_0728              = 0x5980,       // Castle Town                 - Refused entry into Chudley's shop because of dirty shoes\nF_0729              = 0x5940,       // Hyrule Field                - Right after postman's \"Hey!\"\nF_0730              = 0x5920,       // Zora's River                - Rode Iza's boat for the first time\nF_0732              = 0x5910,       // Hidden Village              - Spoke with Cucco (After completing Ilia's memory event)\nF_0733              = 0x5908,       // Zora's River                - Recieved Heart piece reward from Iza for going down the river\nF_0734              = 0x5904,       // Fishing                     - Spoke with wild duck\nF_0735              = 0x5902,       // Fishing                     - Spoke with domestic duck\nF_0736              = 0x5901,       // Forest Temple               - Heard Midna's hint / monkey hint\nF_0737              = 0x5a80,       // Castle Town                 - First conversation with Udo (cat) during Midna's desperate hour\nF_0738              = 0x5a40,       // Castle Town                 - South - Spoke with female customer at vegetable stand\nF_0739              = 0x5a20,       // Castle Town                 - South - Spoke with old customer at fruit stand\nF_0740              = 0x5a10,       // Castle Town                 - Spoke with child Goron (selling lantern oil) (before Hyrule Castle barrier)\nF_0741              = 0x5a08,       // Castle Town                 - Spoke with child Goron (selling lantern oil) (after Hyrule Castle barrier)\nF_0742              = 0x5a04,       // Castle Town                 - Spoke with child Goron (selling red potion)\nF_0743              = 0x5a02,       // Castle Town                 - Spoke with adult Goron (30 arrows) (before Hyrule Castle barrier)\nF_0744              = 0x5a01,       // Castle Town                 - Spoke with adult Goron (30 arrows) (after Hyrule Castle barrier)\nF_0745              = 0x5b80,       // Castle Town                 - Spoke with adult Goron (Hylia shield)\nF_0746              = 0x5b40,       // Kakariko Village            - Spoke with Cucco A\nF_0747              = 0x5b20,       // Kakariko Village            - Spoke with Cucco B\nF_0748              = 0x5b10,       // Hyrule Field                - First conversation with hint hawk\nF_0749              = 0x5b08,       // Hidden Village              - After clearing cat game (Heart piece is buried, whether it is obtained depends on the player)\nF_0750              = 0x5b04,       // Hidden Village              - First conversation with Captain Cucco after beginning cat game activities\nF_0751              = 0x5b02,       // Hidden Village              - Heard detailed explaination from Captain Cucco for the first time\nF_0752              = 0x5b01,       // Hidden Village              - Beat cat game again\nF_0753              = 0x5c80,       // Faron Woods                 - Scooped Coro's bad soup for the first time\nF_0754              = 0x5c40,       // Forest Temple               - Heard Midna's hint / Monkey hint 2 times (SAVE72=ON)\nF_0755              = 0x5c20,       // Zora's River                - Twilight Heard Iza's line right after shadow bug appears\nF_0756              = 0x5c10,       // City in the Sky             - Join with Ooccoo Sr.\nF_0757              = 0x5c08,       // Faron Woods                 - Had Trill and wolf conversation\nF_0758              = 0x5c04,       // Faron Woods                 - Stole from unmanned shop (For use in Trill wolf conversation. Resets after speaking)\nF_0759              = 0x5c02,       // Ordon Village               - Opening (3rd day) first conversation with Sera\nF_0768              = 0x5d40,       // Lake Hylia                  - Heard forced conversation with Midna after Hylia Lake introduction cutscene\nF_0769              = 0x5d20,       // Zora's River                - Forced conversation with Midna right after first arrival at upper Zora's river\nF_0770              = 0x5d10,       // Zora's Domain               - Twilight (frozen) Heard forced conversation after first visit cutscene\nF_0771              = 0x5d08,       // Faron Woods                 - Unmanned Shop : last payment stolen\nF_0772              = 0x5d04,       // Faron Woods                 - Unmanned Shop : last payment too little\nF_0773              = 0x5d02,       // Faron Woods                 - Unmanned Shop : last payment too much\nF_0774              = 0x5d01,       // Zora's Domain               - Listened to Midna's conversation after seeing frozen Zora\nF_0775              = 0x5e80,       // Lake Hylia                  - Heard forced conversation with Midna after first Fyer's cannon\nF_0776              = 0x5e40,       // Palace of Twilight          - Link first turned to wolf due to fog in Palace of Twilight\nF_0777              = 0x5e20,       // Misc.                       - Spoke to Epona\nF_0778              = 0x5e10,       // Faron Woods                 - Heard forced conversation with Midna after story about spirits after clearing Forest Temple\nF_0779              = 0x5e08,       // Lake Hylia                  - Heard one hint from Midna while bridge is burning\nF_0780              = 0x5e04,       // Kakariko Village            - Heard Ilia talk about the messenger from the sky after her memories are restored\nF_0781              = 0x5e02,       // Kakariko Village            - Spoke to Ilia in church after clearing Temple of Time\nF_0782              = 0x5e01,       // Kakariko Village            - Spoke to Renado after Lakebed Temple complete, before Temple of Time complete\nF_0783              = 0x5f80,       // Hidden Village              - Showed dominion rod to Impaz\nF_0784              = 0x5f40,       // Kakariko Village            - Had normal conversation with Shad after he returns to church basement\nF_0785              = 0x5f20,       // Kakariko Village            - Shad leaves after attempting to warp sky cannon\nF_0786              = 0x5f10,       // Kakariko Village            - Forced conversation with Shad when he sees the sky cannon\nF_0787              = 0x5f08,       // Kakariko Village            - Stopped by Midna when trying to warp the sky cannon\nF_0788              = 0x5f04,       // Zora's River                - Talked to Zora going up the waterfall\nF_0789              = 0x5f02,       // Castle Town                 - Grabbed sweet apple 1 time\nF_0790              = 0x5f01,       // Ordon Village               - Sera faces the cat (outside conversation area when 520 is ON)\nF_0791              = 0x6080,       // Sky character               - Sky character 1\nF_0792              = 0x6040,       // Sky character               - Sky character 2\nF_0793              = 0x6020,       // Sky character               - Sky character 3\nF_0794              = 0x6010,       // Sky character               - Sky character 4\nF_0795              = 0x6008,       // Sky character               - Sky character 5\nF_0796              = 0x6004,       // Sky character               - Sky character 6\nF_0797              = 0x6002,       // Lake Hylia                  - Have selected \"Take Cannon / Repair\" at Fyer's cannon (when there's no other business)\nF_0798              = 0x6001,       // Lake Hylia                  - Heard about Zora from Fyer\nF_0799              = 0x6180,       // Hyrule Field                - Listened to the fallen Goron's complaints (after opening bridge)\nF_0800              = 0x6140,       // Cutscene                    - After returning to Ordon Woods, until Midna comes out of the shadows (If 800 is ON, Midna can't be called)\nF_0801              = 0x6120,       // Zora's Domain               - First learned Reek Fish scent\nF_0802              = 0x6110,       // Faron Woods                 - Trill attacks when stealing\nF_0803              = 0x6108,       // Hidden Village              - Talked to Old Lady Impaz after going to Sky\nF_0804              = 0x6104,       // Twilight Hyrule Field       - Heard Midna's forced conversation immediately after plunge into Eldin Twilight\nF_0805              = 0x6102,       // Kakariko Village            - Bought Hylian shield from Malo Mart\nF_0806              = 0x6101,       // Ordon Village               - Talked to Hanch on the first day\nF_0807              = 0x6280,       // Ordon Village               - Talked to Colin on the first day\nF_0808              = 0x6240,       // Ordon Village               - Talked to Beth on the first day\nF_0809              = 0x6220,       // Castle Town                 - 3 groupie girls (first conversation where they become Link's groupies)\nF_0810              = 0x6210,       // Arbiter's Grounds           - Learned ghost's scent\nF_0811              = 0x6208,       // Castle Town                 - Attempted Star Game for the first time\nF_0812              = 0x6204,       // N/A                         - N/A\nF_0813              = 0x6202,       // N/A                         - N/A\nF_0814              = 0x6201,       // N/A                         - N/A\nF_0815              = 0x6380,       // N/A                         - N/A\nF_0816              = 0x6340,       // N/A                         - N/A\nF_0817              = 0x6320,       // N/A                         - N/A\nF_0818              = 0x6310,       // N/A                         - N/A\nF_0819              = 0x6308,       // N/A                         - N/A\nF_0820              = 0x6304,       // N/A                         - N/A\nF_234               = 0x1c08,       // Faron Woods                 - Attacked by Trill\nF_282               = 0x2208,       // Snowpeak mountain           - First conversation with Yeto at peak after Snowpeak Ruins clear\nF_283               = 0x2204,       // Hyrule Field                - Get wood carving\nF_284               = 0x2202,       // Lake Hylia                  - Already have a score recorded for Plumm's game\nF_285               = 0x2201,       // Lake Hylia                  - First conversation with Plumm as wolf\nF_286               = 0x2380,       // Lake Hylia                  - Cleared Plumm's attraction (get heart piece)\nF_287               = 0x2340,       // Kakariko Village            - Handed wood carving to Ilia\nF_288               = 0x2320,       // Cutscene                    - [cutscene: ] Ilia gets her memories back\nF_289               = 0x2310,       // Castle Town                 - Heard conversation about entering Star Game 1\nF_290               = 0x2308,       // Castle Town                 - Star Game 1 cleared\nJ_BTN_GUIDE         = 0x5d80,       // Misc.                       - X-button guide\nKORO2_ALLCLEAR      = 0x6302,       // Fishing                     - After all stages (8-8) of roll goal game cleared\nM_001               = 0x1010,       // Cutscene                    - Opening cutscene\nM_002               = 0x1580,       // Cutscene                    - [cutscene: 2] Met with Ilia (brings horse to spring)\nM_003               = 0x1008,       // Ordon Village               - F0003: Spoke to Colin while he is stopping hors (has fishing rod)\nM_006               = 0x0402,       // Ordon Ranch                 - 3rd day - finished chasing goats, speak to Fado in free state\nM_007               = 0x0401,       // Kakariko Village            - First conversation with Shad in basement (about the words of opening)\nM_008               = 0x0580,       // Cutscene                    - Cutscene - attacked by monsters at Ordon spring\nM_009               = 0x0540,       // Cutscene                    - [cutscene: 6B] Prison escape - Midna rides on back\nM_010               = 0x0520,       // Cutscene                    - [cutscene: 6A] Midna appears in the prison\nM_011               = 0x0510,       // Inside Hyrule Castle        - Midna removes wolf's chains in prison\nM_012               = 0x0508,       // Cutscene                    - [cutscene: 7] Meet Princess Zelda at castle\nM_013               = 0x0504,       // Misc.                       - First heard about Twilight gate from Midna\nM_014               = 0x0502,       // Cutscene                    - [cutscene: 8] First warped from castle by Midna\nM_015               = 0x0501,       // Faron Woods                 - Can use Midna's B charge attack\nM_016               = 0x0680,       // Cutscene                    - [cutscene: 9] Ordon village spirit appears\nM_017               = 0x0640,       // Cutscene                    - [cutscene: 10] Dark Hyrule Forest - Midna again\nM_018               = 0x0620,       // Main Event                  - Brought Kakariko bridge back to original location\nM_019               = 0x0610,       // Cutscene                    - [cutscene: 11] forest spirit revived - Hero's birth\nM_020               = 0x0608,       // Cutscene                    - [cutscene: ] Colin kidnapped : ON once watched\nM_021               = 0x0604,       // Main Event                  - First portal warp\nM_022               = 0x0602,       // Forest Temple               - Forest Temple clear (Midna creates warp hole)\nM_023               = 0x0601,       // Main Event                  - Epona rescued flag\nM_024               = 0x0780,       // Cutscene                    - [cutscene: 16] take back Colin\nM_025               = 0x0740,       // Death Mountain (room)       - First wresting match against fat (elder) goron\nM_026               = 0x0720,       // Ordon Village               - Reunion with Bo (Watched cutscene before wrestle match)\nM_027               = 0x0710,       // Cutscene                    - [cutscene: 13] kids in the church (beast eyes)\nM_028               = 0x0708,       // Cutscene                    - [cutscene: 14] restore mountain spirit - Reuinion with Colin et al.\nM_029               = 0x0704,       // Death Mountain (room)       - Win wrestle match against Gor Coron\nM_030               = 0x0702,       // Death Mountain (room)       - First conversation with Gor Coron\nM_031               = 0x0701,       // Goron Mines                 - Goron Mines clear\nM_032               = 0x0880,       // Main Event                  - Melted Zora river ice with magma rock\nM_033               = 0x0840,       // Main Event                  - Start carriage guarding game\nM_034               = 0x0820,       // Cutscene                    - [cutscene: 19] Reunion with Ilia (After Lakebed Temple?)\nM_035               = 0x0810,       // Cutscene                    - [cutscene: 35] after carriage guarding event\nM_036               = 0x0808,       // Main Event                  - Begin carriage guarding (after joust revenge)\nM_037               = 0x0804,       // Kakariko Village            - Got Zora armor from Zora queen\nM_038               = 0x0802,       // Kakariko Village            - [Bow and arrow game] listen to hawkeye hint\nM_039               = 0x0801,       // Kakariko Village            - [Bow and arrow game] First time talking to Talo\nM_040               = 0x0980,       // Kakariko Village            - [bow and arrow game] Spoke to Talo after completing\nM_041               = 0x0940,       // Kakariko Village            - [Bow and Arrow game] First attempt\nM_042               = 0x0920,       // Kakariko Village            - [Bow and Arrow game] clear\nM_043               = 0x0910,       // Kakariko Village            - [Bow and Arrow game] Complete using Hawkeye\nM_044               = 0x0908,       // Kakariko Village            - [Barnes Bomb Shop] Bought premium pack\nM_045               = 0x0904,       // Lakebed Temple              - Lakebed Temple clear\nM_046               = 0x0902,       // Zora's River                - [Iza river descent] Get advice about boulder blocking river\nM_047               = 0x0901,       // Zora's River                - Iza Twilight - Talked after defeating shadow bugs\nM_048               = 0x0a80,       // Zora's River                - Ran away while clearing rubble at hut\nM_049               = 0x0a40,       // Death Mountain              - Threw first rolling goron at death mountain\nM_050               = 0x0a20,       // Main Event                  - Eldin Bridge disappears\nM_051               = 0x0a10,       // Main Event                  - Shadow Kargorok (?) (Large) event complete (Horse grass appears in various places)\nM_052               = 0x0a08,       // Main Event                  - Horseback battle clear\nM_053               = 0x0a04,       // Main Event                  - Horseback battle cutscene\nM_054               = 0x0a02,       // Main Event                  - Joust / one-on-one battle cutscene\nM_055               = 0x0a01,       // Main Event                  - Did damage at least once during joust/one-on-one battle\nM_056               = 0x0b80,       // Hyrule Field                - Ignored Iza's concerns\nM_057               = 0x0b40,       // Desert                      - View boar cutscene after defeating King Bulblin\nM_058               = 0x0b20,       // Snowpeak Ruins              - First time meeting Yeta (forced converation)\nM_059               = 0x0b10,       // Snowpeak Ruins              - received map from Yeta\nM_060               = 0x0b08,       // Zora's River                - [Iza river descent] // 2nd time running away while clearing rubble in hut\nM_061               = 0x0b04,       // Zora's River                - [Iza river descent] Got explanation for clearing rubble 1 time\nM_062               = 0x0b02,       // Zora's River                - [Iza] Says thanks after night stalker battle\nM_063               = 0x0b01,       // Zora's River                - [Iza river descent] Finish job (First time descending river)\nM_064               = 0x0c80,       // Zora's Domain               - Water returns to Hylia Lake (spoke with Queen Rutela)\nM_065               = 0x0c40,       // Faron Woods                 - Spoke with Faron spirit after clearing Forest Temple\nM_066               = 0x0c20,       // N/A                         - N/A\nM_067               = 0x0c10,       // Main Event                  - Midna riding / not riding (ON == riding)\nM_068               = 0x0c08,       // Main Event                  - when OFF, wolf carries sword and shield on back\nM_069               = 0x0c04,       // Kakariko Village            - First conversation with child goron shop clerk\nM_070               = 0x0c02,       // Cutscene                    - [cutscene: 18] Lanayru spirit restored\nM_071               = 0x0c01,       // Cutscene                    - [cutscene: 20] Zant appears (during Midna's desperate hour)\nM_072               = 0x0d80,       // Ordon Village               - Get wooden shield\nM_073               = 0x0d40,       // Kakariko Village            - Spoke with Renado after guarding carriage [0030]\nM_074               = 0x0d20,       // Kakariko Village            - Spoke with Renado after guarding carriage [0031]\nM_075               = 0x0d10,       // Snowpeak Ruins              - Forced conversation with Yeta after getting bedroom key\nM_076               = 0x0d08,       // Misc.                       - First conversation with Castle Town Malo Mart shop clerk\nM_077               = 0x0d04,       // Main Event                  - Get shadow crystal (can now transform)\nM_078               = 0x0d02,       // Ordon Village               - Spoke with frog A\nM_079               = 0x0d01,       // Ordon Village               - Ordon village night: Heard Z Jump dialogie in Pergie's house\nM_080               = 0x0e80,       // Ordon Village               - Spoke with brown cucco\nM_081               = 0x0e40,       // Death Mountain              - First conversation with Goron that shoots you up (shared with everyone)\nM_082               = 0x0e20,       // Death Mountain              - Spoke with spring Goron A\nM_083               = 0x0e10,       // Lake Hylia                  - Heard Fyer's talk after water restored\nM_084               = 0x0e08,       // Kakariko Village            - Complete sequence of shopping at Malo Mart first time\nM_085               = 0x0e04,       // Twilight Hyrule Field       - Midna dialogue right before Boss Bug's Tear of Light appears\nM_086               = 0x0e02,       // Twilight Hyrule Field       - Show Boss Bug's Tear of Light on the map\nM_087               = 0x0e01,       // Hyrule Field                - Ilia memory event start\nM_088               = 0x0f80,       // Kakariko Village            - Get Renado's Letter\nM_089               = 0x0f40,       // Castle Town                 - First time entering doctor's office (forced conversation)\nM_090               = 0x0f20,       // Castle Town                 - Spoke to town doctor before showing receipt\nM_091               = 0x0f10,       // Kakariko Village            - Buy out fundraiser amount (Malo becomes nice)\nM_092               = 0x0f08,       // Hyrule Field                - Warped Eldin Bridge\nM_093               = 0x0f04,       // Lake Hylia                  - First conversation with Fyer after desert's debut\nM_094               = 0x0f02,       // Zora's River                - First time visiting Rizu's hut after completing river job (forced conversation)\nM_095               = 0x0f01,       // Faron Woods                 - First time meeting Coro (obtain lantern)\nM_096               = 0x1080,       // Ordon Village               - 3rd day: spoke with Pergie\nM_097               = 0x2304,       // Main Event                  - Can use magic\nMAP_VISIBLE         = 0x1d01,       // 2D Map                      - Area map show/hide\nT_0239              = 0x1d40,       // Lake Hylia                  - Spoke with Fyer (start dark carge)\nTEST_001            = 0x0080,       // Faron Woods                 - Kakariko bridge portal warp hint\nTEST_002            = 0x0040,       // Death Mountain              - Big magma stone portal warp hint\nTEST_003            = 0x0020,       // Snowpeak Ruins              - Handed over tomato puree\nTEST_004            = 0x0010,       // Snowpeak Ruins              - Handed over secret ingredient\nKAKERA_GET_INFO_05  = 0xebff,       // Misc.                       - Info about getting heart piece\nKAKERA_GET_INFO_04  = 0xecff,       // Misc.                       - Info about getting heart piece\nKAKERA_GET_INFO_03  = 0xedff,       // Misc.                       - Info about getting heart piece\nKAKERA_GET_INFO_02  = 0xeeff,       // Misc.                       - Info about getting heart piece\nKAKERA_GET_INFO_01  = 0xefff,       // Misc.                       - Info about getting heart piece\nKAKERA_GET_INFO_00  = 0xf0ff,       // Misc.                       - Info about getting heart piece\nSP_LURE__USE_COUNT  = 0xf11f,       // Fishing Pond                - Number of fish caught with sinking lure (Max: 31)\nCF_RECORD_0         = 0xf27f,       // Fishing Pond                - Fishing hut fish tank (Ordon Catfish Size)\nNP_RECORD_0         = 0xf37f,       // Fishing Pond                - Fishing hut fish tank (Hylian Pike Size)\nRI_RECORD_0         = 0xf47f,       // Fishing Pond                - Fishing hut fish tank (Hylian Loach Size)\nLM_RECORD_0         = 0xf57f,       // Fishing Pond                - Fishing hut fish tank (Bass Size)\nKORO2_LEVEL         = 0xf63f,       // Fishing Pond (inside)       - Roll goal game level memory use\nFUND_RAISING_HIGH2  = 0xf7ff,       // Shop                        - Donations top bit\nFUND_RAISING_LOW2   = 0xf8ff,       // Shop                        - Donations bottom bit\nFUND_RAISING_HIGH   = 0xf9ff,       // Shop                        - Fundraising top bit\nFUND_RAISING_LOW    = 0xfaff,       // Shop                        - Fundraising bottom bit\nTOTAL_PAYMENT_LOW   = 0xfbff,       // Shop                        - Unmanned shop payment total top bit (typo maybe? should be bottom bit?)\nTOTAL_PAYMENT_HIGH  = 0xfcff,       // Shop                        - Unmanned shop payment total top bit\nTOTAL_PRICE_LOW     = 0xfdff,       // Shop                        - Unmanned shop total price bottom bit\nTOTAL_PRICE_HIGH    = 0xfeff,       // Shop                        - unmanned shop total price top bit\nEREG_000            = 0xff1f,       // Ranch                       - Rampaging goats number\nUNUSED              = 0xffff,       // N/A                         - Unused? This was the only flag not in the debug table/* end \"d/save/d_save_bit_labels.inc\" */\n    };\n\n    static u16 saveBitLabels[822];\n};\n\nclass dSv_event_tmp_flag_c {\npublic:\n    enum {\n/* \"include/d/save/d_save.h\" line 1165 \"d/save/d_save_temp_bit_labels.inc\" */\n/**\n * d_save_temp_bit_labels.inc\n * Flag labels for dSv_event_tmp_flag_c::tempBitLabels\n *\n * Flag information comes from the debug table in d_event_debug.inc\n *\n */\n\n/* \nName                = Value         // Location                    - Description \n*/\n\nCAT_1               = 0x1180,       // Ordon Village                - 3rd day: Heard results of goat herding\nCAT_2               = 0x1140,       // Ordon Village                - 3rd day: Spoke with Fado after herding goats\nCAT_3               = 0x1120,       // Ordon Village                - 3rd day: Fado's first conversation\nCAT_4               = 0x1110,       // Cat game                     - N/A\nCAT_5               = 0x1108,       // Faron Woods                  - Heard Midna's warning in Twilight fog woods\nCAT_6               = 0x1104,       // Ordon Village                - Entered Uli's room before finding children (ON during forced conversation)\nCAT_7               = 0x1102,       // Cat game                     - N/A\nCAT_8               = 0x1101,       // Cat game                     - N/A\nCAT_9               = 0x1280,       // Cat game                     - N/A\nCAT_10              = 0x1240,       // Cat game                     - N/A\nCAT_11              = 0x1220,       // Sacred Grove                 - Used in Ooccoo Sr. departure event (1)\nCAT_12              = 0x1210,       // Sacred Grove                 - Used in Ooccoo Sr. departure event (2)\nCAT_13              = 0x1208,       // Sacred Grove                 - Used in Ooccoo Sr. departure event (3)\nCAT_14              = 0x1204,       // Sacred Grove                 - Used in Ooccoo Sr. departure event (4)\nCAT_15              = 0x1202,       // Cat game                     - N/A\nCAT_16              = 0x1201,       // Cat game                     - N/A\nCAT_17              = 0x1380,       // Ordon Village                - Used in conversation with Sera's household on first day (1)\nCAT_18              = 0x1340,       // Ordon Village                - Used in conversation with Sera's household on first day (2)\nCAT_19              = 0x1320,       // Cat game                     - N/A\nCAT_20              = 0x1310,       // Cat game                     - N/A\nDUNGEON_130         = 0x0e10,       // Temple of Time               - Heard Midna's hint during mini-boss\nDUNGEON_131         = 0x0e08,       // Unused                       - Dungeon 131\nDUNGEON_132         = 0x0e04,       // Unused                       - Dungeon 132\nDUNGEON_133         = 0x0e02,       // Unused                       - Dungeon 133\nDUNGEON_134         = 0x0e01,       // Unused                       - Dungeon 134\nDUNGEON_135         = 0x0f80,       // Unused                       - Dungeon 135\nDUNGEON_136         = 0x0f40,       // Unused                       - Dungeon 136\nDUNGEON_137         = 0x0f20,       // Unused                       - Dungeon 137\nDUNGEON_138         = 0x0f10,       // Unused                       - Dungeon 138\nDUNGEON_139         = 0x0f08,       // Unused                       - Dungeon 139\nDUNGEON_140         = 0x0f04,       // Unused                       - Dungeon 140\nDUNGEON_141         = 0x0f02,       // Unused                       - Dungeon 141\nDUNGEON_142         = 0x0f01,       // Unused                       - Dungeon 142\nDUNGEON_143         = 0x1080,       // Unused                       - Dungeon 143\nDUNGEON_144         = 0x1040,       // Unused                       - Dungeon 144\nDUNGEON_145         = 0x1020,       // Unused                       - Dungeon 145\nDUNGEON_146         = 0x1010,       // Unused                       - Dungeon 146\nDUNGEON_147         = 0x1008,       // Unused                       - Dungeon 147\nDUNGEON_148         = 0x1004,       // Unused                       - Dungeon 148\nDUNGEON_149         = 0x1002,       // Unused                       - Dungeon 149\nDUNGEON_150         = 0x1001,       // Unused                       - Dungeon 150\nGUARD_URI           = 0x1308,       // Ordon Village                - Rusl is guarding Uli, Ordon village night\nHanch_CLIMBOUT_POND = 0x1304,       // Ordon Village                - Hanch gets out of lake after jumping in\nMN09_02             = 0x0c02,       // Hyrule Castle                - Rusl waves at Link Flag\nMN09_03             = 0x0c01,       // Hyrule Castle                - Auru's cannon hits Flag\nNO_TELOP            = 0x1301,       // General use                  - When on (while changing scenes) stage name is not shown\nNODRAW_STAGE_NAME   = 0x1302,       // General use                  - N/A\nPACHITUTORIAL_CNT   = 0xf4ff,       // Ordon Village                - Slingshot tutorial, number of destroyed targets\nPACHITUTORIAL_INF   = 0xf3ff,       // Ordon Village                - Slingshot tutorial, hit information\nSHA_DBG             = 0xf2ff,       // Castle Town                  - Fortune teller debug\nSHA_LOVEFORTUNE_00  = 0xfaff,       // Castle Town                  - For memory use after love fortune scene change\nSHA_LOVEFORTUNE_01  = 0xf9ff,       // Castle Town                  - For memory use after love fortune scene change\nSHA_LOVEFORTUNE_02  = 0xf8ff,       // Castle Town                  - For memory use after love fortune scene change\nSHA_LOVEFORTUNE_03  = 0xf7ff,       // Castle Town                  - For memory use after love fortune scene change\nSHA_LOVEFORTUNE_04  = 0xf6ff,       // Castle Town                  - For memory use after love fortune scene change\nSHA_LOVEFORTUNE_05  = 0xf5ff,       // Castle Town                  - For memory use after love fortune scene change\nT_0001              = 0x0080,       // Kakariko Village (inside)    - Make successive purchase at Barnes bomb shop\nT_0002              = 0xff0f,       // Ordon Village                - Sword tutorial - step\nT_0003              = 0xfeff,       // Ordon Village                - Sword tutorial - slice count\nT_0004              = 0x0040,       // Ordon Village                - sword tutorial - outcome\nT_0005              = 0xfdff,       // Temp cutscene                - Actual cutscene number delivery\nT_0006              = 0xfcff,       // Temp cutscene                - Return layer number\nT_0007              = 0x0020,       // Ordon Village                - During Uli's pick-up tutorial\nT_0008              = 0x0010,       // Kakariko Village             - Bow and arrow game: shoot target using Hawkeye\nT_0009              = 0x0008,       // Ordon Village                - Walked a bit during Uli's pick-up tutorial\nT_0010              = 0x0004,       // General use                  - General use temporary flag (flow control) A\nT_0011              = 0x0002,       // General use                  - General use temporary flag (flow control) B\nT_0012              = 0x0001,       // General use                  - General use temporary flag (flow control) C\nT_0013              = 0x0180,       // General use                  - General use temporary flag (flow control) D\nT_0014              = 0x0140,       // General use                  - General use temporary flag (flow control) E\nT_0015              = 0x0120,       // Ordon Village                - Link came up the hill afte being called by Jaggle\nT_0016              = 0x0110,       // Ordon Village                - Scold Beth, Talo during sword tutorial\nT_0017              = 0x0108,       // Ordon Village                - Goat herding - first one entered the hut\nT_0018              = 0x0104,       // Ordon Village                - Goat herding - time is almost up\nT_0019              = 0x0102,       // Ordon Village                - Goat herding - time's up\nT_0020              = 0x0101,       // Ordon Village                - Goat herding - ON from `time's up` until `restart`\nT_0021              = 0x0280,       // Ordon Village                - Colin follows to Link's house\nT_0022              = 0x0240,       // Ordon Village                - Uli - carrying baby basket\nT_0023              = 0x0220,       // Ordon Village                - Called Talo, Colin right after sword game\nT_0024              = 0x0210,       // Ordon Village                - To sword tutorial\nT_0025              = 0x0208,       // Ordon Village                - Get on table (Pergie gets mad)\nT_0026              = 0x0204,       // Ordon Village                - Destroy pumpkin near Jaggle (Jaggle gets angry)\nT_0027              = 0x0202,       // Ordon Village                - Rampaging goats complete\nT_0028              = 0x0201,       // Ordon Village                - Right after rampaging goats\nT_0029              = 0x0380,       // Ordon Village                - Succeed at taking Rusl's sword\nT_0030              = 0x0340,       // Ordon Village                - Rusl, Press button to \"take\"\nT_0031              = 0x0320,       // Ordon Village                - Borrow Rusl's sword\nT_0032              = 0x0310,       // Ordon Village                - Return Rusl's sword\nT_0033              = 0x0308,       // Ordon Village                - Press A and up during rampaging goat game\nT_0034              = 0x0304,       // Ordon Village                - Rusl sword failure count 1\nT_0035              = 0x0302,       // Ordon Village                - Rusl sword failure count 2\nT_0036              = 0x0301,       // Ordon Village                - Rusl sword failure count 3\nT_0041              = 0x0420,       // Faron Woods                  - Only ON when Coro is sleeping\nT_0042              = 0x0410,       // Unused                       - Spoke to Coro at night without lantern\nT_0043              = 0x0408,       // Unused                       - N/A\nT_0044              = 0x0404,       // Ordon Village                - For sword tutorial end cutscene\nT_0045              = 0x0402,       // Death Mountain               - Twilight - Talked with Goron C\nT_0046              = 0x0401,       // Ordon Village                - Wrestling with Bo - Link wins\nT_0047              = 0x0580,       // Ordon Village                - Right after wrestling with Bo (Used to connect with conversation after wearing clothes)\nT_0048              = 0x0540,       // Ordon Village                - Wrestling with Bo - Link loses\nT_0049              = 0x0520,       // Sacred Grove                 - During giant game\nT_0050              = 0x0510,       // Death Mountain               - Heard spring goron D and shopkeeper goron's conversation (before match)\nT_0051              = 0x0508,       // General use                  - General use temporary flag (flow control) F\nT_0052              = 0x0504,       // General use                  - General use temporary flag (flow control) G\nT_0053              = 0x0502,       // General use                  - General use temporary flag (flow control) H\nT_0054              = 0x0501,       // General use                  - General use temporary flag (flow control) I\nT_0055              = 0x0680,       // General use                  - General use temporary flag (flow control) J\nT_0056              = 0x0640,       // Faron Woods                  - Stopped by Midna when trying to enter the world of light\nT_0057              = 0x0620,       // Kakariko Village (inside)    - Barnes bomb shop <purchase>\nT_0059              = 0x0608,       // Kakariko Village (inside)    - Luda and Beth both taking Colin's food\nT_0060              = 0x0604,       // Kakariko Village             - During bow and arrow game\nT_0061              = 0x0602,       // N/A                          - Joust revenge complete (restart carriage guarding mission)\nT_0062              = 0x0601,       // N/A                          - Cutscene right before carriage guarding mission (reunion with Ilia)\nT_0063              = 0x0780,       // Kakariko Village             - [Bow and arrow game] Missed the final target!\nT_0064              = 0x0740,       // Kakariko Village             - [Bow and arrow game] Attempting to hit target...\nT_0065              = 0x0720,       // Kakariko Village             - [Bow and arrow game] Destroy first one with Clawshot\nT_0066              = 0x0710,       // Kakariko Village             - [Bow and arrow game] Restart from the middle\nT_0067              = 0x0708,       // Zora's River                 - [Iza's river descent] Get in boat\nT_0068              = 0x0704,       // Lake Hylia                   - [Water bomb shop] choose to buy 10\nT_0069              = 0x0702,       // Lake Hylia                   - [Water bomb shop] choose to buy 15\nT_0070              = 0x0701,       // Zora's River                 - [Iza's river descent] Helping to destroy rubble in boat hut\nT_0071              = 0x0880,       // Ordon Village                - Night, fail to take Rusl's sword (too close OR get hit)\nT_0072              = 0x0840,       // Lake Hylia                   - Knocked down all the cucco in Falbi's hut\nT_0073              = 0x0820,       // Sacred Grove                 - For use in master sword obtaining event\nT_0074              = 0x0810,       // Lake Hylia                   - (After conversation) Resets when Plumm goes off-screen\nT_0075              = 0x0808,       // Lake Hylia                   - Got more points than the set amount during Plumm's attraction\nT_0076              = 0x0804,       // Castle Town                  - Listened to bodyguard goron's complaints\nT_0077              = 0x0802,       // Unused                       - N/A\nT_0078              = 0x0801,       // Castle Town                  - Star Game: Collected all the spheres\nT_0079              = 0x0980,       // Castle Town                  - Star Game: New personal best\nT_0080              = 0x0940,       // Kakariko Village             - Put money in fundraiser box\nT_0081              = 0x0920,       // Kakariko Village             - For use in fundraiser event completion cutscene\nT_0082              = 0x0910,       // Castle Town                  - Threw water on spring goron\nT_0083              = 0x0908,       // LV5 Dungeon                  - Speak with Yeta at top of mountain as wolf after clearing Snowpeak Ruins\nT_0084              = 0x0904,       // Snowpeak mountain            - Racing with Yeto\nT_0085              = 0x0902,       // Snowpeak mountain            - Racing with Yeta\nT_0086              = 0x0901,       // Snowpeak mountain            - Won race against Yeto/Yeta\nT_0087              = 0x0a80,       // Castle Town                  - Used by child A,B (both) inside Malo Mart\nT_0088              = 0x0a40,       // N/A                          - ON only with mini-boss is down (resets when they get up)\nT_0089              = 0x0a20,       // Ordon Village                - Epona is in the middle of ordon village (used by Bo first day)\nT_0090              = 0x0a10,       // Ordon Ranch                  - Epona is at the range (used in goat herding game)\nT_0091              = 0x0a08,       // Ordon Ranch                  - Goat herding in second half (for day 1 check)\nT_0092              = 0x0a04,       // Hero's spirit                - Gold wolf identification 2\nT_0093              = 0x0a02,       // Hero's spirit                - Gold wolf identification 3\nT_0094              = 0x0a01,       // Hero's spirit                - Gold wolf identification 4\nT_0095              = 0x0b80,       // Hero's spirit                - Gold wolf identification 5\nT_0096              = 0x0b40,       // Hero's spirit                - Gold wolf identification 6\nT_0097              = 0x0b20,       // Hero's spirit                - Gold wolf identification 7\nT_0098              = 0x0b10,       // Unused                       - N/A\nT_0099              = 0x0b08,       // Unused                       - N/A\nT_0100              = 0x0b04,       // Ordon Village                - cutscene at start of 2nd day, start focus on kids Flags\nT_0107              = 0x0b02,       // Castle Town                  - (Event control) Jpn04-1063:Louise Use (1)\nT_0108              = 0x0b01,       // Castle Town                  - (Event control) Jpn04-1063:Louise Use (2)\nT_0109              = 0x0c80,       // Castle Town                  - (Event control) Jpn04-1063:Louise Use (3)\nT_0110              = 0x0c40,       // Castle Town                  - (Event control) Jpn04-1063:Louise Use (4)\nT_0111              = 0x0c20,       // Castle Town                  - (Event control) Jpn04-1063:Louise Use (5)\nT_0112              = 0x0c10,       // Castle Town                  - (Event control) Jpn04-1063:Louise Use (6)\nT_0113              = 0x0c08,       // Castle Town                  - (Event control) Jpn04-1063:Louise Use (7)\nT_0119              = 0x0d80,       // Fishing Pond                 - After cheating in Roll goal game\nT_0120              = 0x0d40,       // Fishing Pond                 - Fished something with Hena's guidance\nT_0121              = 0x0d20,       // Program use                  - Fairy use 1\nT_0122              = 0x0d10,       // Program use                  - Fairy use 2\nT_0123              = 0x0d08,       // Program use                  - Fairy use 3\nT_0124              = 0x0d04,       // Program use                  - Fairy use 4\nT_0125              = 0x0e20,       // Unused                       - N/A\nT_0175              = 0x1480,       // Ordon Ranch                  - 1st day: Start Fado's goat herding\nT_0176              = 0x1440,       // Ordon Ranch                  - 1st day: Finish Fado's goat herding\nT_0177              = 0x1420,       // Ordon Ranch                  - 1st day: Asked to jump gate by Fado\nT_0178              = 0x1410,       // Ordon Ranch                  - 1st day: Spoke with Fado while jumping over gate\nT_0179              = 0x1408,       // Ordon Ranch                  - 3rd day - Goat herding START\nT_0180              = 0x1404,       // Ordon Ranch                  - 3rd day - Goat herding END\nT_0181              = 0x1402,       // Ordon Ranch                  - Started Goat herding \u7ac7\uff61\nT_0182              = 0x1401,       // Ordon Ranch                  - Finished Goat herding \u7ac7\uff61\nT_0183              = 0x1580,       // Unused                       - N/A\nT_058               = 0x0610,       // Kakariko Village (inside)    - Conversation with Renado while he is watching over Colin\nTEMP_0038           = 0x0480,       // Ordon Village                - Temporary flag for Hanch the Hawker cutscene\nTEMP_0040           = 0x0440,       // Unused                       - N/A\nTREG_000            = 0xfbff,       // Ordon Village                - Used in conversation with Pergie\nWXXTO               = 0x0c04,       // Hyrule Castle                - Resistance leaves Flag\nYKM_ATTN            = 0x0d02,       // Snowpeak Mountain            - Player focus while Yeto waits for snowboard race\nYKM_TALK            = 0x0d01,       // Snowpeak Mountain            - Yeto talks to Yeta\nYKW_ATTN            = 0x0e40,       // Snowpeak Mountain            - Player focus while Yeta waits for snowboard race\nYKW_TALK            = 0x0e80,       // Snowpeak Mountain            - Yeta talks to Yeto\nUNUSED              = 0xffff,       // Unused                       - Unused? This was the only flag not in the debug table/* end \"d/save/d_save_temp_bit_labels.inc\" */\n    };\n    \n    static u16 const tempBitLabels[185];\n};\n\n#endif /* D_SAVE_D_SAVE_H */\n/* end \"d/save/d_save.h\" */\n/* \"include/d/d_stage.h\" line 7 \"f_pc/f_pc_priority.h\" */\n\n#ifndef F_PC_PRIORITY_H_\n#define F_PC_PRIORITY_H_\n\n/* \"include/f_pc/f_pc_priority.h\" line 4 \"f_pc/f_pc_method_tag.h\" */\n\n#ifndef F_PC_METHOD_TAG_H_\n#define F_PC_METHOD_TAG_H_\n\n/* \"include/f_pc/f_pc_method_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef int (*process_method_tag_func)(void*);\n\ntypedef struct process_method_tag_class {\n    create_tag_class mCreateTag;\n    process_method_tag_func mpFunc;\n    void* mpMthdData;\n} process_method_tag_class;\n\ns32 fpcMtdTg_Do(process_method_tag_class* pMthd);\ns32 fpcMtdTg_ToMethodQ(node_list_class* pList, process_method_tag_class* pMthd);\nvoid fpcMtdTg_MethodQTo(process_method_tag_class* pMthd);\ns32 fpcMtdTg_Init(process_method_tag_class* pMthd, process_method_tag_func pFunc, void* pMthdData);\n\n#endif\n/* end \"f_pc/f_pc_method_tag.h\" */\n\nenum {\n    fpcPi_CURRENT_e = 0xFFFD,\n    fpcPi_SPECIAL_e = 0xFFFE,\n};\n\ntypedef struct process_priority_queue_info {\n    u32 mLayer;\n    u16 mListID;\n    u16 mListPrio;\n} process_priority_queue_info;\n\ntypedef struct process_priority_class {\n    /* 0x00 */ create_tag_class mBase;\n    /* 0x14 */ process_method_tag_class mMtdTag;\n    /* 0x30 */ process_priority_queue_info mInfoQ;\n    /* 0x38 */ process_priority_queue_info mInfoCurr;\n} process_priority_class;\n\ns32 fpcPi_IsInQueue(process_priority_class* pPi);\ns32 fpcPi_QueueTo(process_priority_class* pPi);\ns32 fpcPi_ToQueue(process_priority_class* pPi);\nprocess_priority_class* fpcPi_GetFromQueue(void);\ns32 fpcPi_Delete(process_priority_class* pPi);\ns32 fpcPi_IsNormal(unsigned int layer, u16 listID, u16 priority);\ns32 fpcPi_Change(process_priority_class* pPi, unsigned int layer, u16 listID, u16 priority);\ns32 fpcPi_Handler(void);\ns32 fpcPi_Init(process_priority_class* pPi, void* pUserData, unsigned int layer, u16 listID,\n               u16 priority);\n\nextern s8 data_804505F0;  // roomReadId\n\n#endif\n/* end \"f_pc/f_pc_priority.h\" */\n/* \"include/d/d_stage.h\" line 8 \"global.h\" */\n/* end \"global.h\" */\n\nclass JKRExpHeap;\n\nstruct stage_vrboxcol_info_class {\n    // VRB\n};  // Size: 0x18\n\n// Virt\nstruct stage_vrbox_info_class {\n    /* 0x00 */ color_RGB_class field_0x0;\n    /* 0x03 */ color_RGB_class field_0x3;\n    /* 0x06 */ color_RGB_class field_0x6;\n    /* 0x09 */ GXColor field_0x9;\n    /* 0x0D */ GXColor field_0xd;\n    /* 0x11 */ GXColor field_0x11;\n};  // Size: 0x15\n\nclass stage_tresure_class {\npublic:\n    /* 0x00 */ char mName[8];\n    /* 0x08 */ u8 field_0x8;\n    /* 0x09 */ u8 mTypeFlag;\n    /* 0x0A */ u8 field_0xa;  // part of flag\n    /* 0x0B */ u8 mAppearType;\n    /* 0x0C */ Vec mPosition;\n    /* 0x18 */ s16 mRoomNo;\n    /* 0x1A */ s16 mRotation;\n    /* 0x1C */ u8 mItem;\n    /* 0x1D */ u8 mFlagID;\n};  // Size: 0x20\n\nenum StageType {\n    /* 0x0 */ ST_FIELD,\n    /* 0x1 */ ST_DUNGEON,\n    /* 0x2 */ ST_ROOM,\n    /* 0x3 */ ST_BOSS_ROOM,\n    /* 0x4 */ ST_CASTLE_TOWN,\n    /* 0x5 */ ST_CLOUD_SEA,\n};\n\nstruct stage_stag_info_class {\n    /* 0x00 */ f32 field_0x0;\n    /* 0x04 */ f32 field_0x4;\n    /* 0x08 */ u8 mCameraType;\n    /* 0x09 */ u8 field_0x09;\n    /* 0x0A */ u16 field_0x0a;\n    /* 0x0C */ u32 field_0x0c;\n    /* 0x10 */ u32 field_0x10;\n    /* 0x14 */ u8 field_0x14[6];  // usually all 0xFF\n    /* 0x1A */ s16 mGapLevel;\n    /* 0x1C */ s16 mRangeUp;\n    /* 0x1E */ s16 mRangeDown;\n    /* 0x20 */ f32 field_0x20;\n    /* 0x24 */ f32 field_0x24;\n    /* 0x28 */ u8 mMsgGroup;\n    /* 0x2A */ u16 mStageTitleNo;\n    /* 0x2C */ u8 mParticleNo[16];\n};\n\nstruct stage_scls_info_class {\n    /* 0x0 */ char mStage[8];\n    /* 0x8 */ u8 mStart;\n    /* 0x9 */ s8 mRoom;\n    /* 0xA */ u8 field_0xa;\n    /* 0xB */ u8 field_0xb;\n    /* 0xC */ s8 mWipe;\n\n    char* getStage() { return mStage; }\n\n    int getRoom() { return mRoom; }\n};  // Size: 0xD\n\nstruct stage_scls_info_dummy_class {\n    /* 0x00 */ int numEntries;\n    /* 0x04 */ stage_scls_info_class* mEntries;\n};\n\nstruct stage_pure_lightvec_info_class {\n    // LGT\n    /* 0x00 */ Vec m_position;\n    /* 0x0C */ f32 m_radius;\n    /* 0x10 */ f32 m_directionX;\n    /* 0x14 */ f32 m_directionY;\n    /* 0x18 */ f32 m_spotCutoff;\n    /* 0x1C */ u8 field_0x1c;\n    /* 0x1D */ u8 field_0x1d;\n    /* 0x1E */ u8 field_0x1e;\n    /* 0x1F */ u8 field_0x1f;\n};  // Size: 0x20\n\n// Col\nstruct stage_pselect_info_class {\n    /* 0x0 */ u8 mPalIdx[8];\n    /* 0x8 */ f32 mChangeRate;\n};  // Size: 0xC\n\nstruct stage_plight_info_class {\n    // LGHT\n    /* 0x00 */ Vec m_position;\n    /* 0x0C */ f32 m_radius;\n    /* 0x10 */ u8 field_0x10[0x18 - 0x10];\n    /* 0x18 */ color_RGB_class m_color;\n    /* 0x1B */ u8 m_fluctuation;\n};  // Size: 0x1C\n\n// PALE\nstruct stage_palette_info_class {\n    /* 0x00 */ color_RGB_class mActorAmbColor;\n    /* 0x03 */ color_RGB_class mBgAmbColor[4];\n    /* 0x0F */ color_RGB_class mPlightColor[6];\n    /* 0x21 */ color_RGB_class mFogColor;\n    /* 0x24 */ f32 mFogStartZ;\n    /* 0x28 */ f32 mFogEndZ;\n    /* 0x2C */ u8 mVirtIdx;\n    /* 0x2D */ u8 mTerrainLightInfluence;\n    /* 0x2E */ u8 mCloudShadowDensity;\n    /* 0x2F */ u8 field_0x2f;\n    /* 0x30 */ u8 mBloomTblIdx;\n    /* 0x31 */ u8 mBgAmbColor1A;\n    /* 0x32 */ u8 mBgAmbColor2A;\n    /* 0x33 */ u8 mBgAmbColor3A;\n};  // Size: 0x34\n\nstruct stage_map_info_class {\n    /* 0x00 */ u8 field_0x0[0x35];\n    /* 0x35 */ u8 field_0x35;\n    /* 0x36 */ u8 field_0x36[2];\n};  // Size: 0x38\n\nstruct stage_map_info_dummy_class {\n    /* 0x0 */ int field_0x0;\n    /* 0x4 */ stage_map_info_class* mData;\n};\n\nstruct stage_envr_info_class {\n    /* 0x0 */ u8 m_pselectID[65];\n};  // Size: 0x41\n\nstruct stage_camera2_data_class {\n    /* 0x00 */ int field_0x0;\n    /* 0x04 */ f32 field_0x4;\n    /* 0x08 */ f32 field_0x8;\n    /* 0x0C */ f32 field_0xc;\n    /* 0x10 */ u8 field_0x10;\n    /* 0x11 */ u8 field_0x11;\n    /* 0x12 */ u8 field_0x12;\n    /* 0x13 */ u8 field_0x13;\n    /* 0x14 */ u16 field_0x14;\n    /* 0x16 */ u16 field_0x16;\n};  // Size: 0x18\n\nstruct stage_camera_class {\n    /* 0x0 */ int field_0x0;\n    /* 0x4 */ stage_camera2_data_class* mEntries;\n};\n\nstruct stage_arrow_data_class {\n    /* 0x00 */ cXyz mPosition;\n    /* 0x0C */ csXyz mAngle;\n};  // Size: 0x14\n\nstruct stage_arrow_class {\n    /* 0x00 */ int mNum;\n    /* 0x04 */ stage_arrow_data_class* mEntries;\n};\n\nclass stage_actor_data_class {\npublic:\n    /* 0x00 */ char mName[8];\n    /* 0x08 */ u32 mParameter;\n    /* 0x0C */ cXyz mSpawnPos;\n    /* 0x18 */ csXyz mAngle;\n    /* 0x1E */ u16 mEnemyNo;\n};  // Size: 0x20\n\nclass stage_actor_class {\npublic:\n    /* 0x0 */ int mEntryNum;\n    /* 0x4 */ stage_actor_data_class* mEntries;\n};\n\nstruct stage_tgsc_data_class : public stage_actor_data_class {\n    /* 8002847C */ ~stage_tgsc_data_class() {}\n    /* 800284B8 */ stage_tgsc_data_class() {}\n\n    /* 0x20 */ u8 field_0x20;\n    /* 0x21 */ u8 field_0x21;\n    /* 0x22 */ u8 field_0x22;\n};  // Size: 0x24\n\nSTATIC_ASSERT(sizeof(stage_tgsc_data_class) == 0x24);\n\nclass stage_tgsc_class {\npublic:\n    /* 0x00 */ int mEntryNum;\n    /* 0x04 */ stage_tgsc_data_class* mData;\n};\n\nstruct roomRead_data_class {\n    /* 0x0 */ u8 field_0x0;\n    /* 0x1 */ u8 field_0x1;\n    /* 0x2 */ u8 field_0x2;\n    /* 0x4 */ u8* field_0x4;\n};\n\nstruct roomRead_class {\n    /* 0x0 */ int field_0x0;\n    /* 0x4 */ roomRead_data_class** field_0x4;\n};\n\nclass dStage_FileList2_dt_c {\npublic:\n    /* 0x00 */ f32 mLeftRmX;\n    /* 0x04 */ f32 mInnerRmZ;\n    /* 0x08 */ f32 mRightRmX;\n    /* 0x0C */ f32 mFrontRmZ;\n    /* 0x10 */ u8 mMinFloorNo;\n    /* 0x11 */ u8 mMaxFloorNo;\n    /* 0x12 */ u8 field_0x12;\n    /* 0x13 */ u8 field_0x13;\n    /* 0x14 */ f32 field_0x14;\n    /* 0x18 */ f32 field_0x18;\n    /* 0x1C */ s16 field_0x1c;\n};  // Size: 0x20\n\nstruct dStage_MemoryMap_c {\n    /* 0x0 */ int m_num;\n    /* 0x4 */ u32* field_0x4;\n};\n\nstruct dPath;\nstruct dStage_dPath_c {\n    /* 0x0 */ int m_num;\n    /* 0x4 */ dPath* m_path;\n};\n\nstruct dStage_Mult_info {\n    /* 0x0 */ f32 mTransX;\n    /* 0x4 */ f32 mTransY;\n    /* 0x8 */ s16 mAngle;\n    /* 0xA */ u8 mRoomNo;\n};  // Size: 0xC\n\nclass dStage_Multi_c {\npublic:\n    /* 0x0 */ int field_0x0;\n    /* 0x4 */ dStage_Mult_info* mInfo;\n};\n\nstruct stage_sound_data {\n    /* 0x00 */ char field_0x0[8];\n    /* 0x08 */ Vec field_0x8;\n    /* 0x14 */ u8 field_0x14;\n    /* 0x15 */ u8 field_0x15;\n    /* 0x16 */ u8 field_0x16;\n    /* 0x17 */ u8 field_0x17;\n    /* 0x18 */ u8 field_0x18;\n    /* 0x19 */ u8 field_0x19;\n    /* 0x1A */ u8 field_0x1a;\n};  // Size: 0x1C\n\nstruct dStage_SoundInfo_c {\n    // SOND\n    /* 0x0 */ int num;\n    /* 0x4 */ stage_sound_data* entries;\n};\n\nclass dStage_FileList_dt_c {\npublic:\n    /* 0x00 */ u32 mParameters;\n    /* 0x04 */ f32 mSeaLevel;\n    /* 0x08 */ f32 field_0x8;\n    /* 0x0C */ f32 field_0xc;\n    /* 0x10 */ u8 field_0x10[10];\n    /* 0x1A */ u8 mDefaultCamera;\n    /* 0x1B */ u8 mBitSw;\n    /* 0x1C */ u16 mMsg;\n};  // Size: 0x20\n\n// PPNT\nstruct dStage_dPnt_c {\n    /* 0x0 */ u8 field_0x0;\n    /* 0x1 */ u8 field_0x1;\n    /* 0x2 */ u8 field_0x2;\n    /* 0x3 */ u8 field_0x3;\n    /* 0x4 */ cXyz m_position;\n};  // Size: 0x10\n\nstruct dStage_FloorInfo_c {\n    // FLOR\n};\n\nclass dStage_Lbnk_dt_c {\npublic:\n    /* 0x0 */ u8 field_0x0[0x2 - 0x0];\n    /* 0x2 */ u8 field_0x2;\n};\n\nstruct dStage_Lbnk_c {\n    /* 0x0 */ int num;\n    /* 0x4 */ dStage_Lbnk_dt_c* entries;\n};\n\nstruct dStage_Elst_data {\n    /* 0x0 */ u8 m_layerTable[15];\n};\n\nstruct dStage_Elst_c {\n    /* 0x0 */ int m_entryNum;\n    /* 0x4 */ dStage_Elst_data* m_entries;\n};\n\nstruct dStage_MemoryConfig_data {\n    /* 0x0 */ u8 m_roomNo;\n    /* 0x1 */ u8 m_blockID;\n};  // Size: 0x2\n\nstruct dStage_MemoryConfig_c {\n    /* 0x0 */ int m_num;\n    /* 0x4 */ dStage_MemoryConfig_data* field_0x4;\n};\n\nstruct dStage_DMap_c {\n    // DMAP\n};\n\nstruct dStage_MapEvent_dt_c {\n    /* 0x00 */ u8 mType;\n    /* 0x01 */ u8 field_0x1;\n    /* 0x02 */ u8 field_0x2;\n    /* 0x03 */ u8 field_0x3;\n    /* 0x04 */ u8 field_0x4;\n    /* 0x05 */ u8 field_0x5;\n    /* 0x06 */ u8 mPriority;\n    /* 0x07 */ u8 field_0x7;\n    /* 0x08 */ u8 field_0x8;\n    /* 0x09 */ u8 field_0x9;\n    /* 0x0A */ u8 field_0xA;\n    /* 0x0B */ u8 field_0xB;\n    /* 0x0C */ u8 field_0xC;\n    /* 0x0D */ char mName[7];\n    /* 0x14 */ u16 field_0x14;\n    /* 0x16 */ u8 field_0x16;\n    /* 0x17 */ u8 field_0x17;\n    /* 0x18 */ u8 mSeType;  // 1: RIDDLE_A, 2: RIDDLE_B\n    /* 0x19 */ u8 field_0x19[0x1B - 0x19];\n    /* 0x1B */ u8 mSwitch;\n};  // SIZE = 0x1C\n\nstruct dStage_MapEventInfo_c {\n    // REVT\n    int mCount;\n    dStage_MapEvent_dt_c* mData;\n};\n\nclass dStage_dt_c {\npublic:\n    dStage_dt_c() {}\n    void setRoomNo(s8 roomNo) { mRoomNo = roomNo; }\n    s8 getRoomNo() { return mRoomNo; }\n\n    /* vt[ 2] */ virtual void init(void) = 0;\n    /* vt[ 3] */ virtual void setCamera(stage_camera_class*) = 0;\n    /* vt[ 4] */ virtual stage_camera_class* getCamera(void) const = 0;\n    /* vt[ 5] */ virtual void setArrow(stage_arrow_class*) = 0;\n    /* vt[ 6] */ virtual stage_arrow_class* getArrow(void) const = 0;\n    /* vt[ 7] */ virtual void setPlayer(stage_actor_class*) = 0;\n    /* vt[ 8] */ virtual stage_actor_class* getPlayer(void) const = 0;\n    /* vt[ 9] */ virtual void setPlayerNum(u16) = 0;\n    /* vt[10] */ virtual u16 getPlayerNum(void) const = 0;\n    /* vt[11] */ virtual void setRoom(roomRead_class*) = 0;\n    /* vt[12] */ virtual roomRead_class* getRoom(void) const = 0;\n    /* vt[13] */ virtual void setMapInfo(stage_map_info_class*) = 0;\n    /* vt[14] */ virtual stage_map_info_class* getMapInfo(void) const = 0;\n    /* vt[15] */ virtual stage_map_info_class* getMapInfo2(int) const = 0;\n    /* vt[16] */ virtual void setMapInfoBase(stage_map_info_dummy_class*) = 0;\n    /* vt[17] */ virtual stage_map_info_dummy_class* getMapInfoBase(void) const = 0;\n    /* vt[18] */ virtual void setPaletteInfo(stage_palette_info_class*) = 0;\n    /* vt[19] */ virtual stage_palette_info_class* getPaletteInfo(void) const = 0;\n    /* vt[20] */ virtual void setPselectInfo(stage_pselect_info_class*) = 0;\n    /* vt[21] */ virtual stage_pselect_info_class* getPselectInfo(void) const = 0;\n    /* vt[22] */ virtual void setEnvrInfo(stage_envr_info_class*) = 0;\n    /* vt[23] */ virtual stage_envr_info_class* getEnvrInfo(void) const = 0;\n    /* vt[24] */ virtual void setVrboxInfo(stage_vrbox_info_class*) = 0;\n    /* vt[25] */ virtual stage_vrbox_info_class* getVrboxInfo(void) const = 0;\n    /* vt[26] */ virtual void setVrboxcolInfo(stage_vrboxcol_info_class*) = 0;\n    /* vt[27] */ virtual stage_vrboxcol_info_class* getVrboxcolInfo(void) const = 0;\n    /* vt[28] */ virtual void setPlightInfo(stage_plight_info_class*) = 0;\n    /* vt[29] */ virtual stage_plight_info_class* getPlightInfo(void) const = 0;\n    /* vt[30] */ virtual void setPaletteNumInfo(int) = 0;\n    /* vt[31] */ virtual int getPaletteNumInfo(void) const = 0;\n    /* vt[32] */ virtual void setPselectNumInfo(int) = 0;\n    /* vt[33] */ virtual int getPselectNumInfo(void) const = 0;\n    /* vt[34] */ virtual void setEnvrNumInfo(int) = 0;\n    /* vt[35] */ virtual int getEnvrNumInfo(void) const = 0;\n    /* vt[36] */ virtual void setVrboxNumInfo(int) = 0;\n    /* vt[37] */ virtual int getVrboxNumInfo(void) const = 0;\n    /* vt[38] */ virtual void setVrboxcolNumInfo(int) = 0;\n    /* vt[39] */ virtual int getVrboxcolNumInfo(void) const = 0;\n    /* vt[40] */ virtual void setPlightNumInfo(int) = 0;\n    /* vt[41] */ virtual int getPlightNumInfo(void) const = 0;\n    /* vt[42] */ virtual void setLightVecInfo(stage_pure_lightvec_info_class*) = 0;\n    /* vt[43] */ virtual stage_pure_lightvec_info_class* getLightVecInfo(void) const = 0;\n    /* vt[44] */ virtual void setLightVecInfoNum(int) = 0;\n    /* vt[45] */ virtual int getLightVecInfoNum(void) const = 0;\n    /* vt[46] */ virtual void setStagInfo(stage_stag_info_class*) = 0;\n    /* vt[47] */ virtual stage_stag_info_class* getStagInfo(void) const = 0;\n    /* vt[48] */ virtual void setSclsInfo(stage_scls_info_dummy_class*) = 0;\n    /* vt[49] */ virtual stage_scls_info_dummy_class* getSclsInfo(void) const = 0;\n    /* vt[50] */ virtual void setPntInfo(dStage_dPnt_c*) = 0;\n    /* vt[51] */ virtual dStage_dPnt_c* getPntInf(void) const = 0;\n    /* vt[52] */ virtual void setPathInfo(dStage_dPath_c*) = 0;\n    /* vt[53] */ virtual dStage_dPath_c* getPathInf(void) const = 0;\n    /* vt[54] */ virtual void setPnt2Info(dStage_dPnt_c*) = 0;\n    /* vt[55] */ virtual dStage_dPnt_c* getPnt2Inf(void) const = 0;\n    /* vt[56] */ virtual void setPath2Info(dStage_dPath_c*) = 0;\n    /* vt[57] */ virtual dStage_dPath_c* getPath2Inf(void) const = 0;\n    /* vt[58] */ virtual void setSoundInf(dStage_SoundInfo_c*) = 0;\n    /* vt[59] */ virtual dStage_SoundInfo_c* getSoundInf(void) const = 0;\n    /* vt[60] */ virtual void setSoundInfCL(dStage_SoundInfo_c*) = 0;\n    /* vt[61] */ virtual dStage_SoundInfo_c* getSoundInfCL(void) const = 0;\n    /* vt[62] */ virtual void setMapEventInfo(dStage_MapEventInfo_c*) = 0;\n    /* vt[63] */ virtual dStage_MapEventInfo_c* getMapEventInfo(void) const = 0;\n    /* vt[64] */ virtual void setFileList2Info(dStage_FileList2_dt_c*) = 0;\n    /* vt[65] */ virtual dStage_FileList2_dt_c* getFileList2Info(void) const = 0;\n    /* vt[66] */ virtual void setFileListInfo(dStage_FileList_dt_c*) = 0;\n    /* vt[67] */ virtual dStage_FileList_dt_c* getFileListInfo(void) const = 0;\n    /* vt[68] */ virtual void setFloorInfo(dStage_FloorInfo_c*) = 0;\n    /* vt[69] */ virtual dStage_FloorInfo_c* getFloorInfo(void) const = 0;\n    /* vt[70] */ virtual void setMemoryConfig(dStage_MemoryConfig_c*) = 0;\n    /* vt[71] */ virtual dStage_MemoryConfig_c* getMemoryConfig(void) const = 0;\n    /* vt[72] */ virtual void setMemoryMap(dStage_MemoryMap_c*) = 0;\n    /* vt[73] */ virtual dStage_MemoryMap_c* getMemoryMap(void) const = 0;\n    /* vt[74] */ virtual void setMulti(dStage_Multi_c*) = 0;\n    /* vt[75] */ virtual dStage_Multi_c* getMulti(void) const = 0;\n    /* vt[76] */ virtual void setOldMulti(void) = 0;\n    /* vt[77] */ virtual void resetOldMulti(void) = 0;\n    /* vt[78] */ virtual dStage_Multi_c* getOldMulti(void) const = 0;\n    /* vt[79] */ virtual void setLbnk(dStage_Lbnk_c*) = 0;\n    /* vt[80] */ virtual dStage_Lbnk_c* getLbnk(void) const = 0;\n    /* vt[81] */ virtual void setTresure(stage_tresure_class*) = 0;\n    /* vt[82] */ virtual stage_tresure_class* getTresure(void) const = 0;\n    /* vt[83] */ virtual void setDMap(dStage_DMap_c*) = 0;\n    /* vt[84] */ virtual dStage_DMap_c* getDMap(void) const = 0;\n    /* vt[85] */ virtual void setDrTg(stage_tgsc_class*) = 0;\n    /* vt[86] */ virtual stage_tgsc_class* getDrTg(void) const = 0;\n    /* vt[87] */ virtual void setDoor(stage_tgsc_class*) = 0;\n    /* vt[88] */ virtual stage_tgsc_class* getDoor(void) const = 0;\n    /* vt[89] */ virtual void setMapPath(void*) = 0;\n    /* vt[90] */ virtual int getMapPath(void) = 0;\n    /* vt[91] */ virtual void setElst(dStage_Elst_c*) = 0;\n    /* vt[92] */ virtual dStage_Elst_c* getElst(void) = 0;\n\nprivate:\n    /* 0x04 */ s8 mRoomNo;\n};\n\nclass dStage_stageDt_c : public dStage_dt_c {\npublic:\n    dStage_stageDt_c() {}\n\n    /* vt[ 2] */ virtual void init(void);\n    /* vt[ 3] */ virtual void setCamera(stage_camera_class*);\n    /* vt[ 4] */ virtual stage_camera_class* getCamera(void) const;\n    /* vt[ 5] */ virtual void setArrow(stage_arrow_class*);\n    /* vt[ 6] */ virtual stage_arrow_class* getArrow(void) const;\n    /* vt[ 7] */ virtual void setPlayer(stage_actor_class*);\n    /* vt[ 8] */ virtual stage_actor_class* getPlayer(void) const;\n    /* vt[ 9] */ virtual void setPlayerNum(u16);\n    /* vt[10] */ virtual u16 getPlayerNum(void) const;\n    /* vt[11] */ virtual void setRoom(roomRead_class*);\n    /* vt[12] */ virtual roomRead_class* getRoom(void) const;\n    /* vt[13] */ virtual void setMapInfo(stage_map_info_class*);\n    /* vt[14] */ virtual stage_map_info_class* getMapInfo(void) const;\n    /* vt[15] */ virtual stage_map_info_class* getMapInfo2(int) const;\n    /* vt[16] */ virtual void setMapInfoBase(stage_map_info_dummy_class*);\n    /* vt[17] */ virtual stage_map_info_dummy_class* getMapInfoBase(void) const;\n    /* vt[18] */ virtual void setPaletteInfo(stage_palette_info_class*);\n    /* vt[19] */ virtual stage_palette_info_class* getPaletteInfo(void) const;\n    /* vt[20] */ virtual void setPselectInfo(stage_pselect_info_class*);\n    /* vt[21] */ virtual stage_pselect_info_class* getPselectInfo(void) const;\n    /* vt[22] */ virtual void setEnvrInfo(stage_envr_info_class*);\n    /* vt[23] */ virtual stage_envr_info_class* getEnvrInfo(void) const;\n    /* vt[24] */ virtual void setVrboxInfo(stage_vrbox_info_class*);\n    /* vt[25] */ virtual stage_vrbox_info_class* getVrboxInfo(void) const;\n    /* vt[26] */ virtual void setVrboxcolInfo(stage_vrboxcol_info_class*);\n    /* vt[27] */ virtual stage_vrboxcol_info_class* getVrboxcolInfo(void) const;\n    /* vt[28] */ virtual void setPlightInfo(stage_plight_info_class*);\n    /* vt[29] */ virtual stage_plight_info_class* getPlightInfo(void) const;\n    /* vt[30] */ virtual void setPaletteNumInfo(int);\n    /* vt[31] */ virtual int getPaletteNumInfo(void) const;\n    /* vt[32] */ virtual void setPselectNumInfo(int);\n    /* vt[33] */ virtual int getPselectNumInfo(void) const;\n    /* vt[34] */ virtual void setEnvrNumInfo(int);\n    /* vt[35] */ virtual int getEnvrNumInfo(void) const;\n    /* vt[36] */ virtual void setVrboxNumInfo(int);\n    /* vt[37] */ virtual int getVrboxNumInfo(void) const;\n    /* vt[38] */ virtual void setVrboxcolNumInfo(int);\n    /* vt[39] */ virtual int getVrboxcolNumInfo(void) const;\n    /* vt[40] */ virtual void setPlightNumInfo(int);\n    /* vt[41] */ virtual int getPlightNumInfo(void) const;\n    /* vt[42] */ virtual void setLightVecInfo(stage_pure_lightvec_info_class*);\n    /* vt[43] */ virtual stage_pure_lightvec_info_class* getLightVecInfo(void) const;\n    /* vt[44] */ virtual void setLightVecInfoNum(int);\n    /* vt[45] */ virtual int getLightVecInfoNum(void) const;\n    /* vt[46] */ virtual void setStagInfo(stage_stag_info_class*);\n    /* vt[47] */ virtual stage_stag_info_class* getStagInfo(void) const;\n    /* vt[48] */ virtual void setSclsInfo(stage_scls_info_dummy_class*);\n    /* vt[49] */ virtual stage_scls_info_dummy_class* getSclsInfo(void) const;\n    /* vt[50] */ virtual void setPntInfo(dStage_dPnt_c*);\n    /* vt[51] */ virtual dStage_dPnt_c* getPntInf(void) const;\n    /* vt[52] */ virtual void setPathInfo(dStage_dPath_c*);\n    /* vt[53] */ virtual dStage_dPath_c* getPathInf(void) const;\n    /* vt[54] */ virtual void setPnt2Info(dStage_dPnt_c*);\n    /* vt[55] */ virtual dStage_dPnt_c* getPnt2Inf(void) const;\n    /* vt[56] */ virtual void setPath2Info(dStage_dPath_c*);\n    /* vt[57] */ virtual dStage_dPath_c* getPath2Inf(void) const;\n    /* vt[58] */ virtual void setSoundInf(dStage_SoundInfo_c*);\n    /* vt[59] */ virtual dStage_SoundInfo_c* getSoundInf(void) const;\n    /* vt[60] */ virtual void setSoundInfCL(dStage_SoundInfo_c*);\n    /* vt[61] */ virtual dStage_SoundInfo_c* getSoundInfCL(void) const;\n    /* vt[62] */ virtual void setMapEventInfo(dStage_MapEventInfo_c*);\n    /* vt[63] */ virtual dStage_MapEventInfo_c* getMapEventInfo(void) const;\n    /* vt[64] */ virtual void setFileList2Info(dStage_FileList2_dt_c*);\n    /* vt[65] */ virtual dStage_FileList2_dt_c* getFileList2Info(void) const;\n    /* vt[66] */ virtual void setFileListInfo(dStage_FileList_dt_c*);\n    /* vt[67] */ virtual dStage_FileList_dt_c* getFileListInfo(void) const;\n    /* vt[68] */ virtual void setFloorInfo(dStage_FloorInfo_c*);\n    /* vt[69] */ virtual dStage_FloorInfo_c* getFloorInfo(void) const;\n    /* vt[70] */ virtual void setMemoryConfig(dStage_MemoryConfig_c*);\n    /* vt[71] */ virtual dStage_MemoryConfig_c* getMemoryConfig(void) const;\n    /* vt[72] */ virtual void setMemoryMap(dStage_MemoryMap_c*);\n    /* vt[73] */ virtual dStage_MemoryMap_c* getMemoryMap(void) const;\n    /* vt[74] */ virtual void setMulti(dStage_Multi_c*);\n    /* vt[75] */ virtual dStage_Multi_c* getMulti(void) const;\n    /* vt[76] */ virtual void setOldMulti(void);\n    /* vt[77] */ virtual void resetOldMulti(void);\n    /* vt[78] */ virtual dStage_Multi_c* getOldMulti(void) const;\n    /* vt[79] */ virtual void setLbnk(dStage_Lbnk_c*);\n    /* vt[80] */ virtual dStage_Lbnk_c* getLbnk(void) const;\n    /* vt[81] */ virtual void setTresure(stage_tresure_class*);\n    /* vt[82] */ virtual stage_tresure_class* getTresure(void) const;\n    /* vt[83] */ virtual void setDMap(dStage_DMap_c*);\n    /* vt[84] */ virtual dStage_DMap_c* getDMap(void) const;\n    /* vt[85] */ virtual void setDrTg(stage_tgsc_class*);\n    /* vt[86] */ virtual stage_tgsc_class* getDrTg(void) const;\n    /* vt[87] */ virtual void setDoor(stage_tgsc_class*);\n    /* vt[88] */ virtual stage_tgsc_class* getDoor(void) const;\n    /* vt[89] */ virtual void setMapPath(void*);\n    /* vt[90] */ virtual int getMapPath(void);\n    /* vt[91] */ virtual void setElst(dStage_Elst_c*);\n    /* vt[92] */ virtual dStage_Elst_c* getElst(void);\n\n    void setTreasure(stage_tresure_class*);\n\npublic:\n    /* 0x08 */ stage_camera_class* mCamera;\n    /* 0x0C */ stage_arrow_class* mArrow;\n    /* 0x10 */ stage_actor_class* mPlayer;\n    /* 0x14 */ roomRead_class* mRoom;\n    /* 0x18 */ stage_map_info_class* mMapInfo;\n    /* 0x1C */ stage_map_info_dummy_class* mMapInfoBase;\n    /* 0x20 */ stage_palette_info_class* mPaletteInfo;\n    /* 0x24 */ stage_pselect_info_class* mPselectInfo;\n    /* 0x28 */ stage_envr_info_class* mEnvrInfo;\n    /* 0x2C */ stage_vrbox_info_class* mVrboxInfo;\n    /* 0x30 */ stage_vrboxcol_info_class* mVrboxcolInfo;\n    /* 0x34 */ stage_plight_info_class* mPlightInfo;\n    /* 0x38 */ dStage_MapEventInfo_c* mMapEventInfo;\n    /* 0x3C */ u32 mPaletteNumInfo;\n    /* 0x40 */ u32 mPselectNumInfo;\n    /* 0x44 */ u32 mEnvrNumInfo;\n    /* 0x48 */ u32 mVrboxNumInfo;\n    /* 0x4C */ int mVrboxcolNumInfo;\n    /* 0x50 */ u32 mPlightNumInfo;\n    /* 0x54 */ u16 mPlayerNum;\n    /* 0x56 */ u16 field_0x56;\n    /* 0x58 */ u16 field_0x58;\n    /* 0x5A */ u16 field_0x5a;\n    /* 0x5C */ stage_stag_info_class* mStagInfo;\n    /* 0x60 */ stage_scls_info_dummy_class* mSclsInfo;\n    /* 0x64 */ dStage_dPnt_c* mPntInfo;\n    /* 0x68 */ dStage_dPath_c* mPathInfo;\n    /* 0x6C */ dStage_dPnt_c* mPnt2Inf;\n    /* 0x70 */ dStage_dPath_c* mPath2Info;\n    /* 0x74 */ dStage_SoundInfo_c* mSoundInf;\n    /* 0x78 */ dStage_SoundInfo_c* mSoundInfCL;\n    /* 0x7C */ dStage_FloorInfo_c* mFloorInfo;\n    /* 0x80 */ dStage_MemoryConfig_c* mMemoryConfig;\n    /* 0x84 */ dStage_MemoryMap_c* mMemoryMap;\n    /* 0x88 */ dStage_Multi_c* mMulti;\n    /* 0x8C */ dStage_Multi_c* mOldMulti;\n    /* 0x90 */ stage_tresure_class* mTreasure;\n    /* 0x94 */ dStage_DMap_c* mDMap;\n    /* 0x98 */ stage_tgsc_class* mDrTg;\n    /* 0x9C */ stage_tgsc_class* mDoor;\n    /* 0xA0 */ dStage_Elst_c* mElst;\n};\n\nclass dStage_roomDt_c : public dStage_dt_c {\npublic:\n    dStage_roomDt_c() {}\n    void initFileList2(void);\n    void setPnt2Inf(dStage_dPnt_c*);\n    void setTreasure(stage_tresure_class*);\n\n    virtual void init(void);\n    virtual void setCamera(stage_camera_class*);\n    virtual stage_camera_class* getCamera(void) const;\n    virtual void setArrow(stage_arrow_class*);\n    virtual stage_arrow_class* getArrow(void) const;\n    virtual void setPlayer(stage_actor_class*);\n    virtual stage_actor_class* getPlayer(void) const;\n    virtual void setPlayerNum(u16);\n    virtual u16 getPlayerNum(void) const;\n    virtual void setRoom(roomRead_class*);\n    virtual roomRead_class* getRoom(void) const;\n    virtual void setMapInfo(stage_map_info_class*);\n    virtual stage_map_info_class* getMapInfo(void) const;\n    virtual stage_map_info_class* getMapInfo2(int) const;\n    virtual void setMapInfoBase(stage_map_info_dummy_class*);\n    virtual stage_map_info_dummy_class* getMapInfoBase(void) const;\n    virtual void setPaletteInfo(stage_palette_info_class*);\n    virtual stage_palette_info_class* getPaletteInfo(void) const;\n    virtual void setPselectInfo(stage_pselect_info_class*);\n    virtual stage_pselect_info_class* getPselectInfo(void) const;\n    virtual void setEnvrInfo(stage_envr_info_class*);\n    virtual stage_envr_info_class* getEnvrInfo(void) const;\n    virtual void setVrboxInfo(stage_vrbox_info_class*);\n    virtual stage_vrbox_info_class* getVrboxInfo(void) const;\n    virtual void setVrboxcolInfo(stage_vrboxcol_info_class*);\n    virtual stage_vrboxcol_info_class* getVrboxcolInfo(void) const;\n    virtual void setPlightInfo(stage_plight_info_class*);\n    virtual stage_plight_info_class* getPlightInfo(void) const;\n    virtual void setPaletteNumInfo(int);\n    virtual int getPaletteNumInfo(void) const;\n    virtual void setPselectNumInfo(int);\n    virtual int getPselectNumInfo(void) const;\n    virtual void setEnvrNumInfo(int);\n    virtual int getEnvrNumInfo(void) const;\n    virtual void setVrboxNumInfo(int);\n    virtual int getVrboxNumInfo(void) const;\n    virtual void setVrboxcolNumInfo(int);\n    virtual int getVrboxcolNumInfo(void) const;\n    virtual void setPlightNumInfo(int);\n    virtual int getPlightNumInfo(void) const;\n    virtual void setLightVecInfo(stage_pure_lightvec_info_class*);\n    virtual stage_pure_lightvec_info_class* getLightVecInfo(void) const;\n    virtual void setLightVecInfoNum(int);\n    virtual int getLightVecInfoNum(void) const;\n    virtual void setStagInfo(stage_stag_info_class*);\n    virtual stage_stag_info_class* getStagInfo(void) const;\n    virtual void setSclsInfo(stage_scls_info_dummy_class*);\n    virtual stage_scls_info_dummy_class* getSclsInfo(void) const;\n    virtual void setPntInfo(dStage_dPnt_c*);\n    virtual dStage_dPnt_c* getPntInf(void) const;\n    virtual void setPathInfo(dStage_dPath_c*);\n    virtual dStage_dPath_c* getPathInf(void) const;\n    virtual void setPnt2Info(dStage_dPnt_c*);\n    virtual dStage_dPnt_c* getPnt2Inf(void) const;\n    virtual void setPath2Info(dStage_dPath_c*);\n    virtual dStage_dPath_c* getPath2Inf(void) const;\n    virtual void setSoundInf(dStage_SoundInfo_c*);\n    virtual dStage_SoundInfo_c* getSoundInf(void) const;\n    virtual void setSoundInfCL(dStage_SoundInfo_c*);\n    virtual dStage_SoundInfo_c* getSoundInfCL(void) const;\n    virtual void setMapEventInfo(dStage_MapEventInfo_c*);\n    virtual dStage_MapEventInfo_c* getMapEventInfo(void) const;\n    virtual void setFileList2Info(dStage_FileList2_dt_c*);\n    virtual dStage_FileList2_dt_c* getFileList2Info(void) const;\n    virtual void setFileListInfo(dStage_FileList_dt_c*);\n    virtual dStage_FileList_dt_c* getFileListInfo(void) const;\n    virtual void setFloorInfo(dStage_FloorInfo_c*);\n    virtual dStage_FloorInfo_c* getFloorInfo(void) const;\n    virtual void setMemoryConfig(dStage_MemoryConfig_c*);\n    virtual dStage_MemoryConfig_c* getMemoryConfig(void) const;\n    virtual void setMemoryMap(dStage_MemoryMap_c*);\n    virtual dStage_MemoryMap_c* getMemoryMap(void) const;\n    virtual void setMulti(dStage_Multi_c*);\n    virtual dStage_Multi_c* getMulti(void) const;\n    virtual void setOldMulti(void);\n    virtual void resetOldMulti(void);\n    virtual dStage_Multi_c* getOldMulti(void) const;\n    virtual void setLbnk(dStage_Lbnk_c*);\n    virtual dStage_Lbnk_c* getLbnk(void) const;\n    virtual void setTresure(stage_tresure_class*);\n    virtual stage_tresure_class* getTresure(void) const;\n    virtual void setDMap(dStage_DMap_c*);\n    virtual dStage_DMap_c* getDMap(void) const;\n    virtual void setDrTg(stage_tgsc_class*);\n    virtual stage_tgsc_class* getDrTg(void) const;\n    virtual void setDoor(stage_tgsc_class*);\n    virtual stage_tgsc_class* getDoor(void) const;\n    virtual void setMapPath(void*);\n    virtual int getMapPath(void);\n    virtual void setElst(dStage_Elst_c*);\n    virtual dStage_Elst_c* getElst(void);\n\npublic:\n    /* 0x08 */ stage_pure_lightvec_info_class* mLightVecInfo;\n    /* 0x0C */ int mLightVecInfoNum;\n    /* 0x10 */ stage_map_info_class* mMapInfo;\n    /* 0x14 */ stage_map_info_dummy_class* mMapInfoBase;\n    /* 0x18 */ stage_vrbox_info_class* mVrboxInfo;\n    /* 0x1C */ stage_vrboxcol_info_class* mVrboxcolInfo;\n    /* 0x20 */ dStage_FileList2_dt_c* mFileList2Info;\n    /* 0x24 */ dStage_FileList_dt_c* mFileListInfo;\n    /* 0x28 */ stage_actor_class* mPlayer;\n    /* 0x2C */ dStage_dPnt_c* mPnt2Info;\n    /* 0x30 */ dStage_dPath_c* mPath2Info;\n    /* 0x34 */ stage_camera_class* mCamera;\n    /* 0x38 */ stage_arrow_class* mArrow;\n    /* 0x3C */ dStage_MapEventInfo_c* mMapEventInfo;\n    /* 0x40 */ dStage_SoundInfo_c* mSoundInf;\n    /* 0x44 */ dStage_SoundInfo_c* mSoundInfCL;\n    /* 0x48 */ stage_scls_info_dummy_class* mSclsInfo;\n    /* 0x4C */ dStage_Lbnk_c* mLbnk;\n    /* 0x50 */ stage_tresure_class* mTreasure;\n    /* 0x54 */ stage_tgsc_class* mDrTg;\n    /* 0x58 */ stage_tgsc_class* mDoor;\n    /* 0x5C */ dStage_FloorInfo_c* mFloorInfo;\n    /* 0x60 */ u16 mPlayerNum;\n    /* 0x62 */ u16 field_0x62;\n    /* 0x64 */ int mVrboxNumInfo;\n    /* 0x68 */ int mVrboxcolNumInfo;\n};  // Size: 0x6C\n\nclass dBgW_base;\nclass dStage_roomStatus_c {\npublic:\n    /* 0x000 */ dStage_roomDt_c mRoomDt;\n    /* 0x06C */ dKy_tevstr_c mKyTevStr;\n    /* 0x3F4 */ u8 mFlag;\n    /* 0x3F5 */ bool mDraw;\n    /* 0x3F6 */ s8 mZoneCount;\n    /* 0x3F7 */ s8 mZoneNo;\n    /* 0x3F8 */ s8 mMemBlockID;\n    /* 0x3F9 */ u8 mRegionNo;\n    /* 0x3FC */ int mProcID;\n    /* 0x400 */ dBgW_base* mpBgW;\n\n    int getZoneNo() const { return mZoneNo; }\n    ~dStage_roomStatus_c() {}\n    dStage_roomStatus_c() {}\n};  // Size: 0x404\n\nSTATIC_ASSERT(sizeof(dStage_roomStatus_c) == 0x404);\n\nextern s8 mStayNo__20dStage_roomControl_c;  // gStayNo\nextern s8 mOldStayNo__20dStage_roomControl_c;\nextern s8 mNextStayNo__20dStage_roomControl_c;\nextern s8 m_time_pass__20dStage_roomControl_c;\nextern u8 mNoChangeRoom__20dStage_roomControl_c;\n\nclass dStage_roomControl_c {\npublic:\n    class roomDzs_c {\n    public:\n        roomDzs_c() { m_num = 0; }\n        void create(u8);\n        void remove();\n        void* add(u8, u8);\n\n        /* 0x00 */ u8 m_num;\n        /* 0x04 */ void** m_dzs;\n    };\n\n    struct nameData {\n        /* 0x0 */ s8 m_num;\n        /* 0x1 */ char m_names[32][10];  // ?\n    };\n\n    static void createRoomDzs(u8 i_num) { m_roomDzs.create(i_num); }\n    static void* addRoomDzs(u8 i_num, u8 roomNo) { return m_roomDzs.add(i_num, roomNo); }\n    static void removeRoomDzs() { m_roomDzs.remove(); }\n\n    dStage_roomControl_c() {}\n    void init(void);\n    static int getZoneNo(int room);\n    /* 80024338 */ void initZone();\n    /* 80024384 */ dStage_roomStatus_c* getStatusRoomDt(int);\n    /* 800243B0 */ static JKRExpHeap* getMemoryBlock(int);\n    /* 800243E8 */ static void setStayNo(int);\n    /* 80024424 */ static void setNextStayNo(int);\n    /* 800244E8 */ BOOL checkRoomDisp(int) const;\n    /* 8002451C */ int loadRoom(int, u8*, bool);\n    /* 8002471C */ void zoneCountCheck(int) const;\n    /* 80024844 */ static JKRExpHeap* createMemoryBlock(int, u32);\n    /* 800248A8 */ static void destroyMemoryBlock();\n    /* 8002490C */ static void setArcBank(int, char const*);\n    /* 80024940 */ static char* getArcBank(int);\n    /* 80024954 */ static bool resetArchiveBank(int);\n    /* 80024DB0 */ static void SetTimePass(int);\n    /* 8025BAAC */ static void setZoneNo(int, int);\n    static s8 GetTimePass();\n\n    static s8 getStayNo() { return mStayNo; }\n    static u8 getRegionNo(int i_roomNo) { return mStatus[i_roomNo].mRegionNo; }\n    static s8 getMemoryBlockID(int i_roomNo) { return mStatus[i_roomNo].mMemBlockID; }\n    dKy_tevstr_c* getTevStr(int i_roomNo) { return &mStatus[i_roomNo].mKyTevStr; }\n    void setStatusFlag(int i_roomNo, u8 flag) { mStatus[i_roomNo].mFlag = flag; }\n    static void onStatusDraw(int i_roomNo) { mStatus[i_roomNo].mDraw = true; }\n    static dStage_FileList2_dt_c* getFileList2(int i_roomNo) {\n        return mStatus[i_roomNo].mRoomDt.mFileList2Info;\n    }\n    static char* getDemoArcName() { return mDemoArcName; }\n    static char* getArcBankName() { return mArcBankName; }\n    static void setRoomReadId(s8 id) { data_804505F0 = id; }\n    static s8 getRoomReadId() { return data_804505F0; }\n    static void offNoChangeRoom() { mNoChangeRoom = false; }\n    static void setProcID(u32 id) { mProcID = id; }\n    static u32 getProcID() { return mProcID; }\n    static void setStatusProcID(int i_roomNo, unsigned int i_id) { mStatus[i_roomNo].mProcID = i_id; }\n    static int getStatusProcID(int i_roomNo) { return mStatus[i_roomNo].mProcID; }\n\n    static void setMemoryBlockID(int i_roomNo, int i_blockID) {\n        mStatus[i_roomNo].mMemBlockID = i_blockID;\n    }\n\n    static void setFileList2(int i_roomNo, dStage_FileList2_dt_c* list) {\n        mStatus[i_roomNo].mRoomDt.mFileList2Info = list;\n    }\n\n    static void setBgW(int param_0, dBgW_base* i_bgw) {\n        mStatus[param_0].mpBgW = i_bgw;\n    }\n\n    BOOL checkStatusFlag(int i_roomNo, u8 flag) const {\n        return cLib_checkBit(mStatus[i_roomNo].mFlag, flag);\n    }\n\n    void offStatusFlag(int i_roomNo, u8 flag) {\n        return cLib_offBit(mStatus[i_roomNo].mFlag, flag);\n    }\n\n    void onStatusFlag(int i_roomNo, u8 flag) {\n        return cLib_onBit(mStatus[i_roomNo].mFlag, flag);\n    }\n\n    static JKRExpHeap* mMemoryBlock[19];\n    static char mArcBank[32][10];\n    static dStage_roomStatus_c mStatus[0x40];\n    static char mDemoArcName[10];\n    static u32 mProcID;\n    static char* mArcBankName;\n    static char* mArcBankData;\n    static roomDzs_c m_roomDzs;\n    static s8 mStayNo;\n    static s8 mOldStayNo;\n    static s8 mNextStayNo;\n    static s8 m_time_pass;\n    static u8 mNoChangeRoom;\n\nprivate:\n    /* 0x0 */ u8 field_0x0[4];\n};\n\nclass dStage_startStage_c {\npublic:\n    void set(const char*, s8, s16, s8);\n    const char* getName() const { return mName; }\n    s16 getPoint() const { return mPoint; }\n    s8 getRoomNo() const { return mRoomNo; }\n    s8 getLayer() const { return mLayer; }\n    void setLayer(s8 layer) { mLayer = layer; }\n    s8 getDarkArea() const { return mDarkArea; }\n    void setDarkArea(s8 darkArea) { mDarkArea = darkArea; }\n\nprivate:\n    /* 0x0 */ char mName[8];\n    /* 0x8 */ s16 mPoint;\n    /* 0xA */ s8 mRoomNo;\n    /* 0xB */ s8 mLayer;\n    /* 0xC */ s8 mDarkArea;\n};\n\nclass dStage_nextStage_c : public dStage_startStage_c {\npublic:\n    dStage_nextStage_c() {\n        enabled = 0;  // TODO: maybe wrong\n    }\n    void set(const char*, s8, s16, s8, s8, u8);\n    void offEnable() { enabled = 0; }\n    s8 isEnable() const { return enabled; }\n    s8 getWipe() const { return wipe; }\n\nprivate:\n    s8 enabled;\n    s8 wipe;\n    u8 wipe_speed;\n};\n\n// unknown name\nstruct dStage_objectNameInf {\n    char mName[8];\n    s16 mProcName;\n    s8 mSubtype;\n};  // Size: 0xC\n\nclass dStage_KeepDoorInfo {\npublic:\n    /* 80028418 */ ~dStage_KeepDoorInfo() {}\n    /* 0x000 */ int unk_0x0;\n    /* 0x004 */ stage_tgsc_data_class unk_0x4[0x40];\n};  // Size = 0x904\n\ntypedef int (*dStage_Func)(dStage_dt_c*, void*, int, void*);\n\nstruct FuncTable {\n    char identifier[5];\n    dStage_Func function;\n};\n\nstruct dStage_fileHeader {\n    /* 0x0 */ int chunkCount;\n};\n\nstruct dStage_nodeHeader {\n    /* 0x0 */ u32 m_tag;\n    /* 0x4 */ int m_entryNum;\n    /* 0x8 */ u32 m_offset;\n};\n\nconst char* dStage_getName2(s16, s8);\ndStage_objectNameInf* dStage_searchName(const char*);\nstatic int dStage_stageKeepTresureInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_filiInfo2Init(dStage_dt_c*, void*, int, void*);\nstatic int dStage_mapPathInitCommonLayer(dStage_dt_c*, void*, int, void*);\nstatic int dStage_mapPathInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_memaInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_mecoInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_stagInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_soundInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_lgtvInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_envrInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_pselectInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_paletteInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_vrboxcolInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_roomDrtgInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_tgscInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_actorInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_layerTresureInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_elstInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_rppnInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_rpatInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_multInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_playerInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_cameraInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_actorInit_always(dStage_dt_c*, void*, int, void*);\nstatic int dStage_roomReadInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_arrowInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_vrboxInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_sclsInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_tgscInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_plightInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_ppntInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_pathInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_filiInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_stageDrtgInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_floorInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_dmapInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_stEventInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_soundInfoInitCL(dStage_dt_c*, void*, int, void*);\nstatic int dStage_RoomCameraInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_lbnkInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_actorCommonLayerInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_roomTresureInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_tgscCommonLayerInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_mapEventInfoInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_fieldMapTresureInit(dStage_dt_c*, void*, int, void*);\nstatic int dStage_fieldMapFiliInfo2Init(dStage_dt_c*, void*, int, void*);\nstatic int dStage_fieldMapMapPathInit(dStage_dt_c*, void*, int, void*);\n\ns8 dStage_roomRead_dt_c_GetReverbStage(roomRead_class&, int);\nint dStage_changeScene(int i_exitId, f32 i_speed, u32 i_mode, s8 i_roomNo, s16 i_angle, int i_layerOverride);\nvoid dStage_infoCreate();\nu8 dStage_stagInfo_GetParticleNo(stage_stag_info_class* p_info, int layer);\nint dStage_changeSceneExitId(cBgS_PolyInfo& param_0, f32 speed, u32 mode, s8 roomNo, s16 angle);\nint dStage_changeScene4Event(int i_exitId, s8 room_no, int i_wipe, bool param_3, f32 speed,\n                             u32 mode, s16 angle, int param_7);\nvoid dStage_Create();\nstatic s32 dStage_stagInfo_GetSaveTbl(stage_stag_info_class* param_0);\nvoid dStage_restartRoom(u32 roomParam, u32 mode, int param_2);\nclass cBgS_GndChk;\nint dStage_RoomCheck(cBgS_GndChk* gndChk);\nvoid dStage_dt_c_roomReLoader(void* i_data, dStage_dt_c* stageDt, int param_2);\nvoid dStage_dt_c_roomLoader(void* i_data, dStage_dt_c* stageDt, int param_2);\ndStage_KeepDoorInfo* dStage_GetKeepDoorInfo();\ndStage_KeepDoorInfo* dStage_GetRoomKeepDoorInfo();\n\ninline bool dStage_roomRead_dt_c_ChkBg(u8 param_0) {\n    return param_0 & 0x80;\n}\n\ninline s32 dStage_roomRead_dt_c_GetVrboxswitch(roomRead_data_class& data) {\n    return data.field_0x2 & 8;\n}\n\ninline s32 dStage_roomRead_dt_c_GetTimePass(roomRead_data_class& data) {\n    return data.field_0x2 & 3;\n}\n\ninline u8 dStage_roomRead_dt_c_GetLoadRoomIndex(u8 param_0) {\n    return param_0 & 0x3f;\n}\n\ninline u8 dStage_roomRead_dt_c_GetReverb(roomRead_data_class& room) {\n    return room.field_0x1 & 0x7F;\n}\n\ninline u32 dStage_stagInfo_GetSTType(stage_stag_info_class* pstag) {\n    return (pstag->field_0x0c >> 16) & 7;\n}\n\ninline int dStage_stagInfo_GetEscapeWarp(stage_stag_info_class* pstag) {\n    return (pstag->field_0x10 >> 24);\n}\n\ninline u32 dStage_stagInfo_GetMiniMap(stage_stag_info_class* pstag) {\n    return (pstag->field_0x0a >> 0xD) & 7;\n}\n\ninline u8 dStage_stagInfo_GetParticleNo(stage_stag_info_class* p_info) {\n    return (p_info->field_0x0a >> 0x3) & 0xFF;\n}\n\ninline s16 dStage_stagInfo_GetUpButton(stage_stag_info_class* p_info) {\n    return p_info->field_0x0a & 7;\n}\n\ninline u32 dStage_stagInfo_GetArg0(stage_stag_info_class* p_info) {\n    return (p_info->field_0x0c >> 0x14) & 0xFF;\n}\n\ninline int dStage_stagInfo_GetMsgGroup(stage_stag_info_class* p_info) {\n    return p_info->mMsgGroup;\n}\n\ninline s32 i_dStage_stagInfo_GetSaveTbl(stage_stag_info_class* param_0) {\n    return param_0->field_0x09 >> 1 & 0x1f;\n}\n\ninline s8 dStage_stagInfo_GetTimeH(stage_stag_info_class* p_info) {\n    return (p_info->field_0x0c >> 8) & 0xFF;\n}\n\ninline BOOL dStage_staginfo_GetArchiveHeap(stage_stag_info_class* p_info) {\n    return p_info->field_0x0a & 0x1000;\n}\n\ninline int dStage_stagInfo_GetGapLevel(stage_stag_info_class* pstag) {\n    return pstag->mGapLevel;\n}\n\ninline int dStage_stagInfo_GetRangeUp(stage_stag_info_class* pstag) {\n    return pstag->mRangeUp;\n}\n\ninline int dStage_stagInfo_GetRangeDown(stage_stag_info_class* pstag) {\n    return pstag->mRangeDown;\n}\n\ninline u32 dStage_stagInfo_ChkKeyDisp(stage_stag_info_class* pstag) {\n    return pstag->field_0x09 & 1;\n}\n\ninline u8 dStage_stagInfo_GetWolfDashType(stage_stag_info_class* pstag) {\n    return (pstag->field_0x09 >> 6) & 3;\n}\n\ninline u32 dStage_sclsInfo_getSceneLayer(stage_scls_info_class* p_info) {\n    return p_info->field_0xb & 0xF;\n}\n\ninline s32 dStage_sclsInfo_getWipe(stage_scls_info_class* p_info) {\n    return p_info->mWipe;\n}\n\ninline s32 dStage_sclsInfo_getWipeTime(stage_scls_info_class* p_info) {\n    return (p_info->field_0xb >> 5) & 7;\n}\n\ninline int dStage_sclsInfo_getTimeH(stage_scls_info_class* p_info) {\n    return (u8)((p_info->field_0xa >> 4) & 0xF) | (p_info->field_0xb & 0x10 & ~0xF);\n}\n\ninline u32 dStage_FileList_dt_getMiniMap(dStage_FileList_dt_c* p_fList) {\n    return p_fList->mParameters >> 3 & 7;\n}\n\ninline u32 dStage_FileList_dt_GetEnemyAppear1Flag(dStage_FileList_dt_c* p_fList) {\n    return p_fList->mParameters & 0x20000000;\n}\n\ninline int dStage_FileList_dt_GetBitSw(dStage_FileList_dt_c* p_fList) {\n    return p_fList->mBitSw;\n}\n\ninline f32 dStage_FileList_dt_SeaLevel(dStage_FileList_dt_c* p_fList) {\n    return p_fList->mSeaLevel;\n}\n\ninline int dStage_FileList_dt_GlobalWindLevel(dStage_FileList_dt_c* i_fili) {\n    return (i_fili->mParameters >> 0x12) & 3;\n}\n\ninline int dStage_FileList_dt_GlobalWindDir(dStage_FileList_dt_c* i_fili) {\n    return (i_fili->mParameters >> 0xF) & 7;\n}\n\ninline f32 dStage_FileList2_dt_GetLeftRmX(dStage_FileList2_dt_c* p_fList2) {\n    return p_fList2->mLeftRmX;\n}\n\ninline f32 dStage_FileList2_dt_GetRightRmX(dStage_FileList2_dt_c* p_fList2) {\n    return p_fList2->mRightRmX;\n}\n\ninline f32 dStage_FileList2_dt_GetInnerRmZ(dStage_FileList2_dt_c* p_fList2) {\n    return p_fList2->mInnerRmZ;\n}\n\ninline f32 dStage_FileList2_dt_GetFrontRmZ(dStage_FileList2_dt_c* p_fList2) {\n    return p_fList2->mFrontRmZ;\n}\n\ninline s8 dStage_FileList2_dt_GetMinFloorNo(dStage_FileList2_dt_c* p_fList2) {\n    return p_fList2->mMinFloorNo;\n}\n\ninline s8 dStage_FileList2_dt_GetMaxFloorNo(dStage_FileList2_dt_c* p_fList2) {\n    return p_fList2->mMaxFloorNo;\n}\n\ninline int dStage_MapEvent_dt_c_getEventSCutSW(dStage_MapEvent_dt_c* event) {\n    return event->field_0x8 & 1;\n}\n\ninline int dStage_MapEvent_dt_c_getEventSCutType(dStage_MapEvent_dt_c* event) {\n    return event->field_0x8 >> 1 & 3;\n}\n\ninline int dStage_lbnkWIND(dStage_Lbnk_dt_c* i_data) {\n    return (i_data->field_0x2 >> 3) & 7;\n}\n\ninline int dStage_lbnkWlevel(dStage_Lbnk_dt_c* i_data) {\n    return (i_data->field_0x2 >> 6) & 3;\n}\n\n#endif /* D_D_STAGE_H */\n/* end \"d/d_stage.h\" */\n/* \"include/d/d_camera.h\" line 8 \"dolphin/gx/GXStruct.h\" */\n/* end \"dolphin/gx/GXStruct.h\" */\n/* \"include/d/d_camera.h\" line 9 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nclass fopAc_ac_c;\n\nstruct dCamMapToolData {\n    /* 8015FEB8 */ void Set(s32, s32, fopAc_ac_c*, u16, u8);\n\n    /* 0x00 */ stage_camera2_data_class field_0x0;\n    /* 0x18 */ stage_arrow_data_class field_0x18;\n    /* 0x2C */ u32 field_0x2c;\n    /* 0x30 */ s32 field_0x30;\n    /* 0x34 */ fopAc_ac_c* field_0x34;\n    /* 0x38 */ u16 field_0x38;\n    /* 0x3A */ u8 field_0x3a;\n    /* 0x3B */ u8 field_0x3b;\n};\n\nstruct dCamForcusLine : public dDlst_effectLine_c {\n    /* 801824C8 */ void Init();\n    /* 80182560 */ void Draw();\n    /* 801825E4 */ void Off();\n\n    /* 0x38 */ cXyz field_0x38;\n    /* 0x44 */ GXColor field_0x44;\n    /* 0x48 */ u8 field_0x48;\n    /* 0x49 */ u8 field_0x49;\n    /* 0x4C */ int field_0x4c;\n    /* 0x50 */ int field_0x50;\n    /* 0x54 */ int field_0x54;\n    /* 0x58 */ u16 field_0x58;\n    /* 0x5A */ u16 field_0x5a;\n    /* 0x5C */ u16 field_0x5c;\n    /* 0x5E */ u16 field_0x5e;\n    /* 0x60 */ f32 field_0x60;\n    /* 0x64 */ f32 field_0x64;\n    /* 0x68 */ f32 field_0x68;\n    /* 0x6C */ f32 field_0x6c;\n};\n\nstruct dCamera_FakeAngle_system {\n    /* 0x0 */ u8 field_0x0;\n    /* 0x2 */ cSAngle field_0x2;\n    /* 0x4 */ cSAngle field_0x4;\n};\n\nstruct dCamera_monitoring_things {\n    /* 0x00 */ cXyz field_0x0;\n    /* 0x0C */ u8 field_0xc[8];\n    /* 0x14 */ cXyz field_0x14;\n};\n\nstruct d2DBSplinePath {\n    /* 0x00 */ s32 field_0x0;\n    /* 0x04 */ s32 field_0x4;\n    /* 0x08 */ s32 field_0x8;\n    /* 0x0C */ s32 field_0xc;\n    /* 0x10 */ f32 field_0x10;\n    /* 0x14 */ f32 field_0x14;\n    /* 0x18 */ f32 field_0x18;\n    /* 0x1C */ f32 field_0x1c;\n    /* 0x20 */ u32 field_0x20;\n    /* 0x24 */ u32 field_0x24;\n    /* 0x28 */ u32 field_0x28;\n    /* 0x2C */ u32 field_0x2c;\n\n    /* 80097878 */ void Init(s32, s32);\n    /* 80097B68 */ void Spot(f32*, f32);\n    /* 801828D4 */ virtual ~d2DBSplinePath();\n};\n\nstruct dCamera_event_param {\n    /* 0x00 */ char name[16];\n    /* 0x10 */ int field_0x10;\n    /* 0x14 */ int value;\n};\n\nstruct dCamera_event_data {\n    /* 0x000 */ u8 field_0x0;\n    /* 0x004 */ int field_0x4;\n    /* 0x008 */ int field_0x8;\n    /* 0x00C */ int field_0xc;\n    /* 0x010 */ u8 field_0x10;\n    /* 0x014 */ int field_0x14;\n    /* 0x018 */ int field_0x18;\n    /* 0x01C */ int field_0x1c;\n    /* 0x020 */ int field_0x20;\n    /* 0x024 */ int field_0x24;\n    /* 0x028 */ u8 field_0x28[0x2C - 0x28];\n    /* 0x02C */ dCamera_event_param mEventParams[8];\n    /* 0x0EC */ dStage_MapEvent_dt_c* field_0xec;\n    /* 0x0F0 */ d2DBSplinePath field_0xf0;\n};  // Size: 0x124\n\nstruct dCamera_type_data {\n    /* 0x00 */ char name[24];\n    /* 0x18 */ s16 field_0x18[2][11];\n};  // Size: 0x44\n\nclass camera_class;\n\nclass dCamera_c;\ntypedef bool (dCamera_c::*engine_fn)(s32);\n\nclass dCamera_c {\npublic:\n    class dCamInfo_c {\n    public:\n        /* 8018291C */ dCamInfo_c();\n        /* 80182920 */ ~dCamInfo_c();\n\n    private:\n        /* 0x00 */ cXyz field_0x0;\n        /* 0x0C */ cXyz field_0xc;\n        /* 0x18 */ f32 field_0x18;\n        /* 0x1C */ cSAngle field_0x1c;\n        /* 0x1E */ s16 field_0x1e;\n    };  // Size: 0x20\n\n    struct dCamera_pad_info {\n        struct _stick {\n            /* 0x00 */ f32 mLastPosX;\n            /* 0x04 */ f32 mLastPosY;\n            /* 0x08 */ f32 mLastValue;\n            /* 0x0C */ f32 mPosXDelta;\n            /* 0x10 */ f32 mPosYDelta;\n            /* 0x14 */ f32 mValueDelta;\n            /* 0x18 */ cSAngle field_0x18;\n        };\n\n        /* 0x00 */ _stick mMainStick;\n        /* 0x1C */ _stick mCStick;\n    };\n\n    struct BG {\n        /* 0x000 */ u8 field_0x0;\n        /* 0x004 */ dBgS_CamGndChk field_0x4;\n        /* 0x058 */ f32 field_0x58;\n        /* 0x05C */ u8 field_0x5c;\n        /* 0x060 */ dBgS_CamGndChk field_0x60;\n        /* 0x0B4 */ f32 field_0xb4;\n        /* 0x0B8 */ u8 field_0xb8[0xC0 - 0xB8];\n        /* 0x0C0 */ u8 field_0xc0;\n        /* 0x0C1 */ u8 field_0xc1;\n        /* 0x0C4 */ cXyz field_0xc4;\n        /* 0x0D0 */ cXyz field_0xd0;\n        /* 0x0DC */ cSAngle field_0xdc;\n        /* 0x0DE */ cSAngle field_0xde;\n        /* 0x0E0 */ cSGlobe field_0xe0;\n        /* 0x0E8 */ cSGlobe field_0xe8;\n        /* 0x0F0 */ u8 field_0xf0[4];\n        /* 0x0F4 */ int field_0xf4;\n        /* 0x0F8 */ f32 field_0xf8;\n        /* 0x0FC */ int field_0xfc;\n        /* 0x100 */ int field_0x100;\n        /* 0x104 */ u8 field_0x104[4];\n        /* 0x108 */ int field_0x108;\n        /* 0x10C */ f32 field_0x10c;\n        /* 0x110 */ cXyz field_0x110;\n    };\n\n    struct Shake {\n        /* 0x00 */ u8 field_0x0[12];\n        /* 0x0C */ int field_0xc;\n        /* 0x10 */ int field_0x10;\n        /* 0x14 */ u8 field_0x14[4];\n        /* 0x18 */ cXyz field_0x18;\n        /* 0x24 */ cXyz field_0x24;\n        /* 0x30 */ cXyz field_0x30;\n        /* 0x3C */ f32 field_0x3c;\n        /* 0x40 */ cSAngle field_0x40;\n    };  // Size: 0x44\n\n    /* 80088A7C */ int StartEventCamera(int, int, ...);\n    /* 80088BBC */ int EndEventCamera(int);\n    /* 80088C24 */ int searchEventArgData(char*);\n    /* 8008908C */ void getEvIntData(int*, char*, int);\n    /* 80088CB0 */ void getEvIntData(int*, char*);\n    /* 80088D90 */ void getEvFloatData(f32*, char*);\n    /* 80089154 */ void getEvFloatData(f32*, char*, f32);\n    /* 80088E58 */ void getEvFloatListData(f32**, char*);\n    /* 80088F1C */ void getEvXyzListData(cXyz**, char*);\n    /* 8008941C */ void getEvStringPntData(char*, char*);\n    /* 80088FE0 */ void getEvStringPntData(char*);\n    /* 8008922C */ void getEvXyzData(cXyz*, char*, cXyz);\n    /* 8008933C */ void getEvStringData(char*, char*, char*);\n    /* 800894C4 */ void getEvActor(char*);\n    /* 800895F4 */ void getEvActor(char*, char*);\n    /* 80089730 */ void pauseEvCamera();\n    /* 800897E8 */ void fixedFrameEvCamera();\n    /* 8008A510 */ void stokerEvCamera();\n    /* 8008A974 */ void rollingEvCamera();\n    /* 8008B9B0 */ void fixedPositionEvCamera();\n    /* 8008BE2C */ void uniformTransEvCamera();\n    /* 8008BE50 */ void uniformBrakeEvCamera();\n    /* 8008BE74 */ void uniformAcceleEvCamera();\n    /* 8008BE98 */ void transEvCamera(int);\n    /* 8008E938 */ void watchActorEvCamera();\n    /* 8008FAE8 */ void restorePosEvCamera();\n    /* 80090174 */ void talktoEvCamera();\n    /* 80090230 */ bool maptoolIdEvCamera();\n    /* 80090478 */ void styleEvCamera();\n    /* 80090514 */ void gameOverEvCamera();\n    /* 80091468 */ void tactEvCamera();\n    /* 800923B8 */ bool turnToActorEvCamera();\n    /* 800923C0 */ void stbWaitEvCamera();\n    /* 800924D0 */ void saveEvCamera();\n    /* 8009258C */ void loadEvCamera();\n    /* 800929AC */ void useItem0EvCamera();\n    /* 800937AC */ void useItem1EvCamera();\n    /* 80094240 */ void getItemEvCamera();\n    /* 80094A70 */ void possessedEvCamera();\n    /* 80095010 */ void fixedFramesEvCamera();\n    /* 8009544C */ void bSplineEvCamera();\n    /* 800956E4 */ void twoActor0EvCamera();\n    /* 80095E7C */ void peepHoleEvCamera();\n    /* 80095FD0 */ void digHoleEvCamera();\n    /* 800965AC */ void hintTalkEvCamera();\n    /* 80096EDC */ void bspTransEvCamera();\n    /* 80097694 */ bool portalWarpEvCamera();\n    /* 8009771C */ void attentionPos(fopAc_ac_c*);\n    /* 80097738 */ void directionOf(fopAc_ac_c*);\n    /* 8009775C */ void positionOf(fopAc_ac_c*);\n    /* 80097778 */ void setFlag(u32);\n    /* 8009778C */ void eyePos(fopAc_ac_c*);\n    /* 8016008C */ dCamera_c(camera_class*);\n    /* 80160304 */ ~dCamera_c();\n    /* 80160470 */ void initialize(camera_class*, fopAc_ac_c*, u32, u32);\n    /* 801614AC */ void Start();\n    /* 801614C4 */ void QuickStart();\n    /* 801614D0 */ void Stop();\n    /* 801614E8 */ void Stay();\n    /* 801614F4 */ u8 ChangeModeOK(s32);\n    /* 80161550 */ void initPad();\n    /* 801617B0 */ void updatePad();\n    /* 80161D84 */ void initMonitor();\n    /* 80161E34 */ void updateMonitor();\n    /* 80162088 */ void checkForceLockTarget();\n    /* 801622B0 */ void infoReport();\n    /* 801622B4 */ void Run();\n    /* 80162D38 */ void NotRun();\n    /* 80162FB8 */ void V();\n    /* 80162FD4 */ void U();\n    /* 8016300C */ void SetTrimSize(s32);\n    /* 80163028 */ void SetTrimTypeForce(s32);\n    /* 80163034 */ void CalcTrimSize();\n    /* 80163154 */ void Draw();\n    /* 8016317C */ void setStageMapToolData();\n    /* 80163340 */ void setMapToolData();\n    /* 80163558 */ void SetTagData(fopAc_ac_c*, s32, u16, u8);\n    /* 801635AC */ void setRoomMapToolData(dCamMapToolData*, s32, s32);\n    /* 801635E4 */ void nextMode(s32);\n    /* 80163C38 */ void onModeChange(s32, s32);\n    /* 80163D50 */ void ModeFix(s32);\n    /* 80163D5C */ void nextType(s32);\n    /* 8016444C */ void onTypeChange(s32, s32);\n    /* 8016469C */ void onStyleChange(s32, s32);\n    /* 801647B0 */ void onRoomChange(s32);\n    /* 80164878 */ void getParamTargetActor(s32);\n    /* 80164944 */ int GetCameraTypeFromMapToolID(s32, s32);\n    /* 80164B64 */ int GetCameraTypeFromCameraName(char const*);\n    /* 80164C10 */ void GetCameraTypeFromToolData(stage_camera2_data_class*);\n    /* 80164C64 */ void pushInfo(dCamera_c::dCamInfo_c*, s16);\n    /* 80164CAC */ void popInfo(dCamera_c::dCamInfo_c*);\n    /* 80164D2C */ void heightOf(fopAc_ac_c*);\n    /* 80164E20 */ void relationalPos(fopAc_ac_c*, fopAc_ac_c*, cXyz*, f32);\n    /* 80164D6C */ void relationalPos(fopAc_ac_c*, cXyz*);\n    /* 80165104 */ void setUSOAngle();\n    /* 80165158 */ void getUSOAngle(cSAngle);\n    /* 8016517C */ void pointInSight(cXyz*);\n    /* 80167C24 */ void radiusActorInSight(fopAc_ac_c*, fopAc_ac_c*, fopAc_ac_c*);\n    /* 80165238 */ void radiusActorInSight(fopAc_ac_c*, fopAc_ac_c*, cXyz*, cXyz*, f32, s16, f32);\n    /* 801657EC */ void groundHeight(cXyz*);\n    /* 801658C0 */ void lineBGCheck(cXyz*, cXyz*, dBgS_LinChk*, u32);\n    /* 80165AF0 */ void lineBGCheck(cXyz*, cXyz*, u32);\n    /* 801659F4 */ void lineBGCheck(cXyz*, cXyz*, cXyz*, u32);\n    /* 80165B60 */ void lineCollisionCheckBush(cXyz*, cXyz*);\n    /* 80165CE0 */ void compWallMargin(cXyz*, cXyz*, f32);\n    /* 80165EF4 */ void defaultTriming();\n    /* 80165FB4 */ void setView(f32, f32, f32, f32);\n    /* 8016608C */ void forwardCheckAngle();\n    /* 80166764 */ void bumpCheck(u32);\n    /* 80167BF8 */ void lineBGCheckBoth(cXyz*, cXyz*, dBgS_LinChk*, u32);\n    /* 80167CD8 */ void jutOutCheck(cXyz*, f32);\n    /* 80167E3C */ void tooNearEscape(cXyz*);\n    /* 80167EF4 */ void getWaterSurfaceHeight(cXyz*);\n    /* 80167FEC */ void checkGroundInfo();\n    /* 80168744 */ bool chaseCamera(s32);\n    /* 8016C384 */ bool lockonCamera(s32);\n    /* 8016E448 */ void getMsgCmdSpeaker();\n    /* 8016E4A4 */ void getMsgCmdCut(s32);\n    /* 8016E4F4 */ bool talktoCamera(s32);\n    /* 80174E18 */ void talkBasePos(fopAc_ac_c*);\n    /* 80174E34 */ void talkEyePos(fopAc_ac_c*);\n    /* 80174EA4 */ bool CalcSubjectAngle(s16*, s16*);\n    /* 80174EAC */ void SaveZoomRatio();\n    /* 80174ED4 */ bool subjectCamera(s32);\n    /* 80176074 */ bool magneCamera(s32);\n    /* 801767F8 */ bool colosseumCamera(s32);\n    /* 80176DF0 */ bool test1Camera(s32);\n    /* 80176DF8 */ bool test2Camera(s32);\n    /* 80176E00 */ bool towerCamera(s32);\n    /* 80178E50 */ bool hookshotCamera(s32);\n    /* 80179590 */ bool railCamera(s32);\n    /* 8017A2A0 */ bool paraRailCamera(s32);\n    /* 8017ADC0 */ bool rideCamera(s32);\n    /* 8017D974 */ bool manualCamera(s32);\n    /* 8017D97C */ bool observeCamera(s32);\n    /* 8017DFAC */ bool fixedFrameCamera(s32);\n    /* 8017E730 */ bool fixedPositionCamera(s32);\n    /* 8017F25C */ bool oneSideCamera(s32);\n    /* 8017F828 */ bool eventCamera(s32);\n    /* 8018050C */ void currentEvCamera();\n    /* 801806D4 */ bool letCamera(s32);\n    /* 801806DC */ void setEventRecoveryTrans(s16);\n    /* 80180738 */ void runEventRecoveryTrans();\n    /* 80180A40 */ void EventRecoverNotime();\n    /* 80180AA8 */ void Set(cXyz, cXyz);\n    /* 80180AE0 */ void Set(cXyz, cXyz, f32, s16);\n    /* 80180B40 */ void Set(cXyz, cXyz, s16, f32);\n    /* 80180C18 */ void Reset(cXyz, cXyz);\n    /* 80180C68 */ void Reset();\n    /* 80180BA0 */ void Reset(cXyz, cXyz, f32, s16);\n    /* 80180D24 */ void shakeCamera();\n    /* 80181000 */ void StartShake(s32, u8*, s32, cXyz);\n    /* 80181158 */ void StopShake();\n    /* 80181170 */ void StartBlure(int, fopAc_ac_c*, f32, f32);\n    /* 801811B8 */ void ResetBlure();\n    /* 80181208 */ void SetBlureAlpha(f32);\n    /* 80181210 */ void SetBlureScale(f32, f32, f32);\n    /* 80181220 */ void SetBlurePosition(f32, f32, f32);\n    /* 80181278 */ void SetBlureActor(fopAc_ac_c*);\n    /* 80181280 */ void blureCamera();\n    /* 80181490 */ void onHorseDush();\n    /* 80181500 */ void GetForceLockOnActor();\n    /* 80181534 */ void ForceLockOn(fopAc_ac_c*);\n    /* 80181560 */ void ForceLockOff(unsigned int);\n    /* 8018159C */ void ForceLockOff(fopAc_ac_c*);\n    /* 80181E20 */ void Up();\n    /* 80181E64 */ cXyz Eye();\n    /* 80181E98 */ cXyz Center();\n    /* 8018295C */ void footHeightOf(fopAc_ac_c*);\n    /* 80182964 */ void push_any_key();\n    /* 8018296C */ void clrFlag(u32);\n    /* 80182980 */ void chkFlag(u32);\n    /* 801829AC */ void Bank();\n\n    bool Active() { return field_0x24 == 0; }\n    f32 TrimHeight() { return mTrimHeight; }\n    int Type() { return mCurType; }\n\n    bool i_chkFlag(u32 i_flag) { return mEventFlags & i_flag; }\n    void i_setFlag(u32 i_flag) { mEventFlags |= i_flag; }\n    void i_clrFlag(u32 i_flag) { mEventFlags &= ~i_flag; }\n\n#ifdef NONMATCHING\n    static engine_fn engine_tbl[];\n#else\n    static u8 engine_tbl[240];\n#endif\n\n    /* 0x000 */ camera_class* field_0x0;\n    /* 0x004 */ int mRoomNo;\n    /* 0x008 */ u8 field_0x8[0x20 - 0x8];\n    /* 0x020 */ u8 field_0x20;\n    /* 0x021 */ u8 field_0x21;\n    /* 0x022 */ u8 field_0x22[2];\n    /* 0x024 */ int field_0x24;\n    /* 0x028 */ f32 field_0x28;\n    /* 0x02C */ s16 field_0x2c;\n    /* 0x02E */ s16 field_0x2e;\n    /* 0x030 */ cXyz mCenter;\n    /* 0x03C */ cXyz mEye;\n    /* 0x048 */ cXyz mUp;\n    /* 0x054 */ cSAngle mBank;\n    /* 0x058 */ f32 mFovY;\n    class {\n    public:\n        /* 0x00 */ cSGlobe field_0x0;\n        /* 0x08 */ cXyz field_0x8;\n        /* 0x14 */ cXyz field_0x14;\n        /* 0x20 */ cSAngle field_0x20;\n    }\n    /* 0x05C */ field_0x5c;\n    /* 0x080 */ f32 field_0x80;\n    /* 0x084 */ f32 field_0x84;\n    /* 0x088 */ u32 field_0x88;\n    /* 0x08C */ cSAngle field_0x8c;\n    /* 0x090 */ cXyz field_0x90;\n    /* 0x09C */ cXyz field_0x9c;\n    /* 0x0A8 */ int field_0xa8;\n    /* 0x0AC */ u32 field_0xac;\n    /* 0x0B0 */ dCamInfo_c field_0xb0;\n    /* 0x0D0 */ u8 field_0xd0[0x8];\n    /* 0x0D8 */ cXyz field_0xd8;\n    /* 0x0E4 */ u8 field_0xe4[0xc];\n    /* 0x0F0 */ dCamInfo_c field_0xf0;\n    class {\n    public:\n        /* 0x00 */ int field_0x0;\n        /* 0x04 */ u16 field_0x4;\n        /* 0x08 */ dCamInfo_c field_0x8;\n        /* 0x28 */ cXyz field_0x28;\n    }\n    /* 0x110 */ field_0x110;\n    class {\n    public:\n        /* 0x0 */ cXyz field_0x0;\n        /* 0xC */ csXyz field_0xc;\n    }\n    /* 0x144 */ field_0x144;\n    class {\n    public:\n        /* 0x0 */ u8 field_0x0;\n        /* 0x2 */ cSAngle field_0x2;\n        /* 0x4 */ cSAngle field_0x4;\n    }\n    /* 0x158 */ field_0x158;\n    /* 0x160 */ int field_0x160;\n    /* 0x164 */ u8 field_0x164[0x170 - 0x164];\n    /* 0x170 */ int field_0x170;\n    /* 0x174 */ u32 mCurCamTypeTimer;\n    /* 0x178 */ u32 mCameraID;\n    /* 0x17C */ u32 mPadID;\n    /* 0x180 */ fopAc_ac_c* mpPlayerActor;\n    /* 0x184 */ fopAc_ac_c* mpLockonTarget;\n    /* 0x188 */ u8 field_0x188[0x190 - 0x188];\n    /* 0x190 */ int field_0x190;\n    /* 0x194 */ u8 field_0x194;\n    /* 0x198 */ u32 field_0x198;\n    /* 0x19C */ u32 field_0x19c;\n    /* 0x1A0 */ int mCurMode;\n    /* 0x1A4 */ int mNextMode;\n    /* 0x1A8 */ int field_0x1a8;\n    /* 0x1AC */ int field_0x1ac;\n    /* 0x1B0 */ cSAngle field_0x1b0;\n    /* 0x1B4 */ f32 field_0x1b4;\n    /* 0x1B8 */ u8 field_0x1b8[4];\n    /* 0x1BC */ dCamera_pad_info mPadInfo;\n    /* 0x1F4 */ u8 field_0x1f4[0x200 - 0x1F4];\n    /* 0x200 */ f32 mTriggerLeftLast;\n    /* 0x204 */ f32 mTriggerLeftDelta;\n    /* 0x208 */ u8 field_0x208;\n    /* 0x209 */ u8 field_0x209;\n    /* 0x20A */ u8 field_0x20a;\n    /* 0x20B */ u8 field_0x20b;\n    /* 0x20C */ f32 mTriggerRightLast;\n    /* 0x210 */ f32 mTriggerRightDelta;\n    /* 0x214 */ u8 field_0x214;\n    /* 0x215 */ u8 field_0x215;\n    /* 0x216 */ u8 field_0x216;\n    /* 0x217 */ u8 field_0x217;\n    /* 0x218 */ u8 mHoldX;\n    /* 0x219 */ u8 mTrigX;\n    /* 0x21A */ u8 mHoldY;\n    /* 0x21B */ u8 mTrigY;\n    /* 0x21C */ u8 mHoldZ;\n    /* 0x21D */ u8 mTrigZ;\n    /* 0x21E */ u8 field_0x21e;\n    /* 0x21F */ u8 field_0x21f;\n    /* 0x220 */ u8 mHoldB;\n    /* 0x221 */ u8 mTrigB;\n    /* 0x222 */ u8 field_0x222;\n    /* 0x223 */ u8 field_0x223;\n    /* 0x224 */ u8 field_0x224;\n    /* 0x228 */ dCamForcusLine mFocusLine;\n    /* 0x298 */ dCamera_FakeAngle_system mFakeAngleSys;\n    /* 0x2A0 */ dCamera_monitoring_things mMonitor;\n    /* 0x2C0 */ f32 field_0x2c0;\n    /* 0x2C4 */ int field_0x2c4;\n    /* 0x2C8 */ f32 field_0x2c8;\n    /* 0x2CC */ BG mBG;\n    /* 0x3E8 */ u8 field_0x3e8;\n    /* 0x3E9 */ u8 field_0x3e9[0x4e8 - 0x3e9];\n    /* 0x4E8 */ dCamera_event_data mEventData;\n    /* 0x60C */ u32 mEventFlags;\n    /* 0x610 */ u8 field_0x610;\n    /* 0x611 */ u8 field_0x611;\n    /* 0x612 */ u8 field_0x612[2];\n    class {\n    public:\n        /* 0x00 */ u8 field_0x0[8];\n        /* 0x08 */ cSGlobe field_0x8;\n        /* 0x10 */ u8 field_0x10[4];\n    }\n    /* 0x614 */ field_0x614[4];\n    /* 0x664 */ u8 field_0x664[4];\n    /* 0x668 */ int field_0x668;\n    /* 0x66C */ int field_0x66c;\n    /* 0x670 */ int field_0x670;\n    /* 0x674 */ int field_0x674;\n    /* 0x678 */ int field_0x678;\n    /* 0x67C */ int mCamStyle;\n    /* 0x680 */ int field_0x684;\n    /* 0x684 */ dCamera_type_data* mCamTypeData;\n    /* 0x688 */ int mCamTypeNum;\n    /* 0x68C */ int mCurType;\n    /* 0x690 */ int mNextType;\n    /* 0x694 */ int mMapToolType;\n    /* 0x698 */ int field_0x698;\n    /* 0x69C */ int field_0x69c;\n    /* 0x6A0 */ u8 field_0x6a0[0x6b8 - 0x6a0];\n    /* 0x6B8 */ Shake mShake;\n    /* 0x6FC */ int field_0x6fc;\n    class {\n    public:\n        /* 0x00 */ u8 field_0x0[4];\n        /* 0x04 */ int field_0x4;\n        /* 0x08 */ csXyz field_0x8;\n        /* 0x10 */ fopAc_ac_c* field_0x10;\n        /* 0x14 */ int field_0x14;\n        /* 0x18 */ cXyz mBlurePosition;\n        /* 0x24 */ cXyz mBlureScale;\n    }\n    /* 0x700 */ field_0x700;\n    /* 0x730 */ f32 mBlureAlpha;\n    /* 0x734 */ f32 field_0x734;\n    /* 0x738 */ f32 field_0x738;\n    /* 0x73C */ f32 field_0x73c;\n    class {\n    public:\n        /* 0x00 */ cXyz field_0x0;\n        /* 0x0C */ cXyz field_0xc;\n        /* 0x18 */ cXyz field_0x18;\n        /* 0x24 */ cSGlobe field_0x24;\n    }\n    /* 0x740 */ field_0x740;\n    /* 0x76C */ u8 field_0x76c[0x79c - 0x76c];\n    class {\n    public:\n        /* 0x0 */ u8 field_0x0[4];\n        /* 0x4 */ cXyz field_0x4;\n    }\n    /* 0x79C */ field_0x79c;\n    /* 0x7AC */ dCamMapToolData field_0x7ac;\n    /* 0x7E8 */ dCamMapToolData field_0x7e8;\n    /* 0x824 */ dCamMapToolData field_0x824;\n    /* 0x860 */ dCamMapToolData field_0x860;\n    /* 0x89C */ dCamMapToolData field_0x89c;\n    /* 0x8D8 */ dCamMapToolData field_0x8d8;\n    /* 0x914 */ u8 field_0x914[0x91c - 0x914];\n    /* 0x91C */ f32 field_0x91c;\n    /* 0x920 */ f32 mTrimHeight;\n    /* 0x924 */ int mTrimSize;\n    /* 0x928 */ int mTrimTypeForce;\n    /* 0x92C */ u8 field_0x92c[0x93C - 0x92c];\n    /* 0x93C */ f32 field_0x93c;\n    /* 0x940 */ u8 field_0x940[0x970 - 0x940];\n    /* 0x970 */ dCamSetup_c mCamSetup;\n    /* 0xAEC */ dCamParam_c mCamParam;\n    /* 0xB0C */ u8 field_0xb0c[0xd58 - 0xb0c];\n};  // Size: 0xD58\n\ndCamera_c* dCam_getBody();\ndCamera_c* dCam_getCamera();\ns16 dCam_getControledAngleY(camera_class* param_0);\n\n#endif /* D_D_CAMERA_H */\n/* end \"d/d_camera.h\" */\n/* \"include/f_op/f_op_camera_mng.h\" line 5 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n/* \"include/f_op/f_op_camera_mng.h\" line 6 \"f_op/f_op_view.h\" */\n/* end \"f_op/f_op_view.h\" */\n\ntypedef struct leafdraw_method_class leafdraw_method_class;\n\nclass camera_process_class : public view_class {\npublic:\n    /* 0x210 */ create_tag_class mCreateTag;\n    /* 0x224 */ leafdraw_method_class* mpMtd;\n    /* 0x228 */ u8 field_0x228[4];\n    /* 0x22C */ s8 mPrm1;\n    /* 0x22D */ s8 mPrm2;\n    /* 0x22E */ s8 mPrm3;\n    /* 0x22F */ s8 field_0x22f;\n    /* 0x230 */ csXyz mAngle;\n    /* 0x238 */ int field_0x238;\n};\n\nclass camera_class : public camera_process_class {\npublic:\n    /* 0x23C */ int field_0x23c;\n    /* 0x240 */ request_of_phase_process_class mPhaseReq;\n    /* 0x248 */ dCamera_c mCamera;\n};\n\n/* void fopCamM_SetNear(camera_class* cam, f32 near) {\n    cam->mNear = near;\n}\n\nvoid fopCamM_SetFar(camera_class* cam, f32 far) {\n    cam->mFar = far;\n}\n\nvoid fopCamM_SetFovy(camera_class* cam, f32 fovy) {\n    cam->mFovy = fovy;\n}\n\nvoid fopCamM_SetAspect(camera_class* cam, f32 aspect) {\n    cam->mAspect = aspect;\n}\n\nvoid fopCamM_SetEye(camera_class* cam, f32 x, f32 y, f32 z) {\n    cam->field_0xd8.mEye.set(x, y, z);\n}\n\nvoid fopCamM_SetCenter(camera_class* cam, f32 x, f32 y, f32 z) {\n    cam->field_0xd8.mCenter.set(x, y, z);\n}\n\nvoid fopCamM_SetBank(camera_class* cam, s16 bank) {\n    cam->mBank = bank;\n} */\n\ninline s16 fopCamM_GetAngleY(camera_class* i_camera) {\n    return i_camera->mAngle.y;\n}\n\ninline f32 fopCamM_GetFovy(camera_class* i_camera) {\n    return i_camera->mFovy;\n}\n\nu32 fopCamM_Create(int i_cameraIdx, s16 pProcName, void* param_3);\nvoid fopCamM_Management(void);\nu32 fopCamM_GetParam(camera_class* pCamera);\nvoid fopCamM_Init(void);\n\n#endif/* end \"f_op/f_op_camera_mng.h\" */\n/* \"include/d/com/d_com_inf_game.h\" line 12 \"global.h\" */\n/* end \"global.h\" */\n\nclass JKRAramArchive;\nclass dSmplMdl_draw_c;\nclass dTimer_c;\nclass daPy_py_c;\nclass scene_class;\n\nclass __d_timer_info_c {\npublic:\n    __d_timer_info_c() {\n        mTimerMode = -1;\n        mTimerLimitTimeMs = 0;\n        mTimerNowTimeMs = 0;\n        mTimerPtr = NULL;\n    }\n    dTimer_c* mTimerPtr;\n    s32 mTimerNowTimeMs;\n    s32 mTimerLimitTimeMs;\n    s32 mTimerMode;\n    u8 mTimerType;\n};\n\nclass phaseParam_c {\npublic:\n    phaseParam_c(const char* name, JKRHeap* heap) {\n        mResName = name;\n        mpHeap = heap;\n    }\n\n    /* 0x0 */ const char* mResName;\n    /* 0x4 */ JKRHeap* mpHeap;\n};\n\nclass dComIfG_camera_info_class {\npublic:\n    dComIfG_camera_info_class() {}\n    ~dComIfG_camera_info_class() {}\n\n    /* 0x00 */ camera_class* mCamera;\n    /* 0x04 */ u8 field_0x4;\n    /* 0x05 */ u8 field_0x5;\n    /* 0x06 */ s8 field_0x6;\n    /* 0x07 */ u8 field_0x7;\n    /* 0x08 */ u32 mCameraAttentionStatus;\n    /* 0x0C */ f32 mCameraZoomScale;\n    /* 0x10 */ f32 mCameraZoomForcus;\n    /* 0x14 */ char* mCameraParamFileName;\n    /* 0x18 */ cXyz mCameraPos;\n    /* 0x24 */ cXyz mCameraTarget;\n    /* 0x30 */ f32 field_0x30;\n    /* 0x34 */ s16 field_0x34;\n};\nSTATIC_ASSERT(sizeof(dComIfG_camera_info_class) == 0x38);\n\nclass dComIfG_resLoader_c {\npublic:\n    /* 8002F314 */ dComIfG_resLoader_c();\n    /* 8002F328 */ ~dComIfG_resLoader_c();\n    /* 8002F3B4 */ int load(char const**, JKRHeap*);\n\nprivate:\n    /* 0x0 */ const char** field_0x0;\n    /* 0x4 */ request_of_phase_process_class field_0x4;\n    /* 0xC */ u8 field_0xc;\n};\n\nenum PlayerPtr { LINK_PTR, HORSE_PTR };\n\nclass daHorse_c;\nclass dPa_control_c;\nclass daAlink_c;\nclass dMsgObject_c;\nclass J2DOrthoGraph;\n\nclass dComIfG_play_c {\npublic:\n    dComIfG_play_c() { this->ct(); }\n    void ct();\n    void init();\n    void itemInit();\n    void setItemBombNumCount(u8 i_item, s16 count);\n    s16 getItemBombNumCount(u8 i_item);\n    void clearItemBombNumCount(u8 i_item);\n    void setNowVibration(u8 vib_status);\n    u32 getNowVibration();\n    void setStartStage(dStage_startStage_c* p_startStage);\n    static int getLayerNo_common_common(char const* stageName, int roomId, int layer);\n    static int getLayerNo_common(char const* stageName, int roomId, int layer);\n    static int getLayerNo(int);\n    void createParticle();\n    dSmplMdl_draw_c* createSimpleModel();\n    void deleteSimpleModel();\n    void drawSimpleModel();\n    int addSimpleModel(J3DModelData* i_modelData, int roomNo, u8 drawBG);\n    int removeSimpleModel(J3DModelData* i_modelData, int roomNo);\n    void entrySimpleModel(J3DModel* i_model, int roomNo);\n    void setTimerNowTimeMs(int time);\n    int getTimerNowTimeMs();\n    void setTimerLimitTimeMs(int time);\n    int getTimerLimitTimeMs();\n    void setTimerMode(int mode);\n    int getTimerMode();\n    void setTimerType(u8 type);\n    u8 getTimerType();\n    void setTimerPtr(dTimer_c* ptr);\n    dTimer_c* getTimerPtr();\n    void setWarpItemData(const char* stage, cXyz pos, s16 angle, s8 roomNo, u8, u8);\n    ~dComIfG_play_c() {}\n\n    dMsgObject_c* getMsgObjectClass() { return mMsgObjectClass; }\n    dStage_roomControl_c* getRoomControl() { return &mRoomControl; }\n    dStage_stageDt_c& getStage() { return mStageData; }\n    dEvt_control_c& getEvent() { return mEvent; }\n    daHorse_c* getHorseActor() { return (daHorse_c*)mPlayerPtr[1]; }\n    J2DGrafContext* getCurrentGrafPort() { return (J2DGrafContext*)mCurrentGrafPort; }\n    dVibration_c& getVibration() { return mVibration; }\n    camera_class* getCamera(int idx) { return mCameraInfo[idx].mCamera; }\n    void* getPlayerPtr(int ptrIdx) { return mPlayerPtr[ptrIdx]; }\n    fopAc_ac_c* getPlayer(int idx) { return (fopAc_ac_c*)mPlayer[idx]; }\n    dPa_control_c* getParticle() { return mParticle; }\n    dEvent_manager_c& getEvtManager() { return mEvtManager; }\n    dAttention_c& getAttention() { return mAttention; }\n    dStage_startStage_c* getStartStage() { return &mStartStage; }\n\n    void setCurrentGrafPort(J2DOrthoGraph* i_graf) { mCurrentGrafPort = i_graf; }\n    void setCurrentWindow(dDlst_window_c* i_window) { mCurrentWindow = i_window; }\n    void setCurrentView(view_class* i_view) { mCurrentView = i_view; }\n    void setCurrentViewport(view_port_class* i_viewport) { mCurrentViewport = i_viewport; }\n\n    void setSelectItem(int idx, u8 i_itemNo) { mSelectItem[idx] = i_itemNo; }\n    u8 getSelectItem(int idx) { return mSelectItem[idx]; }\n    void setSelectEquip(int idx, u8 item_id) { mSelectEquip[idx] = item_id; }\n    void setItem(u8 slot, u8 i_no) {\n        mItemSlot = slot;\n        mItemID = i_no;\n    }\n\n    u8 getDoStatus() { return mDoStatus; }\n    u8 getRStatus() { return mRStatus; }\n    u8 getAStatus() { return mAStatus; }\n    u8 getXStatus() { return mXStatus; }\n    u8 getYStatus() { return mYStatus; }\n    u8 getZStatus() { return mZStatus; }\n    u8 get3DStatus() { return m3DStatus; }\n    u8 getCStickStatus() { return mCStickStatus; }\n    u8 getSButtonStatus() { return mSButtonStatus; }\n    u8 getNunStatus() { return mNunStatus; }\n    u8 getRemoConStatus() { return mRemoConStatus; }\n    u8 getNunZStatus() { return mNunZStatus; }\n    u8 getNunCStatus() { return mNunCStatus; }\n    u8 getBottleStatus() { return mBottleStatus; }\n    u8 getSButtonStatusForce() { return mSButtonStatusForce; }\n    u8 getSButtonSetFlagForce() { return mSButtonSetFlagForce; }\n    u8 getCStickStatusForce() { return mCStickStatusForce; }\n    u8 getCStickSetFlagForce() { return mCStickSetFlagForce; }\n    u8 getCStickDirectionForce() { return mCStickDirectionForce; }\n    u8 getDoStatusForce() { return mDoStatusForce; }\n    u8 getDoSetFlagForce() { return mDoSetFlagForce; }\n    u8 getAStatusForce() { return mAStatusForce; }\n    u8 getASetFlagForce() { return mASetFlagForce; }\n    u8 getRStatusForce() { return mRStatusForce; }\n    u8 getRSetFlagForce() { return mRSetFlagForce; }\n    u8 getZStatusForce() { return mZStatusForce; }\n    u8 getZSetFlagForce() { return mZSetFlagForce; }\n    u8 getBottleStatusForce() { return mBottleStatusForce; }\n    u8 getBottleSetFlagForce() { return mBottleSetFlagForce; }\n    u8 get3DStatusForce() { return m3DStatusForce; }\n    u8 get3DSetFlagForce() { return m3DSetFlagForce; }\n    u8 get3DDirectionForce() { return m3DDirectionForce; }\n    u8 getXStatusForce() { return mXStatusForce; }\n    u8 getXSetFlagForce() { return mXSetFlagForce; }\n    u8 getYStatusForce() { return mYStatusForce; }\n    u8 getYSetFlagForce() { return mYSetFlagForce; }\n    u8 getFaceAnimeID() { return mFaceAnimeID; }\n    u8 getBaseAnimeID() { return mBaseAnimeID; }\n    bool isCStickSetFlag(u8 flag) { return mCStickSetFlag & flag; }\n    bool isDoSetFlag(u8 flag) { return (mDoSetFlag & flag) ? true : false; }\n    bool isASetFlag(u8 flag) { return (mASetFlag & flag) ? true : false; }\n    bool isRSetFlag(u8 flag) { return (mRSetFlag & flag) ? true : false; }\n    bool isXSetFlag(u8 flag) { return (mXSetFlag & flag) ? true : false; }\n    bool isYSetFlag(u8 flag) { return (mYSetFlag & flag) ? true : false; }\n\n    void setZStatus(u8 status, u8 flag) {\n        mZStatus = status;\n        mZSetFlag = flag;\n    }\n\n    void setRStatus(u8 status, u8 flag) {\n        mRStatus = status;\n        mRSetFlag = flag;\n    }\n\n    void setDoStatus(u8 status, u8 flag) {\n        mDoStatus = status;\n        mDoSetFlag = flag;\n    }\n\n    void setAStatus(u8 status, u8 flag) {\n        mAStatus = status;\n        mASetFlag = flag;\n    }\n\n    void setXStatus(u8 status, u8 flag) {\n        mXStatus = status;\n        mXSetFlag = flag;\n    }\n\n    void setXStatusForce(u8 status, u8 flag) {\n        mXStatusForce = status;\n        mXSetFlagForce = flag;\n    }\n\n    void setYStatus(u8 status, u8 flag) {\n        mYStatus = status;\n        mYSetFlag = flag;\n    }\n\n    void setYStatusForce(u8 status, u8 flag) {\n        mYStatusForce = status;\n        mYSetFlagForce = flag;\n    }\n\n    void setBottleStatus(u8 status, u8 flag) {\n        mBottleStatus = status;\n        mBottleSetFlag = flag;\n    }\n\n    void setBottleStatusForce(u8 status, u8 flag) {\n        mBottleStatusForce = status;\n        mBottleSetFlagForce = flag;\n    }\n\n    void setNunStatus(u8 status, u8 param_1, u8 flag) {\n        mNunStatus = status;\n        field_0x4ef0 = param_1;\n        mNunSetFlag = flag;\n    }\n\n    void setRemoConStatus(u8 status, u8 param_1, u8 flag) {\n        mRemoConStatus = status;\n        field_0x4ef2 = param_1;\n        mRemoConSetFlag = flag;\n    }\n\n    void setNunZStatus(u8 status, u8 flag) {\n        mNunZStatus = status;\n        mNunZSetFlag = flag;\n    }\n\n    void setNunCStatus(u8 status, u8 flag) {\n        mNunCStatus = status;\n        mNunCSetFlag = flag;\n    }\n\n    void setCStickStatus(u8 status, u8 param_1, u8 flag) {\n        mCStickStatus = status;\n        mCStickDirection = param_1;\n        mCStickSetFlag = flag;\n    }\n\n    void setCStickStatusForce(u8 status, u8 param_1, u8 flag) {\n        mCStickStatusForce = status;\n        mCStickDirectionForce = param_1;\n        mCStickSetFlagForce = flag;\n    }\n\n    void setSButtonStatus(u8 status, u8 flag) {\n        mSButtonStatus = status;\n        mSButtonSetFlag = flag;\n    }\n\n    void setSButtonStatusForce(u8 status, u8 flag) {\n        mSButtonStatusForce = status;\n        mSButtonSetFlagForce = flag;\n    }\n\n    void set3DStatus(u8 status, u8 direction, u8 flag) {\n        m3DStatus = status;\n        m3DDirection = direction;\n        m3DSetFlag = flag;\n    }\n\n    void set3DStatusForce(u8 status, u8 direction, u8 flag) {\n        m3DStatusForce = status;\n        m3DDirectionForce = direction;\n        m3DSetFlagForce = flag;\n    }\n\n    void setDoStatusForce(u8 status, u8 flag) {\n        mDoStatusForce = status;\n        mDoSetFlagForce = flag;\n    }\n\n    void setAStatusForce(u8 status, u8 flag) {\n        mAStatusForce = status;\n        mASetFlagForce = flag;\n    }\n\n    void setRStatusForce(u8 status, u8 flag) {\n        mRStatusForce = status;\n        mRSetFlagForce = flag;\n    }\n\n    void setZStatusForce(u8 status, u8 flag) {\n        mZStatusForce = status;\n        mZSetFlagForce = flag;\n    }\n\n    void onStatus(u16 i_status) { mStatus |= i_status; }\n\n    void setItemRupeeCount(s32 rupees) { mItemRupeeCount += rupees; }\n    void setItemMagicCount(s16 magic) { mItemMagicCount += magic; }\n    void setItemMaxMagicCount(s16 max) { mItemMaxMagicCount += max; }\n    void setItemArrowNumCount(s16 arrows) { mItemArrowNumCount += arrows; }\n    void setItemPachinkoNumCount(s16 seeds) { mItemPachinkoNumCount += seeds; }\n    void setItemKeyNumCount(s16 keys) { mItemKeyNumCount += keys; }\n    void setItemMaxLifeCount(s16 max) { mItemMaxLifeCount += max; }\n    void setOxygen(s32 oxygen) { mOxygen = oxygen; }\n    void setNowOxygen(s32 oxygen) { mNowOxygen = oxygen; }\n    void setOxygenCount(s32 oxygen) { mOxygenCount += oxygen; }\n    int getOxygen() { return mOxygen; }\n    void setMaxOxygen(int max) { mMaxOxygen = max; }\n    int getMaxOxygen() { return mMaxOxygen; }\n    int getNowOxygen() { return mNowOxygen; }\n    void setItemNowLife(u16 life) { mItemNowLife = life; }\n    void setItemNowMagic(s16 magic) { mItemNowMagicCount = magic; }\n    void setItemNowOil(s32 oil) { mItemNowOil = oil; }\n    void setItemOilCount(s32 oil) { mItemOilCount += oil; }\n    s16 getItemMaxLifeCount() { return mItemMaxLifeCount; }\n    f32 getItemLifeCount() { return mItemLifeCount; }\n    s16 getItemMaxArrowNumCount() { return mItemMaxArrowNumCount; }\n    s16 getItemArrowNumCount() { return mItemArrowNumCount; }\n    s32 getItemMaxOilCount() { return mItemMaxOilCount; }\n    s32 getItemOilCount() { return mItemOilCount; }\n    s32 getMaxOxygenCount() { return mMaxOxygenCount; }\n    s32 getOxygenCount() { return mOxygenCount; }\n    s32 getItemRupeeCount() { return mItemRupeeCount; }\n    s16 getItemKeyNumCount() { return mItemKeyNumCount; }\n    void clearNowAnimeID() { mNowAnimeID = -1; }\n    void clearMesgCamInfoID() { mMesgCamInfo = -1; }\n    void clearItemMaxLifeCount() { mItemMaxLifeCount = 0; }\n    void clearItemMaxOilCount() { mItemMaxOilCount = 0; }\n    void clearItemOilCount() { mItemOilCount = 0; }\n    void clearMaxOxygenCount() { mMaxOxygenCount = 0; }\n    void clearOxygenCount() { mOxygenCount = 0; }\n    void clearItemRupeeCount() { mItemRupeeCount = 0; }\n    void clearItemKeyNumCount() { mItemKeyNumCount = 0; }\n    void clearItemArrowNumCount() { mItemArrowNumCount = 0; }\n    void clearItemLifeCount() {\n        mItemLifeCount = 0.0f;\n        mItemLifeCountType = 0;\n    }\n\n    void setItemLifeCount(f32 hearts, u8 type) {\n        mItemLifeCount += hearts;\n        mItemLifeCountType = type;\n    }\n\n    u8& getItemLifeCountType() { return mItemLifeCountType; }\n    u16 getItemNowLife() { return mItemNowLife; }\n    s32 getItemNowOil() { return mItemNowOil; }\n    s16 getItemPachinkoNumCount() { return mItemPachinkoNumCount; }\n    void clearItemPachinkoNumCount() { mItemPachinkoNumCount = 0; }\n    u8 getNeedLightDropNum() { return mNeedLightDropNum; }\n\n    const char* getStartStageName() { return mStartStage.getName(); }\n    s8 getStartStageRoomNo() { return mStartStage.getRoomNo(); }\n    s8 getStartStageLayer() { return mStartStage.getLayer(); }\n    s16 getStartStagePoint() { return mStartStage.getPoint(); }\n    s8 getStartStageDarkArea() { return mStartStage.getDarkArea(); }\n    void setStartStageDarkArea(s8 darkArea) { mStartStage.setDarkArea(darkArea); }\n    void setStartStageLayer(s8 layer) { mStartStage.setLayer(layer); }\n\n    const char* getNextStageName() { return mNextStage.getName(); }\n    dStage_startStage_c* getNextStartStage() { return &mNextStage; }\n    s8 getNextStageRoomNo() { return mNextStage.getRoomNo(); }\n    s8 getNextStageLayer() { return mNextStage.getLayer(); }\n    s16 getNextStagePoint() { return mNextStage.getPoint(); }\n    s8 getNextStageWipe() { return mNextStage.getWipe(); }\n    bool isEnableNextStage() { return mNextStage.isEnable(); }\n    void offEnableNextStage() { mNextStage.offEnable(); }\n    void setNextStage(const char* stage, s8 roomNo, s16 point, s8 layer, s8 wipe, u8 wipe_speed) {\n        mNextStage.set(stage, roomNo, point, layer, wipe, wipe_speed);\n    }\n\n    u8 isHeapLockFlag() { return mHeapLockFlag; }\n    void setHeapLockFlag(u8 status) { mHeapLockFlag = status; }\n    void setSubHeapLockFlag(int idx, u8 status) { mSubHeapLockFlag[idx] = status; }\n    u8 getSubHeapLockFlag(int idx) { return mSubHeapLockFlag[idx]; }\n    void offHeapLockFlag() { mHeapLockFlag = 0; }\n\n    JKRExpHeap* getExpHeap2D() { return mExpHeap2D; }\n    JKRExpHeap* getMsgExpHeap() { return mMsgExpHeap; }\n    JKRExpHeap* getSubExpHeap2D(int idx) { return mSubExpHeap2D[idx]; }\n    void setSubExpHeap2D(int idx, void* heap) { mSubExpHeap2D[idx] = (JKRExpHeap*)heap; }\n    void setExpHeap2D(void* heap) { mExpHeap2D = (JKRExpHeap*)heap; }\n    void setMsgExpHeap(void* heap) { mMsgExpHeap = (JKRExpHeap*)heap; }\n\n    JKRArchive* getMsgDtArchive(int idx) { return mMsgDtArchive[idx]; }\n    JKRArchive* getMsgArchive(int idx) { return mMsgArchive[idx]; }\n    JKRArchive* getMsgCommonArchive() { return mMsgCommonArchive; }\n    JKRArchive* getMain2DArchive() { return mMain2DArchive; }\n    JKRArchive* getAnmArchive() { return mAnmArchive; }\n    JKRArchive* getCollectResArchive() { return mCollectResArchive; }\n    JKRArchive* getItemIconArchive() { return mItemIconArchive; }\n    JKRArchive* getNameResArchive() { return mNameResArchive; }\n    JKRArchive* getDemoMsgArchive() { return mDemoMsgArchive; }\n    JKRArchive* getFmapResArchive() { return mFmapResArchive; }\n    JKRArchive* getDmapResArchive() { return mDmapResArchive; }\n    JKRAramArchive* getFieldMapArchive2() { return (JKRAramArchive*)mFieldMapArchive2; }\n    JKRArchive* getOptionResArchive() { return mOptionResArchive; }\n    JKRArchive* getRingResArchive() { return mRingResArchive; }\n    JKRArchive* getFontArchive() { return mFontArchive; }\n    JKRArchive* getRubyArchive() { return mRubyArchive; }\n\n    void setFieldMapArchive2(JKRArchive* arc) { mFieldMapArchive2 = arc; }\n    void setAnmArchive(JKRArchive* arc) { mAnmArchive = arc; }\n    void setFmapResArchive(JKRArchive* arc) { mFmapResArchive = arc; }\n    void setDmapResArchive(JKRArchive* arc) { mDmapResArchive = arc; }\n    void setCollectResArchive(JKRArchive* arc) { mCollectResArchive = arc; }\n    void setItemIconArchive(JKRArchive* arc) { mItemIconArchive = arc; }\n    void setAllMapArchive(JKRArchive* arc) { mAllMapArchive = arc; }\n    void setOptionResArchive(JKRArchive* arc) { mOptionResArchive = arc; }\n    void setRingResArchive(JKRArchive* arc) { mRingResArchive = arc; }\n    void setNameResArchive(JKRArchive* arc) { mNameResArchive = arc; }\n    void setDemoMsgArchive(JKRArchive* arc) { mDemoMsgArchive = arc; }\n    void setMeterButtonArchive(JKRArchive* arc) { mMeterButtonArchive = arc; }\n    void setErrorResArchive(JKRArchive* arc) { mErrorResArchive = arc; }\n    void setCardIconResArchive(JKRArchive* arc) { mCardIconResArchive = arc; }\n    void setMsgDtArchive(int i, JKRArchive* arc) { mMsgDtArchive[i] = arc; }\n    void setMsgCommonArchive(JKRArchive* arc) { mMsgCommonArchive = arc; }\n    void setMsgArchive(int i, JKRArchive* arc) { mMsgArchive[i] = arc; }\n    void setMesgCamInfoActor(fopAc_ac_c* param_1, fopAc_ac_c* param_2, fopAc_ac_c* param_3,\n                             fopAc_ac_c* param_4, fopAc_ac_c* param_5, fopAc_ac_c* param_6,\n                             fopAc_ac_c* param_7, fopAc_ac_c* param_8, fopAc_ac_c* param_9,\n                             fopAc_ac_c* param_10) {\n        mMesgCamInfoActor1 = param_1;\n        mMesgCamInfoActor2 = param_2;\n        mMesgCamInfoActor3 = param_3;\n        mMesgCamInfoActor4 = param_4;\n        mMesgCamInfoActor5 = param_5;\n        mMesgCamInfoActor6 = param_6;\n        mMesgCamInfoActor7 = param_7;\n        mMesgCamInfoActor8 = param_8;\n        mMesgCamInfoActor9 = param_9;\n        mMesgCamInfoActor10 = param_10;\n    }\n    int getMesgCamInfo() { return mMesgCamInfoBasicID; }\n    void setFontArchive(JKRArchive* arc) { mFontArchive = arc; }\n    void setRubyArchive(JKRArchive* arc) { mRubyArchive = arc; }\n    void setMain2DArchive(JKRArchive* arc) { mMain2DArchive = arc; }\n    void setItemTable(void* data) { mItemTable = data; }\n    void* getItemTable() { return mItemTable; }\n\n    void setPlayerPtr(int i, fopAc_ac_c* ptr) { mPlayerPtr[i] = ptr; }\n    void setPlayer(int i, fopAc_ac_c* player) { mPlayer[i] = (daAlink_c*)player; }\n    void setPlayerInfo(int i, fopAc_ac_c* ptr, int camIdx) {\n        mPlayer[i] = (daAlink_c*)ptr;\n        mPlayerCameraID[camIdx] = 0;\n    }\n    void setPlayerStatus(int param_0, int i, u32 flag) { mPlayerStatus[i] |= flag; }\n    void clearPlayerStatus(int param_0, int i, u32 flag) { mPlayerStatus[i] &= ~flag; }\n    bool checkPlayerStatus(int param_0, int i, u32 flag) { return flag & mPlayerStatus[i]; }\n\n    s8 getPlayerCameraID(int i) { return mPlayerCameraID[i]; }\n    void setCameraParamFileName(int i, char* name) { mCameraInfo[i].mCameraParamFileName = name; }\n    void setCamera(int i, camera_class* cam) { mCameraInfo[i].mCamera = cam; }\n    const char* getCameraParamFileName(int i) { return mCameraInfo[i].mCameraParamFileName; }\n    BOOL checkCameraAttentionStatus(int i, u32 flag) {\n        return mCameraInfo[i].mCameraAttentionStatus & flag;\n    }\n    u32 getCameraAttentionStatus(int i) { return mCameraInfo[i].mCameraAttentionStatus; }\n    void setCameraAttentionStatus(int i, u32 flag) { mCameraInfo[i].mCameraAttentionStatus = flag; }\n    void onCameraAttentionStatus(int i, u32 flag) { mCameraInfo[i].mCameraAttentionStatus |= flag; }\n    void offCameraAttentionStatus(int i, u32 flag) {\n        mCameraInfo[i].mCameraAttentionStatus &= ~flag;\n    }\n    void setCameraInfo(int camIdx, camera_class* p_cam, int param_2, int param_3, int param_4) {\n        mCameraInfo[camIdx].mCamera = p_cam;\n        mCameraInfo[camIdx].field_0x4 = param_2;\n        mCameraInfo[camIdx].field_0x5 = param_3;\n        mCameraInfo[camIdx].field_0x6 = param_4;\n        setCameraAttentionStatus(camIdx, 0);\n    }\n\n    f32 getCameraZoomForcus(int i_no) { return mCameraInfo[i_no].mCameraZoomForcus; }\n\n    void setMesgCamInfoID(int param_0) { mMesgCamInfo = param_0; }\n\n    void setStatus(u16 status) { mStatus = status; }\n    s32 checkStatus(u16 flags) { return flags & mStatus; }\n\n    void setDirection(u8 i_dir) { mDirection = i_dir; }\n\n    bool& isPauseFlag() { return mPauseFlag; }\n    void offPauseFlag() { mPauseFlag = false; }\n    void onPauseFlag() { mPauseFlag = true; }\n    u8 getOxygenShowFlag() { return mOxygenShowFlag; }\n    void setOxygenShowFlag(u8 flag) { mOxygenShowFlag = flag; }\n    void show2dOn() { mShow2D = 1; }\n    void show2dOff() { mShow2D = 0; }\n    u8 show2dCheck() { return mShow2D; }\n    s8 getLayerOld() { return mLayerOld; }\n    void setMesgCancelButton(u8 button) { mMesgCancelButton = button; }\n    void setMesgBgm(u8 param_0) { mMesgBgm = param_0; }\n    int getMessageCountNumber() { return mMessageCountNum; }\n    void setMessageCountNumber(u32 number) { mMessageCountNum = number; }\n\n    void setWindowNum(u8 num) { mWindowNum = num; }\n    int getWindowNum() { return mWindowNum; }\n    dDlst_window_c* getWindow(int i) { return &mWindow[i]; }\n    void setWindow(int i, f32 param_1, f32 param_2, f32 param_3, f32 param_4, f32 param_5,\n                   f32 param_6, int camID, int mode) {\n        mWindow[i].setViewPort(param_1, param_2, param_3, param_4, param_5, param_6);\n        mWindow[i].setScissor(param_1, param_2, param_3, param_4);\n        mWindow[i].setCameraID(camID);\n        mWindow[i].setMode(mode);\n    }\n\n    void setLastPlayStageName(char* name) {\n        strncpy(mLastPlayStageName, name, 7);\n        mLastPlayStageName[7] = 0;\n    }\n    char* getLastPlayStageName() { return mLastPlayStageName; }\n\n    void setGameoverStatus(u8 status) { mGameoverStatus = status; }\n    u8 getGameoverStatus() { return mGameoverStatus; }\n    u8 getMesgStatus() { return mMesgStatus; }\n\npublic:\n    /* 0x00000 */ dBgS mBgs;\n    /* 0x01404 */ dCcS mCcs;\n    /* 0x03EC8 */ dStage_startStage_c mStartStage;\n    /* 0x03ED6 */ dStage_nextStage_c mNextStage;\n    /* 0x03EE8 */ dStage_stageDt_c mStageData;\n    /* 0x03F8C */ dStage_roomControl_c mRoomControl;\n    /* 0x03F90 */ dEvt_control_c mEvent;\n    /* 0x040C0 */ dEvent_manager_c mEvtManager;\n    /* 0x04780 */ dAttention_c mAttention;\n    /* 0x04C9C */ dVibration_c mVibration;\n    /* 0x04D2C */ u8 field_0x4d2c[4];\n    /* 0x04D30 */ JKRArchive* mFieldMapArchive2;\n    /* 0x04D34 */ JKRArchive* mMsgArchive[11];\n    /* 0x04D60 */ JKRArchive* mDemoMsgArchive;\n    /* 0x04D64 */ JKRArchive* mMeterButtonArchive;\n    /* 0x04D68 */ void* field_0x4d68;\n    /* 0x04D6C */ JKRArchive* mFontArchive;\n    /* 0x04D70 */ JKRArchive* mRubyArchive;\n    /* 0x04D74 */ JKRArchive* mAnmArchive;\n    /* 0x04D78 */ void* field_0x4d78[2];\n    /* 0x04D80 */ JKRArchive* mCollectResArchive;\n    /* 0x04D84 */ JKRArchive* mFmapResArchive;\n    /* 0x04D88 */ JKRArchive* mDmapResArchive;\n    /* 0x04D8C */ JKRArchive* mOptionResArchive;\n    /* 0x04D90 */ void* field_0x4d90[2];\n    /* 0x04D98 */ JKRArchive* mItemIconArchive;\n    /* 0x04D9C */ JKRArchive* mNameResArchive;\n    /* 0x04DA0 */ JKRArchive* mErrorResArchive;\n    /* 0x04DA4 */ void* field_0x4da4;\n    /* 0x04DA8 */ JKRArchive* mAllMapArchive;\n    /* 0x04DAC */ JKRArchive* mMsgCommonArchive;\n    /* 0x04DB0 */ JKRArchive* mRingResArchive;\n    /* 0x04DB4 */ void* field_0x4db4;\n    /* 0x04DB8 */ JKRArchive* mCardIconResArchive;\n    /* 0x04DBC */ JKRArchive* mMsgDtArchive[15];\n    /* 0x04DF8 */ JKRArchive* mMain2DArchive;\n    /* 0x04DFC */ void* field_0x4dfc[2];\n    /* 0x04E04 */ dPa_control_c* mParticle;\n    /* 0x04E08 */ dSmplMdl_draw_c* mSimpleModel;\n    /* 0x04E0C */ u8 mWindowNum;\n    /* 0x04E0D */ s8 mLayerOld;\n    /* 0x04E0E */ u16 mStatus;\n    /* 0x04E10 */ dDlst_window_c mWindow[1];\n    /* 0x04E3C */ dComIfG_camera_info_class mCameraInfo[1];\n    /* 0x04E74 */ daAlink_c* mPlayer[1];\n    /* 0x04E78 */ s8 mPlayerCameraID[1];\n    /* 0x04E7C */ fopAc_ac_c* mPlayerPtr[2];  // 0: Player, 1: Horse ; type may be wrong\n    /* 0x04E84 */ dMsgObject_c* mMsgObjectClass;\n    /* 0x04E88 */ f32 mItemLifeCount;\n    /* 0x04E8C */ s32 mItemRupeeCount;\n    /* 0x04E90 */ s16 mItemKeyNumCount;\n    /* 0x04E92 */ s16 mItemMaxLifeCount;\n    /* 0x04E94 */ s16 mItemMagicCount;\n    /* 0x04E96 */ s16 mItemNowMagicCount;\n    /* 0x04E98 */ s16 mItemMaxMagicCount;\n    /* 0x04E9A */ s16 field_0x4e9a;\n    /* 0x04E9C */ s32 mItemOilCount;\n    /* 0x04EA0 */ s32 mItemNowOil;\n    /* 0x04EA4 */ int mItemMaxOilCount;\n    /* 0x04EA8 */ int mOxygen;\n    /* 0x04EAC */ int mNowOxygen;\n    /* 0x04EB0 */ int mMaxOxygen;\n    /* 0x04EB4 */ int mOxygenCount;\n    /* 0x04EB8 */ int mMaxOxygenCount;\n    /* 0x04EBC */ s16 mItemArrowNumCount;\n    /* 0x04EBE */ s16 mItemPachinkoNumCount;\n    /* 0x04EC0 */ s16 mItemMaxArrowNumCount;\n    /* 0x04EC2 */ s16 mItemBombNumCount[3];\n    /* 0x04EC8 */ u8 field_0x4ec8[4];\n    /* 0x04ECC */ s16 mItemMaxBombNumCount1;\n    /* 0x04ECE */ s16 mItemMaxBombNumCount2;\n    /* 0x04ED0 */ u8 field_0x4ed0[4];\n    /* 0x04ED4 */ int mMessageCountNum;\n    /* 0x04ED8 */ u8 field_0x4ed8[6];\n    /* 0x04EDE */ u16 mItemNowLife;\n    /* 0x04EE0 */ u8 field_0x4ee0[2];\n    /* 0x04EE2 */ u8 mMesgStatus;\n    /* 0x04EE3 */ u8 field_0x4ee3;\n    /* 0x04EE4 */ u8 mRStatus;\n    /* 0x04EE5 */ u8 mAStatus;  // B button\n    /* 0x04EE6 */ u8 field_0x4ee6;\n    /* 0x04EE7 */ u8 mNunStatus;\n    /* 0x04EE8 */ u8 mBottleStatus;\n    /* 0x04EE9 */ u8 mRemoConStatus;\n    /* 0x04EEA */ u8 field_0x4eea[2];\n    /* 0x04EEC */ u8 mDoStatus;  // A button\n    /* 0x04EED */ u8 field_0x4eed;\n    /* 0x04EEE */ u8 m3DStatus;\n    /* 0x04EEF */ u8 field_0x4eef;  // related to NunStatusForce\n    /* 0x04EF0 */ u8 field_0x4ef0;  // related to NunStatus\n    /* 0x04EF1 */ u8 field_0x4ef1;  // related to RemoConStatusForce\n    /* 0x04EF2 */ u8 field_0x4ef2;  // related to RemoConStatus\n    /* 0x04EF3 */ u8 field_0x4ef3[2];\n    /* 0x04EF5 */ u8 m3DDirection;\n    /* 0x04EF6 */ u8 m3DDirectionForce;\n    /* 0x04EF7 */ u8 mCStickStatus;\n    /* 0x04EF8 */ u8 mCStickDirection;\n    /* 0x04EF9 */ u8 mCStickDirectionForce;\n    /* 0x04EFA */ u8 mSButtonStatus;\n    /* 0x04EFB */ u8 mZStatus;\n    /* 0x04EFC */ u8 mRStatusForce;\n    /* 0x04EFD */ u8 mAStatusForce;\n    /* 0x04EFE */ u8 field_0x4efe;\n    /* 0x04EFF */ u8 field_0x4eff;  // related to NunStatusForce\n    /* 0x04F00 */ u8 mBottleStatusForce;\n    /* 0x04F01 */ u8 field_0x4f01;  // related to RemoConStatusForce\n    /* 0x04F02 */ u8 field_0x4f02[2];\n    /* 0x04F04 */ u8 mDoStatusForce;\n    /* 0x04F05 */ u8 mTouchStatusForce;\n    /* 0x04F06 */ u8 m3DStatusForce;\n    /* 0x04F07 */ u8 mCStickStatusForce;\n    /* 0x04F08 */ u8 mSButtonStatusForce;\n    /* 0x04F09 */ u8 mZStatusForce;\n    /* 0x04F0A */ u8 mRSetFlag;\n    /* 0x04F0B */ u8 mASetFlag;\n    /* 0x04F0C */ u8 field_0x4f0c;\n    /* 0x04F0D */ u8 mNunSetFlag;\n    /* 0x04F0E */ u8 mBottleSetFlag;\n    /* 0x04F0F */ u8 mRemoConSetFlag;\n    /* 0x04F10 */ u8 field_0x4f10[2];\n    /* 0x04F12 */ u8 mDoSetFlag;\n    /* 0x04F13 */ u8 m3DSetFlag;\n    /* 0x04F14 */ u8 mCStickSetFlag;\n    /* 0x04F15 */ u8 mSButtonSetFlag;\n    /* 0x04F16 */ u8 mZSetFlag;\n    /* 0x04F17 */ u8 mRSetFlagForce;\n    /* 0x04F18 */ u8 mASetFlagForce;\n    /* 0x04F19 */ u8 field_0x4f19;\n    /* 0x04F1A */ u8 field_0x4f1a;  // related to NunStatusForce\n    /* 0x04F1B */ u8 mBottleSetFlagForce;\n    /* 0x04F1C */ u8 field_0x4f1c;  // related to RemoConStatusForce\n    /* 0x04F1D */ u8 field_0x4f1d[2];\n    /* 0x04F1F */ u8 mDoSetFlagForce;\n    /* 0x04F20 */ u8 m3DSetFlagForce;\n    /* 0x04F21 */ u8 mCStickSetFlagForce;\n    /* 0x04F22 */ u8 mSButtonSetFlagForce;\n    /* 0x04F23 */ u8 mZSetFlagForce;\n    /* 0x04F24 */ u8 mXStatus;\n    /* 0x04F25 */ u8 mXStatusForce;\n    /* 0x04F26 */ u8 mXSetFlag;\n    /* 0x04F27 */ u8 mXSetFlagForce;\n    /* 0x04F28 */ u8 mYStatus;\n    /* 0x04F29 */ u8 mYStatusForce;\n    /* 0x04F2A */ u8 mYSetFlag;\n    /* 0x04F2B */ u8 mYSetFlagForce;\n    /* 0x04F2C */ u8 mNunZStatus;\n    /* 0x04F2D */ u8 mNunZSetFlag;\n    /* 0x04F2E */ u8 field_0x4fc6;  // related to NunZStatusForce\n    /* 0x04F2F */ u8 field_0x4fc7;  // related to NunZStatusForce\n    /* 0x04F30 */ u8 mNunCStatus;\n    /* 0x04F31 */ u8 mNunCSetFlag;\n    /* 0x04F32 */ u8 field_0x4fca;  // related to NunCStatusForce\n    /* 0x04F33 */ u8 field_0x4fcb;  // related to NunCStatusForce\n    /* 0x04F34 */ u8 mSelectItem[8];\n    /* 0x04F3C */ u8 mSelectEquip[6];\n    /* 0x04F42 */ u8 mBaseAnimeID;\n    /* 0x04F43 */ u8 mFaceAnimeID;\n    /* 0x04F44 */ u8 mNowAnimeID;\n    /* 0x04F45 */ u8 mItemSlot;\n    /* 0x04F46 */ u8 mItemID;\n    /* 0x04F47 */ u8 field_0x4f47[2];\n    /* 0x04F49 */ u8 mDirection;\n    /* 0x04F4A */ u8 field_0x4f4a;\n    /* 0x04F4B */ u8 field_0x4f4b;  // related to itemInit\n    /* 0x04F4C */ u8 field_0x4f4c;  // related to itemInit\n    /* 0x04F4D */ u8 field_0x4f4d;\n    /* 0x04F4E */ u8 mMesgCancelButton;\n    /* 0x04F4F */ u8 field_0x4f4f[2];\n    /* 0x04F51 */ u8 mGameoverStatus;\n    /* 0x04F52 */ u8 field_0x4f52[5];\n    /* 0x04F57 */ u8 mHeapLockFlag;\n    /* 0x04F58 */ u8 mSubHeapLockFlag[2];\n    /* 0x04F5A */ u8 mNowVibration;\n    /* 0x04F5B */ u8 field_0x4f5b[2];\n    /* 0x04F5D */ u8 mWolfAbility;\n    /* 0x04F5E */ u8 field_0x4f5e[11];\n    /* 0x04F69 */ u8 mNeedLightDropNum;\n    /* 0x04F6A */ u8 field_0x4f6a[18];\n    /* 0x04F7C */ u8 mMesgBgm;\n    /* 0x04F7D */ bool mPauseFlag;\n    /* 0x04F7E */ u8 mItemLifeCountType;\n    /* 0x04F7F */ u8 mOxygenShowFlag;\n    /* 0x04F80 */ u8 mShow2D;\n    /* 0x04F81 */ u8 field_0x4f81[3];\n    /* 0x04F84 */ JKRExpHeap* mExpHeap2D;\n    /* 0x04F88 */ JKRExpHeap* mSubExpHeap2D[2];\n    /* 0x04F90 */ JKRExpHeap* mMsgExpHeap;\n    /* 0x04F94 */ char mWarpItemStage[8];\n    /* 0x04F9C */ cXyz mWarpItemPos;\n    /* 0x04FA8 */ s16 mWarpItemAngle;\n    /* 0x04FAA */ s8 mWarpItemRoom;\n    /* 0x04FAB */ u8 field_0x4fab;  // related to setWarpItemData\n    /* 0x04FAC */ u8 field_0x4fac;  // related to setWarpItemData\n    /* 0x04FAD */ u8 field_0x4fad[3];\n    /* 0x04FB0 */ int mMesgCamInfo;\n    /* 0x04FB4 */ int mMesgCamInfoBasicID;\n    /* 0x04FB8 */ fopAc_ac_c* mMesgCamInfoActor1;\n    /* 0x04FBC */ fopAc_ac_c* mMesgCamInfoActor2;\n    /* 0x04FC0 */ fopAc_ac_c* mMesgCamInfoActor3;\n    /* 0x04FC4 */ fopAc_ac_c* mMesgCamInfoActor4;\n    /* 0x04FC8 */ fopAc_ac_c* mMesgCamInfoActor5;\n    /* 0x04FCC */ fopAc_ac_c* mMesgCamInfoActor6;\n    /* 0x04FD0 */ fopAc_ac_c* mMesgCamInfoActor7;\n    /* 0x04FD4 */ fopAc_ac_c* mMesgCamInfoActor8;\n    /* 0x04FD8 */ fopAc_ac_c* mMesgCamInfoActor9;\n    /* 0x04FDC */ fopAc_ac_c* mMesgCamInfoActor10;\n    /* 0x04FE0 */ u32 mPlayerStatus[2];\n    /* 0x04FE8 */ u8 field_0x4fe8[0x10];\n    /* 0x04FF8 */ __d_timer_info_c mTimerInfo;\n    /* 0x0500C */ dDlst_window_c* mCurrentWindow;\n    /* 0x05010 */ view_class* mCurrentView;\n    /* 0x05014 */ view_port_class* mCurrentViewport;\n    /* 0x05018 */ J2DOrthoGraph* mCurrentGrafPort;\n    /* 0x0501C */ void* mItemTable;\n    /* 0x0501D */ u8 field_0x501d[4];\n    /* 0x05024 */ char mLastPlayStageName[8];\n};\n\nclass dComIfG_inf_c {\npublic:\n    dComIfG_inf_c() { this->ct(); }\n    ~dComIfG_inf_c() {}\n    void ct();\n    dComIfG_play_c& getPlay() { return play; }\n\n    /* 0x00000 */ dSv_info_c info;\n    /* 0x00F38 */ dComIfG_play_c play;\n    /* 0x05F64 */ dDlst_list_c drawlist;\n    /* 0x1C2F8 */ dRes_control_c mResControl;\n    /* 0x1DDF8 */ u8 mFadeBrightness;\n    /* 0x1DDF9 */ u8 mWorldDark;\n    /* 0x1DDFA */ s8 field_0x1ddfa;\n    /* 0x1DDFB */ s8 field_0x1ddfb;\n    /* 0x1DDFC */ s8 field_0x1ddfc;\n    /* 0x1DE00 */ u32 field_0x1de00;\n    /* 0x1DE04 */ u32 field_0x1de04;\n    /* 0x1DE08 */ u8 field_0x1de08;\n    /* 0x1DE09 */ u8 field_0x1de09;\n    /* 0x1DE0A */ u8 field_0x1de0a;\n    /* 0x1DE0B */ u8 field_0x1de0b;\n    /* 0x1DE0C */ u8 field_0x1de0c;\n\n    static __d_timer_info_c dComIfG_mTimerInfo;\n};  // Size: 0x1DE10\n\nSTATIC_ASSERT(122384 == sizeof(dComIfG_inf_c));\n\nextern dComIfG_inf_c g_dComIfG_gameInfo;\nextern GXColor g_blackColor;\nextern GXColor g_clearColor;\nextern GXColor g_whiteColor;\n\nint dComLbG_PhaseHandler(request_of_phase_process_class*, request_of_phase_process_fn*, void*);\nBOOL dComIfG_resetToOpening(scene_class* scene);\nchar* dComIfG_getRoomArcName(int roomNo);\nvoid* dComIfG_getStageRes(char const* resName);\nvoid* dComIfG_getOldStageRes(char const* resName);\nvoid dComIfG_get_timelayer(int* layer);\nint dComIfG_resDelete(request_of_phase_process_class* i_phase, char const* resName);\nint dComIfG_changeOpeningScene(scene_class* scene, s16 procName);\nint dComIfG_resLoad(request_of_phase_process_class* i_phase, char const* arc_name);\nint dComIfG_resLoad(request_of_phase_process_class* i_phase, char const* resName, JKRHeap* heap);\nint dComIfG_TimerDeleteRequest(int i_mode);\nint dComIfG_TimerStart(int i_mode, s16 i_time);\n\ninline void dComIfG_setBrightness(u8 brightness) {\n    g_dComIfG_gameInfo.mFadeBrightness = brightness;\n}\n\ninline int dComIfG_getTimerMode() {\n    return g_dComIfG_gameInfo.play.getTimerMode();\n}\n\ninline void dComIfG_setTimerMode(int mode) {\n    return g_dComIfG_gameInfo.play.setTimerMode(mode);\n}\n\ninline dTimer_c* dComIfG_getTimerPtr() {\n    return g_dComIfG_gameInfo.play.getTimerPtr();\n}\n\ninline u8 dComIfG_getTimerType() {\n    return g_dComIfG_gameInfo.play.getTimerType();\n}\n\ninline int dComIfG_setObjectRes(const char* name, u8 param_1, JKRHeap* heap) {\n    return g_dComIfG_gameInfo.mResControl.setObjectRes(name, param_1, heap);\n}\n\ninline int dComIfG_setObjectRes(const char* name, void* param_1, u32 param_2) {\n    return g_dComIfG_gameInfo.mResControl.setObjectRes(name, param_1, param_2, NULL);\n}\n\ninline int dComIfG_setStageRes(const char* name, JKRHeap* heap) {\n    return g_dComIfG_gameInfo.mResControl.setStageRes(name, heap);\n}\n\ninline int dComIfG_syncObjectRes(const char* name) {\n    return g_dComIfG_gameInfo.mResControl.syncObjectRes(name);\n}\n\ninline int dComIfG_syncStageRes(const char* name) {\n    return g_dComIfG_gameInfo.mResControl.syncStageRes(name);\n}\n\ninline int dComIfG_deleteObjectResMain(const char* res) {\n    return g_dComIfG_gameInfo.mResControl.deleteObjectRes(res);\n}\n\ninline int dComIfG_deleteStageRes(const char* res) {\n    return g_dComIfG_gameInfo.mResControl.deleteStageRes(res);\n}\n\ninline void* dComIfG_getStageRes(const char* arcName, const char* resName) {\n    return g_dComIfG_gameInfo.mResControl.getStageRes(arcName, resName);\n}\n\ninline void* dComIfG_getObjectRes(const char* arcName, const char* resName) {\n    return g_dComIfG_gameInfo.mResControl.getObjectRes(arcName, resName);\n}\n\ninline void* dComIfG_getObjectRes(const char* arcName, int param_1) {\n    return g_dComIfG_gameInfo.mResControl.getObjectRes(arcName, param_1);\n}\n\ninline dBgS& dComIfG_Bgsp() {\n    return g_dComIfG_gameInfo.play.mBgs;\n}\n\ninline dCcS* dComIfG_Ccsp() {\n    return &g_dComIfG_gameInfo.play.mCcs;\n}\n\ninline dCcS& dComIfG_Ccsp2() {\n    return g_dComIfG_gameInfo.play.mCcs;\n}\n\ninline dRes_info_c* dComIfG_getObjectResInfo(const char* arc_name) {\n    return g_dComIfG_gameInfo.mResControl.getObjectResInfo(arc_name);\n}\n\ninline dRes_info_c* dComIfG_getStageResInfo(const char* arc_name) {\n    return g_dComIfG_gameInfo.mResControl.getStageResInfo(arc_name);\n}\n\ninline int dComIfG_syncAllObjectRes() {\n    return g_dComIfG_gameInfo.mResControl.syncAllObjectRes();\n}\n\ninline void* dComIfG_getObjectIDRes(const char* arc_name, u16 id) {\n    return g_dComIfG_gameInfo.mResControl.getObjectIDRes(arc_name, id);\n}\n\ninline u8 dComIfG_getBrightness() {\n    return g_dComIfG_gameInfo.mFadeBrightness;\n}\n\ninline int dComIfG_getObjctResName2Index(const char* i_arcName, const char* i_resName) {\n    return g_dComIfG_gameInfo.mResControl.getObjectResName2Index(i_arcName, i_resName);\n}\n\nu8 dComIfGs_getMixItemIndex(int i_no);\nvoid dComIfGs_setSelectItemIndex(int i_no, u8 item_index);\nvoid dComIfGs_setMixItemIndex(int i_no, u8 item_index);\nu8 dComIfGs_getBottleMax();\nu8 dComIfGs_checkGetItem(u8 i_itemNo);\nvoid dComIfGs_setSelectEquipClothes(u8 i_itemNo);\nvoid dComIfGs_setKeyNum(int i_stageNo, u8 i_keyNum);\ns32 dComIfGs_isDungeonItemWarp(int i_stageNo);\nvoid dComIfGs_BossLife_public_Set(s8);\ns8 dComIfGs_sense_type_change_Get();\nvoid dComIfGs_sense_type_change_Set(s8);\ncXyz& dComIfGs_getWarpPlayerPos();\nconst char* dComIfGs_getWarpStageName();\ns16 dComIfGs_getWarpPlayerAngleY();\ns8 dComIfGs_getWarpRoomNo();\nbool dComIfGs_getWarpMarkFlag();\nBOOL dComIfGs_isOneZoneSwitch(int i_swBit, int i_roomNo);\nBOOL dComIfGs_isOneZoneItem(int i_swBit, int i_roomNo);\nBOOL dComIfGs_isZoneSwitch(int, int);\nBOOL dComIfGs_isZoneItem(int, int);\nvoid dComIfGs_setLastWarpMarkItemData(const char* stage, cXyz pos, s16 angle, s8 roomNo, u8, u8);\nu16 dComIfGs_getMaxLifeGauge();\nvoid dComIfGs_setWarpMarkFlag(u8);\nvoid dComIfGs_setSelectEquipSword(u8 i_itemNo);\nvoid dComIfGs_setSelectEquipShield(u8 i_itemNo);\nBOOL dComIfGs_isVisitedRoom(int i_roomNo);\nvoid dComIfGs_onZoneSwitch(int i_swBit, int i_roomNo);\nvoid dComIfGs_onOneZoneSwitch(int i_swBit, int i_roomNo);\nvoid dComIfGs_offZoneSwitch(int i_swBit, int i_roomNo);\nvoid dComIfGs_offOneZoneSwitch(int i_swBit, int i_roomNo);\ns8 dComIfGp_getReverb(int i_roomNo);\nvoid dComIfGs_gameStart();\nBOOL dComIfGs_wolfeye_effect_check();\nBOOL dComIfGs_Wolf_Change_Check();\nvoid dComIfGs_onVisitedRoom(int param_0);\nvoid dComIfGs_offVisitedRoom(int param_0);\nvoid dComIfGs_setWarpItemData(char const* stage, cXyz pos, s16 angle, s8 roomNo, u8 param_4,\n                              u8 param_5);\nBOOL dComIfGs_isStageSwitch(int i_stageNo, int i_no);\nvoid dComIfGs_onStageSwitch(int i_stageNo, int i_no);\nvoid dComIfGs_offStageSwitch(int i_stageNo, int i_no);\nvoid dComIfGs_PolyDamageOff_Set(s8 param_0);\nu8 dComIfGs_staffroll_next_go_check();\nBOOL dComIfGs_isEventBit(u16 i_flag);\nint dComIfGs_isItemFirstBit(u8 i_no);\nu16 dComIfGs_getRupee();\nstatic u16 dComIfGs_getLife();\ns8 dComIfGs_BossLife_public_Get();\nu8 dComIfGs_checkGetInsectNum();\nu8 dComIfGs_getSelectMixItemNoArrowIndex(int i_selmixItemIdx);\n\ninline void dComIfGs_init() {\n    g_dComIfG_gameInfo.info.init();\n}\n\ninline int i_dComIfGs_isItemFirstBit(u8 i_no) {\n    return g_dComIfG_gameInfo.info.getPlayer().getGetItem().isFirstBit(i_no);\n}\n\ninline u16 i_dComIfGs_getRupee() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().getRupee();\n}\n\ninline void dComIfGs_onDungeonItemMap() {\n    g_dComIfG_gameInfo.info.getMemory().getBit().onDungeonItemMap();\n}\n\ninline void dComIfGs_onDungeonItemCompass() {\n    g_dComIfG_gameInfo.info.getMemory().getBit().onDungeonItemCompass();\n}\n\ninline void dComIfGs_onDungeonItemWarp() {\n    g_dComIfG_gameInfo.info.getMemory().getBit().onDungeonItemWarp();\n}\n\ninline void dComIfGs_setItem(int i_slotNo, u8 i_itemNo) {\n    g_dComIfG_gameInfo.info.getPlayer().getItem().setItem(i_slotNo, i_itemNo);\n}\n\ninline void dComIfGs_setOil(u16 i_oil) {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().setOil(i_oil);\n}\n\ninline void dComIfGs_setMaxOil(u16 i_maxOil) {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().setMaxOil(i_maxOil);\n}\n\ninline void dComIfGs_setWalletSize(u8 i_size) {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().setWalletSize(i_size);\n}\n\ninline void dComIfGs_setMagic(u8 i_magic) {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().setMagic(i_magic);\n}\n\ninline void dComIfGs_setMaxMagic(u8 i_maxMagic) {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().setMaxMagic(i_maxMagic);\n}\n\ninline void dComIfGs_setRupee(u16 i_rupees) {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().setRupee(i_rupees);\n}\n\ninline void dComIfGs_setLife(u16 i_life) {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().setLife(i_life);\n}\n\ninline void dComIfGs_setMaxLife(u8 i_maxLife) {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().setMaxLife(i_maxLife);\n}\n\ninline void dComIfGs_onDungeonItemBossKey() {\n    g_dComIfG_gameInfo.info.getMemory().getBit().onDungeonItemBossKey();\n}\n\ninline void dComIfGs_setCollectSword(u8 i_swordNo) {\n    g_dComIfG_gameInfo.info.getPlayer().getCollect().setCollect(COLLECT_SWORD, i_swordNo);\n}\n\ninline void dComIfGs_setCollectShield(u8 i_shieldNo) {\n    g_dComIfG_gameInfo.info.getPlayer().getCollect().setCollect(COLLECT_SHIELD, i_shieldNo);\n}\n\ninline void dComIfGs_setCollectClothes(u8 i_clothesNo) {\n    g_dComIfG_gameInfo.info.getPlayer().getCollect().setCollect(COLLECT_CLOTHING, i_clothesNo);\n}\n\ninline void dComIfGs_setCardToMemory(char* card_ptr, int dataNum) {\n    g_dComIfG_gameInfo.info.card_to_memory(card_ptr, dataNum);\n}\n\ninline void dComIfGs_setRodTypeLevelUp() {\n    g_dComIfG_gameInfo.info.getPlayer().getItem().setRodTypeLevelUp();\n}\n\ninline void dComIfGs_setArrowNum(u8 i_arrowNum) {\n    g_dComIfG_gameInfo.info.getPlayer().getItemRecord().setArrowNum(i_arrowNum);\n}\n\ninline void dComIfGs_setArrowMax(u8 i_arrowMax) {\n    g_dComIfG_gameInfo.info.getPlayer().getItemMax().setArrowNum(i_arrowMax);\n}\n\ninline u8 dComIfGs_getPachinkoMax() {\n    return 50;\n}\n\ninline void dComIfGs_setEmptyBombBag() {\n    g_dComIfG_gameInfo.info.getPlayer().getItem().setEmptyBombBag();\n}\n\ninline void dComIfGs_setEmptyBombBag(u8 i_newBomb, u8 i_bombNum) {\n    g_dComIfG_gameInfo.info.getPlayer().getItem().setEmptyBombBag(i_newBomb, i_bombNum);\n}\n\ninline void dComIfGs_setEmptyBombBagItemIn(u8 i_newBomb, bool i_setNum) {\n    g_dComIfG_gameInfo.info.getPlayer().getItem().setEmptyBombBagItemIn(i_newBomb, i_setNum);\n}\n\ninline void dComIfGs_setEmptyBombBagItemIn(u8 i_newBomb, u8 i_bombNum, bool i_setNum) {\n    g_dComIfG_gameInfo.info.getPlayer().getItem().setEmptyBombBagItemIn(i_newBomb, i_bombNum,\n                                                                        i_setNum);\n}\n\ninline void dComIfGs_setEmptyBottle() {\n    g_dComIfG_gameInfo.info.getPlayer().getItem().setEmptyBottle();\n}\n\ninline void dComIfGs_setEmptyBottle(u8 i_itemNo) {\n    g_dComIfG_gameInfo.info.getPlayer().getItem().setEmptyBottle(i_itemNo);\n}\n\ninline void dComIfGs_setEmptyBottleItemIn(u8 i_itemNo) {\n    g_dComIfG_gameInfo.info.getPlayer().getItem().setEmptyBottleItemIn(i_itemNo);\n}\n\ninline void dComIfGs_setBottleNum(u8 i_bottleIdx, u8 i_bottleNum) {\n    g_dComIfG_gameInfo.info.getPlayer().getItemRecord().setBottleNum(i_bottleIdx, i_bottleNum);\n}\n\ninline void dComIfGs_onEventBit(u16 i_flag) {\n    g_dComIfG_gameInfo.info.getSavedata().getEvent().onEventBit(i_flag);\n}\n\n// debug rom says `i_flag` is not const, but it's needed to match in some places?\n// missing some other inline maybe?\ninline BOOL i_dComIfGs_isEventBit(const u16 i_flag) {\n    return g_dComIfG_gameInfo.info.getEvent().isEventBit(i_flag);\n}\n\ninline void dComIfGs_onLightDropFlag(u8 i_nowLevel) {\n    g_dComIfG_gameInfo.info.getPlayer().getLightDrop().onLightDropGetFlag(i_nowLevel);\n}\n\ninline void dComIfGs_onSwitch(int i_no, int i_roomNo) {\n    g_dComIfG_gameInfo.info.onSwitch(i_no, i_roomNo);\n}\n\ninline void dComIfGs_offSwitch(int i_no, int i_roomNo) {\n    g_dComIfG_gameInfo.info.offSwitch(i_no, i_roomNo);\n}\n\ninline BOOL dComIfGs_isSwitch(int i_no, int i_roomNo) {\n    return g_dComIfG_gameInfo.info.isSwitch(i_no, i_roomNo);\n}\n\ninline BOOL dComIfGs_isRegionBit(int i_region) {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerFieldLastStayInfo().isRegionBit(i_region);\n}\n\ninline void dComIfGs_onRegionBit(int i_region) {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerFieldLastStayInfo().onRegionBit(i_region);\n}\n\ninline void dComIfGs_onSvZoneSwitch(int i_zoneNo, int i_swBit) {\n    g_dComIfG_gameInfo.info.getZone(i_zoneNo).getZoneBit().onSwitch(i_swBit);\n}\n\ninline s32 dComIfGs_isDungeonItemMap() {\n    return g_dComIfG_gameInfo.info.getMemory().getBit().isDungeonItemMap();\n}\n\ninline s32 dComIfGs_isDungeonItemCompass() {\n    return g_dComIfG_gameInfo.info.getMemory().getBit().isDungeonItemCompass();\n}\n\ninline s32 dComIfGs_isDungeonItemBossKey() {\n    return g_dComIfG_gameInfo.info.getMemory().getBit().isDungeonItemBossKey();\n}\n\ninline u8 dComIfGs_getItem(int i_slotNo, bool i_checkCombo) {\n    return g_dComIfG_gameInfo.info.getPlayer().getItem().getItem(i_slotNo, i_checkCombo);\n}\n\ninline u8 dComIfGs_getLineUpItem(int i_slotNo) {\n    return g_dComIfG_gameInfo.info.getPlayer().getItem().getLineUpItem(i_slotNo);\n}\n\ninline BOOL dComIfGs_isCollectSword(u8 i_swordNo) {\n    return g_dComIfG_gameInfo.info.getPlayer().getCollect().isCollect(COLLECT_SWORD, i_swordNo);\n}\n\ninline BOOL dComIfGs_isCollectClothing(u8 i_clothesNo) {\n    return g_dComIfG_gameInfo.info.getPlayer().getCollect().isCollect(COLLECT_CLOTHING,\n                                                                      i_clothesNo);\n}\n\ninline u8 dComIfGs_checkBottle(u8 i_itemNo) {\n    return g_dComIfG_gameInfo.info.getPlayer().getItem().checkBottle(i_itemNo);\n}\n\ninline u8 dComIfGs_checkOptVibration() {\n    return g_dComIfG_gameInfo.info.getPlayer().getConfig().checkVibration();\n}\n\ninline BOOL dComIfGs_isLightDropGetFlag(u8 i_nowLevel) {\n    return g_dComIfG_gameInfo.info.getPlayer().getLightDrop().isLightDropGetFlag(i_nowLevel);\n}\n\ninline u8 dComIfGs_getArrowMax() {\n    return g_dComIfG_gameInfo.info.getPlayer().getItemMax().getArrowNum();\n}\n\ninline u8 dComIfGs_getCollectSmell() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().getSelectEquip(3);\n}\n\ninline u8 dComIfGs_getPohSpiritNum() {\n    return g_dComIfG_gameInfo.info.getPlayer().getCollect().getPohNum();\n}\n\ninline u8 dComIfGs_getKeyNum() {\n    return g_dComIfG_gameInfo.info.getMemory().getBit().getKeyNum();\n}\n\ninline void dComIfGs_onItemFirstBit(u8 i_itemNo) {\n    g_dComIfG_gameInfo.info.getPlayer().getGetItem().onFirstBit(i_itemNo);\n}\n\ninline u16 dComIfGs_getMaxLife() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().getMaxLife();\n}\n\ninline u16 i_dComIfGs_getLife() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().getLife();\n}\n\ninline void dComIfGs_offEventBit(u16 i_flag) {\n    g_dComIfG_gameInfo.info.getSavedata().getEvent().offEventBit(i_flag);\n}\n\ninline const char* dComIfGs_getLastWarpMarkStageName() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerLastMarkInfo().getName();\n}\n\ninline cXyz& dComIfGs_getLastWarpMarkPlayerPos() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerLastMarkInfo().getPos();\n}\n\ninline s16 dComIfGs_getLastWarpMarkPlayerAngleY() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerLastMarkInfo().getAngleY();\n}\n\ninline u8 dComIfGs_getLastWarpMarkRoomNo() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerLastMarkInfo().getRoomNo();\n}\n\ninline s8 dComIfGs_getLastWarpAcceptStage() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerLastMarkInfo().getWarpAcceptStage();\n}\n\ninline u8 dComIfGs_getSelectEquipClothes() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().getSelectEquip(COLLECT_CLOTHING);\n}\n\ninline u8 dComIfGs_getSelectEquipSword() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().getSelectEquip(COLLECT_SWORD);\n}\n\ninline u8 dComIfGs_getSelectEquipShield() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().getSelectEquip(COLLECT_SHIELD);\n}\n\ninline u8 dComIfGs_getLightDropNum(u8 i_nowLevel) {\n    return g_dComIfG_gameInfo.info.getPlayer().getLightDrop().getLightDropNum(i_nowLevel);\n}\n\ninline u8 dComIfGs_getSelectItemIndex(int i_no) {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().getSelectItemIndex(i_no);\n}\n\ninline u8 dComIfGs_getOptVibration() {\n    return g_dComIfG_gameInfo.info.getPlayer().getConfig().getVibration();\n}\n\ninline u8 dComIfGs_getOptAttentionType() {\n    return g_dComIfG_gameInfo.info.getPlayer().getConfig().getAttentionType();\n}\n\ninline u8 dComIfGs_getOptCameraControl() {\n    return g_dComIfG_gameInfo.info.getPlayer().getConfig().getCameraControl();\n}\n\ninline u8 dComIfGs_getOptSound() {\n    return g_dComIfG_gameInfo.info.getPlayer().getConfig().getSound();\n}\n\ninline BOOL dComIfGs_isTbox(int i_no) {\n    return g_dComIfG_gameInfo.info.getMemory().getBit().isTbox(i_no);\n}\n\ninline void dComIfGs_onTbox(int i_no) {\n    g_dComIfG_gameInfo.info.getMemory().getBit().onTbox(i_no);\n}\n\ninline BOOL dComIfGs_isSaveItem(int i_no) {\n    return g_dComIfG_gameInfo.info.getMemory().getBit().isItem(i_no);\n}\n\ninline BOOL dComIfGs_isSaveTbox(int i_stageNo, int i_no) {\n    return g_dComIfG_gameInfo.info.getSavedata().getSave(i_stageNo).getBit().isTbox(i_no);\n}\n\ninline BOOL dComIfGs_isSaveDunSwitch(int i_no) {\n    return g_dComIfG_gameInfo.info.getDan().isSwitch(i_no);\n}\n\ninline BOOL dComIfGs_isSaveDunItem(int i_no) {\n    return g_dComIfG_gameInfo.info.getDan().isItem(i_no);\n}\n\ninline void dComIfGs_onSaveSwitch(int i_stageNo, int i_no) {\n    g_dComIfG_gameInfo.info.getSavedata().getSave(i_stageNo).getBit().onSwitch(i_no);\n}\n\ninline void dComIfGs_onSaveSwitch(int i_no) {\n    g_dComIfG_gameInfo.info.getMemory().getBit().onSwitch(i_no);\n}\n\ninline void dComIfGs_offSaveSwitch(int i_no) {\n    g_dComIfG_gameInfo.info.getMemory().getBit().offSwitch(i_no);\n}\n\ninline void dComIfGs_offSaveSwitch(int i_stageNo, int i_no) {\n    g_dComIfG_gameInfo.info.getSavedata().getSave(i_stageNo).getBit().offSwitch(i_no);\n}\n\ninline BOOL dComIfGs_isSaveSwitch(int i_stageNo, int i_no) {\n    return g_dComIfG_gameInfo.info.getSavedata().getSave(i_stageNo).getBit().isSwitch(i_no);\n}\n\ninline BOOL dComIfGs_isSaveSwitch(int i_no) {\n    return g_dComIfG_gameInfo.info.getMemory().getBit().isSwitch(i_no);\n}\n\ninline void dComIfGs_onStageBossEnemy() {\n    g_dComIfG_gameInfo.info.getMemory().getBit().onStageBossEnemy();\n}\n\ninline s32 dComIfGs_isDungeonItemWarp() {\n    return g_dComIfG_gameInfo.info.getMemory().getBit().isDungeonItemWarp();\n}\n\ninline s32 dComIfGs_isStageBossEnemy() {\n    return g_dComIfG_gameInfo.info.getMemory().getBit().isStageBossEnemy();\n}\n\ninline void dComIfGs_setKeyNum(u8 i_keyNum) {\n    g_dComIfG_gameInfo.info.getMemory().getBit().setKeyNum(i_keyNum);\n}\n\ninline BOOL dComIfGs_isSaveVisitedRoom(int param_0, int i_roomNo) {\n    return g_dComIfG_gameInfo.info.getSavedata().getSave2(param_0)->isVisitedRoom(i_roomNo);\n}\n\ninline void dComIfGs_onSaveVisitedRoom(int param_0, int i_roomNo) {\n    return g_dComIfG_gameInfo.info.getSavedata().getSave2(param_0)->onVisitedRoom(i_roomNo);\n}\n\ninline void dComIfGs_offSaveVisitedRoom(int param_0, int i_roomNo) {\n    return g_dComIfG_gameInfo.info.getSavedata().getSave2(param_0)->offVisitedRoom(i_roomNo);\n}\n\ninline u16 dComIfGs_getOil() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().getOil();\n}\n\ninline u16 dComIfGs_getMaxOil() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().getMaxOil();\n}\n\ninline s64 dComIfGs_getSaveStartTime() {\n    return g_dComIfG_gameInfo.info.getStartTime();\n}\n\ninline s64 dComIfGs_getSaveTotalTime() {\n    return g_dComIfG_gameInfo.info.getSaveTotalTime();\n}\n\ninline dSv_save_c* dComIfGs_getSaveData() {\n    return &g_dComIfG_gameInfo.info.getSavedata();\n}\n\ninline void dComIfGs_setLineUpItem() {\n    g_dComIfG_gameInfo.info.getPlayer().getItem().setLineUpItem();\n}\n\ninline s32 dComIfGs_isGetMagicUseFlag() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().isMagicFlag(0);\n}\n\ninline void dComIfGs_offTmpBit(u16 i_flag) {\n    g_dComIfG_gameInfo.info.getTmp().offEventBit(i_flag);\n}\n\ninline BOOL dComIfGs_isDarkClearLV(int i_no) {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusB().isDarkClearLV(i_no);\n}\n\ninline BOOL dComIfGs_isTmpBit(u16 i_flag) {\n    return g_dComIfG_gameInfo.info.getTmp().isEventBit(i_flag);\n}\n\ninline void dComIfGs_onTmpBit(u16 i_flag) {\n    g_dComIfG_gameInfo.info.getTmp().onEventBit(i_flag);\n}\n\ninline BOOL dComIfGs_isTransformLV(int i_no) {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusB().isTransformLV(i_no);\n}\n\ninline void dComIfGs_onStageLife() {\n    g_dComIfG_gameInfo.info.getMemory().getBit().onStageLife();\n}\n\ninline u8 dComIfGs_getBombNum(u8 i_bagIdx) {\n    return g_dComIfG_gameInfo.info.getPlayer().getItemRecord().getBombNum(i_bagIdx);\n}\n\ninline u8 dComIfGs_getPachinkoNum() {\n    return g_dComIfG_gameInfo.info.getPlayer().getItemRecord().getPachinkoNum();\n}\n\ninline u8 dComIfGs_getBottleNum(u8 i_bottleIdx) {\n    return g_dComIfG_gameInfo.info.getPlayer().getItemRecord().getBottleNum(i_bottleIdx);\n}\n\ninline u8 dComIfGs_getBombMax(u8 i_bombType) {\n    return g_dComIfG_gameInfo.info.getPlayer().getItemMax().getBombNum(i_bombType);\n}\n\ninline void dComIfGs_setBombNum(u8 i_bagIdx, u8 i_bombNum) {\n    g_dComIfG_gameInfo.info.getPlayer().getItemRecord().setBombNum(i_bagIdx, i_bombNum);\n}\n\ninline void dComIfGs_setPachinkoNum(u8 i_num) {\n    g_dComIfG_gameInfo.info.getPlayer().getItemRecord().setPachinkoNum(i_num);\n}\n\ninline void dComIfGs_addBottleNum(u8 i_bottleIdx, s16 i_num) {\n    g_dComIfG_gameInfo.info.getPlayer().getItemRecord().addBottleNum(i_bottleIdx, i_num);\n}\n\ninline void dComIfGs_resetLastWarpAcceptStage() {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerLastMarkInfo().resetWarpAcceptStage();\n}\n\ninline void dComIfGs_offItemFirstBit(u8 i_itemNo) {\n    g_dComIfG_gameInfo.info.getPlayer().getGetItem().offFirstBit(i_itemNo);\n}\n\ninline BOOL dComIfGs_isLetterGetFlag(int i_no) {\n    return g_dComIfG_gameInfo.info.getPlayer().getLetterInfo().isLetterGetFlag(i_no);\n}\n\ninline u8 dComIfGs_getArrowNum() {\n    return g_dComIfG_gameInfo.info.getPlayer().getItemRecord().getArrowNum();\n}\n\ninline u8 dComIfGs_checkEmptyBottle() {\n    return g_dComIfG_gameInfo.info.getPlayer().getItem().checkEmptyBottle();\n}\n\ninline void dComIfGs_initZone() {\n    g_dComIfG_gameInfo.info.initZone();\n}\n\ninline s16 dComIfGs_getStartPoint() {\n    return g_dComIfG_gameInfo.info.getRestart().getStartPoint();\n}\n\ninline u32 dComIfGs_getLastSceneMode() {\n    return g_dComIfG_gameInfo.info.getRestart().getLastMode();\n}\n\ninline void dComIfGs_setTurnRestart(const cXyz& i_position, s16 i_angle, s8 param_2, u32 i_param) {\n    g_dComIfG_gameInfo.info.getTurnRestart().set(i_position, i_angle, param_2, i_param);\n}\n\ninline void dComIfGs_setRestartRoom(const cXyz& i_position, s16 i_angle, s8 i_roomNo) {\n    g_dComIfG_gameInfo.info.getRestart().setRoom(i_position, i_angle, i_roomNo);\n}\n\ninline s8 dComIfGs_getRestartRoomNo() {\n    return g_dComIfG_gameInfo.info.getRestart().getRoomNo();\n}\n\ninline void dComIfGs_setRestartRoomParam(u32 i_param) {\n    g_dComIfG_gameInfo.info.getRestart().setRoomParam(i_param);\n}\n\ninline u8 dComIfGs_getMagic() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().getMagic();\n}\n\ninline u8 dComIfGs_getMaxMagic() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().getMaxMagic();\n}\n\ninline bool dComIfGs_isCollectMirror(u8 i_item) {\n    return g_dComIfG_gameInfo.info.getPlayer().getCollect().isCollectMirror(i_item);\n}\n\ninline bool dComIfGs_isCollectCrystal(u8 i_item) {\n    return g_dComIfG_gameInfo.info.getPlayer().getCollect().isCollectCrystal(i_item);\n}\n\ninline void dComIfGs_onCollectMirror(u8 i_item) {\n    g_dComIfG_gameInfo.info.getPlayer().getCollect().onCollectMirror(i_item);\n}\n\ninline void dComIfGs_onCollectCrystal(u8 i_item) {\n    g_dComIfG_gameInfo.info.getPlayer().getCollect().onCollectCrystal(i_item);\n}\n\ninline u16 dComIfGs_getDate() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusB().getDate();\n}\n\ninline void dComIfGs_setDate(u16 i_date) {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusB().setDate(i_date);\n}\n\ninline f32 dComIfGs_getTime() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusB().getTime();\n}\n\ninline void dComIfGs_setTime(f32 i_time) {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusB().setTime(i_time);\n}\n\ninline void dComIfGs_onDarkClearLV(int i_no) {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusB().onDarkClearLV(i_no);\n}\n\ninline void dComIfGs_onTransformLV(int i_no) {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusB().onTransformLV(i_no);\n}\n\ninline void dComIfGs_onSaveDunSwitch(int i_swNo) {\n    g_dComIfG_gameInfo.info.getDan().onSwitch(i_swNo);\n}\n\ninline void dComIfGs_offSaveDunSwitch(int i_swNo) {\n    g_dComIfG_gameInfo.info.getDan().offSwitch(i_swNo);\n}\n\ninline u8 dComIfGs_getDataNum() {\n    return g_dComIfG_gameInfo.info.getDataNum();\n}\n\ninline void dComIfGs_setDataNum(u8 i_num) {\n    return g_dComIfG_gameInfo.info.setDataNum(i_num);\n}\n\ninline void dComIfGs_setNewFile(u8 i_fileNo) {\n    return g_dComIfG_gameInfo.info.setNewFile(i_fileNo);\n}\n\ninline void dComIfGs_i_setNewFile(u8 i_fileNo) {\n    return g_dComIfG_gameInfo.info.setNewFile(i_fileNo);\n}\n\ninline char* dComIfGs_getPlayerName() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerInfo().getLinkName();\n}\n\ninline char* dComIfGs_getHorseName() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerInfo().getHorseName();\n}\n\ninline u32 dComIfGs_getRaceGameTime() {\n    return g_dComIfG_gameInfo.info.getMiniGame().getRaceGameTime();\n}\n\ninline u32 dComIfGs_getBalloonScore() {\n    return g_dComIfG_gameInfo.info.getMiniGame().getBalloonScore();\n}\n\ninline u8 dComIfGs_getTransformStatus() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().getTransformStatus();\n}\n\ninline bool dComIfGs_isPlayerFieldLastStayFieldDataExistFlag() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerFieldLastStayInfo().isFieldDataExistFlag();\n}\n\ninline void dComIfGs_setPlayerFieldLastStayInfo(const char* i_stage, cXyz& i_pos, s16 i_angle,\n                                                s8 i_point, u8 i_region) {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerFieldLastStayInfo().set(i_stage, i_pos, i_angle,\n                                                                         i_point, i_region);\n}\n\ninline void dComIfGs_setPlayerName(const char* i_name) {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerInfo().setPlayerName(i_name);\n}\n\ninline void dComIfGs_setHorseName(const char* i_name) {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerInfo().setHorseName(i_name);\n}\n\ninline void dComIfGs_setStartPoint(s16 i_point) {\n    g_dComIfG_gameInfo.info.getRestart().setStartPoint(i_point);\n}\n\ninline void dComIfGs_clearRoomSwitch(int i_zoneNo) {\n    g_dComIfG_gameInfo.info.getZone(i_zoneNo).getZoneBit().clearRoomSwitch();\n}\n\ninline void dComIfGs_clearRoomItem(int i_zoneNo) {\n    g_dComIfG_gameInfo.info.getZone(i_zoneNo).getZoneBit().clearRoomItem();\n}\n\ninline void dComIfGs_removeZone(int i_zoneNo) {\n    g_dComIfG_gameInfo.info.removeZone(i_zoneNo);\n}\n\ninline void dComIfGp_removeSimpleModel(J3DModelData* i_modelData, int roomNo) {\n    g_dComIfG_gameInfo.play.removeSimpleModel(i_modelData, roomNo);\n}\n\ninline u32 dComIfGs_getTurnRestartParam() {\n    return g_dComIfG_gameInfo.info.getTurnRestart().getParam();\n}\n\ninline cXyz& dComIfGs_getTurnRestartPos() {\n    return g_dComIfG_gameInfo.info.getTurnRestart().getPos();\n}\n\ninline s16 dComIfGs_getTurnRestartAngleY() {\n    return g_dComIfG_gameInfo.info.getTurnRestart().getAngleY();\n}\n\ninline u32 dComIfGs_getRestartRoomParam() {\n    return g_dComIfG_gameInfo.info.getRestart().getRoomParam();\n}\n\ninline cXyz& dComIfGs_getRestartRoomPos() {\n    return g_dComIfG_gameInfo.info.getRestart().getRoomPos();\n}\n\ninline s16 dComIfGs_getRestartRoomAngleY() {\n    return g_dComIfG_gameInfo.info.getRestart().getRoomAngleY();\n}\n\ninline BOOL dComIfGs_isActor(int i_no, int i_roomNo) {\n    return g_dComIfG_gameInfo.info.isActor(i_no, i_roomNo);\n}\n\ninline void dComIfGs_offActor(int i_no, int i_roomNo) {\n    g_dComIfG_gameInfo.info.offActor(i_no, i_roomNo);\n}\n\ninline void dComIfGs_putSave(int i_stageNo) {\n    g_dComIfG_gameInfo.info.putSave(i_stageNo);\n}\n\ninline void dComIfGs_getSave(int i_stageNo) {\n    g_dComIfG_gameInfo.info.getSave(i_stageNo);\n}\n\ninline void dComIfGs_initDan(s8 i_stageNo) {\n    g_dComIfG_gameInfo.info.initDan(i_stageNo);\n}\n\ninline void dComIfGs_resetDan() {\n    g_dComIfG_gameInfo.info.resetDan();\n}\n\ninline u16 dComIfGs_getRupeeMax() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().getRupeeMax();\n}\n\ninline void dComIfGs_onLightDropGetFlag(u8 i_nowLevel) {\n    g_dComIfG_gameInfo.info.getPlayer().getLightDrop().onLightDropGetFlag(i_nowLevel);\n}\n\ninline void dComIfGs_setTmpReg(u16 i_reg, u8 i_no) {\n    g_dComIfG_gameInfo.info.getTmp().setEventReg(i_reg, i_no);\n}\n\ninline u8 dComIfGs_getTmpReg(u16 i_reg) {\n    return g_dComIfG_gameInfo.info.getTmp().getEventReg(i_reg);\n}\n\ninline u8 i_dComIfGs_getEventReg(u16 reg) {\n    return g_dComIfG_gameInfo.info.getEvent().getEventReg(reg);\n}\n\ninline void dComIfGs_setEventReg(u16 reg, u8 value) {\n    g_dComIfG_gameInfo.info.getEvent().setEventReg(reg, value);\n}\n\ninline void dComIfGs_setWarashibeItem(u8 i_itemNo) {\n    g_dComIfG_gameInfo.info.getPlayer().getItem().setWarashibeItem(i_itemNo);\n}\n\ninline void dComIfGs_setBottleItemIn(u8 curItem, u8 newItem) {\n    g_dComIfG_gameInfo.info.getPlayer().getItem().setBottleItemIn(curItem, newItem);\n}\n\ninline u8 dComIfGs_checkInsectBottle() {\n    return g_dComIfG_gameInfo.info.getPlayer().getItem().checkInsectBottle();\n}\n\ninline u8 dComIfGs_checkBombBag(u8 i_itemNo) {\n    return g_dComIfG_gameInfo.info.getPlayer().getItem().checkBombBag(i_itemNo);\n}\n\ninline s64 dComIfGs_getTotalTime() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerInfo().getTotalTime();\n}\n\ninline void dComIfGs_setSaveTotalTime(s64 i_time) {\n    g_dComIfG_gameInfo.info.setSaveTotalTime(i_time);\n}\n\ninline void dComIfGs_setSaveStartTime(s64 i_time) {\n    g_dComIfG_gameInfo.info.setStartTime(i_time);\n}\n\ninline void dComIfGs_setNoFile(u8 i_file) {\n    g_dComIfG_gameInfo.info.setNoFile(i_file);\n}\n\ninline void* dComIfGs_getPEventBit() {\n    return g_dComIfG_gameInfo.info.getEvent().getPEventBit();\n}\n\ninline bool dComIfGs_isItem(int i_bitNo, int i_roomNo) {\n    return g_dComIfG_gameInfo.info.isItem(i_bitNo, i_roomNo);\n}\n\ninline void dComIfGs_onItem(int i_bitNo, int i_roomNo) {\n    g_dComIfG_gameInfo.info.onItem(i_bitNo, i_roomNo);\n}\n\ninline void dComIfGs_onActor(int i_bitNo, int i_roomNo) {\n    g_dComIfG_gameInfo.info.onActor(i_bitNo, i_roomNo);\n}\n\ninline void dComIfGs_setLastWarpAcceptStage(s8 param_0) {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerLastMarkInfo().setWarpAcceptStage(param_0);\n}\n\ninline void dComIfGs_setOptSound(u8 i_mode) {\n    g_dComIfG_gameInfo.info.getPlayer().getConfig().setSound(i_mode);\n}\n\ninline void dComIfGs_setOptVibration(u8 i_status) {\n    g_dComIfG_gameInfo.info.getPlayer().getConfig().setVibration(i_status);\n}\n\ninline void dComIfGs_setOptAttentionType(u8 i_attentionType) {\n    g_dComIfG_gameInfo.info.getPlayer().getConfig().setAttentionType(i_attentionType);\n}\n\ninline void dComIfGs_setOptCameraControl(u8 i_cameraControl) {\n    g_dComIfG_gameInfo.info.getPlayer().getConfig().setCameraControl(i_cameraControl);\n}\n\ninline void dComIfGs_setOptPointer(u8 i_pointer) {\n    g_dComIfG_gameInfo.info.getPlayer().getConfig().setPointer(i_pointer);\n}\n\ninline u8 dComIfGs_getNewFile() {\n    return g_dComIfG_gameInfo.info.getNewFile();\n}\n\ninline u8 dComIfGs_getNoFile() {\n    return g_dComIfG_gameInfo.info.getNoFile();\n}\n\ninline void dComIfGs_setInitDataToCard(u8* i_saveData, int i_dataNum) {\n    g_dComIfG_gameInfo.info.initdata_to_card((char*)i_saveData, i_dataNum);\n}\n\ninline void dComIfGs_setMemoryToCard(u8* i_saveData, int i_dataNum) {\n    g_dComIfG_gameInfo.info.memory_to_card((char*)i_saveData, i_dataNum);\n}\n\ninline int dComIfGs_createZone(int roomNo) {\n    return g_dComIfG_gameInfo.info.createZone(roomNo);\n}\n\ninline void dComIfGs_addDeathCount() {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerInfo().addDeathCount();\n}\n\ninline u8 dComIfGs_getWalletSize() {\n    return g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().getWalletSize();\n}\n\ninline void dComIfGs_setOptCalValue(s8 i_calValue) {\n    g_dComIfG_gameInfo.info.getPlayer().getConfig().setCalValue(i_calValue);\n}\n\ninline void dComIfGs_setOptCalibrateDist(u16 i_calibrateDist) {\n    g_dComIfG_gameInfo.info.getPlayer().getConfig().setCalibrateDist(i_calibrateDist);\n}\n\ninline u16 dComIfGs_getFishNum(u8 param_0) {\n    return g_dComIfG_gameInfo.info.getPlayer().getFishingInfo().getFishCount(param_0);\n}\n\ninline u8 dComIfGs_getFishSize(u8 param_0) {\n    return g_dComIfG_gameInfo.info.getPlayer().getFishingInfo().getMaxSize(param_0);\n}\n\ninline u8 dComIfGs_getGetNumber(int i_no) {\n    return g_dComIfG_gameInfo.info.getPlayer().getLetterInfo().getGetNumber(i_no);\n}\n\ninline void dComIfGs_setGetNumber(int i_no, u8 i_value) {\n    g_dComIfG_gameInfo.info.getPlayer().getLetterInfo().setGetNumber(i_no, i_value);\n}\n\ninline BOOL dComIfGs_isStageMiddleBoss() {\n    return g_dComIfG_gameInfo.info.getMemory().getBit().isStageBossEnemy2();\n}\n\ninline void dComIfGs_setTransformStatus(u8 i_status) {\n    g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusA().setTransformStatus(i_status);\n}\n\ninline void dComIfGs_setEquipBottleItemIn(u8 i_curItem, u8 i_newItem) {\n    g_dComIfG_gameInfo.info.getPlayer().getItem().setEquipBottleItemIn(i_curItem, i_newItem);\n}\n\ninline void dComIfGs_setEquipBottleItemEmpty(u8 i_curItem) {\n    g_dComIfG_gameInfo.info.getPlayer().getItem().setEquipBottleItemEmpty(i_curItem);\n}\n\nvoid dComIfGp_setSelectItem(int index);\ns32 dComIfGp_offHeapLockFlag(int flag);\nvoid dComIfGp_createSubExpHeap2D();\nvoid dComIfGp_destroySubExpHeap2D();\nint dComIfGp_checkEmptySubHeap2D();\nint dComIfGp_searchUseSubHeap2D(int flag);\nvoid dComIfGp_addSelectItemNum(int index, s16 num);\nu8 dComIfGp_getSelectItem(int index);\nu8 dComIfGp_TargetWarpPt_get();\nvoid dComIfGp_TargetWarpPt_set(u8);\nBOOL dComIfGp_TransportWarp_check();\nu8 dComIfGp_SelectWarpPt_get();\nvoid dComIfGp_setNextStage(char const* stage, s16 point, s8 roomNo, s8 layer, f32 lastSpeed,\n                           u32 lastMode, int, s8 wipe, s16 lastAngle, int, int);\nvoid dComIfGp_setNextStage(char const* stage, s16 point, s8 roomNo, s8 layer);\ns16 dComIfGp_getSelectItemNum(int index);\nint dComIfGp_getSelectItemMaxNum(int index);\nvoid dComIfGp_mapShow();\nvoid dComIfGp_mapHide();\nbool dComIfGp_checkMapShow();\nvoid dComIfGp_ret_wp_set(s8);\ns32 dComIfGp_setHeapLockFlag(u8 flag);\nu8 dComIfGp_world_dark_get();\nJKRExpHeap* dComIfGp_getSubHeap2D(int flag);\nvoid dComIfGp_world_dark_set(u8);\nu8 dComIfGp_getNowLevel();\nvoid dComIfGp_calcNowRegion();\ndaHorse_c* dComIfGp_getHorseActor();\nstatic BOOL dComIfGp_event_runCheck();\nstatic s32 dComIfGp_evmng_getMyStaffId(const char* pName, fopAc_ac_c* pActor, int param_2);\nstatic u16 dComIfGp_event_chkEventFlag(u16 flag);\nstatic s8 dComIfGp_getPlayerCameraID(int idx);\nstatic dEvent_manager_c& dComIfGp_getEventManager();\nstatic u32 dComIfGp_checkPlayerStatus0(int param_0, u32 param_1);\nstatic u32 dComIfGp_checkPlayerStatus1(int param_0, u32 param_1);\nstatic dEvt_control_c& dComIfGp_getEvent();\nstatic bool dComIfGp_evmng_startCheck(char const* param_0);\nstatic dStage_stageDt_c* dComIfGp_getStage();\nvoid dComIfGp_setItemLifeCount(f32 amount, u8 type);\nvoid dComIfGp_setItemRupeeCount(s32 param_0);\nstatic u8 dComIfGp_getDoStatus();\nstatic u8 dComIfGp_getRStatus();\nstatic dAttCatch_c* dComIfGp_att_getCatghTarget();\nstatic void dComIfGp_setBottleStatus(u8 param_0, u8 param_1);\nbool dComIfGp_getMapTrans(int i_roomNo, f32* o_transX, f32* o_transY, s16* o_angle);\nvoid dComIfGp_setSelectItemNum(int i_selItemIdx, s16 i_num);\n\ninline void dComIfGp_itemDataInit() {\n    g_dComIfG_gameInfo.play.itemInit();\n}\n\ninline bool i_dComIfGp_checkPlayerStatus0(int param_0, u32 flag) {\n    return g_dComIfG_gameInfo.play.checkPlayerStatus(param_0, 0, flag);\n}\n\ninline bool i_dComIfGp_checkPlayerStatus1(int param_0, u32 flag) {\n    return g_dComIfG_gameInfo.play.checkPlayerStatus(param_0, 1, flag);\n}\n\ninline void i_dComIfGp_setItemLifeCount(float amount, u8 type) {\n    g_dComIfG_gameInfo.play.setItemLifeCount(amount, type);\n}\n\ninline void i_dComIfGp_setItemRupeeCount(int amount) {\n    g_dComIfG_gameInfo.play.setItemRupeeCount(amount);\n}\n\ninline dStage_startStage_c* dComIfGp_getStartStage() {\n    return g_dComIfG_gameInfo.play.getStartStage();\n}\n\ninline dEvent_manager_c* dComIfGp_getPEvtManager() {\n    return &g_dComIfG_gameInfo.play.getEvtManager();\n}\n\ninline dAttention_c& dComIfGp_getAttention() {\n    return g_dComIfG_gameInfo.play.getAttention();\n}\n\ninline u8 dComIfGp_att_getCatchChgItem() {\n    return dComIfGp_getAttention().getCatchChgItem();\n}\n\ninline fopAc_ac_c* i_dComIfGp_att_getCatghTarget() {\n    return dComIfGp_getAttention().getCatghTarget();\n}\n\ninline int dComIfGp_att_ZHintRequest(fopAc_ac_c* param_1, int param_2) {\n    return dComIfGp_getAttention().ZHintRequest(param_1, param_2);\n}\n\ninline void dComIfGp_att_LookRequest(fopAc_ac_c* param_0, f32 i_horizontalDist, f32 i_upDist,\n                                     f32 i_downDist, s16 i_angle, int param_5) {\n    dComIfGp_getAttention().LookRequest(param_0, i_horizontalDist, i_upDist, i_downDist, i_angle,\n                                        param_5);\n}\n\ninline void dComIfGp_att_CatchRequest(fopAc_ac_c* param_0, u8 param_1, f32 i_horizontalDist,\n                                      f32 i_upDist, f32 i_downDist, s16 i_angle, int param_5) {\n    dComIfGp_getAttention().CatchRequest(param_0, param_1, i_horizontalDist, i_upDist,\n                                         i_downDist, i_angle, param_5);\n}\n\ninline J2DGrafContext* dComIfGp_getCurrentGrafPort() {\n    return g_dComIfG_gameInfo.play.getCurrentGrafPort();\n}\n\ninline dVibration_c& dComIfGp_getVibration() {\n    return g_dComIfG_gameInfo.play.getVibration();\n}\n\ninline daPy_py_c* dComIfGp_getLinkPlayer() {\n    return (daPy_py_c*)g_dComIfG_gameInfo.play.getPlayerPtr(LINK_PTR);\n}\n\ninline fopAc_ac_c* dComIfGp_getPlayer(int idx) {\n    fopAc_ac_c* const link = g_dComIfG_gameInfo.play.getPlayer(idx);\n    fopAc_ac_c* player = (fopAc_ac_c*)link;\n    return player;\n}\n\ninline s8 i_dComIfGp_getPlayerCameraID(int idx) {\n    return g_dComIfG_gameInfo.play.getPlayerCameraID(idx);\n}\n\ninline daHorse_c* i_dComIfGp_getHorseActor() {\n    return (daHorse_c*)g_dComIfG_gameInfo.play.getPlayerPtr(1);\n}\n\ninline dMsgObject_c* dComIfGp_getMsgObjectClass() {\n    return g_dComIfG_gameInfo.play.getMsgObjectClass();\n}\n\ninline camera_class* dComIfGp_getCamera(int idx) {\n    return g_dComIfG_gameInfo.play.getCamera(idx);\n}\n\ninline JKRArchive* dComIfGp_getMain2DArchive() {\n    return g_dComIfG_gameInfo.play.getMain2DArchive();\n}\n\ninline JKRArchive* dComIfGp_getAnmArchive() {\n    return g_dComIfG_gameInfo.play.getAnmArchive();\n}\n\ninline JKRArchive* dComIfGp_getCollectResArchive() {\n    return g_dComIfG_gameInfo.play.getCollectResArchive();\n}\n\ninline JKRArchive* dComIfGp_getItemIconArchive() {\n    return g_dComIfG_gameInfo.play.getItemIconArchive();\n}\n\ninline JKRArchive* dComIfGp_getNameResArchive() {\n    return g_dComIfG_gameInfo.play.getNameResArchive();\n}\n\ninline JKRArchive* dComIfGp_getDemoMsgArchive() {\n    return g_dComIfG_gameInfo.play.getDemoMsgArchive();\n}\n\ninline JKRArchive* dComIfGp_getMsgDtArchive(int idx) {\n    return g_dComIfG_gameInfo.play.getMsgDtArchive(idx);\n}\n\ninline JKRArchive* dComIfGp_getMsgArchive(int idx) {\n    return g_dComIfG_gameInfo.play.getMsgArchive(idx);\n}\n\ninline JKRArchive* dComIfGp_getMsgCommonArchive() {\n    return g_dComIfG_gameInfo.play.getMsgCommonArchive();\n}\n\ninline void dComIfGp_setFieldMapArchive2(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setFieldMapArchive2(arc);\n}\n\ninline void dComIfGp_setAnmArchive(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setAnmArchive(arc);\n}\n\ninline void dComIfGp_setFmapResArchive(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setFmapResArchive(arc);\n}\n\ninline void dComIfGp_setDmapResArchive(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setDmapResArchive(arc);\n}\n\ninline void dComIfGp_setCollectResArchive(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setCollectResArchive(arc);\n}\n\ninline void dComIfGp_setItemIconArchive(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setItemIconArchive(arc);\n}\n\ninline void dComIfGp_setAllMapArchive(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setAllMapArchive(arc);\n}\n\ninline void dComIfGp_setRingResArchive(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setRingResArchive(arc);\n}\n\ninline void dComIfGp_setOptionResArchive(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setOptionResArchive(arc);\n}\n\ninline void dComIfGp_setNameResArchive(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setNameResArchive(arc);\n}\n\ninline void dComIfGp_setDemoMsgArchive(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setDemoMsgArchive(arc);\n}\n\ninline void dComIfGp_setMeterButtonArchive(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setMeterButtonArchive(arc);\n}\n\ninline void dComIfGp_setErrorResArchive(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setErrorResArchive(arc);\n}\n\ninline void dComIfGp_setCardIconResArchive(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setCardIconResArchive(arc);\n}\n\ninline void dComIfGp_setMsgDtArchive(int i, JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setMsgDtArchive(i, arc);\n}\n\ninline void dComIfGp_setMsgCommonArchive(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setMsgCommonArchive(arc);\n}\n\ninline void dComIfGp_setMsgArchive(int i, JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setMsgArchive(i, arc);\n}\n\ninline void dComIfGp_setFontArchive(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setFontArchive(arc);\n}\n\ninline void dComIfGp_setRubyArchive(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setRubyArchive(arc);\n}\n\ninline JKRArchive* dComIfGp_getFontArchive() {\n    return g_dComIfG_gameInfo.play.getFontArchive();\n}\n\ninline JKRArchive* dComIfGp_getRubyArchive() {\n    return g_dComIfG_gameInfo.play.getRubyArchive();\n}\n\ninline void dComIfGp_setMain2DArchive(JKRArchive* arc) {\n    g_dComIfG_gameInfo.play.setMain2DArchive(arc);\n}\n\ninline void dComIfGp_setItemTable(void* data) {\n    g_dComIfG_gameInfo.play.setItemTable(data);\n}\n\ninline void* dComIfGp_getItemTable() {\n    return g_dComIfG_gameInfo.play.getItemTable();\n}\n\ninline JKRExpHeap* dComIfGp_getExpHeap2D() {\n    return g_dComIfG_gameInfo.play.getExpHeap2D();\n}\n\ninline JKRExpHeap* dComIfGp_getMsgExpHeap() {\n    return g_dComIfG_gameInfo.play.getMsgExpHeap();\n}\n\ninline JKRExpHeap* dComIfGp_getSubExpHeap2D(int idx) {\n    return g_dComIfG_gameInfo.play.getSubExpHeap2D(idx);\n}\n\ninline const char* dComIfGp_getStartStageName() {\n    return g_dComIfG_gameInfo.play.getStartStageName();\n}\n\ninline void dComIfGp_setStartStage(dStage_startStage_c* p_startStage) {\n    g_dComIfG_gameInfo.play.setStartStage(p_startStage);\n}\n\ninline s8 dComIfGp_getStartStageRoomNo() {\n    return g_dComIfG_gameInfo.play.getStartStageRoomNo();\n}\n\ninline s8 dComIfGp_getStartStageLayer() {\n    return g_dComIfG_gameInfo.play.getStartStageLayer();\n}\n\ninline s8 dComIfGp_getStartStageDarkArea() {\n    return g_dComIfG_gameInfo.play.getStartStageDarkArea();\n}\n\ninline void dComIfGp_setStartStageDarkArea(s8 darkArea) {\n    g_dComIfG_gameInfo.play.setStartStageDarkArea(darkArea);\n}\n\ninline s16 dComIfGp_getStartStagePoint() {\n    return g_dComIfG_gameInfo.play.getStartStagePoint();\n}\n\ninline const char* dComIfGp_getNextStageName() {\n    return g_dComIfG_gameInfo.play.getNextStageName();\n}\n\ninline dStage_startStage_c* dComIfGp_getNextStartStage() {\n    return g_dComIfG_gameInfo.play.getNextStartStage();\n}\n\ninline s8 dComIfGp_getNextStageRoomNo() {\n    return g_dComIfG_gameInfo.play.getNextStageRoomNo();\n}\n\ninline s8 dComIfGp_getNextStageLayer() {\n    return g_dComIfG_gameInfo.play.getNextStageLayer();\n}\n\ninline s32 dComIfGp_getNextStageWipe() {\n    return g_dComIfG_gameInfo.play.getNextStageWipe();\n}\n\ninline bool dComIfGp_isEnableNextStage() {\n    return g_dComIfG_gameInfo.play.isEnableNextStage();\n}\n\ninline s16 dComIfGp_getNextStagePoint() {\n    return g_dComIfG_gameInfo.play.getNextStagePoint();\n}\n\ninline void dComIfGp_setLastPlayStageName(char* name) {\n    g_dComIfG_gameInfo.play.setLastPlayStageName(name);\n}\n\ninline char* dComIfGp_getLastPlayStageName() {\n    return g_dComIfG_gameInfo.play.getLastPlayStageName();\n}\n\ninline u8 dComIfGp_getGameoverStatus() {\n    return g_dComIfG_gameInfo.play.getGameoverStatus();\n}\n\ninline void dComIfGp_setGameoverStatus(u8 i_status) {\n    return g_dComIfG_gameInfo.play.setGameoverStatus(i_status);\n}\n\ninline u32 dComIfGp_getNowVibration() {\n    return g_dComIfG_gameInfo.play.getNowVibration();\n}\n\ninline void dComIfGp_setRStatus(u8 status, u8 flag) {\n    g_dComIfG_gameInfo.play.setRStatus(status, flag);\n}\n\ninline void dComIfGp_setDoStatus(u8 status, u8 flag) {\n    g_dComIfG_gameInfo.play.setDoStatus(status, flag);\n}\n\ninline void dComIfGp_setAStatus(u8 status, u8 flag) {\n    g_dComIfG_gameInfo.play.setAStatus(status, flag);\n}\n\ninline void dComIfGp_setZStatus(u8 status, u8 flag) {\n    g_dComIfG_gameInfo.play.setZStatus(status, flag);\n}\n\ninline void dComIfGp_setZStatusForce(u8 status, u8 flag) {\n    g_dComIfG_gameInfo.play.setZStatusForce(status, flag);\n}\n\ninline void dComIfGp_set3DStatus(u8 status, u8 direction, u8 flag) {\n    g_dComIfG_gameInfo.play.set3DStatus(status, direction, flag);\n}\n\ninline void dComIfGp_set3DStatusForce(u8 status, u8 direction, u8 flag) {\n    g_dComIfG_gameInfo.play.set3DStatusForce(status, direction, flag);\n}\n\ninline void dComIfGp_setXStatus(u8 status, u8 flag) {\n    g_dComIfG_gameInfo.play.setXStatus(status, flag);\n}\n\ninline void dComIfGp_setXStatusForce(u8 status, u8 flag) {\n    g_dComIfG_gameInfo.play.setXStatusForce(status, flag);\n}\n\ninline void dComIfGp_setYStatus(u8 status, u8 flag) {\n    g_dComIfG_gameInfo.play.setYStatus(status, flag);\n}\n\ninline void dComIfGp_setYStatusForce(u8 status, u8 flag) {\n    g_dComIfG_gameInfo.play.setYStatusForce(status, flag);\n}\n\ninline void dComIfGp_setNunStatus(u8 status, u8 param_1, u8 flag) {\n    g_dComIfG_gameInfo.play.setNunStatus(status, param_1, flag);\n}\n\ninline void dComIfGp_setRemoConStatus(u8 status, u8 param_1, u8 flag) {\n    g_dComIfG_gameInfo.play.setRemoConStatus(status, param_1, flag);\n}\n\ninline void dComIfGp_setNunZStatus(u8 param_0, u8 param_1) {\n    g_dComIfG_gameInfo.play.setNunZStatus(param_0, param_1);\n}\n\ninline void dComIfGp_setNunCStatus(u8 param_0, u8 param_1) {\n    g_dComIfG_gameInfo.play.setNunCStatus(param_0, param_1);\n}\n\ninline void dComIfGp_setCStickStatus(u8 status, u8 param_1, u8 flag) {\n    g_dComIfG_gameInfo.play.setCStickStatus(status, param_1, flag);\n}\n\ninline void dComIfGp_setCStickStatusForce(u8 status, u8 param_1, u8 flag) {\n    g_dComIfG_gameInfo.play.setCStickStatusForce(status, param_1, flag);\n}\n\ninline void dComIfGp_setSButtonStatus(u8 status, u8 flag) {\n    g_dComIfG_gameInfo.play.setSButtonStatus(status, flag);\n}\n\ninline void dComIfGp_setSButtonStatusForce(u8 status, u8 flag) {\n    g_dComIfG_gameInfo.play.setSButtonStatusForce(status, flag);\n}\n\ninline void dComIfGp_setDoStatusForce(u8 status, u8 flag) {\n    g_dComIfG_gameInfo.play.setDoStatusForce(status, flag);\n}\n\ninline void dComIfGp_setAStatusForce(u8 status, u8 flag) {\n    g_dComIfG_gameInfo.play.setAStatusForce(status, flag);\n}\n\ninline void dComIfGp_setRStatusForce(u8 status, u8 flag) {\n    g_dComIfG_gameInfo.play.setRStatusForce(status, flag);\n}\n\ninline u8 dComIfGp_getAStatus() {\n    return g_dComIfG_gameInfo.play.getAStatus();\n}\n\ninline u8 dComIfGp_getXStatus() {\n    return g_dComIfG_gameInfo.play.getXStatus();\n}\n\ninline u8 dComIfGp_getYStatus() {\n    return g_dComIfG_gameInfo.play.getYStatus();\n}\n\ninline u8 dComIfGp_getZStatus() {\n    return g_dComIfG_gameInfo.play.getZStatus();\n}\n\ninline u8 dComIfGp_get3DStatus() {\n    return g_dComIfG_gameInfo.play.get3DStatus();\n}\n\ninline u8 dComIfGp_getCStickStatus() {\n    return g_dComIfG_gameInfo.play.getCStickStatus();\n}\n\ninline u8 dComIfGp_getSButtonStatus() {\n    return g_dComIfG_gameInfo.play.getSButtonStatus();\n}\n\ninline u8 dComIfGp_getNunStatus() {\n    return g_dComIfG_gameInfo.play.getNunStatus();\n}\n\ninline u8 dComIfGp_getNunZStatus() {\n    return g_dComIfG_gameInfo.play.getNunZStatus();\n}\n\ninline u8 dComIfGp_getNunCStatus() {\n    return g_dComIfG_gameInfo.play.getNunCStatus();\n}\n\ninline u8 dComIfGp_getBottleStatus() {\n    return g_dComIfG_gameInfo.play.getBottleStatus();\n}\n\ninline u8 dComIfGp_getRemoConStatus() {\n    return g_dComIfG_gameInfo.play.getRemoConStatus();\n}\n\ninline u8 dComIfGp_getCStickDirectionForce() {\n    return g_dComIfG_gameInfo.play.getCStickDirectionForce();\n}\n\ninline u8 dComIfGp_getCStickStatusForce() {\n    return g_dComIfG_gameInfo.play.getCStickStatusForce();\n}\n\ninline u8 dComIfGp_getCStickSetFlagForce() {\n    return g_dComIfG_gameInfo.play.getCStickSetFlagForce();\n}\n\ninline u8 dComIfGp_getSButtonStatusForce() {\n    return g_dComIfG_gameInfo.play.getSButtonStatusForce();\n}\n\ninline u8 dComIfGp_getSButtonSetFlagForce() {\n    return g_dComIfG_gameInfo.play.getSButtonSetFlagForce();\n}\n\ninline u8 dComIfGp_getDoStatusForce() {\n    return g_dComIfG_gameInfo.play.getDoStatusForce();\n}\n\ninline u8 dComIfGp_getDoSetFlagForce() {\n    return g_dComIfG_gameInfo.play.getDoSetFlagForce();\n}\n\ninline u8 dComIfGp_getAStatusForce() {\n    return g_dComIfG_gameInfo.play.getAStatusForce();\n}\n\ninline u8 dComIfGp_getASetFlagForce() {\n    return g_dComIfG_gameInfo.play.getASetFlagForce();\n}\n\ninline u8 dComIfGp_getRStatusForce() {\n    return g_dComIfG_gameInfo.play.getRStatusForce();\n}\n\ninline u8 dComIfGp_getRSetFlagForce() {\n    return g_dComIfG_gameInfo.play.getRSetFlagForce();\n}\n\ninline u8 dComIfGp_getZStatusForce() {\n    return g_dComIfG_gameInfo.play.getZStatusForce();\n}\n\ninline u8 dComIfGp_getZSetFlagForce() {\n    return g_dComIfG_gameInfo.play.getZSetFlagForce();\n}\n\ninline u8 dComIfGp_getBottleStatusForce() {\n    return g_dComIfG_gameInfo.play.getBottleStatusForce();\n}\n\ninline u8 dComIfGp_getBottleSetFlagForce() {\n    return g_dComIfG_gameInfo.play.getBottleSetFlagForce();\n}\n\ninline u8 dComIfGp_getXStatusForce() {\n    return g_dComIfG_gameInfo.play.getXStatusForce();\n}\n\ninline u8 dComIfGp_getXSetFlagForce() {\n    return g_dComIfG_gameInfo.play.getXSetFlagForce();\n}\n\ninline u8 dComIfGp_getYStatusForce() {\n    return g_dComIfG_gameInfo.play.getYStatusForce();\n}\n\ninline u8 dComIfGp_getYSetFlagForce() {\n    return g_dComIfG_gameInfo.play.getYSetFlagForce();\n}\n\ninline u8 dComIfGp_get3DStatusForce() {\n    return g_dComIfG_gameInfo.play.get3DStatusForce();\n}\n\ninline u8 dComIfGp_get3DDirectionForce() {\n    return g_dComIfG_gameInfo.play.get3DDirectionForce();\n}\n\ninline u8 dComIfGp_get3DSetFlagForce() {\n    return g_dComIfG_gameInfo.play.get3DSetFlagForce();\n}\n\ninline void dComIfGp_onStatus(u16 i_status) {\n    g_dComIfG_gameInfo.play.onStatus(i_status);\n}\n\ninline void dComIfGp_setItemMagicCount(s16 count) {\n    g_dComIfG_gameInfo.play.setItemMagicCount(count);\n}\n\ninline void dComIfGp_setItemMaxMagicCount(s16 count) {\n    g_dComIfG_gameInfo.play.setItemMaxMagicCount(count);\n}\n\ninline void dComIfGp_setItemArrowNumCount(s16 count) {\n    g_dComIfG_gameInfo.play.setItemArrowNumCount(count);\n}\n\ninline void dComIfGp_setItemPachinkoNumCount(s16 count) {\n    g_dComIfG_gameInfo.play.setItemPachinkoNumCount(count);\n}\n\ninline void dComIfGp_setItemBombNumCount(u8 i_item, s16 count) {\n    g_dComIfG_gameInfo.play.setItemBombNumCount(i_item, count);\n}\n\ninline void dComIfGp_setItemKeyNumCount(s16 count) {\n    g_dComIfG_gameInfo.play.setItemKeyNumCount(count);\n}\n\ninline void dComIfGp_setItemMaxLifeCount(s16 count) {\n    g_dComIfG_gameInfo.play.setItemMaxLifeCount(count);\n}\n\ninline void dComIfGp_setItem(u8 slot, u8 i_no) {\n    g_dComIfG_gameInfo.play.setItem(slot, i_no);\n}\n\ninline roomRead_class* dComIfGp_getStageRoom() {\n    return g_dComIfG_gameInfo.play.getStage().getRoom();\n}\n\ninline stage_stag_info_class* dComIfGp_getStageStagInfo() {\n    return g_dComIfG_gameInfo.play.getStage().getStagInfo();\n}\n\ninline stage_envr_info_class* dComIfGp_getStageEnvrInfo() {\n    return g_dComIfG_gameInfo.play.getStage().getEnvrInfo();\n}\n\ninline stage_palette_info_class* dComIfGp_getStagePaletteInfo() {\n    return g_dComIfG_gameInfo.play.getStage().getPaletteInfo();\n}\n\ninline stage_pselect_info_class* dComIfGp_getStagePselectInfo() {\n    return g_dComIfG_gameInfo.play.getStage().getPselectInfo();\n}\n\ninline stage_vrbox_info_class* dComIfGp_getStageVrboxcolInfo() {\n    return g_dComIfG_gameInfo.play.getStage().getVrboxInfo();\n}\n\ninline stage_plight_info_class* dComIfGp_getStagePlightInfo() {\n    return g_dComIfG_gameInfo.play.getStage().getPlightInfo();\n}\n\ninline int dComIfGp_getStagePlightNumInfo() {\n    return g_dComIfG_gameInfo.play.getStage().getPlightNumInfo();\n}\n\ninline u8 dComIfGp_isHeapLockFlag() {\n    return g_dComIfG_gameInfo.play.isHeapLockFlag();\n}\n\ninline void dComIfGp_setSubHeapLockFlag(int idx, u8 status) {\n    g_dComIfG_gameInfo.play.setSubHeapLockFlag(idx, status);\n}\n\ninline u8 dComIfGp_getSubHeapLockFlag(int idx) {\n    return g_dComIfG_gameInfo.play.getSubHeapLockFlag(idx);\n}\n\ninline void dComIfGp_setSubExpHeap2D(int idx, void* heap) {\n    g_dComIfG_gameInfo.play.setSubExpHeap2D(idx, heap);\n}\n\ninline void dComIfGp_setExpHeap2D(void* heap) {\n    g_dComIfG_gameInfo.play.setExpHeap2D(heap);\n}\n\ninline void dComIfGp_setMsgExpHeap(void* heap) {\n    g_dComIfG_gameInfo.play.setMsgExpHeap(heap);\n}\n\ninline void dComIfGp_offEnableNextStage() {\n    g_dComIfG_gameInfo.play.offEnableNextStage();\n}\n\ninline void dComIfGp_setNowVibration(u8 status) {\n    g_dComIfG_gameInfo.play.setNowVibration(status);\n}\n\ninline void dComIfGp_setSelectEquipClothes(u8 i_clothNo) {\n    g_dComIfG_gameInfo.play.setSelectEquip(COLLECT_CLOTHING, i_clothNo);\n}\n\ninline void dComIfGp_setSelectEquipSword(u8 i_swordNo) {\n    g_dComIfG_gameInfo.play.setSelectEquip(COLLECT_SWORD, i_swordNo);\n}\n\ninline void dComIfGp_setSelectEquipShield(u8 i_shieldNo) {\n    g_dComIfG_gameInfo.play.setSelectEquip(COLLECT_SHIELD, i_shieldNo);\n}\n\ninline void dComIfGp_setStatus(u16 status) {\n    g_dComIfG_gameInfo.play.setStatus(status);\n}\n\ninline void dComIfGp_setAdvanceDirection(u8 i_dir) {\n    g_dComIfG_gameInfo.play.setDirection(i_dir);\n}\n\ninline void dComIfGp_setLinkPlayer(fopAc_ac_c* ptr) {\n    g_dComIfG_gameInfo.play.setPlayerPtr(0, ptr);\n}\n\ninline void dComIfGp_setPlayerPtr(int i, fopAc_ac_c* ptr) {\n    g_dComIfG_gameInfo.play.setPlayerPtr(i, ptr);\n}\n\ninline void dComIfGp_setPlayer(int i, fopAc_ac_c* player) {\n    g_dComIfG_gameInfo.play.setPlayer(i, player);\n}\n\ninline void dComIfGp_setPlayerInfo(int plyrIdx, fopAc_ac_c* ptr, int camIdx) {\n    g_dComIfG_gameInfo.play.setPlayerInfo(plyrIdx, ptr, camIdx);\n}\n\ninline void dComIfGp_setPlayerStatus0(int param_0, u32 flag) {\n    g_dComIfG_gameInfo.play.setPlayerStatus(param_0, 0, flag);\n}\n\ninline void dComIfGp_setPlayerStatus1(int param_0, u32 flag) {\n    g_dComIfG_gameInfo.play.setPlayerStatus(param_0, 1, flag);\n}\n\ninline BOOL dComIfGp_checkCameraAttentionStatus(int i, u32 flag) {\n    return g_dComIfG_gameInfo.play.checkCameraAttentionStatus(i, flag);\n}\n\ninline void dComIfGp_onCameraAttentionStatus(int i, u32 flag) {\n    g_dComIfG_gameInfo.play.onCameraAttentionStatus(i, flag);\n}\n\ninline void dComIfGp_offCameraAttentionStatus(int i, u32 flag) {\n    g_dComIfG_gameInfo.play.offCameraAttentionStatus(i, flag);\n}\n\ninline void dComIfGp_setCameraInfo(int camIdx, camera_class* p_cam, int param_2, int param_3,\n                                   int param_4) {\n    g_dComIfG_gameInfo.play.setCameraInfo(camIdx, p_cam, param_2, param_3, param_4);\n}\n\ninline f32 dComIfGp_getCameraZoomForcus(int i_no) {\n    return g_dComIfG_gameInfo.play.getCameraZoomForcus(i_no);\n}\n\ninline u32 dComIfGp_getCameraAttentionStatus(int i_no) {\n    return g_dComIfG_gameInfo.play.getCameraAttentionStatus(i_no);\n}\n\ninline void dComIfGp_clearPlayerStatus0(int param_0, u32 flag) {\n    g_dComIfG_gameInfo.play.clearPlayerStatus(param_0, 0, flag);\n}\n\ninline void dComIfGp_clearPlayerStatus1(int param_0, u32 flag) {\n    g_dComIfG_gameInfo.play.clearPlayerStatus(param_0, 1, flag);\n}\n\ninline dStage_stageDt_c* i_dComIfGp_getStage() {\n    return &g_dComIfG_gameInfo.play.getStage();\n}\n\ninline stage_scls_info_dummy_class* dComIfGp_getStageSclsInfo() {\n    return g_dComIfG_gameInfo.play.getStage().getSclsInfo();\n}\n\ninline void dComIfGp_setItemNowLife(u16 life) {\n    g_dComIfG_gameInfo.play.setItemNowLife(life);\n}\n\ninline void dComIfGp_setItemNowMagic(s16 magic) {\n    g_dComIfG_gameInfo.play.setItemNowMagic(magic);\n}\n\ninline void dComIfGp_setOxygen(int oxygen) {\n    g_dComIfG_gameInfo.play.setOxygen(oxygen);\n}\n\ninline void dComIfGp_setNowOxygen(s32 oxygen) {\n    g_dComIfG_gameInfo.play.setNowOxygen(oxygen);\n}\n\ninline void dComIfGp_setOxygenCount(s32 oxygen) {\n    g_dComIfG_gameInfo.play.setOxygenCount(oxygen);\n}\n\ninline void dComIfGp_setMaxOxygen(s32 i_oxygen) {\n    g_dComIfG_gameInfo.play.setMaxOxygen(i_oxygen);\n}\n\ninline s32 dComIfGp_getMaxOxygen() {\n    return g_dComIfG_gameInfo.play.getMaxOxygen();\n}\n\ninline int dComIfGp_getOxygen() {\n    return g_dComIfG_gameInfo.play.getOxygen();\n}\n\ninline int dComIfGp_getNowOxygen() {\n    return g_dComIfG_gameInfo.play.getNowOxygen();\n}\n\ninline u8 dComIfGp_getOxygenShowFlag() {\n    return g_dComIfG_gameInfo.play.getOxygenShowFlag();\n}\n\ninline void dComIfGp_onOxygenShowFlag() {\n    g_dComIfG_gameInfo.play.setOxygenShowFlag(1);\n}\n\ninline void dComIfGp_offOxygenShowFlag() {\n    g_dComIfG_gameInfo.play.setOxygenShowFlag(0);\n}\n\ninline u8 dComIfGp_getNeedLightDropNum() {\n    return g_dComIfG_gameInfo.play.getNeedLightDropNum();\n}\n\ninline void dComIfGp_setItemNowOil(s32 oil) {\n    g_dComIfG_gameInfo.play.setItemNowOil(oil);\n}\n\ninline void dComIfGp_setItemOilCount(s32 oil) {\n    g_dComIfG_gameInfo.play.setItemOilCount(oil);\n}\n\ninline bool dComIfGp_isDoSetFlag(u8 flag) {\n    return g_dComIfG_gameInfo.play.isDoSetFlag(flag);\n}\n\ninline bool dComIfGp_isASetFlag(u8 flag) {\n    return g_dComIfG_gameInfo.play.isASetFlag(flag);\n}\n\ninline bool dComIfGp_isRSetFlag(u8 flag) {\n    return g_dComIfG_gameInfo.play.isRSetFlag(flag);\n}\n\ninline bool dComIfGp_isXSetFlag(u8 flag) {\n    return g_dComIfG_gameInfo.play.isXSetFlag(flag);\n}\n\ninline bool dComIfGp_isYSetFlag(u8 flag) {\n    return g_dComIfG_gameInfo.play.isYSetFlag(flag);\n}\n\ninline bool dComIfGp_isPauseFlag() {\n    return g_dComIfG_gameInfo.play.isPauseFlag();\n}\n\ninline bool dComIfGp_isCStickSetFlag(u8 flag) {\n    return g_dComIfG_gameInfo.play.isCStickSetFlag(flag);\n}\n\ninline void dComIfGp_offPauseFlag() {\n    g_dComIfG_gameInfo.play.offPauseFlag();\n}\n\ninline void dComIfGp_setMesgCancelButton(u8 button) {\n    g_dComIfG_gameInfo.play.setMesgCancelButton(button);\n}\n\ninline void dComIfGp_setMesgBgmOn() {\n    g_dComIfG_gameInfo.play.setMesgBgm(1);\n}\n\ninline void dComIfGp_setMessageCountNumber(u32 number) {\n    g_dComIfG_gameInfo.play.setMessageCountNumber(number);\n}\n\ninline s32 dComIfGp_checkStatus(u16 flags) {\n    return g_dComIfG_gameInfo.play.checkStatus(flags);\n}\n\ninline s16 dComIfGp_getItemPachinkoNumCount() {\n    return g_dComIfG_gameInfo.play.getItemPachinkoNumCount();\n}\n\ninline void dComIfGp_clearItemPachinkoNumCount() {\n    g_dComIfG_gameInfo.play.clearItemPachinkoNumCount();\n}\n\ninline void dComIfGp_2dShowOn() {\n    g_dComIfG_gameInfo.play.show2dOn();\n}\n\ninline void dComIfGp_2dShowOff() {\n    g_dComIfG_gameInfo.play.show2dOff();\n}\n\ninline u8 dComIfGp_2dShowCheck() {\n    return g_dComIfG_gameInfo.play.show2dCheck();\n}\n\ninline s16 dComIfGp_getItemMaxLifeCount() {\n    return g_dComIfG_gameInfo.play.getItemMaxLifeCount();\n}\n\ninline f32 dComIfGp_getItemLifeCount() {\n    return g_dComIfG_gameInfo.play.getItemLifeCount();\n}\n\ninline s16 dComIfGp_getItemMaxArrowNumCount() {\n    return g_dComIfG_gameInfo.play.getItemMaxArrowNumCount();\n}\n\ninline s16 dComIfGp_getItemArrowNumCount() {\n    return g_dComIfG_gameInfo.play.getItemArrowNumCount();\n}\n\ninline s16 dComIfGp_getItemBombNumCount(u8 i_no) {\n    return g_dComIfG_gameInfo.play.getItemBombNumCount(i_no);\n}\n\ninline s32 dComIfGp_getItemMaxOilCount() {\n    return g_dComIfG_gameInfo.play.getItemMaxOilCount();\n}\n\ninline s32 dComIfGp_getItemOilCount() {\n    return g_dComIfG_gameInfo.play.getItemOilCount();\n}\n\ninline s32 dComIfGp_getMaxOxygenCount() {\n    return g_dComIfG_gameInfo.play.getMaxOxygenCount();\n}\n\ninline s32 dComIfGp_getOxygenCount() {\n    return g_dComIfG_gameInfo.play.getOxygenCount();\n}\n\ninline s32 dComIfGp_getItemRupeeCount() {\n    return g_dComIfG_gameInfo.play.getItemRupeeCount();\n}\n\ninline void dComIfGp_clearItemRupeeCount() {\n    g_dComIfG_gameInfo.play.clearItemRupeeCount();\n}\n\ninline s16 dComIfGp_getItemKeyNumCount() {\n    return g_dComIfG_gameInfo.play.getItemKeyNumCount();\n}\n\ninline void dComIfGp_clearItemMaxOilCount() {\n    g_dComIfG_gameInfo.play.clearItemMaxOilCount();\n}\n\ninline void dComIfGp_clearItemBombNumCount(u8 i_no) {\n    g_dComIfG_gameInfo.play.clearItemBombNumCount(i_no);\n}\n\ninline void dComIfGp_clearItemOilCount() {\n    g_dComIfG_gameInfo.play.clearItemOilCount();\n}\n\ninline void dComIfGp_clearMaxOxygenCount() {\n    g_dComIfG_gameInfo.play.clearMaxOxygenCount();\n}\n\ninline void dComIfGp_clearOxygenCount() {\n    g_dComIfG_gameInfo.play.clearOxygenCount();\n}\n\ninline void dComIfGp_clearItemKeyNumCount() {\n    g_dComIfG_gameInfo.play.clearItemKeyNumCount();\n}\n\ninline void dComIfGp_clearItemArrowNumCount() {\n    g_dComIfG_gameInfo.play.clearItemArrowNumCount();\n}\n\ninline void dComIfGp_clearItemLifeCount() {\n    g_dComIfG_gameInfo.play.clearItemLifeCount();\n}\n\ninline void dComIfGp_clearItemMaxLifeCount() {\n    g_dComIfG_gameInfo.play.clearItemMaxLifeCount();\n}\n\ninline u8 dComIfGp_getItemLifeCountType() {\n    return g_dComIfG_gameInfo.play.getItemLifeCountType();\n}\n\ninline u16 dComIfGp_getItemNowLife() {\n    return g_dComIfG_gameInfo.play.getItemNowLife();\n}\n\ninline s32 dComIfGp_getItemNowOil() {\n    return g_dComIfG_gameInfo.play.getItemNowOil();\n}\n\ninline int dComIfGp_getMessageCountNumber() {\n    return g_dComIfG_gameInfo.play.getMessageCountNumber();\n}\n\ninline u8 dComIfGp_getMesgFaceAnimeAttrInfo() {\n    return g_dComIfG_gameInfo.play.getFaceAnimeID();\n}\n\ninline u8 dComIfGp_getMesgAnimeAttrInfo() {\n    return g_dComIfG_gameInfo.play.getBaseAnimeID();\n}\n\ninline void dComIfGp_setCameraParamFileName(int i, char* name) {\n    g_dComIfG_gameInfo.play.setCameraParamFileName(i, name);\n}\n\ninline void dComIfGp_setCamera(int i, camera_class* cam) {\n    g_dComIfG_gameInfo.play.setCamera(i, cam);\n}\n\ninline const char* dComIfGp_getCameraParamFileName(int i) {\n    return g_dComIfG_gameInfo.play.getCameraParamFileName(i);\n}\n\ninline void dComIfGp_setWindowNum(int num) {\n    g_dComIfG_gameInfo.play.setWindowNum(num);\n}\n\ninline int dComIfGp_getWindowNum() {\n    return g_dComIfG_gameInfo.play.getWindowNum();\n}\n\ninline dDlst_window_c* dComIfGp_getWindow(int i) {\n    return g_dComIfG_gameInfo.play.getWindow(i);\n}\n\ninline void dComIfGp_setWindow(u8 i, f32 param_1, f32 param_2, f32 param_3, f32 param_4,\n                               f32 param_5, f32 param_6, int camID, int mode) {\n    g_dComIfG_gameInfo.play.setWindow(i, param_1, param_2, param_3, param_4, param_5, param_6,\n                                      camID, mode);\n}\n\ninline s8 dComIfGp_getLayerOld() {\n    return g_dComIfG_gameInfo.play.getLayerOld();\n}\n\ninline void dComIfGp_resetOldMulti() {\n    g_dComIfG_gameInfo.play.getStage().resetOldMulti();\n}\n\ninline void dComIfGp_setOldMulti() {\n    g_dComIfG_gameInfo.play.getStage().setOldMulti();\n}\n\ninline void dComIfGp_setStartStageLayer(s8 layer) {\n    g_dComIfG_gameInfo.play.setStartStageLayer(layer);\n}\n\ninline void dComIfGp_drawSimpleModel() {\n    g_dComIfG_gameInfo.play.drawSimpleModel();\n}\n\ninline void dComIfGp_entrySimpleModel(J3DModel *model,int roomNo) {\n    g_dComIfG_gameInfo.play.entrySimpleModel(model, roomNo);\n}\n\n\ninline dStage_Multi_c* dComIfGp_getMulti() {\n    return g_dComIfG_gameInfo.play.getStage().getMulti();\n}\n\ninline JKRAramArchive* dComIfGp_getFieldMapArchive2() {\n    return g_dComIfG_gameInfo.play.getFieldMapArchive2();\n}\n\ninline JKRArchive* dComIfGp_getOptionResArchive() {\n    return g_dComIfG_gameInfo.play.getOptionResArchive();\n}\n\ninline JKRArchive* dComIfGp_getRingResArchive() {\n    return g_dComIfG_gameInfo.play.getRingResArchive();\n}\n\ninline void dComIfGp_onPauseFlag() {\n    g_dComIfG_gameInfo.play.onPauseFlag();\n}\n\ninline void dComIfGp_createSimpleModel() {\n    g_dComIfG_gameInfo.play.createSimpleModel();\n}\n\ninline void i_dComIfGp_setHitMark(u16 i_hitmark, fopAc_ac_c* param_1, const cXyz* param_2,\n                                  const csXyz* param_3, const cXyz* param_4, u32 i_atType) {\n    g_dComIfG_gameInfo.play.getParticle()->setHitMark(i_hitmark, param_1, param_2, param_3, param_4,\n                                                      i_atType);\n}\n\ninline JKRArchive* dComIfGp_getFmapResArchive() {\n    return g_dComIfG_gameInfo.play.getFmapResArchive();\n}\n\ninline JKRArchive* dComIfGp_getDmapResArchive() {\n    return g_dComIfG_gameInfo.play.getDmapResArchive();\n}\n\ninline u8 dComIfGp_getMesgStatus() {\n    return g_dComIfG_gameInfo.play.getMesgStatus();\n}\n\ninline void dComIfGp_setMesgCameraTagInfo(int param_0) {\n    g_dComIfG_gameInfo.play.setMesgCamInfoID(param_0);\n}\n\ninline void dComIfGp_setMesgCameraInfoActor(fopAc_ac_c* param_1, fopAc_ac_c* param_2,\n                                            fopAc_ac_c* param_3, fopAc_ac_c* param_4,\n                                            fopAc_ac_c* param_5, fopAc_ac_c* param_6,\n                                            fopAc_ac_c* param_7, fopAc_ac_c* param_8,\n                                            fopAc_ac_c* param_9, fopAc_ac_c* param_10)\n\n{\n    g_dComIfG_gameInfo.play.setMesgCamInfoActor(param_1, param_2, param_3, param_4, param_5,\n                                                param_6, param_7, param_8, param_9, param_10);\n}\n\ninline int dComIfGp_getMesgCameraInfo() {\n    return g_dComIfG_gameInfo.play.getMesgCamInfo();\n}\n\ninline s32 dComIfGp_roomControl_getStayNo() {\n    return dStage_roomControl_c::getStayNo();\n}\n\ninline s32 dComIfGp_roomControl_getZoneNo(int i_roomNo) {\n    return dStage_roomControl_c::getZoneNo(i_roomNo);\n}\n\ninline void dComIfGp_roomControl_initZone() {\n    g_dComIfG_gameInfo.play.getRoomControl()->initZone();\n}\n\ninline void dComIfGp_roomControl_init() {\n    g_dComIfG_gameInfo.play.getRoomControl()->init();\n}\n\ninline dStage_roomStatus_c* dComIfGp_roomControl_getStatusRoomDt(int room_no) {\n    return g_dComIfG_gameInfo.play.getRoomControl()->getStatusRoomDt(room_no);\n}\n\ninline s32 dComIfGp_roomControl_getTimePass() {\n    return g_dComIfG_gameInfo.play.getRoomControl()->GetTimePass();\n}\n\ninline void dComIfGp_roomControl_setTimePass(int isPassing) {\n    g_dComIfG_gameInfo.play.getRoomControl()->SetTimePass(isPassing);\n}\n\ninline int dComIfGp_roomControl_loadRoom(int param_0, u8* param_1, bool param_2) {\n    return g_dComIfG_gameInfo.play.getRoomControl()->loadRoom(param_0, param_1, param_2);\n}\n\ninline void dComIfGp_roomControl_setStayNo(int stayNo) {\n    g_dComIfG_gameInfo.play.getRoomControl()->setStayNo(stayNo);\n}\n\ninline void dComIfGp_roomControl_setZoneNo(int roomNo, int zoneNo) {\n    g_dComIfG_gameInfo.play.getRoomControl()->setZoneNo(roomNo, zoneNo);\n}\n\ninline dKy_tevstr_c* dComIfGp_roomControl_getTevStr(int i_roomNo) {\n    return g_dComIfG_gameInfo.play.getRoomControl()->getTevStr(i_roomNo);\n}\n\ninline BOOL dComIfGp_roomControl_checkRoomDisp(int i_roomNo) {\n    return g_dComIfG_gameInfo.play.getRoomControl()->checkRoomDisp(i_roomNo);\n}\n\ninline BOOL dComIfGp_roomControl_checkStatusFlag(int i_roomNo, u8 flag) {\n    return g_dComIfG_gameInfo.play.getRoomControl()->checkStatusFlag(i_roomNo, flag);\n}\n\ninline void dComIfGp_roomControl_offStatusFlag(int i_roomNo, u8 flag) {\n    return g_dComIfG_gameInfo.play.getRoomControl()->offStatusFlag(i_roomNo, flag);\n}\n\ninline void dComIfGp_roomControl_onStatusFlag(int i_roomNo, u8 flag) {\n    return g_dComIfG_gameInfo.play.getRoomControl()->onStatusFlag(i_roomNo, flag);\n}\n\ninline void dComIfGp_roomControl_setStatusFlag(int i_roomNo, u8 flag) {\n    return g_dComIfG_gameInfo.play.getRoomControl()->setStatusFlag(i_roomNo, flag);\n}\n\ninline void dComIfGp_roomControl_zoneCountCheck(int i_roomNo) {\n    g_dComIfG_gameInfo.play.mRoomControl.zoneCountCheck(i_roomNo);\n}\n\ninline u8 i_dComIfGp_getRStatus() {\n    return g_dComIfG_gameInfo.play.getRStatus();\n}\n\ninline void i_dComIfGp_setBottleStatus(u8 param_0, u8 param_1) {\n    g_dComIfG_gameInfo.play.setBottleStatus(param_0, param_1);\n}\n\ninline void dComIfGp_setBottleStatusForce(u8 param_0, u8 param_1) {\n    g_dComIfG_gameInfo.play.setBottleStatusForce(param_0, param_1);\n}\n\ninline u8 i_dComIfGp_getDoStatus() {\n    return g_dComIfG_gameInfo.play.getDoStatus();\n}\n\ninline dEvt_control_c& i_dComIfGp_getEvent() {\n    return g_dComIfG_gameInfo.play.getEvent();\n}\n\ninline dEvent_manager_c& i_dComIfGp_getEventManager() {\n    return g_dComIfG_gameInfo.play.getEvtManager();\n}\n\ninline void dComIfGp_setCurrentGrafPort(J2DOrthoGraph* i_graf) {\n    g_dComIfG_gameInfo.play.setCurrentGrafPort(i_graf);\n}\n\ninline void dComIfGp_setCurrentWindow(dDlst_window_c* i_window) {\n    g_dComIfG_gameInfo.play.setCurrentWindow(i_window);\n}\n\ninline void dComIfGp_setCurrentView(view_class* i_view) {\n    g_dComIfG_gameInfo.play.setCurrentView(i_view);\n}\n\ninline void dComIfGp_setCurrentViewport(view_port_class* i_viewport) {\n    g_dComIfG_gameInfo.play.setCurrentViewport(i_viewport);\n}\n\ninline BOOL dComIfGp_event_compulsory(void* param_0, const char* param_1, u16 param_2) {\n    return g_dComIfG_gameInfo.play.getEvent().compulsory(param_0, param_1, param_2);\n}\n\ninline int dComIfGp_event_moveApproval(void* actor) {\n    return g_dComIfG_gameInfo.play.getEvent().moveApproval(actor);\n}\n\ninline int dComIfGp_event_order(u16 eventType, u16 priority, u16 flag, u16 param_3, void* param_4,\n                                void* param_5, s16 eventID, u8 infoIdx) {\n    return g_dComIfG_gameInfo.play.getEvent().order(eventType, priority, flag, param_3, param_4,\n                                                    param_5, eventID, infoIdx);\n}\n\ninline void dComIfGp_event_setGtItm(int i_itemNo) {\n    g_dComIfG_gameInfo.play.getEvent().setGtItm(i_itemNo);\n}\n\ninline void i_dComIfGp_event_reset() {\n    g_dComIfG_gameInfo.play.getEvent().reset();\n}\n\ninline void dComIfGp_event_onEventFlag(u16 i_flag) {\n    g_dComIfG_gameInfo.play.getEvent().onEventFlag(i_flag);\n}\n\ninline void dComIfGp_event_onHindFlag(u16 i_flag) {\n    g_dComIfG_gameInfo.play.getEvent().onHindFlag(i_flag);\n}\n\ninline void dComIfGp_evmng_cutEnd(int param_0) {\n    dComIfGp_getPEvtManager()->cutEnd(param_0);\n}\n\ninline cXyz* dComIfGp_evmng_getGoal() {\n    return dComIfGp_getPEvtManager()->getGoal();\n}\n\ninline BOOL i_dComIfGp_evmng_startCheck(char const* i_event) {\n    return g_dComIfG_gameInfo.play.getEvtManager().startCheckOld(i_event);\n}\n\ninline BOOL dComIfGp_evmng_endCheck(const char* event) {\n    return g_dComIfG_gameInfo.play.getEvtManager().endCheckOld(event);\n}\n\ninline BOOL dComIfGp_evmng_endCheck(s16 eventID) {\n    return g_dComIfG_gameInfo.play.getEvtManager().endCheck(eventID);\n}\n\ninline u8 dComIfGp_event_getPreItemNo() {\n    return g_dComIfG_gameInfo.play.getEvent().getPreItemNo();\n}\n\ninline void dComIfGp_event_setItemPartner(void* param_0) {\n    g_dComIfG_gameInfo.play.getEvent().setPtI(param_0);\n}\n\ninline void dComIfGp_event_setItemPartnerId(unsigned int id) {\n    g_dComIfG_gameInfo.play.getEvent().setPtI_Id(id);\n}\n\ninline u8 dComIfGp_event_getGtItm() {\n    return g_dComIfG_gameInfo.play.getEvent().getGtItm();\n}\n\ninline int dComIfGp_evmng_startDemo(int param_0) {\n    return dComIfGp_getPEvtManager()->setStartDemo(param_0);\n}\n\ninline fopAc_ac_c* dComIfGp_event_getTalkPartner() {\n    u32 t = g_dComIfG_gameInfo.play.getEvent().mPtT;\n    return g_dComIfG_gameInfo.play.getEvent().convPId(t);\n}\n\ninline fopAc_ac_c* dComIfGp_event_getItemPartner() {\n    u32 i = g_dComIfG_gameInfo.play.getEvent().mPtI;\n    return g_dComIfG_gameInfo.play.getEvent().convPId(i);\n}\n\ninline fopAc_ac_c* dComIfGp_event_getPt1() {\n    u32 pt1 = g_dComIfG_gameInfo.play.getEvent().mPt1;\n    return g_dComIfG_gameInfo.play.getEvent().convPId(pt1);\n}\n\ninline fopAc_ac_c* dComIfGp_event_getPt2() {\n    u32 pt2 = g_dComIfG_gameInfo.play.getEvent().mPt2;\n    return g_dComIfG_gameInfo.play.getEvent().convPId(pt2);\n}\n\ninline BOOL i_dComIfGp_event_runCheck() {\n    return g_dComIfG_gameInfo.play.getEvent().runCheck();\n}\n\ninline f32 dComIfGp_event_getCullRate() {\n    return g_dComIfG_gameInfo.play.getEvent().getCullRate();\n}\n\ninline u16 dComIfGp_event_checkHind(u16 flag) {\n    if (!i_dComIfGp_event_runCheck()) {\n        return false;\n    }\n    return g_dComIfG_gameInfo.play.getEvent().checkHind(flag);\n}\n\ninline u16 i_dComIfGp_event_chkEventFlag(u16 flag) {\n    return g_dComIfG_gameInfo.play.getEvent().chkEventFlag(flag);\n}\n\ninline BOOL dComIfGp_event_chkTalkXY() {\n    return g_dComIfG_gameInfo.play.getEvent().chkTalkXY();\n}\n\ninline void dComIfGp_event_setCullRate(f32 f) {\n    g_dComIfG_gameInfo.play.getEvent().setCullRate(f);\n}\n\ninline int i_dComIfGp_evmng_getMyStaffId(const char* pName, fopAc_ac_c* pActor, int param_2) {\n    return dComIfGp_getPEvtManager()->getMyStaffId(pName, pActor, param_2);\n}\n\ninline int dComIfGp_evmng_getMyActIdx(int i_staffIdx, char** param_1, int param_2, int param_3,\n                                      int param_4) {\n    return dComIfGp_getPEvtManager()->getMyActIdx(i_staffIdx, param_1, param_2, param_3, param_4);\n}\n\ninline int dComIfGp_evmng_getIsAddvance(int param_0) {\n    return dComIfGp_getPEvtManager()->getIsAddvance(param_0);\n}\n\ninline int* dComIfGp_evmng_getMyIntegerP(int index, char* name) {\n    return (int*)dComIfGp_getPEvtManager()->getMySubstanceP(index, name, dEvDtData_c::TYPE_INT);\n}\n\ninline char* dComIfGp_evmng_getMyStringP(int index, char* name) {\n    return (char*)dComIfGp_getPEvtManager()->getMySubstanceP(index, name, dEvDtData_c::TYPE_STRING);\n}\n\ninline f32* dComIfGp_evmng_getMyFloatP(int index, char* name) {\n    return (f32*)dComIfGp_getPEvtManager()->getMySubstanceP(index, name, dEvDtData_c::TYPE_FLOAT);\n}\n\ninline cXyz* dComIfGp_evmng_getMyXyzP(int index, char* name) {\n    return (cXyz*)dComIfGp_getPEvtManager()->getMySubstanceP(index, name, dEvDtData_c::TYPE_VEC);\n}\n\ninline int dComIfGp_evmng_getMySubstanceNum(int index, char* name) {\n    return dComIfGp_getPEvtManager()->getMySubstanceNum(index, name);\n}\n\ninline void dComIfGp_evmng_setGoal(cXyz* i_goal) {\n    dComIfGp_getPEvtManager()->setGoal(i_goal);\n}\n\ninline BOOL dComIfGp_evmng_ChkPresentEnd() {\n    return dComIfGp_getPEvtManager()->ChkPresentEnd();\n}\n\ninline int dComIfGp_evmng_checkStartDemo() {\n    return dComIfGp_getPEvtManager()->checkStartDemo();\n}\n\ninline void dComIfGp_evmng_create() {\n    g_dComIfG_gameInfo.play.getEvtManager().create();\n}\n\ninline void dComIfGp_evmng_remove() {\n    g_dComIfG_gameInfo.play.getEvtManager().remove();\n}\n\ninline void dComIfGp_particle_createCommon(const void* data) {\n    g_dComIfG_gameInfo.play.getParticle()->createCommon(data);\n}\n\ninline void dComIfGp_particle_create() {\n    g_dComIfG_gameInfo.play.createParticle();\n}\n\ninline void dComIfGp_particle_createScene(const void* param_0) {\n    g_dComIfG_gameInfo.play.getParticle()->createScene(param_0);\n}\n\ninline JKRExpHeap* dComIfGp_particle_getResHeap() {\n    return g_dComIfG_gameInfo.play.getParticle()->getResHeap();\n}\n\ninline void dComIfGp_particle_readScene(u8 particle_no, mDoDvdThd_toMainRam_c** param_1) {\n    g_dComIfG_gameInfo.play.getParticle()->readScene(particle_no, param_1);\n}\n\ninline void dComIfGp_particle_calc3D() {\n    g_dComIfG_gameInfo.play.getParticle()->calc3D();\n}\n\ninline void dComIfGp_particle_calc2D() {\n    g_dComIfG_gameInfo.play.getParticle()->calc2D();\n}\n\ninline void dComIfGp_particle_calcMenu() {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->calcMenu();\n    }\n}\n\ninline void dComIfGp_particle_cleanup() {\n    g_dComIfG_gameInfo.play.getParticle()->cleanup();\n}\n\ninline void dComIfGp_particle_removeScene(bool param_0) {\n    g_dComIfG_gameInfo.play.getParticle()->removeScene(param_0);\n}\n\ninline void dComIfGp_particle_drawFogPri0_B(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->drawFogPri0_B(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_drawNormalPri0_B(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->drawNormalPri0_B(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_drawFogPri0_A(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->drawFogPri0_A(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_drawNormalPri0_A(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->drawNormalPri0_A(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_drawFogPri4(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->drawFogPri4(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_drawProjection(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->drawProjection(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_drawFogPri1(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->drawFogPri1(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_draw(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->drawNormal(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_drawFogPri2(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->drawFogPri2(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_drawFog(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->drawNormalFog(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_drawFogPri3(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->drawFogPri3(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_drawP1(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->drawNormalP1(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_drawDarkworld(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->drawDarkworld(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_drawScreen(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->drawFogScreen(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_draw2Dgame(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->draw2Dgame(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_draw2Dfore(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->draw2Dfore(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_draw2Dback(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->draw2Dback(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_draw2DmenuFore(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->draw2DmenuFore(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_draw2DmenuBack(JPADrawInfo* i_drawInfo) {\n    if (g_dComIfG_gameInfo.play.getParticle() != NULL) {\n        g_dComIfG_gameInfo.play.getParticle()->draw2DmenuBack(i_drawInfo);\n    }\n}\n\ninline void dComIfGp_particle_setWaterRipple(u32* param_0, cBgS_PolyInfo& param_1,\n                                             const cXyz* param_2, f32 param_3,\n                                             const dKy_tevstr_c* param_4, const cXyz* param_5,\n                                             s8 param_6) {\n    g_dComIfG_gameInfo.play.getParticle()->setWaterRipple(param_0, param_1, param_2, param_3,\n                                                          param_4, param_5, param_6);\n}\n\ninline u16 dComIfGp_particle_setCommonPoly(u32* param_0, cBgS_PolyInfo* param_1,\n                                           const cXyz* param_2, const cXyz* param_3,\n                                           const dKy_tevstr_c* param_4, u32 param_5, u32 param_6,\n                                           const csXyz* param_7, const cXyz* param_8, s8 param_9) {\n    return g_dComIfG_gameInfo.play.getParticle()->setCommonPoly(\n        param_0, param_1, param_2, param_3, param_4, param_5, param_6, param_7, param_8, param_9);\n}\n\ninline u32 dComIfGp_particle_setStopContinue(u32 param_0) {\n    return g_dComIfG_gameInfo.play.getParticle()->setStopContinue(param_0);\n}\n\ninline int dComIfG_getTimerNowTimeMs() {\n    return g_dComIfG_gameInfo.play.getTimerNowTimeMs();\n}\n\ninline void dComIfG_setTimerNowTimeMs(int time) {\n    g_dComIfG_gameInfo.play.setTimerNowTimeMs(time);\n}\n\ninline void dComIfGp_clearMesgAnimeTagInfo() {\n    g_dComIfG_gameInfo.play.clearNowAnimeID();\n}\n\ninline void dComIfGp_clearMesgCameraTagInfo() {\n    g_dComIfG_gameInfo.play.clearMesgCamInfoID();\n}\n\ninline u32 dComIfGp_particle_set(u32 param_0, u16 param_1, const cXyz* param_2,\n                                 const dKy_tevstr_c* param_3, const csXyz* param_4,\n                                 const cXyz* param_5, u8 param_6, dPa_levelEcallBack* param_7,\n                                 s8 param_8, const GXColor* param_9, const GXColor* param_10,\n                                 const cXyz* param_11) {\n    return g_dComIfG_gameInfo.play.getParticle()->setNormal(\n        param_0, param_1, param_2, param_3, param_4, param_5, param_6, param_7, param_8, param_9,\n        param_10, param_11, 1.0f);\n}\n\ninline u32 dComIfGp_particle_set(u32 param_0, u16 param_1, const cXyz* param_2,\n                                 const csXyz* param_3, const cXyz* param_4, u8 param_5,\n                                 dPa_levelEcallBack* param_6, s8 param_7, const GXColor* param_8,\n                                 const GXColor* param_9, const cXyz* param_10) {\n    return g_dComIfG_gameInfo.play.getParticle()->setNormal(\n        param_0, param_1, param_2, NULL, param_3, param_4, param_5, param_6, param_7, param_8,\n        param_9, param_10, 1.0f);\n}\n\ninline u32 dComIfGp_particle_set(u32 param_0, u16 param_1, const cXyz* param_2,\n                                 const dKy_tevstr_c* param_3) {\n    return dComIfGp_particle_set(param_0, param_1, param_2, param_3, 0, 0, 0xFF, 0, 0xFFFFFFFF, 0,\n                                 0, 0);\n}\n\ninline JPABaseEmitter* dComIfGp_particle_set(u16 i_resID, const cXyz* i_pos,\n                                             const dKy_tevstr_c* param_3, const csXyz* i_rotation,\n                                             const cXyz* i_scale, u8 i_alpha,\n                                             dPa_levelEcallBack* i_callback, s8 param_8,\n                                             const GXColor* i_prmColor, const GXColor* i_envColor,\n                                             const cXyz* i_particleScale) {\n    return g_dComIfG_gameInfo.play.getParticle()->setNormal(\n        i_resID, i_pos, param_3, i_rotation, i_scale, i_alpha, i_callback, param_8, i_prmColor,\n        i_envColor, i_particleScale, 1.0f);\n}\n\ninline JPABaseEmitter* dComIfGp_particle_set(u16 i_resID, const cXyz* i_pos,\n                                             const csXyz* i_rotation, const cXyz* i_scale,\n                                             u8 i_alpha, dPa_levelEcallBack* i_callback, s8 param_7,\n                                             const GXColor* i_prmColor, const GXColor* i_envColor,\n                                             const cXyz* i_particleScale) {\n    return g_dComIfG_gameInfo.play.getParticle()->setNormal(\n        i_resID, i_pos, NULL, i_rotation, i_scale, i_alpha, i_callback, param_7, i_prmColor,\n        i_envColor, i_particleScale, 1.0f);\n}\n\ninline JPABaseEmitter* dComIfGp_particle_set(u16 i_resID, const cXyz* i_pos,\n                                             const csXyz* i_rotation, const cXyz* i_scale) {\n    return dComIfGp_particle_set(i_resID, i_pos, NULL, i_rotation, i_scale, 255, NULL, -1, NULL,\n                                 NULL, NULL);\n}\n\ninline JPABaseEmitter* dComIfGp_particle_set(u16 i_resID, const cXyz* i_pos,\n                                             const dKy_tevstr_c* param_2, const csXyz* i_rotation,\n                                             const cXyz* i_scale) {\n    return dComIfGp_particle_set(i_resID, i_pos, param_2, i_rotation, i_scale, 255, NULL, -1, NULL,\n                                 NULL, NULL);\n}\n\ninline u32 dComIfGp_particle_set(u32 param_0, u16 param_1, const cXyz* param_2,\n                                 const csXyz* param_3, const cXyz* param_4) {\n    return dComIfGp_particle_set(param_0, param_1, param_2, param_3, param_4, 0xFF, NULL, -1, NULL,\n                                 NULL, NULL);\n}\n\ninline u32 dComIfGp_particle_setColor(u32 param_0, u16 param_1, const cXyz* param_2,\n                                      const dKy_tevstr_c* param_3, const GXColor* param_4,\n                                      const GXColor* param_5, f32 param_6, u8 param_7,\n                                      const csXyz* param_8, const cXyz* param_9,\n                                      dPa_levelEcallBack* param_10, s8 param_11,\n                                      const cXyz* param_12) {\n    return g_dComIfG_gameInfo.play.getParticle()->setNormal(\n        param_0, param_1, param_2, param_3, param_8, param_9, param_7, param_10, param_11, param_4,\n        param_5, param_12, param_6);\n}\n\ninline JPABaseEmitter* dComIfGp_particle_setColor(u16 param_0, const cXyz* param_1,\n                                                  const dKy_tevstr_c* param_2,\n                                                  const GXColor* param_3, const GXColor* param_4,\n                                                  f32 param_5, u8 param_6, const csXyz* param_7,\n                                                  const cXyz* param_8, dPa_levelEcallBack* param_9,\n                                                  s8 param_10, const cXyz* param_11) {\n    return g_dComIfG_gameInfo.play.getParticle()->setNormal(param_0, param_1, param_2, param_7,\n                                                            param_8, param_6, param_9, param_10,\n                                                            param_3, param_4, param_11, param_5);\n}\n\ninline JPABaseEmitter* dComIfGp_particle_setColor(u16 param_0, const cXyz* param_1,\n                                                  const dKy_tevstr_c* param_2,\n                                                  const GXColor* param_3, const GXColor* param_4,\n                                                  f32 param_5, u8 param_6) {\n    return dComIfGp_particle_setColor(param_0, param_1, param_2, param_3, param_4, param_5, param_6,\n                                      NULL, NULL, NULL, -1, NULL);\n}\n\ninline void dComIfGp_particle_setSimple(u16 param_0, cXyz* param_1, u8 param_2, _GXColor& param_3,\n                                        _GXColor& param_4, int param_5, float param_6) {\n    g_dComIfG_gameInfo.play.getParticle()->setSimple(param_0, param_1, 0, param_2, param_3, param_4,\n                                                     param_5, param_6);\n}\n\ninline void dComIfGp_particle_levelEmitterOnEventMove(u32 param_0) {\n    g_dComIfG_gameInfo.play.getParticle()->forceOnEventMove(param_0);\n}\n\ninline JPABaseEmitter* dComIfGp_particle_getEmitter(u32 param_0) {\n    return g_dComIfG_gameInfo.play.getParticle()->getEmitter(param_0);\n}\n\ninline u32 dComIfGp_particle_setSimpleFoot(u32 param_0, u32* param_1, cBgS_PolyInfo& param_2,\n                                           cXyz const* param_3, dKy_tevstr_c const* param_4,\n                                           int param_5, csXyz const* param_6, cXyz const* param_7,\n                                           dPa_levelEcallBack* param_8, s8 param_9,\n                                           cXyz const* param_10) {\n    return g_dComIfG_gameInfo.play.getParticle()->setSimpleFoot(param_0, param_1, param_2, param_3,\n                                                                param_4, param_5, param_6, param_7,\n                                                                param_8, param_9, param_10);\n}\n\ninline u32 dComIfGp_particle_setPolyColor(u32 param_0, u16 param_1, cBgS_PolyInfo& param_2,\n                                          const cXyz* param_3, const dKy_tevstr_c* param_4,\n                                          const csXyz* param_5, const cXyz* param_6, int param_7,\n                                          dPa_levelEcallBack* param_8, s8 param_9,\n                                          const cXyz* param_10) {\n    return g_dComIfG_gameInfo.play.getParticle()->setPoly(param_0, param_1, param_2, param_3,\n                                                          param_4, param_5, param_6, param_7,\n                                                          param_8, param_9, param_10);\n}\n\ninline JPABaseEmitter* dComIfGp_particle_setPolyColor(u16 param_1, cBgS_PolyInfo& param_2,\n                                          const cXyz* param_3, const dKy_tevstr_c* param_4,\n                                          const csXyz* param_5, const cXyz* param_6, int param_7,\n                                          dPa_levelEcallBack* param_8, s8 param_9,\n                                          const cXyz* param_10) {\n    return g_dComIfG_gameInfo.play.getParticle()->setPoly(param_1, param_2, param_3,\n                                                          param_4, param_5, param_6, param_7,\n                                                          param_8, param_9, param_10);\n}\n\nint dComIfGd_setSimpleShadow(cXyz* pos, f32 param_1, f32 param_2, cBgS_PolyInfo& param_3, s16 angle,\n                             f32 param_5, _GXTexObj* tex);\nstage_camera_class* dComIfGp_getRoomCamera(int i_roomNo);\nstage_arrow_class* dComIfGp_getRoomArrow(int i_roomNo);\nint dComIfGd_setShadow(u32 param_0, s8 param_1, J3DModel* param_2, cXyz* param_3, f32 param_4,\n                       f32 param_5, f32 param_6, f32 param_7, cBgS_PolyInfo& param_8,\n                       dKy_tevstr_c* param_9, s16 param_10, f32 param_11, _GXTexObj* param_12);\n\ninline int dComIfGd_setRealShadow(u32 param_0, s8 param_1, J3DModel* param_2, cXyz* param_3,\n                                  f32 param_4, f32 param_5, dKy_tevstr_c* param_6) {\n    return g_dComIfG_gameInfo.drawlist.setRealShadow(param_0, param_1, param_2, param_3, param_4,\n                                                     param_5, param_6);\n}\n\ninline int dComIfGd_setSimpleShadow(cXyz* pos, f32 param_1, f32 param_2, cXyz* param_3, s16 angle,\n                                    f32 param_5, _GXTexObj* tex) {\n    return g_dComIfG_gameInfo.drawlist.setSimpleShadow(pos, param_1, param_2, param_3, angle,\n                                                       param_5, tex);\n}\n\ninline void dComIfGd_drawListItem3d() {\n    g_dComIfG_gameInfo.drawlist.drawOpaListItem3d();\n    g_dComIfG_gameInfo.drawlist.drawXluListItem3d();\n}\n\ninline void dComIfGd_reset() {\n    g_dComIfG_gameInfo.drawlist.reset();\n}\n\ninline void dComIfGd_set2DOpa(dDlst_base_c* dlst) {\n    g_dComIfG_gameInfo.drawlist.set2DOpa(dlst);\n}\n\ninline void dComIfGd_set2DXlu(dDlst_base_c* dlst) {\n    g_dComIfG_gameInfo.drawlist.set2DXlu(dlst);\n}\n\ninline void dComIfGd_set2DOpaTop(dDlst_base_c* dlst) {\n    g_dComIfG_gameInfo.drawlist.set2DOpaTop(dlst);\n}\n\ninline void dComIfGd_setCopy2D(dDlst_base_c* dlst) {\n    g_dComIfG_gameInfo.drawlist.setCopy2D(dlst);\n}\n\ninline view_class* dComIfGd_getView() {\n    return g_dComIfG_gameInfo.drawlist.getView();\n}\n\ninline Mtx44* dComIfGd_getProjViewMtx() {\n    return &(g_dComIfG_gameInfo.drawlist.getView()->mProjViewMtx);\n}\n\ninline MtxP dComIfGd_getInvViewMtx() {\n    return g_dComIfG_gameInfo.drawlist.getView()->mInvViewMtx;\n}\n\ninline view_port_class* dComIfGd_getViewport() {\n    return g_dComIfG_gameInfo.drawlist.getViewport();\n}\n\ninline MtxP dComIfGd_getViewRotMtx() {\n    return ((camera_process_class*)g_dComIfG_gameInfo.drawlist.getView())->mViewMtxNoTrans;\n}\ninline MtxP dComIfGd_getViewMtx() {\n    return ((camera_process_class*)g_dComIfG_gameInfo.drawlist.getView())->mViewMtx;\n}\n\ninline J3DDrawBuffer* dComIfGd_getListFilter() {\n    return g_dComIfG_gameInfo.drawlist.getOpaListFilter();\n}\n\ninline J3DDrawBuffer* dComIfGd_getOpaListIndScreen() {\n    return g_dComIfG_gameInfo.drawlist.getOpaListP0();\n}\n\ninline J3DDrawBuffer* dComIfGd_getListPacket() {\n    return g_dComIfG_gameInfo.drawlist.getOpaListPacket();\n}\n\ninline void dComIfGd_setListSky() {\n    g_dComIfG_gameInfo.drawlist.setOpaListSky();\n    g_dComIfG_gameInfo.drawlist.setXluListSky();\n}\n\ninline void dComIfGd_setListDark() {\n    g_dComIfG_gameInfo.drawlist.setOpaListDark();\n    g_dComIfG_gameInfo.drawlist.setXluListDark();\n}\n\ninline void dComIfGd_setListInvisisble() {\n    g_dComIfG_gameInfo.drawlist.setOpaListInvisible();\n    g_dComIfG_gameInfo.drawlist.setXluListInvisible();\n}\n\ninline void dComIfGd_setListDarkBG() {\n    g_dComIfG_gameInfo.drawlist.setOpaListDarkBG();\n    g_dComIfG_gameInfo.drawlist.setXluListDarkBG();\n}\n\ninline void dComIfGd_setList() {\n    g_dComIfG_gameInfo.drawlist.setOpaList();\n    g_dComIfG_gameInfo.drawlist.setXluList();\n}\n\ninline void dComIfGd_setListItem3D() {\n    g_dComIfG_gameInfo.drawlist.setOpaListItem3D();\n    g_dComIfG_gameInfo.drawlist.setXluListItem3D();\n}\n\ninline void dComIfGd_setList3Dlast() {\n    g_dComIfG_gameInfo.drawlist.setOpaList3Dlast();\n    g_dComIfG_gameInfo.drawlist.setXluList3Dlast();\n}\n\ninline void dComIfGd_setXluList2DScreen() {\n    g_dComIfG_gameInfo.drawlist.setXluList2DScreen();\n}\n\ninline void dComIfGd_setXluListBG() {\n    g_dComIfG_gameInfo.drawlist.setXluListBG();\n}\n\ninline void dComIfGd_setListBG() {\n    g_dComIfG_gameInfo.drawlist.setOpaListBG();\n    g_dComIfG_gameInfo.drawlist.setXluListBG();\n}\n\ninline void dComIfGd_setListIndScreen() {\n    g_dComIfG_gameInfo.drawlist.setOpaListP0();\n    g_dComIfG_gameInfo.drawlist.setXluListP0();\n}\n\ninline void dComIfGd_setListMiddle() {\n    g_dComIfG_gameInfo.drawlist.setOpaListMiddle();\n    g_dComIfG_gameInfo.drawlist.setXluListMiddle();\n}\n\ninline void dComIfGd_setListZxlu() {\n    g_dComIfG_gameInfo.drawlist.setOpaListZxlu();\n    g_dComIfG_gameInfo.drawlist.setXluListZxlu();\n}\n\ninline J3DDrawBuffer* dComIfGd_getOpaListBG() {\n    return g_dComIfG_gameInfo.drawlist.getOpaListBG();\n}\n\ninline J3DDrawBuffer* dComIfGd_getOpaListDark() {\n    return g_dComIfG_gameInfo.drawlist.getOpaListDark();\n}\n\ninline void dComIfGd_init() {\n    g_dComIfG_gameInfo.drawlist.init();\n}\n\ninline void dComIfGd_peekZ(s16 param_0, s16 param_1, u32* param_2) {\n    g_dComIfG_gameInfo.drawlist.newPeekZdata(param_0, param_1, param_2);\n}\n\ninline void dComIfGd_peekZdata() {\n    g_dComIfG_gameInfo.drawlist.peekZdata();\n}\n\ninline void dComIfGd_setView(view_class* view) {\n    g_dComIfG_gameInfo.drawlist.setView(view);\n}\n\ninline void dComIfGd_setWindow(dDlst_window_c* window) {\n    g_dComIfG_gameInfo.drawlist.setWindow(window);\n}\n\ninline void dComIfGd_setViewport(view_port_class* port) {\n    g_dComIfG_gameInfo.drawlist.setViewport(port);\n}\n\ninline void dComIfGd_entryZSortListZxlu(J3DPacket* i_packet, cXyz& param_1) {\n    g_dComIfG_gameInfo.drawlist.entryZSortListZxlu(i_packet, param_1);\n}\n\ninline void dComIfGd_entryZSortXluList(J3DPacket* i_packet, cXyz& param_1) {\n    g_dComIfG_gameInfo.drawlist.entryZSortXluList(i_packet, param_1);\n}\n\ninline void dComIfGd_drawCopy2D() {\n    g_dComIfG_gameInfo.drawlist.drawCopy2D();\n}\n\ninline void dComIfGd_drawOpaListSky() {\n    g_dComIfG_gameInfo.drawlist.drawOpaListSky();\n}\n\ninline void dComIfGd_drawXluListSky() {\n    g_dComIfG_gameInfo.drawlist.drawXluListSky();\n}\n\ninline void dComIfGd_drawOpaListBG() {\n    g_dComIfG_gameInfo.drawlist.drawOpaListBG();\n}\n\ninline void dComIfGd_drawOpaListDarkBG() {\n    g_dComIfG_gameInfo.drawlist.drawOpaListDarkBG();\n}\n\ninline void dComIfGd_drawOpaListMiddle() {\n    g_dComIfG_gameInfo.drawlist.drawOpaListMiddle();\n}\n\ninline void dComIfGd_drawOpaList() {\n    g_dComIfG_gameInfo.drawlist.drawOpaList();\n}\n\ninline void dComIfGd_drawOpaListDark() {\n    g_dComIfG_gameInfo.drawlist.drawOpaListDark();\n}\n\ninline void dComIfGd_drawOpaListPacket() {\n    g_dComIfG_gameInfo.drawlist.drawOpaListPacket();\n}\n\ninline void dComIfGd_drawXluListBG() {\n    g_dComIfG_gameInfo.drawlist.drawXluListBG();\n}\n\ninline void dComIfGd_drawXluListDarkBG() {\n    g_dComIfG_gameInfo.drawlist.drawXluListDarkBG();\n}\n\ninline void dComIfGd_drawXluList() {\n    g_dComIfG_gameInfo.drawlist.drawXluList();\n}\n\ninline void dComIfGd_drawXluListDark() {\n    g_dComIfG_gameInfo.drawlist.drawXluListDark();\n}\n\ninline void dComIfGd_drawXluListInvisible() {\n    g_dComIfG_gameInfo.drawlist.drawXluListInvisible();\n}\n\ninline void dComIfGd_drawOpaListInvisible() {\n    g_dComIfG_gameInfo.drawlist.drawOpaListInvisible();\n}\n\ninline void dComIfGd_drawXluListZxlu() {\n    g_dComIfG_gameInfo.drawlist.drawXluListZxlu();\n}\n\ninline void dComIfGd_drawXluList2DScreen() {\n    g_dComIfG_gameInfo.drawlist.drawXluList2DScreen();\n}\n\ninline void dComIfGd_drawOpaList3Dlast() {\n    g_dComIfG_gameInfo.drawlist.drawOpaList3Dlast();\n}\n\ninline void dComIfGd_draw2DOpa() {\n    g_dComIfG_gameInfo.drawlist.draw2DOpa();\n}\n\ninline void dComIfGd_draw2DOpaTop() {\n    g_dComIfG_gameInfo.drawlist.draw2DOpaTop();\n}\n\ninline void dComIfGd_draw2DXlu() {\n    g_dComIfG_gameInfo.drawlist.draw2DXlu();\n}\n\ninline void dComIfGd_drawOpaListFilter() {\n    g_dComIfG_gameInfo.drawlist.drawOpaListFilter();\n}\n\ninline void dComIfGd_drawIndScreen() {\n    g_dComIfG_gameInfo.drawlist.drawOpaListP0();\n}\n\ninline void dComIfGd_drawListZxlu() {\n    g_dComIfG_gameInfo.drawlist.drawXluListZxlu();\n}\n\ninline void dComIfGd_drawShadow(Mtx param_0) {\n    g_dComIfG_gameInfo.drawlist.drawShadow(param_0);\n}\n\ninline void dComIfGd_imageDrawShadow(Mtx param_0) {\n    g_dComIfG_gameInfo.drawlist.imageDrawShadow(param_0);\n}\n\ninline void dComIfGd_set3DlineMat(mDoExt_3DlineMat_c *param_0) {\n    g_dComIfG_gameInfo.drawlist.set3DlineMat(param_0);\n}\n\ninline daPy_py_c* daPy_getLinkPlayerActorClass() {\n    return dComIfGp_getLinkPlayer();\n}\n\ninline daPy_py_c* daPy_getPlayerActorClass() {\n    return (daPy_py_c*)dComIfGp_getPlayer(0);\n}\n\ninline daAlink_c* daAlink_getAlinkActorClass() {\n    return (daAlink_c*)g_dComIfG_gameInfo.play.getPlayerPtr(LINK_PTR);\n}\n\n#endif /* D_COM_D_COM_INF_GAME_H */\n/* end \"d/com/d_com_inf_game.h\" */\n/* \"src/d/d_attention.cpp\" line 10 \"d/d_procname.h\" */\n#ifndef D_PROCNAME_H\n#define D_PROCNAME_H\n\nenum {\n    PROC_OVERLAP0          = 0x0000,\n    PROC_OVERLAP1          = 0x0001,\n    PROC_OVERLAP3          = 0x0002,\n    PROC_OVERLAP6          = 0x0003,\n    PROC_OVERLAP7          = 0x0004,\n    PROC_OVERLAP8          = 0x0005,\n    PROC_OVERLAP9          = 0x0006,\n    PROC_OVERLAP10         = 0x0007,\n    PROC_OVERLAP11         = 0x0008,\n    PROC_LOGO_SCENE        = 0x0009,\n    PROC_MENU_SCENE        = 0x000A,\n    PROC_PLAY_SCENE        = 0x000B,\n    PROC_OPENING_SCENE     = 0x000C,\n    PROC_NAME_SCENE        = 0x000D,\n    PROC_NAMEEX_SCENE      = 0x000E,\n    PROC_WARNING_SCENE     = 0x000F,\n    PROC_WARNING2_SCENE    = 0x0010,\n    PROC_OVERLAP2          = 0x0011,\n    PROC_ROOM_SCENE        = 0x0012,\n    PROC_KANKYO            = 0x0013,\n    PROC_ALLDIE            = 0x0014,\n    PROC_ENVSE             = 0x0015,\n    PROC_Obj_Swpush        = 0x0016,\n    PROC_Obj_Swpush2       = 0x0017,\n    PROC_Obj_Swpush5       = 0x0018,\n    PROC_Tag_Gstart        = 0x0019,\n    PROC_NO_CHG_ROOM       = 0x001A,\n    PROC_Obj_Lv6ElevtA     = 0x001B,\n    PROC_OBJ_SO            = 0x001C,\n    PROC_Obj_Movebox       = 0x001D,\n    PROC_Obj_SwTurn        = 0x001E,\n    PROC_Obj_Lv6SwTurn     = 0x001F,\n    PROC_OBJ_SEKIZOA       = 0x0020,\n    PROC_OBJ_GRA           = 0x0021,\n    PROC_TAG_GRA           = 0x0022,\n    PROC_TAG_YAMI          = 0x0023,\n    PROC_Obj_Ladder        = 0x0024,\n    PROC_OBJ_BEF           = 0x0025,\n    PROC_OBJ_FMOBJ         = 0x0026,\n    PROC_OBJ_LBOX          = 0x0027,\n    PROC_OBJ_WEB0          = 0x0028,\n    PROC_OBJ_WEB1          = 0x0029,\n    PROC_OBJ_CB            = 0x002A,\n    PROC_OBJ_MAKI          = 0x002B,\n    PROC_OBJ_BRG           = 0x002C,\n    PROC_OBJ_GB            = 0x002D,\n    PROC_OBJ_GM            = 0x002E,\n    PROC_OBJ_TOBY          = 0x002F,\n    PROC_OBJ_TP            = 0x0030,\n    PROC_TREESH            = 0x0031,\n    PROC_Obj_ZDoor         = 0x0032,\n    PROC_Obj_Pillar        = 0x0033,\n    PROC_Obj_Cdoor         = 0x0034,\n    PROC_GRDWATER          = 0x0035,\n    PROC_Obj_RotBridge     = 0x0036,\n    PROC_Obj_MagLift       = 0x0037,\n    PROC_Obj_MagLiftRot    = 0x0038,\n    PROC_Obj_Lv1Cdl00      = 0x0039,\n    PROC_Obj_Lv1Cdl01      = 0x003A,\n    PROC_Obj_TvCdlst       = 0x003B,\n    PROC_Obj_HsTarget      = 0x003C,\n    PROC_Obj_HeavySw       = 0x003D,\n    PROC_Obj_GoGate        = 0x003E,\n    PROC_Obj_TaFence       = 0x003F,\n    PROC_Obj_Saidan        = 0x0040,\n    PROC_Obj_SpinLift      = 0x0041,\n    PROC_Obj_BmWindow      = 0x0042,\n    PROC_Obj_RfHole        = 0x0043,\n    PROC_Obj_WaterPillar   = 0x0044,\n    PROC_Obj_SyRock        = 0x0045,\n    PROC_Obj_BsGate        = 0x0046,\n    PROC_Obj_AmiShutter    = 0x0047,\n    PROC_Obj_WtGate        = 0x0048,\n    PROC_Obj_Lv2Candle     = 0x0049,\n    PROC_Obj_TogeTrap      = 0x004A,\n    PROC_Obj_RotTrap       = 0x004B,\n    PROC_Obj_SwallShutter  = 0x004C,\n    PROC_Obj_IceWall       = 0x004D,\n    PROC_Obj_Lv5SwIce      = 0x004E,\n    PROC_Obj_Lv5FBoard     = 0x004F,\n    PROC_Obj_Turara        = 0x0050,\n    PROC_Obj_TwGate        = 0x0051,\n    PROC_Obj_Digholl       = 0x0052,\n    PROC_Obj_Digpl         = 0x0053,\n    PROC_Obj_TestCube      = 0x0054,\n    PROC_Obj_Kshutter      = 0x0055,\n    PROC_NPC_COACH         = 0x0056,\n    PROC_NPC_THEB          = 0x0057,\n    PROC_COACH_FIRE        = 0x0058,\n    PROC_COACH2D           = 0x0059,\n    PROC_BALLOON2D         = 0x005A,\n    PROC_SKIP2D            = 0x005B,\n    PROC_Obj_MvStair       = 0x005C,\n    PROC_Obj_Cowdoor       = 0x005D,\n    PROC_Obj_Swpropeller   = 0x005E,\n    PROC_Obj_BoomShutter   = 0x005F,\n    PROC_NPC_KS            = 0x0060,\n    PROC_Obj_Hfuta         = 0x0061,\n    PROC_Obj_BkDoor        = 0x0062,\n    PROC_Obj_Cboard        = 0x0063,\n    PROC_Obj_MGate         = 0x0064,\n    PROC_Obj_Ikada         = 0x0065,\n    PROC_Obj_Ice_l         = 0x0066,\n    PROC_Obj_Ice_s         = 0x0067,\n    PROC_Obj_E_CREATE      = 0x0068,\n    PROC_Obj_Bhbridge      = 0x0069,\n    PROC_Obj_Kaisou        = 0x006A,\n    PROC_Obj_HHASHI        = 0x006B,\n    PROC_Obj_BHASHI        = 0x006C,\n    PROC_OCTHASHI          = 0x006D,\n    PROC_Obj_THASHI        = 0x006E,\n    PROC_Obj_CRVGATE       = 0x006F,\n    PROC_Obj_CRVFENCE      = 0x0070,\n    PROC_Obj_CRVHAHEN      = 0x0071,\n    PROC_Obj_CRVSTEEL      = 0x0072,\n    PROC_Obj_CRVLH_UP      = 0x0073,\n    PROC_Obj_CRVLH_DW      = 0x0074,\n    PROC_Obj_RIVERROCK     = 0x0075,\n    PROC_Obj_DUST          = 0x0076,\n    PROC_Obj_ITA           = 0x0077,\n    PROC_Obj_Window        = 0x0078,\n    PROC_Obj_MetalBox      = 0x0079,\n    PROC_Obj_BBox          = 0x007A,\n    PROC_OBJ_MSIMA         = 0x007B,\n    PROC_OBJ_MYOGAN        = 0x007C,\n    PROC_B_ZANTS           = 0x007D,\n    PROC_Obj_ChainBlock    = 0x007E,\n    PROC_Obj_ChainWall     = 0x007F,\n    PROC_Obj_KkrGate       = 0x0080,\n    PROC_Obj_RiderGate     = 0x0081,\n    PROC_Obj_Onsen         = 0x0082,\n    PROC_Obj_Chest         = 0x0083,\n    PROC_Obj_Bemos         = 0x0084,\n    PROC_Obj_RopeBridge    = 0x0085,\n    PROC_Obj_WellCover     = 0x0086,\n    PROC_Obj_GraveStone    = 0x0087,\n    PROC_Obj_ZraRock       = 0x0088,\n    PROC_Obj_GraRock       = 0x0089,\n    PROC_Obj_GrzRock       = 0x008A,\n    PROC_GRA_WALL          = 0x008B,\n    PROC_OBJ_ONSEN_FIRE    = 0x008C,\n    PROC_Obj_Lv6bemos      = 0x008D,\n    PROC_Obj_Lv6bemos2     = 0x008E,\n    PROC_Obj_BarDesk       = 0x008F,\n    PROC_Obj_DigSnow       = 0x0090,\n    PROC_Obj_Ytaihou       = 0x0091,\n    PROC_Obj_Elevator      = 0x0092,\n    PROC_Obj_Lv6TogeRoll   = 0x0093,\n    PROC_Obj_Lv6TogeTrap   = 0x0094,\n    PROC_Obj_Lv6Tenbin     = 0x0095,\n    PROC_Obj_Lv6SwGate     = 0x0096,\n    PROC_Obj_Lv6Lblock     = 0x0097,\n    PROC_Obj_Lv6ChgGate    = 0x0098,\n    PROC_Obj_Lv6FuriTrap   = 0x0099,\n    PROC_Obj_Lv6SzGate     = 0x009A,\n    PROC_Obj_Lv4EdShutter  = 0x009B,\n    PROC_Obj_Lv4Gate       = 0x009C,\n    PROC_Obj_Lv4PoGate     = 0x009D,\n    PROC_Obj_Lv4SlideWall  = 0x009E,\n    PROC_Obj_Lv4HsTarget   = 0x009F,\n    PROC_Obj_Lv7PropY      = 0x00A0,\n    PROC_Obj_Lv7BsGate     = 0x00A1,\n    PROC_Obj_Lv8OptiLift   = 0x00A2,\n    PROC_Obj_Lv8KekkaiTrap = 0x00A3,\n    PROC_Obj_Lv8Lift       = 0x00A4,\n    PROC_Obj_Lv8UdFloor    = 0x00A5,\n    PROC_Obj_Lv9SwShutter  = 0x00A6,\n    PROC_Obj_TobyHouse     = 0x00A7,\n    PROC_Obj_poCandle      = 0x00A8,\n    PROC_Obj_Lv4DigSand    = 0x00A9,\n    PROC_Obj_FallObj       = 0x00AA,\n    PROC_Obj_SmgDoor       = 0x00AB,\n    PROC_Obj_SwLight       = 0x00AC,\n    PROC_Obj_Avalanche     = 0x00AD,\n    PROC_Obj_MirrorScrew   = 0x00AE,\n    PROC_Obj_MirrorSand    = 0x00AF,\n    PROC_Obj_MirrorTable   = 0x00B0,\n    PROC_Obj_MirrorChain   = 0x00B1,\n    PROC_Obj_Mirror6Pole   = 0x00B2,\n    PROC_Obj_SwSpinner     = 0x00B3,\n    PROC_Obj_TDoor         = 0x00B4,\n    PROC_Obj_Lv7Bridge     = 0x00B5,\n    PROC_Obj_zrTurara      = 0x00B6,\n    PROC_Obj_TakaraDai     = 0x00B7,\n    PROC_Obj_Table         = 0x00B8,\n    PROC_Obj_CatDoor       = 0x00B9,\n    PROC_Obj_Gake          = 0x00BA,\n    PROC_CSTAF             = 0x00BB,\n    PROC_Obj_Lv4RailWall   = 0x00BC,\n    PROC_Obj_Lv4Sand       = 0x00BD,\n    PROC_Obj_PushDoor      = 0x00BE,\n    PROC_PushDoor          = 0x00BF,\n    PROC_Obj_GanonWall2    = 0x00C0,\n    PROC_Obj_Lv4Bridge     = 0x00C1,\n    PROC_Obj_Lv4Floor      = 0x00C2,\n    PROC_Tag_Spinner       = 0x00C3,\n    PROC_Obj_SwHang        = 0x00C4,\n    PROC_Obj_RotStair      = 0x00C5,\n    PROC_Obj_MagneArm      = 0x00C6,\n    PROC_Obj_KWheel00      = 0x00C7,\n    PROC_Obj_KWheel01      = 0x00C8,\n    PROC_Obj_Ychndlr       = 0x00C9,\n    PROC_Obj_PRElvtr       = 0x00CA,\n    PROC_Obj_MHasu         = 0x00CB,\n    PROC_Obj_YIblltray     = 0x00CC,\n    PROC_Obj_Lv6EGate      = 0x00CD,\n    PROC_Obj_PDtile        = 0x00CE,\n    PROC_Obj_PDwall        = 0x00CF,\n    PROC_Obj_Lv4PRwall     = 0x00D0,\n    PROC_Obj_KLift00       = 0x00D1,\n    PROC_B_OH              = 0x00D2,\n    PROC_Obj_Lv4Chan       = 0x00D3,\n    PROC_Obj_Lv3R10Saka    = 0x00D4,\n    PROC_Obj_Lv3Water      = 0x00D5,\n    PROC_Obj_Lv3Water2     = 0x00D6,\n    PROC_OBJ_LV3WATERB     = 0x00D7,\n    PROC_Obj_HBombkoya     = 0x00D8,\n    PROC_Obj_SZbridge      = 0x00D9,\n    PROC_Obj_KakarikoBrg   = 0x00DA,\n    PROC_Obj_OrdinBrg      = 0x00DB,\n    PROC_Obj_BurnBox       = 0x00DC,\n    PROC_Obj_KJgjs         = 0x00DD,\n    PROC_OBJ_IHASI         = 0x00DE,\n    PROC_Obj_IceBlock      = 0x00DF,\n    PROC_Obj_VolcanicBall  = 0x00E0,\n    PROC_Obj_VolcanicBomb  = 0x00E1,\n    PROC_Obj_VolcGnd       = 0x00E2,\n    PROC_Obj_KKanban       = 0x00E3,\n    PROC_E_PH              = 0x00E4,\n    PROC_NPC_ZRA           = 0x00E5,\n    PROC_Obj_Chandelier    = 0x00E6,\n    PROC_Obj_Stopper2      = 0x00E7,\n    PROC_DOOR20            = 0x00E8,\n    PROC_Tag_Hinit         = 0x00E9,\n    PROC_Tag_Hjump         = 0x00EA,\n    PROC_Tag_AJnot         = 0x00EB,\n    PROC_Tag_Hstop         = 0x00EC,\n    PROC_CANOE             = 0x00ED,\n    PROC_HORSE             = 0x00EE,\n    PROC_E_WB              = 0x00EF,\n    PROC_OBJ_ITO           = 0x00F0,\n    PROC_OBJ_SW            = 0x00F1,\n    PROC_SPINNER           = 0x00F2,\n    PROC_B_OB              = 0x00F3,\n    PROC_KAGO              = 0x00F4,\n    PROC_E_YC              = 0x00F5,\n    PROC_B_DS              = 0x00F6,\n    PROC_B_DR              = 0x00F7,\n    PROC_B_ZANTZ           = 0x00F8,\n    PROC_B_ZANT            = 0x00F9,\n    PROC_B_ZANTM           = 0x00FA,\n    PROC_TBOX              = 0x00FB,\n    PROC_TBOX2             = 0x00FC,\n    PROC_ALINK             = 0x00FD,\n    PROC_BOOMERANG         = 0x00FE,\n    PROC_MIDNA             = 0x00FF,\n    PROC_NPC_TK            = 0x0100,\n    PROC_NPC_WORM          = 0x0101,\n    PROC_PPolamp           = 0x0102,\n    PROC_BkyRock           = 0x0103,\n    PROC_HITOBJ            = 0x0104,\n    PROC_EP                = 0x0105,\n    PROC_COW               = 0x0106,\n    PROC_PERU              = 0x0107,\n    PROC_NI                = 0x0108,\n    PROC_NPC_TKJ2          = 0x0109,\n    PROC_SQ                = 0x010A,\n    PROC_NPC_SQ            = 0x010B,\n    PROC_DO                = 0x010C,\n    PROC_NPC_NE            = 0x010D,\n    PROC_NPC_TR            = 0x010E,\n    PROC_NPC_LF            = 0x010F,\n    PROC_OBJ_FOOD          = 0x0110,\n    PROC_OBJ_KI            = 0x0111,\n    PROC_OBJ_KITA          = 0x0112,\n    PROC_OBJ_KEY           = 0x0113,\n    PROC_OBJ_KEYHOLE       = 0x0114,\n    PROC_Obj_Lv5Key        = 0x0115,\n    PROC_OBJ_LP            = 0x0116,\n    PROC_OBJ_TATIGI        = 0x0117,\n    PROC_OBJ_ROCK          = 0x0118,\n    PROC_OBJ_WFLAG         = 0x0119,\n    PROC_OBJ_KAGE          = 0x011A,\n    PROC_OBJ_KANBAN2       = 0x011B,\n    PROC_OBJ_BALLOON       = 0x011C,\n    PROC_OBJ_SUISYA        = 0x011D,\n    PROC_OBJ_OILTUBO       = 0x011E,\n    PROC_OBJ_ROTEN         = 0x011F,\n    PROC_OBJ_SSDRINK       = 0x0120,\n    PROC_OBJ_SSITEM        = 0x0121,\n    PROC_TAG_SSDRINK       = 0x0122,\n    PROC_TAG_BTLITM        = 0x0123,\n    PROC_TAG_LV5SOUP       = 0x0124,\n    PROC_TAG_MNLIGHT       = 0x0125,\n    PROC_TAG_SHOPCAM       = 0x0126,\n    PROC_TAG_SHOPITM       = 0x0127,\n    PROC_OBJ_NDOOR         = 0x0128,\n    PROC_OBJ_UDOOR         = 0x0129,\n    PROC_OBJ_USAKU         = 0x012A,\n    PROC_Obj_SM_DOOR       = 0x012B,\n    PROC_OBJ_BED           = 0x012C,\n    PROC_OBJ_BOUMATO       = 0x012D,\n    PROC_OBJ_ITAMATO       = 0x012E,\n    PROC_OBJ_NOUGU         = 0x012F,\n    PROC_OBJ_STICK         = 0x0130,\n    PROC_OBJ_MIE           = 0x0131,\n    PROC_OBJ_SEKIDOOR      = 0x0132,\n    PROC_OBJ_SEKIZO        = 0x0133,\n    PROC_OBJ_SMTILE        = 0x0134,\n    PROC_NPC_FISH          = 0x0135,\n    PROC_MG_FISH           = 0x0136,\n    PROC_FSHOP             = 0x0137,\n    PROC_NPC_DU            = 0x0138,\n    PROC_DISAPPEAR         = 0x0139,\n    PROC_Obj_Mato          = 0x013A,\n    PROC_Obj_Flag          = 0x013B,\n    PROC_Obj_Flag2         = 0x013C,\n    PROC_Obj_Flag3         = 0x013D,\n    PROC_Obj_GOMIKABE      = 0x013E,\n    PROC_Obj_Yousei        = 0x013F,\n    PROC_Obj_Kabuto        = 0x0140,\n    PROC_Obj_Cho           = 0x0141,\n    PROC_Obj_Kuw           = 0x0142,\n    PROC_Obj_Nan           = 0x0143,\n    PROC_Obj_Dan           = 0x0144,\n    PROC_Obj_Kam           = 0x0145,\n    PROC_Obj_Ten           = 0x0146,\n    PROC_Obj_Ari           = 0x0147,\n    PROC_Obj_Kag           = 0x0148,\n    PROC_Obj_Batta         = 0x0149,\n    PROC_Obj_Tombo         = 0x014A,\n    PROC_Obj_Kat           = 0x014B,\n    PROC_Obj_H_Saku        = 0x014C,\n    PROC_Obj_Yobikusa      = 0x014D,\n    PROC_Obj_KazeNeko      = 0x014E,\n    PROC_Obj_KznkArm       = 0x014F,\n    PROC_Obj_NamePlate     = 0x0150,\n    PROC_Obj_OnCloth       = 0x0151,\n    PROC_Obj_LndRope       = 0x0152,\n    PROC_Obj_ItaRope       = 0x0153,\n    PROC_Obj_Sakuita       = 0x0154,\n    PROC_Obj_Laundry       = 0x0155,\n    PROC_WarpBug           = 0x0156,\n    PROC_Izumi_Gate        = 0x0157,\n    PROC_Obj_Fchain        = 0x0158,\n    PROC_Obj_Wchain        = 0x0159,\n    PROC_Tag_Attp          = 0x015A,\n    PROC_Obj_Tornado       = 0x015B,\n    PROC_Obj_Tornado2      = 0x015C,\n    PROC_Obj_FirePillar    = 0x015D,\n    PROC_Obj_FirePillar2   = 0x015E,\n    PROC_Obj_InoBone       = 0x015F,\n    PROC_Obj_Stopper       = 0x0160,\n    PROC_Obj_MHole         = 0x0161,\n    PROC_Tag_Magne         = 0x0162,\n    PROC_Obj_BossWarp      = 0x0163,\n    PROC_Obj_WoodPendulum  = 0x0164,\n    PROC_Obj_WdStick       = 0x0165,\n    PROC_Obj_StairBlock    = 0x0166,\n    PROC_Obj_Geyser        = 0x0167,\n    PROC_Tag_KtOnFire      = 0x0168,\n    PROC_Obj_FireWood      = 0x0169,\n    PROC_Obj_FireWood2     = 0x016A,\n    PROC_Obj_GpTaru        = 0x016B,\n    PROC_Obj_OnsenTaru     = 0x016C,\n    PROC_Obj_KiPot         = 0x016D,\n    PROC_TBOX_SW           = 0x016E,\n    PROC_Obj_SwChain       = 0x016F,\n    PROC_Obj_WoodenSword   = 0x0170,\n    PROC_Obj_StoneMark     = 0x0171,\n    PROC_Obj_Lv3Candle     = 0x0172,\n    PROC_Tag_Lv4Candle     = 0x0173,\n    PROC_Tag_Lv4CandleDm   = 0x0174,\n    PROC_Obj_DamCps        = 0x0175,\n    PROC_Obj_Smoke         = 0x0176,\n    PROC_Obj_WaterFall     = 0x0177,\n    PROC_Obj_ZoraCloth     = 0x0178,\n    PROC_Obj_poFire        = 0x0179,\n    PROC_Tag_poFire        = 0x017A,\n    PROC_Obj_glowSphere    = 0x017B,\n    PROC_Tag_LightBall     = 0x017C,\n    PROC_SwLBall           = 0x017D,\n    PROC_SwBall            = 0x017E,\n    PROC_Obj_WaterEff      = 0x017F,\n    PROC_Tag_RiverBack     = 0x0180,\n    PROC_Tag_KagoFall      = 0x0181,\n    PROC_Tag_Lv2PrChk      = 0x0182,\n    PROC_Obj_Lv4Gear       = 0x0183,\n    PROC_Obj_MasterSword   = 0x0184,\n    PROC_Obj_WoodStatue    = 0x0185,\n    PROC_Obj_Fan           = 0x0186,\n    PROC_Obj_IceLeaf       = 0x0187,\n    PROC_Obj_zrTuraraRc    = 0x0188,\n    PROC_Tag_RetRoom       = 0x0189,\n    PROC_Obj_WindStone     = 0x018A,\n    PROC_Tag_WaraHowl      = 0x018B,\n    PROC_Obj_SCannon       = 0x018C,\n    PROC_Obj_SmWStone      = 0x018D,\n    PROC_Obj_SCannonCrs    = 0x018E,\n    PROC_Tag_SnowEff       = 0x018F,\n    PROC_Tag_CstaSw        = 0x0190,\n    PROC_Tag_Lv6CstaSw     = 0x0191,\n    PROC_Obj_awaPlar       = 0x0192,\n    PROC_Obj_poTbox        = 0x0193,\n    PROC_Obj_TimeFire      = 0x0194,\n    PROC_Obj_TMoon         = 0x0195,\n    PROC_Obj_GanonWall     = 0x0196,\n    PROC_Obj_Prop          = 0x0197,\n    PROC_CSTATUE           = 0x0198,\n    PROC_Obj_SwBallA       = 0x0199,\n    PROC_Obj_SwBallB       = 0x019A,\n    PROC_Obj_SnowSoup      = 0x019B,\n    PROC_Obj_Nagaisu       = 0x019C,\n    PROC_Obj_RCircle       = 0x019D,\n    PROC_Obj_Picture       = 0x019E,\n    PROC_Tag_SetBall       = 0x019F,\n    PROC_Tag_SmkEmt        = 0x01A0,\n    PROC_SwTime            = 0x01A1,\n    PROC_Obj_HFtr          = 0x01A2,\n    PROC_Obj_HBarrel       = 0x01A3,\n    PROC_Obj_Crystal       = 0x01A4,\n    PROC_Obj_SCannonTen    = 0x01A5,\n    PROC_Obj_SwBallC       = 0x01A6,\n    PROC_SCENE_EXIT2       = 0x01A7,\n    PROC_Obj_Hata          = 0x01A8,\n    PROC_Obj_ToaruMaki     = 0x01A9,\n    PROC_Tag_AttackItem    = 0x01AA,\n    PROC_Tag_RmbitSw       = 0x01AB,\n    PROC_Obj_Sword         = 0x01AC,\n    PROC_Tag_Spring        = 0x01AD,\n    PROC_Tag_Statue        = 0x01AE,\n    PROC_E_AI              = 0x01AF,\n    PROC_E_GS              = 0x01B0,\n    PROC_E_GOB             = 0x01B1,\n    PROC_E_DD              = 0x01B2,\n    PROC_E_DN              = 0x01B3,\n    PROC_E_S1              = 0x01B4,\n    PROC_E_MF              = 0x01B5,\n    PROC_E_SG              = 0x01B6,\n    PROC_E_BS              = 0x01B7,\n    PROC_E_SF              = 0x01B8,\n    PROC_E_SH              = 0x01B9,\n    PROC_E_DF              = 0x01BA,\n    PROC_E_GM              = 0x01BB,\n    PROC_E_MD              = 0x01BC,\n    PROC_E_SM              = 0x01BD,\n    PROC_E_SM2             = 0x01BE,\n    PROC_E_ST              = 0x01BF,\n    PROC_E_ST_LINE         = 0x01C0,\n    PROC_E_SB              = 0x01C1,\n    PROC_E_TH              = 0x01C2,\n    PROC_E_CR              = 0x01C3,\n    PROC_E_CR_EGG          = 0x01C4,\n    PROC_E_DB              = 0x01C5,\n    PROC_E_DB_LEAF         = 0x01C6,\n    PROC_E_GA              = 0x01C7,\n    PROC_E_GB              = 0x01C8,\n    PROC_E_HB              = 0x01C9,\n    PROC_E_HB_LEAF         = 0x01CA,\n    PROC_E_HZELDA          = 0x01CB,\n    PROC_E_YD              = 0x01CC,\n    PROC_E_YH              = 0x01CD,\n    PROC_E_YD_LEAF         = 0x01CE,\n    PROC_E_HM              = 0x01CF,\n    PROC_E_TK              = 0x01D0,\n    PROC_E_TK2             = 0x01D1,\n    PROC_E_TK_BALL         = 0x01D2,\n    PROC_E_RB              = 0x01D3,\n    PROC_E_RD              = 0x01D4,\n    PROC_E_RDB             = 0x01D5,\n    PROC_E_RDY             = 0x01D6,\n    PROC_E_FM              = 0x01D7,\n    PROC_E_FS              = 0x01D8,\n    PROC_E_PM              = 0x01D9,\n    PROC_E_PO              = 0x01DA,\n    PROC_E_MB              = 0x01DB,\n    PROC_E_MK              = 0x01DC,\n    PROC_E_MM              = 0x01DD,\n    PROC_E_FZ              = 0x01DE,\n    PROC_E_ZS              = 0x01DF,\n    PROC_E_KK              = 0x01E0,\n    PROC_E_HP              = 0x01E1,\n    PROC_E_ZH              = 0x01E2,\n    PROC_E_ZM              = 0x01E3,\n    PROC_E_PZ              = 0x01E4,\n    PROC_E_FB              = 0x01E5,\n    PROC_E_FK              = 0x01E6,\n    PROC_E_MS              = 0x01E7,\n    PROC_E_NEST            = 0x01E8,\n    PROC_E_NZ              = 0x01E9,\n    PROC_E_BA              = 0x01EA,\n    PROC_E_BU              = 0x01EB,\n    PROC_E_BUG             = 0x01EC,\n    PROC_E_BEE             = 0x01ED,\n    PROC_E_IS              = 0x01EE,\n    PROC_E_KG              = 0x01EF,\n    PROC_E_KR              = 0x01F0,\n    PROC_E_SW              = 0x01F1,\n    PROC_E_GE              = 0x01F2,\n    PROC_Tag_WatchGe       = 0x01F3,\n    PROC_E_YM              = 0x01F4,\n    PROC_E_YM_TAG          = 0x01F5,\n    PROC_E_YMB             = 0x01F6,\n    PROC_Tag_FWall         = 0x01F7,\n    PROC_Tag_WaterFall     = 0x01F8,\n    PROC_E_YK              = 0x01F9,\n    PROC_E_YR              = 0x01FA,\n    PROC_E_YG              = 0x01FB,\n    PROC_E_HZ              = 0x01FC,\n    PROC_E_WS              = 0x01FD,\n    PROC_E_OC              = 0x01FE,\n    PROC_E_OT              = 0x01FF,\n    PROC_E_DT              = 0x0200,\n    PROC_E_BG              = 0x0201,\n    PROC_E_OctBg           = 0x0202,\n    PROC_DR                = 0x0203,\n    PROC_L7lowDr           = 0x0204,\n    PROC_L7ODR             = 0x0205,\n    PROC_E_TT              = 0x0206,\n    PROC_E_DK              = 0x0207,\n    PROC_E_VT              = 0x0208,\n    PROC_E_WW              = 0x0209,\n    PROC_E_GI              = 0x020A,\n    PROC_B_BH              = 0x020B,\n    PROC_B_BQ              = 0x020C,\n    PROC_B_GM              = 0x020D,\n    PROC_B_GND             = 0x020E,\n    PROC_B_GO              = 0x020F,\n    PROC_B_OH2             = 0x0210,\n    PROC_B_YO              = 0x0211,\n    PROC_B_YOI             = 0x0212,\n    PROC_B_TN              = 0x0213,\n    PROC_B_GG              = 0x0214,\n    PROC_B_DRE             = 0x0215,\n    PROC_B_MGN             = 0x0216,\n    PROC_E_WAP             = 0x0217,\n    PROC_ITEM              = 0x0218,\n    PROC_Obj_SmallKey      = 0x0219,\n    PROC_Obj_Kantera       = 0x021A,\n    PROC_Obj_LifeContainer = 0x021B,\n    PROC_Obj_Shield        = 0x021C,\n    PROC_Demo_Item         = 0x021D,\n    PROC_ShopItem          = 0x021E,\n    PROC_Obj_Drop          = 0x021F,\n    PROC_OBJ_RW            = 0x0220,\n    PROC_NBOMB             = 0x0221,\n    PROC_TAG_CSW           = 0x0222,\n    PROC_TAG_QS            = 0x0223,\n    PROC_HOZELDA           = 0x0224,\n    PROC_SWC00             = 0x0225,\n    PROC_KNOB20            = 0x0226,\n    PROC_DBDOOR            = 0x0227,\n    PROC_BOSS_DOOR         = 0x0228,\n    PROC_L1BOSS_DOOR       = 0x0229,\n    PROC_L1MBOSS_DOOR      = 0x022A,\n    PROC_L5BOSS_DOOR       = 0x022B,\n    PROC_DSHUTTER          = 0x022C,\n    PROC_SPIRAL_DOOR       = 0x022D,\n    PROC_Tag_ChgRestart    = 0x022E,\n    PROC_Tag_Restart       = 0x022F,\n    PROC_ANDSW             = 0x0230,\n    PROC_ANDSW2            = 0x0231,\n    PROC_MYNA              = 0x0232,\n    PROC_NPC_GND           = 0x0233,\n    PROC_NPC_GRA           = 0x0234,\n    PROC_NPC_GRC           = 0x0235,\n    PROC_NPC_GRD           = 0x0236,\n    PROC_NPC_GRM           = 0x0237,\n    PROC_NPC_GRMC          = 0x0238,\n    PROC_NPC_GRO           = 0x0239,\n    PROC_NPC_GRR           = 0x023A,\n    PROC_NPC_GRS           = 0x023B,\n    PROC_NPC_GRZ           = 0x023C,\n    PROC_NPC_YAMID         = 0x023D,\n    PROC_NPC_YAMIT         = 0x023E,\n    PROC_NPC_YAMIS         = 0x023F,\n    PROC_NPC_BLUENS        = 0x0240,\n    PROC_NPC_KAKASHI       = 0x0241,\n    PROC_NPC_KDK           = 0x0242,\n    PROC_NPC_ARU           = 0x0243,\n    PROC_NPC_BANS          = 0x0244,\n    PROC_NPC_BESU          = 0x0245,\n    PROC_NPC_BOU           = 0x0246,\n    PROC_NPC_BOU_S         = 0x0247,\n    PROC_NPC_CLERKA        = 0x0248,\n    PROC_NPC_CLERKB        = 0x0249,\n    PROC_NPC_CLERKT        = 0x024A,\n    PROC_NPC_WRESTLER      = 0x024B,\n    PROC_Tag_Arena         = 0x024C,\n    PROC_Tag_Instruction   = 0x024D,\n    PROC_NPC_DOC           = 0x024E,\n    PROC_NPC_GWOLF         = 0x024F,\n    PROC_NPC_LEN           = 0x0250,\n    PROC_NPC_LUD           = 0x0251,\n    PROC_NPC_FAIRY_SEIREI  = 0x0252,\n    PROC_NPC_FAIRY         = 0x0253,\n    PROC_NPC_HANJO         = 0x0254,\n    PROC_NPC_HENNA         = 0x0255,\n    PROC_NPC_HENNA0        = 0x0256,\n    PROC_NPC_HOZ           = 0x0257,\n    PROC_NPC_JAGAR         = 0x0258,\n    PROC_NPC_KKRI          = 0x0259,\n    PROC_NPC_KN            = 0x025A,\n    PROC_KN_BULLET         = 0x025B,\n    PROC_NPC_KNJ           = 0x025C,\n    PROC_NPC_KOLIN         = 0x025D,\n    PROC_NPC_KOLINB        = 0x025E,\n    PROC_NPC_KYURY         = 0x025F,\n    PROC_NPC_MARO          = 0x0260,\n    PROC_NPC_MIDP          = 0x0261,\n    PROC_NPC_MOI           = 0x0262,\n    PROC_NPC_RACA          = 0x0263,\n    PROC_NPC_SARU          = 0x0264,\n    PROC_NPC_SEIB          = 0x0265,\n    PROC_NPC_SEIC          = 0x0266,\n    PROC_NPC_SEID          = 0x0267,\n    PROC_NPC_SEIRA         = 0x0268,\n    PROC_NPC_SERA2         = 0x0269,\n    PROC_NPC_SEIREI        = 0x026A,\n    PROC_NPC_SHAMAN        = 0x026B,\n    PROC_NPC_SMARO         = 0x026C,\n    PROC_NPC_SOLA          = 0x026D,\n    PROC_NPC_TARO          = 0x026E,\n    PROC_NPC_PACHI_BESU    = 0x026F,\n    PROC_NPC_PACHI_TARO    = 0x0270,\n    PROC_NPC_PACHI_MARO    = 0x0271,\n    PROC_TAG_PATI          = 0x0272,\n    PROC_NPC_THE           = 0x0273,\n    PROC_NPC_TKJ           = 0x0274,\n    PROC_NPC_TKS           = 0x0275,\n    PROC_NPC_TKC           = 0x0276,\n    PROC_OBJ_TKS           = 0x0277,\n    PROC_NPC_TOBY          = 0x0278,\n    PROC_NPC_URI           = 0x0279,\n    PROC_NPC_YELIA         = 0x027A,\n    PROC_NPC_YKM           = 0x027B,\n    PROC_NPC_YKW           = 0x027C,\n    PROC_NPC_ZANB          = 0x027D,\n    PROC_NPC_ZANT          = 0x027E,\n    PROC_NPC_ZELDA         = 0x027F,\n    PROC_NPC_ZELR          = 0x0280,\n    PROC_NPC_ZELRO         = 0x0281,\n    PROC_OBJ_ZRAFREEZE     = 0x0282,\n    PROC_NPC_ZRC           = 0x0283,\n    PROC_NPC_ZRZ           = 0x0284,\n    PROC_ZRA_MARK          = 0x0285,\n    PROC_MYNA2             = 0x0286,\n    PROC_TAG_MYNA2         = 0x0287,\n    PROC_NPC_CD3           = 0x0288,\n    PROC_Tag_Schedule      = 0x0289,\n    PROC_Tag_Escape        = 0x028A,\n    PROC_NPC_CHAT          = 0x028B,\n    PROC_NPC_SOLDIERa      = 0x028C,\n    PROC_NPC_SOLDIERb      = 0x028D,\n    PROC_PASSER_MNG        = 0x028E,\n    PROC_NPC_PASSER        = 0x028F,\n    PROC_NPC_PASSER2       = 0x0290,\n    PROC_NPC_POST          = 0x0291,\n    PROC_NPC_POUYA         = 0x0292,\n    PROC_FORMATION_MNG     = 0x0293,\n    PROC_NPC_FGUARD        = 0x0294,\n    PROC_GUARD_MNG         = 0x0295,\n    PROC_TAG_GUARD         = 0x0296,\n    PROC_NPC_GUARD         = 0x0297,\n    PROC_NPC_ASH           = 0x0298,\n    PROC_NPC_ASHB          = 0x0299,\n    PROC_NPC_SHAD          = 0x029A,\n    PROC_NPC_RAFREL        = 0x029B,\n    PROC_NPC_MOIR          = 0x029C,\n    PROC_NPC_IMPAL         = 0x029D,\n    PROC_NPC_SHOE          = 0x029E,\n    PROC_NPC_DOORBOY       = 0x029F,\n    PROC_NPC_PRAYER        = 0x02A0,\n    PROC_NPC_KASIHANA      = 0x02A1,\n    PROC_NPC_KASIKYU       = 0x02A2,\n    PROC_NPC_KASIMICH      = 0x02A3,\n    PROC_NPC_DRSOL         = 0x02A4,\n    PROC_NPC_CHIN          = 0x02A5,\n    PROC_NPC_INS           = 0x02A6,\n    PROC_NPC_SHOP0         = 0x02A7,\n    PROC_NPC_MK            = 0x02A8,\n    PROC_NPC_P2            = 0x02A9,\n    PROC_KYTAG00           = 0x02AA,\n    PROC_KYTAG01           = 0x02AB,\n    PROC_KYTAG02           = 0x02AC,\n    PROC_KYTAG03           = 0x02AD,\n    PROC_KYTAG04           = 0x02AE,\n    PROC_KYTAG05           = 0x02AF,\n    PROC_KYTAG06           = 0x02B0,\n    PROC_KYTAG07           = 0x02B1,\n    PROC_KYTAG08           = 0x02B2,\n    PROC_KYTAG09           = 0x02B3,\n    PROC_KYTAG10           = 0x02B4,\n    PROC_KYTAG11           = 0x02B5,\n    PROC_KYTAG12           = 0x02B6,\n    PROC_KYTAG13           = 0x02B7,\n    PROC_KYTAG14           = 0x02B8,\n    PROC_KYTAG15           = 0x02B9,\n    PROC_KYTAG16           = 0x02BA,\n    PROC_KYTAG17           = 0x02BB,\n    PROC_Ykgr              = 0x02BC,\n    PROC_TALK              = 0x02BD,\n    PROC_Obj_Crope         = 0x02BE,\n    PROC_Obj_Bombf         = 0x02BF,\n    PROC_Obj_BkLeaf        = 0x02C0,\n    PROC_Tag_Mhint         = 0x02C1,\n    PROC_Tag_Mmsg          = 0x02C2,\n    PROC_Tag_Mwait         = 0x02C3,\n    PROC_Tag_Mstop         = 0x02C4,\n    PROC_Tag_Stream        = 0x02C5,\n    PROC_Tag_Sppath        = 0x02C6,\n    PROC_Tag_Wljump        = 0x02C7,\n    PROC_Tag_TWGate        = 0x02C8,\n    PROC_Tag_Lv6Gate       = 0x02C9,\n    PROC_Tag_Lv7Gate       = 0x02CA,\n    PROC_Tag_Lv8Gate       = 0x02CB,\n    PROC_Tag_TheBHint      = 0x02CC,\n    PROC_Tag_Assist        = 0x02CD,\n    PROC_DEMO00            = 0x02CE,\n    PROC_TAG_CAMERA        = 0x02CF,\n    PROC_TAG_CHKPOINT      = 0x02D0,\n    PROC_TAG_EVENT         = 0x02D1,\n    PROC_TAG_EVT           = 0x02D2,\n    PROC_TAG_TELOP         = 0x02D3,\n    PROC_TAG_HOWL          = 0x02D4,\n    PROC_TAG_MSG           = 0x02D5,\n    PROC_TAG_LANTERN       = 0x02D6,\n    PROC_Tag_Mist          = 0x02D7,\n    PROC_DMIDNA            = 0x02D8,\n    PROC_KY_THUNDER        = 0x02D9,\n    PROC_VRBOX             = 0x02DA,\n    PROC_VRBOX2            = 0x02DB,\n    PROC_BG                = 0x02DC,\n    PROC_SET_BG_OBJ        = 0x02DD,\n    PROC_BG_OBJ            = 0x02DE,\n    PROC_MIRROR            = 0x02DF,\n    PROC_MOVIE_PLAYER      = 0x02E0,\n    PROC_TITLE             = 0x02E1,\n    PROC_FR                = 0x02E2,\n    PROC_ECONT             = 0x02E3,\n    PROC_MG_ROD            = 0x02E4,\n    PROC_E_ARROW           = 0x02E5,\n    PROC_BULLET            = 0x02E6,\n    PROC_SWHIT0            = 0x02E7,\n    PROC_E_TH_BALL         = 0x02E8,\n    PROC_TAG_EVTAREA       = 0x02E9,\n    PROC_TAG_EVTMSG        = 0x02EA,\n    PROC_TAG_KMSG          = 0x02EB,\n    PROC_TAG_PUSH          = 0x02EC,\n    PROC_E_MK_BO           = 0x02ED,\n    PROC_E_MM_MT           = 0x02EE,\n    PROC_OBJ_KBOX          = 0x02EF,\n    PROC_OBJ_FW            = 0x02F0,\n    PROC_B_GOS             = 0x02F1,\n    PROC_OBJ_YSTONE        = 0x02F2,\n    PROC_MANT              = 0x02F3,\n    PROC_CROD              = 0x02F4,\n    PROC_OBJ_PLEAF         = 0x02F5,\n    PROC_OBJ_KBACKET       = 0x02F6,\n    PROC_OBJ_YBAG          = 0x02F7,\n    PROC_OBJ_PUMPKIN       = 0x02F8,\n    PROC_OBJ_AUTOMATA      = 0x02F9,\n    PROC_OBJ_GADGET        = 0x02FA,\n    PROC_OBJ_KAGO          = 0x02FB,\n    PROC_Obj_Carry         = 0x02FC,\n    PROC_Obj_Stone         = 0x02FD,\n    PROC_OBJ_HB            = 0x02FE,\n    PROC_NPC_INKO          = 0x02FF,\n    PROC_BD                = 0x0300,\n    PROC_Obj_Eff           = 0x0301,\n    PROC_WPILLAR           = 0x0302,\n    PROC_WMARK             = 0x0303,\n    PROC_E_BI              = 0x0304,\n    PROC_E_BI_LEAF         = 0x0305,\n    PROC_START_AND_GOAL    = 0x0306,\n    PROC_NPC_DF            = 0x0307,\n    PROC_ARROW             = 0x0308,\n    PROC_PATH_LINE         = 0x0309,\n    PROC_TAG_ALLMATO       = 0x030A,\n    PROC_Obj_Timer         = 0x030B,\n    PROC_SCENE_EXIT        = 0x030C,\n    PROC_CAMERA            = 0x030D,\n    PROC_CAMERA2           = 0x030E,\n    PROC_SUSPEND           = 0x030F,\n    PROC_GRASS             = 0x0310,\n    PROC_KYEFF             = 0x0311,\n    PROC_KYEFF2            = 0x0312,\n    PROC_MSG_OBJECT        = 0x0313,\n    PROC_MENUWINDOW        = 0x0314,\n    PROC_TIMER             = 0x0315,\n    PROC_METER2            = 0x0316,\n    PROC_GAMEOVER          = 0x0317,\n};\n\n#endif /* D_PROCNAME_H *//* end \"d/d_procname.h\" */\n/* \"src/d/d_attention.cpp\" line 11 \"dol2asm.h\" */\n#ifndef DOL2ASM\n#define DOL2ASM\n\n// this helps remove useless error from the linter when using vscode.\n#ifndef IN_VSCODE_EDITOR\n\n#ifdef __cplusplus\n#define SECTION_INIT extern \"C\" __declspec(section \".init\")\n#define SECTION_RODATA __declspec(section \".rodata\")\n#define SECTION_DATA __declspec(section \".data\")\n#define SECTION_SDATA __declspec(section \".sdata\")\n#define SECTION_SDATA2 __declspec(section \".sdata2\")\n#define SECTION_BSS __declspec(section \".data\")\n#define SECTION_SBSS __declspec(section \".sdata\")\n#define SECTION_SBSS2 __declspec(section \".sdata2\")\n#define SECTION_CTORS extern \"C\" __declspec(section \".ctors\")\n#define SECTION_DTORS extern \"C\" __declspec(section \".dtors\")\n#define SECTION_EXTAB extern \"C\" __declspec(section \"extab_\")\n#define SECTION_EXTABINDEX extern \"C\" __declspec(section \"extabindex_\")\n#define SECTION_DEAD extern \"C\" __declspec(section \".dead\")\n#define SECTION_CTORS10 __declspec(section \".ctors$10\")\n#define SECTION_CTORS15 __declspec(section \".ctors$15\")\n#define SECTION_DTORS10 __declspec(section \".dtors$10\")\n#define SECTION_DTORS15 __declspec(section \".dtors$15\")\n#define COMPILER_STRIP_GATE(NAME, VALUE) SECTION_DEAD void* const cg_##NAME = (void*)(VALUE)\n#define ALIGN_DECL(ALIGNMENT) __attribute__((aligned(ALIGNMENT)))\n#define REGISTER_CTORS(ADDR, FUNCTION) SECTION_CTORS void* const _ctors_##ADDR = (void*)(FUNCTION);\n#else\n#define SECTION_INIT __declspec(section \".init\")\n#define SECTION_RODATA __declspec(section \".rodata\")\n#define SECTION_DATA __declspec(section \".data\")\n#define SECTION_SDATA __declspec(section \".sdata\")\n#define SECTION_SDATA2 __declspec(section \".sdata2\")\n#define SECTION_BSS __declspec(section \".data\")\n#define SECTION_SBSS __declspec(section \".sdata\")\n#define SECTION_SBSS2 __declspec(section \".sdata2\")\n#define SECTION_CTORS __declspec(section \".ctors\")\n#define SECTION_DTORS __declspec(section \".dtors\")\n#define SECTION_EXTAB __declspec(section \"extab_\")\n#define SECTION_EXTABINDEX __declspec(section \"extabindex_\")\n#define SECTION_DEAD __declspec(section \".dead\")\n#define SECTION_CTORS10 __declspec(section \".ctors$10\")\n#define SECTION_CTORS15 __declspec(section \".ctors$15\")\n#define SECTION_DTORS10 __declspec(section \".dtors$10\")\n#define SECTION_DTORS15 __declspec(section \".dtors$15\")\n#define COMPILER_STRIP_GATE(NAME, VALUE) SECTION_DEAD void* const cg_##NAME = (void*)(VALUE)\n#define ALIGN_DECL(ALIGNMENT) __attribute__((aligned(ALIGNMENT)))\n#define REGISTER_CTORS(ADDR, FUNCTION) SECTION_CTORS void* const _ctors_##ADDR = (void*)(FUNCTION);\n#endif\n\n#else\n#define SECTION_INIT\n#define SECTION_RODATA\n#define SECTION_DATA\n#define SECTION_SDATA\n#define SECTION_SDATA2\n#define SECTION_BSS\n#define SECTION_SBSS\n#define SECTION_SBSS2\n#define SECTION_CTORS\n#define SECTION_DTORS\n#define SECTION_EXTAB\n#define SECTION_EXTABINDEX\n#define SECTION_DEAD\n#define SECTION_CTORS10\n#define SECTION_CTORS15\n#define SECTION_DTORS10\n#define SECTION_DTORS15\n#define COMPILER_STRIP_GATE(...)\n#define ALIGN_DECL(...)\n#define REGISTER_CTORS(...)\n\n// vscode doesn't like asm and nofralloc very much\n#define asm\n#define nofralloc\n#endif\n\n// floating-point constants\n// TODO: move to different header\n#define _HUGE_ENUF 1e+300\n#define INFINITY ((float)(_HUGE_ENUF * _HUGE_ENUF))\n#define HUGE_VAL ((double)INFINITY)\n#define HUGE_VALL ((long double)INFINITY)\n\n#define DOUBLE_INF HUGE_VAL\n\n#pragma section \".dead\"\n#pragma section \".ctors$10\"\n#pragma section \".ctors$15\"\n#pragma section \".dtors$10\"\n#pragma section \".dtors$15\"\n\n#endif /* DOL2ASM */\n/* end \"dol2asm.h\" */\n/* \"src/d/d_attention.cpp\" line 12 \"dolphin/os/OSCache.h\" */\n/* end \"dolphin/os/OSCache.h\" */\n/* \"src/d/d_attention.cpp\" line 13 \"f_op/f_op_actor_mng.h\" */\n#ifndef F_OP_ACTOR_MNG_H_\n#define F_OP_ACTOR_MNG_H_\n\n/* \"include/f_op/f_op_actor_mng.h\" line 3 \"f_op/f_op_actor.h\" */\n/* end \"f_op/f_op_actor.h\" */\n/* \"include/f_op/f_op_actor_mng.h\" line 4 \"f_op/f_op_actor_iter.h\" */\n#ifndef F_OP_ACTOR_ITER_H_\n#define F_OP_ACTOR_ITER_H_\n\n\ntypedef int (*fopAcIt_ExecutorFunc)(void* actor, void* data);\ntypedef void* (*fopAcIt_JudgeFunc)(void* actor, void* data);\n\nint fopAcIt_Executor(fopAcIt_ExecutorFunc executeFunc, void* data);\nvoid* fopAcIt_Judge(fopAcIt_JudgeFunc judgeFunc, void* data);\n\n#endif/* end \"f_op/f_op_actor_iter.h\" */\n/* \"include/f_op/f_op_actor_mng.h\" line 5 \"f_pc/f_pc_manager.h\" */\n#ifndef F_PC_MANAGER_H_\n#define F_PC_MANAGER_H_\n\n/* \"include/f_pc/f_pc_manager.h\" line 3 \"f_pc/f_pc_create_iter.h\" */\n\n#ifndef F_PC_CREATE_ITER_H_\n#define F_PC_CREATE_ITER_H_\n\n/* \"include/f_pc/f_pc_create_iter.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef struct create_tag create_tag;\n\ntypedef int (*fpcCtIt_MethodFunc)(void*, void*);\ntypedef void* (*fpcCtIt_JudgeFunc)(void*, void*);\n\ntypedef struct node_method_data {\n    fpcCtIt_MethodFunc mFunc;\n    void* mpUserData;\n} node_method_data;\n\ntypedef struct node_judge_data {\n    fpcCtIt_JudgeFunc mFunc;\n    void* mpUserData;\n} node_judge_data;\n\ntypedef struct fpcCtIt_jilprm_c {\n    u32 mLayerID;\n    fpcCtIt_JudgeFunc mFunc;\n    void* mpUserData;\n} fpcCtIt_jilprm_c;\n\ns32 fpcCtIt_Method(fpcCtIt_MethodFunc pJudge, void* pUserData);\nvoid* fpcCtIt_Judge(fpcCtIt_JudgeFunc pJudge, void* pUserData);\nvoid* fpcCtIt_filter_JudgeInLayer(create_tag*, fpcCtIt_jilprm_c*);\nvoid* fpcCtIt_JudgeInLayer(unsigned int pUnk0, fpcCtIt_JudgeFunc pFunc, void* pUserData);\n\n#endif\n/* end \"f_pc/f_pc_create_iter.h\" */\n/* \"include/f_pc/f_pc_manager.h\" line 4 \"f_pc/f_pc_executor.h\" */\n\n#ifndef F_PC_EXECUTOR_H_\n#define F_PC_EXECUTOR_H_\n\n/* \"include/f_pc/f_pc_executor.h\" line 4 \"f_pc/f_pc_layer_iter.h\" */\n#ifndef F_PC_LAYER_ITER_H_\n#define F_PC_LAYER_ITER_H_\n\n/* \"include/f_pc/f_pc_layer_iter.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef struct layer_class layer_class;\n\ntypedef struct layer_iter {\n    void* mpFunc;\n    void* mpUserData;\n} layer_iter;\n\ntypedef int (*fpcLyIt_OnlyHereFunc)(void*, void*);\ntypedef void* (*fpcLyIt_JudgeFunc)(void*, void*);\n\ns32 fpcLyIt_OnlyHere(layer_class* pLayer, fpcLyIt_OnlyHereFunc pFunc, void* pUserData);\ns32 fpcLyIt_OnlyHereLY(layer_class* pLayer, fpcLyIt_OnlyHereFunc pFunc, void* pUserData);\nvoid* fpcLyIt_Judge(layer_class* pLayer, fpcLyIt_JudgeFunc pFunc, void* pUserData);\nvoid* fpcLyIt_AllJudge(fpcLyIt_JudgeFunc pFunc, void* pUserData);\n\n#endif\n/* end \"f_pc/f_pc_layer_iter.h\" */\n/* \"include/f_pc/f_pc_executor.h\" line 5 \"f_pc/f_pc_line_iter.h\" */\n\n#ifndef F_PC_LINE_ITER_H_\n#define F_PC_LINE_ITER_H_\n\ntypedef int (*fpcLnIt_QueueFunc)(void*, void*);\n\nvoid fpcLnIt_Queue(fpcLnIt_QueueFunc pFunc);\n\n#endif\n/* end \"f_pc/f_pc_line_iter.h\" */\n\ntypedef struct base_process_class base_process_class;\n\nbase_process_class* fpcEx_Search(fpcLyIt_JudgeFunc pFunc, void* pUserData);\nbase_process_class* fpcEx_SearchByID(unsigned int id);\nBOOL fpcEx_IsExist(unsigned int id);\ns32 fpcEx_ToLineQ(base_process_class* pProc);\ns32 fpcEx_ExecuteQTo(base_process_class* pProc);\ns32 fpcEx_Execute(base_process_class* pProc);\ns32 fpcEx_ToExecuteQ(base_process_class* pProc);\nvoid fpcEx_Handler(fpcLnIt_QueueFunc pFunc);\n\ninline base_process_class* i_fpcM_Search(fpcLyIt_JudgeFunc pFunc, void* pUserData) {\n    return fpcEx_Search(pFunc, pUserData);\n}\n\nextern \"C\" {\nvoid fpcEx_IsExist__FUi(void);\n}\n\n#endif\n/* end \"f_pc/f_pc_executor.h\" */\n/* \"include/f_pc/f_pc_manager.h\" line 5 \"f_pc/f_pc_leaf.h\" */\n\n#ifndef F_PC_LEAF_H_\n#define F_PC_LEAF_H_\n\n/* \"include/f_pc/f_pc_leaf.h\" line 4 \"f_pc/f_pc_base.h\" */\n\n#ifndef F_PC_BASE_H_\n#define F_PC_BASE_H_\n\n/* \"include/f_pc/f_pc_base.h\" line 4 \"f_pc/f_pc_delete_tag.h\" */\n\n#ifndef F_PC_DELETE_TAG_H_\n#define F_PC_DELETE_TAG_H_\n\n/* \"include/f_pc/f_pc_delete_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef struct layer_class layer_class;\n\ntypedef int (*delete_tag_func)(void*);\n\ntypedef struct delete_tag_class {\n    create_tag_class mBase;\n    layer_class* mpLayer;\n    s16 mTimer;\n} delete_tag_class;\n\nBOOL fpcDtTg_IsEmpty(void);\nvoid fpcDtTg_ToDeleteQ(delete_tag_class* pTag);\nvoid fpcDtTg_DeleteQTo(delete_tag_class* pTag);\ns32 fpcDtTg_Do(delete_tag_class* pTag, delete_tag_func pFunc);\ns32 fpcDtTg_Init(delete_tag_class* pTag, void* pUserData);\n\nextern node_list_class g_fpcDtTg_Queue;\n\n#endif\n/* end \"f_pc/f_pc_delete_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 5 \"f_pc/f_pc_layer_tag.h\" */\n\n#ifndef F_PC_LAYER_TAG_H_\n#define F_PC_LAYER_TAG_H_\n\n/* \"include/f_pc/f_pc_layer_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\nenum {\n    fpcLy_ROOT_e    = 0,\n    fpcLy_CURRENT_e = 0xFFFFFFFD,\n    fpcLy_SPECIAL_e = 0xFFFFFFFE,\n    fpcLy_NONE_e    = 0xFFFFFFFF,\n};\n\ntypedef struct layer_class layer_class;\n\n\ntypedef struct layer_management_tag_class {\n    create_tag_class mCreateTag;\n    layer_class* mpLayer;\n    u16 mNodeListID;\n    u16 mNodeListIdx;\n} layer_management_tag_class;\n\ns32 fpcLyTg_QueueTo(layer_management_tag_class* pTag);\ns32 fpcLyTg_ToQueue(layer_management_tag_class* pTag, unsigned int layerID, u16 listID,\n                    u16 listPrio);\ns32 fpcLyTg_Move(layer_management_tag_class*, unsigned int, u16, u16);\ns32 fpcLyTg_Init(layer_management_tag_class*, unsigned int, void*);\n\n#endif\n/* end \"f_pc/f_pc_layer_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 6 \"f_pc/f_pc_line_tag.h\" */\n\n#ifndef F_PC_LINE_TAG_H_\n#define F_PC_LINE_TAG_H_\n\n/* \"include/f_pc/f_pc_line_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef struct line_tag {\n    create_tag_class mBase;\n    s32 mLineListID;\n} line_tag;\n\ns32 fpcLnTg_Move(line_tag* pLineTag, int newLineListID);\nvoid fpcLnTg_QueueTo(line_tag* pLineTag);\ns32 fpcLnTg_ToQueue(line_tag* pLineTag, int lineListID);\nvoid fpcLnTg_Init(line_tag* pLineTag, void* pData);\n\n#endif\n/* end \"f_pc/f_pc_line_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 7 \"f_pc/f_pc_priority.h\" */\n\n#ifndef F_PC_PRIORITY_H_\n#define F_PC_PRIORITY_H_\n\n/* \"include/f_pc/f_pc_priority.h\" line 4 \"f_pc/f_pc_method_tag.h\" */\n\n#ifndef F_PC_METHOD_TAG_H_\n#define F_PC_METHOD_TAG_H_\n\n/* \"include/f_pc/f_pc_method_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef int (*process_method_tag_func)(void*);\n\ntypedef struct process_method_tag_class {\n    create_tag_class mCreateTag;\n    process_method_tag_func mpFunc;\n    void* mpMthdData;\n} process_method_tag_class;\n\ns32 fpcMtdTg_Do(process_method_tag_class* pMthd);\ns32 fpcMtdTg_ToMethodQ(node_list_class* pList, process_method_tag_class* pMthd);\nvoid fpcMtdTg_MethodQTo(process_method_tag_class* pMthd);\ns32 fpcMtdTg_Init(process_method_tag_class* pMthd, process_method_tag_func pFunc, void* pMthdData);\n\n#endif\n/* end \"f_pc/f_pc_method_tag.h\" */\n\nenum {\n    fpcPi_CURRENT_e = 0xFFFD,\n    fpcPi_SPECIAL_e = 0xFFFE,\n};\n\ntypedef struct process_priority_queue_info {\n    u32 mLayer;\n    u16 mListID;\n    u16 mListPrio;\n} process_priority_queue_info;\n\ntypedef struct process_priority_class {\n    /* 0x00 */ create_tag_class mBase;\n    /* 0x14 */ process_method_tag_class mMtdTag;\n    /* 0x30 */ process_priority_queue_info mInfoQ;\n    /* 0x38 */ process_priority_queue_info mInfoCurr;\n} process_priority_class;\n\ns32 fpcPi_IsInQueue(process_priority_class* pPi);\ns32 fpcPi_QueueTo(process_priority_class* pPi);\ns32 fpcPi_ToQueue(process_priority_class* pPi);\nprocess_priority_class* fpcPi_GetFromQueue(void);\ns32 fpcPi_Delete(process_priority_class* pPi);\ns32 fpcPi_IsNormal(unsigned int layer, u16 listID, u16 priority);\ns32 fpcPi_Change(process_priority_class* pPi, unsigned int layer, u16 listID, u16 priority);\ns32 fpcPi_Handler(void);\ns32 fpcPi_Init(process_priority_class* pPi, void* pUserData, unsigned int layer, u16 listID,\n               u16 priority);\n\nextern s8 data_804505F0;  // roomReadId\n\n#endif\n/* end \"f_pc/f_pc_priority.h\" */\n\ntypedef struct create_request create_request;\ntypedef struct process_method_class process_method_class; \ntypedef struct process_profile_definition process_profile_definition;\ntypedef struct profile_method_class profile_method_class;\n\ntypedef struct base_process_class {\n    /* 0x00 */ u32 mBsType;\n    /* 0x04 */ u32 mBsPcId;\n    /* 0x08 */ s16 mProcName;\n    /* 0x0A */ s8 mUnk0;\n    /* 0x0B */ u8 mPauseFlag;\n    /* 0x0C */ s8 mInitState;\n    /* 0x0D */ u8 mUnk2;\n    /* 0x0E */ s16 mBsTypeId;\n    /* 0x10 */ process_profile_definition* mpProf;\n    /* 0x14 */ struct create_request* mpCtRq;\n    /* 0x18 */ layer_management_tag_class mLyTg;\n    /* 0x34 */ line_tag mLnTg;\n    /* 0x4C */ delete_tag_class mDtTg;\n    /* 0x68 */ process_priority_class mPi;\n    /* 0xA8 */ process_method_class* mpPcMtd;\n    /* 0xAC */ void* mpUserData;\n    /* 0xB0 */ u32 mParameters;\n    /* 0xB4 */ u32 mSubType;\n} base_process_class;  // Size: 0xB8\n\ns32 fpcBs_Is_JustOfType(int pType1, int pType2);\ns32 fpcBs_MakeOfType(int* pType);\ns32 fpcBs_MakeOfId(void);\ns32 fpcBs_Execute(base_process_class* pProc);\nvoid fpcBs_DeleteAppend(base_process_class* pProc);\ns32 fpcBs_IsDelete(base_process_class* pProc);\ns32 fpcBs_Delete(base_process_class* pProc);\nbase_process_class* fpcBs_Create(s16 pProcTypeID, unsigned int pProcID, void* pData);\ns32 fpcBs_SubCreate(base_process_class* pProc);\n\nextern \"C\" {\nvoid fpcBs_MakeOfType__FPi(void);\nvoid fpcBs_Is_JustOfType__Fii(void);\n}\n\n#endif\n/* end \"f_pc/f_pc_base.h\" */\n/* \"include/f_pc/f_pc_leaf.h\" line 5 \"f_pc/f_pc_draw_priority.h\" */\n\n#ifndef F_PC_DRAW_PRIORITY_H_\n#define F_PC_DRAW_PRIORITY_H_\n\n/* \"include/f_pc/f_pc_draw_priority.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef struct draw_priority_class {\n    s16 mPriority;\n} draw_priority_class;\n\ns16 fpcDwPi_Get(const draw_priority_class* pDwPi);\nvoid fpcDwPi_Set(draw_priority_class* pDwPi, s16 p);\nvoid fpcDwPi_Init(draw_priority_class* pDwPi, s16 p);\n\n#endif\n/* end \"f_pc/f_pc_draw_priority.h\" */\n/* \"include/f_pc/f_pc_leaf.h\" line 6 \"f_pc/f_pc_method.h\" */\n\n#ifndef F_PC_METHOD_H_\n#define F_PC_METHOD_H_\n\n/* \"include/f_pc/f_pc_method.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef int (*process_method_func)(void*);\n\ntypedef struct process_method_class {\n    process_method_func mpCreateFunc;\n    process_method_func mpDeleteFunc;\n    process_method_func mpExecuteFunc;\n    process_method_func mpIsDeleteFunc;\n} process_method_class;\n\ns32 fpcMtd_Method(process_method_func pFunc, void* pUserData);\ns32 fpcMtd_Execute(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_IsDelete(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_Delete(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_Create(process_method_class* pMthd, void* pUserData);\n\nextern \"C\" {\nvoid fpcMtd_Execute__FP20process_method_classPv(void);\nvoid fpcMtd_Create__FP20process_method_classPv(void);\n}\n\n#endif\n/* end \"f_pc/f_pc_method.h\" */\n/* \"include/f_pc/f_pc_leaf.h\" line 7 \"f_pc/f_pc_profile.h\" */\n\n#ifndef F_PC_PROFILE_H_\n#define F_PC_PROFILE_H_\n\n/* \"include/f_pc/f_pc_profile.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef struct nodedraw_method_class nodedraw_method_class;\ntypedef struct leafdraw_method_class leafdraw_method_class;\ntypedef struct process_method_class process_method_class;\n\ntypedef struct process_profile_definition {\n    /* 0x00 */ s32 mLayerID;\n    /* 0x04 */ u16 mListID;\n    /* 0x06 */ u16 mListPrio;\n    /* 0x08 */ s16 mProcName;\n    /* 0x0C */ process_method_class* mSubMtd; // Subclass methods\n    /* 0x10 */ s32 mSize;\n    /* 0x14 */ s32 mSizeOther;\n    /* 0x18 */ s32 mParameters;\n} process_profile_definition;\n\n#define LAYER_DEFAULT (-2)\n\nstruct leaf_process_profile_definition;\nprocess_profile_definition* fpcPf_Get(s16 profileID);\nextern process_profile_definition** g_fpcPf_ProfileList_p;\n\n#endif\n/* end \"f_pc/f_pc_profile.h\" */\n\ntypedef struct leafdraw_method_class {\n    /* 0x00 */ process_method_class mBase;\n    /* 0x10 */ process_method_func mpDrawFunc;\n} leafdraw_method_class;\n\ntypedef struct leafdraw_class {\n    /* 0x00 */ base_process_class mBase;\n    /* 0xB8 */ leafdraw_method_class* mpDrawMtd;\n    /* 0xBC */ s8 mbUnk0;\n    /* 0xBD */ u8 mbUnk1;\n    /* 0xBE */ draw_priority_class mDwPi;\n} leafdraw_class;\n\ntypedef struct leaf_process_profile_definition {\n    /* 0x00 */ process_profile_definition mBase;\n    /* 0x1C */ leafdraw_method_class* mSubMtd; // Subclass methods\n    /* 0x20 */ s16 mPriority; // mDrawPriority\n} leaf_process_profile_definition;\n\ns16 fpcLf_GetPriority(const leafdraw_class* pLeaf);\ns32 fpcLf_DrawMethod(leafdraw_method_class* pMthd, void* pUserData);\ns32 fpcLf_Draw(leafdraw_class* pMthd);\ns32 fpcLf_Execute(leafdraw_class* pLeaf);\ns32 fpcLf_IsDelete(leafdraw_class* pLeaf);\ns32 fpcLf_Delete(leafdraw_class* pLeaf);\ns32 fpcLf_Create(leafdraw_class* pLeaf);\n\nextern int g_fpcLf_type;\nextern leafdraw_method_class g_fpcLf_Method;\n\n#endif\n/* end \"f_pc/f_pc_leaf.h\" */\n/* \"include/f_pc/f_pc_manager.h\" line 6 \"f_pc/f_pc_node.h\" */\n\n#ifndef F_PC_NODE_H_\n#define F_PC_NODE_H_\n\n/* \"include/f_pc/f_pc_node.h\" line 4 \"f_pc/f_pc_base.h\" */\n\n#ifndef F_PC_BASE_H_\n#define F_PC_BASE_H_\n\n/* \"include/f_pc/f_pc_base.h\" line 4 \"f_pc/f_pc_delete_tag.h\" */\n\n#ifndef F_PC_DELETE_TAG_H_\n#define F_PC_DELETE_TAG_H_\n\n/* \"include/f_pc/f_pc_delete_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef struct layer_class layer_class;\n\ntypedef int (*delete_tag_func)(void*);\n\ntypedef struct delete_tag_class {\n    create_tag_class mBase;\n    layer_class* mpLayer;\n    s16 mTimer;\n} delete_tag_class;\n\nBOOL fpcDtTg_IsEmpty(void);\nvoid fpcDtTg_ToDeleteQ(delete_tag_class* pTag);\nvoid fpcDtTg_DeleteQTo(delete_tag_class* pTag);\ns32 fpcDtTg_Do(delete_tag_class* pTag, delete_tag_func pFunc);\ns32 fpcDtTg_Init(delete_tag_class* pTag, void* pUserData);\n\nextern node_list_class g_fpcDtTg_Queue;\n\n#endif\n/* end \"f_pc/f_pc_delete_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 5 \"f_pc/f_pc_layer_tag.h\" */\n\n#ifndef F_PC_LAYER_TAG_H_\n#define F_PC_LAYER_TAG_H_\n\n/* \"include/f_pc/f_pc_layer_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\nenum {\n    fpcLy_ROOT_e    = 0,\n    fpcLy_CURRENT_e = 0xFFFFFFFD,\n    fpcLy_SPECIAL_e = 0xFFFFFFFE,\n    fpcLy_NONE_e    = 0xFFFFFFFF,\n};\n\ntypedef struct layer_class layer_class;\n\n\ntypedef struct layer_management_tag_class {\n    create_tag_class mCreateTag;\n    layer_class* mpLayer;\n    u16 mNodeListID;\n    u16 mNodeListIdx;\n} layer_management_tag_class;\n\ns32 fpcLyTg_QueueTo(layer_management_tag_class* pTag);\ns32 fpcLyTg_ToQueue(layer_management_tag_class* pTag, unsigned int layerID, u16 listID,\n                    u16 listPrio);\ns32 fpcLyTg_Move(layer_management_tag_class*, unsigned int, u16, u16);\ns32 fpcLyTg_Init(layer_management_tag_class*, unsigned int, void*);\n\n#endif\n/* end \"f_pc/f_pc_layer_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 6 \"f_pc/f_pc_line_tag.h\" */\n\n#ifndef F_PC_LINE_TAG_H_\n#define F_PC_LINE_TAG_H_\n\n/* \"include/f_pc/f_pc_line_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef struct line_tag {\n    create_tag_class mBase;\n    s32 mLineListID;\n} line_tag;\n\ns32 fpcLnTg_Move(line_tag* pLineTag, int newLineListID);\nvoid fpcLnTg_QueueTo(line_tag* pLineTag);\ns32 fpcLnTg_ToQueue(line_tag* pLineTag, int lineListID);\nvoid fpcLnTg_Init(line_tag* pLineTag, void* pData);\n\n#endif\n/* end \"f_pc/f_pc_line_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 7 \"f_pc/f_pc_priority.h\" */\n\n#ifndef F_PC_PRIORITY_H_\n#define F_PC_PRIORITY_H_\n\n/* \"include/f_pc/f_pc_priority.h\" line 4 \"f_pc/f_pc_method_tag.h\" */\n\n#ifndef F_PC_METHOD_TAG_H_\n#define F_PC_METHOD_TAG_H_\n\n/* \"include/f_pc/f_pc_method_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef int (*process_method_tag_func)(void*);\n\ntypedef struct process_method_tag_class {\n    create_tag_class mCreateTag;\n    process_method_tag_func mpFunc;\n    void* mpMthdData;\n} process_method_tag_class;\n\ns32 fpcMtdTg_Do(process_method_tag_class* pMthd);\ns32 fpcMtdTg_ToMethodQ(node_list_class* pList, process_method_tag_class* pMthd);\nvoid fpcMtdTg_MethodQTo(process_method_tag_class* pMthd);\ns32 fpcMtdTg_Init(process_method_tag_class* pMthd, process_method_tag_func pFunc, void* pMthdData);\n\n#endif\n/* end \"f_pc/f_pc_method_tag.h\" */\n\nenum {\n    fpcPi_CURRENT_e = 0xFFFD,\n    fpcPi_SPECIAL_e = 0xFFFE,\n};\n\ntypedef struct process_priority_queue_info {\n    u32 mLayer;\n    u16 mListID;\n    u16 mListPrio;\n} process_priority_queue_info;\n\ntypedef struct process_priority_class {\n    /* 0x00 */ create_tag_class mBase;\n    /* 0x14 */ process_method_tag_class mMtdTag;\n    /* 0x30 */ process_priority_queue_info mInfoQ;\n    /* 0x38 */ process_priority_queue_info mInfoCurr;\n} process_priority_class;\n\ns32 fpcPi_IsInQueue(process_priority_class* pPi);\ns32 fpcPi_QueueTo(process_priority_class* pPi);\ns32 fpcPi_ToQueue(process_priority_class* pPi);\nprocess_priority_class* fpcPi_GetFromQueue(void);\ns32 fpcPi_Delete(process_priority_class* pPi);\ns32 fpcPi_IsNormal(unsigned int layer, u16 listID, u16 priority);\ns32 fpcPi_Change(process_priority_class* pPi, unsigned int layer, u16 listID, u16 priority);\ns32 fpcPi_Handler(void);\ns32 fpcPi_Init(process_priority_class* pPi, void* pUserData, unsigned int layer, u16 listID,\n               u16 priority);\n\nextern s8 data_804505F0;  // roomReadId\n\n#endif\n/* end \"f_pc/f_pc_priority.h\" */\n\ntypedef struct create_request create_request;\ntypedef struct process_method_class process_method_class; \ntypedef struct process_profile_definition process_profile_definition;\ntypedef struct profile_method_class profile_method_class;\n\ntypedef struct base_process_class {\n    /* 0x00 */ u32 mBsType;\n    /* 0x04 */ u32 mBsPcId;\n    /* 0x08 */ s16 mProcName;\n    /* 0x0A */ s8 mUnk0;\n    /* 0x0B */ u8 mPauseFlag;\n    /* 0x0C */ s8 mInitState;\n    /* 0x0D */ u8 mUnk2;\n    /* 0x0E */ s16 mBsTypeId;\n    /* 0x10 */ process_profile_definition* mpProf;\n    /* 0x14 */ struct create_request* mpCtRq;\n    /* 0x18 */ layer_management_tag_class mLyTg;\n    /* 0x34 */ line_tag mLnTg;\n    /* 0x4C */ delete_tag_class mDtTg;\n    /* 0x68 */ process_priority_class mPi;\n    /* 0xA8 */ process_method_class* mpPcMtd;\n    /* 0xAC */ void* mpUserData;\n    /* 0xB0 */ u32 mParameters;\n    /* 0xB4 */ u32 mSubType;\n} base_process_class;  // Size: 0xB8\n\ns32 fpcBs_Is_JustOfType(int pType1, int pType2);\ns32 fpcBs_MakeOfType(int* pType);\ns32 fpcBs_MakeOfId(void);\ns32 fpcBs_Execute(base_process_class* pProc);\nvoid fpcBs_DeleteAppend(base_process_class* pProc);\ns32 fpcBs_IsDelete(base_process_class* pProc);\ns32 fpcBs_Delete(base_process_class* pProc);\nbase_process_class* fpcBs_Create(s16 pProcTypeID, unsigned int pProcID, void* pData);\ns32 fpcBs_SubCreate(base_process_class* pProc);\n\nextern \"C\" {\nvoid fpcBs_MakeOfType__FPi(void);\nvoid fpcBs_Is_JustOfType__Fii(void);\n}\n\n#endif\n/* end \"f_pc/f_pc_base.h\" */\n/* \"include/f_pc/f_pc_node.h\" line 5 \"f_pc/f_pc_layer.h\" */\n\n#ifndef F_PC_LAYER_H_\n#define F_PC_LAYER_H_\n\n/* \"include/f_pc/f_pc_layer.h\" line 4 \"SSystem/SComponent/c_list.h\" */\n/* end \"SSystem/SComponent/c_list.h\" */\n/* \"include/f_pc/f_pc_layer.h\" line 5 \"SSystem/SComponent/c_node.h\" */\n/* end \"SSystem/SComponent/c_node.h\" */\n/* \"include/f_pc/f_pc_layer.h\" line 6 \"SSystem/SComponent/c_tree.h\" */\n/* end \"SSystem/SComponent/c_tree.h\" */\n/* \"include/f_pc/f_pc_layer.h\" line 7 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef struct create_tag_class create_tag_class;\ntypedef struct process_method_tag_class process_method_tag_class;\ntypedef struct process_node_class process_node_class;\n\ntypedef struct layer_class {\n    /* 0x00 */ node_class mNode;\n    /* 0x0C */ u32 mLayerID;\n    /* 0x10 */ node_lists_tree_class mNodeListTree;\n    /* 0x18 */ process_node_class* mpPcNode;\n    /* 0x1C */ node_list_class mCancelList;\n    struct {\n        /* 0x28 */ s16 mCreatingCount;\n        /* 0x2A */ s16 mDeletingCount;\n    } counts;\n} layer_class;\n\nvoid fpcLy_SetCurrentLayer(layer_class* pLayer);\nlayer_class* fpcLy_CurrentLayer(void);\nlayer_class* fpcLy_RootLayer(void);\nlayer_class* fpcLy_Layer(unsigned int id);\nlayer_class* fpcLy_Search(unsigned int id);\nvoid fpcLy_Regist(layer_class* pLayer);\n\nvoid fpcLy_CreatedMesg(layer_class* pLayer);\nvoid fpcLy_CreatingMesg(layer_class* pLayer);\nvoid fpcLy_DeletedMesg(layer_class* pLayer);\nvoid fpcLy_DeletingMesg(layer_class* pLayer);\nBOOL fpcLy_IsCreatingMesg(layer_class* pLayer);\nBOOL fpcLy_IsDeletingMesg(layer_class* pLayer);\n\ns32 fpcLy_IntoQueue(layer_class* pLayer, int treeListIdx, create_tag_class* pTag, int idx);\ns32 fpcLy_ToQueue(layer_class* pLayer, int treeListIdx, create_tag_class* pTag);\ns32 fpcLy_QueueTo(layer_class* pLayer, create_tag_class* pTag);\n\nvoid fpcLy_Cancel(layer_class* pLayer);\nbool fpcLy_CancelMethod(process_method_tag_class* pLayer);\n\nvoid fpcLy_CancelQTo(process_method_tag_class* pMthd);\ns32 fpcLy_ToCancelQ(layer_class* pLayer, process_method_tag_class* pMthd);\n\nvoid fpcLy_Create(layer_class* pLayer, void* pPcNode, node_list_class* pLists, int listNum);\n\ns32 fpcLy_Delete(layer_class* pLayer);\n\n#endif\n/* end \"f_pc/f_pc_layer.h\" */\n/* \"include/f_pc/f_pc_node.h\" line 6 \"f_pc/f_pc_method.h\" */\n\n#ifndef F_PC_METHOD_H_\n#define F_PC_METHOD_H_\n\n/* \"include/f_pc/f_pc_method.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef int (*process_method_func)(void*);\n\ntypedef struct process_method_class {\n    process_method_func mpCreateFunc;\n    process_method_func mpDeleteFunc;\n    process_method_func mpExecuteFunc;\n    process_method_func mpIsDeleteFunc;\n} process_method_class;\n\ns32 fpcMtd_Method(process_method_func pFunc, void* pUserData);\ns32 fpcMtd_Execute(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_IsDelete(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_Delete(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_Create(process_method_class* pMthd, void* pUserData);\n\nextern \"C\" {\nvoid fpcMtd_Execute__FP20process_method_classPv(void);\nvoid fpcMtd_Create__FP20process_method_classPv(void);\n}\n\n#endif\n/* end \"f_pc/f_pc_method.h\" */\n/* \"include/f_pc/f_pc_node.h\" line 7 \"f_pc/f_pc_profile.h\" */\n\n#ifndef F_PC_PROFILE_H_\n#define F_PC_PROFILE_H_\n\n/* \"include/f_pc/f_pc_profile.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef struct nodedraw_method_class nodedraw_method_class;\ntypedef struct leafdraw_method_class leafdraw_method_class;\ntypedef struct process_method_class process_method_class;\n\ntypedef struct process_profile_definition {\n    /* 0x00 */ s32 mLayerID;\n    /* 0x04 */ u16 mListID;\n    /* 0x06 */ u16 mListPrio;\n    /* 0x08 */ s16 mProcName;\n    /* 0x0C */ process_method_class* mSubMtd; // Subclass methods\n    /* 0x10 */ s32 mSize;\n    /* 0x14 */ s32 mSizeOther;\n    /* 0x18 */ s32 mParameters;\n} process_profile_definition;\n\n#define LAYER_DEFAULT (-2)\n\nstruct leaf_process_profile_definition;\nprocess_profile_definition* fpcPf_Get(s16 profileID);\nextern process_profile_definition** g_fpcPf_ProfileList_p;\n\n#endif\n/* end \"f_pc/f_pc_profile.h\" */\n\ntypedef struct nodedraw_method_class {\n    process_method_class mBase;\n    process_method_func mpDrawFunc;\n} nodedraw_method_class;\n\ntypedef struct process_node_class {\n    /* 0x00 */ base_process_class mBase;\n    /* 0xB8 */ nodedraw_method_class* mpNodeMtd;\n    /* 0xBC */ layer_class mLayer;\n    /* 0xE8 */ node_list_class mLayerNodeLists[16];\n    /* 0x1A8 */ s8 mUnk0;\n} process_node_class;\n\ntypedef struct node_process_profile_definition {\n    /* 0x00 */ process_profile_definition mBase;\n    /* 0x1C */ process_method_class* mSubMtd; // Subclass methods\n} node_process_profile_definition;\n\ns32 fpcNd_DrawMethod(nodedraw_method_class* pNodeMethod, void* pData);\ns32 fpcNd_Draw(process_node_class* pProcNode);\ns32 fpcNd_Execute(process_node_class* pProcNode);\nvoid* fpcNd_IsCreatingFromUnder(void* pProcNode);\ns32 fpcNd_IsDeleteTiming(process_node_class* pProcNode);\ns32 fpcNd_IsDelete(process_node_class* pProcNode);\ns32 fpcNd_Delete(process_node_class* pProcNode);\ns32 fpcNd_Create(process_node_class* pProcNode);\n\nextern int g_fpcNd_type;\nextern nodedraw_method_class g_fpcNd_Method;\n\n#endif\n/* end \"f_pc/f_pc_node.h\" */\n/* \"include/f_pc/f_pc_manager.h\" line 7 \"f_pc/f_pc_stdcreate_req.h\" */\n#ifndef F_PC_STDCREATE_H_\n#define F_PC_STDCREATE_H_\n\n/* \"include/f_pc/f_pc_stdcreate_req.h\" line 3 \"f_pc/f_pc_create_req.h\" */\n\n#ifndef F_PC_CREATE_REQ_H_\n#define F_PC_CREATE_REQ_H_\n\n/* \"include/f_pc/f_pc_create_req.h\" line 4 \"SSystem/SComponent/c_phase.h\" */\n/* end \"SSystem/SComponent/c_phase.h\" */\n/* \"include/f_pc/f_pc_create_req.h\" line 5 \"f_pc/f_pc_create_tag.h\" */\n\n#ifndef F_PC_CREATE_TAG_H_\n#define F_PC_CREATE_TAG_H_\n\n/* \"include/f_pc/f_pc_create_tag.h\" line 4 \"SSystem/SComponent/c_list.h\" */\n/* end \"SSystem/SComponent/c_list.h\" */\n/* \"include/f_pc/f_pc_create_tag.h\" line 5 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef struct create_tag {\n    create_tag_class mBase;\n} create_tag;\n\nvoid fpcCtTg_ToCreateQ(create_tag* pTag);\nvoid fpcCtTg_CreateQTo(create_tag* pTag);\ns32 fpcCtTg_Init(create_tag* pTag, void* pUserData);\n\nextern node_list_class g_fpcCtTg_Queue;\n\n#endif\n/* end \"f_pc/f_pc_create_tag.h\" */\n/* \"include/f_pc/f_pc_create_req.h\" line 6 \"f_pc/f_pc_method.h\" */\n\n#ifndef F_PC_METHOD_H_\n#define F_PC_METHOD_H_\n\n/* \"include/f_pc/f_pc_method.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef int (*process_method_func)(void*);\n\ntypedef struct process_method_class {\n    process_method_func mpCreateFunc;\n    process_method_func mpDeleteFunc;\n    process_method_func mpExecuteFunc;\n    process_method_func mpIsDeleteFunc;\n} process_method_class;\n\ns32 fpcMtd_Method(process_method_func pFunc, void* pUserData);\ns32 fpcMtd_Execute(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_IsDelete(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_Delete(process_method_class* pMthd, void* pUserData);\ns32 fpcMtd_Create(process_method_class* pMthd, void* pUserData);\n\nextern \"C\" {\nvoid fpcMtd_Execute__FP20process_method_classPv(void);\nvoid fpcMtd_Create__FP20process_method_classPv(void);\n}\n\n#endif\n/* end \"f_pc/f_pc_method.h\" */\n/* \"include/f_pc/f_pc_create_req.h\" line 7 \"f_pc/f_pc_method_tag.h\" */\n\n#ifndef F_PC_METHOD_TAG_H_\n#define F_PC_METHOD_TAG_H_\n\n/* \"include/f_pc/f_pc_method_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef int (*process_method_tag_func)(void*);\n\ntypedef struct process_method_tag_class {\n    create_tag_class mCreateTag;\n    process_method_tag_func mpFunc;\n    void* mpMthdData;\n} process_method_tag_class;\n\ns32 fpcMtdTg_Do(process_method_tag_class* pMthd);\ns32 fpcMtdTg_ToMethodQ(node_list_class* pList, process_method_tag_class* pMthd);\nvoid fpcMtdTg_MethodQTo(process_method_tag_class* pMthd);\ns32 fpcMtdTg_Init(process_method_tag_class* pMthd, process_method_tag_func pFunc, void* pMthdData);\n\n#endif\n/* end \"f_pc/f_pc_method_tag.h\" */\n\ntypedef struct base_process_class base_process_class;\ntypedef struct layer_class layer_class;\n\ntypedef struct create_request_method_class {\n    cPhs__Handler mpHandler;\n    process_method_func mpCancel;\n    process_method_func mpDelete;\n} create_request_method_class;\n\ntypedef struct create_request {\n    create_tag mBase;\n    s8 mbIsCreating;\n    s8 mbIsCancelling;\n    process_method_tag_class mMtdTg;\n    create_request_method_class* mpCtRqMtd;\n    void* mpUnk1;\n    s32 mBsPcId;\n    struct base_process_class* mpRes;\n    layer_class* mpLayer;\n} create_request;  // Size: 0x48\n\nbool fpcCtRq_isCreatingByID(create_tag* pTag, unsigned int* pId);\nBOOL fpcCtRq_IsCreatingByID(unsigned int id);\nvoid fpcCtRq_CreateQTo(create_request* pReq);\nvoid fpcCtRq_ToCreateQ(create_request* pReq);\nBOOL fpcCtRq_Delete(create_request* pReq);\nBOOL fpcCtRq_Cancel(create_request* pReq);\ns32 fpcCtRq_IsDoing(create_request* pReq);\nvoid fpcCtRq_Handler(void);\ncreate_request* fpcCtRq_Create(layer_class* pLayer, u32 size,\n                               create_request_method_class* pCtRqMtd);\n\n#endif\n/* end \"f_pc/f_pc_create_req.h\" */\n\ntypedef struct layer_class layer_class;\n\ntypedef int (*stdCreateFunc)(void*, void*);\n\ntypedef struct standard_create_request_class {\n    /* 0x00 */ create_request mBase;\n    /* 0x48 */ request_of_phase_process_class unk_0x48;\n    /* 0x50 */ s16 mLoadID;\n    /* 0x54 */ void* unk_0x54;\n    /* 0x58 */ stdCreateFunc unk_0x58;\n    /* 0x5C */ void* unk_0x5C;\n} standard_create_request_class;\n\ns32 fpcSCtRq_phase_CreateProcess(standard_create_request_class* pStdCreateReq);\ns32 fpcSCtRq_phase_SubCreateProcess(standard_create_request_class* pStdCreateReq);\ns32 fpcSCtRq_phase_IsComplete(standard_create_request_class* pStdCreateReq);\ns32 fpcSCtRq_phase_PostMethod(standard_create_request_class* pStdCreateReq);\ns32 fpcSCtRq_phase_Done(standard_create_request_class*);\ns32 fpcSCtRq_Handler(standard_create_request_class* pStdCreateReq);\ns32 fpcSCtRq_Delete(standard_create_request_class*);\ns32 fpcSCtRq_Cancel(standard_create_request_class*);\ns32 fpcSCtRq_Request(layer_class* param_1, s16 param_2, stdCreateFunc param_3, void* param_4,\n                     void* param_5);\n\nextern \"C\" {\nvoid fpcSCtRq_Request__FP11layer_classsPFPvPv_iPvPv(void);\n}\n\n#endif/* end \"f_pc/f_pc_stdcreate_req.h\" */\n\nenum {\n    fpcM_ERROR_PROCESS_ID_e = -1,\n};\n\ntypedef int (*FastCreateReqFunc)(void*);\ntypedef void (*fpcM_ManagementFunc)(void);\ntypedef int (*fpcM_DrawIteraterFunc)(void*, void*);\n\ninline u32 fpcM_GetID(const void* pProc) {\n    return pProc != NULL ? ((base_process_class*)pProc)->mBsPcId : 0xFFFFFFFF;\n}\ninline s16 fpcM_GetName(const void* pActor) {\n    return ((base_process_class*)pActor)->mProcName;\n}\ninline u32 fpcM_GetParam(const void* pActor) {\n    return ((base_process_class*)pActor)->mParameters;\n}\n\ninline void fpcM_SetParam(void* p_actor, u32 param) {\n    ((base_process_class*)p_actor)->mParameters = param;\n}\n\ninline s16 fpcM_GetProfName(const void* pActor) {\n    return ((base_process_class*)pActor)->mBsTypeId;\n}\n\ninline int fpcM_Create(s16 procName, FastCreateReqFunc createFunc, void* process) {\n    return fpcSCtRq_Request(fpcLy_CurrentLayer(), procName, (stdCreateFunc)createFunc, NULL,\n                            process);\n}\n\ninline s16 fpcM_DrawPriority(const void* param_0) {\n    return fpcLf_GetPriority((const leafdraw_class*)param_0);\n}\n\ninline s32 fpcM_ChangeLayerID(void* proc, int layerID) {\n    return fpcPi_Change(&((base_process_class*)proc)->mPi, layerID, 0xFFFD, 0xFFFD);\n}\n\ninline s32 fpcM_IsJustType(int type1, int type2) {\n    return fpcBs_Is_JustOfType(type1, type2);\n}\n\ninline bool fpcM_IsFirstCreating(void* proc) {\n    return ((base_process_class*)proc)->mInitState == 0;\n}\n\ninline process_profile_definition* fpcM_GetProfile(void* proc) {\n    return (process_profile_definition*)((base_process_class*)proc)->mpProf;\n}\n\ninline void* fpcM_GetAppend(const void* proc) {\n    return ((base_process_class*)proc)->mpUserData;\n}\n\ninline BOOL fpcM_IsExecuting(unsigned int id) {\n    return fpcEx_IsExist(id);\n}\n\ninline void* fpcM_LyJudge(process_node_class* i_node, fpcLyIt_JudgeFunc i_func, void* i_data) {\n    return fpcLyIt_Judge(&i_node->mLayer, i_func, i_data);\n}\n\nvoid fpcM_Draw(void* pProc);\ns32 fpcM_DrawIterater(fpcM_DrawIteraterFunc pFunc);\ns32 fpcM_Execute(void* pProc);\ns32 fpcM_Delete(void* pProc);\nBOOL fpcM_IsCreating(unsigned int pID);\nvoid fpcM_Management(fpcM_ManagementFunc pFunc1, fpcM_ManagementFunc pFunc2);\nvoid fpcM_Init(void);\nbase_process_class* fpcM_FastCreate(s16 pProcTypeID, FastCreateReqFunc param_2, void* param_3,\n                                    void* pData);\ns32 fpcM_IsPause(void* pProc, u8 param_2);\nvoid fpcM_PauseEnable(void* pProc, u8 param_2);\nvoid fpcM_PauseDisable(void* pProc, u8 param_2);\nvoid* fpcM_JudgeInLayer(unsigned int pLayerID, fpcCtIt_JudgeFunc pFunc, void* pUserData);\n\nextern \"C\" {\nvoid fpcM_Delete__FPv(void);\n}\n\n#endif\n/* end \"f_pc/f_pc_manager.h\" */\n/* \"include/f_op/f_op_actor_mng.h\" line 6 \"f_pc/f_pc_searcher.h\" */\n\n#ifndef F_PC_SEARCHER_H_\n#define F_PC_SEARCHER_H_\n\n/* \"include/f_pc/f_pc_searcher.h\" line 4 \"f_pc/f_pc_base.h\" */\n\n#ifndef F_PC_BASE_H_\n#define F_PC_BASE_H_\n\n/* \"include/f_pc/f_pc_base.h\" line 4 \"f_pc/f_pc_delete_tag.h\" */\n\n#ifndef F_PC_DELETE_TAG_H_\n#define F_PC_DELETE_TAG_H_\n\n/* \"include/f_pc/f_pc_delete_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef struct layer_class layer_class;\n\ntypedef int (*delete_tag_func)(void*);\n\ntypedef struct delete_tag_class {\n    create_tag_class mBase;\n    layer_class* mpLayer;\n    s16 mTimer;\n} delete_tag_class;\n\nBOOL fpcDtTg_IsEmpty(void);\nvoid fpcDtTg_ToDeleteQ(delete_tag_class* pTag);\nvoid fpcDtTg_DeleteQTo(delete_tag_class* pTag);\ns32 fpcDtTg_Do(delete_tag_class* pTag, delete_tag_func pFunc);\ns32 fpcDtTg_Init(delete_tag_class* pTag, void* pUserData);\n\nextern node_list_class g_fpcDtTg_Queue;\n\n#endif\n/* end \"f_pc/f_pc_delete_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 5 \"f_pc/f_pc_layer_tag.h\" */\n\n#ifndef F_PC_LAYER_TAG_H_\n#define F_PC_LAYER_TAG_H_\n\n/* \"include/f_pc/f_pc_layer_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\nenum {\n    fpcLy_ROOT_e    = 0,\n    fpcLy_CURRENT_e = 0xFFFFFFFD,\n    fpcLy_SPECIAL_e = 0xFFFFFFFE,\n    fpcLy_NONE_e    = 0xFFFFFFFF,\n};\n\ntypedef struct layer_class layer_class;\n\n\ntypedef struct layer_management_tag_class {\n    create_tag_class mCreateTag;\n    layer_class* mpLayer;\n    u16 mNodeListID;\n    u16 mNodeListIdx;\n} layer_management_tag_class;\n\ns32 fpcLyTg_QueueTo(layer_management_tag_class* pTag);\ns32 fpcLyTg_ToQueue(layer_management_tag_class* pTag, unsigned int layerID, u16 listID,\n                    u16 listPrio);\ns32 fpcLyTg_Move(layer_management_tag_class*, unsigned int, u16, u16);\ns32 fpcLyTg_Init(layer_management_tag_class*, unsigned int, void*);\n\n#endif\n/* end \"f_pc/f_pc_layer_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 6 \"f_pc/f_pc_line_tag.h\" */\n\n#ifndef F_PC_LINE_TAG_H_\n#define F_PC_LINE_TAG_H_\n\n/* \"include/f_pc/f_pc_line_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef struct line_tag {\n    create_tag_class mBase;\n    s32 mLineListID;\n} line_tag;\n\ns32 fpcLnTg_Move(line_tag* pLineTag, int newLineListID);\nvoid fpcLnTg_QueueTo(line_tag* pLineTag);\ns32 fpcLnTg_ToQueue(line_tag* pLineTag, int lineListID);\nvoid fpcLnTg_Init(line_tag* pLineTag, void* pData);\n\n#endif\n/* end \"f_pc/f_pc_line_tag.h\" */\n/* \"include/f_pc/f_pc_base.h\" line 7 \"f_pc/f_pc_priority.h\" */\n\n#ifndef F_PC_PRIORITY_H_\n#define F_PC_PRIORITY_H_\n\n/* \"include/f_pc/f_pc_priority.h\" line 4 \"f_pc/f_pc_method_tag.h\" */\n\n#ifndef F_PC_METHOD_TAG_H_\n#define F_PC_METHOD_TAG_H_\n\n/* \"include/f_pc/f_pc_method_tag.h\" line 4 \"SSystem/SComponent/c_tag.h\" */\n/* end \"SSystem/SComponent/c_tag.h\" */\n\ntypedef int (*process_method_tag_func)(void*);\n\ntypedef struct process_method_tag_class {\n    create_tag_class mCreateTag;\n    process_method_tag_func mpFunc;\n    void* mpMthdData;\n} process_method_tag_class;\n\ns32 fpcMtdTg_Do(process_method_tag_class* pMthd);\ns32 fpcMtdTg_ToMethodQ(node_list_class* pList, process_method_tag_class* pMthd);\nvoid fpcMtdTg_MethodQTo(process_method_tag_class* pMthd);\ns32 fpcMtdTg_Init(process_method_tag_class* pMthd, process_method_tag_func pFunc, void* pMthdData);\n\n#endif\n/* end \"f_pc/f_pc_method_tag.h\" */\n\nenum {\n    fpcPi_CURRENT_e = 0xFFFD,\n    fpcPi_SPECIAL_e = 0xFFFE,\n};\n\ntypedef struct process_priority_queue_info {\n    u32 mLayer;\n    u16 mListID;\n    u16 mListPrio;\n} process_priority_queue_info;\n\ntypedef struct process_priority_class {\n    /* 0x00 */ create_tag_class mBase;\n    /* 0x14 */ process_method_tag_class mMtdTag;\n    /* 0x30 */ process_priority_queue_info mInfoQ;\n    /* 0x38 */ process_priority_queue_info mInfoCurr;\n} process_priority_class;\n\ns32 fpcPi_IsInQueue(process_priority_class* pPi);\ns32 fpcPi_QueueTo(process_priority_class* pPi);\ns32 fpcPi_ToQueue(process_priority_class* pPi);\nprocess_priority_class* fpcPi_GetFromQueue(void);\ns32 fpcPi_Delete(process_priority_class* pPi);\ns32 fpcPi_IsNormal(unsigned int layer, u16 listID, u16 priority);\ns32 fpcPi_Change(process_priority_class* pPi, unsigned int layer, u16 listID, u16 priority);\ns32 fpcPi_Handler(void);\ns32 fpcPi_Init(process_priority_class* pPi, void* pUserData, unsigned int layer, u16 listID,\n               u16 priority);\n\nextern s8 data_804505F0;  // roomReadId\n\n#endif\n/* end \"f_pc/f_pc_priority.h\" */\n\ntypedef struct create_request create_request;\ntypedef struct process_method_class process_method_class; \ntypedef struct process_profile_definition process_profile_definition;\ntypedef struct profile_method_class profile_method_class;\n\ntypedef struct base_process_class {\n    /* 0x00 */ u32 mBsType;\n    /* 0x04 */ u32 mBsPcId;\n    /* 0x08 */ s16 mProcName;\n    /* 0x0A */ s8 mUnk0;\n    /* 0x0B */ u8 mPauseFlag;\n    /* 0x0C */ s8 mInitState;\n    /* 0x0D */ u8 mUnk2;\n    /* 0x0E */ s16 mBsTypeId;\n    /* 0x10 */ process_profile_definition* mpProf;\n    /* 0x14 */ struct create_request* mpCtRq;\n    /* 0x18 */ layer_management_tag_class mLyTg;\n    /* 0x34 */ line_tag mLnTg;\n    /* 0x4C */ delete_tag_class mDtTg;\n    /* 0x68 */ process_priority_class mPi;\n    /* 0xA8 */ process_method_class* mpPcMtd;\n    /* 0xAC */ void* mpUserData;\n    /* 0xB0 */ u32 mParameters;\n    /* 0xB4 */ u32 mSubType;\n} base_process_class;  // Size: 0xB8\n\ns32 fpcBs_Is_JustOfType(int pType1, int pType2);\ns32 fpcBs_MakeOfType(int* pType);\ns32 fpcBs_MakeOfId(void);\ns32 fpcBs_Execute(base_process_class* pProc);\nvoid fpcBs_DeleteAppend(base_process_class* pProc);\ns32 fpcBs_IsDelete(base_process_class* pProc);\ns32 fpcBs_Delete(base_process_class* pProc);\nbase_process_class* fpcBs_Create(s16 pProcTypeID, unsigned int pProcID, void* pData);\ns32 fpcBs_SubCreate(base_process_class* pProc);\n\nextern \"C\" {\nvoid fpcBs_MakeOfType__FPi(void);\nvoid fpcBs_Is_JustOfType__Fii(void);\n}\n\n#endif\n/* end \"f_pc/f_pc_base.h\" */\n/* \"include/f_pc/f_pc_searcher.h\" line 5 \"f_pc/f_pc_layer_iter.h\" */\n/* end \"f_pc/f_pc_layer_iter.h\" */\n\nvoid* fpcSch_JudgeForPName(void* pProc, void* pUserData);\nvoid* fpcSch_JudgeByID(void* pProc, void* pUserData);\n\nextern \"C\" {\nvoid fpcSch_JudgeForPName__FPvPv(void);\n}\n\ninline base_process_class* i_fpcM_SearchByName(s16 name) {\n    return (base_process_class*)fpcLyIt_AllJudge(fpcSch_JudgeForPName, &name);\n}\n\n#endif\n/* end \"f_pc/f_pc_searcher.h\" */\n/* \"include/f_op/f_op_actor_mng.h\" line 7 \"d/bg/d_bg_s.h\" */\n/* end \"d/bg/d_bg_s.h\" */\n/* \"include/f_op/f_op_actor_mng.h\" line 8 \"d/bg/d_bg_s_lin_chk.h\" */\n/* end \"d/bg/d_bg_s_lin_chk.h\" */\n/* \"include/f_op/f_op_actor_mng.h\" line 9 \"d/bg/d_bg_s_wtr_chk.h\" */\n/* end \"d/bg/d_bg_s_wtr_chk.h\" */\n\n#define fopAcM_SetupActor(ptr,ClassName) \\\n    if (!fopAcM_CheckCondition(ptr, fopAcCnd_INIT_e)) { \\\n        new (ptr) ClassName(); \\\n        fopAcM_OnCondition(ptr, fopAcCnd_INIT_e); \\\n    }\n\nclass J3DModelData;  // placeholder\nclass JKRHeap;\nclass cM3dGPla;\n\nstruct fopAcM_prmBase_class {\n    /* 0x00 */ u32 field_0x00;\n    /* 0x04 */ cXyz field_0x04;\n    /* 0x10 */ csXyz field_0x10;\n    /* 0x16 */ u16 field_0x16;\n};  // Size = 0x18\n\nstruct fopAcM_prm_class {\n    /* 0x00 */ u32 mParameter;  // single U32 Parameter\n    /* 0x04 */ cXyz mPos;\n    /* 0x10 */ csXyz mAngle;  // rotation\n    /* 0x16 */ u16 mEnemyNo;\n    /* 0x18 */ u8 mScale[3];\n    /* 0x1B */ u8 mGbaName;     // from WW, maybe a different parameter here\n    /* 0x1C */ s32 mParentPId;  // parent process ID\n    /* 0x20 */ s8 mSubtype;\n    /* 0x21 */ s8 mRoomNo;\n};\n\nstruct fopAcM_search4ev_prm {\n    fopAcM_search4ev_prm() { clear(); }\n    void clear() {\n        mName[0] = 0;\n        mEventID = -1;\n        mProcName = 11;\n        mSubType = 0;\n    }\n\n    /* 0x00 */ char mName[30];\n    /* 0x1E */ s16 mEventID;\n    /* 0x20 */ s16 mProcName;\n    /* 0x22 */ s8 mSubType;\n};\n\nstruct fopAcM_search_prm {\n    /* 0x00 */ u32 mParam0;\n    /* 0x04 */ u32 mParam1;\n    /* 0x08 */ s16 mProcName;\n    /* 0x0A */ s8 mSubType;\n};\n\ndBgS& dComIfG_Bgsp();\n\nclass fopAcM_lc_c {\npublic:\n    static dBgS_LinChk* getLineCheck() { return (dBgS_LinChk*)&mLineCheck; }\n    static bool checkMoveBG() { return dComIfG_Bgsp().ChkMoveBG(*(dBgS_LinChk*)&mLineCheck); }\n    static cXyz* getCrossP() { return ((dBgS_LinChk*)&mLineCheck)->GetCrossP(); }\n    static bool lineCheck(const cXyz*, const cXyz*, const fopAc_ac_c*);\n    static u8 mLineCheck[112];\n};\n\nclass dBgS_RoofChk;\nclass fopAcM_rc_c {\npublic:\n    static dBgS_RoofChk* getRoofCheck() { return (dBgS_RoofChk*)&mRoofCheck; }\n    static bool roofCheck(const cXyz*);\n    static u8 mRoofCheck[80];\n    static f32 mRoofY;\n};\n\nclass dBgS_GndChk;\nclass fopAcM_gc_c {\npublic:\n    static bool gndCheck(const cXyz*);\n    static u8 mGndCheck[84]; // this is dBgS_GndChk but all static data in the TU probably needs to be setup first (otherwise causes a reordering problem with the __sinit function)\n    static f32 mGroundY;\n\n    // this avoids having to include d_bg_s.h here\n    static inline bool getTriPla(cM3dGPla* pPlane);\n    static inline int getRoomId();\n    static inline int getPolyColor();\n\n    static dBgS_GndChk* getGroundCheck() { return (dBgS_GndChk*)&mGndCheck; }\n    static f32 getGroundY() { return mGroundY; }\n};\n\nclass fopAcM_wt_c {\npublic:\n    static dBgS_WtrChk* getWaterCheck() { return (dBgS_WtrChk*)&mWaterCheck; }\n    static f32 getWaterY() { return mWaterY[0]; }\n    static int getPolyAtt0() { return dComIfG_Bgsp().GetPolyAtt0(*(dBgS_WtrChk*)&mWaterCheck); }\n\n    static bool waterCheck(const cXyz*);\n    static u8 mWaterCheck[84 + 4 /* padding */];\n    static f32 mWaterY[1 + 1 /* padding */];\n};\n\nclass dKy_tevstr_c;\nclass cBgS_PolyInfo;\ntypedef int (*heapCallbackFunc)(fopAc_ac_c*);\ntypedef int (*createFunc)(void*);\n\nstruct DOUBLE_POS {\n    double x, y, z;\n};\n\ninline s32 fopAcM_GetRoomNo(const fopAc_ac_c* pActor) {\n    return (s8)pActor->current.roomNo;\n}\n\ninline u32 fopAcM_GetID(const void* pActor) {\n    return fpcM_GetID(pActor);\n}\n\ninline s16 fopAcM_GetName(void* pActor) {\n    return fpcM_GetName(pActor);\n}\n\ninline MtxP fopAcM_GetMtx(const fopAc_ac_c* pActor) {\n    return pActor->mCullMtx;\n}\n\ninline u32 fopAcM_checkStatus(fopAc_ac_c* pActor, u32 status) {\n    return pActor->mStatus & status;\n}\n\ninline u32 fopAcM_checkCarryNow(fopAc_ac_c* pActor) {\n    return pActor->mStatus & 0x2000;\n}\n\nenum fopAcM_CARRY {\n    /* 0x01 */ fopAcM_CARRY_TYPE_1 = 1,\n    /* 0x02 */ fopAcM_CARRY_HEAVY = 2,\n    /* 0x04 */ fopAcM_CARRY_SIDE = 4,\n    /* 0x08 */ fopAcM_CARRY_TYPE_8 = 8,\n    /* 0x10 */ fopAcM_CARRY_LIGHT = 16, // guess based on context\n    /* 0x20 */ fopAcM_CARRY_ITEM = 32,\n    /* 0x30 */ fopAcM_CARRY_UNK_30 = 0x30,\n};\n\ninline u32 fopAcM_CheckCarryType(fopAc_ac_c* actor, fopAcM_CARRY type) {\n    return actor->mCarryType & type;\n}\n\ninline u32 fopAcM_checkHookCarryNow(fopAc_ac_c* pActor) {\n    return fopAcM_checkStatus(pActor, 0x100000);\n}\n\ninline u32 fopAcM_GetParam(const void* pActor) {\n    return fpcM_GetParam(pActor);\n}\n\ninline u32 fopAcM_GetParamBit(void* ac, u8 shift, u8 bit) {\n    return (fopAcM_GetParam(ac) >> shift) & ((1 << bit) - 1);\n}\n\ninline void fopAcM_SetParam(void* p_actor, u32 param) {\n    fpcM_SetParam(p_actor, param);\n}\n\ninline void fopAcM_SetJntCol(fopAc_ac_c* i_actorP, dJntCol_c* i_jntColP) {\n    i_actorP->mJntCol = i_jntColP;\n}\n\ninline s16 fopAcM_GetProfName(const void* pActor) {\n    return fpcM_GetProfName(pActor);\n}\n\ninline u8 fopAcM_GetGroup(const fopAc_ac_c* p_actor) {\n    return p_actor->mGroup;\n}\n\ninline void fopAcM_OnStatus(fopAc_ac_c* pActor, u32 flag) {\n    pActor->mStatus |= flag;\n}\n\ninline void fopAcM_OffStatus(fopAc_ac_c* pActor, u32 flag) {\n    pActor->mStatus &= ~flag;\n}\n\ninline fopAc_ac_c* fopAcM_Search(fopAcIt_JudgeFunc func, void* param) {\n    return (fopAc_ac_c*)fopAcIt_Judge(func, param);\n}\n\ninline fopAc_ac_c* fopAcM_SearchByID(unsigned int id) {\n    return (fopAc_ac_c*)fopAcIt_Judge((fopAcIt_JudgeFunc)fpcSch_JudgeByID, &id);\n}\n\ninline cXyz& fopAcM_GetPosition_p(fopAc_ac_c* pActor) {\n    return pActor->current.pos;\n}\n\ninline cXyz& fopAcM_GetPosition(fopAc_ac_c* pActor) {\n    return pActor->current.pos;\n}\n\ninline cXyz& fopAcM_GetOldPosition_p(fopAc_ac_c* pActor) {\n    return pActor->next.pos;\n}\n\ninline cXyz& fopAcM_GetSpeed_p(fopAc_ac_c* pActor) {\n    return pActor->speed;\n}\n\ninline csXyz& fopAcM_GetAngle_p(fopAc_ac_c* pActor) {\n    return pActor->current.angle;\n}\n\ninline csXyz& fopAcM_GetShapeAngle_p(fopAc_ac_c* pActor) {\n    return pActor->shape_angle;\n}\n\ninline bool fopAcM_CheckCondition(fopAc_ac_c* p_actor, u32 flag) {\n    return p_actor->mCondition & flag;\n}\n\ninline void fopAcM_OnCondition(fopAc_ac_c* p_actor, u32 flag) {\n    p_actor->mCondition |= flag;\n}\n\ninline void fopAcM_OffCondition(fopAc_ac_c* p_actor, u32 flag) {\n    p_actor->mCondition &= ~flag;\n}\n\ninline BOOL fopAcM_IsActor(void* actor) {\n    return fopAc_IsActor(actor);\n}\n\ninline void fopAcM_SetRoomNo(fopAc_ac_c* actor, s8 roomNo) {\n    actor->current.roomNo = roomNo;\n}\n\ninline void fopAcM_setHookCarryNow(fopAc_ac_c* actor) {\n    fopAcM_OnStatus(actor, 0x100000);\n}\n\ninline void fopAcM_cancelHookCarryNow(fopAc_ac_c* actor) {\n    fopAcM_OffStatus(actor, 0x100000);\n}\n\ninline s8 fopAcM_GetHomeRoomNo(const fopAc_ac_c* pActor) {\n    return pActor->orig.roomNo;\n}\n\ninline void fopAcM_SetGravity(fopAc_ac_c* actor, f32 gravity) {\n    actor->mGravity = gravity;\n}\n\ninline void fopAcM_SetMaxFallSpeed(fopAc_ac_c* actor, f32 speed) {\n    actor->mMaxFallSpeed = speed;\n}\n\ninline void fopAcM_SetMtx(fopAc_ac_c* actor, MtxP m) {\n    actor->mCullMtx = m;\n}\n\ninline void fopAcM_SetSpeed(fopAc_ac_c* actor, f32 x, f32 y, f32 z) {\n    actor->speed.set(x, y, z);\n}\n\ninline void fopAcM_SetSpeedF(fopAc_ac_c* actor, f32 f) {\n    actor->speedF = f;\n}\n\ninline void fopAcM_SetStatus(fopAc_ac_c* actor, u32 status) {\n    actor->mStatus = status;\n}\n\ninline void fopAcM_SetModel(fopAc_ac_c* actor, J3DModel* model) {\n    actor->model = model;\n}\n\ninline fopAcM_prm_class* fopAcM_GetAppend(void* actor) {\n    return (fopAcM_prm_class*)fpcM_GetAppend(actor);\n}\n\ninline BOOL fopAcM_IsExecuting(unsigned int id) {\n    return fpcM_IsExecuting(id);\n}\n\ninline f32 fopAcM_GetSpeedF(const fopAc_ac_c* p_actor) {\n    return p_actor->speedF;\n}\n\ninline f32 fopAcM_GetGravity(const fopAc_ac_c* p_actor) {\n    return p_actor->mGravity;\n}\n\ninline f32 fopAcM_GetMaxFallSpeed(const fopAc_ac_c* p_actor) {\n    return p_actor->mMaxFallSpeed;\n}\n\ninline const cXyz& fopAcM_GetSpeed_p(const fopAc_ac_c* p_actor) {\n    return p_actor->speed;\n}\n\ninline const cXyz& fopAcM_GetPosition_p(const fopAc_ac_c* p_actor) {\n    return p_actor->current.pos;\n}\n\ninline dJntCol_c* fopAcM_GetJntCol(fopAc_ac_c* i_actor) {\n    return i_actor->mJntCol;\n}\n\ninline void fopAcM_setCullSizeFar(fopAc_ac_c* i_actor, f32 i_far) {\n    i_actor->mCullSizeFar = i_far;\n}\n\ninline f32 fopAcM_getCullSizeFar(const fopAc_ac_c* i_actor) {\n    return i_actor->mCullSizeFar;\n}\n\ninline void fopAcM_SetCullSize(fopAc_ac_c* i_actor, s8 i_cullsize) {\n    i_actor->mCullType = i_cullsize;\n}\n\ninline int fopAcM_GetCullSize(const fopAc_ac_c* i_actor) {\n    return i_actor->mCullType;\n}\n\ninline BOOL fopAcM_CULLSIZE_IS_BOX(int i_culltype) {\n    return (i_culltype >= 0 && i_culltype < 14) || i_culltype == 14;\n}\n\ninline Vec fopAcM_getCullSizeSphereCenter(const fopAc_ac_c* i_actor) {\n    return i_actor->mCull.mSphere.mCenter;\n}\n\ninline f32 fopAcM_getCullSizeSphereR(const fopAc_ac_c* i_actor) {\n    return i_actor->mCull.mSphere.mRadius;\n}\n\ninline void dComIfGs_onSwitch(int i_no, int i_roomNo);\ninline void dComIfGs_offSwitch(int i_no, int i_roomNo);\ninline BOOL dComIfGs_isSwitch(int i_no, int i_roomNo);\ninline void dComIfGs_offActor(int i_no, int i_roomNo);\n\ninline void i_fopAcM_onSwitch(const fopAc_ac_c* pActor, int sw) {\n    return dComIfGs_onSwitch(sw, fopAcM_GetHomeRoomNo(pActor));\n}\n\ninline void i_fopAcM_offSwitch(const fopAc_ac_c* pActor, int sw) {\n    return dComIfGs_offSwitch(sw, fopAcM_GetHomeRoomNo(pActor));\n}\n\ninline BOOL i_fopAcM_isSwitch(const fopAc_ac_c* item, int sw) {\n    return dComIfGs_isSwitch(sw, fopAcM_GetHomeRoomNo(item));\n}\n\ninline fopAc_ac_c* i_fopAcM_SearchByName(s16 proc_id) {\n    return (fopAc_ac_c*)fopAcIt_Judge(fpcSch_JudgeForPName, &proc_id);\n}\n\ninline void dComIfGs_onItem(int bitNo, int roomNo);\ninline void fopAcM_onItem(const fopAc_ac_c* item, int bitNo) {\n    dComIfGs_onItem(bitNo, fopAcM_GetHomeRoomNo(item));\n}\n\ninline bool dComIfGs_isItem(int bitNo, int roomNo);\ninline bool fopAcM_isItem(const fopAc_ac_c* item, int bitNo) {\n    return dComIfGs_isItem(bitNo, fopAcM_GetHomeRoomNo(item));\n}\n\ninline f32 fopAcM_searchActorDistanceY(const fopAc_ac_c* actorA, const fopAc_ac_c* actorB) {\n    return actorB->current.pos.y - actorA->current.pos.y;\n}\n\ninline u16 fopAcM_GetSetId(const fopAc_ac_c* p_actor) {\n    return p_actor->mSetID;\n}\n\ninline void dComIfGs_onActor(int bitNo, int roomNo);\n\ninline void fopAcM_onActor(const fopAc_ac_c* p_actor) {\n    int setId = fopAcM_GetSetId(p_actor);\n    dComIfGs_onActor(setId, fopAcM_GetHomeRoomNo(p_actor));\n}\n\nvoid fopAcM_initManager();\n\nvoid* fopAcM_FastCreate(s16 pProcTypeID, FastCreateReqFunc param_2, void* param_3, void* pData);\n\nvoid fopAcM_setStageLayer(void* p_proc);\n\nvoid fopAcM_setRoomLayer(void* p_proc, int roomNo);\n\ns32 fopAcM_SearchByID(unsigned int id, fopAc_ac_c** p_actor);\n\ns32 fopAcM_SearchByName(s16 procName, fopAc_ac_c** p_actor);\n\nfopAcM_prm_class* fopAcM_CreateAppend();\n\nfopAcM_prm_class* createAppend(u16 enemyNo, u32 parameters, const cXyz* p_pos, int roomNo,\n                               const csXyz* p_angle, const cXyz* p_scale, s8 subType,\n                               unsigned int parentPId);\n\nvoid fopAcM_Log(fopAc_ac_c const* p_actor, char const* str);\n\nvoid fopAcM_delete(fopAc_ac_c* p_actor);\n\ns32 fopAcM_delete(unsigned int actorID);\n\ns32 fopAcM_create(s16 procName, u16 enemyNo, u32 parameter, const cXyz* p_pos, int roomNo,\n                  const csXyz* p_angle, const cXyz* p_scale, s8 subType, createFunc p_createFunc);\n\ns32 fopAcM_create(s16 procName, u32 parameter, const cXyz* p_pos, int roomNo, const csXyz* p_angle,\n                  const cXyz* p_scale, s8 subType);\n\nvoid* fopAcM_fastCreate(s16 procName, u32 parameter, const cXyz* p_pos, int roomNo,\n                        const csXyz* p_angle, const cXyz* p_scale, s8 subType,\n                        createFunc p_createFunc, void* p_createFuncData);\n\nvoid* fopAcM_fastCreate(const char* p_actorName, u32 parameter, const cXyz* pActorPos, int roomNo,\n                        const csXyz* p_angle, const cXyz* p_scale, createFunc p_createFunc,\n                        void* p_createFuncData);\n\ns32 fopAcM_createChild(s16 procName, unsigned int parentPId, u32 parameters, const cXyz* p_pos,\n                       int roomNo, const csXyz* p_angle, const cXyz* p_scale, s8 subType,\n                       createFunc p_createFunc);\n\ns32 fopAcM_createChildFromOffset(s16 procName, unsigned int parentProcID, u32 actorParams,\n                                 const cXyz* p_pos, int roomNo, const csXyz* p_angle,\n                                 const cXyz* p_scale, s8 subType, createFunc p_createFunc);\n\nvoid fopAcM_DeleteHeap(fopAc_ac_c* p_actor);\n\ns32 fopAcM_callCallback(fopAc_ac_c* p_actor, heapCallbackFunc p_callbackFunc, JKRHeap* p_heap);\n\nbool fopAcM_entrySolidHeap_(fopAc_ac_c* p_actor, heapCallbackFunc p_heapCallback, u32 size);\n\nbool fopAcM_entrySolidHeap(fopAc_ac_c* p_actor, heapCallbackFunc p_heapCallback, u32 size);\n\nvoid fopAcM_SetMin(fopAc_ac_c* p_actor, f32 minX, f32 minY, f32 minZ);\n\nvoid fopAcM_SetMax(fopAc_ac_c* p_actor, f32 maxX, f32 maxY, f32 maxZ);\n\nvoid fopAcM_setCullSizeBox(fopAc_ac_c* p_actor, f32 minX, f32 minY, f32 minZ, f32 maxX, f32 maxY,\n                           f32 maxZ);\n\nvoid fopAcM_setCullSizeSphere(fopAc_ac_c* p_actor, f32 minX, f32 minY, f32 minZ, f32 radius);\n\nvoid fopAcM_setCullSizeBox2(fopAc_ac_c* p_actor, J3DModelData* p_modelData);\n\nbool fopAcM_addAngleY(fopAc_ac_c* p_actor, s16 target, s16 step);\n\nvoid fopAcM_calcSpeed(fopAc_ac_c* p_actor);\n\nvoid fopAcM_posMove(fopAc_ac_c* p_actor, const cXyz* p_movePos);\n\nvoid fopAcM_posMoveF(fopAc_ac_c* p_actor, const cXyz* p_movePos);\n\ns16 fopAcM_searchActorAngleY(const fopAc_ac_c* p_actorA, const fopAc_ac_c* p_actorB);\n\ns16 fopAcM_searchActorAngleX(const fopAc_ac_c* p_actorA, const fopAc_ac_c* p_actorB);\n\ns32 fopAcM_seenActorAngleY(const fopAc_ac_c*, const fopAc_ac_c*);\n\nf32 fopAcM_searchActorDistance(const fopAc_ac_c* p_actorA, const fopAc_ac_c* p_actorB);\n\nf32 fopAcM_searchActorDistance2(const fopAc_ac_c* p_actorA, const fopAc_ac_c* p_actorB);\n\nf32 fopAcM_searchActorDistanceXZ(const fopAc_ac_c* p_actorA, const fopAc_ac_c* p_actorB);\n\nf32 fopAcM_searchActorDistanceXZ2(const fopAc_ac_c* p_actorA, const fopAc_ac_c* p_actorB);\n\ns32 fopAcM_rollPlayerCrash(const fopAc_ac_c*, f32, u32, f32, f32, int, f32);\ns32 fopAcM_checkCullingBox(f32[3][4], f32, f32, f32, f32, f32, f32);\ns32 fopAcM_cullingCheck(const fopAc_ac_c*);\nvoid* event_second_actor(u16);\ns32 fopAcM_orderTalkEvent(fopAc_ac_c*, fopAc_ac_c*, u16, u16);\ns32 fopAcM_orderTalkItemBtnEvent(u16, fopAc_ac_c*, fopAc_ac_c*, u16, u16);\ns32 fopAcM_orderSpeakEvent(fopAc_ac_c* i_actor, u16 i_priority, u16 i_flag);\ns32 fopAcM_orderDoorEvent(fopAc_ac_c*, fopAc_ac_c*, u16, u16);\ns32 fopAcM_orderCatchEvent(fopAc_ac_c*, fopAc_ac_c*, u16, u16);\ns32 fopAcM_orderOtherEvent(fopAc_ac_c*, const char*, u16, u16, u16);\ns32 fopAcM_orderOtherEvent(fopAc_ac_c*, fopAc_ac_c*, const char*, u16, u16, u16);\ns32 fopAcM_orderChangeEventId(fopAc_ac_c*, s16, u16, u16);\ns32 fopAcM_orderOtherEventId(fopAc_ac_c* actor, s16 eventID, u8 mapToolID, u16 param_3,\n                             u16 priority, u16 flag);\ns32 fopAcM_orderMapToolEvent(fopAc_ac_c*, u8, s16, u16, u16, u16);\ns32 fopAcM_orderMapToolAutoNextEvent(fopAc_ac_c*, u8, s16, u16, u16, u16);\ns32 fopAcM_orderPotentialEvent(fopAc_ac_c*, u16, u16, u16);\ns32 fopAcM_orderItemEvent(fopAc_ac_c*, u16, u16);\ns32 fopAcM_orderTreasureEvent(fopAc_ac_c*, fopAc_ac_c*, u16, u16);\nfopAc_ac_c* fopAcM_getTalkEventPartner(const fopAc_ac_c*);\nfopAc_ac_c* fopAcM_getItemEventPartner(const fopAc_ac_c*);\nfopAc_ac_c* fopAcM_getEventPartner(const fopAc_ac_c*);\nstatic void fopAcM_onSwitch(fopAc_ac_c const* param_0, int param_1);\n\ns32 fopAcM_createItemForPresentDemo(cXyz const* p_pos, int i_itemNo, u8 param_2, int i_itemBitNo,\n                                    int i_roomNo, csXyz const* p_angle, cXyz const* p_scale);\n\ns32 fopAcM_createItemForTrBoxDemo(cXyz const* p_pos, int i_itemNo, int i_itemBitNo, int i_roomNo,\n                                  csXyz const* p_angle, cXyz const* p_scale);\n\nu8 fopAcM_getItemNoFromTableNo(u8 i_tableNo);\n\ns32 fopAcM_createItemFromEnemyID(u8 i_enemyID, cXyz const* p_pos, int i_itemBitNo, int i_roomNo,\n                                 csXyz const* p_angle, cXyz const* p_scale, f32* speedF,\n                                 f32* speedY);\n\ns32 fopAcM_createItemFromTable(cXyz const* p_pos, int i_tableNo, int i_itemBitNo, int i_roomNo,\n                               csXyz const* p_angle, int param_5, cXyz const* p_scale, f32* speedF,\n                               f32* speedY, bool createDirect);\n\ns32 fopAcM_createDemoItem(const cXyz* p_pos, int itemNo, int itemBitNo, const csXyz* p_angle,\n                          int roomNo, const cXyz* scale, u8 param_7);\n\ns32 fopAcM_createItemForBoss(const cXyz* p_pos, int param_2, int roomNo, const csXyz* p_angle,\n                             const cXyz* p_scale, f32 speedF, f32 speedY, int param_8);\n\ns32 fopAcM_createItemForMidBoss(const cXyz* p_pos, int i_itemNo, int i_roomNo, const csXyz* p_angle,\n                                const cXyz* p_scale, int param_6, int param_7);\n\nvoid* fopAcM_createItemForDirectGet(const cXyz* p_pos, int i_itemNo, int i_roomNo,\n                                    const csXyz* p_angle, const cXyz* p_scale, f32 speedF,\n                                    f32 speedY);\n\nvoid* fopAcM_createItemForSimpleDemo(const cXyz* p_pos, int i_itemNo, int i_roomNo,\n                                     const csXyz* p_angle, const cXyz* p_scale, f32 speedF,\n                                     f32 speedY);\n\ns32 fopAcM_createItem(const cXyz* p_pos, int itemNo, int param_3, int roomNo, const csXyz* p_angle,\n                      const cXyz* p_scale, int param_7);\n\nvoid* fopAcM_fastCreateItem2(const cXyz* p_pos, int itemNo, int param_3, int roomNo, int param_5,\n                             const csXyz* p_angle, const cXyz* p_scale);\n\nvoid* fopAcM_fastCreateItem(const cXyz* p_pos, int i_itemNo, int i_roomNo, const csXyz* p_angle,\n                            const cXyz* p_scale, f32* p_speedF, f32* p_speedY, int param_8,\n                            int param_9, createFunc p_createFunc);\n\ns32 fopAcM_createBokkuri(u16, const cXyz*, int, int, int, const cXyz*, int, int);\ns32 fopAcM_createWarpHole(const cXyz*, const csXyz*, int, u8, u8, u8);\n\nfopAc_ac_c* fopAcM_myRoomSearchEnemy(s8 roomNo);\n\ns32 fopAcM_createDisappear(const fopAc_ac_c*, const cXyz*, u8, u8, u8);\nvoid fopAcM_setCarryNow(fopAc_ac_c*, int);\nvoid fopAcM_cancelCarryNow(fopAc_ac_c*);\ns32 fopAcM_otoCheck(const fopAc_ac_c*, f32);\ns32 fopAcM_otherBgCheck(const fopAc_ac_c*, const fopAc_ac_c*);\ns32 fopAcM_wayBgCheck(const fopAc_ac_c*, f32, f32);\ns32 fopAcM_plAngleCheck(const fopAc_ac_c*, s16);\nvoid fopAcM_effSmokeSet1(u32*, u32*, const cXyz*, const csXyz*, f32, const dKy_tevstr_c*, int);\nvoid fopAcM_effHamonSet(u32*, const cXyz*, f32, f32);\ns32 fopAcM_riverStream(cXyz*, s16*, f32*, f32);\ns32 fopAcM_carryOffRevise(fopAc_ac_c*);\n// void vectle_calc(const DOUBLE_POS*, cXyz*);\n// void get_vectle_calc(const cXyz*, const cXyz*, cXyz*);\nvoid fopAcM_setEffectMtx(const fopAc_ac_c*, const J3DModelData*);\n\nstatic const char* fopAcM_getProcNameString(const fopAc_ac_c* p_actor);\n\nstatic const fopAc_ac_c* fopAcM_findObjectCB(fopAc_ac_c const* p_actor, void* p_data);\n\nfopAc_ac_c* fopAcM_searchFromName(char const* name, u32 param0, u32 param1);\n\nfopAc_ac_c* fopAcM_findObject4EventCB(fopAc_ac_c* p_actor, void* p_data);\n\nfopAc_ac_c* fopAcM_searchFromName4Event(char const* name, s16 eventID);\n\ns32 fopAcM_getWaterY(const cXyz*, f32*);\nvoid fpoAcM_relativePos(fopAc_ac_c const* actor, cXyz const* p_inPos, cXyz* p_outPos);\ns32 fopAcM_getWaterStream(const cXyz*, const cBgS_PolyInfo&, cXyz*, int*, int);\ns16 fopAcM_getPolygonAngle(const cBgS_PolyInfo&, s16);\ns16 fopAcM_getPolygonAngle(cM3dGPla const* param_0, s16 param_1);\n\ninline void make_prm_warp_hole(u32* actorParams, u8 p1, u8 p2, u8 p3) {\n    u32 pp1 = (p3 << 0x8);\n    u32 pp2 = (p2 << 0x10);\n    u32 pp3 = (p1 << 0x1B) | 0x170000FF;\n    *actorParams = pp2 | pp3 | pp1;\n}\n\ninline void make_prm_bokkuri(u32* pActorParams, csXyz* p_angle, u8 param_2, u8 param_3, u8 param_4,\n                             u8 param_5, u8 param_6) {\n    p_angle->x = (param_4 << 0x8) | (param_3 & 0xFF);\n    p_angle->z = (param_6 << 0xD) | (param_2 << 0x1) | param_5;\n}\n\ninline fopAc_ac_c* dComIfGp_getPlayer(int);\n\ninline s16 fopAcM_searchPlayerAngleY(const fopAc_ac_c* actor) {\n    return fopAcM_searchActorAngleY(actor, dComIfGp_getPlayer(0));\n}\n\ninline f32 fopAcM_searchPlayerDistanceY(const fopAc_ac_c* actor) {\n    return fopAcM_searchActorDistanceY(actor, dComIfGp_getPlayer(0));\n}\n\ninline f32 fopAcM_searchPlayerDistanceXZ2(const fopAc_ac_c* actor) {\n    return fopAcM_searchActorDistanceXZ2(actor, dComIfGp_getPlayer(0));\n}\n\ninline f32 fopAcM_searchPlayerDistanceXZ(const fopAc_ac_c* actor) {\n    return fopAcM_searchActorDistanceXZ(actor, dComIfGp_getPlayer(0));\n}\n\ninline f32 fopAcM_searchPlayerDistance(const fopAc_ac_c* actor) {\n    return fopAcM_searchActorDistance(actor, dComIfGp_getPlayer(0));\n}\n\ninline s32 fopAcM_seenPlayerAngleY(const fopAc_ac_c* i_actor) {\n    return fopAcM_seenActorAngleY(i_actor, dComIfGp_getPlayer(0));\n}\n\ns8 dComIfGp_getReverb(int roomNo);\n\ninline void fopAcM_seStartCurrent(const fopAc_ac_c* actor, u32 sfxID, u32 param_2) {\n    s8 roomNo = fopAcM_GetRoomNo(actor);\n    mDoAud_seStart(sfxID, &actor->current.pos, param_2, dComIfGp_getReverb(roomNo));\n}\n\ninline void fopAcM_seStart(const fopAc_ac_c* actor, u32 sfxID, u32 param_2) {\n    s8 roomNo = fopAcM_GetRoomNo(actor);\n    mDoAud_seStart(sfxID, &actor->mEyePos, param_2, dComIfGp_getReverb(roomNo));\n}\n\ninline void fopAcM_seStartLevel(const fopAc_ac_c* actor, u32 sfxID, u32 param_2) {\n    s8 roomNo = fopAcM_GetRoomNo(actor);\n    i_mDoAud_seStartLevel(sfxID, &actor->mEyePos, param_2, dComIfGp_getReverb(roomNo));\n}\n\ninline void fopAcM_seStartCurrentLevel(const fopAc_ac_c* actor, u32 sfxID, u32 param_2) {\n    s8 roomNo = fopAcM_GetRoomNo(actor);\n    i_mDoAud_seStartLevel(sfxID, &actor->current.pos, param_2, dComIfGp_getReverb(roomNo));\n}\n\ninline void fopAcM_offActor(fopAc_ac_c* pActor, u32 flag) {\n    dComIfGs_offActor(flag,fopAcM_GetHomeRoomNo(pActor));\n}\n\ninline void fopAcM_OnCarryType(fopAc_ac_c* pActor, fopAcM_CARRY param_2) {\n    pActor->mCarryType |= param_2;\n}\n\nextern \"C\" {\nvoid fopAcM_initManager__Fv(void);\nvoid fopAcM_CreateAppend__Fv(void);\nvoid fopAcM_DeleteHeap__FP10fopAc_ac_c(void);\nvoid fopAcM_FastCreate__FsPFPv_iPvPv(void);\nvoid fopAcM_Log__FPC10fopAc_ac_cPCc(void);\nvoid fopAcM_SearchByID__FUiPP10fopAc_ac_c(void);\nvoid fopAcM_calcSpeed__FP10fopAc_ac_c(void);\nvoid fopAcM_callCallback__FP10fopAc_ac_cPFP10fopAc_ac_c_iP7JKRHeap(void);\nvoid fopAcM_cancelCarryNow__FP10fopAc_ac_c(void);\nvoid fopAcM_create__FsUsUlPC4cXyziPC5csXyzPC4cXyzScPFPv_i(void);\nvoid fopAcM_createChild__FsUiUlPC4cXyziPC5csXyzPC4cXyzScPFPv_i(void);\nvoid fopAcM_createDemoItem__FPC4cXyziiPC5csXyziPC4cXyzUc(void);\nvoid fopAcM_createItem__FPC4cXyziiiPC5csXyzPC4cXyzi(void);\nvoid fopAcM_createItemForDirectGet__FPC4cXyziiPC5csXyzPC4cXyzff(void);\nvoid fopAcM_createItemForPresentDemo__FPC4cXyziUciiPC5csXyzPC4cXyz(void);\nvoid fopAcM_createItemForSimpleDemo__FPC4cXyziiPC5csXyzPC4cXyzff(void);\nvoid fopAcM_createItemForTrBoxDemo__FPC4cXyziiiPC5csXyzPC4cXyz(void);\nvoid fopAcM_createItemFromTable__FPC4cXyziiiPC5csXyziPC4cXyzPfPfb(void);\nvoid fopAcM_create__FsUlPC4cXyziPC5csXyzPC4cXyzSc(void);\nvoid fopAcM_cullingCheck__FPC10fopAc_ac_c(void);\nvoid fopAcM_delete__FP10fopAc_ac_c(void);\nvoid fopAcM_delete__FUi(void);\nvoid fopAcM_effHamonSet__FPUlPC4cXyzff(void);\nvoid fopAcM_entrySolidHeap__FP10fopAc_ac_cPFP10fopAc_ac_c_iUl(void);\nvoid fopAcM_entrySolidHeap___FP10fopAc_ac_cPFP10fopAc_ac_c_iUl(void);\nvoid fopAcM_fastCreate__FsUlPC4cXyziPC5csXyzPC4cXyzScPFPv_iPv(void);\nvoid fopAcM_fastCreateItem__FPC4cXyziiPC5csXyzPC4cXyzPfPfiiPFPv_i(void);\nvoid fopAcM_fastCreateItem2__FPC4cXyziiiiPC5csXyzPC4cXyz(void);\nvoid fopAcM_fastCreate__FPCcUlPC4cXyziPC5csXyzPC4cXyzPFPv_iPv(void);\nvoid fopAcM_findObject4EventCB__FP10fopAc_ac_cPv(void);\nvoid fopAcM_findObjectCB__FPC10fopAc_ac_cPv(void);\nvoid gndCheck__11fopAcM_gc_cFPC4cXyz(void);\nvoid fopAcM_getEventPartner__FPC10fopAc_ac_c(void);\nvoid fopAcM_getItemEventPartner__FPC10fopAc_ac_c(void);\nvoid fopAcM_getItemNoFromTableNo__FUc(void);\nvoid fopAcM_getPolygonAngle__FRC13cBgS_PolyInfos(void);\nvoid fopAcM_getPolygonAngle__FPC8cM3dGPlas(void);\nvoid fopAcM_getProcNameString__FPC10fopAc_ac_c(void);\nvoid fopAcM_getTalkEventPartner__FPC10fopAc_ac_c(void);\nvoid fopAcM_getWaterStream__FPC4cXyzRC13cBgS_PolyInfoP4cXyzPii(void);\nvoid fopAcM_getWaterY__FPC4cXyzPf(void);\nvoid lineCheck__11fopAcM_lc_cFPC4cXyzPC4cXyzPC10fopAc_ac_c(void);\nvoid fopAcM_orderCatchEvent__FP10fopAc_ac_cP10fopAc_ac_cUsUs(void);\nvoid fopAcM_orderChangeEventId__FP10fopAc_ac_csUsUs(void);\nvoid fopAcM_orderDoorEvent__FP10fopAc_ac_cP10fopAc_ac_cUsUs(void);\nvoid fopAcM_orderItemEvent__FP10fopAc_ac_cUsUs(void);\nvoid fopAcM_orderMapToolAutoNextEvent__FP10fopAc_ac_cUcsUsUsUs(void);\nvoid fopAcM_orderMapToolEvent__FP10fopAc_ac_cUcsUsUsUs(void);\nvoid fopAcM_orderOtherEvent__FP10fopAc_ac_cPCcUsUsUs(void);\nvoid fopAcM_orderOtherEventId__FP10fopAc_ac_csUcUsUsUs(void);\nvoid fopAcM_orderOtherEvent__FP10fopAc_ac_cP10fopAc_ac_cPCcUsUsUs(void);\nvoid fopAcM_orderSpeakEvent__FP10fopAc_ac_cUsUs(void);\nvoid fopAcM_orderTalkEvent__FP10fopAc_ac_cP10fopAc_ac_cUsUs(void);\nvoid fopAcM_orderTalkItemBtnEvent__FUsP10fopAc_ac_cP10fopAc_ac_cUsUs(void);\nvoid fopAcM_orderTreasureEvent__FP10fopAc_ac_cP10fopAc_ac_cUsUs(void);\nvoid fopAcM_posMove__FP10fopAc_ac_cPC4cXyz(void);\nvoid fopAcM_posMoveF__FP10fopAc_ac_cPC4cXyz(void);\nvoid fopAcM_searchActorAngleY__FPC10fopAc_ac_cPC10fopAc_ac_c(void);\nvoid fopAcM_searchActorDistance__FPC10fopAc_ac_cPC10fopAc_ac_c(void);\nvoid fopAcM_searchActorDistanceXZ__FPC10fopAc_ac_cPC10fopAc_ac_c(void);\nvoid fopAcM_searchActorDistanceXZ2__FPC10fopAc_ac_cPC10fopAc_ac_c(void);\nvoid fopAcM_searchFromName__FPCcUlUl(void);\nvoid fopAcM_searchFromName4Event__FPCcs(void);\nvoid fopAcM_seenActorAngleY__FPC10fopAc_ac_cPC10fopAc_ac_c(void);\nvoid fopAcM_setCarryNow__FP10fopAc_ac_ci(void);\nvoid fopAcM_setCullSizeBox__FP10fopAc_ac_cffffff(void);\nvoid fopAcM_setEffectMtx__FPC10fopAc_ac_cPC12J3DModelData(void);\nvoid fopAcM_setRoomLayer__FPvi(void);\nvoid fopAcM_setStageLayer__FPv(void);\nvoid waterCheck__11fopAcM_wt_cFPC4cXyz(void);\nvoid fpoAcM_relativePos__FPC10fopAc_ac_cPC4cXyzP4cXyz(void);\nvoid fopAcM_SearchByName__FsPP10fopAc_ac_c(void);\nvoid fopAcM_createChildFromOffset__FsUiUlPC4cXyziPC5csXyzPC4cXyzScPFPv_i(void);\nvoid fopAcM_SetMin__FP10fopAc_ac_cfff(void);\nvoid fopAcM_SetMax__FP10fopAc_ac_cfff(void);\nvoid fopAcM_setCullSizeSphere__FP10fopAc_ac_cffff(void);\nvoid fopAcM_setCullSizeBox2__FP10fopAc_ac_cP12J3DModelData(void);\nvoid fopAcM_addAngleY__FP10fopAc_ac_css(void);\nvoid fopAcM_searchActorAngleX__FPC10fopAc_ac_cPC10fopAc_ac_c(void);\nvoid fopAcM_searchActorDistance2__FPC10fopAc_ac_cPC10fopAc_ac_c(void);\nvoid fopAcM_rollPlayerCrash__FPC10fopAc_ac_cfUlffif(void);\nvoid fopAcM_checkCullingBox__FPA4_fffffff(void);\nvoid fopAcM_orderPotentialEvent__FP10fopAc_ac_cUsUsUs(void);\nvoid fopAcM_createItemFromEnemyID__FUcPC4cXyziiPC5csXyzPC4cXyzPfPf(void);\nvoid fopAcM_createItemForBoss__FPC4cXyziiPC5csXyzPC4cXyzffi(void);\nvoid fopAcM_createItemForMidBoss__FPC4cXyziiPC5csXyzPC4cXyzii(void);\nvoid fopAcM_createBokkuri__FUsPC4cXyziiiPC4cXyzii(void);\nvoid fopAcM_createWarpHole__FPC4cXyzPC5csXyziUcUcUc(void);\nvoid fopAcM_myRoomSearchEnemy__FSc(void);\nvoid fopAcM_createDisappear__FPC10fopAc_ac_cPC4cXyzUcUcUc(void);\nvoid fopAcM_otoCheck__FPC10fopAc_ac_cf(void);\nvoid fopAcM_otherBgCheck__FPC10fopAc_ac_cPC10fopAc_ac_c(void);\nvoid fopAcM_wayBgCheck__FPC10fopAc_ac_cff(void);\nvoid fopAcM_plAngleCheck__FPC10fopAc_ac_cs(void);\nvoid fopAcM_effSmokeSet1__FPUlPUlPC4cXyzPC5csXyzfPC12dKy_tevstr_ci(void);\nvoid fopAcM_riverStream__FP4cXyzPsPff(void);\nvoid fopAcM_carryOffRevise__FP10fopAc_ac_c(void);\nvoid fopAcM_searchFromName4Event__FPCcs(void);\nvoid fopAcM_GetName__FPv(void);  // mostly inlined\nvoid fopAcM_GetID__FPCv(void);   // mostly inlined\n}\n\n#endif\n/* end \"f_op/f_op_actor_mng.h\" */\n/* \"src/d/d_attention.cpp\" line 14 \"m_Do/m_Do_controller_pad.h\" */\n#ifndef M_DO_M_DO_CONTROLLER_PAD_H\n#define M_DO_M_DO_CONTROLLER_PAD_H\n\n/* \"include/m_Do/m_Do_controller_pad.h\" line 3 \"JSystem/JUtility/JUTGamePad.h\" */\n#ifndef JUTGAMEPAD_H\n#define JUTGAMEPAD_H\n\n/* \"include/JSystem/JUtility/JUTGamePad.h\" line 3 \"JSystem/JKernel/JKRDisposer.h\" */\n/* end \"JSystem/JKernel/JKRDisposer.h\" */\n/* \"include/JSystem/JUtility/JUTGamePad.h\" line 4 \"dolphin/os/OSTime.h\" */\n/* end \"dolphin/os/OSTime.h\" */\n/* \"include/JSystem/JUtility/JUTGamePad.h\" line 5 \"dolphin/pad/Pad.h\" */\n#ifndef PAD_H\n#define PAD_H\n\n/* \"include/dolphin/pad/Pad.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct OSContext OSContext;\n\ntypedef enum PADMask {\n    PAD_CHAN3_BIT = (1 << 28),\n    PAD_CHAN2_BIT = (1 << 29),\n    PAD_CHAN1_BIT = (1 << 30),\n    PAD_CHAN0_BIT = (1 << 31),\n} PADMask;\n\n#define PAD_SPEC_0 0\n#define PAD_SPEC_1 1\n#define PAD_SPEC_2 2\n#define PAD_SPEC_3 3\n#define PAD_SPEC_4 4\n#define PAD_SPEC_5 5\n\n#define PAD_MOTOR_STOP 0\n#define PAD_MOTOR_RUMBLE 1\n#define PAD_MOTOR_STOP_HARD 2\n\n#define PAD_ERR_NONE 0\n#define PAD_ERR_NO_CONTROLLER -1\n#define PAD_ERR_NOT_READY -2\n#define PAD_ERR_TRANSFER -3\n\n#define PAD_BUTTON_LEFT 0x0001\n#define PAD_BUTTON_RIGHT 0x0002\n#define PAD_BUTTON_DOWN 0x0004\n#define PAD_BUTTON_UP 0x0008\n#define PAD_TRIGGER_Z 0x0010\n#define PAD_TRIGGER_R 0x0020\n#define PAD_TRIGGER_L 0x0040\n#define PAD_BUTTON_A 0x0100\n#define PAD_BUTTON_B 0x0200\n#define PAD_BUTTON_X 0x0400\n#define PAD_BUTTON_Y 0x0800\n#define PAD_BUTTON_MENU 0x1000\n#define PAD_BUTTON_START 0x1000\n\ntypedef struct PADStatus {\n    /* 0x0 */ u16 button;\n    /* 0x2 */ s8 stick_x;\n    /* 0x3 */ s8 stick_y;\n    /* 0x4 */ s8 substick_x;\n    /* 0x5 */ s8 substick_y;\n    /* 0x6 */ u8 trigger_left;\n    /* 0x7 */ u8 trigger_right;\n    /* 0x8 */ u8 analog_a;\n    /* 0x9 */ u8 analog_b;\n    /* 0xA */ s8 error;\n} PADStatus;\n\ntypedef void (*PADSamplingCallback)(void);\n\nBOOL PADInit(void);\nvoid PADSetAnalogMode(u32 mode);\nvoid PADSetSpec(u32 spec);\nBOOL PADReset(u32 mask);\nvoid PADClampCircle(PADStatus* status);\nvoid PADClamp(PADStatus* status);\nu32 PADRead(PADStatus* status);\nvoid PADControlMotor(s32 channel, u32 command);\nBOOL PADRecalibrate(u32 mask);\nstatic void PADOriginCallback(s32 chan, u32 error, OSContext* context);\nstatic void PADOriginUpdateCallback(s32 chan, u32 error, OSContext* context);\nstatic void PADProbeCallback(s32 chan, u32 error, OSContext* context);\nstatic void PADTypeAndStatusCallback(s32 chan, u32 type);\nstatic void PADReceiveCheckCallback(s32 chan, u32 type);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* PAD_H */\n/* end \"dolphin/pad/Pad.h\" */\n/* \"include/JSystem/JUtility/JUTGamePad.h\" line 6 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\ntypedef void (*callbackFn)(int, void*);\n\nnamespace CButton {\nenum {\n    DPAD_LEFT = 0x0001,\n    DPAD_RIGHT = 0x0002,\n    DPAD_DOWN = 0x0004,\n    DPAD_UP = 0x0008,\n    Z = 0x0010,\n    R = 0x0020,\n    L = 0x0040,\n    A = 0x0100,\n    B = 0x0200,\n    X = 0x0400,\n    Y = 0x0800,\n    START = 0x1000,\n};\n}\n\nextern bool sResetSwitchPushing__Q210JUTGamePad13C3ButtonReset;\n\nstruct JUTGamePadRecordBase {\n    virtual void unk0() {}\n    virtual void unk1(PADStatus* pad) {}\n    virtual void unk2() {}\n\n    /* 0x4 */ bool mActive;\n};\n\nstruct JUTGamePad : public JKRDisposer {\npublic:\n    enum EStickMode {\n        STICK_MODE_1 = 1,\n    };\n    enum EWhichStick {\n        WS_MAIN_STICK,\n        WS_SUB_STICK,\n    };\n    enum EPadPort {\n        Port_Unknown = -1,\n        Port_1,\n        Port_2,\n        Port_3,\n        Port_4,\n    };\n\n    JUTGamePad(JUTGamePad::EPadPort port);\n    virtual ~JUTGamePad();\n\n    void initList();\n    static s32 init();\n    void clear();\n    static u32 read();\n    void assign();\n    void checkResetCallback(OSTime unk);\n    void update();\n    void stopPatternedRumble() { mRumble.stopPatternedRumble(mPortNum); }\n    static void checkResetSwitch();\n    static void clearForReset();\n    static JUTGamePad* getGamePad(int pad_index);\n    static bool recalibrate(u32 pad_mask);\n\n    static void setAnalogMode(u32 mode) {\n        sAnalogMode = mode;\n        PADSetAnalogMode(mode);\n    }\n\n    static void clearResetOccurred() { C3ButtonReset::sResetOccurred = false; }\n\n    static void setResetCallback(callbackFn callback, void* param_0) {\n        C3ButtonReset::sCallback = callback;\n        C3ButtonReset::sCallbackArg = param_0;\n    }\n\n    u32 getButton() const { return mButton.mButton; }\n\n    u32 getTrigger() const { return mButton.mTrigger; }\n\n    f32 getMainStickX() const { return mMainStick.mPosX; }\n\n    f32 getMainStickY() const { return mMainStick.mPosY; }\n\n    f32 getMainStickValue() const { return mMainStick.mValue; }\n\n    s16 getMainStickAngle() const { return mMainStick.mAngle; }\n\n    f32 getSubStickX() const { return mSubStick.mPosX; }\n\n    f32 getSubStickY() const { return mSubStick.mPosY; }\n\n    f32 getSubStickValue() const { return mSubStick.mValue; }\n\n    s16 getSubStickAngle() const { return mSubStick.mAngle; }\n\n    u8 getAnalogA() const { return mButton.mAnalogA; }\n\n    u8 getAnalogB() const { return mButton.mAnalogB; }\n\n    u8 getAnalogL() const { return mButton.mAnalogL; }\n\n    u8 getAnalogR() const { return mButton.mAnalogR; }\n\n    s8 getErrorStatus() const { return mErrorStatus; }\n\n    s16 getPortNum() const { return mPortNum; }\n\n    JUTGamePadRecordBase* getPadReplay() const { return mPadReplay; }\n\n    JUTGamePadRecordBase* getPadRecord() const { return mPadRecord; }\n\n    u32 testTrigger(u32 button) const { return mButton.mTrigger & button; }\n\n    bool isPushing3ButtonReset() const {\n        bool isPushingReset = false;\n\n        if (mPortNum != -1 && mButtonReset.mReset != false) {\n            isPushingReset = true;\n        }\n        return isPushingReset;\n    }\n\n    inline void stopMotorWave() { mRumble.stopPatternedRumbleAtThePeriod(); }\n    void stopMotor() { mRumble.stopMotor(mPortNum, false); }\n    void stopMotorHard() { mRumble.stopMotorHard(mPortNum); }\n\n    static s8 getPortStatus(u32 port) { return mPadStatus[port].error; }\n\n    struct CButton {\n        CButton() { clear(); }\n        void clear();\n        void update(PADStatus const*, u32 unk);\n        void setRepeat(u32 unk0, u32 unk1, u32 unk2);\n\n        /* 0x00 */ u32 mButton;\n        /* 0x04 */ u32 mTrigger;  // Pressed Buttons\n        /* 0x08 */ u32 mRelease;  // Released Buttons\n        /* 0x0C */ u8 mAnalogA;\n        /* 0x0D */ u8 mAnalogB;\n        /* 0x0E */ u8 mAnalogL;\n        /* 0x0F */ u8 mAnalogR;\n        /* 0x10 */ f32 mAnalogLf;\n        /* 0x14 */ f32 mAnalogRf;\n        /* 0x18 */ u32 mRepeat;\n        /* 0x1C */ u32 field_0x1c;\n        /* 0x20 */ u32 field_0x20;\n        /* 0x24 */ u32 field_0x24;\n        /* 0x28 */ u32 field_0x28;\n        /* 0x2C */ u32 field_0x2c;\n    };  // Size: 0x30\n\n    struct C3ButtonReset {\n        C3ButtonReset() { mReset = false; }\n\n        static u32 sResetPattern;\n        static u32 sResetMaskPattern;\n        static callbackFn sCallback;\n        static void* sCallbackArg;\n        static OSTime sThreshold;\n        static s32 sResetOccurredPort;\n        static bool sResetOccurred;\n        static bool sResetSwitchPushing;\n\n        /* 0x0 */ bool mReset;\n    };  // Size: 0x4\n\n    struct CStick {\n        static f32 sPressPoint;\n        static f32 sReleasePoint;\n\n        CStick() { clear(); }\n        void clear();\n        void clear(JUTGamePad* pad);\n        u32 update(s8 unk0, s8 unk1, JUTGamePad::EStickMode mode, JUTGamePad::EWhichStick stick,\n                   u32 unk2);\n        u32 getButton(u32 unk);\n\n        /* 0x0 */ f32 mPosX;\n        /* 0x4 */ f32 mPosY;\n        /* 0x8 */ f32 mValue;\n        /* 0xC */ s16 mAngle;\n        /* 0xE */ s8 field_0xe;\n        /* 0xF */ s8 field_0xf;\n    };  // Size: 0x10\n\n    void stopMotorWaveHard() { mRumble.stopPatternedRumble(mPortNum); }\n\n    struct CRumble {\n        CRumble(JUTGamePad* pad) { clear(pad); }\n\n        static PADMask sChannelMask[4];\n        static bool mStatus[4];\n        static PADMask mEnabled;\n\n        enum ERumble {\n            VAL_0 = 0,\n            VAL_1 = 1,\n            VAL_2 = 2,\n        };\n\n        void clear();\n        void clear(JUTGamePad* pad);\n        static void startMotor(int channel);\n        static void stopMotor(int channel, bool stop);\n        void update(s16 unk0);\n        void triggerPatternedRumble(u32 unk0);\n        void startPatternedRumble(void* unk0, ERumble rumble, u32 unk1);\n        void stopPatternedRumble(s16 pad_port);\n        void stopPatternedRumbleAtThePeriod();\n        static void setEnabled(u32 pad_mask);\n\n        void stopMotorHard(int portNo) { stopMotor(portNo, true); }\n\n        static bool isEnabled(u32 mask) { return mEnabled & mask; }\n        static bool isEnabledPort(int port) { return isEnabled(sChannelMask[port]); }\n\n        /* 0x00 */ u32 field_0x0;\n        /* 0x04 */ u32 field_0x4;\n        /* 0x08 */ u8* field_0x8;\n        /* 0x0C */ u32 field_0xc;\n        /* 0x10 */ u8* field_0x10;\n    };  // Size: 0x14\n\n    void startMotorWave(void* param_2, CRumble::ERumble rumble, u32 param_4) {\n        mRumble.startPatternedRumble(param_2, rumble, param_4);\n    }\n\n    /* 0x18 */ CButton mButton;\n    /* 0x48 */ CStick mMainStick;\n    /* 0x58 */ CStick mSubStick;\n    /* 0x68 */ CRumble mRumble;\n    /* 0x7C */ s16 mPortNum;\n    /* 0x7E */ s8 mErrorStatus;\n    /* 0x80 */ JSULink<JUTGamePad> mLink;\n    /* 0x90 */ JUTGamePadRecordBase* mPadRecord;\n    /* 0x94 */ JUTGamePadRecordBase* mPadReplay;\n    /* 0x98 */ C3ButtonReset mButtonReset;\n    /* 0x9C */ u8 field_0x9c[4];\n    /* 0xA0 */ OSTime mResetTime;\n    /* 0xA8 */ u8 field_0xa8;\n\n    static JSUList<JUTGamePad> mPadList;\n    static bool mListInitialized;\n    static PADStatus mPadStatus[4];\n    static CButton mPadButton[4];\n    static CStick mPadMStick[4];\n    static CStick mPadSStick[4];\n    static EStickMode sStickMode;\n    static u32 sClampMode;\n    static u8 mPadAssign[4];\n    static u32 sSuppressPadReset;\n    static s32 sAnalogMode;\n    static u32 sRumbleSupported;\n};\n\nstruct JUTGamePadLongPress {\n    static JSUList<JUTGamePadLongPress> sPatternList;\n    void checkCallback(int port, u32 timer);\n\n    u32 getMaskPattern() const { return mMaskPattern; }\n    u32 getPattern() const { return mPattern; }\n\n    /* 0x00 */ u8 field_0x0[0x10];\n    /* 0x10 */ bool mValid;\n    /* 0x11 */ bool field_0x11;\n    /* 0x14 */ u32 mPattern;\n    /* 0x18 */ u32 mMaskPattern;\n    /* 0x1C */ u32 field_0x1c;\n    /* 0x20 */ bool field_0x20[4];\n    /* 0x28 */ OSTime mTimer[4];\n    /* 0x48 */ bool field_0x48[4];\n    /* 0x4C */ void (*mCallback)(s32, JUTGamePadLongPress*, s32);\n    /* 0x50 */ s32 field_0x50;\n};\n\n#endif /* JUTGAMEPAD_H */\n/* end \"JSystem/JUtility/JUTGamePad.h\" */\n/* \"include/m_Do/m_Do_controller_pad.h\" line 4 \"SSystem/SComponent/c_API_controller_pad.h\" */\n#ifndef C_API_CONTROLLER_PAD_\n#define C_API_CONTROLLER_PAD_\n\n/* \"include/SSystem/SComponent/c_API_controller_pad.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nstruct interface_of_controller_pad {\n    /* 0x00 */ f32 mMainStickPosX;\n    /* 0x04 */ f32 mMainStickPosY;\n    /* 0x08 */ f32 mMainStickValue;\n    /* 0x0C */ s16 mMainStickAngle;\n    /* 0x0E */ u8 field_0xe;\n    /* 0x0F */ u8 field_0xf;\n    /* 0x10 */ f32 mCStickPosX;\n    /* 0x14 */ f32 mCStickPosY;\n    /* 0x18 */ f32 mCStickValue;\n    /* 0x1C */ s16 mCStickAngle;\n    /* 0x1E */ u8 field_0x1e;\n    /* 0x1F */ u8 field_0x1f;\n    /* 0x20 */ f32 mAnalogA;\n    /* 0x24 */ f32 mAnalogB;\n    /* 0x28 */ f32 mTriggerLeft;\n    /* 0x2C */ f32 mTriggerRight;\n    /* 0x30 */ u32 mButtonFlags;\n    /* 0x34 */ u32 mPressedButtonFlags;\n    /* 0x38 */ s8 mGamepadErrorFlags;\n    /* 0x39 */ u8 mHoldLockL;\n    /* 0x3A */ u8 mTrigLockL;\n    /* 0x3B */ u8 mHoldLockR;\n    /* 0x3C */ u8 mTrigLockR;\n    /* 0x3D */ u8 field_0x3d;\n    /* 0x3E */ u8 field_0x3e;\n    /* 0x3F */ u8 field_0x3f;\n};\n\nvoid cAPICPad_recalibrate(void);\nu32 cAPICPad_ANY_BUTTON(u32 param_0);\n\n#endif/* end \"SSystem/SComponent/c_API_controller_pad.h\" */\n\n// Controller Ports 1 - 4\nenum { PAD_1, PAD_2, PAD_3, PAD_4 };\n\nclass mDoCPd_c {\npublic:\n    static void create();\n    static void read();\n    static void convert(interface_of_controller_pad*, JUTGamePad*);\n    static void LRlockCheck(interface_of_controller_pad*);\n    static void recalibrate();\n\n    static interface_of_controller_pad& getCpadInfo(u32 pad) { return m_cpadInfo[pad]; }\n    static JUTGamePad* getGamePad(u32 pad) { return m_gamePad[pad]; }\n    static u32 getTrig(u32 pad) { return getCpadInfo(pad).mPressedButtonFlags; }\n    static u32 getTrigLockL(u32 pad) { return getCpadInfo(pad).mTrigLockL; }\n    static u32 getTrigLockR(u32 pad) { return getCpadInfo(pad).mTrigLockR; }\n    static u32 getTrigUp(u32 pad) { return getTrig(pad) & CButton::DPAD_UP; }\n    static u32 getTrigDown(u32 pad) { return getTrig(pad) & CButton::DPAD_DOWN; }\n    static u32 getTrigLeft(u32 pad) { return getTrig(pad) & CButton::DPAD_LEFT; }\n    static u32 getTrigRight(u32 pad) { return getTrig(pad) & CButton::DPAD_RIGHT; }\n    static u32 getTrigL(u32 pad) { return getTrig(pad) & CButton::L; }\n    static u32 getTrigR(u32 pad) { return getTrig(pad) & CButton::R; }\n    static u32 getTrigA(u32 pad) { return getTrig(pad) & CButton::A; }\n    static u32 getTrigB(u32 pad) { return getTrig(pad) & CButton::B; }\n    static u32 getTrigZ(u32 pad) { return getTrig(pad) & CButton::Z; }\n    static u32 getTrigY(u32 pad) { return getTrig(pad) & CButton::Y; }\n    static u32 getTrigX(u32 pad) { return getTrig(pad) & CButton::X; }\n    static u32 getTrigStart(u32 pad) { return getTrig(pad) & CButton::START; }\n    static u32 getHold(u32 pad) { return getCpadInfo(pad).mButtonFlags; }\n    static u32 getHoldLockL(u32 pad) { return getCpadInfo(pad).mHoldLockL; }\n    static u32 getHoldLockR(u32 pad) { return getCpadInfo(pad).mHoldLockR; }\n    static u32 getHoldUp(u32 pad) { return getHold(pad) & CButton::DPAD_UP; }\n    static u32 getHoldDown(u32 pad) { return getHold(pad) & CButton::DPAD_DOWN; }\n    static u32 getHoldLeft(u32 pad) { return getHold(pad) & CButton::DPAD_LEFT; }\n    static u32 getHoldRight(u32 pad) { return getHold(pad) & CButton::DPAD_RIGHT; }\n    static u32 getHoldL(u32 pad) { return getHold(pad) & CButton::L; }\n    static u32 getHoldR(u32 pad) { return getHold(pad) & CButton::R; }\n    static u32 getHoldA(u32 pad) { return getHold(pad) & CButton::A; }\n    static u32 getHoldB(u32 pad) { return getHold(pad) & CButton::B; }\n    static u32 getHoldZ(u32 pad) { return getHold(pad) & CButton::Z; }\n    static u32 getHoldY(u32 pad) { return getHold(pad) & CButton::Y; }\n    static u32 getHoldX(u32 pad) { return getHold(pad) & CButton::X; }\n    static f32 getStickX(u32 pad) { return getCpadInfo(pad).mMainStickPosX; }\n    static f32 getStickY(u32 pad) { return getCpadInfo(pad).mMainStickPosY; }\n    static f32 getStickX3D(u32 pad) { return getCpadInfo(pad).mMainStickPosX; }\n    static f32 getStickValue(u32 pad) { return getCpadInfo(pad).mMainStickValue; }\n    static s16 getStickAngle(u32 pad) { return getCpadInfo(pad).mMainStickAngle; }\n    static s16 getStickAngle3D(u32 pad) { return getCpadInfo(pad).mMainStickAngle; }\n    static f32 getSubStickX(u32 pad) { return getCpadInfo(pad).mCStickPosX; }\n    static f32 getSubStickY(u32 pad) { return getCpadInfo(pad).mCStickPosY; }\n    static f32 getSubStickValue(u32 pad) { return getCpadInfo(pad).mCStickValue; }\n    static s16 getSubStickAngle(u32 pad) { return getCpadInfo(pad).mCStickAngle; }\n    static f32 getAnalogR(u32 pad) { return getCpadInfo(pad).mTriggerRight; }\n    static f32 getAnalogL(u32 pad) { return getCpadInfo(pad).mTriggerLeft; }\n    static BOOL isConnect(u32 pad) { return JUTGamePad::getPortStatus(pad) == 0; }\n    static void startMotorWave(u32 pad, void* param_2, JUTGamePad::CRumble::ERumble param_3, u32 param_4) {\n        m_gamePad[pad]->startMotorWave(param_2, param_3, param_4);\n    }\n    static void stopMotor(u32 pad) { m_gamePad[pad]->stopMotor(); }\n    static void stopMotorWave(u32 pad) { m_gamePad[pad]->stopMotorWave(); }\n    static void stopMotorHard(u32 pad) { return m_gamePad[pad]->stopMotorHard(); }\n    static void stopMotorWaveHard(u32 pad) { return m_gamePad[pad]->stopMotorWaveHard(); }\n\n    static JUTGamePad* m_gamePad[4];\n    static interface_of_controller_pad m_cpadInfo[4];\n};\n\ninline void mDoCPd_ANALOG_CONV(u8 analog, f32& param_1) {\n    param_1 = analog * (1.0f / 15.0f);\n    if (param_1 > 1.0f) {\n        param_1 = 1.0f;\n    }\n}\n\ninline void mDoCPd_TRIGGER_CONV(u8 analog, f32& param_1) {\n    param_1 = analog * 0.0071428571827709675f;\n    if (param_1 > 1.0f) {\n        param_1 = 1.0f;\n    }\n}\n\n#endif /* M_DO_M_DO_CONTROLLER_PAD_H */\n/* end \"m_Do/m_Do_controller_pad.h\" */\n\n//\n// Types:\n//\n\nclass dAttDrawParam_c {\npublic:\n    /* 80070158 */ dAttDrawParam_c();\n    /* 80073FC4 */ virtual ~dAttDrawParam_c();\n\n    /* 0x4 */ s8 field_0x4;\n    /* 0x8 */ f32 mCursorDistance;\n    /* 0xC */ f32 field_0xc;\n};", "diff_flags": [], "diff_label": "request__11dAttCatch_cFP10fopAc_ac_cUcfffsi", "libraries": []}