{"compiler": "mwcc_247_105", "compiler_flags": "-lang=c++ -use_lmw_stmw on -O4 -char signed -Cpp_exceptions off -fp_contract on -fp fmadd -enum int -inline auto -sym on", "source_code": "namespace GameAudio\n{\n    //JMath::TRandom_<JMath::TRandom_fast_> Random::sRandom(0);\n    //JMath::TRandom_<JMath::TRandom_fast_> Random::sSignalEngineRandom(0);\n\n    f32 Common::panDeform(f32 x, f32 y) \n    {\n        if(x > 0.5f) {\n            f32 ret = 0.5f + (x - 0.5f) * y;\n            if(ret > 1.0f)\n                ret = 1.0f;\n            return ret;\n        } \n        else {\n            f32 ret = 0.5f - (0.5f - x) * y;\n            if (ret < 0.0f)\n                ret = 0.0f;\n            return ret;\n        }\n    }\n\n    f32 Common::setMultiPlayModePan(u8 p1) { return (p1 & 1); }\n\n    u32 Common::changeRandomId(u32 id1, u32 id2)\n    {\n        JAISoundID soundId(id1);\n        u32 swBit = GetGameAudioMain()->getSoundTable()->getSwBit(soundId);\n\n        if (swBit & 0x70000000) {\n            swBit = ((swBit & 0x70000000) >> 0x1c) + 1;\n            u32 rnd = Random::getRandomU32();\n            u32 randId = id1 + ((rnd >> 0xc) % swBit);\n            if (randId == id2 && (++randId == id1 + swBit))\n            {\n                randId = id1;\n            }\n            return randId;\n        }\n        return id1;\n    }\n\n    void Random::setSeed(u32 seed)\n    {\n        sRandom.setSeed(seed);\n        sSignalEngineRandom.setSeed(seed);\n    }\n\n    u32 Random::getRandomU32() { return (4.294967295f) * sRandom.get_ufloat_1(); }\n    u32 Random::getSignalEngineRandomU32() { return (4.294967295f) * sSignalEngineRandom.get_ufloat_1(); }\n}\n\n", "context": "#ifndef GAMEAUDIOMAIN_H\n#define GAMEAUDIOMAIN_H\n\n/* \"include\\Inagaki\\GameAudioMain.h\" line 3 \"JSystem/JKernel/JKRHeap.h\" */\n#ifndef JKRHEAP_H\n#define JKRHEAP_H\n\n/* \"include\\JSystem\\JKernel\\JKRHeap.h\" line 3 \"dolphin/os.h\" */\n#ifndef _DOLPHIN_OS\n#define _DOLPHIN_OS\n\n/* \"include\\dolphin\\os.h\" line 3 \"dolphin/gx.h\" */\n#ifndef _DOLPHIN_GX\n#define _DOLPHIN_GX\n\n/* \"include\\dolphin\\gx.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n#ifndef _DOLPHIN_GXENUM\n#define _DOLPHIN_GXENUM\n\n/* \"include\\dolphin\\gx\\GXEnum.h\" line 3 \"dolphin/types.h\" */\n#ifndef DOLPHIN_TYPES_H\n#define DOLPHIN_TYPES_H\n\ntypedef signed char s8;\ntypedef signed short s16;\ntypedef signed long s32;\ntypedef signed long long s64;\ntypedef unsigned char u8;\ntypedef unsigned short u16;\ntypedef unsigned long u32;\ntypedef unsigned long long u64;\n\ntypedef volatile u8 vu8;\ntypedef volatile u16 vu16;\ntypedef volatile u32 vu32;\ntypedef volatile u64 vu64;\ntypedef volatile s8 vs8;\ntypedef volatile s16 vs16;\ntypedef volatile s32 vs32;\ntypedef volatile s64 vs64;\n\ntypedef float f32;\ntypedef double f64;\ntypedef volatile f32 vf32;\ntypedef volatile f64 vf64;\n\ntypedef int BOOL;\n\n#ifndef TRUE\n#define TRUE 1\n#endif // TRUE\n\n#ifndef FALSE\n#define FALSE 0\n#endif // FALSE\n\n#ifndef NULL\n#ifdef __cplusplus\n#define NULL 0\n#else // __cplusplus\n#define NULL ((void *)0)\n#endif // __cplusplus\n#endif // NULL\n\n#endif/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef u8 GXBool;\n\n#define GX_FALSE ((GXBool)0)\n#define GX_TRUE ((GXBool)1)\n\n#define GX_ENABLE ((GXBool)1)\n#define GX_DISABLE ((GXBool)0)\n\ntypedef enum _GXProjectionType {\n  GX_PERSPECTIVE,\n  GX_ORTHOGRAPHIC,\n} GXProjectionType;\n\ntypedef enum _GXCompare {\n  GX_NEVER,\n  GX_LESS,\n  GX_EQUAL,\n  GX_LEQUAL,\n  GX_GREATER,\n  GX_NEQUAL,\n  GX_GEQUAL,\n  GX_ALWAYS,\n} GXCompare;\n\ntypedef enum _GXAlphaOp {\n  GX_AOP_AND,\n  GX_AOP_OR,\n  GX_AOP_XOR,\n  GX_AOP_XNOR,\n  GX_MAX_ALPHAOP,\n} GXAlphaOp;\n\ntypedef enum _GXFBClamp {\n  GX_CLAMP_NONE,\n  GX_CLAMP_TOP,\n  GX_CLAMP_BOTTOM,\n} GXFBClamp;\n\ntypedef enum _GXZFmt16 {\n  GX_ZC_LINEAR,\n  GX_ZC_NEAR,\n  GX_ZC_MID,\n  GX_ZC_FAR,\n} GXZFmt16;\n\ntypedef enum _GXGamma {\n  GX_GM_1_0,\n  GX_GM_1_7,\n  GX_GM_2_2,\n} GXGamma;\n\ntypedef enum _GXPixelFmt {\n  GX_PF_RGB8_Z24,\n  GX_PF_RGBA6_Z24,\n  GX_PF_RGB565_Z16,\n  GX_PF_Z24,\n  GX_PF_Y8,\n  GX_PF_U8,\n  GX_PF_V8,\n  GX_PF_YUV420,\n} GXPixelFmt;\n\ntypedef enum _GXPrimitive {\n  GX_QUADS = 0x80,\n  GX_TRIANGLES = 0x90,\n  GX_TRIANGLESTRIP = 0x98,\n  GX_TRIANGLEFAN = 0xA0,\n  GX_LINES = 0xA8,\n  GX_LINESTRIP = 0xB0,\n  GX_POINTS = 0xB8,\n} GXPrimitive;\n\ntypedef enum _GXVtxFmt {\n  GX_VTXFMT0,\n  GX_VTXFMT1,\n  GX_VTXFMT2,\n  GX_VTXFMT3,\n  GX_VTXFMT4,\n  GX_VTXFMT5,\n  GX_VTXFMT6,\n  GX_VTXFMT7,\n  GX_MAX_VTXFMT,\n} GXVtxFmt;\n\ntypedef enum _GXAttr {\n  GX_VA_PNMTXIDX,\n  GX_VA_TEX0MTXIDX,\n  GX_VA_TEX1MTXIDX,\n  GX_VA_TEX2MTXIDX,\n  GX_VA_TEX3MTXIDX,\n  GX_VA_TEX4MTXIDX,\n  GX_VA_TEX5MTXIDX,\n  GX_VA_TEX6MTXIDX,\n  GX_VA_TEX7MTXIDX,\n  GX_VA_POS,\n  GX_VA_NRM,\n  GX_VA_CLR0,\n  GX_VA_CLR1,\n  GX_VA_TEX0,\n  GX_VA_TEX1,\n  GX_VA_TEX2,\n  GX_VA_TEX3,\n  GX_VA_TEX4,\n  GX_VA_TEX5,\n  GX_VA_TEX6,\n  GX_VA_TEX7,\n  GX_POS_MTX_ARRAY,\n  GX_NRM_MTX_ARRAY,\n  GX_TEX_MTX_ARRAY,\n  GX_LIGHT_ARRAY,\n  GX_VA_NBT,\n  GX_VA_MAX_ATTR,\n  GX_VA_NULL = 0xFF,\n} GXAttr;\n\n#define GX_MAX_VTXDESCLIST_SZ (GX_VA_MAX_ATTR + 1)\n\ntypedef enum _GXAttrType {\n  GX_NONE,\n  GX_DIRECT,\n  GX_INDEX8,\n  GX_INDEX16,\n} GXAttrType;\n\n#define _GX_TF_CTF 0x20\n#define _GX_TF_ZTF 0x10\n\ntypedef enum _GXTexFmt {\n  GX_TF_I4 = 0x0,\n  GX_TF_I8 = 0x1,\n  GX_TF_IA4 = 0x2,\n  GX_TF_IA8 = 0x3,\n  GX_TF_RGB565 = 0x4,\n  GX_TF_RGB5A3 = 0x5,\n  GX_TF_RGBA8 = 0x6,\n  GX_TF_CMPR = 0xE,\n\n  GX_CTF_R4 = 0x0 | _GX_TF_CTF,\n  GX_CTF_RA4 = 0x2 | _GX_TF_CTF,\n  GX_CTF_RA8 = 0x3 | _GX_TF_CTF,\n  GX_CTF_YUVA8 = 0x6 | _GX_TF_CTF,\n  GX_CTF_A8 = 0x7 | _GX_TF_CTF,\n  GX_CTF_R8 = 0x8 | _GX_TF_CTF,\n  GX_CTF_G8 = 0x9 | _GX_TF_CTF,\n  GX_CTF_B8 = 0xA | _GX_TF_CTF,\n  GX_CTF_RG8 = 0xB | _GX_TF_CTF,\n  GX_CTF_GB8 = 0xC | _GX_TF_CTF,\n\n  GX_TF_Z8 = 0x1 | _GX_TF_ZTF,\n  GX_TF_Z16 = 0x3 | _GX_TF_ZTF,\n  GX_TF_Z24X8 = 0x6 | _GX_TF_ZTF,\n\n  GX_CTF_Z4 = 0x0 | _GX_TF_ZTF | _GX_TF_CTF,\n  GX_CTF_Z8M = 0x9 | _GX_TF_ZTF | _GX_TF_CTF,\n  GX_CTF_Z8L = 0xA | _GX_TF_ZTF | _GX_TF_CTF,\n  GX_CTF_Z16L = 0xC | _GX_TF_ZTF | _GX_TF_CTF,\n\n  GX_TF_A8 = GX_CTF_A8,\n} GXTexFmt;\n\ntypedef enum _GXCITexFmt {\n  GX_TF_C4 = 0x8,\n  GX_TF_C8 = 0x9,\n  GX_TF_C14X2 = 0xa,\n} GXCITexFmt;\n\ntypedef enum _GXTexWrapMode {\n  GX_CLAMP,\n  GX_REPEAT,\n  GX_MIRROR,\n  GX_MAX_TEXWRAPMODE,\n} GXTexWrapMode;\n\ntypedef enum _GXTexFilter {\n  GX_NEAR,\n  GX_LINEAR,\n  GX_NEAR_MIP_NEAR,\n  GX_LIN_MIP_NEAR,\n  GX_NEAR_MIP_LIN,\n  GX_LIN_MIP_LIN,\n} GXTexFilter;\n\ntypedef enum _GXAnisotropy {\n  GX_ANISO_1,\n  GX_ANISO_2,\n  GX_ANISO_4,\n  GX_MAX_ANISOTROPY,\n} GXAnisotropy;\n\ntypedef enum _GXTexMapID {\n  GX_TEXMAP0,\n  GX_TEXMAP1,\n  GX_TEXMAP2,\n  GX_TEXMAP3,\n  GX_TEXMAP4,\n  GX_TEXMAP5,\n  GX_TEXMAP6,\n  GX_TEXMAP7,\n  GX_MAX_TEXMAP,\n  GX_TEXMAP_NULL = 0xFF,\n  GX_TEX_DISABLE = 0x100,\n} GXTexMapID;\n\ntypedef enum _GXTexCoordID {\n  GX_TEXCOORD0,\n  GX_TEXCOORD1,\n  GX_TEXCOORD2,\n  GX_TEXCOORD3,\n  GX_TEXCOORD4,\n  GX_TEXCOORD5,\n  GX_TEXCOORD6,\n  GX_TEXCOORD7,\n  GX_MAX_TEXCOORD,\n  GX_TEXCOORD_NULL = 0xFF,\n} GXTexCoordID;\n\ntypedef enum _GXTevStageID {\n  GX_TEVSTAGE0,\n  GX_TEVSTAGE1,\n  GX_TEVSTAGE2,\n  GX_TEVSTAGE3,\n  GX_TEVSTAGE4,\n  GX_TEVSTAGE5,\n  GX_TEVSTAGE6,\n  GX_TEVSTAGE7,\n  GX_TEVSTAGE8,\n  GX_TEVSTAGE9,\n  GX_TEVSTAGE10,\n  GX_TEVSTAGE11,\n  GX_TEVSTAGE12,\n  GX_TEVSTAGE13,\n  GX_TEVSTAGE14,\n  GX_TEVSTAGE15,\n  GX_MAX_TEVSTAGE,\n} GXTevStageID;\n\ntypedef enum _GXTevMode {\n  GX_MODULATE,\n  GX_DECAL,\n  GX_BLEND,\n  GX_REPLACE,\n  GX_PASSCLR,\n} GXTevMode;\n\ntypedef enum _GXTexMtxType {\n  GX_MTX3x4,\n  GX_MTX2x4,\n} GXTexMtxType;\n\ntypedef enum _GXTexGenType {\n  GX_TG_MTX3x4,\n  GX_TG_MTX2x4,\n  GX_TG_BUMP0,\n  GX_TG_BUMP1,\n  GX_TG_BUMP2,\n  GX_TG_BUMP3,\n  GX_TG_BUMP4,\n  GX_TG_BUMP5,\n  GX_TG_BUMP6,\n  GX_TG_BUMP7,\n  GX_TG_SRTG,\n} GXTexGenType;\n\ntypedef enum _GXPosNrmMtx {\n  GX_PNMTX0 = 0,\n  GX_PNMTX1 = 3,\n  GX_PNMTX2 = 6,\n  GX_PNMTX3 = 9,\n  GX_PNMTX4 = 12,\n  GX_PNMTX5 = 15,\n  GX_PNMTX6 = 18,\n  GX_PNMTX7 = 21,\n  GX_PNMTX8 = 24,\n  GX_PNMTX9 = 27,\n} GXPosNrmMtx;\n\ntypedef enum _GXTexMtx {\n  GX_TEXMTX0 = 30,\n  GX_TEXMTX1 = 33,\n  GX_TEXMTX2 = 36,\n  GX_TEXMTX3 = 39,\n  GX_TEXMTX4 = 42,\n  GX_TEXMTX5 = 45,\n  GX_TEXMTX6 = 48,\n  GX_TEXMTX7 = 51,\n  GX_TEXMTX8 = 54,\n  GX_TEXMTX9 = 57,\n  GX_IDENTITY = 60,\n} GXTexMtx;\n\ntypedef enum _GXChannelID {\n  GX_COLOR0,\n  GX_COLOR1,\n  GX_ALPHA0,\n  GX_ALPHA1,\n  GX_COLOR0A0,\n  GX_COLOR1A1,\n  GX_COLOR_ZERO,\n  GX_ALPHA_BUMP,\n  GX_ALPHA_BUMPN,\n  GX_COLOR_NULL = 0xFF,\n} GXChannelID;\n\ntypedef enum _GXTexGenSrc {\n  GX_TG_POS,\n  GX_TG_NRM,\n  GX_TG_BINRM,\n  GX_TG_TANGENT,\n  GX_TG_TEX0,\n  GX_TG_TEX1,\n  GX_TG_TEX2,\n  GX_TG_TEX3,\n  GX_TG_TEX4,\n  GX_TG_TEX5,\n  GX_TG_TEX6,\n  GX_TG_TEX7,\n  GX_TG_TEXCOORD0,\n  GX_TG_TEXCOORD1,\n  GX_TG_TEXCOORD2,\n  GX_TG_TEXCOORD3,\n  GX_TG_TEXCOORD4,\n  GX_TG_TEXCOORD5,\n  GX_TG_TEXCOORD6,\n  GX_TG_COLOR0,\n  GX_TG_COLOR1,\n  GX_MAX_TEXGENSRC,\n} GXTexGenSrc;\n\ntypedef enum _GXBlendMode {\n  GX_BM_NONE,\n  GX_BM_BLEND,\n  GX_BM_LOGIC,\n  GX_BM_SUBTRACT,\n  GX_MAX_BLENDMODE,\n} GXBlendMode;\n\ntypedef enum _GXBlendFactor {\n  GX_BL_ZERO,\n  GX_BL_ONE,\n  GX_BL_SRCCLR,\n  GX_BL_INVSRCCLR,\n  GX_BL_SRCALPHA,\n  GX_BL_INVSRCALPHA,\n  GX_BL_DSTALPHA,\n  GX_BL_INVDSTALPHA,\n  GX_BL_DSTCLR = GX_BL_SRCCLR,\n  GX_BL_INVDSTCLR = GX_BL_INVSRCCLR,\n} GXBlendFactor;\n\ntypedef enum _GXLogicOp {\n  GX_LO_CLEAR,\n  GX_LO_AND,\n  GX_LO_REVAND,\n  GX_LO_COPY,\n  GX_LO_INVAND,\n  GX_LO_NOOP,\n  GX_LO_XOR,\n  GX_LO_OR,\n  GX_LO_NOR,\n  GX_LO_EQUIV,\n  GX_LO_INV,\n  GX_LO_REVOR,\n  GX_LO_INVCOPY,\n  GX_LO_INVOR,\n  GX_LO_NAND,\n  GX_LO_SET,\n} GXLogicOp;\n\ntypedef enum _GXCompCnt {\n  GX_POS_XY = 0,\n  GX_POS_XYZ = 1,\n  GX_NRM_XYZ = 0,\n  GX_NRM_NBT = 1,\n  GX_NRM_NBT3 = 2,\n  GX_CLR_RGB = 0,\n  GX_CLR_RGBA = 1,\n  GX_TEX_S = 0,\n  GX_TEX_ST = 1,\n} GXCompCnt;\n\ntypedef enum _GXCompType {\n  GX_U8 = 0,\n  GX_S8 = 1,\n  GX_U16 = 2,\n  GX_S16 = 3,\n  GX_F32 = 4,\n  GX_RGB565 = 0,\n  GX_RGB8 = 1,\n  GX_RGBX8 = 2,\n  GX_RGBA4 = 3,\n  GX_RGBA6 = 4,\n  GX_RGBA8 = 5,\n} GXCompType;\n\ntypedef enum _GXPTTexMtx {\n  GX_PTTEXMTX0 = 64,\n  GX_PTTEXMTX1 = 67,\n  GX_PTTEXMTX2 = 70,\n  GX_PTTEXMTX3 = 73,\n  GX_PTTEXMTX4 = 76,\n  GX_PTTEXMTX5 = 79,\n  GX_PTTEXMTX6 = 82,\n  GX_PTTEXMTX7 = 85,\n  GX_PTTEXMTX8 = 88,\n  GX_PTTEXMTX9 = 91,\n  GX_PTTEXMTX10 = 94,\n  GX_PTTEXMTX11 = 97,\n  GX_PTTEXMTX12 = 100,\n  GX_PTTEXMTX13 = 103,\n  GX_PTTEXMTX14 = 106,\n  GX_PTTEXMTX15 = 109,\n  GX_PTTEXMTX16 = 112,\n  GX_PTTEXMTX17 = 115,\n  GX_PTTEXMTX18 = 118,\n  GX_PTTEXMTX19 = 121,\n  GX_PTIDENTITY = 125,\n} GXPTTexMtx;\n\ntypedef enum _GXTevRegID {\n  GX_TEVPREV,\n  GX_TEVREG0,\n  GX_TEVREG1,\n  GX_TEVREG2,\n  GX_MAX_TEVREG,\n} GXTevRegID;\n\ntypedef enum _GXDiffuseFn {\n  GX_DF_NONE,\n  GX_DF_SIGN,\n  GX_DF_CLAMP,\n} GXDiffuseFn;\n\ntypedef enum _GXColorSrc {\n  GX_SRC_REG,\n  GX_SRC_VTX,\n} GXColorSrc;\n\ntypedef enum _GXAttnFn {\n  GX_AF_SPEC,\n  GX_AF_SPOT,\n  GX_AF_NONE,\n} GXAttnFn;\n\ntypedef enum _GXLightID {\n  GX_LIGHT0 = 0x001,\n  GX_LIGHT1 = 0x002,\n  GX_LIGHT2 = 0x004,\n  GX_LIGHT3 = 0x008,\n  GX_LIGHT4 = 0x010,\n  GX_LIGHT5 = 0x020,\n  GX_LIGHT6 = 0x040,\n  GX_LIGHT7 = 0x080,\n  GX_MAX_LIGHT = 0x100,\n  GX_LIGHT_NULL = 0,\n} GXLightID;\n\ntypedef enum _GXTexOffset {\n  GX_TO_ZERO,\n  GX_TO_SIXTEENTH,\n  GX_TO_EIGHTH,\n  GX_TO_FOURTH,\n  GX_TO_HALF,\n  GX_TO_ONE,\n  GX_MAX_TEXOFFSET,\n} GXTexOffset;\n\ntypedef enum _GXSpotFn {\n  GX_SP_OFF,\n  GX_SP_FLAT,\n  GX_SP_COS,\n  GX_SP_COS2,\n  GX_SP_SHARP,\n  GX_SP_RING1,\n  GX_SP_RING2,\n} GXSpotFn;\n\ntypedef enum _GXDistAttnFn {\n  GX_DA_OFF,\n  GX_DA_GENTLE,\n  GX_DA_MEDIUM,\n  GX_DA_STEEP,\n} GXDistAttnFn;\n\ntypedef enum _GXCullMode {\n  GX_CULL_NONE,\n  GX_CULL_FRONT,\n  GX_CULL_BACK,\n  GX_CULL_ALL,\n} GXCullMode;\n\ntypedef enum _GXTevSwapSel {\n  GX_TEV_SWAP0 = 0,\n  GX_TEV_SWAP1,\n  GX_TEV_SWAP2,\n  GX_TEV_SWAP3,\n  GX_MAX_TEVSWAP,\n} GXTevSwapSel;\n\ntypedef enum _GXTevColorChan {\n  GX_CH_RED = 0,\n  GX_CH_GREEN,\n  GX_CH_BLUE,\n  GX_CH_ALPHA,\n} GXTevColorChan;\n\ntypedef enum _GXFogType {\n  GX_FOG_NONE = 0,\n  GX_FOG_PERSP_LIN = 2,\n  GX_FOG_PERSP_EXP = 4,\n  GX_FOG_PERSP_EXP2 = 5,\n  GX_FOG_PERSP_REVEXP = 6,\n  GX_FOG_PERSP_REVEXP2 = 7,\n  GX_FOG_ORTHO_LIN = 10,\n  GX_FOG_ORTHO_EXP = 12,\n  GX_FOG_ORTHO_EXP2 = 13,\n  GX_FOG_ORTHO_REVEXP = 14,\n  GX_FOG_ORTHO_REVEXP2 = 15,\n  GX_FOG_LIN = GX_FOG_PERSP_LIN,\n  GX_FOG_EXP = GX_FOG_PERSP_EXP,\n  GX_FOG_EXP2 = GX_FOG_PERSP_EXP2,\n  GX_FOG_REVEXP = GX_FOG_PERSP_REVEXP,\n  GX_FOG_REVEXP2 = GX_FOG_PERSP_REVEXP2,\n} GXFogType;\n\ntypedef enum _GXTevColorArg {\n  GX_CC_CPREV,\n  GX_CC_APREV,\n  GX_CC_C0,\n  GX_CC_A0,\n  GX_CC_C1,\n  GX_CC_A1,\n  GX_CC_C2,\n  GX_CC_A2,\n  GX_CC_TEXC,\n  GX_CC_TEXA,\n  GX_CC_RASC,\n  GX_CC_RASA,\n  GX_CC_ONE,\n  GX_CC_HALF,\n  GX_CC_KONST,\n  GX_CC_ZERO,\n} GXTevColorArg;\n\ntypedef enum _GXTevAlphaArg {\n  GX_CA_APREV,\n  GX_CA_A0,\n  GX_CA_A1,\n  GX_CA_A2,\n  GX_CA_TEXA,\n  GX_CA_RASA,\n  GX_CA_KONST,\n  GX_CA_ZERO,\n} GXTevAlphaArg;\n\ntypedef enum _GXTevOp {\n  GX_TEV_ADD = 0,\n  GX_TEV_SUB = 1,\n  GX_TEV_COMP_R8_GT = 8,\n  GX_TEV_COMP_R8_EQ = 9,\n  GX_TEV_COMP_GR16_GT = 10,\n  GX_TEV_COMP_GR16_EQ = 11,\n  GX_TEV_COMP_BGR24_GT = 12,\n  GX_TEV_COMP_BGR24_EQ = 13,\n  GX_TEV_COMP_RGB8_GT = 14,\n  GX_TEV_COMP_RGB8_EQ = 15,\n  GX_TEV_COMP_A8_GT = GX_TEV_COMP_RGB8_GT,\n  GX_TEV_COMP_A8_EQ = GX_TEV_COMP_RGB8_EQ,\n} GXTevOp;\n\ntypedef enum _GXTevBias {\n  GX_TB_ZERO,\n  GX_TB_ADDHALF,\n  GX_TB_SUBHALF,\n  GX_MAX_TEVBIAS,\n} GXTevBias;\n\ntypedef enum _GXTevScale {\n  GX_CS_SCALE_1,\n  GX_CS_SCALE_2,\n  GX_CS_SCALE_4,\n  GX_CS_DIVIDE_2,\n  GX_MAX_TEVSCALE,\n} GXTevScale;\n\ntypedef enum _GXTevKColorSel {\n  GX_TEV_KCSEL_8_8 = 0x00,\n  GX_TEV_KCSEL_7_8 = 0x01,\n  GX_TEV_KCSEL_6_8 = 0x02,\n  GX_TEV_KCSEL_5_8 = 0x03,\n  GX_TEV_KCSEL_4_8 = 0x04,\n  GX_TEV_KCSEL_3_8 = 0x05,\n  GX_TEV_KCSEL_2_8 = 0x06,\n  GX_TEV_KCSEL_1_8 = 0x07,\n  GX_TEV_KCSEL_1 = GX_TEV_KCSEL_8_8,\n  GX_TEV_KCSEL_3_4 = GX_TEV_KCSEL_6_8,\n  GX_TEV_KCSEL_1_2 = GX_TEV_KCSEL_4_8,\n  GX_TEV_KCSEL_1_4 = GX_TEV_KCSEL_2_8,\n  GX_TEV_KCSEL_K0 = 0x0C,\n  GX_TEV_KCSEL_K1 = 0x0D,\n  GX_TEV_KCSEL_K2 = 0x0E,\n  GX_TEV_KCSEL_K3 = 0x0F,\n  GX_TEV_KCSEL_K0_R = 0x10,\n  GX_TEV_KCSEL_K1_R = 0x11,\n  GX_TEV_KCSEL_K2_R = 0x12,\n  GX_TEV_KCSEL_K3_R = 0x13,\n  GX_TEV_KCSEL_K0_G = 0x14,\n  GX_TEV_KCSEL_K1_G = 0x15,\n  GX_TEV_KCSEL_K2_G = 0x16,\n  GX_TEV_KCSEL_K3_G = 0x17,\n  GX_TEV_KCSEL_K0_B = 0x18,\n  GX_TEV_KCSEL_K1_B = 0x19,\n  GX_TEV_KCSEL_K2_B = 0x1A,\n  GX_TEV_KCSEL_K3_B = 0x1B,\n  GX_TEV_KCSEL_K0_A = 0x1C,\n  GX_TEV_KCSEL_K1_A = 0x1D,\n  GX_TEV_KCSEL_K2_A = 0x1E,\n  GX_TEV_KCSEL_K3_A = 0x1F,\n} GXTevKColorSel;\n\ntypedef enum _GXTevKAlphaSel {\n  GX_TEV_KASEL_8_8 = 0x00,\n  GX_TEV_KASEL_7_8 = 0x01,\n  GX_TEV_KASEL_6_8 = 0x02,\n  GX_TEV_KASEL_5_8 = 0x03,\n  GX_TEV_KASEL_4_8 = 0x04,\n  GX_TEV_KASEL_3_8 = 0x05,\n  GX_TEV_KASEL_2_8 = 0x06,\n  GX_TEV_KASEL_1_8 = 0x07,\n  GX_TEV_KASEL_1 = GX_TEV_KASEL_8_8,\n  GX_TEV_KASEL_3_4 = GX_TEV_KASEL_6_8,\n  GX_TEV_KASEL_1_2 = GX_TEV_KASEL_4_8,\n  GX_TEV_KASEL_1_4 = GX_TEV_KASEL_2_8,\n  GX_TEV_KASEL_K0_R = 0x10,\n  GX_TEV_KASEL_K1_R = 0x11,\n  GX_TEV_KASEL_K2_R = 0x12,\n  GX_TEV_KASEL_K3_R = 0x13,\n  GX_TEV_KASEL_K0_G = 0x14,\n  GX_TEV_KASEL_K1_G = 0x15,\n  GX_TEV_KASEL_K2_G = 0x16,\n  GX_TEV_KASEL_K3_G = 0x17,\n  GX_TEV_KASEL_K0_B = 0x18,\n  GX_TEV_KASEL_K1_B = 0x19,\n  GX_TEV_KASEL_K2_B = 0x1A,\n  GX_TEV_KASEL_K3_B = 0x1B,\n  GX_TEV_KASEL_K0_A = 0x1C,\n  GX_TEV_KASEL_K1_A = 0x1D,\n  GX_TEV_KASEL_K2_A = 0x1E,\n  GX_TEV_KASEL_K3_A = 0x1F,\n} GXTevKAlphaSel;\n\ntypedef enum _GXTevKColorID {\n  GX_KCOLOR0 = 0,\n  GX_KCOLOR1,\n  GX_KCOLOR2,\n  GX_KCOLOR3,\n  GX_MAX_KCOLOR,\n} GXTevKColorID;\n\ntypedef enum _GXZTexOp {\n  GX_ZT_DISABLE,\n  GX_ZT_ADD,\n  GX_ZT_REPLACE,\n  GX_MAX_ZTEXOP,\n} GXZTexOp;\n\ntypedef enum _GXIndTexFormat {\n  GX_ITF_8,\n  GX_ITF_5,\n  GX_ITF_4,\n  GX_ITF_3,\n  GX_MAX_ITFORMAT,\n} GXIndTexFormat;\n\ntypedef enum _GXIndTexBiasSel {\n  GX_ITB_NONE,\n  GX_ITB_S,\n  GX_ITB_T,\n  GX_ITB_ST,\n  GX_ITB_U,\n  GX_ITB_SU,\n  GX_ITB_TU,\n  GX_ITB_STU,\n  GX_MAX_ITBIAS,\n} GXIndTexBiasSel;\n\ntypedef enum _GXIndTexAlphaSel {\n  GX_ITBA_OFF,\n  GX_ITBA_S,\n  GX_ITBA_T,\n  GX_ITBA_U,\n  GX_MAX_ITBALPHA,\n} GXIndTexAlphaSel;\n\ntypedef enum _GXIndTexMtxID {\n  GX_ITM_OFF,\n  GX_ITM_0,\n  GX_ITM_1,\n  GX_ITM_2,\n  GX_ITM_S0 = 5,\n  GX_ITM_S1,\n  GX_ITM_S2,\n  GX_ITM_T0 = 9,\n  GX_ITM_T1,\n  GX_ITM_T2,\n} GXIndTexMtxID;\n\ntypedef enum _GXIndTexWrap {\n  GX_ITW_OFF,\n  GX_ITW_256,\n  GX_ITW_128,\n  GX_ITW_64,\n  GX_ITW_32,\n  GX_ITW_16,\n  GX_ITW_0,\n  GX_MAX_ITWRAP,\n} GXIndTexWrap;\n\ntypedef enum _GXIndTexStageID {\n  GX_INDTEXSTAGE0,\n  GX_INDTEXSTAGE1,\n  GX_INDTEXSTAGE2,\n  GX_INDTEXSTAGE3,\n  GX_MAX_INDTEXSTAGE,\n} GXIndTexStageID;\n\ntypedef enum _GXIndTexScale {\n  GX_ITS_1,\n  GX_ITS_2,\n  GX_ITS_4,\n  GX_ITS_8,\n  GX_ITS_16,\n  GX_ITS_32,\n  GX_ITS_64,\n  GX_ITS_128,\n  GX_ITS_256,\n  GX_MAX_ITSCALE,\n} GXIndTexScale;\n\ntypedef enum _GXClipMode {\n  GX_CLIP_ENABLE = 0,\n  GX_CLIP_DISABLE = 1,\n} GXClipMode;\n\ntypedef enum _GXTlut {\n  GX_TLUT0 = 0,\n  GX_TLUT1 = 1,\n  GX_TLUT2 = 2,\n  GX_TLUT3 = 3,\n  GX_TLUT4 = 4,\n  GX_TLUT5 = 5,\n  GX_TLUT6 = 6,\n  GX_TLUT7 = 7,\n  GX_TLUT8 = 8,\n  GX_TLUT9 = 9,\n  GX_TLUT10 = 10,\n  GX_TLUT11 = 11,\n  GX_TLUT12 = 12,\n  GX_TLUT13 = 13,\n  GX_TLUT14 = 14,\n  GX_TLUT15 = 15,\n  GX_BIGTLUT0 = 16,\n  GX_BIGTLUT1 = 17,\n  GX_BIGTLUT2 = 18,\n  GX_BIGTLUT3 = 19,\n} GXTlut;\n\ntypedef enum _GXTlutFmt {\n  GX_TL_IA8,\n  GX_TL_RGB565,\n  GX_TL_RGB5A3,\n  GX_MAX_TLUTFMT,\n} GXTlutFmt;\n\ntypedef enum _GXMiscToken {\n  GX_MT_NULL = 0,\n  GX_MT_XF_FLUSH = 1,\n  GX_MT_DL_SAVE_CONTEXT = 2,\n  GX_MT_ABORT_WAIT_COPYOUT = 3,\n} GXMiscToken;\n\ntypedef enum _GXTexCacheSize {\n  GX_TEXCACHE_32K,\n  GX_TEXCACHE_128K,\n  GX_TEXCACHE_512K,\n  GX_TEXCACHE_NONE\n} GXTexCacheSize;\n\ntypedef enum _GXPerf0 {\n  GX_PERF0_VERTICES,\n  GX_PERF0_CLIP_VTX,\n  GX_PERF0_CLIP_CLKS,\n  GX_PERF0_XF_WAIT_IN,\n  GX_PERF0_XF_WAIT_OUT,\n  GX_PERF0_XF_XFRM_CLKS,\n  GX_PERF0_XF_LIT_CLKS,\n  GX_PERF0_XF_BOT_CLKS,\n  GX_PERF0_XF_REGLD_CLKS,\n  GX_PERF0_XF_REGRD_CLKS,\n  GX_PERF0_CLIP_RATIO,\n\n  GX_PERF0_TRIANGLES,\n  GX_PERF0_TRIANGLES_CULLED,\n  GX_PERF0_TRIANGLES_PASSED,\n  GX_PERF0_TRIANGLES_SCISSORED,\n  GX_PERF0_TRIANGLES_0TEX,\n  GX_PERF0_TRIANGLES_1TEX,\n  GX_PERF0_TRIANGLES_2TEX,\n  GX_PERF0_TRIANGLES_3TEX,\n  GX_PERF0_TRIANGLES_4TEX,\n  GX_PERF0_TRIANGLES_5TEX,\n  GX_PERF0_TRIANGLES_6TEX,\n  GX_PERF0_TRIANGLES_7TEX,\n  GX_PERF0_TRIANGLES_8TEX,\n  GX_PERF0_TRIANGLES_0CLR,\n  GX_PERF0_TRIANGLES_1CLR,\n  GX_PERF0_TRIANGLES_2CLR,\n\n  GX_PERF0_QUAD_0CVG,\n  GX_PERF0_QUAD_NON0CVG,\n  GX_PERF0_QUAD_1CVG,\n  GX_PERF0_QUAD_2CVG,\n  GX_PERF0_QUAD_3CVG,\n  GX_PERF0_QUAD_4CVG,\n  GX_PERF0_AVG_QUAD_CNT,\n\n  GX_PERF0_CLOCKS,\n  GX_PERF0_NONE\n\n} GXPerf0;\n\ntypedef enum _GXPerf1 {\n  GX_PERF1_TEXELS,\n  GX_PERF1_TX_IDLE,\n  GX_PERF1_TX_REGS,\n  GX_PERF1_TX_MEMSTALL,\n  GX_PERF1_TC_CHECK1_2,\n  GX_PERF1_TC_CHECK3_4,\n  GX_PERF1_TC_CHECK5_6,\n  GX_PERF1_TC_CHECK7_8,\n  GX_PERF1_TC_MISS,\n\n  GX_PERF1_VC_ELEMQ_FULL,\n  GX_PERF1_VC_MISSQ_FULL,\n  GX_PERF1_VC_MEMREQ_FULL,\n  GX_PERF1_VC_STATUS7,\n  GX_PERF1_VC_MISSREP_FULL,\n  GX_PERF1_VC_STREAMBUF_LOW,\n  GX_PERF1_VC_ALL_STALLS,\n  GX_PERF1_VERTICES,\n\n  GX_PERF1_FIFO_REQ,\n  GX_PERF1_CALL_REQ,\n  GX_PERF1_VC_MISS_REQ,\n  GX_PERF1_CP_ALL_REQ,\n\n  GX_PERF1_CLOCKS,\n  GX_PERF1_NONE\n\n} GXPerf1;\n\ntypedef enum _GXVCachePerf {\n  GX_VC_POS,\n  GX_VC_NRM,\n  GX_VC_CLR0,\n  GX_VC_CLR1,\n  GX_VC_TEX0,\n  GX_VC_TEX1,\n  GX_VC_TEX2,\n  GX_VC_TEX3,\n  GX_VC_TEX4,\n  GX_VC_TEX5,\n  GX_VC_TEX6,\n  GX_VC_TEX7,\n  GX_VC_ALL = 0xf\n\n} GXVCachePerf;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXENUM\n/* end \"dolphin/gx/GXEnum.h\" */\n/* \"include\\dolphin\\gx.h\" line 4 \"dolphin/gx/GXStruct.h\" */\n#ifndef _DOLPHIN_GXSTRUCT\n#define _DOLPHIN_GXSTRUCT\n\n/* \"include\\dolphin\\gx\\GXStruct.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n/* \"include\\dolphin\\gx\\GXStruct.h\" line 4 \"dolphin/vi.h\" */\n#ifndef _DOLPHIN_VI_H\n#define _DOLPHIN_VI_H\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif // ifdef __cplusplus\n\n/* \"include\\dolphin\\vi.h\" line 8 \"types.h\" */\n/* end \"types.h\" */\n\n#define VI_DISPLAY_PIX_SZ 2\n\n#define VI_INTERLACE 0\n#define VI_NON_INTERLACE 1\n#define VI_PROGRESSIVE 2\n\n#define VI_NTSC 0\n#define VI_PAL 1\n#define VI_MPAL 2\n#define VI_DEBUG 3\n#define VI_DEBUG_PAL 4\n#define VI_EURGB60 5\n\n#define VI_TVMODE(FMT, INT) (((FMT) << 2) + (INT))\n\ntypedef enum\n{\n    VI_TVMODE_NTSC_INT = VI_TVMODE(VI_NTSC, VI_INTERLACE),\n    VI_TVMODE_NTSC_DS = VI_TVMODE(VI_NTSC, VI_NON_INTERLACE),\n    VI_TVMODE_NTSC_PROG = VI_TVMODE(VI_NTSC, VI_PROGRESSIVE),\n\n    VI_TVMODE_PAL_INT = VI_TVMODE(VI_PAL, VI_INTERLACE),\n    VI_TVMODE_PAL_DS = VI_TVMODE(VI_PAL, VI_NON_INTERLACE),\n\n    VI_TVMODE_EURGB60_INT = VI_TVMODE(VI_EURGB60, VI_INTERLACE),\n    VI_TVMODE_EURGB60_DS = VI_TVMODE(VI_EURGB60, VI_NON_INTERLACE),\n\n    VI_TVMODE_MPAL_INT = VI_TVMODE(VI_MPAL, VI_INTERLACE),\n    VI_TVMODE_MPAL_DS = VI_TVMODE(VI_MPAL, VI_NON_INTERLACE),\n\n    VI_TVMODE_DEBUG_INT = VI_TVMODE(VI_DEBUG, VI_INTERLACE),\n\n    VI_TVMODE_DEBUG_PAL_INT = VI_TVMODE(VI_DEBUG_PAL, VI_INTERLACE),\n    VI_TVMODE_DEBUG_PAL_DS = VI_TVMODE(VI_DEBUG_PAL, VI_NON_INTERLACE)\n} VITVMode;\n\ntypedef enum\n{\n    VI_XFBMODE_SF = 0, // progressive scan\n    VI_XFBMODE_DF // interlaced\n} VIXFBMode;\n\n#define VI_FIELD_ABOVE 1\n#define VI_FIELD_BELOW 0\n\n// Maximum screen space\n#define VI_MAX_WIDTH_NTSC 720\n#define VI_MAX_HEIGHT_NTSC 480\n\n#define VI_MAX_WIDTH_PAL 720\n#define VI_MAX_HEIGHT_PAL 574\n\n#define VI_MAX_WIDTH_MPAL 720\n#define VI_MAX_HEIGHT_MPAL 480\n\n#define VI_MAX_WIDTH_EURGB60 VI_MAX_WIDTH_NTSC\n#define VI_MAX_HEIGHT_EURGB60 VI_MAX_HEIGHT_NTSC\n\n#define VI_DTV_STAT (55)\n\ntypedef void (*VIRetraceCallback)(u32 retraceCount);\n\n#define VIPadFrameBufferWidth(width) ((u16)(((u16)(width) + 15) & ~15))\n\nvoid VIInit(void);\nvoid VIFlush(void);\nvoid *VIGetNextFrameBuffer();\nvoid VIWaitForRetrace(void);\n\nvoid VIConfigure(const struct _GXRenderModeObj *rm);\nvoid VIConfigurePan(u16 PanPosX, u16 PanPosY, u16 PanSizeX, u16 PanSizeY);\nvoid VISetNextFrameBuffer(void *fb);\nvoid *VIGetCurrentFrameBuffer();\n\nVIRetraceCallback VISetPreRetraceCallback(VIRetraceCallback callback);\nVIRetraceCallback VISetPostRetraceCallback(VIRetraceCallback callback);\n\nvoid VISetBlack(BOOL black);\nu32 VIGetRetraceCount();\nu32 VIGetNextField();\nu32 VIGetCurrentLine();\nu32 VIGetTvFormat();\n\nu32 VIGetDTVStatus();\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif/* end \"dolphin/vi.h\" */\n/* \"include\\dolphin\\gx\\GXStruct.h\" line 5 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct _GXRenderModeObj {\n  VITVMode viTVmode;\n  u16 fbWidth;\n  u16 efbHeight;\n  u16 xfbHeight;\n  u16 viXOrigin;\n  u16 viYOrigin;\n  u16 viWidth;\n  u16 viHeight;\n  VIXFBMode xFBmode;\n  u8 field_rendering;\n  u8 aa;\n  u8 sample_pattern[12][2];\n  u8 vfilter[7];\n} GXRenderModeObj;\n\ntypedef struct _GXColor {\n  u8 r;\n  u8 g;\n  u8 b;\n  u8 a;\n} GXColor;\n\ntypedef struct _GXTexObj {\n  u32 dummy[8];\n} GXTexObj;\n\ntypedef struct _GXTlutObj {\n  u32 dummy[3];\n} GXTlutObj;\n\ntypedef struct _GXLightObj {\n  u32 dummy[16];\n} GXLightObj;\n\ntypedef struct _GXVtxDescList {\n  GXAttr attr;\n  GXAttrType type;\n} GXVtxDescList;\n\ntypedef struct _GXVtxAttrFmtList {\n\tGXAttr attr;\n  GXCompCnt cnt;\n  GXCompType type;\n\tu8 frac;\n} GXVtxAttrFmtList;\n\ntypedef struct _GXColorS10 {\n  s16 r;\n  s16 g;\n  s16 b;\n  s16 a;\n} GXColorS10;\n\ntypedef struct _GXTexRegion {\n  u32 dummy[4];\n} GXTexRegion;\n\ntypedef struct _GXTlutRegion {\n  u32 dummy[4];\n} GXTlutRegion;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXSTRUCT\n/* end \"dolphin/gx/GXStruct.h\" */\n\n/* \"include\\dolphin\\gx.h\" line 6 \"dolphin/gx/GXBump.h\" */\n#ifndef _DOLPHIN_GXBUMP\n#define _DOLPHIN_GXBUMP\n\n/* \"include\\dolphin\\gx\\GXBump.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXSetTevDirect(GXTevStageID tev_stage);\nvoid GXSetNumIndStages(u8 nIndStages);\nvoid GXSetIndTexMtx(GXIndTexMtxID mtx_sel, f32 offset[2][3], s8 scale_exp);\nvoid GXSetIndTexOrder(GXIndTexStageID ind_stage, GXTexCoordID tex_coord, GXTexMapID tex_map);\nvoid GXSetTevIndirect(GXTevStageID tev_stage, GXIndTexStageID ind_stage, GXIndTexFormat format,\n                      GXIndTexBiasSel bias_sel, GXIndTexMtxID matrix_sel, GXIndTexWrap wrap_s,\n                      GXIndTexWrap wrap_t, GXBool add_prev, GXBool ind_lod,\n                      GXIndTexAlphaSel alpha_sel);\nvoid GXSetTevIndWarp(GXTevStageID tev_stage, GXIndTexStageID ind_stage, GXBool signed_offsets,\n                     GXBool replace_mode, GXIndTexMtxID matrix_sel);\nvoid GXSetIndTexCoordScale(GXIndTexStageID ind_state, GXIndTexScale scale_s, GXIndTexScale scale_t);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXBUMP\n/* end \"dolphin/gx/GXBump.h\" */\n/* \"include\\dolphin\\gx.h\" line 7 \"dolphin/gx/GXCommandList.h\" */\n#ifndef _DOLPHIN_GXCOMMANDLIST\n#define _DOLPHIN_GXCOMMANDLIST\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define GX_NOP 0x00\n#define GX_DRAW_QUADS 0x80\n#define GX_DRAW_TRIANGLES 0x90\n#define GX_DRAW_TRIANGLE_STRIP 0x98\n#define GX_DRAW_TRIANGLE_FAN 0xA0\n#define GX_DRAW_LINES 0xA8\n#define GX_DRAW_LINE_STRIP 0xB0\n#define GX_DRAW_POINTS 0xB8\n\n#define GX_LOAD_BP_REG 0x61\n#define GX_LOAD_CP_REG 0x08\n#define GX_LOAD_XF_REG 0x10\n#define GX_LOAD_INDX_A 0x20\n#define GX_LOAD_INDX_B 0x28\n#define GX_LOAD_INDX_C 0x30\n#define GX_LOAD_INDX_D 0x38\n\n#define GX_CMD_CALL_DL 0x40\n#define GX_CMD_INVL_VC 0x48\n\n#define GX_OPCODE_MASK 0xF8\n#define GX_VAT_MASK 0x07\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXCOMMANDLIST\n/* end \"dolphin/gx/GXCommandList.h\" */\n/* \"include\\dolphin\\gx.h\" line 8 \"dolphin/gx/GXCull.h\" */\n#ifndef _DOLPHIN_GXCULL\n#define _DOLPHIN_GXCULL\n\n/* \"include\\dolphin\\gx\\GXCull.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXSetScissor(u32 left, u32 top, u32 wd, u32 ht);\nvoid GXSetCullMode(GXCullMode mode);\nvoid GXSetCoPlanar(GXBool enable);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXCULL\n/* end \"dolphin/gx/GXCull.h\" */\n/* \"include\\dolphin\\gx.h\" line 9 \"dolphin/gx/GXDispList.h\" */\n#ifndef _DOLPHIN_GXDISPLIST\n#define _DOLPHIN_GXDISPLIST\n\n/* \"include\\dolphin\\gx\\GXDispList.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXBeginDisplayList(void* list, u32 size);\nu32 GXEndDisplayList(void);\nvoid GXCallDisplayList(const void* list, u32 nbytes);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXDISPLIST\n/* end \"dolphin/gx/GXDispList.h\" */\n/* \"include\\dolphin\\gx.h\" line 10 \"dolphin/gx/GXDraw.h\" */\n#ifndef _DOLPHIN_GXDRAW\n#define _DOLPHIN_GXDRAW\n\n/* \"include\\dolphin\\gx\\GXDraw.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXDrawSphere(u8 numMajor, u8 numMinor);\nvoid GXDrawCylinder(u8 numEdges);\nvoid GXDrawCube();\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXDRAW\n/* end \"dolphin/gx/GXDraw.h\" */\n/* \"include\\dolphin\\gx.h\" line 11 \"dolphin/gx/GXFifo.h\" */\n#ifndef _DOLPHIN_GXFIFO\n#define _DOLPHIN_GXFIFO\n\n/* \"include\\dolphin\\gx\\GXFifo.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n  u8 pad[128];\n} GXFifoObj;\n\ntypedef void (*GXBreakPtCallback)(void);\n\nvoid GXInitFifoBase(GXFifoObj* fifo, void* base, u32 size);\nvoid GXInitFifoPtrs(GXFifoObj* fifo, void* readPtr, void* writePtr);\nvoid GXGetFifoPtrs(GXFifoObj* fifo, void** readPtr, void** writePtr);\nGXFifoObj* GXGetCPUFifo(void);\nGXFifoObj* GXGetGPFifo(void);\nvoid GXSetCPUFifo(GXFifoObj* fifo);\nvoid GXSetGPFifo(GXFifoObj* fifo);\nvoid GXSaveCPUFifo(GXFifoObj* fifo);\nvoid GXGetFifoStatus(GXFifoObj* fifo, GXBool* overhi, GXBool* underlow, u32* fifoCount,\n                     GXBool* cpu_write, GXBool* gp_read, GXBool* fifowrap);\nvoid GXGetGPStatus(GXBool* overhi, GXBool* underlow, GXBool* readIdle, GXBool* cmdIdle,\n                   GXBool* brkpt);\nvoid GXInitFifoLimits(GXFifoObj* fifo, u32 hiWaterMark, u32 loWaterMark);\nGXBreakPtCallback GXSetBreakPtCallback(GXBreakPtCallback cb);\nvoid GXEnableBreakPt(void* breakPt);\nvoid GXDisableBreakPt(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXFIFO\n/* end \"dolphin/gx/GXFifo.h\" */\n/* \"include\\dolphin\\gx.h\" line 12 \"dolphin/gx/GXFrameBuffer.h\" */\n#ifndef _DOLPHIN_GXFRAMEBUFFER\n#define _DOLPHIN_GXFRAMEBUFFER\n\n/* \"include\\dolphin\\gx\\GXFrameBuffer.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n/* \"include\\dolphin\\gx\\GXFrameBuffer.h\" line 4 \"dolphin/gx/GXStruct.h\" */\n/* end \"dolphin/gx/GXStruct.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern GXRenderModeObj GXNtsc240Ds;\nextern GXRenderModeObj GXNtsc240DsAa;\nextern GXRenderModeObj GXNtsc240Int;\nextern GXRenderModeObj GXNtsc240IntAa;\nextern GXRenderModeObj GXNtsc480IntDf;\nextern GXRenderModeObj GXNtsc480Int;\nextern GXRenderModeObj GXNtsc480IntAa;\nextern GXRenderModeObj GXNtsc480Prog;\nextern GXRenderModeObj GXNtsc480ProgSoft;\nextern GXRenderModeObj GXNtsc480ProgAa;\nextern GXRenderModeObj GXMpal240Ds;\nextern GXRenderModeObj GXMpal240DsAa;\nextern GXRenderModeObj GXMpal240Int;\nextern GXRenderModeObj GXMpal240IntAa;\nextern GXRenderModeObj GXMpal480IntDf;\nextern GXRenderModeObj GXMpal480Int;\nextern GXRenderModeObj GXMpal480IntAa;\nextern GXRenderModeObj GXPal264Ds;\nextern GXRenderModeObj GXPal264DsAa;\nextern GXRenderModeObj GXPal264Int;\nextern GXRenderModeObj GXPal264IntAa;\nextern GXRenderModeObj GXPal528IntDf;\nextern GXRenderModeObj GXPal528Int;\nextern GXRenderModeObj GXPal524IntAa;\nextern GXRenderModeObj GXEurgb60Hz240Ds;\nextern GXRenderModeObj GXEurgb60Hz240DsAa;\nextern GXRenderModeObj GXEurgb60Hz240Int;\nextern GXRenderModeObj GXEurgb60Hz240IntAa;\nextern GXRenderModeObj GXEurgb60Hz480IntDf;\nextern GXRenderModeObj GXEurgb60Hz480Int;\nextern GXRenderModeObj GXEurgb60Hz480IntAa;\n\n#define GX_MAX_Z24 0x00FFFFFF\n\nvoid GXSetCopyClear(GXColor clear_clr, u32 clear_z);\nvoid GXAdjustForOverscan(GXRenderModeObj* rmin, GXRenderModeObj* rmout, u16 hor, u16 ver);\nvoid GXCopyDisp(void* dest, GXBool clear);\nvoid GXSetDispCopyGamma(GXGamma gamma);\nvoid GXSetDispCopySrc(u16 left, u16 top, u16 wd, u16 ht);\nvoid GXSetDispCopyDst(u16 wd, u16 ht);\nf32 GXGetYScaleFactor(u16 efbHeight, u16 xfbHeight);\nu32 GXSetDispCopyYScale(f32 vscale);\nu16 GXGetNumXfbLines(u16 efbHeight, f32 yScale);\nvoid GXSetCopyFilter(GXBool aa, u8 sample_pattern[12][2], GXBool vf, u8 vfilter[7]);\nvoid GXSetPixelFmt(GXPixelFmt pix_fmt, GXZFmt16 z_fmt);\nvoid GXSetTexCopySrc(u16 left, u16 top, u16 wd, u16 ht);\nvoid GXSetTexCopyDst(u16 wd, u16 ht, GXTexFmt fmt, GXBool mipmap);\nvoid GXCopyTex(void* dest, GXBool clear);\n\nvoid GXSetCopyClamp(GXFBClamp clamp);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXFRAMEBUFFER\n/* end \"dolphin/gx/GXFrameBuffer.h\" */\n/* \"include\\dolphin\\gx.h\" line 13 \"dolphin/gx/GXGeometry.h\" */\n#ifndef _DOLPHIN_GXGEOMETRY\n#define _DOLPHIN_GXGEOMETRY\n\n/* \"include\\dolphin\\gx\\GXGeometry.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXSetVtxDesc(GXAttr attr, GXAttrType type);\nvoid GXSetVtxDescv(GXVtxDescList* list);\nvoid GXClearVtxDesc(void);\nvoid GXSetVtxAttrFmt(GXVtxFmt vtxfmt, GXAttr attr, GXCompCnt cnt, GXCompType type, u8 frac);\nvoid GXSetNumTexGens(u8 nTexGens);\nvoid GXBegin(GXPrimitive type, GXVtxFmt vtxfmt, u16 nverts);\nvoid GXSetTexCoordGen2(GXTexCoordID dst_coord, GXTexGenType func, GXTexGenSrc src_param, u32 mtx,\n                       GXBool normalize, u32 postmtx);\nvoid GXSetLineWidth(u8 width, GXTexOffset texOffsets);\nvoid GXSetPointSize(u8 pointSize, GXTexOffset texOffsets);\nvoid GXEnableTexOffsets(GXTexCoordID coord, GXBool line_enable, GXBool point_enable);\nvoid GXSetArray(GXAttr attr, const void* data, u8 stride);\nvoid GXInvalidateVtxCache(void);\n\nstatic inline void GXSetTexCoordGen(GXTexCoordID dst_coord, GXTexGenType func,\n                                    GXTexGenSrc src_param, u32 mtx) {\n  GXSetTexCoordGen2(dst_coord, func, src_param, mtx, GX_FALSE, GX_PTIDENTITY);\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXGEOMETRY\n/* end \"dolphin/gx/GXGeometry.h\" */\n/* \"include\\dolphin\\gx.h\" line 14 \"dolphin/gx/GXGet.h\" */\n#ifndef _DOLPHIN_GXGET\n#define _DOLPHIN_GXGET\n\n/* \"include\\dolphin\\gx\\GXGet.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n/* \"include\\dolphin\\gx\\GXGet.h\" line 4 \"dolphin/gx/GXStruct.h\" */\n/* end \"dolphin/gx/GXStruct.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nGXBool GXGetTexObjMipMap(const GXTexObj* obj);\nGXTexFmt GXGetTexObjFmt(const GXTexObj* obj);\nu16 GXGetTexObjHeight(const GXTexObj* obj);\nu16 GXGetTexObjWidth(const GXTexObj* obj);\nGXTexWrapMode GXGetTexObjWrapS(const GXTexObj* obj);\nGXTexWrapMode GXGetTexObjWrapT(const GXTexObj* obj);\nvoid* GXGetTexObjData(const GXTexObj* obj);\nvoid GXGetProjectionv(f32* p);\nvoid GXGetLightPos(const GXLightObj* lt_obj, f32* x, f32* y, f32* z);\nvoid GXGetLightColor(const GXLightObj* lt_obj, GXColor* color);\nvoid GXGetVtxAttrFmt(GXVtxFmt idx, GXAttr attr, GXCompCnt* compCnt, GXCompType* compType,\n                     u8* shift);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXGET\n/* end \"dolphin/gx/GXGet.h\" */\n/* \"include\\dolphin\\gx.h\" line 15 \"dolphin/gx/GXLighting.h\" */\n#ifndef _DOLPHIN_GXLIGHTING\n#define _DOLPHIN_GXLIGHTING\n\n/* \"include\\dolphin\\gx\\GXLighting.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n/* \"include\\dolphin\\gx\\GXLighting.h\" line 4 \"dolphin/gx/GXStruct.h\" */\n/* end \"dolphin/gx/GXStruct.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXSetNumChans(u8 nChans);\nvoid GXSetChanCtrl(GXChannelID chan, GXBool enable, GXColorSrc amb_src, GXColorSrc mat_src,\n                   u32 light_mask, GXDiffuseFn diff_fn, GXAttnFn attn_fn);\nvoid GXSetChanAmbColor(GXChannelID chan, GXColor amb_color);\nvoid GXSetChanMatColor(GXChannelID chan, GXColor mat_color);\n\nvoid GXInitLightSpot(GXLightObj* lt_obj, f32 cutoff, GXSpotFn spot_func);\nvoid GXInitLightDistAttn(GXLightObj* lt_obj, f32 ref_distance, f32 ref_brightness,\n                         GXDistAttnFn dist_func);\nvoid GXInitLightPos(GXLightObj* lt_obj, f32 x, f32 y, f32 z);\nvoid GXInitLightDir(GXLightObj* lt_obj, f32 nx, f32 ny, f32 nz);\nvoid GXInitLightColor(GXLightObj* lt_obj, GXColor color);\nvoid GXInitLightAttn(GXLightObj* lt_obj, f32 a0, f32 a1, f32 a2, f32 k0, f32 k1, f32 k2);\nvoid GXInitLightAttnA(GXLightObj* lt_obj, f32 a0, f32 a1, f32 a2);\nvoid GXInitLightAttnK(GXLightObj* lt_obj, f32 k0, f32 k1, f32 k2);\nvoid GXLoadLightObjImm(GXLightObj* lt_obj, GXLightID light);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXLIGHTING\n/* end \"dolphin/gx/GXLighting.h\" */\n/* \"include\\dolphin\\gx.h\" line 16 \"dolphin/gx/GXManage.h\" */\n#ifndef _DOLPHIN_GXMANAGE\n#define _DOLPHIN_GXMANAGE\n\n/* \"include\\dolphin\\gx\\GXManage.h\" line 3 \"dolphin/gx/GXFifo.h\" */\n/* end \"dolphin/gx/GXFifo.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef void (*GXDrawDoneCallback)(void);\n\nGXFifoObj* GXInit(void* base, u32 size);\nGXDrawDoneCallback GXSetDrawDoneCallback(GXDrawDoneCallback cb);\nvoid GXDrawDone(void);\nvoid GXSetDrawDone(void);\nvoid GXFlush(void);\nvoid GXPixModeSync(void);\nvoid GXSetMisc(GXMiscToken token, u32 val);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXMANAGE\n/* end \"dolphin/gx/GXManage.h\" */\n/* \"include\\dolphin\\gx.h\" line 17 \"dolphin/gx/GXMisc.h\" */\n#ifndef RVL_SDK_GX_MISC_H\n#define RVL_SDK_GX_MISC_H\n/* \"include\\dolphin\\gx\\GXMisc.h\" line 2 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n/* \"include\\dolphin\\gx\\GXMisc.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\nvoid GXSetMisc(GXMiscToken token, u32 val);\nvoid GXFlush();\nvoid GXResetWriteGatherPipe();\nvoid GXPeekARGB(u16 x, u16 y, u32 *color);\n\nvoid GXAbortFrame();\n\n#ifdef __cplusplus\n}\n#endif\n#endif/* end \"dolphin/gx/GXMisc.h\" */\n/* \"include\\dolphin\\gx.h\" line 18 \"dolphin/gx/GXPerf.h\" */\n#ifndef _DOLPHIN_GXPERF\n#define _DOLPHIN_GXPERF\n\n/* \"include\\dolphin\\gx\\GXPerf.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXReadXfRasMetric(u32* xf_wait_in, u32* xf_wait_out, u32* ras_busy, u32* clocks);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXPERF\n/* end \"dolphin/gx/GXPerf.h\" */\n/* \"include\\dolphin\\gx.h\" line 19 \"dolphin/gx/GXPixel.h\" */\n#ifndef _DOLPHIN_GXPIXEL\n#define _DOLPHIN_GXPIXEL\n\n/* \"include\\dolphin\\gx\\GXPixel.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXSetFog(GXFogType type, f32 startz, f32 endz, f32 nearz, f32 farz, GXColor color);\nvoid GXSetFogColor(GXColor color);\n// ? GXSetFogRangeAdj();\nvoid GXSetBlendMode(GXBlendMode type, GXBlendFactor src_factor, GXBlendFactor dst_factor,\n                    GXLogicOp op);\nvoid GXSetColorUpdate(GXBool update_enable);\nvoid GXSetAlphaUpdate(GXBool update_enable);\nvoid GXSetZMode(GXBool compare_enable, GXCompare func, GXBool update_enable);\nvoid GXSetZCompLoc(GXBool before_tex);\nvoid GXSetPixelFmt(GXPixelFmt pix_fmt, GXZFmt16 z_fmt);\nvoid GXSetDither(GXBool dither);\nvoid GXSetDstAlpha(GXBool enable, u8 alpha);\n// ? GXSetFieldMask();\n// ? GXSetFieldMode();\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXPIXEL\n/* end \"dolphin/gx/GXPixel.h\" */\n/* \"include\\dolphin\\gx.h\" line 20 \"dolphin/gx/GXTev.h\" */\n#ifndef _DOLPHIN_GXTEV\n#define _DOLPHIN_GXTEV\n\n/* \"include\\dolphin\\gx\\GXTev.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n/* \"include\\dolphin\\gx\\GXTev.h\" line 4 \"dolphin/gx/GXStruct.h\" */\n/* end \"dolphin/gx/GXStruct.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid GXSetTevOp(GXTevStageID id, GXTevMode mode);\nvoid GXSetTevColorIn(GXTevStageID stage, GXTevColorArg a, GXTevColorArg b, GXTevColorArg c,\n                     GXTevColorArg d);\nvoid GXSetTevAlphaIn(GXTevStageID stage, GXTevAlphaArg a, GXTevAlphaArg b, GXTevAlphaArg c,\n                     GXTevAlphaArg d);\nvoid GXSetTevColorOp(GXTevStageID stage, GXTevOp op, GXTevBias bias, GXTevScale scale, GXBool clamp,\n                     GXTevRegID out_reg);\nvoid GXSetTevAlphaOp(GXTevStageID stage, GXTevOp op, GXTevBias bias, GXTevScale scale, GXBool clamp,\n                     GXTevRegID out_reg);\nvoid GXSetTevColor(GXTevRegID id, GXColor color);\nvoid GXSetTevColorS10(GXTevRegID id, GXColorS10 color);\nvoid GXSetTevKColor(GXTevKColorID id, GXColor color);\nvoid GXSetTevKColorSel(GXTevStageID stage, GXTevKColorSel sel);\nvoid GXSetTevKAlphaSel(GXTevStageID stage, GXTevKAlphaSel sel);\nvoid GXSetTevSwapMode(GXTevStageID stage, GXTevSwapSel ras_sel, GXTevSwapSel tex_sel);\nvoid GXSetTevSwapModeTable(GXTevSwapSel table, GXTevColorChan red, GXTevColorChan green,\n                           GXTevColorChan blue, GXTevColorChan alpha);\nvoid GXSetAlphaCompare(GXCompare comp0, u8 ref0, GXAlphaOp op, GXCompare comp1, u8 ref1);\nvoid GXSetZTexture(GXZTexOp op, GXTexFmt fmt, u32 bias);\nvoid GXSetTevOrder(GXTevStageID stage, GXTexCoordID coord, GXTexMapID map, GXChannelID color);\nvoid GXSetNumTevStages(u8 nStages);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXTEV\n/* end \"dolphin/gx/GXTev.h\" */\n/* \"include\\dolphin\\gx.h\" line 21 \"dolphin/gx/GXTexture.h\" */\n#ifndef _DOLPHIN_GXTEXTURE\n#define _DOLPHIN_GXTEXTURE\n\n/* \"include\\dolphin\\gx\\GXTexture.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n/* \"include\\dolphin\\gx\\GXTexture.h\" line 4 \"dolphin/gx/GXStruct.h\" */\n/* end \"dolphin/gx/GXStruct.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef GXTexRegion* (*GXTexRegionCallback)(const GXTexObj* obj, GXTexMapID id);\n\nvoid GXInitTexObj(GXTexObj* obj, const void* data, u16 width, u16 height, u32 format,\n                  GXTexWrapMode wrapS, GXTexWrapMode wrapT, GXBool mipmap);\nvoid GXInitTexObjCI(GXTexObj* obj, const void* data, u16 width, u16 height, GXCITexFmt format,\n                    GXTexWrapMode wrapS, GXTexWrapMode wrapT, GXBool mipmap, u32 tlut);\nvoid GXInitTexObjData(GXTexObj* obj, const void* data);\nvoid GXInitTexObjLOD(GXTexObj* obj, GXTexFilter min_filt, GXTexFilter mag_filt, f32 min_lod,\n                     f32 max_lod, f32 lod_bias, GXBool bias_clamp, GXBool do_edge_lod,\n                     GXAnisotropy max_aniso);\nvoid GXLoadTexObj(GXTexObj* obj, GXTexMapID id);\nu32 GXGetTexBufferSize(u16 width, u16 height, u32 format, GXBool mipmap, u8 max_lod);\nvoid GXInvalidateTexAll();\nvoid GXInitTexObjWrapMode(GXTexObj* obj, GXTexWrapMode s, GXTexWrapMode t);\nvoid GXInitTlutObj(GXTlutObj* obj, const void* data, GXTlutFmt format, u16 entries);\nvoid GXLoadTlut(const GXTlutObj* obj, u32 idx);\nvoid GXSetTexCoordScaleManually(GXTexCoordID coord, GXBool enable, u16 ss, u16 ts);\nvoid GXInitTexCacheRegion(GXTexRegion* region, GXBool is_32b_mipmap, u32 tmem_even,\n                          GXTexCacheSize size_even, u32 tmem_odd, GXTexCacheSize size_odd);\nGXTexRegionCallback GXSetTexRegionCallback(GXTexRegionCallback callback);\nvoid GXInvalidateTexRegion(const GXTexRegion* region);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXTEXTURE\n/* end \"dolphin/gx/GXTexture.h\" */\n/* \"include\\dolphin\\gx.h\" line 22 \"dolphin/gx/GXTransform.h\" */\n#ifndef _DOLPHIN_GXTRANSFORM\n#define _DOLPHIN_GXTRANSFORM\n\n/* \"include\\dolphin\\gx\\GXTransform.h\" line 3 \"dolphin/gx/GXEnum.h\" */\n/* end \"dolphin/gx/GXEnum.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define GX_PROJECTION_SZ 7\n\nvoid GXSetProjection(f32 mtx[4][4], GXProjectionType type);\nvoid GXLoadPosMtxImm(f32 mtx[3][4], u32 id);\nvoid GXLoadNrmMtxImm(f32 mtx[3][4], u32 id);\nvoid GXLoadTexMtxImm(f32 mtx[][4], u32 id, GXTexMtxType type);\nvoid GXSetViewport(f32 left, f32 top, f32 wd, f32 ht, f32 nearz, f32 farz);\nvoid GXSetCurrentMtx(u32 id);\nvoid GXSetViewportJitter(f32 left, f32 top, f32 wd, f32 ht, f32 nearz, f32 farz, u32 field);\nvoid GXSetScissorBoxOffset(s32 x_off, s32 y_off);\nvoid GXSetClipMode(GXClipMode mode);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXTRANSFORM\n/* end \"dolphin/gx/GXTransform.h\" */\n/* \"include\\dolphin\\gx.h\" line 23 \"dolphin/gx/GXVert.h\" */\n#ifndef _DOLPHIN_GXVERT\n#define _DOLPHIN_GXVERT\n\n/* \"include\\dolphin\\gx\\GXVert.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define GXFIFO_ADDR 0xCC008000\n\ntypedef union {\n  u8 u8;\n  u16 u16;\n  u32 u32;\n  u64 u64;\n  s8 s8;\n  s16 s16;\n  s32 s32;\n  s64 s64;\n  f32 f32;\n  f64 f64;\n} PPCWGPipe;\n\n#ifdef __MWERKS__\n/*volatile*/ PPCWGPipe GXWGFifo : GXFIFO_ADDR;\n#else\n#define GXWGFifo (*(volatile PPCWGPipe*)GXFIFO_ADDR)\n#endif\n\nstatic inline void GXPosition2f32(const f32 x, const f32 y)\n{\n  GXWGFifo.f32 = x;\n  GXWGFifo.f32 = y;\n}\n\n// why is this non const? or better question, is everything else actually non const?\nstatic inline void GXPosition3s16(s16 x, s16 y, s16 z)\n{\n  GXWGFifo.s16 = x;\n  GXWGFifo.s16 = y;\n  GXWGFifo.s16 = z;\n}\n\nstatic inline void GXPosition3u16(const u16 x, const u16 y, const u16 z)\n{\n  GXWGFifo.u16 = x;\n  GXWGFifo.u16 = y;\n  GXWGFifo.u16 = z;\n}\n\nstatic inline void GXPosition3f32(const f32 x, const f32 y, const f32 z)\n{\n  GXWGFifo.f32 = x;\n  GXWGFifo.f32 = y;\n  GXWGFifo.f32 = z;\n}\n\nstatic inline void GXNormal3f32(const f32 x, const f32 y, const f32 z)\n{\n  GXWGFifo.f32 = x;\n  GXWGFifo.f32 = y;\n  GXWGFifo.f32 = z;\n}\n\nstatic inline void GXColor1u32(u32 c) { GXWGFifo.u32 = c; }\n\nstatic inline void GXColor4u8(const u8 r, const u8 g, const u8 b, const u8 a)\n{\n  GXWGFifo.u8 = r;\n  GXWGFifo.u8 = g;\n  GXWGFifo.u8 = b;\n  GXWGFifo.u8 = a;\n}\n\nstatic inline void GXTexCoord2s8(const s8 u, const s8 v)\n{\n  GXWGFifo.s8 = u;\n  GXWGFifo.s8 = v;\n}\n\nstatic inline void GXTexCoord2u8(u8 s, u8 t)\n{\n  GXWGFifo.u8 = s;\n  GXWGFifo.u8 = t;\n}\n\nstatic inline void GXPosition2u16(u16 x, u16 y)\n{\n  GXWGFifo.u16 = x;\n  GXWGFifo.u16 = y;\n}\n\nstatic inline void GXTexCoord2s16(const s16 u, const s16 v)\n{\n  GXWGFifo.s16 = u;\n  GXWGFifo.s16 = v;\n}\n\nstatic inline void GXTexCoord2u16(const u16 u, const u16 v)\n{\n  GXWGFifo.u16 = u;\n  GXWGFifo.u16 = v;\n}\n\nstatic inline void GXTexCoord2f32(const f32 u, const f32 v)\n{\n  GXWGFifo.f32 = u;\n  GXWGFifo.f32 = v;\n}\n\nstatic inline void GXEnd(void) {}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_GXVERT\n/* end \"dolphin/gx/GXVert.h\" */\n\n#endif // _DOLPHIN_GX\n/* end \"dolphin/gx.h\" */\n/* \"include\\dolphin\\os.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n// Upper words of the masks, since UIMM is only 16 bits\n#define OS_CACHED_REGION_PREFIX 0x8000\n#define OS_UNCACHED_REGION_PREFIX 0xC000\n#define OS_PHYSICAL_MASK 0x3FFF\n\n#define OS_BASE_CACHED (OS_CACHED_REGION_PREFIX << 16)\n#define OS_BASE_UNCACHED (OS_UNCACHED_REGION_PREFIX << 16)\n\n#ifdef __MWERKS__\n#define AT_ADDRESS(xyz) : (xyz)\n#else\n#define AT_ADDRESS\n#endif\nvolatile int __OSTVMode AT_ADDRESS(OS_BASE_CACHED | 0xCC);\nu32 __OSBusClock AT_ADDRESS(OS_BASE_CACHED | 0x00F8);  // sync with OSLoMem.h\nu32 __OSCoreClock AT_ADDRESS(OS_BASE_CACHED | 0x00FC); // sync with OSLoMem.h\n#define OS_BUS_CLOCK (u32) __OSBusClock\n#define OS_CORE_CLOCK __OSCoreClock\n#define OS_TIMER_CLOCK (OS_BUS_CLOCK / 4)\n\n#ifndef _DEBUG\n#define OSPhysicalToCached(paddr) ((void *)((u32)(paddr) + OS_BASE_CACHED))\n#define OSPhysicalToUncached(paddr) ((void *)((u32)(paddr) + OS_BASE_UNCACHED))\n#define OSCachedToPhysical(caddr) ((u32)((u8 *)(caddr)-OS_BASE_CACHED))\n#define OSUncachedToPhysical(ucaddr) ((u32)((u8 *)(ucaddr)-OS_BASE_UNCACHED))\n#define OSCachedToUncached(caddr) ((void *)((u8 *)(caddr) + (OS_BASE_UNCACHED - OS_BASE_CACHED)))\n#define OSUncachedToCached(ucaddr) ((void *)((u8 *)(ucaddr) - (OS_BASE_UNCACHED - OS_BASE_CACHED)))\n#else\nu32 OSPhysicalToCached(void *paddr);\nu32 OSPhysicalToUncached(void *paddr);\nu32 OSCachedToPhysical(void *caddr);\nu32 OSUncachedToPhysical(void *ucaddr);\nu32 OSCachedToUncached(void *caddr);\nu32 OSUncachedToCached(void *ucaddr);\n#endif\n\n#define OSTicksToCycles(ticks) (((ticks) * ((OS_CORE_CLOCK * 2) / OS_TIMER_CLOCK)) / 2)\n#define OSTicksToSeconds(ticks) ((ticks) / OS_TIMER_CLOCK)\n#define OSTicksToMilliseconds(ticks) ((ticks) / (OS_TIMER_CLOCK / 1000))\n#define OSTicksToMicroseconds(ticks) (((ticks)*8) / (OS_TIMER_CLOCK / 125000))\n#define OSTicksToNanoseconds(ticks) (((ticks)*8000) / (OS_TIMER_CLOCK / 125000))\n#define OSSecondsToTicks(sec) ((sec)*OS_TIMER_CLOCK)\n#define OSMillisecondsToTicks(msec) ((msec) * (OS_TIMER_CLOCK / 1000))\n#define OSMicrosecondsToTicks(usec) (((usec) * (OS_TIMER_CLOCK / 125000)) / 8)\n#define OSNanosecondsToTicks(nsec) (((nsec) * (OS_TIMER_CLOCK / 125000)) / 8000)\n\n#define OSDiffTick(tick1, tick0) ((s32)(tick1) - (s32)(tick0))\n\n#define OSRoundUp32B(v) ((((u32)v + 31) & ~31))\n#define OSRoundDown32B(v) (((u32)(v) & ~31))\n\nvoid *OSGetArenaHi(void);\nvoid *OSGetArenaLo(void);\nvoid OSSetArenaHi(void *newHi);\nvoid OSSetArenaLo(void *newLo);\n\nvoid *OSAllocFromArenaLo(u32 size, u32 align);\nvoid *OSAllocFromArenaHi(u32 size, u32 align);\n\nvoid OSInit();\n\n#define OS_CONSOLE_MASK 0xf0000000\n#define OS_CONSOLE_RETAIL 0x00000000\n#define OS_CONSOLE_DEVELOPMENT 0x10000000\n#define OS_CONSOLE_TDEV 0x20000000\n\n#define OS_CONSOLE_RETAIL4 0x00000004\n#define OS_CONSOLE_RETAIL3 0x00000003\n#define OS_CONSOLE_RETAIL2 0x00000002\n#define OS_CONSOLE_RETAIL1 0x00000001\n#define OS_CONSOLE_TDEVHW4 0x20000007\n#define OS_CONSOLE_TDEVHW3 0x20000006\n#define OS_CONSOLE_TDEVHW2 0x20000005\n#define OS_CONSOLE_TDEVHW1 0x20000004\n#define OS_CONSOLE_DEVHW4 0x10000007\n#define OS_CONSOLE_DEVHW3 0x10000006\n#define OS_CONSOLE_DEVHW2 0x10000005\n#define OS_CONSOLE_DEVHW1 0x10000004\n#define OS_CONSOLE_MINNOW 0x10000003\n#define OS_CONSOLE_ARTHUR 0x10000002\n#define OS_CONSOLE_PC_EMULATOR 0x10000001\n#define OS_CONSOLE_EMULATOR 0x10000000\n\nu32 OSGetConsoleType();\n\n#define OS_SOUND_MODE_MONO 0u\n#define OS_SOUND_MODE_STEREO 1u\n\nu32 OSGetSoundMode(void);\nvoid OSSetSoundMode(u32 mode);\n\n#define OS_PROGRESSIVE_MODE_OFF 0u\n#define OS_PROGRESSIVE_MODE_ON 1u\n\nu32 OSGetProgressiveMode(void);\nvoid OSSetProgressiveMode(u32 on);\n\n#define OS_LANG_ENGLISH 0u\n#define OS_LANG_GERMAN 1u\n#define OS_LANG_FRENCH 2u\n#define OS_LANG_SPANISH 3u\n#define OS_LANG_ITALIAN 4u\n#define OS_LANG_DUTCH 5u\n\nu8 OSGetLanguage(void);\nvoid OSSetLanguage(u8 language);\n\n#define OS_EURGB60_OFF 0u\n#define OS_EURGB60_ON 1u\n\nu32 OSGetEuRgb60Mode(void);\nvoid OSSetEuRgb60Mode(u32 on);\n\nvoid OSRegisterVersion(const char *id);\n\nBOOL OSDisableInterrupts(void);\nBOOL OSEnableInterrupts(void);\nBOOL OSRestoreInterrupts(BOOL level);\n\n#ifndef REGION_EU\n#define OSGetVideoMode() OSGetProgressiveMode()\n#define OSSetVideoMode(on) OSSetProgressiveMode(on)\n#else\n#define OSGetVideoMode() OSGetEuRgb60Mode()\n#define OSSetVideoMode(on) OSSetEuRgb60Mode(on)\n#endif\n\n#define OSHalt(msg) OSPanic(__FILE__, __LINE__, msg)\n\n#ifdef _DEBUG\n\n#ifndef ASSERT\n#define ASSERT(exp) (void)((exp) || (OSPanic(__FILE__, __LINE__, \"Failed assertion \" #exp), 0))\n#endif\n\n#ifndef ASSERTMSG\n#if defined(__STDC_VERSION__) && (199901L <= __STDC_VERSION__) || defined(__MWERKS__) || \\\n    defined(__SN__)\n#define ASSERTMSG(exp, ...) (void)((exp) || (OSPanic(__FILE__, __LINE__, __VA_ARGS__), 0))\n#else\n#define ASSERTMSG(exp, msg) (void)((exp) || (OSPanic(__FILE__, __LINE__, (msg)), 0))\n#endif\n#endif\n\n#ifndef ASSERTMSG1\n#define ASSERTMSG1(exp, msg, param1) \\\n  (void)((exp) || (OSPanic(__FILE__, __LINE__, (msg), (param1)), 0))\n#endif\n\n#ifndef ASSERTMSG2\n#define ASSERTMSG2(exp, msg, param1, param2) \\\n  (void)((exp) || (OSPanic(__FILE__, __LINE__, (msg), (param1), (param2)), 0))\n#endif\n\n#ifndef ASSERTMSG3\n#define ASSERTMSG3(exp, msg, param1, param2, param3) \\\n  (void)((exp) || (OSPanic(__FILE__, __LINE__, (msg), (param1), (param2), (param3)), 0))\n#endif\n\n#ifndef ASSERTMSG4\n#define ASSERTMSG4(exp, msg, param1, param2, param3, param4) \\\n  (void)((exp) || (OSPanic(__FILE__, __LINE__, (msg), (param1), (param2), (param3), (param4)), 0))\n#endif\n\n#else // _DEBUG\n\n#ifndef ASSERT\n#define ASSERT(exp) ((void)0)\n#endif\n\n#ifndef ASSERTMSG\n#if defined(__STDC_VERSION__) && (199901L <= __STDC_VERSION__) || defined(__MWERKS__) || \\\n    defined(__SN__)\n#define ASSERTMSG(exp, ...) ((void)0)\n#else\n#define ASSERTMSG(exp, msg) ((void)0)\n#endif\n#endif\n\n#ifndef ASSERTMSG1\n#define ASSERTMSG1(exp, msg, param1) ((void)0)\n#endif\n#ifndef ASSERTMSG2\n#define ASSERTMSG2(exp, msg, param1, param2) ((void)0)\n#endif\n#ifndef ASSERTMSG3\n#define ASSERTMSG3(exp, msg, param1, param2, param3) ((void)0)\n#endif\n#ifndef ASSERTMSG4\n#define ASSERTMSG4(exp, msg, param1, param2, param3, param4) ((void)0)\n#endif\n\n#endif // _DEBUG\n\nvoid OSReport(const char *msg, ...);\nvoid OSPanic(const char *file, int line, const char *msg, ...);\nvoid OSFatal(GXColor fg, GXColor bg, const char *msg);\n\n#ifdef __cplusplus\n}\n#endif\n\n/* \"include\\dolphin\\os.h\" line 213 \"dolphin/os/OSAlarm.h\" */\n#ifndef _DOLPHIN_OSALARM\n#define _DOLPHIN_OSALARM\n\n/* \"include\\dolphin\\os\\OSAlarm.h\" line 3 \"dolphin/os/OSContext.h\" */\n#ifndef _DOLPHIN_OSCONTEXT\n#define _DOLPHIN_OSCONTEXT\n\n/* \"include\\dolphin\\os\\OSContext.h\" line 3 \"types.h\" */\n#ifndef TYPES_H\n#define TYPES_H\n\n/* \"include\\types.h\" line 3 \"macros.h\" */\n#ifndef MACROS_H\n#define MACROS_H\n\n#define MAX(x, y) ((x) > (y) ? (x) : (y))\n#define MIN(x, y) ((x) < (y) ? (x) : (y))\n\n#define CLAMP(low, high, x) \\\n    ((x) > (high) ? (high) : ((x) < (low) ? (low) : (x)))\n\n#define ROUND_UP(x, align) (((x) + (align)-1) & (-(align)))\n#define ROUND_UP_PTR(x, align) \\\n    ((void *)((((u32)(x)) + (align)-1) & (~((align)-1))))\n\n#define ROUND_DOWN(x, align) ((x) & (-(align)))\n#define ROUND_DOWN_PTR(x, align) ((void *)(((u32)(x)) & (~((align)-1))))\n\n#define ARRAY_SIZE(x) (sizeof((x)) / sizeof((x)[0]))\n#define STRING_SIZE(x) (sizeof(x) - 1) // for char arrays, subtract 1 to act as null terminator?\n\n#define CLEAR_PATH(x) __memclr((x), sizeof((x)))\n\n#define ALIGN(x) __attribute__((aligned(x)))\n#define DECL_SECTION(x) __declspec(section x)\n#define DECL_WEAK __declspec(weak)\n#define DONT_INLINE __attribute__((never_inline))\n\n// Align X to the previous N bytes (N must be power of two)\n#define ALIGN_PREV(X, N) ((X) & ~((N)-1))\n// Align X to the next N bytes (N must be power of two)\n#define ALIGN_NEXT(X, N) ALIGN_PREV(((X) + (N)-1), N)\n#define IS_ALIGNED(X, N) (((X) & ((N)-1)) == 0)\n#define IS_NOT_ALIGNED(X, N) (((X) & ((N)-1)) != 0)\n\n#define READU32_BE(ptr, offset) \\\n    (((u32)ptr[offset] << 24) | ((u32)ptr[offset + 1] << 16) | ((u32)ptr[offset + 2] << 8) | (u32)ptr[offset + 3]);\n\n#define FLAG_ON(V, F) (((V) & (F)) == 0)\n#define FLAG_OFF(V, F) (((V) & (F)))\n\n// Codewarrior tricks for matching decomp\n// (Functions are given prototypes for -requireprotos)\n#ifdef __MWERKS__\n// Force BSS order\n#define CW_FORCE_BSS(module, ...)    \\\n    void fake_function(...);         \\\n    void FORCE_BSS##module##x(void); \\\n    void FORCE_BSS##module##x(void)  \\\n    {                                \\\n        fake_function(__VA_ARGS__);  \\\n    }\n// Force strings into pool\n#define CW_FORCE_STRINGS(module, ...) \\\n    void fake_function(...);          \\\n    void FORCE_STRINGS##module(void); \\\n    void FORCE_STRINGS##module(void)  \\\n    {                                 \\\n        fake_function(__VA_ARGS__);   \\\n    }\n#else\n#define CW_FORCE_BSS(module, ...)\n#define CW_FORCE_STRINGS(module, ...)\n#endif\n\n// For VSCode\n#ifdef __INTELLISENSE__\n#define asm\n#define __attribute__(x)\n#define __declspec(x)\n#endif\n\n#endif/* end \"macros.h\" */\n\ntypedef signed char s8;\ntypedef signed short s16;\ntypedef signed long s32;\ntypedef signed long long s64;\ntypedef unsigned char u8;\ntypedef unsigned short u16;\ntypedef unsigned long u32;\ntypedef unsigned long size_t;\ntypedef unsigned long long u64;\n\ntypedef unsigned short ushort;\ntypedef unsigned int uint;\n\ntypedef volatile u8 vu8;\ntypedef volatile u16 vu16;\ntypedef volatile u32 vu32;\ntypedef volatile u64 vu64;\ntypedef volatile s8 vs8;\ntypedef volatile s16 vs16;\ntypedef volatile s32 vs32;\ntypedef volatile s64 vs64;\n\ntypedef float f32;\ntypedef double f64;\ntypedef volatile f32 vf32;\ntypedef volatile f64 vf64;\n\ntypedef int BOOL;\n\ntypedef int unknown;\n\n#ifndef __cplusplus\ntypedef unsigned short wchar_t;\ntypedef wchar_t wint_t;\n#endif\n\n// Basic defines to allow newer-like C++ code to be written\n#define TRUE 1\n#define FALSE 0\n\n#define nullptr 0\n#define null 0\n\n#ifndef NULL\n#define NULL 0\n#endif\n\n#define UINT32_MAX 0xffffffff\n\n#endif // !TYPES_H/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define __OS_CONTEXT_FRAME 768\n\n#define OS_CONTEXT_R0 0\n#define OS_CONTEXT_R1 4\n#define OS_CONTEXT_R2 8\n#define OS_CONTEXT_R3 12\n#define OS_CONTEXT_R4 16\n#define OS_CONTEXT_R5 20\n#define OS_CONTEXT_R6 24\n#define OS_CONTEXT_R7 28\n#define OS_CONTEXT_R8 32\n#define OS_CONTEXT_R9 36\n#define OS_CONTEXT_R10 40\n#define OS_CONTEXT_R11 44\n#define OS_CONTEXT_R12 48\n#define OS_CONTEXT_R13 52\n#define OS_CONTEXT_R14 56\n#define OS_CONTEXT_R15 60\n#define OS_CONTEXT_R16 64\n#define OS_CONTEXT_R17 68\n#define OS_CONTEXT_R18 72\n#define OS_CONTEXT_R19 76\n#define OS_CONTEXT_R20 80\n#define OS_CONTEXT_R21 84\n#define OS_CONTEXT_R22 88\n#define OS_CONTEXT_R23 92\n#define OS_CONTEXT_R24 96\n#define OS_CONTEXT_R25 100\n#define OS_CONTEXT_R26 104\n#define OS_CONTEXT_R27 108\n#define OS_CONTEXT_R28 112\n#define OS_CONTEXT_R29 116\n#define OS_CONTEXT_R30 120\n#define OS_CONTEXT_R31 124\n\n#define OS_CONTEXT_CR 128\n#define OS_CONTEXT_LR 132\n#define OS_CONTEXT_CTR 136\n#define OS_CONTEXT_XER 140\n\n#define OS_CONTEXT_FPR0 144\n#define OS_CONTEXT_FPR1 152\n#define OS_CONTEXT_FPR2 160\n#define OS_CONTEXT_FPR3 168\n#define OS_CONTEXT_FPR4 176\n#define OS_CONTEXT_FPR5 184\n#define OS_CONTEXT_FPR6 192\n#define OS_CONTEXT_FPR7 200\n#define OS_CONTEXT_FPR8 208\n#define OS_CONTEXT_FPR9 216\n#define OS_CONTEXT_FPR10 224\n#define OS_CONTEXT_FPR11 232\n#define OS_CONTEXT_FPR12 240\n#define OS_CONTEXT_FPR13 248\n#define OS_CONTEXT_FPR14 256\n#define OS_CONTEXT_FPR15 264\n#define OS_CONTEXT_FPR16 272\n#define OS_CONTEXT_FPR17 280\n#define OS_CONTEXT_FPR18 288\n#define OS_CONTEXT_FPR19 296\n#define OS_CONTEXT_FPR20 304\n#define OS_CONTEXT_FPR21 312\n#define OS_CONTEXT_FPR22 320\n#define OS_CONTEXT_FPR23 328\n#define OS_CONTEXT_FPR24 336\n#define OS_CONTEXT_FPR25 344\n#define OS_CONTEXT_FPR26 352\n#define OS_CONTEXT_FPR27 360\n#define OS_CONTEXT_FPR28 368\n#define OS_CONTEXT_FPR29 376\n#define OS_CONTEXT_FPR30 384\n#define OS_CONTEXT_FPR31 392\n\n#define OS_CONTEXT_FPSCR 400\n\n#define OS_CONTEXT_SRR0 408\n#define OS_CONTEXT_SRR1 412\n\n#define OS_CONTEXT_MODE 416\n#define OS_CONTEXT_STATE 418\n\n#define OS_CONTEXT_GQR0 420\n#define OS_CONTEXT_GQR1 424\n#define OS_CONTEXT_GQR2 428\n#define OS_CONTEXT_GQR3 432\n#define OS_CONTEXT_GQR4 436\n#define OS_CONTEXT_GQR5 440\n#define OS_CONTEXT_GQR6 444\n#define OS_CONTEXT_GQR7 448\n#define __OSCONTEXT_PADDING 452\n\n#define OS_CONTEXT_PSF0 456\n#define OS_CONTEXT_PSF1 464\n#define OS_CONTEXT_PSF2 472\n#define OS_CONTEXT_PSF3 480\n#define OS_CONTEXT_PSF4 488\n#define OS_CONTEXT_PSF5 496\n#define OS_CONTEXT_PSF6 504\n#define OS_CONTEXT_PSF7 512\n#define OS_CONTEXT_PSF8 520\n#define OS_CONTEXT_PSF9 528\n#define OS_CONTEXT_PSF10 536\n#define OS_CONTEXT_PSF11 544\n#define OS_CONTEXT_PSF12 552\n#define OS_CONTEXT_PSF13 560\n#define OS_CONTEXT_PSF14 568\n#define OS_CONTEXT_PSF15 576\n#define OS_CONTEXT_PSF16 584\n#define OS_CONTEXT_PSF17 592\n#define OS_CONTEXT_PSF18 600\n#define OS_CONTEXT_PSF19 608\n#define OS_CONTEXT_PSF20 616\n#define OS_CONTEXT_PSF21 624\n#define OS_CONTEXT_PSF22 632\n#define OS_CONTEXT_PSF23 640\n#define OS_CONTEXT_PSF24 648\n#define OS_CONTEXT_PSF25 656\n#define OS_CONTEXT_PSF26 664\n#define OS_CONTEXT_PSF27 672\n#define OS_CONTEXT_PSF28 680\n#define OS_CONTEXT_PSF29 688\n#define OS_CONTEXT_PSF30 696\n#define OS_CONTEXT_PSF31 704\n#define OS_CONTEXT_STATE_EXC 0x02u\n\n#define OS_CONTEXT_STATE_FPSAVED 0x01u\n\ntypedef struct OSContext {\n  u32 gpr[32];\n  u32 cr;\n  u32 lr;\n  u32 ctr;\n  u32 xer;\n\n  f64 fpr[32];\n\n  u32 fpscr_pad;\n  u32 fpscr;\n\n  u32 srr0;\n  u32 srr1;\n\n  u16 mode;\n  u16 state;\n\n  u32 gqr[8];\n  u32 psf_pad;\n  f64 psf[32];\n\n} OSContext;\n\nu32 OSSaveContext(OSContext* context);\nvoid OSClearContext(OSContext* context);\nOSContext* OSGetCurrentContext();\nvoid OSSetCurrentContext(OSContext* context);\nvoid OSFillFPUContext(OSContext *context);\nu32 OSGetStackPointer();\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_OSCONTEXT\n/* end \"dolphin/os/OSContext.h\" */\n/* \"include\\dolphin\\os\\OSAlarm.h\" line 4 \"dolphin/os/OSTime.h\" */\n#ifndef _DOLPHIN_OSTIME_H\n#define _DOLPHIN_OSTIME_H\n/* \"include\\dolphin\\os\\OSTime.h\" line 2 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\ntypedef s64 OSTime;\ntypedef u32 OSTick;\n\ntypedef struct OSCalendarTime\n{\n    int sec;  // seconds after the minute [0, 61]\n    int min;  // minutes after the hour [0, 59]\n    int hour; // hours since midnight [0, 23]\n    int mday; // day of the month [1, 31]\n    int mon;  // month since January [0, 11]\n    int year; // years in AD [1, ...]\n    int wday; // days since Sunday [0, 6]\n    int yday; // days since January 1 [0, 365]\n\n    int msec; // milliseconds after the second [0,999]\n    int usec; // microseconds after the millisecond [0,999]\n} OSCalendarTime;\n\nOSTime OSGetTime(void);\nOSTick OSGetTick(void);\n\nOSTime __OSGetSystemTime(void);\nOSTime __OSTimeToSystemTime(OSTime time);\n\nvoid OSTicksToCalendarTime(OSTime time, OSCalendarTime *cal);\nOSTime OSCalendarTimeToTicks(const OSCalendarTime *cal);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n/* end \"dolphin/os/OSTime.h\" */\n/* \"include\\dolphin\\os\\OSAlarm.h\" line 5 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct OSAlarm OSAlarm;\ntypedef void (*OSAlarmHandler)(OSAlarm* alarm, OSContext* context);\n\nstruct OSAlarm {\n  OSAlarmHandler handler;\n  u32 tag;\n  OSTime fire;\n  OSAlarm* prev;\n  OSAlarm* next;\n  OSTime period;\n  OSTime start;\n};\n\nvoid OSInitAlarm(void);\nvoid OSSetAlarm(OSAlarm* alarm, OSTime tick, OSAlarmHandler handler);\nvoid OSSetAlarmTag(OSAlarm* alarm, u32 tag);\nvoid OSSetAbsAlarm(OSAlarm* alarm, OSTime time, OSAlarmHandler handler);\nvoid OSSetPeriodicAlarm(OSAlarm* alarm, OSTime start, OSTime period, OSAlarmHandler handler);\nvoid OSCreateAlarm(OSAlarm* alarm);\nvoid OSCancelAlarm(OSAlarm* alarm);\nvoid OSCancelAlarms(u32 tag);\n\nBOOL OSCheckAlarmQueue(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_OSALARM\n/* end \"dolphin/os/OSAlarm.h\" */\n/* \"include\\dolphin\\os.h\" line 214 \"dolphin/os/OSAlloc.h\" */\n#ifndef _DOLPHIN_OSALLOC\n#define _DOLPHIN_OSALLOC\n\n/* \"include\\dolphin\\os\\OSAlloc.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\ntypedef int OSHeapHandle;\ntypedef void (*OSAllocVisitor)(void* obj, u32 size);\nvoid* OSInitAlloc(void* arenaStart, void* arenaEnd, int maxHeaps);\nOSHeapHandle OSCreateHeap(void* start, void* end);\nvoid OSDestroyHeap(OSHeapHandle heap);\nvoid OSAddToHeap(OSHeapHandle heap, void* start, void* end);\nOSHeapHandle OSSetCurrentHeap(OSHeapHandle heap);\nvoid* OSAllocFromHeap(OSHeapHandle heap, u32 size);\nvoid* OSAllocFixed(void** rstart, void** rend);\nvoid OSFreeToHeap(OSHeapHandle heap, void* ptr);\nlong OSCheckHeap(OSHeapHandle heap);\nvoid OSDumpHeap(OSHeapHandle heap);\nu32 OSReferentSize(void* ptr);\nvoid OSVisitAllocated(OSAllocVisitor visitor);\nextern volatile OSHeapHandle __OSCurrHeap;\n#define OSAlloc(size) OSAllocFromHeap(__OSCurrHeap, (size))\n#define OSFree(ptr) OSFreeToHeap(__OSCurrHeap, (ptr))\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_OSALLOC\n/* end \"dolphin/os/OSAlloc.h\" */\n/* \"include\\dolphin\\os.h\" line 215 \"dolphin/os/OSArena.h\" */\n#ifndef _DOLPHIN_OSARENA\n#define _DOLPHIN_OSARENA\n\n/* \"include\\dolphin\\os\\OSArena.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nvoid* OSGetArenaHi(void);\nvoid* OSGetArenaLo(void);\nvoid OSSetArenaHi(void* addr);\nvoid OSSetArenaLo(void* addr);\nvoid* OSAllocFromArenaLo(u32 size, u32 align);\nvoid* OSAllocFromArenaLo(u32 size, u32 align);\n\n#endif // _DOLPHIN_OSARENA\n/* end \"dolphin/os/OSArena.h\" */\n/* \"include\\dolphin\\os.h\" line 216 \"dolphin/os/OSCache.h\" */\n#ifndef _DOLPHIN_OSCACHE\n#define _DOLPHIN_OSCACHE\n\n/* \"include\\dolphin\\os\\OSCache.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid DCInvalidateRange(void* addr, u32 nBytes);\nvoid DCFlushRange(void* addr, u32 nBytes);\nvoid DCStoreRange(void* addr, u32 nBytes);\nvoid DCFlushRangeNoSync(void* addr, u32 nBytes);\nvoid DCStoreRangeNoSync(void* addr, u32 nBytes);\nvoid DCZeroRange(void* addr, u32 nBytes);\nvoid DCTouchRange(void* addr, u32 nBytes);\nvoid ICInvalidateRange(void* addr, u32 nBytes);\n\n#define LC_BASE_PREFIX 0xE000\n#define LC_BASE (LC_BASE_PREFIX << 16)\n#define LCGetBase() ((void*)LC_BASE)\n\nvoid LCEnable();\nvoid LCDisable(void);\nvoid LCLoadBlocks(void* destTag, void* srcAddr, u32 numBlocks);\nvoid LCStoreBlocks(void* destAddr, void* srcTag, u32 numBlocks);\nu32 LCLoadData(void* destAddr, void* srcAddr, u32 nBytes);\nu32 LCStoreData(void* destAddr, void* srcAddr, u32 nBytes);\nu32 LCQueueLength(void);\nvoid LCQueueWait(u32 len);\nvoid LCFlushQueue(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_OSCACHE\n/* end \"dolphin/os/OSCache.h\" */\n/* \"include\\dolphin\\os.h\" line 217 \"dolphin/os/OSContext.h\" */\n/* end \"dolphin/os/OSContext.h\" */\n/* \"include\\dolphin\\os.h\" line 218 \"dolphin/os/OSError.h\" */\n#ifndef _DOLPHIN_OSERROR\n#define _DOLPHIN_OSERROR\n\n/* \"include\\dolphin\\os\\OSError.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define OS_ERROR_SYSTEM_RESET 0\n#define OS_ERROR_MACHINE_CHECK 1\n#define OS_ERROR_DSI 2\n#define OS_ERROR_ISI 3\n#define OS_ERROR_EXTERNAL_INTERRUPT 4\n#define OS_ERROR_ALIGNMENT 5\n#define OS_ERROR_PROGRAM 6\n#define OS_ERROR_FLOATING_POINT 7\n#define OS_ERROR_DECREMENTER 8\n#define OS_ERROR_SYSTEM_CALL 9\n#define OS_ERROR_TRACE 10\n#define OS_ERROR_PERFORMACE_MONITOR 11\n#define OS_ERROR_BREAKPOINT 12\n#define OS_ERROR_SYSTEM_INTERRUPT 13\n#define OS_ERROR_THERMAL_INTERRUPT 14\n#define OS_ERROR_PROTECTION 15\n#define OS_ERROR_FPE 16\n\n#define OS_ERROR_MAX (OS_ERROR_FPE + 1)\n\ntypedef u16 OSError;\ntypedef void (*OSErrorHandler)( OSError error, OSContext* context, ... );\n\nOSErrorHandler OSSetErrorHandler(OSError code, OSErrorHandler handler);\n\n// Error table.\nextern OSErrorHandler __OSErrorTable[OS_ERROR_MAX];\nextern u32 __OSFpscrEnableBits;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_OSERROR\n/* end \"dolphin/os/OSError.h\" */\n/* \"include\\dolphin\\os.h\" line 219 \"dolphin/os/OSException.h\" */\n\n#ifndef _DOLPHIN_OSEXCEPTION\n#define _DOLPHIN_OSEXCEPTION\n\n/* \"include\\dolphin\\os\\OSException.h\" line 4 \"dolphin/os/OSContext.h\" */\n/* end \"dolphin/os/OSContext.h\" */\n/* \"include\\dolphin\\os\\OSException.h\" line 5 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n#define __OS_EXCEPTION_SYSTEM_RESET         0\n#define __OS_EXCEPTION_MACHINE_CHECK        1\n#define __OS_EXCEPTION_DSI                  2\n#define __OS_EXCEPTION_ISI                  3\n#define __OS_EXCEPTION_EXTERNAL_INTERRUPT   4\n#define __OS_EXCEPTION_ALIGNMENT            5\n#define __OS_EXCEPTION_PROGRAM              6\n#define __OS_EXCEPTION_FLOATING_POINT       7\n#define __OS_EXCEPTION_DECREMENTER          8\n#define __OS_EXCEPTION_SYSTEM_CALL          9\n#define __OS_EXCEPTION_TRACE                10\n#define __OS_EXCEPTION_PERFORMACE_MONITOR   11\n#define __OS_EXCEPTION_BREAKPOINT           12\n#define __OS_EXCEPTION_SYSTEM_INTERRUPT     13\n#define __OS_EXCEPTION_THERMAL_INTERRUPT    14\n#define __OS_EXCEPTION_MAX                  \\\n        (__OS_EXCEPTION_THERMAL_INTERRUPT+1)\n\ntypedef u8 __OSException;\ntypedef void (*__OSExceptionHandler)(__OSException exception, OSContext* context);\n\n#define OS_EXCEPTION_SAVE_GPRS(context)                                                            \\\n  stw r0, OS_CONTEXT_R0(context);                                                                  \\\n  stw r1, OS_CONTEXT_R1(context);                                                                  \\\n  stw r2, OS_CONTEXT_R2(context);                                                                  \\\n  stmw r6, OS_CONTEXT_R6(context);                                                                 \\\n  mfspr r0, GQR1;                                                                                  \\\n  stw r0, OS_CONTEXT_GQR1(context);                                                                \\\n  mfspr r0, GQR2;                                                                                  \\\n  stw r0, OS_CONTEXT_GQR2(context);                                                                \\\n  mfspr r0, GQR3;                                                                                  \\\n  stw r0, OS_CONTEXT_GQR3(context);                                                                \\\n  mfspr r0, GQR4;                                                                                  \\\n  stw r0, OS_CONTEXT_GQR4(context);                                                                \\\n  mfspr r0, GQR5;                                                                                  \\\n  stw r0, OS_CONTEXT_GQR5(context);                                                                \\\n  mfspr r0, GQR6;                                                                                  \\\n  stw r0, OS_CONTEXT_GQR6(context);                                                                \\\n  mfspr r0, GQR7;                                                                                  \\\n  stw r0, OS_CONTEXT_GQR7(context);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_OSEXCEPTION\n/* end \"dolphin/os/OSException.h\" */\n/* \"include\\dolphin\\os.h\" line 220 \"dolphin/os/OSExpansion.h\" */\n#ifndef _DOLPHIN_OSEXPANSION\n#define _DOLPHIN_OSEXPANSION\n\n/* \"include\\dolphin\\os\\OSExpansion.h\" line 3 \"dolphin/os.h\" */\n/* end \"dolphin/os.h\" */\n/* \"include\\dolphin\\os\\OSExpansion.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define EXI_MEMORY_CARD_59 0x00000004\n#define EXI_MEMORY_CARD_123 0x00000008\n#define EXI_MEMORY_CARD_251 0x00000010\n#define EXI_MEMORY_CARD_507 0x00000020\n\n#define EXI_MEMORY_CARD_1019 0x00000040\n#define EXI_MEMORY_CARD_2043 0x00000080\n\n#define EXI_MEMORY_CARD_1019A 0x00000140\n#define EXI_MEMORY_CARD_1019B 0x00000240\n#define EXI_MEMORY_CARD_1019C 0x00000340\n#define EXI_MEMORY_CARD_1019D 0x00000440\n#define EXI_MEMORY_CARD_1019E 0x00000540\n#define EXI_MEMORY_CARD_1019F 0x00000640\n#define EXI_MEMORY_CARD_1019G 0x00000740\n\n#define EXI_MEMORY_CARD_2043A 0x00000180\n#define EXI_MEMORY_CARD_2043B 0x00000280\n#define EXI_MEMORY_CARD_2043C 0x00000380\n#define EXI_MEMORY_CARD_2043D 0x00000480\n#define EXI_MEMORY_CARD_2043E 0x00000580\n#define EXI_MEMORY_CARD_2043F 0x00000680\n#define EXI_MEMORY_CARD_2043G 0x00000780\n\n#define EXI_USB_ADAPTER 0x01010000\n#define EXI_NPDP_GDEV 0x01020000\n\n#define EXI_MODEM 0x02020000\n#define EXI_ETHER 0x04020200\n#define EXI_ETHER_VIEWER 0x04220001\n#define EXI_STREAM_HANGER 0x04130000\n\n#define EXI_MARLIN 0x03010000\n\n#define EXI_IS_VIEWER 0x05070000\n\n#define EXI_FREQ_1M 0\n#define EXI_FREQ_2M 1\n#define EXI_FREQ_4M 2\n#define EXI_FREQ_8M 3\n#define EXI_FREQ_16M 4\n#define EXI_FREQ_32M 5\n\n#define EXI_READ 0\n#define EXI_WRITE 1\n\n#define EXI_STATE_IDLE 0x00\n#define EXI_STATE_DMA 0x01\n#define EXI_STATE_IMM 0x02\n#define EXI_STATE_BUSY (EXI_STATE_DMA | EXI_STATE_IMM)\n#define EXI_STATE_SELECTED 0x04\n#define EXI_STATE_ATTACHED 0x08\n#define EXI_STATE_LOCKED 0x10\n\nBOOL EXIProbe(s32 chan);\ns32 EXIProbeEx(s32 chan);\n\ns32 EXIGetType(s32 chan, u32 dev, u32* type);\nchar* EXIGetTypeString(u32 type);\nu32 EXIClearInterrupts(s32 chan, BOOL exi, BOOL tc, BOOL ext);\ns32 EXIGetID(s32 chan, u32 dev, u32* id);\n\ntypedef void (*EXICallback)(s32 chan, OSContext* context);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_OSEXPANSION\n/* end \"dolphin/os/OSExpansion.h\" */\n/* \"include\\dolphin\\os.h\" line 221 \"dolphin/os/OSFastCast.h\" */\n#ifndef _DOLPHIN_OSFASTCAST\n#define _DOLPHIN_OSFASTCAST\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define OS_GQR_F32 0x0000\n#define OS_GQR_U8 0x0004\n#define OS_GQR_U16 0x0005\n#define OS_GQR_S8 0x0006\n#define OS_GQR_S16 0x0007\n\n#define OS_FASTCAST_U8 2\n#define OS_FASTCAST_U16 3\n#define OS_FASTCAST_S8 4\n#define OS_FASTCAST_S16 5\n// clang-format off\nstatic inline void OSInitFastCast(void) {\n#ifdef __MWERKS__\n  asm\n  {\n        li      r3, OS_GQR_U8\n        oris    r3, r3, OS_GQR_U8\n        mtspr   GQR2, r3\n\n        li      r3, OS_GQR_U16\n        oris    r3, r3, OS_GQR_U16\n        mtspr   GQR3, r3\n\n        li      r3, OS_GQR_S8\n        oris    r3, r3, OS_GQR_S8\n        mtspr   GQR4, r3\n\n        li      r3, OS_GQR_S16\n        oris    r3, r3, OS_GQR_S16\n        mtspr   GQR5, r3\n  }\n#else\n\n#endif\n}\n// clang-format off\n\n\nstatic inline s16 __OSf32tos16(register f32 inF)\n{\n\tregister s16 out;\n\tu32 tmp;\n\tregister u32* tmpPtr = &tmp;\n\t// clang-format off\n    asm {\n        psq_st inF, 0(tmpPtr), 0x1, OS_FASTCAST_S16\n        lha out, 0(tmpPtr)\n    }\n  // clang-format on\n\n  return out;\n}\n\nstatic inline void OSf32tos16(f32 *f, s16 *out) { *out = __OSf32tos16(*f); }\n\nstatic inline u8 __OSf32tou8(register f32 inF)\n{\n  register u8 out;\n  u32 tmp;\n  register u32 *tmpPtr = &tmp;\n  // clang-format off\n    asm {\n        psq_st inF, 0(tmpPtr), 0x1, OS_FASTCAST_U8\n        lbz out, 0(tmpPtr)\n    }\n  // clang-format on\n\n  return out;\n}\n\nstatic inline void OSf32tou8(f32 *f, u8 *out) { *out = __OSf32tou8(*f); }\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_OSFASTCAST\n/* end \"dolphin/os/OSFastCast.h\" */\n/* \"include\\dolphin\\os.h\" line 222 \"dolphin/os/OSFont.h\" */\n#ifndef _DOLPHIN_OSFONT\n#define _DOLPHIN_OSFONT\n\n/* \"include\\dolphin\\os\\OSFont.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n    typedef struct OSFontHeader\n    {\n        u16 fontType;      // _00\n        u16 firstChar;     // _02, first char code defined in font.\n        u16 lastChar;      // _04, last char code defined in font.\n        u16 invalChar;     // _06, code to sub for invalid chars.\n        u16 ascent;        // _08\n        u16 descent;       // _0A\n        u16 width;         // _0C, max width.\n        u16 leading;       // _0E\n        u16 cellWidth;     // _10\n        u16 cellHeight;    // _12\n        u32 sheetSize;     // _14\n        u16 sheetFormat;   // _18, see GX_TF_* part of GXTexFmt enum\n        u16 sheetColumn;   // _1A\n        u16 sheetRow;      // _1C\n        u16 sheetWidth;    // _1E\n        u16 sheetHeight;   // _20\n        u16 widthTable;    // _22\n        u32 sheetImage;    // _24\n        u32 sheetFullSize; // _28\n        u8 c0;             // _2C, font color components?\n        u8 c1;             // _2D\n        u8 c2;             // _2E\n        u8 c3;             // _2F\n    } OSFontHeader;\n\n#define OS_FONT_ENCODE_NULL -1\n#define OS_FONT_ENCODE_ANSI 0u\n#define OS_FONT_ENCODE_SJIS 1u\n#define OS_FONT_ENCODE_UTF8 3u  // UTF-8 [RFC 3629]\n#define OS_FONT_ENCODE_UTF16 4u // UTF-16BE [RFC 2781]\n#define OS_FONT_ENCODE_UTF32 5u // UTF-32\n#define OS_FONT_ENCODE_MAX 5u\n#define OS_FONT_ENCODE_VOID 0xffffu\n\n#define OS_FONT_PROPORTIONAL FALSE\n#define OS_FONT_FIXED TRUE\n\nu16 OSGetFontEncode(void);\nu16 OSSetFontEncode(u16 encode);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_OSFONT\n/* end \"dolphin/os/OSFont.h\" */\n/* \"include\\dolphin\\os.h\" line 223 \"dolphin/os/OSFst.h\" */\n#ifndef _DOLPHIN_OSFST_H\n#define _DOLPHIN_OSFST_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\ntypedef struct OSFstEntry\n{\n    int entryNum;\n    int nextEntryNum;\n    char *fileNameMaybe;\n} OSFstEntry;\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif/* end \"dolphin/os/OSFst.h\" */\n/* \"include\\dolphin\\os.h\" line 224 \"dolphin/os/OSInterrupt.h\" */\n#ifndef _DOLPHIN_OSINTERRUPT\n#define _DOLPHIN_OSINTERRUPT\n\n/* \"include\\dolphin\\os\\OSInterrupt.h\" line 3 \"dolphin/os/OSContext.h\" */\n/* end \"dolphin/os/OSContext.h\" */\n/* \"include\\dolphin\\os\\OSInterrupt.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define __OS_INTERRUPT_MEM_0 0\n#define __OS_INTERRUPT_MEM_1 1\n#define __OS_INTERRUPT_MEM_2 2\n#define __OS_INTERRUPT_MEM_3 3\n#define __OS_INTERRUPT_MEM_ADDRESS 4\n#define __OS_INTERRUPT_DSP_AI 5\n#define __OS_INTERRUPT_DSP_ARAM 6\n#define __OS_INTERRUPT_DSP_DSP 7\n#define __OS_INTERRUPT_AI_AI 8\n#define __OS_INTERRUPT_EXI_0_EXI 9\n#define __OS_INTERRUPT_EXI_0_TC 10\n#define __OS_INTERRUPT_EXI_0_EXT 11\n#define __OS_INTERRUPT_EXI_1_EXI 12\n#define __OS_INTERRUPT_EXI_1_TC 13\n#define __OS_INTERRUPT_EXI_1_EXT 14\n#define __OS_INTERRUPT_EXI_2_EXI 15\n#define __OS_INTERRUPT_EXI_2_TC 16\n#define __OS_INTERRUPT_PI_CP 17\n#define __OS_INTERRUPT_PI_PE_TOKEN 18\n#define __OS_INTERRUPT_PI_PE_FINISH 19\n#define __OS_INTERRUPT_PI_SI 20\n#define __OS_INTERRUPT_PI_DI 21\n#define __OS_INTERRUPT_PI_RSW 22\n#define __OS_INTERRUPT_PI_ERROR 23\n#define __OS_INTERRUPT_PI_VI 24\n#define __OS_INTERRUPT_PI_DEBUG 25\n#define __OS_INTERRUPT_PI_HSP 26\n#define __OS_INTERRUPT_MAX 32\n\n#define OS_INTERRUPTMASK(interrupt) (0x80000000u >> (interrupt))\n\n#define OS_INTERRUPTMASK_MEM_0 OS_INTERRUPTMASK(__OS_INTERRUPT_MEM_0)\n#define OS_INTERRUPTMASK_MEM_1 OS_INTERRUPTMASK(__OS_INTERRUPT_MEM_1)\n#define OS_INTERRUPTMASK_MEM_2 OS_INTERRUPTMASK(__OS_INTERRUPT_MEM_2)\n#define OS_INTERRUPTMASK_MEM_3 OS_INTERRUPTMASK(__OS_INTERRUPT_MEM_3)\n#define OS_INTERRUPTMASK_MEM_ADDRESS OS_INTERRUPTMASK(__OS_INTERRUPT_MEM_ADDRESS)\n#define OS_INTERRUPTMASK_MEM                                                                       \\\n  (OS_INTERRUPTMASK_MEM_0 | OS_INTERRUPTMASK_MEM_1 | OS_INTERRUPTMASK_MEM_2 |                      \\\n   OS_INTERRUPTMASK_MEM_3 | OS_INTERRUPTMASK_MEM_ADDRESS)\n#define OS_INTERRUPTMASK_DSP_AI OS_INTERRUPTMASK(__OS_INTERRUPT_DSP_AI)\n#define OS_INTERRUPTMASK_DSP_ARAM OS_INTERRUPTMASK(__OS_INTERRUPT_DSP_ARAM)\n#define OS_INTERRUPTMASK_DSP_DSP OS_INTERRUPTMASK(__OS_INTERRUPT_DSP_DSP)\n#define OS_INTERRUPTMASK_DSP                                                                       \\\n  (OS_INTERRUPTMASK_DSP_AI | OS_INTERRUPTMASK_DSP_ARAM | OS_INTERRUPTMASK_DSP_DSP)\n#define OS_INTERRUPTMASK_AI_AI OS_INTERRUPTMASK(__OS_INTERRUPT_AI_AI)\n#define OS_INTERRUPTMASK_AI (OS_INTERRUPTMASK_AI_AI)\n#define OS_INTERRUPTMASK_EXI_0_EXI OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_0_EXI)\n#define OS_INTERRUPTMASK_EXI_0_TC OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_0_TC)\n#define OS_INTERRUPTMASK_EXI_0_EXT OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_0_EXT)\n#define OS_INTERRUPTMASK_EXI_0                                                                     \\\n  (OS_INTERRUPTMASK_EXI_0_EXI | OS_INTERRUPTMASK_EXI_0_TC | OS_INTERRUPTMASK_EXI_0_EXT)\n#define OS_INTERRUPTMASK_EXI_1_EXI OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_1_EXI)\n#define OS_INTERRUPTMASK_EXI_1_TC OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_1_TC)\n#define OS_INTERRUPTMASK_EXI_1_EXT OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_1_EXT)\n#define OS_INTERRUPTMASK_EXI_1                                                                     \\\n  (OS_INTERRUPTMASK_EXI_1_EXI | OS_INTERRUPTMASK_EXI_1_TC | OS_INTERRUPTMASK_EXI_1_EXT)\n#define OS_INTERRUPTMASK_EXI_2_EXI OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_2_EXI)\n#define OS_INTERRUPTMASK_EXI_2_TC OS_INTERRUPTMASK(__OS_INTERRUPT_EXI_2_TC)\n#define OS_INTERRUPTMASK_EXI_2 (OS_INTERRUPTMASK_EXI_2_EXI | OS_INTERRUPTMASK_EXI_2_TC)\n#define OS_INTERRUPTMASK_EXI                                                                       \\\n  (OS_INTERRUPTMASK_EXI_0_EXI | OS_INTERRUPTMASK_EXI_0_TC | OS_INTERRUPTMASK_EXI_0_EXT |           \\\n   OS_INTERRUPTMASK_EXI_1_EXI | OS_INTERRUPTMASK_EXI_1_TC | OS_INTERRUPTMASK_EXI_1_EXT |           \\\n   OS_INTERRUPTMASK_EXI_2_EXI | OS_INTERRUPTMASK_EXI_2_TC)\n#define OS_INTERRUPTMASK_PI_PE_TOKEN OS_INTERRUPTMASK(__OS_INTERRUPT_PI_PE_TOKEN)\n#define OS_INTERRUPTMASK_PI_PE_FINISH OS_INTERRUPTMASK(__OS_INTERRUPT_PI_PE_FINISH)\n#define OS_INTERRUPTMASK_PI_PE (OS_INTERRUPTMASK_PI_PE_TOKEN | OS_INTERRUPTMASK_PI_PE_FINISH)\n#define OS_INTERRUPTMASK_PI_CP OS_INTERRUPTMASK(__OS_INTERRUPT_PI_CP)\n#define OS_INTERRUPTMASK_PI_SI OS_INTERRUPTMASK(__OS_INTERRUPT_PI_SI)\n#define OS_INTERRUPTMASK_PI_DI OS_INTERRUPTMASK(__OS_INTERRUPT_PI_DI)\n#define OS_INTERRUPTMASK_PI_RSW OS_INTERRUPTMASK(__OS_INTERRUPT_PI_RSW)\n#define OS_INTERRUPTMASK_PI_ERROR OS_INTERRUPTMASK(__OS_INTERRUPT_PI_ERROR)\n#define OS_INTERRUPTMASK_PI_VI OS_INTERRUPTMASK(__OS_INTERRUPT_PI_VI)\n#define OS_INTERRUPTMASK_PI_DEBUG OS_INTERRUPTMASK(__OS_INTERRUPT_PI_DEBUG)\n#define OS_INTERRUPTMASK_PI_HSP OS_INTERRUPTMASK(__OS_INTERRUPT_PI_HSP)\n#define OS_INTERRUPTMASK_PI                                                                        \\\n  (OS_INTERRUPTMASK_PI_CP | OS_INTERRUPTMASK_PI_SI | OS_INTERRUPTMASK_PI_DI |                      \\\n   OS_INTERRUPTMASK_PI_RSW | OS_INTERRUPTMASK_PI_ERROR | OS_INTERRUPTMASK_PI_VI |                  \\\n   OS_INTERRUPTMASK_PI_PE_TOKEN | OS_INTERRUPTMASK_PI_PE_FINISH | OS_INTERRUPTMASK_PI_DEBUG |      \\\n   OS_INTERRUPTMASK_PI_HSP)\n\ntypedef s16 __OSInterrupt;\ntypedef void (*__OSInterruptHandler)(__OSInterrupt interrupt, OSContext* context);\n\ntypedef u32 OSInterruptMask;\n\nextern volatile __OSInterrupt __OSLastInterrupt;\nextern volatile u32 __OSLastInterruptSrr0;\nextern volatile OSTime __OSLastInterruptTime;\n\n__OSInterruptHandler __OSSetInterruptHandler(__OSInterrupt interrupt, __OSInterruptHandler handler);\n\n__OSInterruptHandler __OSGetInterruptHandler(__OSInterrupt interrupt);\n\nvoid __OSDispatchInterrupt(__OSException exception, OSContext* context);\n\nOSInterruptMask OSGetInterruptMask(void);\nOSInterruptMask OSSetInterruptMask(OSInterruptMask mask);\nOSInterruptMask __OSMaskInterrupts(OSInterruptMask mask);\nOSInterruptMask __OSUnmaskInterrupts(OSInterruptMask mask);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_OSINTERRUPT\n/* end \"dolphin/os/OSInterrupt.h\" */\n/* \"include\\dolphin\\os.h\" line 225 \"dolphin/os/OSMemory.h\" */\n#ifndef _DOLPHIN_OSMEMORY\n#define _DOLPHIN_OSMEMORY\n\n/* \"include\\dolphin\\os\\OSMemory.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define OS_PROTECT_CHAN0 0\n#define OS_PROTECT_CHAN1 1\n#define OS_PROTECT_CHAN2 2\n#define OS_PROTECT_CHAN3 3\n\n#define OS_PROTECT_CONTROL_NONE 0x00\n#define OS_PROTECT_CONTROL_READ 0x01\n#define OS_PROTECT_CONTROL_WRITE 0x02\n#define OS_PROTECT_CONTROL_RDWR (OS_PROTECT_CONTROL_READ | OS_PROTECT_CONTROL_WRITE)\n\nvoid OSProtectRange(u32 chan, void* addr, u32 nBytes, u32 control);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_OSMEMORY\n/* end \"dolphin/os/OSMemory.h\" */\n/* \"include\\dolphin\\os.h\" line 226 \"dolphin/os/OSMessage.h\" */\n#ifndef _DOLPHIN_OSMESSAGE\n#define _DOLPHIN_OSMESSAGE\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* \"include\\dolphin\\os\\OSMessage.h\" line 7 \"dolphin/os/OSThread.h\" */\n#ifndef _DOLPHIN_OSTHREAD\n#define _DOLPHIN_OSTHREAD\n\n/* \"include\\dolphin\\os\\OSThread.h\" line 3 \"dolphin/os/OSContext.h\" */\n/* end \"dolphin/os/OSContext.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define OS_THREAD_SPECIFIC_MAX 2\n\ntypedef struct OSThread OSThread;\ntypedef struct OSThreadQueue OSThreadQueue;\ntypedef struct OSThreadLink OSThreadLink;\ntypedef s32 OSPriority; //  0 highest, 31 lowest\n\ntypedef struct OSMutex OSMutex;\ntypedef struct OSMutexQueue OSMutexQueue;\ntypedef struct OSMutexLink OSMutexLink;\ntypedef struct OSCond OSCond;\n\n// Idle function type.\ntypedef void (*OSIdleFunction)(void *param);\n\n// Start function.\ntypedef void *(*OSThreadStartFunction)(void *);\n\n// Thread switching function.\ntypedef void (*OSSwitchThreadCallback)(OSThread *from, OSThread *to);\n\nstruct OSThreadQueue {\n  OSThread* head;\n  OSThread* tail;\n};\n\nstruct OSThreadLink {\n  OSThread* next;\n  OSThread* prev;\n};\n\nstruct OSMutexQueue {\n  OSMutex* head;\n  OSMutex* tail;\n};\n\nstruct OSMutexLink {\n  OSMutex* next;\n  OSMutex* prev;\n};\n\nstruct OSThread {\n  OSContext context;\n  u16 state;\n  u16 attr;\n  s32 suspend;\n  OSPriority priority;\n  OSPriority base;\n  void* val;\n  OSThreadQueue* queue;\n  OSThreadLink link;\n  OSThreadQueue queueJoin;\n  OSMutex* mutex;\n  OSMutexQueue queueMutex;\n  OSThreadLink linkActive;\n  u8* stackBase;\n  u32* stackEnd;\n  s32 error;\n  void* specific[OS_THREAD_SPECIFIC_MAX];\n};\n\nenum OS_THREAD_STATE\n{\n  OS_THREAD_STATE_NULL = 0,\n  OS_THREAD_STATE_READY = 1,\n  OS_THREAD_STATE_RUNNING = 2,\n  OS_THREAD_STATE_WAITING = 4,\n  OS_THREAD_STATE_MORIBUND = 8, // set for death.\n};\n\n#define OS_THREAD_ATTR_DETACH 0x0001u\n\n#define OS_THREAD_STACK_MAGIC 0xDEADBABE\n\n#define OS_PRIORITY_MIN 0  // highest\n#define OS_PRIORITY_MAX 31 // lowest\n#define OS_PRIORITY_IDLE OS_PRIORITY_MAX\n\n//////// THREAD FUNCTIONS ////////\n// Basic thread functions.\nOSSwitchThreadCallback OSSetSwitchThreadCallback(OSSwitchThreadCallback);\nvoid OSInitThreadQueue(OSThreadQueue *queue);\nOSThread *OSGetCurrentThread();\nBOOL OSIsThreadTerminated(OSThread *thread);\n\n// Scheduler functions.\ns32 OSDisableScheduler();\ns32 OSEnableScheduler();\n\n// Thread manip functions.\nvoid OSYieldThread();\nBOOL OSCreateThread(OSThread *thread, OSThreadStartFunction func, void *param, void *stack, u32 stackSize, OSPriority prio, u16 attr);\nvoid OSExitThread(void *val);\nvoid OSCancelThread(OSThread *thread);\nvoid OSDetachThread(OSThread *thread);\ns32 OSResumeThread(OSThread *thread);\ns32 OSSuspendThread(OSThread *thread);\nvoid OSSleepThread(OSThreadQueue *queue);\nvoid OSWakeupThread(OSThreadQueue *queue);\n\nvoid OSClearStack(u8 val);\n\n// Priority functions.\nOSPriority OSGetThreadPriority(OSThread *thread);\n\n// Unused/inlined in P2.\nBOOL OSIsThreadSuspended(OSThread *thread);\nBOOL OSJoinThread(OSThread *thread, void **val);\nBOOL OSSetThreadPriority(OSThread *thread, OSPriority prio);\nOSThread *OSSetIdleFunction(OSIdleFunction idleFunc, void *param, void *stack, u32 stackSize);\nOSThread *OSGetIdleFunction();\nlong OSCheckActiveThreads();\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_OSTHREAD\n/* end \"dolphin/os/OSThread.h\" */\ntypedef struct OSMessageQueue OSMessageQueue;\ntypedef void* OSMessage;\n\nstruct OSMessageQueue {\n  OSThreadQueue queueSend;\n  OSThreadQueue queueReceive;\n  OSMessage* msgArray;\n  s32 msgCount;\n  s32 firstIndex;\n  s32 usedCount;\n};\n\n// Flags to turn blocking on/off when sending/receiving message\n#define OS_MESSAGE_NOBLOCK 0\n#define OS_MESSAGE_BLOCK 1\n\nvoid OSInitMessageQueue(OSMessageQueue* mq, OSMessage* msgArray, s32 msgCount);\nBOOL OSSendMessage(OSMessageQueue* mq, OSMessage msg, s32 flags);\nBOOL OSJamMessage(OSMessageQueue* mq, OSMessage msg, s32 flags);\nBOOL OSReceiveMessage(OSMessageQueue* mq, OSMessage* msg, s32 flags);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_OSMESSAGE\n/* end \"dolphin/os/OSMessage.h\" */\n/* \"include\\dolphin\\os.h\" line 227 \"dolphin/os/OSModule.h\" */\n#ifndef _DOLPHIN_OSMODULE\n#define _DOLPHIN_OSMODULE\n\n/* \"include\\dolphin\\os\\OSModule.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define OS_MODULE_VERSION 2\ntypedef struct OSModuleHeader OSModuleHeader;\n\ntypedef u32 OSModuleID;\ntypedef struct OSModuleQueue OSModuleQueue;\ntypedef struct OSModuleLink OSModuleLink;\ntypedef struct OSModuleInfo OSModuleInfo;\ntypedef struct OSSectionInfo OSSectionInfo;\ntypedef struct OSImportInfo OSImportInfo;\ntypedef struct OSRel OSRel;\n\nstruct OSModuleQueue {\n  OSModuleInfo* head;\n  OSModuleInfo* tail;\n};\n\nstruct OSModuleLink {\n  OSModuleInfo* next;\n  OSModuleInfo* prev;\n};\n\nstruct OSModuleInfo {\n  OSModuleID id;         // unique identifier for the module\n  OSModuleLink link;     // doubly linked list of modules\n  u32 numSections;       // # of sections\n  u32 sectionInfoOffset; // offset to section info table\n  u32 nameOffset;        // offset to module name\n  u32 nameSize;          // size of module name\n  u32 version;           // version number\n};\n\nstruct OSModuleHeader {\n  // CAUTION: info must be the 1st member\n  OSModuleInfo info;\n\n  // OS_MODULE_VERSION == 1\n  u32 bssSize; // total size of bss sections in bytes\n  u32 relOffset;\n  u32 impOffset;\n  u32 impSize;          // size in bytes\n  u8 prologSection;     // section # for prolog function\n  u8 epilogSection;     // section # for epilog function\n  u8 unresolvedSection; // section # for unresolved function\n  u8 bssSection;        // section # for bss section (set at run-time)\n  u32 prolog;           // prolog function offset\n  u32 epilog;           // epilog function offset\n  u32 unresolved;       // unresolved function offset\n\n  // OS_MODULE_VERSION == 2\n#if (2 <= OS_MODULE_VERSION)\n  u32 align;    // module alignment constraint\n  u32 bssAlign; // bss alignment constraint\n#endif\n\n  // OS_MODULE_VERSION == 3\n#if (3 <= OS_MODULE_VERSION)\n  u32 fixSize;\n#endif\n};\n\n#define OSGetSectionInfo(module) ((OSSectionInfo*)(((OSModuleInfo*)(module))->sectionInfoOffset))\n\nstruct OSSectionInfo {\n  u32 offset;\n  u32 size;\n};\n\n// OSSectionInfo.offset bit\n#define OS_SECTIONINFO_EXEC 0x1\n#define OS_SECTIONINFO_OFFSET(offset) ((offset) & ~0x1)\n\nstruct OSImportInfo {\n  OSModuleID id; // external module id\n  u32 offset;    // offset to OSRel instructions\n};\n\nstruct OSRel {\n  u16 offset; // byte offset from the previous entry\n  u8 type;\n  u8 section;\n  u32 addend;\n};\n\n#define R_DOLPHIN_NOP 201     //  C9h current offset += OSRel.offset\n#define R_DOLPHIN_SECTION 202 //  CAh current section = OSRel.section\n#define R_DOLPHIN_END 203     //  CBh\n#define R_DOLPHIN_MRKREF 204  //  CCh\n\nvoid OSSetStringTable(const void* stringTable);\nBOOL OSLink(OSModuleInfo* newModule, void* bss);\n#if (3 <= OS_MODULE_VERSION)\nBOOL OSLinkFixed(OSModuleInfo* newModule, void* bss);\n#endif\nBOOL OSUnlink(OSModuleInfo* oldModule);\n\nOSModuleInfo* OSSearchModule(void* ptr, u32* section, u32* offset);\n\n// debugger notification\nvoid OSNotifyLink(OSModuleInfo* module);\nvoid OSNotifyUnlink(OSModuleInfo* module);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_OSMODULE\n/* end \"dolphin/os/OSModule.h\" */\n/* \"include\\dolphin\\os.h\" line 228 \"dolphin/os/OSMutex.h\" */\n#ifndef _DOLPHIN_OSMUTEX\n#define _DOLPHIN_OSMUTEX\n\n/* \"include\\dolphin\\os\\OSMutex.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n/* \"include\\dolphin\\os\\OSMutex.h\" line 5 \"dolphin/os/OSThread.h\" */\n/* end \"dolphin/os/OSThread.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct OSMutex {\n  OSThreadQueue queue;\n  OSThread* thread; // the current owner\n  s32 count;        // lock count\n  OSMutexLink link; // for OSThread.queueMutex\n};\n\nstruct OSCond {\n  OSThreadQueue queue;\n};\n\nvoid OSInitMutex(OSMutex* mutex);\nvoid OSLockMutex(OSMutex* mutex);\nvoid OSUnlockMutex(OSMutex* mutex);\nBOOL OSTryLockMutex(OSMutex* mutex);\nvoid OSInitCond(OSCond* cond);\nvoid OSWaitCond(OSCond* cond, OSMutex* mutex);\nvoid OSSignalCond(OSCond* cond);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_OSMUTEX\n/* end \"dolphin/os/OSMutex.h\" */\n/* \"include\\dolphin\\os.h\" line 229 \"dolphin/os/OSReset.h\" */\n#ifndef _DOLPHIN_OSRESET\n#define _DOLPHIN_OSRESET\n\n/* \"include\\dolphin\\os\\OSReset.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define OS_RESETCODE_RESTART 0x80000000\n#define OS_RESETCODE_SYSTEM 0x40000000\n\n#define OS_RESETCODE_EXEC 0xC0000000\n#define OS_RESETCODE_NETCONFIG 0xC0010000\n\n#define OS_RESET_TIMEOUT OSMillisecondsToTicks(1000)\n\n#define OS_RESET_RESTART 0\n#define OS_RESET_HOTRESET 1\n#define OS_RESET_SHUTDOWN 2\n\n#define OS_RESET_PRIO_SO 110\n#define OS_RESET_PRIO_IP 111\n#define OS_RESET_PRIO_CARD 127\n#define OS_RESET_PRIO_PAD 127\n#define OS_RESET_PRIO_GX 127\n#define OS_RESET_PRIO_ALARM 4294967295\n\ntypedef BOOL (*OSResetFunction)(BOOL final);\ntypedef struct OSResetFunctionInfo OSResetFunctionInfo;\n\nstruct OSResetFunctionInfo {\n  // public\n  OSResetFunction func;\n  u32 priority;\n\n  // private\n  OSResetFunctionInfo* next;\n  OSResetFunctionInfo* prev;\n};\n\nvoid OSResetSystem(BOOL reset, u32 resetCode, BOOL forceMenu);\nvoid OSRegisterResetFunction(OSResetFunctionInfo *func);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_OSRESET\n/* end \"dolphin/os/OSReset.h\" */\n/* \"include\\dolphin\\os.h\" line 230 \"dolphin/os/OSResetSW.h\" */\n#ifndef _DOLPHIN_OSRESETSW\n#define _DOLPHIN_OSRESETSW\n\n/* \"include\\dolphin\\os\\OSResetSW.h\" line 3 \"dolphin/os/OSContext.h\" */\n/* end \"dolphin/os/OSContext.h\" */\n/* \"include\\dolphin\\os\\OSResetSW.h\" line 4 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef void (*OSResetCallback)(void);\n\nBOOL OSGetResetButtonState(void);\nBOOL OSGetResetSwitchState(void);\nOSResetCallback OSSetResetCallback(OSResetCallback callback);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_OSRESETSW\n/* end \"dolphin/os/OSResetSW.h\" */\n/* \"include\\dolphin\\os.h\" line 231 \"dolphin/os/OSSerial.h\" */\n#ifndef _DOLPHIN_OSSERIAL\n#define _DOLPHIN_OSSERIAL\n\n/* \"include\\dolphin\\os\\OSSerial.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define SI_MAX_CHAN 4\n#define SI_MAX_COMCSR_INLNGTH 128\n#define SI_MAX_COMCSR_OUTLNGTH 128\n#define SI_ERROR_UNDER_RUN 0x0001\n#define SI_ERROR_OVER_RUN 0x0002\n#define SI_ERROR_COLLISION 0x0004\n#define SI_ERROR_NO_RESPONSE 0x0008\n#define SI_ERROR_WRST 0x0010\n#define SI_ERROR_RDST 0x0020\n#define SI_ERROR_UNKNOWN 0x0040\n#define SI_ERROR_BUSY 0x0080\n#define SI_CHAN0 0\n#define SI_CHAN1 1\n#define SI_CHAN2 2\n#define SI_CHAN3 3\n#define SI_CHAN0_BIT 0x80000000\n#define SI_CHAN1_BIT 0x40000000\n#define SI_CHAN2_BIT 0x20000000\n#define SI_CHAN3_BIT 0x10000000\n#define SI_CHAN_BIT(chan) (SI_CHAN0_BIT >> (chan))\n#define SI_TYPE_MASK 0x18000000u\n#define SI_TYPE_N64 0x00000000u\n#define SI_TYPE_DOLPHIN 0x08000000u\n#define SI_TYPE_GC SI_TYPE_DOLPHIN\n#define SI_GC_WIRELESS 0x80000000\n#define SI_GC_NOMOTOR 0x20000000\n#define SI_GC_STANDARD 0x01000000\n#define SI_WIRELESS_RECEIVED 0x40000000\n#define SI_WIRELESS_IR 0x04000000\n#define SI_WIRELESS_STATE 0x02000000\n#define SI_WIRELESS_ORIGIN 0x00200000\n#define SI_WIRELESS_FIX_ID 0x00100000\n#define SI_WIRELESS_TYPE 0x000f0000\n#define SI_WIRELESS_LITE_MASK 0x000c0000\n#define SI_WIRELESS_LITE 0x00040000\n#define SI_WIRELESS_CONT_MASK 0x00080000\n#define SI_WIRELESS_CONT 0x00000000\n#define SI_WIRELESS_ID 0x00c0ff00\n#define SI_WIRELESS_TYPE_ID (SI_WIRELESS_TYPE | SI_WIRELESS_ID)\n#define SI_N64_CONTROLLER (SI_TYPE_N64 | 0x05000000)\n#define SI_N64_MIC (SI_TYPE_N64 | 0x00010000)\n#define SI_N64_KEYBOARD (SI_TYPE_N64 | 0x00020000)\n#define SI_N64_MOUSE (SI_TYPE_N64 | 0x02000000)\n#define SI_GBA (SI_TYPE_N64 | 0x00040000)\n#define SI_GC_CONTROLLER (SI_TYPE_GC | SI_GC_STANDARD)\n#define SI_GC_RECEIVER (SI_TYPE_GC | SI_GC_WIRELESS)\n#define SI_GC_WAVEBIRD                                                                             \\\n  (SI_TYPE_GC | SI_GC_WIRELESS | SI_GC_STANDARD | SI_WIRELESS_STATE | SI_WIRELESS_FIX_ID)\n#define SI_GC_KEYBOARD (SI_TYPE_GC | 0x00200000)\n#define SI_GC_STEERING (SI_TYPE_GC | 0x00000000)\n\nu32 SIProbe(s32 chan);\nchar* SIGetTypeString(u32 type);\nvoid SIRefreshSamplingRate(void);\nvoid SISetSamplingRate(u32 msec);\n\n#ifdef __cplusplus\n}\n#endif\n#endif // _DOLPHIN_OSSERIAL\n/* end \"dolphin/os/OSSerial.h\" */\n/* \"include\\dolphin\\os.h\" line 232 \"dolphin/os/OSThread.h\" */\n/* end \"dolphin/os/OSThread.h\" */\n/* \"include\\dolphin\\os.h\" line 233 \"dolphin/os/OSTime.h\" */\n/* end \"dolphin/os/OSTime.h\" */\n#endif // _DOLPHIN_OS/* end \"dolphin/os.h\" */\n/* \"include\\JSystem\\JKernel\\JKRHeap.h\" line 4 \"JSystem/JKernel/JKRDisposer.h\" */\n#ifndef JKRDISPOSER_H\n#define JKRDISPOSER_H\n\n/* \"include\\JSystem\\JKernel\\JKRDisposer.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n/* \"include\\JSystem\\JKernel\\JKRDisposer.h\" line 5 \"JSystem/JSupport/JSUList.h\" */\n#ifndef JSULIST_H\n#define JSULIST_H\n\n/* \"include\\JSystem\\JSupport\\JSUList.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\nclass JSUPtrLink;\n\nclass JSUPtrList {\npublic:\n    JSUPtrList() {\n        initiate();\n    }\n\n    JSUPtrList(bool);\n    ~JSUPtrList();\n\n    void initiate();\n    void setFirst(JSUPtrLink *);\n    bool append(JSUPtrLink *);\n    bool prepend(JSUPtrLink *);\n    bool insert(JSUPtrLink *, JSUPtrLink *);\n    bool remove(JSUPtrLink *);\n    JSUPtrLink *getNthLink(u32 idx) const;\n\n    JSUPtrLink *getFirstLink() const { return mHead; }\n    JSUPtrLink *getLastLink() const { return mTail; }\n    u32 getNumLinks() const { return mLinkCount; }\n\n    JSUPtrLink *mHead;  // _0\n    JSUPtrLink *mTail;  // _4\n    u32 mLinkCount;     // _8\n};\n\nclass JSUPtrLink {\npublic:\n    JSUPtrLink(void *);\n    ~JSUPtrLink();\n\n    void *getObjectPtr() const { return mData; }\n    JSUPtrList *getList() const { return mPtrList; }\n    JSUPtrLink *getNext() const { return mNext; }\n    JSUPtrLink *getPrev() const { return mPrev; }\n\n    void *mData;            // _0\n    JSUPtrList *mPtrList;   // _4\n    JSUPtrLink *mPrev;      // _8\n    JSUPtrLink *mNext;      // _C\n};\n\ntemplate <class T>\nclass JSULink; // friend class? i'm C++ noob\n\ntemplate<class T>\nclass JSUList : public JSUPtrList {\npublic:\n    JSUList(bool thing) : JSUPtrList(thing)  {\n        \n    }\n    JSUList() : JSUPtrList() {\n\n    }\n\n    bool append(JSULink<T> *link) { return JSUPtrList::append((JSUPtrLink *)link); }\n    bool prepend(JSULink<T> *link) { return JSUPtrList::prepend((JSUPtrLink *)link); }\n    bool insert(JSULink<T> *before, JSULink<T> *link) { return JSUPtrList::insert((JSUPtrLink *)before, (JSUPtrLink *)link); }\n    bool remove(JSULink<T> *link) { return JSUPtrList::remove((JSUPtrLink *)link); }\n\n    JSULink<T> *getFirst() const { return (JSULink<T> *)getFirstLink(); }\n    JSULink<T> *getLast() const { return (JSULink<T> *)getLastLink(); }\n    JSULink<T> *getEnd() const { return nullptr; }\n\n    u32 getNumLinks() const { return mLinkCount; }\n};\n\ntemplate <typename T>\nclass JSUListIterator\n{\npublic:\n    JSUListIterator()\n        : mLink(nullptr)\n    {\n    }\n    JSUListIterator(JSULink<T> *link)\n        : mLink(link)\n    {\n    }\n    JSUListIterator(JSUList<T> *list)\n        : mLink(list->getFirst())\n    {\n    }\n\n    JSUListIterator<T> &operator=(JSULink<T> *link)\n    {\n        mLink = link;\n        return *this;\n    }\n\n    T *getObject() const { return mLink->getObject(); }\n\n    bool operator==(JSULink<T> const *other) const { return mLink == other; }\n    bool operator!=(JSULink<T> const *other) const { return mLink != other; }\n    bool operator==(JSUListIterator<T> const &other) const { return mLink == other.mLink; }\n    bool operator!=(JSUListIterator<T> const &other) const { return mLink != other.mLink; }\n\n    JSUListIterator<T> operator++(int)\n    {\n        JSUListIterator<T> prev = *this;\n        mLink = mLink->getNext();\n        return prev;\n    }\n\n    JSUListIterator<T> &operator++()\n    {\n        mLink = mLink->getNext();\n        return *this;\n    }\n\n    JSUListIterator<T> operator--(int)\n    {\n        JSUListIterator<T> prev = *this;\n        mLink = mLink->getPrev();\n        return prev;\n    }\n\n    JSUListIterator<T> &operator--()\n    {\n        mLink = mLink->getPrev();\n        return *this;\n    }\n\n    // Investigate where and if this actually exists\n    //T &operator*() { return *getObject(); }\n\n    T *operator->() const { return mLink->getObject(); }\n\n    // private:\n    JSULink<T> *mLink;\n};\n\ntemplate <class T>\nclass JSULink : public JSUPtrLink\n{\npublic:\n    JSULink(void *pData) : JSUPtrLink(pData)\n    {\n    }\n\n    T *getObject() const { return (T *)mData; }\n    JSUList<T> *getList() const { return (JSUList<T> *)JSUPtrLink::getList(); } // fabricated, offcial name: getSupervisor\n    JSULink<T> *getNext() const { return (JSULink<T> *)mNext; }\n    JSULink<T> *getPrev() const { return (JSULink<T> *)JSUPtrLink::getPrev(); }\n\n    ~JSULink() {\n        \n    }\n};\n\ntemplate <typename T>\nclass JSUTree : public JSUList<T>, public JSULink<T>\n{\npublic:\n    JSUTree(T *owner) : JSUList<T>(), JSULink<T>(owner) {}\n    ~JSUTree() {}\n\n    bool appendChild(JSUTree<T> *child) { return append(child); }\n    bool prependChild(JSUTree<T> *child) { return prepend(child); }\n    bool removeChild(JSUTree<T> *child) { return remove(child); }\n    bool insertChild(JSUTree<T> *before, JSUTree<T> *child) { return insert(before, child); }\n\n    JSUTree<T> *getEndChild() const { return nullptr; }\n    JSUTree<T> *getFirstChild() const { return (JSUTree<T> *)getFirstLink(); }\n    JSUTree<T> *getLastChild() const { return (JSUTree<T> *)getLastLink(); }\n    JSUTree<T> *getNextChild() const { return (JSUTree<T> *)mNext; }\n    JSUTree<T> *getPrevChild() const { return (JSUTree<T> *)mPrev; }\n    u32 getNumChildren() const { return mLinkCount; } // In TP Debug getNumLinks() gets called here, however that kills something in JKRHeap::find(inline depth?)\n    T *getObject() const { return (T *)mData; }\n    JSUTree<T> *getParent() const { return (JSUTree<T> *)mPtrList; }\n};\n\ntemplate <typename T>\nclass JSUTreeIterator\n{\npublic:\n    JSUTreeIterator() : mTree(nullptr) {}\n    JSUTreeIterator(JSUTree<T> *tree) : mTree(tree) {}\n\n    JSUTreeIterator<T> &operator=(JSUTree<T> *tree)\n    {\n        mTree = tree;\n        return *this;\n    }\n\n    T *getObject() const { return mTree->getObject(); }\n\n    bool operator==(JSUTree<T> *other) { return mTree == other; }\n\n    bool operator!=(const JSUTree<T> *other) const { return mTree != other; }\n\n    JSUTreeIterator<T> operator++(int)\n    {\n        JSUTreeIterator<T> prev = *this;\n        mTree = mTree->getNextChild();\n        return prev;\n    }\n\n    JSUTreeIterator<T> &operator++()\n    {\n        mTree = mTree->getNextChild();\n        return *this;\n    }\n\n    T &operator*() { return *getObject(); }\n\n    T *operator->() const { return mTree->getObject(); }\n\nprivate:\n    JSUTree<T> *mTree;\n};\n\n#endif /* JSULIST_H *//* end \"JSystem/JSupport/JSUList.h\" */\n\nclass JKRHeap;\n\nclass JKRDisposer\n{\npublic:\n    JKRDisposer();\n    virtual ~JKRDisposer();\npublic:\n    JKRHeap* mRootHeap; // _4\n    JSULink<JKRDisposer> mPointerLinks; // _8\n};\n\n#endif/* end \"JSystem/JKernel/JKRDisposer.h\" */\n\n/* \"include\\JSystem\\JKernel\\JKRHeap.h\" line 6 \"types.h\" */\n/* end \"types.h\" */\n\n// TODO: Add JKRExpHeap and JKRAssertHeap to here?\ntypedef void JKRHeapErrorHandler(void *, u32, int);\nclass JKRHeap : public JKRDisposer {\npublic:\n    enum EAllocMode\n    {\n        HEAPALLOC_Unk1 = 1,\n    };\n\n    struct TState\n    { // NB: this struct doesn't agree with TP's struct\n        struct TLocation\n        {\n            TLocation() : _00(nullptr), _04(-1)\n            {\n            }\n\n            void *_00; // _00\n            int _04;   // _04\n        };\n\n        struct TArgument\n        {\n            TArgument(const JKRHeap *heap, u32 p2, bool p3)\n                : mHeap((heap) ? heap : JKRHeap::sCurrentHeap), mId(p2), mIsCompareOnDestructed(p3)\n            {\n            }\n\n            const JKRHeap *mHeap;        // _00\n            u32 mId;                     // _04\n            bool mIsCompareOnDestructed; // _08\n        };\n\n        TState(const JKRHeap *heap, u32 id, bool isCompareOnDestructed)\n            : mUsedSize(0), mCheckCode(0), mArgument(heap, id, isCompareOnDestructed)\n        {\n            mArgument.mHeap->state_register(this, mArgument.mId);\n        }\n\n        TState(JKRHeap *heap)\n            : mUsedSize(0), mCheckCode(0), mArgument(heap, 0xFFFFFFFF, true)\n        {\n        }\n\n        ~TState();\n        void dump() const { mArgument.mHeap->state_dump(*this); }\n        bool isVerbose() { return bVerbose_; };\n        bool isCompareOnDestructed() const { return mArgument.mIsCompareOnDestructed; };\n        u32 getUsedSize() const { return mUsedSize; }\n        u32 getCheckCode() const { return mCheckCode; }\n        const JKRHeap *getHeap() const { return mArgument.mHeap; }\n        u32 getId() const { return mArgument.mId; }\n\n        // unused/inlined:\n        TState(const JKRHeap::TState::TArgument &arg, const JKRHeap::TState::TLocation &location);\n        TState(const JKRHeap::TState &other, bool p2);\n        TState(const JKRHeap::TState &other, const JKRHeap::TState::TLocation &location, bool p3);\n\n        static bool bVerbose_;\n\n        u32 mUsedSize;       // _00\n        u32 mCheckCode;      // _04, plausibly TLocation when combined with _00\n        u32 mBuf;            // _08\n        u8 _0C[0x4];         // _0C\n        TArgument mArgument; // _10\n        TLocation mLocation; // _1C\n    };\n\npublic:\n    JKRHeap(void *, u32, JKRHeap *, bool);\n\n    bool setErrorFlag(bool errorFlag);\n    bool isSubHeap(JKRHeap* heap) const;\n\n    /////////////// VTABLE\n    virtual ~JKRHeap();                                               // _08\n    virtual void callAllDisposer();                                   // _0C\n    virtual u32 getHeapType() = 0;                                    // _10\n    virtual bool check() = 0;                                         // _14\n    virtual bool dump_sort() { return true; }                         // _18 (weak)\n    virtual bool dump() = 0;                                          // _1C\n    virtual void do_destroy() = 0;                                    // _20\n    virtual void *do_alloc(u32, int) = 0;                             // _24\n    virtual void do_free(void *) = 0;                                 // _28\n    virtual void do_freeAll() = 0;                                    // _2C\n    virtual void do_freeTail() = 0;                                   // _30\n    virtual void do_fillFreeArea() = 0;                               // _34\n    virtual int do_resize(void *, u32) = 0;                           // _38\n    virtual int do_getSize(void *) = 0;                               // _3C\n    virtual u32 do_getFreeSize() = 0;                                 // _40\n    virtual void *do_getMaxFreeBlock() = 0;                           // _44\n    virtual u32 do_getTotalFreeSize() = 0;                            // _48\n    virtual u8 do_changeGroupID(u8) { return 0; }                     // _4C (weak)\n    virtual u8 do_getCurrentGroupId() { return 0; }                   // _50 (weak)\n    virtual void state_register(TState *, u32) const;                 // _54\n    virtual bool state_compare(const TState &, const TState &) const; // _58\n    virtual void state_dump(const TState &) const;                    // _5C\n\n    JKRHeap* becomeSystemHeap();\n    JKRHeap* becomeCurrentHeap();\n    void destroy();    \n    void *alloc(u32, int);\n    void free(void *);\n    void freeAll();\n    void freeTail();\n    void fillFreeArea();\n    int resize(void *, u32);\n\n    // ... more functions\n\n    s32 getSize(void *ptr);\n    s32 getFreeSize();\n    void *getMaxFreeBlock();\n    u32 getTotalFreeSize();\n    u8 getCurrentGroupId();\n    u8 changeGroupID(u8 newGroupId);\n    u32 getMaxAllocatableSize(int alignment);\n    JKRHeap *find(void *const) const;  // 0x80084640\n    JKRHeap *findAllHeap(void *const) const; // 0x8008492c\n    void dispose_subroutine(u32 begin, u32 end);\n    bool dispose(void *, u32); // 0x80084b9c\n    void dispose(void *, void *);        // 0x80084c2c\n    void dispose();                      // 0x80084cb8\n\n    void appendDisposer(JKRDisposer * disposer) {\n        mDisposerList.append(&disposer->mPointerLinks);\n    }\n\n    void removeDisposer(JKRDisposer * disposer) {\n        mDisposerList.remove(&disposer->mPointerLinks);\n    }\n\n    void setDebugFill(bool debugFill) { mIsDebugFill = debugFill; }\n    bool getDebugFill() const { return mIsDebugFill; }\n    void *getStartAddr() const { return (void *)mStartAddress; }\n    void *getEndAddr() const { return (void *)mEndAddress; }\n    u32 getHeapSize() const { return mHeapSize; }\n    bool getErrorFlag() const { return mErrorFlag; }\n    void callErrorHandler(JKRHeap *heap, u32 size, int alignment) {\n        if (mErrorHandler)        {\n            (*mErrorHandler)(heap, size, alignment);\n        }\n    }\n\n    // TState related\n    static u32 getState_buf_(TState *state) { return state->mBuf; } // might instead be a pointer to a next state?\n    static void setState_u32ID_(TState *state, u32 id)\n    {\n        state->mArgument.mId = id;\n    }\n    static void setState_uUsedSize_(TState *state, u32 usedSize)\n    {\n        state->mUsedSize = usedSize;\n    }\n    static void setState_u32CheckCode_(TState * state, u32 checkCode) { state->mCheckCode = checkCode; }\n\n    void lock() const {OSLockMutex(const_cast<OSMutex *>(&mMutex)); }\n    void unlock() const {OSUnlockMutex(const_cast<OSMutex*>(&mMutex)); }\n\n    JKRHeap *getParent()\n    {\n        return mHeapTree.getParent()->getObject();\n    }\n\n    const JSUTree<JKRHeap> &getHeapTree() {\n        return mHeapTree;\n    }\n\n    // Unused\n    void checkMemoryFilled(u8 *, u32 size, u8);\n\n    static void destroy(JKRHeap *heap); // fabricated\n    static bool initArena(char **, u32 *, int);\n    static void *alloc(u32, int, JKRHeap *);\n    static void copyMemory(void *, void *, u32);\n    static void free(void *, JKRHeap *);\n    static void state_dumpDifference(const TState &, const TState &);\n    static JKRHeap *findFromRoot(void *);\n    static JKRHeapErrorHandler *setErrorHandler(JKRHeapErrorHandler *);\n    \n    static void * getCodeStart() {\n        return mCodeStart;\n    }\n\n    static void *getCodeEnd() {\n        return mCodeEnd;\n    }\n\n    static void *getUserRamStart() {\n        return mUserRamStart;\n    }\n\n    static void *getUserRamEnd() {\n        return mUserRamEnd;\n    }\n\n    static u32 getMemorySize() {\n        return mMemorySize;\n    }\n\n    static JKRHeap * getCurrentHeap() {\n        return sCurrentHeap;\n    }\n\n    static JKRHeap *getRootHeap()    {\n        return sRootHeap;\n    }\n\n    static JKRHeap *getSystemHeap() {\n        return sSystemHeap;\n    }\n\n    static void* mCodeStart;\n    static void* mCodeEnd;\n    static void* mUserRamStart;\n    static void* mUserRamEnd;\n    static u32 mMemorySize;\n\n    static JKRHeap* sSystemHeap;\n    static JKRHeap* sCurrentHeap;\n    static JKRHeap* sRootHeap;\n\n    static bool sDefaultFillFlag;\n    static bool sDefaultFillCheckFlag;\n\n    static JKRHeapErrorHandler* mErrorHandler;\n\nprotected:\n    OSMutex mMutex;                     // _18\n    void *mStartAddress;                // _30\n    void *mEndAddress;                  // _34\n    u32 mHeapSize;                      // _38\n    bool mIsDebugFill;                    // _3C\n    u8 mFillCheckFlag;                  // _3D\n    u8 mAllocMode;                      // _3E, see EAllocMode enum\n    u8 mGroupID;                        // _3F\n    JSUTree<JKRHeap> mHeapTree;         // _40\n    JSUList<JKRDisposer> mDisposerList; // _5C\n    bool mErrorFlag;                    // _68\n    bool mInitFlag;                     // _69\n};\n\nclass JKRSolidHeap : public JKRHeap\n{\npublic:\n    struct State\n    {\n        State(State * other, u32 cnt) {\n            mCnt = cnt;\n            mSize = other->mSize;\n            _08 = other->_08;\n            _0C = other->_0C;\n            mNext = other;\n            other = this;\n        }\n        State(u32 cnt, u32 size, u8 *p3, u8 *p4, State *next)\n        {\n            mCnt = cnt;\n            mSize = size;\n            _08 = p3;\n            _0C = p4;\n            mNext = next;\n        }\n        u32 mCnt;\n        u32 mSize;\n        u8 *_08;\n        void *_0C;\n        State *mNext;\n    };\n\n    JKRSolidHeap(void *, u32, JKRHeap *, bool);\n\n    virtual ~JKRSolidHeap();                                          // _08\n    virtual u32 getHeapType() { return 'SLID'; }                      // _10 (weak)\n    virtual bool check();                                             // _14\n    virtual bool dump();                                              // _1C\n    virtual void do_destroy();                                        // _20\n    virtual void *do_alloc(u32, int);                                 // _24\n    virtual void do_free(void *);                                     // _28\n    virtual void do_freeAll();                                        // _2C\n    virtual void do_freeTail();                                       // _30\n    virtual void do_fillFreeArea();                                   // _34\n    virtual int do_resize(void *, u32);                               // _38\n    virtual int do_getSize(void *);                                   // _3C\n    virtual u32 do_getFreeSize() { return mFreeSize; }                // _40 (weak)\n    virtual void *do_getMaxFreeBlock() { return (void *)mSolidHead; } // _44 (weak)\n    virtual u32 do_getTotalFreeSize() { return getFreeSize(); }       // _48 (weak)\n    virtual void state_register(TState *, u32) const;                 // _54\n    virtual bool state_compare(const TState &, const TState &) const; // _58\n\n    s32 adjustSize();\n    void recordState(u32);\n    void restoreState(u32);\n    void *allocFromHead(u32, int);\n    void *allocFromTail(u32, int);\n\n    static JKRSolidHeap *create(u32, JKRHeap *, bool);\n\n    // TState stupidness\n    static u32 getUsedSize(JKRSolidHeap *sldHeap)\n    {\n        u32 totalFreeSize = sldHeap->getTotalFreeSize();\n        return sldHeap->mHeapSize - totalFreeSize;\n    }\n    static u32 getState_(TState *state) { return getState_buf_(state); } // might instead be a pointer to a next state?\n\n    // _00     = VTBL\n    // _00-_6C = JKRHeap\nprivate:\n    u32 mFreeSize;  // _6C\n    u8 *mSolidHead; // _70\n    u8 *mSolidTail; // _74\n    State *_78;     // _78, seems to be some linked list struct in TP\n};\n\ninline JKRSolidHeap *JKRCreateSolidHeap(size_t size, JKRHeap *heap, bool p3) {\n    return JKRSolidHeap::create(size, heap, p3);\n}\n\ninline JKRHeap * JKRGetCurrentHeap() {\n    return JKRHeap::getCurrentHeap();\n}\n\ninline JKRHeap *JKRGetSystemHeap(){\n    return JKRHeap::getSystemHeap();\n}\n\ninline JKRHeap *JKRGetRootHeap(){\n    return JKRHeap::getRootHeap();\n}\n\ninline void *JKRAllocFromSysHeap(u32 size, int alignment) {\n    return JKRHeap::getSystemHeap()->alloc(size, alignment);\n}\n\ninline void * JKRAllocFromHeap(JKRHeap * heap, u32 size, int alignment) {\n    return JKRHeap::alloc(size, alignment, heap);\n}\n\ninline void JKRFree(void * pBuf) {\n    JKRHeap::free(pBuf, nullptr);\n}\n\ninline void JKRFreeToHeap(JKRHeap *heap, void *ptr) { JKRHeap::free(ptr, heap); }\n\ninline void JKRFreeToSysHeap(void * buf) {\n    JKRHeap::getSystemHeap()->free(buf);\n}\n\nvoid JKRDefaultMemoryErrorRoutine(void *, u32, int);\n\nvoid* operator new(size_t);\nvoid *operator new(size_t, int);\nvoid* operator new(size_t, JKRHeap*, int);\ninline void *operator new(size_t, void *buf) { return buf; }\n\nvoid* operator new[](size_t);\nvoid* operator new[](size_t, int);\nvoid* operator new[](size_t, JKRHeap*, int);\n\nvoid operator delete(void*);\nvoid operator delete[](void*);\n\n#endif // !JKRHEAP_H\n/* end \"JSystem/JKernel/JKRHeap.h\" */\n/* \"include\\Inagaki\\GameAudioMain.h\" line 4 \"JSystem/JAudio/JAUSectionHeap.h\" */\n#ifndef JAUDIO_JAUSECTIONHEAP_H\n#define JAUDIO_JAUSECTIONHEAP_H\n\n/* \"include\\JSystem\\JAudio\\JAUSectionHeap.h\" line 3 \"JSystem/JAudio/Interface/JAISeqDataMgr.h\" */\n#ifndef JAUDIO_JAISEQDATAMGR_H\n#define JAUDIO_JAISEQDATAMGR_H\n\n/* \"include\\JSystem\\JAudio\\Interface\\JAISeqDataMgr.h\" line 3 \"JSystem/JAudio/Interface/JAISound.h\" */\n#ifndef JAUDIO_JAISOUND_H\n#define JAUDIO_JAISOUND_H\n\n/* \"include\\JSystem\\JAudio\\Interface\\JAISound.h\" line 3 \"JSystem/JUtility/JUTDbg.h\" */\n#ifndef _JSYSTEM_JUTILITY_JUTDBG_H\n#define _JSYSTEM_JUTILITY_JUTDBG_H\n\n// Get rid of this file?\n\n/* \"include\\JSystem\\JUtility\\JUTDbg.h\" line 5 \"JSystem/JUtility/JUTAssert.h\" */\n#ifndef JUTASSERT_H\n#define JUTASSERT_H\n\n/* \"include\\JSystem\\JUtility\\JUTAssert.h\" line 3 \"stdio.h\" */\n#ifndef _STDIO_H\n#define _STDIO_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\stdio.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"libs\\PowerPC_EABI_Support\\include\\stdio.h\" line 8 \"PowerPC_EABI_Support/MSL_C/MSL_Common/FILE_POS.h\" */\n#ifndef _MSL_FILE_POS_H\n#define _MSL_FILE_POS_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\FILE_POS.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\FILE_POS.h\" line 4 \"PowerPC_EABI_Support/MSL_C/MSL_Common/ansi_files.h\" */\n#ifndef _MSL_COMMON_ANSI_FILES_H\n#define _MSL_COMMON_ANSI_FILES_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\ansi_files.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\ntypedef unsigned long __file_handle;\ntypedef unsigned long fpos_t;\ntypedef struct _IO_FILE _IO_FILE, *P_IO_FILE;\n\n#define __ungetc_buffer_size 2\n\nenum __file_kinds { __closed_file, __disk_file, __console_file, __unavailable_file };\n\nenum __file_orientation { __unoriented, __char_oriented, __wide_oriented };\n\ntypedef struct __file_modes {\n\tu32 open_mode : 2;\n\tu32 io_mode : 3;\n\tu32 buffer_mode : 2;\n\tu32 file_kind : 3;\n\n#ifdef _MSL_WIDE_CHAR\n\tu32 file_orientation : 2;\n#endif /* _MSL_WIDE_CHAR */\n\n\tu32 binary_io : 1;\n} file_modes;\n\nenum __io_states { __neutral, __writing, __reading, __rereading };\n\ntypedef struct __file_states {\n\tu32 io_state : 3;\n\tu32 free_buffer : 1;\n\n\tu8 eof;\n\tu8 error;\n} file_states;\n\ntypedef void* __ref_con;\ntypedef void (*__idle_proc)(void);\ntypedef int (*__pos_proc)(__file_handle file, fpos_t* position, int mode, __ref_con ref_con);\ntypedef int (*__io_proc)(__file_handle file, char* buff, size_t* count, __ref_con ref_con);\ntypedef int (*__close_proc)(__file_handle file);\n\nstruct _IO_FILE {\n\t__file_handle mHandle;                           // _00\n\tfile_modes mMode;                                // _04\n\tfile_states mState;                              // _08\n\tu8 mIsDynamicallyAllocated;                      // _0C\n\tu8 mCharBuffer;                                  // _0D\n\tu8 mCharBufferOverflow;                          // _0E\n\tu8 mUngetcBuffer[__ungetc_buffer_size];          // _0F\n\twchar_t mUngetcWideBuffer[__ungetc_buffer_size]; // _12\n\tu32 mPosition;                                   // _18\n\tchar* mBuffer;                                   // _1C\n\tu32 mBufferSize;                                 // _20\n\tchar* mBufferPtr;                                // _24\n\tu32 mBufferLength;                               // _28\n\tu32 mBufferAlignment;                            // _2C\n\tu32 mBufferLength2;                              // _30\n\tu32 mBufferPosition;                             // _34\n\t__pos_proc positionFunc;                         // _38\n\t__io_proc readFunc;                              // _3C\n\t__io_proc writeFunc;                             // _40\n\t__close_proc closeFunc;                          // _44\n\t__ref_con ref_con;                               // _48\n\t_IO_FILE* mNextFile;                             // _4C\n};\n\ntypedef struct _IO_FILE FILE;\n\nextern FILE __files[4];\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\nvoid __convert_from_newlines(char *buffer, size_t *length);\n\nint fflush(FILE* __stream);\nvoid free(void*);\nint __flush_buffer(FILE* file, size_t* length);\nvoid __prep_buffer(FILE* file);\nu32 __flush_all();\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/ansi_files.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n    int fseek(FILE *stream, fpos_t offset, int whence);\n    int _fseek(FILE *stream, fpos_t offset, int whence);\n    int ftell(FILE *stream);\n    int _ftell(FILE *stream);\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/FILE_POS.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\stdio.h\" line 9 \"PowerPC_EABI_Support/MSL_C/MSL_Common/direct_io.h\" */\n#ifndef _MSL_DIRECT_IO_H\n#define _MSL_DIRECT_IO_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\direct_io.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\direct_io.h\" line 4 \"PowerPC_EABI_Support/MSL_C/MSL_Common/ansi_files.h\" */\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/ansi_files.h\" */\n\n// fread\nsize_t fwrite(const void* pPtr, size_t memb_size, size_t num_memb, FILE* pFile);\n\n#endif\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/direct_io.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\stdio.h\" line 10 \"PowerPC_EABI_Support/MSL_C/MSL_Common/file_io.h\" */\n#ifndef _MSL_FILE_IO_H\n#define _MSL_FILE_IO_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\file_io.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\file_io.h\" line 4 \"PowerPC_EABI_Support/MSL_C/MSL_Common/ansi_files.h\" */\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/ansi_files.h\" */\n\nint fclose(FILE* file);\nint fflush(FILE* file);\n\n#endif\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/file_io.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\stdio.h\" line 11 \"PowerPC_EABI_Support/MSL_C/MSL_Common/printf.h\" */\n#ifndef _MSL_PRINTF_H\n#define _MSL_PRINTF_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\printf.h\" line 3 \"stdarg.h\" */\n\n#ifndef _STDARG_H_\n#define _STDARG_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef __MWERKS__\ntypedef struct __va_list_struct \n{\n\tchar gpr;\n\tchar fpr;\n\tchar reserved[2];\n\tchar *input_arg_area;\n\tchar *reg_save_area;\n} __va_list[1];\ntypedef __va_list va_list;\n\n#ifndef __MWERKS__\nextern void __builtin_va_info(va_list*);\n#endif\n\nvoid* __va_arg(va_list v_list, unsigned char type);\n\n#define va_start(ap, fmt) ((void)fmt, __builtin_va_info(&ap))\n#define va_arg(ap, t)     (*((t*)__va_arg(ap, _var_arg_typeof(t))))\n#define va_end(ap)        (void)0\n\n#else\ntypedef __builtin_va_list va_list;\n#define va_start(v, l) __builtin_va_start(v, l)\n#define va_end(v)      __builtin_va_end(v)\n#define va_arg(v, l)   __builtin_va_arg(v, l)\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n/* end \"stdarg.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\printf.h\" line 4 \"PowerPC_EABI_Support/MSL_C/MSL_Common/file_struc.h\" */\n#ifndef _MSL_COMMON_FILE_STRUC_H\n#define _MSL_COMMON_FILE_STRUC_H\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\file_struc.h\" line 2 \"types.h\" */\n/* end \"types.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\file_struc.h\" line 3 \"PowerPC_EABI_Support/MSL_C/MSL_Common/ansi_files.h\" */\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/ansi_files.h\" */\n\n#define stdin  &(__files[0])\n#define stdout &(__files[1])\n#define stderr &(__files[2])\n\n#endif\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/file_struc.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\printf.h\" line 5 \"PowerPC_EABI_Support/MSL_C/MSL_Common/ansi_files.h\" */\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/ansi_files.h\" */\n\nvoid printf(const char*, ...);\n// printf_s\nint fprintf(FILE*, const char* format, ...);\n// fprintf_s\nint vprintf(const char*, va_list);\n// vprintf_s\n// vfprintf\n// vfprintf_s\nint vsnprintf(char*, size_t, const char*, va_list);\n// vsnprintf_s\nint vsprintf(char*, const char*, va_list);\n// vsprintf_s\nint snprintf(char*, size_t, const char*, ...);\n// snprintf_s\nint sprintf(char*, const char*, ...);\n// sprintf_s\n\n#endif\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/printf.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\stdio.h\" line 12 \"PowerPC_EABI_Support/MSL_C/MSL_Common/scanf.h\" */\n#ifndef _MSL_SCANF_H\n#define _MSL_SCANF_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\scanf.h\" line 3 \"stdarg.h\" */\n\n#ifndef _STDARG_H_\n#define _STDARG_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef __MWERKS__\ntypedef struct __va_list_struct \n{\n\tchar gpr;\n\tchar fpr;\n\tchar reserved[2];\n\tchar *input_arg_area;\n\tchar *reg_save_area;\n} __va_list[1];\ntypedef __va_list va_list;\n\n#ifndef __MWERKS__\nextern void __builtin_va_info(va_list*);\n#endif\n\nvoid* __va_arg(va_list v_list, unsigned char type);\n\n#define va_start(ap, fmt) ((void)fmt, __builtin_va_info(&ap))\n#define va_arg(ap, t)     (*((t*)__va_arg(ap, _var_arg_typeof(t))))\n#define va_end(ap)        (void)0\n\n#else\ntypedef __builtin_va_list va_list;\n#define va_start(v, l) __builtin_va_start(v, l)\n#define va_end(v)      __builtin_va_end(v)\n#define va_arg(v, l)   __builtin_va_arg(v, l)\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n/* end \"stdarg.h\" */\n\n// fscanf\n// fscanf_s\n// vscanf\n// scanf\n// scanf_s\n// vfscanf\n// vfscanf_s\nint vsscanf(const char*, const char*, va_list);\n// vsscanf_s\nint sscanf(const char*, const char*, ...);\n// sscanf_s\n\n#endif\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/scanf.h\" */\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"stdio.h\" */\n/* \"include\\JSystem\\JUtility\\JUTAssert.h\" line 4 \"dolphin/os.h\" */\n/* end \"dolphin/os.h\" */\n/* \"include\\JSystem\\JUtility\\JUTAssert.h\" line 5 \"types.h\" */\n/* end \"types.h\" */\n\nnamespace JUTAssertion\n{\n  void create();\n  void flushMessage();\n  void flushMessage_dbPrint();\n  u32 getSDevice(void);\n\n  void showAssert_f(u32 device, char const *file, int line, char const *errormsg, ...);\n  inline void showAssert(u32 device, char const *file, int line, char const *errormsg) {\n    showAssert_f(device, file, line, \"%s\", errormsg);\n  }\n\n  void setConfirmMessage(u32 device, char *file, int line, bool condition, const char *msg);\n  void setWarningMessage_f(u32 device, char *file, int line, char const *, ...);\n  inline void setWarningMessage(u32 device, char *file, int line, char const *errormsg) {\n    setWarningMessage_f(device, file, line, \"%s\", errormsg);\n  }\n\n  void setLogMessage_f(u32 device, char *file, int line, char const *fmt, ...);\n  extern \"C\"\n  {\n    void showAssert_f_va(u32 device, const char *file, int line, const char *fmt, va_list vl);\n    void setWarningMessage_f_va(u32 device, char *file, int line, const char *fmt, va_list vl);\n    void setLogMessage_f_va(u32 device, char *file, int line, const char *fmt, va_list vl);\n  }\n}\n\n#ifdef DEBUG\n// Asserts\n#define JUT_CONFIRM_MESSAGE(COND) \\\n  JUTAssertion::setConfirmMessage(JUTAssertion::getSDevice(), __FILE__, __LINE__, COND, #COND);\n\n#define JUT_WARNING(COND) \\\n  (COND) ? (void)0 : JUTAssertion::setWarningMessage(JUTAssertion::getSDevice(), __FILE__, __LINE__, #COND);\n\n#define JUT_WARNING_F(COND, ...) \\\n  (COND) ? (void)0 : JUTAssertion::setWarningMessage_f(JUTAssertion::getSDevice(), __FILE__, __LINE__, __VA_ARGS__);\n\n// how about get rid of this and pass true to JUT_WARNING_F instead?\n#define JUT_WARNING_F2(...) \\\n  JUTAssertion::setWarningMessage_f(JUTAssertion::getSDevice(), __FILE__, __LINE__, __VA_ARGS__);\n\n// perhaps \"%s\" is already added here\n#define JUT_CRITICAL_WARNING_F(...) \\\n  JUTAssertion::setWarningMessage_f(2, __FILE__, __LINE__, __VA_ARGS__);\n\n#define JUT_ASSERT(COND) \\\n  (COND) ? (void)0 : (JUTAssertion::showAssert(JUTAssertion::getSDevice(), __FILE__, __LINE__, #COND), OSHalt(\"Halt\"));\n\n#define JUT_ASSERT_F(COND, ...) \\\n  (COND) ? (void)0 : (JUTAssertion::showAssert_f(JUTAssertion::getSDevice(), __FILE__, __LINE__, __VA_ARGS__), OSHalt(\"Halt\"));\n\n// could this maybe have used __VA_ARGS__?\n#define JUT_ASSERT_MSG(COND, MSG) \\\n  (COND) ? (void)0 : (JUTAssertion::showAssert(JUTAssertion::getSDevice(), __FILE__, __LINE__, MSG), OSHalt(\"Halt\"));\n\n#define JUT_MINMAX_ASSERT(min, cur, max) \\\n  JUT_ASSERT_F((((min) <= (cur)) && ((cur) < (max))), \"range over: %d <= \" #cur \"=%d < %d\", (min), (cur), (max));\n\n// TODO: might not exist, unsigned comparisons against 0 get discarded\n#define JUT_MAX_ASSERT(cur, max) \\\n  JUT_ASSERT_F(((cur) < (max)), \"range over: %d <= \" #cur \"=%d < %d\", 0, (cur), (max));\n\n#define JUT_LOG_F(...) \\\n  JUTAssertion::setLogMessage_f(JUTAssertion::getSDevice(), __FILE__, __LINE__, __VA_ARGS__);\n\n#define JUT_REPORT_MSG(...) \\\n  OSReport(__VA_ARGS__);\n\n#else // for non debug build\n#define JUT_CONFIRM_MESSAGE(...)\n#define JUT_WARNING(...)\n#define JUT_WARNING_F(...)\n#define JUT_WARNING_F2(...) // remove condintional?\n#define JUT_CRITICAL_WARNING_F(...)\n#define JUT_ASSERT(...)\n#define JUT_ASSERT_F(...)\n#define JUT_ASSERT_MSG(...)\n#define JUT_MINMAX_ASSERT(...)\n#define JUT_MAX_ASSERT(...)\n#define JUT_LOG_F(...)\n#define JUT_REPORT_MSG(...)\n#endif\n\n#endif\n/* end \"JSystem/JUtility/JUTAssert.h\" */\n/* \"include\\JSystem\\JUtility\\JUTDbg.h\" line 6 \"JSystem/JUtility/JUTException.h\" */\n#ifndef _JSYSTEM_JUT_JUTEXCEPTION_H\n#define _JSYSTEM_JUT_JUTEXCEPTION_H\n\n/* \"include\\JSystem\\JUtility\\JUTException.h\" line 3 \"dolphin/os.h\" */\n/* end \"dolphin/os.h\" */\n/* \"include\\JSystem\\JUtility\\JUTException.h\" line 4 \"JSystem/JKernel/JKRThread.h\" */\n#ifndef _JSYSTEM_JKR_JKRTHREAD_H\n#define _JSYSTEM_JKR_JKRTHREAD_H\n\n/* \"include\\JSystem\\JKernel\\JKRThread.h\" line 3 \"dolphin/os.h\" */\n/* end \"dolphin/os.h\" */\n/* \"include\\JSystem\\JKernel\\JKRThread.h\" line 4 \"JSystem/JKernel/JKRDisposer.h\" */\n/* end \"JSystem/JKernel/JKRDisposer.h\" */\n/* \"include\\JSystem\\JKernel\\JKRThread.h\" line 5 \"JSystem/JKernel/JKRHeap.h\" */\n/* end \"JSystem/JKernel/JKRHeap.h\" */\n/* \"include\\JSystem\\JKernel\\JKRThread.h\" line 6 \"JSystem/JSupport/JSUList.h\" */\n/* end \"JSystem/JSupport/JSUList.h\" */\n/* \"include\\JSystem\\JKernel\\JKRThread.h\" line 7 \"JSystem/JUtility/JUTConsole.h\" */\n#ifndef _JUTCONSOLE_H\n#define _JUTCONSOLE_H\n\n/* \"include\\JSystem\\JUtility\\JUTConsole.h\" line 3 \"stdarg.h\" */\n\n#ifndef _STDARG_H_\n#define _STDARG_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef __MWERKS__\ntypedef struct __va_list_struct \n{\n\tchar gpr;\n\tchar fpr;\n\tchar reserved[2];\n\tchar *input_arg_area;\n\tchar *reg_save_area;\n} __va_list[1];\ntypedef __va_list va_list;\n\n#ifndef __MWERKS__\nextern void __builtin_va_info(va_list*);\n#endif\n\nvoid* __va_arg(va_list v_list, unsigned char type);\n\n#define va_start(ap, fmt) ((void)fmt, __builtin_va_info(&ap))\n#define va_arg(ap, t)     (*((t*)__va_arg(ap, _var_arg_typeof(t))))\n#define va_end(ap)        (void)0\n\n#else\ntypedef __builtin_va_list va_list;\n#define va_start(v, l) __builtin_va_start(v, l)\n#define va_end(v)      __builtin_va_end(v)\n#define va_arg(v, l)   __builtin_va_arg(v, l)\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n/* end \"stdarg.h\" */\n\n/* \"include\\JSystem\\JUtility\\JUTConsole.h\" line 5 \"JSystem/JKernel/JKRHeap.h\" */\n/* end \"JSystem/JKernel/JKRHeap.h\" */\n/* \"include\\JSystem\\JUtility\\JUTConsole.h\" line 6 \"JSystem/JUtility/JUTFont.h\" */\n#ifndef _JSYSTEM_JUT_JUTFONT_H\n#define _JSYSTEM_JUT_JUTFONT_H\n\n/* \"include\\JSystem\\JUtility\\JUTFont.h\" line 3 \"string.h\" */\n#ifndef _STRING_H\n#define _STRING_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\string.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\string.h\" line 4 \"mem.h\" */\n#ifndef _MEM_H\n#define _MEM_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\mem.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\mem.h\" line 4 \"PowerPC_EABI_Support/Runtime/__mem.h\" */\n#ifndef RUNTIME_MEM_H\n#define RUNTIME_MEM_H\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\Runtime\\__mem.h\" line 2 \"types.h\" */\n/* end \"types.h\" */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n__declspec(section \".init\") void* memcpy(void* dest, const void* src, size_t n);\n__declspec(section \".init\") void __fill_mem(void* dest, int val, size_t count);\n__declspec(section \".init\") void* memset(void* dest, int val, size_t count);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n/* end \"PowerPC_EABI_Support/Runtime/__mem.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\nint memcmp(const void*, const void*, size_t);\nvoid *__memrchr(const void *src, int val, size_t n);\nvoid *memchr(const void *src, int val, size_t n);\nvoid *memmove(void *, const void *, size_t);\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"mem.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\string.h\" line 5 \"extras.h\" */\n#ifndef _EXTRAS_H\n#define _EXTRAS_H\n/* \"libs\\PowerPC_EABI_Support\\include\\extras.h\" line 2 \"types.h\" */\n/* end \"types.h\" */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint stricmp(const char*, const char*);\nint strnicmp(const char *s1, const char *s2, int n);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n/* end \"extras.h\" */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nchar* strcpy(char*, const char*);\nchar* strncpy(char*, const char*, size_t);\n\nchar* strcat(char*, const char*);\nchar* strncat(char*, const char*, size_t);\n\nint strcmp(const char*, const char*);\nint strncmp(const char*, const char*, size_t);\nchar* strchr(const char*, int);\nchar* strstr(const char*, const char*);\nchar* strrchr(const char* str, int chr);\nsize_t strlen(const char*);\nlong strtol(const char *str, char **end, int base);\n\nint __msl_strnicmp(const char *s1, const char *s2, int n);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n/* end \"string.h\" */\n/* \"include\\JSystem\\JUtility\\JUTFont.h\" line 4 \"dolphin/gx.h\" */\n/* end \"dolphin/gx.h\" */\n/* \"include\\JSystem\\JUtility\\JUTFont.h\" line 5 \"dolphin/os.h\" */\n/* end \"dolphin/os.h\" */\n/* \"include\\JSystem\\JUtility\\JUTFont.h\" line 6 \"JSystem/JUtility/TColor.h\" */\n\n#ifndef _JSYSTEM_JUT_TCOLOR_H\n#define _JSYSTEM_JUT_TCOLOR_H\n\n/* \"include\\JSystem\\JUtility\\TColor.h\" line 4 \"types.h\" */\n/* end \"types.h\" */\n/* \"include\\JSystem\\JUtility\\TColor.h\" line 5 \"dolphin/gx.h\" */\n/* end \"dolphin/gx.h\" */\n\n#define TCOLOR_WHITE JUtility::TColor(0xFF, 0xFF, 0xFF, 0xFF)\n#define TCOLOR_BLACK JUtility::TColor(0, 0, 0, 0)\n\nnamespace JUtility\n{\n    struct TColor : public GXColor\n    {\n        TColor() { set(0xFFFFFFFF); }\n\n        TColor(u8 _r, u8 _g, u8 _b, u8 _a) { set(_r, _g, _b, _a); }\n\n        TColor(u32 u32Color) { set(u32Color); }\n\n        TColor(GXColor color) { set(color); }\n\n        TColor &operator=(const TColor &other)\n        {\n            ((GXColor *)this)->operator=(other);\n            return *this;\n        }\n\n        /** @fabricated */\n        TColor &operator=(const GXColorS10 &other)\n        {\n            r = other.r;\n            g = other.g;\n            b = other.b;\n            a = other.a;\n            return *this;\n        }\n\n        operator u32() const { return toUInt32(); }\n        u32 toUInt32() const { return *(u32 *)&r; }\n\n        void set(u8 cR, u8 cG, u8 cB, u8 cA)\n        {\n            r = cR;\n            g = cG;\n            b = cB;\n            a = cA;\n        }\n\n        void set(u32 u32Color) { *(u32 *)&r = u32Color; }\n\n        void set(GXColor gxColor) { *(GXColor *)&r = gxColor; }\n        void set(TColor color) { *this = color; }\n\n        void setRGB(u8 cR, u8 cG, u8 cB)\n        {\n            r = cR;\n            g = cG;\n            b = cB;\n        }\n\n        void setRGB(const TColor &other) { setRGB(other.r, other.g, other.b); }\n\n        void setRGBA(const TColor &other)\n        {\n            r = other.r;\n            g = other.g;\n            b = other.b;\n            a = other.a;\n        }\n\n        // _00 = GXColor (_00 = r, _01 = g, _02 = b, _03 = a)\n    };\n} // namespace JUtility\n\n#endif\n/* end \"JSystem/JUtility/TColor.h\" */\n\nstruct JKRAramBlock;\nstruct JKRHeap;\n\nstruct ResFONT;\n\nstruct JUTFont\n{\n    typedef bool (*IsLeadByte)(int);\n\n    struct TWidth\n    {\n        u8 w0;\n        u8 w1;\n\n        const TWidth &operator=(const TWidth &other)\n        {\n            w0 = other.w0;\n            w1 = other.w1;\n            return *this;\n        }\n    };\n\n    JUTFont();\n\n    virtual ~JUTFont() {}                                                // _08\n    virtual void setGX() = 0;                                            // _0C\n    virtual void setGX(JUtility::TColor, JUtility::TColor) { setGX(); }; // _10\n    virtual f32 drawChar_scale(f32, f32, f32, f32, int, bool) = 0;       // _14\n    virtual int getLeading() const = 0;                                  // _18\n    virtual int getAscent() const = 0;                                   // _1C\n    virtual int getDescent() const = 0;                                  // _20\n    virtual int getHeight() const = 0;                                   // _24\n    virtual int getWidth() const = 0;                                    // _28\n    virtual void getWidthEntry(int, JUTFont::TWidth *) const = 0;        // _2C\n    virtual int getCellWidth() const { return getWidth(); };             // _30\n    virtual int getCellHeight() const { return getHeight(); };           // _34\n    virtual int getFontType() const = 0;                                 // _38\n    virtual const ResFONT *getResFont() const = 0;                       // _3C\n    virtual bool isLeadByte(int) const = 0;                              // _40\n\n    void initialize_state();\n    void setCharColor(JUtility::TColor);\n    void setGradColor(JUtility::TColor, JUtility::TColor);\n    f32 drawString_size_scale(f32, f32, f32, f32, const char *, u32, bool);\n\n    void drawString(int posX, int posY, const char *str, bool visible) { drawString_size(posX, posY, str, strlen(str), visible); }\n\n    void drawString_size(int posX, int posY, const char *str, u32 len, bool visible)\n    {\n        drawString_size_scale(posX, posY, getWidth(), getHeight(), str, len, visible);\n    }\n\n    void drawString_scale(f32 posX, f32 posY, f32 width, f32 height, const char *str, bool visible)\n    {\n        drawString_size_scale(posX, posY, width, height, str, strlen(str), visible);\n    }\n\n    int getWidth(int i_no) const\n    {\n        TWidth width;\n        getWidthEntry(i_no, &width);\n        return width.w0;\n    }\n\n    void setFixedWidth(bool fixed, int width) {\n        mFixed = fixed;\n        mFixedWidth = width;\n    }\n\n    bool isValid() const { return mValid; }\n\n    static bool isLeadByte_1Byte(int c) { return false; }\n    static bool isLeadByte_2Byte(int c) { return true; }\n    static bool isLeadByte_ShiftJIS(int c)\n    {\n        return ((c >= 0x81) && (c <= 0x9F)) || ((c >= 0xE0) && (c <= 0xFC));\n    }\n\n    // _00 = VTBL\n    bool mValid;            // _04\n    bool mFixed;            // _05\n    int mFixedWidth;          // _08\n    JUtility::TColor mColor1; // _0C, bottom left\n    JUtility::TColor mColor2; // _10, bottom right\n    JUtility::TColor mColor3; // _14, top left\n    JUtility::TColor mColor4; // _18, top right\n};\n\nstruct JUTRomFont : public JUTFont\n{\n    // @fabricatedName\n    struct AboutEncoding\n    {\n        u32 mFontType;                  // _00\n        u32 mDataSize;                  // _04\n        IsLeadByte mIsLeadByteFunction; // _08\n    };\n\n    JUTRomFont();\n    JUTRomFont(JKRHeap *);\n\n    virtual ~JUTRomFont();                                                   // _08\n    virtual void setGX();                                                    // _0C\n    virtual f32 drawChar_scale(f32, f32, f32, f32, int, bool);               // _14\n    virtual int getWidth() const { return spFontHeader_->width; };           // _28\n    virtual int getLeading() const { return spFontHeader_->leading; };       // _18\n    virtual int getAscent() const { return spFontHeader_->ascent; };         // _1C\n    virtual int getDescent() const { return spFontHeader_->descent; };       // _20\n    virtual int getHeight() const { return getAscent() + getDescent(); };    // _24\n    virtual void getWidthEntry(int, JUTFont::TWidth *) const;                // _2C\n    virtual int getCellWidth() const { return spFontHeader_->cellWidth; };   // _30\n    virtual int getCellHeight() const { return spFontHeader_->cellHeight; }; // _34\n    virtual ResFONT *getResFont() const { return nullptr; };                 // _3C\n    virtual int getFontType() const { return spAboutEncoding_->mFontType; }; // _38\n    virtual bool isLeadByte(int) const;                                      // _40\n\n    void initiate(JKRHeap *);\n    void loadImage(JKRHeap *);\n\n    static AboutEncoding *spAboutEncoding_;\n    static OSFontHeader *spFontHeader_;\n    static u32 suFontHeaderRefered_; // they misspelled referred\n    static AboutEncoding saoAboutEncoding_[2];\n\n    // _00     = VTBL\n    // _00-_1C = JUTFont\n};\n\nstruct BlockHeader\n{\n    const BlockHeader *getNext() const { return reinterpret_cast<const BlockHeader *>(reinterpret_cast<const u8 *>(this) + this->mSize); }\n    inline static void advance(const BlockHeader **iterator)\n    {\n        *iterator = reinterpret_cast<const BlockHeader *>(reinterpret_cast<const u8 *>(*iterator) + (*iterator)->mSize);\n    }\n\n    u32 mMagic; // _00\n    u32 mSize;  // _04\n};\n\nstruct ResFONT\n{\n    // INF1, size: 0x14\n    struct InfoBlock : public BlockHeader\n    {\n        // _00 = BlockHeader\n        u16 mFontType;    // _08\n        u16 mAscent;      // _0A\n        u16 mDescent;     // _0C\n        u16 mWidth;       // _0E\n        u16 mLeading;     // _10\n        u16 mDefaultCode; // _12\n    };\n\n    // WID1, size: 0x10\n    struct WidthBlock : public BlockHeader\n    {\n        // _00 = BlockHeader\n        u16 mStartCode;               // _08\n        u16 mEndCode;                 // _0A\n        JUTFont::TWidth mChunkNum[2]; // _0C\n    };\n\n    // MAP1, size: 0x14\n    struct MapBlock : public BlockHeader\n    {\n        // _00 = BlockHeader\n        u16 mMappingMethod; // _08\n        u16 mStartCode;     // _0A\n        u16 mEndCode;       // _0C\n        u16 mNumEntries;    // _0E\n        u16 mLeading;       // _10\n    };\n\n    // GLY1, size: 0x20\n    struct GlyphBlock : public BlockHeader\n    {\n        // _00 = BlockHeader\n        u16 mStartCode;     // _08\n        u16 mEndCode;       // _0A\n        u16 mCellWidth;     // _0C\n        u16 mCellHeight;    // _0E\n        u32 mTextureSize;   // _10\n        u16 mTextureFormat; // _14\n        u16 mNumRows;       // _16\n        u16 mNumColumns;    // _18\n        u16 mTextureWidth;  // _1A\n        u16 mTextureHeight; // _1C\n        u16 mPadding;       // _1E\n        u8 mData[];         // _20\n    };\n\n    u64 mMagic;        // _00\n    u32 mFileSize;     // _08\n    u32 mNumBlocks;    // _0C\n    u8 mPadding[0x10]; // _10\n    u8 mData[];        // _20\n};\n\n/**\n * @size{0x70}\n */\nstruct JUTResFont : public JUTFont\n{\n    JUTResFont();\n    JUTResFont(const ResFONT *, JKRHeap *);\n\n    virtual ~JUTResFont();                                                // _08\n    virtual void setGX();                                                 // _0C\n    virtual void setGX(JUtility::TColor, JUtility::TColor);               // _10\n    virtual f32 drawChar_scale(f32, f32, f32, f32, int, bool);            // _14\n    virtual int getDescent() const { return mInfoBlock->mDescent; };      // _20\n    virtual int getHeight() const { return getAscent() + getDescent(); }; // _24\n    virtual int getAscent() const { return mInfoBlock->mAscent; };        // _1C\n    virtual int getWidth() const { return mInfoBlock->mWidth; };          // _28\n    virtual void getWidthEntry(int, JUTFont::TWidth *) const;             // _2C\n    virtual int getCellWidth() const;                                     // _30\n    virtual int getCellHeight() const;                                    // _34\n    virtual int getFontType() const { return mInfoBlock->mFontType; };    // _38\n    virtual const ResFONT *getResFont() const { return mResource; };      // _3C\n    virtual int getLeading() const { return mInfoBlock->mLeading; };      // _18\n    virtual bool isLeadByte(int) const;                                   // _40\n    virtual void loadImage(int, GXTexMapID);                              // _44\n    virtual void setBlock();                                              // _48\n\n    int convertSjis(int, u16 *) const;\n    void countBlock();\n    void deleteMemBlocks_ResFont();\n    int getFontCode(int) const;\n    void initialize_state();\n    bool initiate(const ResFONT *, JKRHeap *);\n    void loadFont(int, GXTexMapID, TWidth *);\n    bool protected_initiate(const ResFONT *, JKRHeap *);\n\n    inline void delete_and_initialize()\n    {\n        deleteMemBlocks_ResFont();\n        initialize_state();\n    }\n\n    static IsLeadByte const saoAboutEncoding_[3];\n\n    // _00     = VTBL\n    // _00-_1C = JUTFont\n    int mWidth;                         // _1C\n    int mHeight;                        // _20\n    GXTexObj _24;                       // _24\n    int _44;                            // _44\n    const ResFONT *mResource;           // _48\n    ResFONT::InfoBlock *mInfoBlock;     // _4C, INF1\n    void **mMemBlocks;                  // _50\n    ResFONT::WidthBlock **mWidthBlocks; // _54, WID1\n    ResFONT::GlyphBlock **mGlyphBlocks; // _58, GLY1\n    ResFONT::MapBlock **mMapBlocks;     // _5C, MAP1\n    u16 mWidthBlockCount;               // _60\n    u16 mGlyphBlockCount;               // _62\n    u16 mMapBlockCount;                 // _64\n    u16 _66;                            // _66\n    u16 mMaxCode;                       // _68\n    IsLeadByte *mIsLeadByte;            // _6C\n};\n\nstruct JUTCacheFont : public JUTResFont\n{\n    enum EPagingType\n    {\n        CFPAGETYPE_Unk0 = 0,\n        CFPAGETYPE_Unk1 = 1,\n    };\n\n    struct TGlyphCacheInfo\n    {\n        // TODO: the rest of the data members\n        TGlyphCacheInfo *mPrev; // _00\n        TGlyphCacheInfo *mNext; // _04\n        u8 _08[4];              // _08\n        u16 _0C;                // _0C\n        u16 _0E;                // _0E\n        u8 _10[4];              // _10\n        u16 _14;                // _14\n        u16 _16;                // _16\n        u8 _18[8];              // _18\n        GXTexObj mGxTexObj;     // _20\n    };\n\n    struct TCachePage\n    {\n        u8 _00[0x8]; // _00, unknown\n        s16 _08;     // _08\n        u16 _0A;     // _0A\n        u8 _0C[0x4]; // _0C, unknown\n        u8 *_10;     // _10\n        u16 _14;     // _14\n        u16 _18;     // _18\n        u16 _1C;     // _1C\n        u16 _20;     // _20\n        u16 _24;     // _24\n        u16 _28;     // _28\n    };\n\n    JUTCacheFont();\n    JUTCacheFont(const ResFONT *, void *, u32, JKRHeap *);\n    JUTCacheFont(const ResFONT *, u32, JKRHeap *);\n\n    virtual ~JUTCacheFont();                  // _08\n    virtual void loadImage(int, _GXTexMapID); // _44\n    virtual void setBlock();                  // _48\n\n    bool allocArea(void *, u32, JKRHeap *);\n    bool allocArray(JKRHeap *);\n    void deleteMemBlocks_CacheFont();\n    bool getMemorySize(const ResFONT *, u16 *, u32 *, u16 *, u32 *, u16 *, u32 *, u32 *);\n    void initialize_state();\n    bool initiate(const ResFONT *, void *, u32, JKRHeap *);\n    bool internal_initiate(const ResFONT *, void *, u32, JKRHeap *);\n    void invalidiateAllCache();\n    TGlyphCacheInfo *loadCache_char_subroutine(int *, bool);\n    void loadCache_string(const char *, bool);\n    void prepend(TGlyphCacheInfo *);\n    void unlink(TGlyphCacheInfo *);\n\n    // Unused/inlined:\n    void determineBlankPage();\n    void getGlyphFromAram(TGlyphCacheInfo *, TCachePage *, int *, int *);\n    void loadCache_char(int, bool);\n    void loadCache_string_size(const char *, u32, bool);\n    void unlockCache_all();\n    void unlockCache_char(int);\n    void unlockCache_string(const char *);\n    void unlockCache_string_size(const char *, u32);\n\n    void setPagingType(EPagingType type) { mPagingType = type; }\n\n    static u32 calcCacheSize(u32 param_0, int param_1) { return (ALIGN_NEXT(param_0, 0x20) + 0x40) * param_1; }\n\n    // _00     = VTBL\n    // _00-_70 = JUTResFont\n    u32 mWidthBlocksSize;     // _70\n    u32 mGlyphBlocksSize;     // _74\n    u32 mMapBlocksSize;       // _78\n    void *_7C;                // _7C\n    void *_80;                // _80\n    void *_84;                // _84\n    u32 mMaxSheetSize;        // _88\n    EPagingType mPagingType;  // _8C\n    void *mCacheBuffer;       // _90\n    u32 _94;                  // _94\n    u32 mCachePage;           // _98\n    TGlyphCacheInfo *_9C;     // _9C\n    TGlyphCacheInfo *_A0;     // _A0\n    void *_A4;                // _A4\n    u32 _A8;                  // _A8\n    JKRAramBlock *mAramBlock; // _AC\n    u8 _B0;                   // _B0\n    int _B4;                  // _B4\n};\n\nextern const ResFONT JUTResFONT_Ascfont_fix12;\n\n#endif/* end \"JSystem/JUtility/JUTFont.h\" */\n/* \"include\\JSystem\\JUtility\\JUTConsole.h\" line 7 \"JSystem/JGadget/linklist.h\" */\n#ifndef LINKLIST_H\n#define LINKLIST_H\n/* \"include\\JSystem\\JGadget\\linklist.h\" line 2 \"types.h\" */\n/* end \"types.h\" */\n\n/* \"include\\JSystem\\JGadget\\linklist.h\" line 4 \"JSystem/JGadget/define.h\" */\n#ifndef DEFINE_H\n#define DEFINE_H\n\n/* \"include\\JSystem\\JGadget\\define.h\" line 3 \"JSystem/JUtility/JUTAssert.h\" */\n/* end \"JSystem/JUtility/JUTAssert.h\" */\n/* \"include\\JSystem\\JGadget\\define.h\" line 4 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n    class JGadget_outMessage\n    {\n    public:\n        typedef void (*MessageFunc)(const char *, int, const char *);\n\n        static void warning(const char *, int, const char *);\n\n        JGadget_outMessage(MessageFunc fn, const char *file, int line);\n        ~JGadget_outMessage();\n\n        JGadget_outMessage &operator<<(const char *str);\n\n    private:\n        MessageFunc mMsgFunc;\n        char mBuffer[256];\n        char *mWrite_p;\n        char *mFile;\n        int mLine;\n    };\n\n#ifdef JGADGET_DEBUG\n\n#define JGADGET_ASSERTWARN(cond) \\\n    ((cond) || ((JGadget_outMessage(JGadget_outMessage::warning, __FILE__, __LINE__) << (#cond)), false))\n\n#define JGADGET_EXITWARN(cond)                                                                 \\\n    if (!(cond))                                                                               \\\n    {                                                                                          \\\n        JGadget_outMessage(JGadget_outMessage::warning, __FILE__, __LINE__) << (#cond), false; \\\n        return false;                                                                          \\\n    }\n\n#define JGADGET_ASSERT(cond) \\\n    JUT_ASSERT(cond);\n\n#else\n\n#define JGADGET_ASSERTWARN(cond) \\\n    ((cond) || (false))\n\n#define JGADGET_EXITWARN(cond) \\\n    if (!(cond))               \\\n    {                          \\\n        false;                 \\\n        return false;          \\\n    }\n\n// this is required, removing this will result in functions not matching\n#define JGADGET_ASSERT(...) (void)0;\n\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif/* end \"JSystem/JGadget/define.h\" */\n\n#define NEGATIVE_OFFSETOF(TYPE, MEMBER) (-static_cast<s32>(offsetof(TYPE, MEMBER)))\n#define TLINKLIST_NODE_OFS(TYPE) (NEGATIVE_OFFSETOF(TYPE, mNode))\n#define TLinkList(TYPE) TLinkList<TYPE, TLINKLIST_NODE_OFS(TYPE)>\n\nnamespace JGadget {\n\nnamespace {\n\ntemplate <typename T>\nclass TPRIsEqual_pointer_ {\npublic:\n  TPRIsEqual_pointer_<T>(const T* p) { this->p_ = p; }\n\n  bool operator()(const T& rSrc) const {\n    return &rSrc == this->p_;\n  }\n\nprivate:\n  const T* p_;\n};\n\n}\n\nclass TLinkListNode {\npublic:\n  TLinkListNode() {\n    this->pNext_ = nullptr;\n    this->pPrev_ = nullptr;\n  }\n\n  ~TLinkListNode() {\n    // Seemingly not present in earlier versions of JSystem\n    #line 77\n    JGADGET_ASSERT(pNext_==NULL);\n    JGADGET_ASSERT(pPrev_==NULL);\n  }\n\n  TLinkListNode* getNext() const {\n    return this->pNext_;\n  }\n\n  TLinkListNode* getPrev() const {\n    return this->pPrev_;\n  }\n\n  void clear_() {\n    this->pNext_ = nullptr;\n    this->pPrev_ = nullptr;\n  }\n\n  TLinkListNode* pNext_;\n  TLinkListNode* pPrev_;\n};\n\nclass TNodeLinkList {\npublic:\n  TNodeLinkList() : oNode_() { Initialize_(); }\n  ~TNodeLinkList();\n\n  class iterator {\n  public:\n    iterator() { this->p_ = nullptr; }\n    iterator(TLinkListNode* node) { this->p_ = node; }\n\n    iterator& operator++() {\n      this->p_ = this->p_->getNext();\n      return *this;\n    }\n\n    iterator& operator--() {\n      this->p_ = this->p_->getPrev();\n      return *this;\n    }\n\n    TLinkListNode& operator*() const {\n      JGADGET_ASSERT(p_!=0);\n      return *this->p_;\n    }\n\n    TLinkListNode* operator->() const { return this->p_; }\n    \n    TLinkListNode* p_;\n  };\n\n  class const_iterator {\n  public:\n    const_iterator(const TLinkListNode* node) { this->p_ = node; }\n    const_iterator(iterator it) { this->p_ = it.p_; }\n\n    const const_iterator& operator++() {\n      this->p_ = this->p_->getNext();\n      return *this;\n    }\n\n    const const_iterator& operator--() {\n      this->p_ = this->p_->getPrev();\n      return *this;\n    }\n\n    const TLinkListNode* operator->() const { return this->p_; }\n    \n    const TLinkListNode* p_;\n  };\n\n  bool Confirm() const;\n  bool Confirm_iterator(const_iterator it) const;\n  iterator Erase(TLinkListNode* node);\n  iterator Find(const TLinkListNode* node);\n  iterator Insert(iterator it, TLinkListNode* node);\n  void Remove(TLinkListNode* node);\n  template <typename Predicate> \n  inline void Remove_if(Predicate predicate, TNodeLinkList& tList) {\n    iterator it = this->begin();\n\n    while(!Iterator_isEnd_(it)) {\n      if (predicate(*it)) {\n        iterator itPrev = it;\n        ++it;\n        tList.splice(tList.end(), *this, itPrev);\n      }\n      else {\n        ++it;\n      }\n    }\n  }\n\n  u32 size() const { return this->size_; }\n  bool empty() const { return this->size() == 0; }\n  void clear();\n  iterator erase(iterator itStart, iterator itEnd);\n  iterator erase(iterator it);\n  template <typename Predicate> \n  inline void remove_if(Predicate predicate) {\n    TNodeLinkList list;\n\n    this->Remove_if(predicate, list);\n  }\n  void splice(iterator it, TNodeLinkList& rSrc, iterator itBegin, iterator itEnd);\n  void splice(iterator it, TNodeLinkList& rSrc);\n  void splice(iterator it, TNodeLinkList& rSrc, iterator otherIt);\n  iterator pop_back() { return this->erase(--this->end()); }\n  iterator pop_font() { return this->erase(++this->begin()); }\n\n  iterator begin() { return this->oNode_.getNext(); }\n  const_iterator begin() const { return this->oNode_.getNext(); }\n\n  iterator end() {return &this->oNode_; }\n  const_iterator end() const { return &this->oNode_; }\n\nprivate:\n  void Initialize_() {\n    this->size_ = 0;\n    this->oNode_.pNext_ = &this->oNode_;\n    this->oNode_.pPrev_ = &this->oNode_;\n  }\n\n  bool Iterator_isEnd_(const_iterator it) const { return it.p_ == &this->oNode_; }\n\n  u32 size_;\n  TLinkListNode oNode_;\n};\n\ninline bool operator==(TNodeLinkList::iterator lhs, TNodeLinkList::iterator rhs) { return lhs.p_ == rhs.p_; }\ninline bool operator!=(TNodeLinkList::iterator lhs, TNodeLinkList::iterator rhs) { return !(lhs == rhs); }\n\ninline bool operator==(TNodeLinkList::const_iterator lhs, TNodeLinkList::const_iterator rhs) { return lhs.p_ == rhs.p_; }\ninline bool operator!=(TNodeLinkList::const_iterator lhs, TNodeLinkList::const_iterator rhs) { return !(lhs == rhs); }\n\n/* TODO: TLinkList has not been matched and should be verified */\n\ntemplate <typename T, int O>\nclass TLinkList;\n\ntemplate <typename T, int O>\nbool operator==(typename TLinkList<T, O>::iterator lhs, typename TLinkList<T, O>::iterator rhs);\ntemplate <typename T, int O>\nbool operator!=(typename TLinkList<T, O>::iterator lhs, typename TLinkList<T, O>::iterator rhs);\n\ntemplate <typename T, int O>\nbool operator==(typename TLinkList<T, O>::const_iterator lhs, typename TLinkList<T, O>::const_iterator rhs);\ntemplate <typename T, int O>\nbool operator!=(typename TLinkList<T, O>::const_iterator lhs, typename TLinkList<T, O>::const_iterator rhs);\n\ntemplate <typename T, int O>\nclass TLinkList : public TNodeLinkList {\npublic:\n  class iterator {\n  public:\n    iterator(TNodeLinkList::iterator it) : mIt(it) {  }\n\n    friend bool operator==(iterator lhs, iterator rhs) { return (lhs.mIt == rhs.mIt); }\n    friend bool operator!=(iterator lhs, iterator rhs) { return !(lhs == rhs); }\n    iterator& operator++() {\n      ++mIt;\n      return *this;\n    }\n    iterator& operator--() {\n      --mIt;\n      return *this;\n    }\n\n    T* operator->() const { return TLinkList::Element_toValue(mIt.operator->()); }\n    T& operator*() const {\n      T* p = this->operator->();\n      #line 541\n      JGADGET_ASSERT(p!=0);\n      return *p;\n    }\n\n    TNodeLinkList::iterator mIt;\n  };\n\n  class const_iterator {\n  public:\n    const_iterator(TNodeLinkList::const_iterator it) : mIt(it) {  }\n    const_iterator(iterator it) : mIt(it.mIt) {}\n\n    friend bool operator==(const_iterator lhs, const_iterator rhs) { return (lhs.mIt == rhs.mIt); }\n    friend bool operator!=(const_iterator lhs, const_iterator rhs) { return !(lhs == rhs); }\n    \n    const_iterator& operator++() {\n      ++mIt;\n      return *this;\n    }\n    const_iterator& operator--() {\n      --mIt;\n      return *this;\n    }\n\n    const T* operator->() const { return TLinkList::Element_toValue(mIt.operator->()); }\n    const T& operator*() const {\n      const T* p = this->operator->();\n      #line 586\n      JGADGET_ASSERT(p!=0);\n      return *p;\n    }\n    TNodeLinkList::const_iterator mIt;\n  };\n\n  iterator begin() { return TNodeLinkList::begin(); }\n  const_iterator begin() const { return const_cast<TLinkList *>(this)->begin(); }\n\n  iterator end() { return TNodeLinkList::end(); }\n  const_iterator end() const { return const_cast<TLinkList *>(this)->end(); }\n\n  iterator Find(const T* p) { return TNodeLinkList::Find(TLinkList::Element_toNode(p)); }\n  iterator Erase(T* p) { return TNodeLinkList::Erase(Element_toNode(p)); }\n  iterator Insert(iterator it, T *p) { return TNodeLinkList::Insert(it.mIt, TLinkList::Element_toNode(p)); }\n  void Remove(T* p) { TNodeLinkList::Remove(TLinkList::Element_toNode(p)); }\n  void Push_front(T* p) { Insert(begin(), p); }\n  void Push_back(T* p) { Insert(end(), p); }\n\n  T& front() {\n    #line 642\n    JGADGET_ASSERT(!empty());\n    return *begin();\n  }\n\n  T& back() {\n    #line 652\n    JGADGET_ASSERT(!empty());\n    return *--end();\n  }\n\n  static TLinkListNode* Element_toNode(T* p) {\n    #line 753\n    JGADGET_ASSERT(p!=0);\n    return (TLinkListNode*)((char*)p - O);\n  }\n\n  static const TLinkListNode* Element_toNode(const T* p) {\n    #line 758\n    JGADGET_ASSERT(p!=0);\n    return (const TLinkListNode*)((const char*)p - O);\n  }\n\n  static T* Element_toValue(TLinkListNode* p) {\n    #line 763\n    JGADGET_ASSERT(p!=0);\n    return (T*)((char*)p + O);\n  }\n\n  static const T* Element_toValue(const TLinkListNode* p) {\n    #line 768\n    JGADGET_ASSERT(p!=0);\n    return (const T*)((const char*)p + O);\n  }\n};\n}\n\n#endif/* end \"JSystem/JGadget/linklist.h\" */\n/* \"include\\JSystem\\JUtility\\JUTConsole.h\" line 8 \"types.h\" */\n/* end \"types.h\" */\n\ninline s32 colorCheck(s32 diff, s32 t)\n{\n    s32 ret = diff - t;\n    return ret + 1;\n}\n\nclass JUTConsole : public JKRDisposer\n{\npublic:\n    enum EConsoleType\n    {\n        CONSOLE_TYPE_0 = 0,\n        CONSOLE_TYPE_1 = 1,\n        CONSOLE_TYPE_2 = 2,\n    };\n\n    enum OutputFlag\n    {\n        /* 0x0 */ OUTPUT_NONE,\n        /* 0x1 */ OUTPUT_OSREPORT,\n        /* 0x2 */ OUTPUT_CONSOLE,\n        /* 0x3 */ OUTPUT_OSR_AND_CONSOLE,\n    };\n\n    virtual ~JUTConsole(); // _08\n\n    // _00 VTBL\n\n    static JUTConsole *create(uint, uint, JKRHeap *);\n    static JUTConsole *create(uint, void *, u32);\n    static void destroy(JUTConsole *); // UNUSED\n    JUTConsole(uint, uint, bool);\n    static size_t getObjectSizeFromBufferSize(uint, uint);\n    static size_t getLineFromObjectSize(u32, uint);\n    void clear();\n    void doDraw(JUTConsole::EConsoleType) const;\n    void print_f(char const *, ...);\n    void print(char const *);\n    void dumpToTerminal(uint);\n    void scroll(int);\n    int getUsedLine() const;\n    int getLineOffset() const;\n\n    void setOutput(uint output) { mOutput = output; }\n    void setPosition(int x, int y)\n    {\n        mPositionX = x;\n        mPositionY = y;\n    }\n    void setFontSize(f32 x, f32 y)\n    {\n        mFontSizeX = x;\n        mFontSizeY = y;\n    }\n    void setHeight(u32 height)\n    {\n        mHeight = height;\n        if (mHeight > mMaxLines)\n        {\n            mHeight = mMaxLines;\n        }\n    }\n\n    void setFont(JUTFont *p_font)\n    {\n        mFont = p_font;\n        setFontSize(p_font->getWidth(), p_font->getHeight());\n    }\n\n    int nextIndex(int index) const\n    {\n        return ++index >= (int)mMaxLines ? 0 : index;\n    }\n\n    u32 getOutput() const { return mOutput; }\n    int getPositionY() const { return mPositionY; }\n    int getPositionX() const { return mPositionX; }\n    u32 getHeight() const { return mHeight; }\n\n    bool isVisible() const { return mIsVisible; }\n    void setVisible(bool visible) { mIsVisible = visible; }\n\n    void setLineAttr(int param_0, u8 param_1) { mBuf[(_20 + 2) * param_0] = param_1; }\n    u8 *getLinePtr(int param_0) const { return &mBuf[(_20 + 2) * param_0] + 1; }\n    int diffIndex(int param_0, int param_1) const\n    {\n        int diff = param_1 - param_0;\n        if (diff >= 0)\n        {\n            return diff;\n        }\n        return diff += mMaxLines;\n    }\n\n    void scrollToLastLine() { scroll(mMaxLines); }\n    void scrollToFirstLine() { scroll(-mMaxLines); }\n\n    // _00     = VTBL\n    // _00-_18 = JKRDisposer\n    JGadget::TLinkListNode mListNode; // _18\n    u32 _20;                          // _20\n    u32 mMaxLines;                    // _24, might be int\n    u8 *mBuf;                         // _28\n    bool _2C;                         // _2C\n    int _30;                          // _30\n    int _34;                          // _34\n    int _38;                          // _38\n    int _3C;                          // _3C\n    int mPositionX;                   // _40\n    int mPositionY;                   // _44\n    u32 mHeight;                      // _48\n    JUTFont *mFont;                   // _4C\n    f32 mFontSizeX;                   // _50\n    f32 mFontSizeY;                   // _54\n    u32 mOutput;                      // _58\n    JUtility::TColor _5C;             // _5C\n    JUtility::TColor _60;             // _60\n    int _64;                          // _64\n    bool mIsVisible;                  // _68\n    bool _69;                         // _69\n    bool _6A;                         // _6A\n    bool _6B;                         // _6B\n}; // Size: 0x6C\n\nclass JUTConsoleManager\n{\npublic:\n    JUTConsoleManager();\n    static JUTConsoleManager *createManager(JKRHeap *);\n    void appendConsole(JUTConsole *console);\n    void removeConsole(JUTConsole *console);\n    void draw() const;\n    void drawDirect(bool) const;\n    void setDirectConsole(JUTConsole *);\n\n    static JUTConsoleManager *getManager() { return sManager; }\n\n    static JUTConsoleManager *sManager;\n\nprivate:\n    JGadget::TLinkList<JUTConsole, -24> soLink_; // _00\n    JUTConsole *mActiveConsole;                  // _0C\n    JUTConsole *mDirectConsole;                  // _10\n};                                               // Size: 0x14\n\n#ifdef __cplusplus // not sure if this is needed, if it is, maybe recast JUTConsole to void * or forward declaration\nextern \"C\" {\n#endif\nvoid JUTConsole_print_f_va_(JUTConsole *, const char *, va_list);\n\nJUTConsole *JUTGetReportConsole();\nvoid JUTSetReportConsole(JUTConsole *);\nJUTConsole *JUTGetWarningConsole();\nvoid JUTSetWarningConsole(JUTConsole *);\nvoid JUTReportConsole(const char *);\nvoid JUTReportConsole_f(const char *, ...);\nvoid JUTReportConsole_f_va(const char *, va_list);\nvoid JUTWarningConsole(const char*);\nvoid JUTWarningConsole_f(const char *, ...);\nvoid JUTWarningConsole_f_va(const char *, va_list);\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif/* end \"JSystem/JUtility/JUTConsole.h\" */\n/* \"include\\JSystem\\JKernel\\JKRThread.h\" line 8 \"types.h\" */\n/* end \"types.h\" */\n\nstruct JKRThread;\n\nstruct JKRThreadName_\n{\n    s32 id;\n    char *name;\n};\n\ntypedef void (*JKRThreadSwitch_PreCallback)(OSThread *current, OSThread *next);\ntypedef void (*JKRThreadSwitch_PostCallback)(OSThread *current, OSThread *next);\n\nclass JKRThreadSwitch\n{\npublic:\n    JKRThreadSwitch(JKRHeap *);\n    virtual void draw(JKRThreadName_ *param_1, JUTConsole *param_2);\n    virtual void draw(JKRThreadName_ *param_1);\n    virtual ~JKRThreadSwitch();\n\n    static JKRThreadSwitch *createManager(JKRHeap *heap);\n\n    JKRThread *enter(JKRThread *param_1, int param_2);\n    static void callback(OSThread *param_1, OSThread *param_2);\n\n    static u32 getTotalCount() { return sTotalCount; }\n\nprivate:\n    static JKRThreadSwitch *sManager;\n    static u32 sTotalCount;\n    static u64 sTotalStart;\n    static JKRThreadSwitch_PreCallback mUserPreCallback;\n    static JKRThreadSwitch_PostCallback mUserPostCallback;\n\nprivate:\n    JKRHeap *mHeap;              // _04\n    bool mSetNextHeap;           // _08\n    u8 _09[3];                   // _09, padding?\n    u32 _0C;                     // _0C\n    u32 _10;                     // _10\n    u8 _14[4];                   // _14 - unknown/padding\n    s64 _18;                     // _18\n    JUTConsole *mConsole;        // _20\n    JKRThreadName_ *mThreadName; // _24\n};\n\nstruct JKRThread : public JKRDisposer\n{\n    struct TLoad\n    {\n        inline TLoad()\n        {\n            mSwitchCount = 0;\n            mCost = 0;\n            mLastTick = 0;\n            mIsValid = false;\n            mThreadID = 0;\n        }\n\n        bool isValid() const { return mIsValid; }\n        u32 getCost() const { return mCost; }\n        u32 getCount() const { return mSwitchCount; }\n        int getId() const { return mThreadID; }\n\n        void setValid(bool valid) { mIsValid = valid; }\n        void setId(int id) { mThreadID = id; }\n        void setCurrentTime() { mLastTick = OSGetTick(); }\n\n        void resetCost() { mCost = 0; }\n        void resetCount() { mSwitchCount = 0; }\n\n        void incCount() { mSwitchCount++; }\n        void addCurrentCost() { mCost = mCost + (OSGetTick() - mLastTick); }\n\n        void clear()\n        {\n            resetCount();\n            resetCost();\n            mLastTick = 0;\n        }\n\n        bool mIsValid;    // _00\n        u32 mCost;        // _04\n        u32 mSwitchCount; // _08\n        u32 mLastTick;    // _0C\n        int mThreadID;    // _10\n    };\n\n    JKRThread(u32 stackSize, int msgCount, int threadPriority);\n    JKRThread(JKRHeap *, u32 stackSize, int msgCount, int threadPriority);\n    JKRThread(OSThread *, int);\n\n    virtual ~JKRThread();                   // _08\n    virtual void *run() { return nullptr; } // _0C (weak), does this really return void*? might as well be int\n\n    void setCommon_mesgQueue(JKRHeap *, int);\n    BOOL setCommon_heapSpecified(JKRHeap *, u32, int);\n    static void *start(void *);\n    static JSUList<JKRThread> &getList() { return (JSUList<JKRThread> &)sThreadList; }\n\n    // unused/inlined:\n    static JKRThread *searchThread(OSThread *);\n    static TLoad *searchThreadLoad(OSThread *);\n    void dump();\n\n    OSThread *getThreadRecord() const { return mThreadRecord; }\n    void *getStack() const { return mStackMemory; }\n    TLoad *getLoadInfo() { return &mLoadInfo; }\n    JKRHeap *getCurrentHeap() const { return mCurrentHeap; }\n    s32 getCurrentHeapError() const { return mCurrentHeapError; }\n    void resume() { OSResumeThread(mThreadRecord); }\n\n    void setCurrentHeap(JKRHeap *heap)\n    {\n        /*\n        JKRHeap *curHeap;\n        if(heap) {\n            curHeap = heap;\n        }\n        else {\n            curHeap = JKRGetCurrentHeap();\n        }\n        mCurrentHeap = curHeap;\n        */\n\n        mCurrentHeap = heap ? heap : JKRGetCurrentHeap();\n    }\n\n    static JSUList<JKRThread> sThreadList;\n\n    // _00     = VTBL\n    // _00-_18 = JKRDisposer\n    JSULink<JKRThread> mThreadListLink; // _18\n    JKRHeap *mHeap;                     // _28\n    OSThread *mThreadRecord;            // _2C\n    OSMessageQueue mMessageQueue;       // _30\n    OSMessage *mMesgBuffer;             // _50\n    s32 mMessageCount;                  // _54\n    void *mStackMemory;                 // _58\n    u32 mStackSize;                     // _5C\n    TLoad mLoadInfo;                    // _60\n    JKRHeap *mCurrentHeap;              // _74\n    s32 mCurrentHeapError;              // _78\n};\n\n/**\n * @size{0x98}\n */\nstruct JKRTask : public JKRThread\n{\n    typedef void (*RequestCallback)(void *);\n\n    /**\n     * @fabricated\n     * @size{0xC}\n     */\n    struct Request\n    {\n        RequestCallback mCb;\n        void *mArg;\n        void *mMsg;\n    };\n\n    JKRTask(int, int, u32); // unused/inlined\n\n    virtual ~JKRTask();  // _08\n    virtual void *run(); // _0C\n\n    bool request(RequestCallback, void *, void *);\n\n    static JKRTask *create(int, int, u32, JKRHeap *);\n\n    // unused/inlined:\n    Request *searchBlank();\n    void requestJam(RequestCallback, void *, void *);\n    void cancelAll();\n    void createTaskEndMessageQueue(int, JKRHeap *);\n    void destroyTaskEndMessageQueue();\n    void waitQueueMessageBlock(OSMessageQueue *, int *);\n    void waitQueueMessage(OSMessageQueue *, int *);\n\n    OSMessage waitMessageBlock()\n    {\n        OSMessage msg;\n        OSReceiveMessage(&mMessageQueue, &msg, OS_MESSAGE_BLOCK);\n        return msg;\n    }\n\n    static void destroy(JKRTask *);\n\n    // Unused\n    static OSMessage *sEndMesgBuffer;\n    static u32 sEndMesgBufSize;\n\n    // u32 _78;\t\t\t // _78\n    JSULink<JKRTask> mTaskLink;    // _7C\n    Request *mRequest;             // _8C - ptr to request array\n    u32 mRequestCnt;               // _90 - amount of requests\n    OSMessageQueue *mTaskMsgQueue; // _94\n\n    static JSUList<JKRTask> sTaskList;\n    static u8 sEndMesgQueue[32]; // Unused\n};\n\n/** @unused */\nstruct JKRIdleThread : JKRThread\n{\n    virtual ~JKRIdleThread(){}; // _08\n    virtual void *run()         // _0C\n    {\n        while (true)\n        {\n        }\n    }; \n    virtual void destroy() {} // 0x10\n\n    static void create(JKRHeap *, int, u32);\n\n    static JKRIdleThread *sThread;\n};\n\n#endif\n/* end \"JSystem/JKernel/JKRThread.h\" */\n/* \"include\\JSystem\\JUtility\\JUTException.h\" line 5 \"JSystem/JSupport/JSUList.h\" */\n/* end \"JSystem/JSupport/JSUList.h\" */\n/* \"include\\JSystem\\JUtility\\JUTException.h\" line 6 \"JSystem/JUtility/JUTGamePad.h\" */\n#ifndef JUTGAMEPAD_H\n#define JUTGAMEPAD_H\n// from Super Mario Eclipse\n/* \"include\\JSystem\\JUtility\\JUTGamePad.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n/* \"include\\JSystem\\JUtility\\JUTGamePad.h\" line 4 \"dolphin/os.h\" */\n/* end \"dolphin/os.h\" */\n/* \"include\\JSystem\\JUtility\\JUTGamePad.h\" line 5 \"dolphin/pad.h\" */\n#ifndef _DOLPHIN_PAD\n#define _DOLPHIN_PAD\n\n/* \"include\\dolphin\\pad.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\nextern u32 __PADFixBits;\n\n#define PAD_CONTROLLER_NUM 4\n\n#define PAD_SPEC_0 0\n#define PAD_SPEC_1 1\n#define PAD_SPEC_2 2\n#define PAD_SPEC_3 3\n#define PAD_SPEC_4 4\n#define PAD_SPEC_5 5\n\n#define PAD_CHAN0 0\n#define PAD_CHAN1 1\n#define PAD_CHAN2 2\n#define PAD_CHAN3 3\n#define PAD_CHANMAX 4\n\n#define PAD_MOTOR_STOP 0\n#define PAD_MOTOR_RUMBLE 1\n#define PAD_MOTOR_STOP_HARD 2\n\n#define PAD_ERR_NONE 0\n#define PAD_ERR_NO_CONTROLLER -1\n#define PAD_ERR_NOT_READY -2\n#define PAD_ERR_TRANSFER -3\n\n#define PAD_BUTTON_LEFT 0x0001\n#define PAD_BUTTON_RIGHT 0x0002\n#define PAD_BUTTON_DOWN 0x0004\n#define PAD_BUTTON_UP 0x0008\n#define PAD_TRIGGER_Z 0x0010\n#define PAD_TRIGGER_R 0x0020\n#define PAD_TRIGGER_L 0x0040\n#define PAD_BUTTON_A 0x0100\n#define PAD_BUTTON_B 0x0200\n#define PAD_BUTTON_X 0x0400\n#define PAD_BUTTON_Y 0x0800\n#define PAD_BUTTON_MENU 0x1000\n#define PAD_BUTTON_START 0x1000\n#define PAD_SUBSTICK_LEFT 0x10000\n#define PAD_SUBSTICK_RIGHT 0x20000\n#define PAD_SUBSTICK_DOWN 0x40000\n#define PAD_SUBSTICK_UP 0x80000\n#define PAD_STICK_LEFT 0x1000000\n#define PAD_STICK_RIGHT 0x2000000\n#define PAD_STICK_DOWN 0x4000000\n#define PAD_STICK_UP 0x8000000\n\n#define PAD_CHAN0_BIT 0x80000000\n#define PAD_CHAN1_BIT 0x40000000\n#define PAD_CHAN2_BIT 0x20000000\n#define PAD_CHAN3_BIT 0x10000000\n\n#define PADButtonDown(buttonLast, button) ((((buttonLast) ^ (button)) & (button)))\n\n#define PADButtonUp(buttonLast, button) ((((buttonLast) ^ (button)) & (buttonLast)))\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n    typedef void (*PADSamplingCallback)(void);\n\n    typedef struct PADStatus\n    {\n        u16 button;\n        s8 stickX;\n        s8 stickY;\n        s8 substickX;\n        s8 substickY;\n        u8 triggerLeft;\n        u8 triggerRight;\n        u8 analogA;\n        u8 analogB;\n        s8 err;\n    } PADStatus;\n\n    BOOL PADInit();\n    u32 PADRead(PADStatus *status);\n    BOOL PADReset(u32 mask);\n    BOOL PADRecalibrate(u32 mask);\n    void PADClamp(PADStatus *status);\n    void PADClampCircle(PADStatus *status);\n    void PADControlMotor(s32 chan, u32 cmd);\n    void PADSetSpec(u32 spec);\n    void PADControlAllMotors(const u32 *cmdArr);\n    void PADSetAnalogMode(u32 mode);\n    PADSamplingCallback PADSetSamplingCallback(PADSamplingCallback);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _DOLPHIN_PAD\n/* end \"dolphin/pad.h\" */\n/* \"include\\JSystem\\JUtility\\JUTGamePad.h\" line 6 \"JSystem/Logitech/Wheels.h\" */\n#ifndef LOGITECH_WHEELS_H\n#define LOGITECH_WHEELS_H\n\n/* \"include\\JSystem\\Logitech\\Wheels.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n/* \"include\\JSystem\\Logitech\\Wheels.h\" line 5 \"dolphin/lg.h\" */\n#ifndef DOLPHIN_LG_H\n#define DOLPHIN_LG_H\n\n/* \"include\\dolphin\\lg.h\" line 3 \"dolphin/types.h\" */\n/* end \"dolphin/types.h\" */\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif // ifdef __cplusplus\n\n// This file presumably was for a logitech steering wheel, as it is some sort of controller handler\n\nstruct LGPosition { // seems really similar to PADStatus but is slightly different\n    u16 button;\n    s8 _2;\n    s8 steerDirection;\n    u8 gasPedal;\n    u8 brakePedal;\n    u8 _6; // unknown, are there any other analog buttons?(start maybe)\n    u8 analogL;\n    u8 analogR;\n    s8 err; // -1 probably means disconnected?\n};\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif/* end \"dolphin/lg.h\" */\n\nclass LGWheels\n{ // Autogenerated\npublic:\n    // Global\n    LGWheels();                                     // 0x8007649c\n    void InitVars(s32);                             // 0x80076520\n    void ReadAll();                                 // 0x80076590\n    void StopForce(s32, s32);                       // 0x8007664c\n    bool IsConnected(s32);                          // 0x800769dc\n    void IsPlaying(s32, s32);                       // 0x80076a00\n    void PlayAutoCalibAndSpringForce(s32);          // 0x80076b3c\n    void PlaySpringForce(s32, s8, u8, s16);         // 0x80076c74\n    void SameSpringForceParams(s32, s8, u8, s16);   // 0x80076e98\n    void PlayConstantForce(s32, s16, u16);          // 0x80076ee0\n    void SameConstantForceParams(s32, s16, u16);    // 0x800770d8\n    void PlayDamperForce(s32, s16);                 // 0x8007710c\n    void SameDamperForceParams(s32, s16);           // 0x80077310\n    void PlayDirtRoadEffect(s32, u8);               // 0x80077330\n    void SameDirtRoadEffectParams(s32, s16);        // 0x80077560\n    void PlayBumpyRoadEffect(s32, u8);              // 0x80077580\n    void StopBumpyRoadEffect(s32);                  // 0x800777b0\n    void SameBumpyRoadEffectParams(s32, s16);       // 0x800777d4\n    void PlaySlipperyRoadEffect(s32, s16);          // 0x800777f4\n    void StopSlipperyRoadEffect(s32);               // 0x80077a90\n    void SameSlipperyRoadEffectParams(s32, s16);    // 0x80077ab4\n    void PlaySurfaceEffect(s32, u8, u8, u16);       // 0x80077ad4\n    void SameSurfaceEffectParams(s32, u8, u8, u16); // 0x80077e20\n    void PlayCarAirborne(s32);                      // 0x80077e64\n    void StopCarAirborne(s32);                      // 0x8007804c\n    // Inline/Unused\n    // void ~LGWheels();\n    // void ButtonTriggered(s32, u32);\n    // void ButtonReleased(s32, u32);\n    // void ButtonIsPressed(s32, u32);\n    // void PedalsConnected(s32);\n    // void PowerConnected(s32);\n    // void SetOverallForceGain(s32, s32);\n    // void GetOverallForceGain(s32);\n    // void GenerateNonLinValues(s32, u8);\n    // void StopSpringForce(s32);\n    // void StopConstantForce(s32);\n    // void StopDamperForce(s32);\n    // void PlaySideCollisionForce(s32, s16, u16);\n    // void SameSideCollisionForceParams(s32, s16, u16);\n    // void PlayFrontalCollisionForce(s32, u8);\n    // void SameFrontalCollisionForceParams(s32, s16);\n    // void StopDirtRoadEffect(s32);\n    // void StopSurfaceEffect(s32);\n\n    LGPosition &getPosition(int idx) {return mPosition[idx]; }\n\n    LGPosition mPosition[4];\n    u8 _28[0x1440]; // TODO\n}; // Size: 0x1468\n#endif // LOGITECH_WHEELS_H\n/* end \"JSystem/Logitech/Wheels.h\" */\n/* \"include\\JSystem\\JUtility\\JUTGamePad.h\" line 7 \"JSystem/JUtility/JUTAssert.h\" */\n/* end \"JSystem/JUtility/JUTAssert.h\" */\n/* \"include\\JSystem\\JUtility\\JUTGamePad.h\" line 8 \"JSystem/JKernel/JKRDisposer.h\" */\n/* end \"JSystem/JKernel/JKRDisposer.h\" */\n\n// this currently is need to match testButton and testTrigger, if the entire file uses o4,p is unknown to me\n#pragma push\n#pragma optimize_for_size off\nclass JUTGamePadRecordBase\n{\npublic:\n    JUTGamePadRecordBase();\n    virtual ~JUTGamePadRecordBase();\n    virtual void read(PADStatus *status) = 0;\n    virtual void write(PADStatus *) = 0;\n\n    bool mActive;\n    /* more that are unknown */\n\n    bool isActive() const { return this->mActive; }\n};\n\nstruct JUTGamePadLongPress\n{\n    static JSUList<JUTGamePadLongPress> sPatternList;\n    void checkCallback(int port, u32 timer);\n\n    u32 getMaskPattern() const { return mMaskPattern; }\n    u32 getPattern() const { return mPattern; }\n    bool isValid() const { return mValid; }\n\n    u8 _0[0x10];\n    bool mValid;\n    bool _11;\n    u32 mPattern;\n    u32 mMaskPattern;\n    u32 _1C;\n    bool _20[PAD_CONTROLLER_NUM];\n    OSTime mTimer[PAD_CONTROLLER_NUM];\n    bool _48[PAD_CONTROLLER_NUM];\n    void (*mCallback)(int, JUTGamePadLongPress *, int);\n    int _50;\n};\n\ntypedef void (*JUTResetBtnCb)(int, void*);\nclass JUTGamePad : public JKRDisposer\n{\npublic:\n    enum EPadPort\n    {\n        Port_unknown = -999,\n        Port_Invalid = -1,\n        Port1 = 0,\n        Port2,\n        Port3,\n        Port4,\n        PortRecorder\n    };\n\n    enum EButtons\n    {\n        MAINSTICK_UP = 0x8000000,\n        MAINSTICK_DOWN = 0x4000000,\n        MAINSTICK_RIGHT = 0x2000000,\n        MAINSTICK_LEFT = 0x1000000,\n        CSTICK_UP = 0x80000,\n        CSTICK_DOWN = 0x40000,\n        CSTICK_RIGHT = 0x20000,\n        CSTICK_LEFT = 0x10000,\n        START = 0x1000,\n        Y = 0x800,\n        X = 0x400,\n        B = 0x200,\n        A = 0x100,\n        L = 0x40,\n        R = 0x20,\n        Z = 0x10,\n        DPAD_UP = 0x8,\n        DPAD_DOWN = 0x4,\n        DPAD_RIGHT = 0x2,\n        DPAD_LEFT = 0x1\n    };\n\n    enum EStickMode\n    {\n        NonClamped,\n        Clamped\n    };\n\n    enum EClampMode\n    {\n        NoClamp,\n        Clamp,\n        ClampCircle\n    };\n\n    enum EWhichStick\n    {\n        WhichStick_MainStick,\n        WhichStick_SubStick\n    };\n\n    JUTGamePad();\n    JUTGamePad(EPadPort port);\n    virtual ~JUTGamePad();\n\n    void assign();\n    void checkResetCallback(OSTime time);\n    void clearForReset();\n    static void init();\n    void initList();\n    static u32 read();\n    static bool recalibrate(u32);\n    void setButtonRepeat(u32, u32, u32);\n    void update();\n    void clear();\n\n    static void checkResetSwitch();\n\n    static bool mListInitialized;\n    static u8 mPadAssign[PAD_CONTROLLER_NUM];\n    static u32 sSuppressPadReset;\n    static bool sErrorReport;\n    static u32 sAnalogMode;\n    static u32 sRumbleSupported;\n    static s32 msaSIType[PAD_CONTROLLER_NUM]; // check type?\n\n    static void setAnalogMode(u32 mode)\n    {\n        JUTGamePad::sAnalogMode = mode;\n        PADSetAnalogMode(mode);\n    }\n\n    static void setResetCallback(JUTResetBtnCb callback, void *arg)\n    {\n        C3ButtonReset::sCallback = callback;\n        C3ButtonReset::sCallbackArg = arg;\n    }\n\n    static void clearResetOccurred()\n    {\n        C3ButtonReset::sResetOccurred = false;\n    }\n\n    static EClampMode getClampMode()\n    {\n        return JUTGamePad::sClampMode;\n    }\n\n    static s8 getPortStatus(EPadPort port)\n    {\n        JUT_ASSERT(0 <= port && port < 4);\n        return mPadStatus[port].err;\n    }\n\n    bool isPushing3ButtonReset() const\n    {\n        bool pushing = false;\n\n        if (this->mPortNum != -1 && this->mButtonReset.mReset != false)\n        {\n            pushing = true;\n        }\n\n        return pushing;\n    }\n\n    int getErrorStatus() const\n    {\n        return this->mErrorStatus;\n    }\n\n    u8 getAnalogR() const\n    {\n        return this->mButtons.mAnalogR;\n    }\n\n    f32 getAnalogRf() const\n    {\n        return this->mButtons.mAnalogRf;\n    }\n\n    u8 getAnalogL() const\n    {\n        return this->mButtons.mAnalogL;\n    }\n\n    f32 getAnalogLf() const\n    {\n        return this->mButtons.mAnalogLf;\n    }\n\n    u8 getAnalogB() const\n    {\n        return this->mButtons.mAnalogB;\n    }\n\n    u8 getAnalogA() const\n    {\n        return this->mButtons.mAnalogA;\n    }\n\n    int getSubStickAngle() const\n    {\n        return this->mSubStick.mAngle;\n    }\n\n    f32 getSubStickValue() const\n    {\n        return this->mSubStick.mValue;\n    }\n\n    f32 getSubStickY() const\n    {\n        return this->mSubStick.mY;\n    }\n\n    f32 getSubStickX() const\n    {\n        return this->mSubStick.mX;\n    }\n\n    int getMainStickAngle() const\n    {\n        return this->mMainStick.mAngle;\n    }\n\n    f32 getMainStickValue() const\n    {\n        return this->mMainStick.mValue;\n    }\n\n    f32 getMainStickY() const\n    {\n        return this->mMainStick.mY;\n    }\n\n    f32 getMainStickX() const\n    {\n        return this->mMainStick.mX;\n    }\n\n    u32 getTrigger() const\n    {\n        return this->mButtons.mTrigger;\n    }\n\n    u32 getButton() const\n    {\n        return this->mButtons.mButton;\n    }\n\n    u32 getRelease() const\n    {\n        return this->mButtons.mRelease;\n    }\n\n    u32 getRepeat() const\n    {\n        return this->mButtons.mRepeat;\n    }\n\n    bool testButton(u32 mask) const\n    {\n        return this->mButtons.mButton & mask;\n    }\n\n    bool testTrigger(u32 mask) const\n    {\n        return this->mButtons.mTrigger & mask;\n    }\n\n    int getPortNum() const\n    {\n        return this->mPortNum;\n    }\n\n    JUTGamePadRecordBase *getPadRecord() const\n    {\n        return this->mPadRecord;\n    }\n\n    JUTGamePadRecordBase *getPadReplay() const\n    {\n        return this->mPadReplay;\n    }\n\n    inline void stopMotorHard() {\n        CRumble::stopMotorHard(this->mPortNum);\n    }\n\n    class CButton\n    {\n    public:\n        CButton() { this->clear(); };\n\n        void clear();\n        void update(const PADStatus *padStatus, u32 buttons);\n        void update(const LGPosition *padStatus, u32 buttons);\n        void setRepeat(u32 mask, u32 delay, u32 frequency);\n\n        u32 mButton;           // buttons held down\n        u32 mTrigger;          // buttons newly pressed this frame\n        u32 mRelease;          // buttons released this frame\n        u8 mAnalogA;           //\n        u8 mAnalogB;           //\n        u8 mAnalogL;           // left trigger percent\n        u8 mAnalogR;           // right trigger percent\n        f32 mAnalogLf;         // left trigger analog percent\n        f32 mAnalogRf;         // right trigger analog percent\n        u32 mRepeat;           // buttons currently marked as \"repeated\" triggers when held\n        u32 mRepeatTimer;      // frames since current button combo has been held\n        u32 mRepeatLastButton; // last buttons pressed\n        u32 mRepeatMask;       // button mask to allow repeating trigger inputs\n        u32 mRepeatDelay;      // delay before beginning repeated input\n        u32 mRepeatFrequency;  // repeat input every X frames\n    };\n\n    class CStick\n    {\n    public:\n        CStick() {\n            clear();\n        }\n\n        void clear();\n        u32 update(s8 x, s8 y, JUTGamePad::EStickMode, JUTGamePad::EWhichStick); // old or non mkdd version?\n        u32 update(s8 x, s8 y, JUTGamePad::EStickMode, JUTGamePad::EWhichStick, u32);\n        u32 update(s8, u32);\n        u32 getButton(u32);\n\n        f32 mX;\n        f32 mY;\n        f32 mValue;\n        s16 mAngle;\n        s8 mAnalogX;\n        s8 mAnalogY;\n    };\n\n    class CRumble\n    {\n    public:\n        enum ERumble\n        {\n            Rumble0,\n            Rumble1,\n            Rumble2\n        };\n\n        CRumble(JUTGamePad *gamePad) { this->clear(gamePad); }\n\n        static u8 mStatus[PAD_CONTROLLER_NUM];\n        static u32 mEnabled;\n\n        static void startMotor(int port);\n        static void stopMotor(int port, bool hard);\n        static void stopMotorHard(int port)\n        {\n            stopMotor(port, true);\n        }\n\n        static bool isEnabledPort(int port) {\n            return (0 <= port && port < 4) ? isEnabled(sChannelMask[port]) : false;\n        } \n        static bool isEnabled(u32 channel)\n        {\n            return (JUTGamePad::CRumble::mEnabled & channel) ? true : false;\n        }\n\n        void clear();\n        void clear(JUTGamePad *gamePad);\n        void update(s16);\n        void setEnable(u32);\n\n        static u32 sChannelMask[4];\n\n        u32 mFrame;\n        u32 mLength;\n        u8 *mData;\n        u32 mFrameCount;\n        u8 *_10;\n    };\n\n    class C3ButtonReset {\n    public:\n        C3ButtonReset() { mReset = false; }\n\n        static u32 sResetPattern;\n        static u32 sResetMaskPattern;\n        static JUTResetBtnCb sCallback;\n        static void *sCallbackArg;\n        static OSTime sThreshold;\n        static s32 sResetOccurredPort;\n        static bool sResetOccurred;\n        static bool sResetSwitchPushing;\n\n        bool mReset;\n    };\n\n    static bool isPadOk() { // fabricated\n        bool ret = false;\n        switch(mPadStatus[0].err) {\n        case -1:\n        case 0:\n            ret = true;\n            break;\n        }\n        return ret;        \n    }\n\n    static LGWheels* getLGWheels() { return mspLGWheels; }\n    static PADStatus *getPadStatus(int idx) { return &mPadStatus[idx]; }\n\n    static LGWheels *mspLGWheels;\n    static JSUList<JUTGamePad> mPadList;\n    static CButton mPadButton[PAD_CONTROLLER_NUM];\n    static CStick mPadMStick[PAD_CONTROLLER_NUM];\n    static CStick mPadSStick[PAD_CONTROLLER_NUM];\n    static EStickMode sStickMode;\n    static EClampMode sClampMode;\n    static f32 sPressPoint;\n    static f32 sReleasePoint;\n    static PADStatus mPadStatus[PAD_CONTROLLER_NUM];\n\n    CButton mButtons;          // _18\n    CStick mMainStick;         // _48\n    CStick mSubStick;          // _58\n    CRumble mRumble;           // _68\n    s16 mPortNum;              // _7C\n    s8 mErrorStatus;           // _7E\n    JSULink<JUTGamePad> mLink; // _80\n    JUTGamePadRecordBase *mPadRecord;\n    JUTGamePadRecordBase *mPadReplay;\n    C3ButtonReset mButtonReset; // _98\n    OSTime mResetTime;          // _A0\n};\n#pragma pop\n#endif\n/* end \"JSystem/JUtility/JUTGamePad.h\" */\n/* \"include\\JSystem\\JUtility\\JUTException.h\" line 7 \"JSystem/JUtility/JUTExternalFB.h\" */\n#ifndef _JSYSTEM_JUT_JUTEXTERNALFB_H\n#define _JSYSTEM_JUT_JUTEXTERNALFB_H\n\n/* \"include\\JSystem\\JUtility\\JUTExternalFB.h\" line 3 \"dolphin/gx.h\" */\n/* end \"dolphin/gx.h\" */\n/* \"include\\JSystem\\JUtility\\JUTExternalFB.h\" line 4 \"types.h\" */\n/* end \"types.h\" */\n\nstruct JUTExternalFB\n{\n    JUTExternalFB(GXRenderModeObj *, GXGamma, void *, u32);\n\n    GXRenderModeObj *mRenderModeObj; // _00\n    u32 mSize;                       // _04\n    u8 _08[4];                       // _08\n    u16 _0C;                         // _0C\n    u16 mGamma;                      // _0E, treat as GXGamma\n    bool _10;                        // _10\n};\n\n#endif/* end \"JSystem/JUtility/JUTExternalFB.h\" */\n/* \"include\\JSystem\\JUtility\\JUTException.h\" line 8 \"types.h\" */\n/* end \"types.h\" */\n\nstruct JUTConsole;\nstruct JUTDirectPrint;\n\ntypedef void (*JUTErrorHandler)(OSError error, OSContext *context, u32 p3, u32 p4);\n\nenum ExPrintFlags\n{\n    EXPRINTFLAG_GPR = 0x1,\n    EXPRINTFLAG_GPRMap = 0x2,\n    EXPRINTFLAG_SRR0Map = 0x4,\n    EXPRINTFLAG_Float = 0x8,\n    EXPRINTFLAG_Stack = 0x10,\n\n    EXPRINTFLAG_All = 0x1F,\n};\n\n/**\n * @size{0xA4}\n */\nstruct JUTException : public JKRThread\n{\n    enum EInfoPage\n    {\n        INFOPAGE_GPR = 1,\n        INFOPAGE_Float = 2,\n        INFOPAGE_Stack = 3,\n        INFOPAGE_GPRMap = 4,\n        INFOPAGE_SRR0Map = 5,\n    };\n\n    // size: 0x14\n    struct JUTExMapFile\n    {\n        inline JUTExMapFile(const char *fileName)\n            : mLink(this)\n        {\n            mFileName = (char *)fileName;\n        }\n\n        char *mFileName;       // _00\n        JSULink<JUTExMapFile> mLink; // _04\n    };\n\n    /** @fabricated */\n    struct ExCallbackObject\n    {\n        JUTErrorHandler mErrorHandler; // _00\n        OSError mError;               // _04\n        OSContext *mContext;          // _08\n        u32 _0C;                      // _0C\n        u32 _10;                      // _10\n    };\n\n    JUTException(JUTDirectPrint *); // unused/inlined\n\n    virtual ~JUTException(){}; // _08 (weak)\n    virtual void *run();       // _0C\n\n    void showFloat(OSContext *);\n    void showStack(OSContext *);\n    void showMainInfo(u16, OSContext *, u32, u32);\n    bool showMapInfo_subroutine(u32, bool);\n    void showGPRMap(OSContext *);\n    void printDebugInfo(JUTException::EInfoPage, u16, OSContext *, u32, u32);\n    bool readPad(u32 *, u32 *);\n    void printContext(u16, OSContext *, u32, u32);\n    void createFB();\n\n    static void waitTime(long);\n    static JUTErrorHandler setPreUserCallback(JUTErrorHandler);\n    static void appendMapFile(const char *);\n    static bool queryMapAddress(char *, u32, long, u32 *, u32 *, char *, u32, bool, bool);\n    static bool queryMapAddress_single(char *, u32, long, u32 *, u32 *, char *, u32, bool, bool);\n\n    static JUTException *create(JUTDirectPrint *);\n    static void createConsole(void *buffer, u32 bufferSize);\n    static void panic_f(const char *file, int line, const char *msg, ...);\n    static void errorHandler(u16, OSContext *, u32, u32);\n    static void setFPException(u32);\n    static bool searchPartialModule(u32, u32 *, u32 *, u32 *, u32 *);\n\n    // unused/inlined:\n    static void panic_f_va(const char *, int, const char *, va_list);\n    static JUTErrorHandler setPostUserCallback(JUTErrorHandler);\n\n    // Inline\n    static void panic(const char *file, int line, const char *msg) {\n        panic_f(file, line, \"%s\", msg);\n    }\n\n    void showFloatSub(int, f32);\n    void showGPR(OSContext *);\n    void showSRR0Map(OSContext *);\n    bool isEnablePad() const;\n    u32 getFpscr();\n    void setFpscr(u32);\n    void enableFpuException();\n    void disableFpuException();\n\n    JUTExternalFB *getFrameMemory() const { return mFrameMemory; }\n\n    void setTraceSuppress(u32 supress) { mTraceSuppress = supress; }\n    void setGamePad(JUTGamePad *gamePad)\n    {\n        mGamePad = gamePad;\n        mPadPort = JUTGamePad::Port_Invalid;\n    }\n\n    static JUTException *getManager() { return sErrorManager; }\n    static JUTConsole *getConsole() { return sConsole; }\n\n    static JUTConsole *sConsole;\n    static void *sConsoleBuffer;\n    static size_t sConsoleBufferSize;\n    static JUTException *sErrorManager;\n    static OSMessageQueue sMessageQueue;\n    static void *sMessageBuffer[1];\n    static JUTErrorHandler sPreUserCallback;\n    static JUTErrorHandler sPostUserCallback;\n    static u32 msr;\n    static u32 fpscr;\n    static const char *sCpuExpName[OS_ERROR_MAX];\n    static JSUList<JUTExMapFile> sMapFileList;\n\n    // _00     = VTBL\n    // _00-_7C = JKRThread\n    JUTExternalFB *mFrameMemory;   // _7C\n    JUTDirectPrint *mDirectPrint;  // _80\n    JUTGamePad *mGamePad;          // _84\n    JUTGamePad::EPadPort mPadPort; // _88\n    int mPrintWaitTime0;           // _8C\n    int mPrintWaitTime1;           // _90\n    u32 mTraceSuppress;            // _94\n    u32 _98;                       // _98\n    u32 mPrintFlags;               // _9C, see ExPrintFlags enum\n    u32 mStackPointer;                 // _A0\n};\n\n#endif\n/* end \"JSystem/JUtility/JUTException.h\" */\n\n// Panic functions\n#define JUT_PANIC(MSG) \\\n  JUTException::panic(__FILE__, __LINE__, MSG);\n#define JUT_PANIC_F(...) \\\n  JUTException::panic_f(__FILE__, __LINE__, __VA_ARGS__);\n\n#endif/* end \"JSystem/JUtility/JUTDbg.h\" */\n/* \"include\\JSystem\\JAudio\\Interface\\JAISound.h\" line 4 \"JSystem/JAudio/Interface/JAIAudible.h\" */\n#ifndef JAUDIO_JAIAUDIBLE_H\n#define JAUDIO_JAIAUDIBLE_H\n\n/* \"include\\JSystem\\JAudio\\Interface\\JAIAudible.h\" line 3 \"JSystem/JGeometry.h\" */\n#ifndef JGEOMETRY_PUBLIC_H\n#define JGEOMETRY_PUBLIC_H\n\n/* \"include\\JSystem\\JGeometry.h\" line 3 \"JSystem/JGeometry/Vec.h\" */\n#ifndef JGEOMETRY_VEC_H\n#define JGEOMETRY_VEC_H\n\n/* \"include\\JSystem\\JGeometry\\Vec.h\" line 3 \"JSystem/JGeometry/Util.h\" */\n#ifndef JGEOMETRY_UTIL_H\n#define JGEOMETRY_UTIL_H\n\n/* \"include\\JSystem\\JGeometry\\Util.h\" line 3 \"math.h\" */\n#ifndef _MATH_H\n#define _MATH_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\math.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\math.h\" line 4 \"PowerPC_EABI_Support/MSL_C/MSL_Common/math_api.h\" */\n#ifndef _MSL_MATH_API_H\n#define _MSL_MATH_API_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\math_api.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\math_api.h\" line 4 \"fdlibm.h\" */\n#ifndef _FDLIBM_H\n#define _FDLIBM_H\n\n/* @(#)fdlibm.h 1.5 04/04/22 */\n/*\n * ====================================================\n * Copyright (C) 2004 by Sun Microsystems, Inc. All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this\n * software is freely granted, provided that this notice\n * is preserved.\n * ====================================================\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* Sometimes it's necessary to define __LITTLE_ENDIAN explicitly\n   but these catch some common cases. */\n\n#if defined(i386) || defined(i486) || defined(intel) || defined(x86) || defined(i86pc) || defined(__alpha) || defined(__osf__)\n#define __LITTLE_ENDIAN\n#endif\n\n#ifdef __LITTLE_ENDIAN\n#define __HI(x)  *(1 + (int*)&x)\n#define __LO(x)  *(int*)&x\n#define __HIp(x) *(1 + (int*)x)\n#define __LOp(x) *(int*)x\n#else\n#define __HI(x)  *(int*)&x\n#define __LO(x)  *(1 + (int*)&x)\n#define __HIp(x) *(int*)x\n#define __LOp(x) *(1 + (int*)x)\n#endif\n\n// TODO: should __STDC__ actually be defined?\n// #ifdef __STDC__\n#define __P(p) p\n// #else\n// #define __P(p) ()\n// #endif\n\n/*\n * ANSI/POSIX\n */\n\nextern int signgam;\n\n#define MAXFLOAT ((float)3.40282346638528860e+38)\n\nenum fdversion { fdlibm_ieee = -1, fdlibm_svid, fdlibm_xopen, fdlibm_posix };\n\n#define _LIB_VERSION_TYPE enum fdversion\n#define _LIB_VERSION      _fdlib_version\n\n/* if global variable _LIB_VERSION is not desirable, one may\n * change the following to be a constant by:\n *\t#define _LIB_VERSION_TYPE const enum version\n * In that case, after one initializes the value _LIB_VERSION (see\n * s_lib_version.c) during compile time, it cannot be modified\n * in the middle of a program\n */\nextern _LIB_VERSION_TYPE _LIB_VERSION;\n\n#define _IEEE_  fdlibm_ieee\n#define _SVID_  fdlibm_svid\n#define _XOPEN_ fdlibm_xopen\n#define _POSIX_ fdlibm_posix\n\nstruct exception {\n\tint type;\n\tchar* name;\n\tdouble arg1;\n\tdouble arg2;\n\tdouble retval;\n};\n\n#define HUGE MAXFLOAT\n\n/*\n * set X_TLOSS = pi*2**52, which is possibly defined in <values.h>\n * (one may replace the following line by \"#include <values.h>\")\n */\n\n#define X_TLOSS 1.41484755040568800000e+16\n\n#define DOMAIN    1\n#define SING      2\n#define OVERFLOW  3\n#define UNDERFLOW 4\n#define TLOSS     5\n#define PLOSS     6\n\n/*\n * ANSI/POSIX\n */\nextern double acos __P((double));\nextern double asin __P((double));\nextern double atan __P((double));\nextern double atan2 __P((double, double));\nextern double cos __P((double));\nextern double sin __P((double));\nextern double tan __P((double));\n\nextern double cosh __P((double));\nextern double sinh __P((double));\nextern double tanh __P((double));\n\nextern double exp __P((double));\nextern double frexp __P((double, int*));\nextern double ldexp __P((double, int));\nextern double scalbn __P((double, int));\nextern double log __P((double));\nextern double log10 __P((double));\nextern double modf __P((double, double*));\n\nextern double pow __P((double, double));\nextern double sqrt __P((double));\n\nextern double ceil __P((double));\nextern double fabs __P((double));\nextern double floor __P((double));\nextern double fmod __P((double, double));\n\nextern double erf __P((double));\nextern double erfc __P((double));\nextern double gamma __P((double));\nextern double hypot __P((double, double));\nextern int isnan __P((double));\nextern int finite __P((double));\nextern double j0 __P((double));\nextern double j1 __P((double));\nextern double jn __P((int, double));\nextern double lgamma __P((double));\nextern double y0 __P((double));\nextern double y1 __P((double));\nextern double yn __P((int, double));\n\nextern double acosh __P((double));\nextern double asinh __P((double));\nextern double atanh __P((double));\nextern double cbrt __P((double));\nextern double logb __P((double));\nextern double nextafter __P((double, double));\nextern double remainder __P((double, double));\n#ifdef _SCALB_INT\nextern double scalb __P((double, int));\n#else\nextern double scalb __P((double, double));\n#endif\n\nextern int matherr __P((struct exception*));\n\n/*\n * IEEE Test Vector\n */\nextern double significand __P((double));\n\n/*\n * Functions callable from C, intended to support IEEE arithmetic.\n */\nextern double copysign __P((double, double));\nextern int ilogb __P((double));\nextern double rint __P((double));\nextern double scalbn __P((double, int));\n\n/*\n * BSD math library entry points\n */\nextern double expm1 __P((double));\nextern double log1p __P((double));\n\n/*\n * Reentrant version of gamma & lgamma; passes signgam back by reference\n * as the second argument; user must allocate space for signgam.\n */\n#ifdef _REENTRANT\nextern double gamma_r __P((double, int*));\nextern double lgamma_r __P((double, int*));\n#endif /* _REENTRANT */\n\n/* ieee style elementary functions */\nextern double __ieee754_sqrt __P((double));\nextern double __ieee754_acos __P((double));\nextern double __ieee754_acosh __P((double));\nextern double __ieee754_log __P((double));\nextern double __ieee754_atanh __P((double));\nextern double __ieee754_asin __P((double));\nextern double __ieee754_atan2 __P((double, double));\nextern double __ieee754_exp __P((double));\nextern double __ieee754_cosh __P((double));\nextern double __ieee754_fmod __P((double, double));\nextern double __ieee754_pow __P((double, double));\nextern double __ieee754_lgamma_r __P((double, int*));\nextern double __ieee754_gamma_r __P((double, int*));\nextern double __ieee754_lgamma __P((double));\nextern double __ieee754_gamma __P((double));\nextern double __ieee754_log10 __P((double));\nextern double __ieee754_sinh __P((double));\nextern double __ieee754_hypot __P((double, double));\nextern double __ieee754_j0 __P((double));\nextern double __ieee754_j1 __P((double));\nextern double __ieee754_y0 __P((double));\nextern double __ieee754_y1 __P((double));\nextern double __ieee754_jn __P((int, double));\nextern double __ieee754_yn __P((int, double));\nextern double __ieee754_remainder __P((double, double));\nextern int __ieee754_rem_pio2 __P((double, double*));\n#ifdef _SCALB_INT\nextern double __ieee754_scalb __P((double, int));\n#else\nextern double __ieee754_scalb __P((double, double));\n#endif\n\n/* fdlibm kernel function */\nextern double __kernel_standard __P((double, double, int));\nextern double __kernel_sin __P((double, double, int));\nextern double __kernel_cos __P((double, double));\nextern double __kernel_tan __P((double, double, int));\nextern int __kernel_rem_pio2 __P((double*, double*, int, int, int, const int*));\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n/* \"libs\\PowerPC_EABI_Support\\include\\fdlibm.h\" line 227 \"math.h\" */\n/* end \"math.h\" */\n\n#endif\n/* end \"fdlibm.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\nint __fpclassifyf(float);\nint __signbitd(double);\nint __fpclassifyd(double);\n\ninline int __fpclassifyf(f32 x)\n{\n\tswitch ((*(s32*)&x) & 0x7f800000) {\n\tcase 0x7f800000: {\n\t\tif ((*(s32*)&x) & 0x007fffff)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 2;\n\t\tbreak;\n\t}\n\tcase 0: {\n\t\tif ((*(s32*)&x) & 0x007fffff)\n\t\t\treturn 5;\n\t\telse\n\t\t\treturn 3;\n\t\tbreak;\n\t}\n\t}\n\treturn 4;\n}\ninline int __fpclassifyd(f64 x)\n{\n\tswitch (__HI(x) & 0x7ff00000) {\n\tcase 0x7ff00000: {\n\t\tif ((__HI(x) & 0x000fffff) || (__LO(x) & 0xffffffff))\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 2;\n\t\tbreak;\n\t}\n\tcase 0: {\n\t\tif ((__HI(x) & 0x000fffff) || (__LO(x) & 0xffffffff))\n\t\t\treturn 5;\n\t\telse\n\t\t\treturn 3;\n\t\tbreak;\n\t}\n\t}\n\treturn 4;\n}\n\n#define fpclassify(x) ((sizeof(x) == sizeof(float)) ? __fpclassifyf((float)(x)) : __fpclassifyd((double)(x)))\n\n#define isinf(x) ((fpclassify(x) == 2))\n#define isnan(x) ((fpclassify(x) == 1))\n#define isfinite(x) ((fpclassify(x) > 2))\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/math_api.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n#ifndef __MWERKS__\n// Get clangd to shut up about __fabs being undefined.\n#define __fabs(x)    (x)\n#define __frsqrte(x) (x)\n#endif\n\n#define FABS(x) (float)__fabs(x)\n// #define __frsqrtes opword\n\n#define SQUARE(v) ((v) * (v))\n\n#define signbit(x) ((int)(__HI(x) & 0x80000000))\n\n#define TAU     6.2831855f\n#define PI      3.1415927f\n#define HALF_PI 1.5707964f\n\n#define LONG_TAU 6.2831854820251465\n\nextern int __float_nan[];\nextern int __float_huge[];\nextern int __double_huge[];\n\n#define INFINITY (*(float*)__float_huge)\n#define NAN      (*(float*)__float_nan)\n#define HUGE_VAL (*(double*)__double_huge)\n\ninline long double fabsl(long double x) { return __fabs((double)x); }\n\ninline double fabs(double x) { return __fabs(x); }\n\ndouble acos(double);\ndouble asin(double);\ndouble atan(double);\ndouble atan2(double, double);\ndouble ceil(double);\ndouble floor(double);\ndouble frexp(double, int*);\ndouble ldexp(double, int);\ndouble sqrt(double);\n\ndouble pow(double, double);\n\ndouble log(double);\ndouble log10(double);\n\ndouble fmod(double, double);\n\ndouble sin(double x);\ndouble cos(double x);\n\ndouble __ieee754_acos(double);\ndouble __ieee754_fmod(double, double);\ndouble __ieee754_log(double);\ndouble __ieee754_log10(double);\ndouble __ieee754_pow(double, double);\ndouble __ieee754_sqrt(double);\ndouble __ieee754_atan2(double, double);\ndouble __ieee754_asin(double);\n\ndouble scalbn(double, int);\n\ndouble __kernel_sin(double, double, int);\ndouble __kernel_cos(double, double);\ndouble __kernel_tan(double, double, int);\n\nint __ieee754_rem_pio2(double, double*);\n\nstatic inline float atan2f(float y, float x) { return atan2(y, x); }\n\n// float sqrtf(float);\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"math.h\" */\n/* \"include\\JSystem\\JGeometry\\Util.h\" line 4 \"JSystem/JMath/JMath.h\" */\n#ifndef JMATH_H\n#define JMATH_H\n\n/* \"include\\JSystem\\JMath\\JMath.h\" line 3 \"math.h\" */\n/* end \"math.h\" */\n/* \"include\\JSystem\\JMath\\JMath.h\" line 4 \"float.h\" */\n#ifndef _FLOAT_H\n#define _FLOAT_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\nextern int __double_max[];\nextern int __extended_min[];\nextern int __extended_max[];\nextern int __float_max[];\nextern int __float_epsilon[];\n\n#define FLT_MANT_DIG   24\n#define FLT_DIG        6\n#define FLT_MIN_EXP    (-125)\n#define FLT_MIN_10_EXP (-37)\n#define FLT_MAX_EXP    128\n#define FLT_MAX_10_EXP 38\n\n//#define FLT_MAX 0x1.fffffeP127F\n//#define FLT_EPSILON 0x1.000000P-23F\n#define FLT_MIN 0x1.000000P-126F\n\n#define FLT_MAX     (*(float*)__float_max)\n#define FLT_EPSILON (*(float*)__float_epsilon)\n\n#define DBL_MANT_DIG   53\n#define DBL_DIG        15\n#define DBL_MIN_EXP    (-1021)\n#define DBL_MIN_10_EXP (-308)\n#define DBL_MAX_EXP    1024\n#define DBL_MAX_10_EXP 308\n\n//#define DBL_MAX 0x1.fffffffffffffP1023\n#define DBL_EPSILON 0x1.0000000000000P-52\n#define DBL_MIN     0x1.0000000000000P-1022\n\n#define DBL_MAX (*(double*)__double_max)\n\n#define LDBL_MANT_DIG   53\n#define LDBL_DIG        15\n#define LDBL_MIN_EXP    (-1021)\n#define LDBL_MIN_10_EXP (-308)\n#define LDBL_MAX_EXP    1024\n#define LDBL_MAX_10_EXP 308\n\n//#define LDBL_MAX 0x1.fffffffffffffP1023L\n#define LDBL_EPSILON 0x1.0000000000000P-52L\n//#define LDBL_MIN 0x1.0000000000000P-1022L\n\n#define LDBL_MAX (*(long double*)__extended_max)\n#define LDBL_MIN (*(long double*)__extended_min)\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"float.h\" */\n\n/* \"include\\JSystem\\JMath\\JMath.h\" line 6 \"utility\" */\n#ifndef _STD_PAIR_H\n#define _STD_PAIR_H\n\nnamespace std {\ntemplate <typename T1, typename T2>\nstruct pair {\n\tT1 first;\n\tT2 second;\n};\n\ntemplate <>\nstruct pair<float, float> {\n\tpair()\n\t    : first(0.0f)\n\t    , second(0.0f) {};\n\tfloat first;\n\tfloat second;\n};\n} // namespace std\n\n#endif\n/* end \"utility\" */\n/* \"include\\JSystem\\JMath\\JMath.h\" line 7 \"dolphin/mtx.h\" */\n#ifndef _DOLPHIN_MTX_H\n#define _DOLPHIN_MTX_H\n\n/* \"include\\dolphin\\mtx.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif // ifdef __cplusplus\n\n    typedef float Mtx[3][4];\n    typedef float (*MtxPtr)[4];\n    typedef float Mtx23[2][3];\n    typedef float Mtx33[3][3];\n    typedef float Mtx44[4][4];\n    typedef float PSQuaternion[4];\n\n    typedef struct\n    {\n        f32 x, y, z;\n    } Vec, *VecPtr;\n\n    typedef struct\n    {\n        s16 x, y, z;\n    } S16Vec, *S16VecPtr;\n\n    typedef struct\n    {\n        f32 x, y, z, w;\n    } Quaternion, *QuaternionPtr;\n\n\n#define MTXDegToRad(a) ((a)*0.01745329252f)\n\n    // Paired single versions\n\n    void PSMTXIdentity(Mtx m);\n    void PSMTXCopy(const Mtx src, Mtx dst);\n    void PSMTXConcat(const Mtx a, const Mtx b, Mtx ab);\n    void PSMTXConcatArray(const Mtx a, const Mtx *srcBase, Mtx *dstBase, u32 count);\n    void PSMTXTranspose(const Mtx src, Mtx xPose);\n    u32 PSMTXInverse(const Mtx src, Mtx inv);\n    u32 PSMTXInvXpose(const Mtx src, Mtx invX);\n    void PSMTXMultVec(const Mtx m, const Vec *src, Vec *dst);\n    void PSMTXMultVecArray(const Mtx m, const Vec *srcBase, Vec *dstBase, u32 count);\n    void PSMTXMultVecSR(const Mtx m, const Vec *src, Vec *dst);\n    void PSMTXMultVecArraySR(const Mtx m, const Vec *srcBase, Vec *dstBase, u32 count);\n    void PSMTXQuat(Mtx m, const Quaternion *q);\n    void PSMTXReflect(Mtx m, const Vec *p, const Vec *n);\n    void PSMTXTrans(Mtx m, f32 xT, f32 yT, f32 zT);\n    void PSMTXTransApply(const Mtx src, Mtx dst, f32 xT, f32 yT, f32 zT);\n    void PSMTXScale(Mtx m, f32 xS, f32 yS, f32 zS);\n    void PSMTXScaleApply(const Mtx src, Mtx dst, f32 xS, f32 yS, f32 zS);\n    void PSMTXRotRad(Mtx m, char axis, f32 rad);\n    void PSMTXRotTrig(Mtx m, char axis, f32 sinA, f32 cosA);\n    void PSMTXRotAxisRad(Mtx m, const Vec *axis, f32 rad);\n\n    // move to vec.h?\n    void PSVECAdd(const Vec *a, const Vec *b, Vec *ab);\n    void PSVECSubtract(const Vec *a, const Vec *b, Vec *ab);\n    void PSVECScale(const Vec *src, Vec *dst, f32 scale);\n    void PSVECNormalize(const Vec *src, Vec *dst);\n    f32 PSVECSquareMag(const Vec *v);\n    f32 PSVECMag(const Vec *v);\n    f32 PSVECDotProduct(const Vec *a, const Vec *b);\n    void PSVECCrossProduct(const Vec *a, const Vec *b, Vec *ab);\n    f32 PSVECSquareDistance(const Vec *a, const Vec *b);\n    f32 PSVECDistance(const Vec *a, const Vec *b);\n\n    // C Versions\n\n    void C_MTXIdentity(Mtx m);\n    void C_MTXCopy(const Mtx src, Mtx dst);\n    void C_MTXConcat(const Mtx a, const Mtx b, Mtx ab);\n    void C_MTXConcatArray(const Mtx a, const Mtx *srcBase, Mtx *dstBase, u32 count);\n    void C_MTXTranspose(const Mtx src, Mtx xPose);\n    u32 C_MTXInverse(const Mtx src, Mtx inv);\n    u32 C_MTXInvXpose(const Mtx src, Mtx invX);\n    void C_MTXMultVec(const Mtx m, const Vec *src, Vec *dst);\n    void C_MTXMultVecArray(const Mtx m, const Vec *srcBase, Vec *dstBase, u32 count);\n    void C_MTXMultVecSR(const Mtx m, const Vec *src, Vec *dst);\n    void C_MTXMultVecArraySR(const Mtx m, const Vec *srcBase, Vec *dstBase, u32 count);\n    void C_MTXQuat(Mtx m, const Quaternion *q);\n    void C_MTXReflect(Mtx m, const Vec *p, const Vec *n);\n    void C_MTXTrans(Mtx m, f32 xT, f32 yT, f32 zT);\n    void C_MTXTransApply(const Mtx src, Mtx dst, f32 xT, f32 yT, f32 zT);\n    void C_MTXScale(Mtx m, f32 xS, f32 yS, f32 zS);\n    void C_MTXScaleApply(const Mtx src, Mtx dst, f32 xS, f32 yS, f32 zS);\n    void C_MTXRotRad(Mtx m, char axis, f32 rad);\n    void C_MTXRotTrig(Mtx m, char axis, f32 sinA, f32 cosA);\n    void C_MTXRotAxisRad(Mtx m, const Vec *axis, f32 rad);\n    void C_MTXLookAt(Mtx m, const Vec *camPos, const Vec *camUp, const Vec *target);\n    void C_MTXFrustum(Mtx44 m, f32 t, f32 b, f32 l, f32 r, f32 n, f32 f);\n    void C_MTXPerspective(Mtx44 m, f32 fovY, f32 aspect, f32 n, f32 f);\n    void C_MTXOrtho(Mtx44 m, f32 t, f32 b, f32 l, f32 r, f32 n, f32 f);\n    void C_MTXLightFrustum(Mtx m, f32 t, f32 b, f32 l, f32 r, f32 n, f32 scaleS, f32 scaleT, f32 transS,\n                           f32 transT);\n\n    void C_MTXLightPerspective(Mtx m, f32 fovY, f32 aspect, f32 scaleS, f32 scaleT, f32 transS,\n                               f32 transT);\n\n    void C_MTXLightOrtho(Mtx m, f32 t, f32 b, f32 l, f32 r, f32 scaleS, f32 scaleT, f32 transS,\n                         f32 transT);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif/* end \"dolphin/mtx.h\" */\n/* \"include\\JSystem\\JMath\\JMath.h\" line 8 \"JSystem/JMath/Inline.h\" */\n#ifndef JSYSTEM_JMATH_INLINE_H\n#define JSYSTEM_JMATH_INLINE_H\n\n/* \"include\\JSystem\\JMath\\Inline.h\" line 3 \"dolphin/mtx.h\" */\n/* end \"dolphin/mtx.h\" */\n/* \"include\\JSystem\\JMath\\Inline.h\" line 4 \"types.h\" */\n/* end \"types.h\" */\n\nnamespace JMathInlineVEC {\ninline void PSVECAdd(register const Vec* vec1, register const Vec* vec2, register Vec* dst)\n{\n\tregister f32 v1xy, v2xy, d1xy, v1z, v2z, d1z;\n\t// clang-format off\n\t__asm {            \n\t\tpsq_l     v1xy, 0(vec1), 0, 0\n\t\tpsq_l     v2xy, 0(vec2), 0, 0\n\t\tps_add    d1xy, v1xy, v2xy\n\t\tpsq_st    d1xy, 0(dst), 0, 0\n\t\t\n\t\tpsq_l     v1z,   8(vec1), 1, 0\n\t\tpsq_l     v2z,   8(vec2), 1, 0\n\t\tps_add    d1z, v1z, v2z\n\t\tpsq_st    d1z,  8(dst), 1, 0\n\t}\n\t// clang-format on\n}\ninline void PSVECSubtract(register const Vec* vec1, register const Vec* vec2, register Vec* dst)\n{\n\t// clang-format off\n\tregister f32 v1xy, v2xy, dxy, v1z, v2z, dz;\n\t__asm {\n\t\tpsq_l     v1xy, 0(vec1), 0, 0\n\t\tpsq_l     v2xy, 0(vec2), 0, 0\n\t\tps_sub    dxy, v1xy, v2xy\n\t\tpsq_st    dxy, 0(dst), 0, 0\n\t\t\n\t\tpsq_l     v1z,   8(vec1), 1, 0\n\t\tpsq_l     v2z,   8(vec2), 1, 0\n\t\tps_sub    dz, v1z, v2z\n\t\tpsq_st    dz,  8(dst), 1, 0            \n\t}\n\t// clang-format on\n}\ninline void PSVECScale(register const Vec* src, register Vec* dst, register f32 scalar)\n{\n\t// clang-format off\n\tregister f32 vxy, vz, rxy, rz;\n\t__asm {\n\t\t\n\t\tpsq_l       vxy, 0(src), 0, 0\n\t\tpsq_l       vz,  8(src), 1, 0\n\t\tps_muls0    rxy, vxy, scalar\n\t\tpsq_st      rxy, 0(dst), 0, 0\n\t\tps_muls0    rz,  vz,  scalar                        \n\t\tpsq_st      rz,  8(dst), 1, 0\n\t}\n\t// clang-format on\n}\ninline f32 PSVECDotProduct(register const Vec* vec1, register const Vec* vec2)\n{\n\tregister f32 dp, v1yz, v2yz, v2xy, v1xy;\n\t// clang-format off\n\t__asm {            \n\t\tpsq_l    v1yz, 4(vec1), 0, 0\n\t\tpsq_l    v2yz, 4(vec2), 0, 0\n\t\tps_mul   v1yz, v1yz, v2yz\n\t\tpsq_l    v1xy, 0(vec1), 0, 0\n\t\tpsq_l    v2xy, 0(vec2), 0, 0\n\t\tps_madd  v2yz, v1xy, v2xy, v1yz\n\t\tps_sum0  dp, v2yz, v1yz, v1yz\n\t}\n\t// clang-format on\n\treturn dp;\n}\ninline f32 PSVECSquareMag(register const Vec* src)\n{\n\tregister f32 xy, z, ret;\n\t// clang-format off\n\t__asm {\n\t\tpsq_l xy, 0(src), 0, 0\n\t\tps_mul xy, xy, xy\n\t\tlfs z, 8(src)            \n\t\tps_madd ret, z, z, xy\n\t\tps_sum0 ret, ret, xy, xy            \n\t}\n\t// clang-format on\n\treturn ret;\n}\n} // namespace JMathInlineVEC\n\n#endif\n/* end \"JSystem/JMath/Inline.h\" */\n\n/* \"include\\JSystem\\JMath\\JMath.h\" line 10 \"types.h\" */\n/* end \"types.h\" */\n\nnamespace JMath\n{\n    template <typename T>\n    struct TAngleConstant_\n    {\n        static const f32 RADIAN_DEG090() { return HALF_PI; }\n        static const f32 RADIAN_DEG180() { return PI; }\n        static const f32 RADIAN_DEG360() { return TAU; }\n        static const f32 RADIAN_TO_DEGREE_FACTOR() { return 180.0f / RADIAN_DEG180(); }\n    };\n\n    template <int length, typename T>\n    struct TSinCosTable\n    {\n        TSinCosTable() { init(); }\n\n        void init()\n        {\n            for (int i = 0; i < 2048; i++)\n            {\n                mTable[i].first = sin(((f64)i * TAngleConstant_<f32>::RADIAN_DEG360()) / 2048.0);\n                mTable[i].second = cos(((f64)i * TAngleConstant_<f32>::RADIAN_DEG360()) / 2048.0);\n            }\n        }\n        /**\n         * elements are pairs of {sine, cosine}\n         */\n        f32 sinShort(s16 v) const { return mTable[static_cast<u16>(v) >> 5].first; }\n        f32 cosShort(s16 v) const { return mTable[static_cast<u16>(v) >> 5].second; }\n        std::pair<f32, f32> mTable[2048];\n    };\n\n    template <int length, typename T>\n    struct TAtanTable\n    {\n        T atan2_(T, T) const;\n        T atan_(T) const;\n        T mTable[length];\n    };\n\n    template <int length, typename T>\n    struct TAsinAcosTable\n    {\n        T acos2_(T, T) const;\n        T acos_(T) const;\n        T mTable[length];\n    };\n\n    template <>\n    struct TAtanTable<1024, f32>\n    {\n        TAtanTable() { init(); }\n\n        void init()\n        {\n            for (int i = 0; i < (u32)1024; i++)\n            {\n                mTable[i] = atan(i / 1024.0);\n            }\n            mTable[0] = 0.0f;\n            mTable2[0] = TAngleConstant_<f32>::RADIAN_DEG180() / 4;\n        }\n\n        f32 atan_(f32) const;\n        f32 atan2_(f32, f32) const;\n        f32 atan2Radian(f32 y, f32 x) const { return atan2_(y, x); }\n        f32 alignmentHack(f32 x) const;\n\n        f32 calc(f32 y, f32 x) const\n        {\n            if (x >= 0.0f)\n            {\n                if (x >= y)\n                {\n                    return (0.0f == x ? 0.0f : mTable[(int)((y * 1024.0f) / x + 0.5f)]);\n                }\n                else\n                {\n                    return HALF_PI - (y == 0.0f ? 0.0f : mTable[(int)((x * 1024.0f) / y + 0.5f)]);\n                }\n            }\n            else\n            {\n                x = -x;\n                if (x < y)\n                {\n                    return (y == 0.0f ? 0.0f : mTable[(int)((x * 1024.0f) / y + 0.5f)]) + HALF_PI;\n                }\n                else\n                {\n                    return PI - (x == 0.0f ? 0.0f : mTable[(int)((y * 1024.0f) / x + 0.5f)]);\n                }\n            }\n        }\n\n        f32 calcInverse(f32 y, f32 x) const\n        {\n            y = -y;\n            if (x < 0.0f)\n            {\n                x = -x;\n                if (x >= y)\n                {\n                    return (x == 0.0f ? 0.0f : mTable[(int)((y * 1024.0f) / x + 0.5f)]) + -PI;\n                }\n                else\n                {\n                    return -HALF_PI - (y == 0.0f ? 0.0f : mTable[(int)((x * 1024.0f) / y + 0.5f)]);\n                }\n            }\n            else\n            {\n                if (x < y)\n                {\n                    return (y == 0.0f ? 0.0f : mTable[(int)((x * 1024.0f) / y + 0.5f)]) + -HALF_PI;\n                }\n                else\n                {\n                    return -(x == 0.0f ? 0.0f : mTable[(int)((y * 1024.0f) / x + 0.5f)]);\n                }\n            }\n        }\n\n        f32 mTable[1024];\n        f32 mTable2[8];\n    };\n\n    template <>\n    struct TAsinAcosTable<1024, f32>\n    {\n        TAsinAcosTable() { init(); }\n        void init()\n        {\n            for (int i = 0; i < 1024; i++)\n            {\n                mTable[i] = asin(i / 1024.0);\n            }\n            mTable[0] = 0.0f;\n            mTable2[0] = TAngleConstant_<f32>::RADIAN_DEG180() / 4;\n        }\n        f32 acos2_(f32, f32) const;\n        f32 acos_(f32) const;\n        f32 mTable[1024];\n        f32 mTable2[8];\n    };\n\n    extern const TAsinAcosTable<1024, f32> asinAcosTable_ __attribute__((aligned(32)));\n    extern const TSinCosTable<11, f32> sincosTable_ __attribute__((aligned(32)));\n    extern const TAtanTable<1024, f32> atanTable_ __attribute__((aligned(32)));\n\n    class TRandom_fast_\n    {\n    public:\n        TRandom_fast_(u32 num); // maybe has a default ctor?\n        u32 get()\n        {\n            seed = (seed * 0x19660d) + 0x3c6ef35f;\n            return seed;\n        }\n\n        // from TP decomp\n        f32 get_ufloat_1()\n        {\n            // !@bug UB: in C++ it's not legal to read from an union member other\n            // than the last one that was written to.\n            union\n            {\n                f32 f;\n                u32 s;\n            } out;\n            out.s = (this->get() >> 9) | 0x3f800000;\n            return out.f - 1;\n        }\n\n        void setSeed(u32 Seed)\n        {\n            seed = Seed;\n        }\n\n    protected:\n        u32 seed;\n    };\n    template <typename T>\n    class TRandom_ : public TRandom_fast_\n    {\n    public:\n        TRandom_(u32 num) : TRandom_fast_(num){};\n    };\n}\n\ninline f32 JMAAbs(f32 input) { return __fabs(input); }\n\ninline f32 JMAAtan2Radian(f32 y, f32 x) { return JMath::atanTable_.atan2Radian(y, x); };\n\ninline f32 JMASCosShort(s16 v) { return JMath::sincosTable_.cosShort(v); }\ninline f32 JMASinShort(s16 v) { return JMath::sincosTable_.sinShort(v); }\n\ninline f32 JMASCos(s16 v) { return JMASCosShort(v); }\ninline f32 JMASSin(s16 v) { return JMASinShort(v); }\n\ninline f32 JMAHermiteInterpolation(register f32 p1, register f32 p2, register f32 p3, register f32 p4, register f32 p5, register f32 p6,\n                                   register f32 p7)\n{\n    register f32 ff25;\n    register f32 ff31;\n    register f32 ff30;\n    register f32 ff29;\n    register f32 ff28;\n    register f32 ff27;\n    register f32 ff26;\n    // clang-format off\n    __asm {\n        fsubs   ff31, p1, p2\n        fsubs   ff30, p5, p2\n        fdivs   ff29, ff31, ff30\n        fmuls   ff28,ff29,ff29\n        fadds   ff25,ff29,ff29\n        fsubs   ff27,ff28,ff29\n        fsubs   ff30, p3, p6\n        fmsubs  ff26,ff25,ff27,ff28\n        fmadds  ff25,p4,ff27,p4\n        fmadds  ff26,ff26,ff30,p3\n        fmadds  ff25,p7,ff27,ff25\n        fmsubs  ff25,ff29,p4,ff25\n        fnmsubs ff25,ff31,ff25,ff26\n\n    }\n    // clang-format on\n    return ff25;\n}\n\ninline f32 JMAFastSqrt(register f32 x)\n{\n    register f32 recip;\n\n    if (x > 0.0f)\n    {\n        __asm { frsqrte recip, x }\n        return recip * x;\n    }\n    return x;\n}\n\nvoid JMAEulerToQuat(s16, s16, s16, Quaternion *);\nvoid JMAQuatLerp(const Quaternion *, const Quaternion *, f32, Quaternion *);\nvoid JMAVECScaleAdd(const Vec *, const Vec *, Vec *, f32);\nvoid JMAVECLerp(const Vec *, const Vec *, Vec *, f32);\nvoid JMAMTXApplyScale(const Mtx, Mtx, f32, f32, f32);\n\n#endif // !JMATH_H\n/* end \"JSystem/JMath/JMath.h\" */\n/* \"include\\JSystem\\JGeometry\\Util.h\" line 5 \"types.h\" */\n/* end \"types.h\" */\n\nnamespace JGeometry {\n    template <typename T>\n    class TUtil\n    {\n    public:\n        static f32 abs(f32 x) { return __fabs(x); }\n        static f32 atan2(f32 y, f32 x) { return JMAAtan2Radian(y, x); }\n        static const f32 epsilon() { return 32.0f * FLT_EPSILON; }\n\n        static bool epsilonEquals(T a1, T a2, T a3)\n        {\n            bool equal = false;\n\n            a1 -= a2;\n\n            if (-a3 <= a1 && a1 <= a3)\n            {\n                equal = true;\n            }\n\n            return equal;\n        }\n\n        f32 invert(f32 x) { return 1.0f/x; }\n\n        static f32 sqrt(f32 x)\n        {\n            if (x <= 0.0f)\n                return x;\n\n            f32 y = __frsqrte(x);\n            y = 0.5f * y * (3.0f - (x * (y * y)));\n            return x * y;\n        }\n\n        static f32 inv_sqrt(f32 x)\n        {\n            if (x <= 0.0f)\n                return x;\n            \n            f32 y = __frsqrte(x);\n            y = 0.5f * y * (3.0f - (x * (y * y)));\n            return y;\n        }\n\n        T one() { return (T)1; }\n\n        // TODO: probably uses seomthing from TSinCosTable\n        /*static f32 asin(f32 val) NO_INLINE\n        {\n            if (val >= 1.0f)\n            {\n                return 1.5707964f;\n            }\n\n            if (val <= -1.0f)\n            {\n                return -1.5707964f;\n            }\n\n            if (val < 0.0f)\n            {\n                return -flt_80630CA0[(u32)(1023.5f * -val)];\n            }\n\n            return flt_80630CA0[(u32)(1023.5f * val)];\n        }*/\n\n        /*static f32 PI() NO_INLINE\n        {\n            return 3.1415927f;\n        }*/\n\n        static T clamp(T p1, T p2, T p3);\n    };\n\n    typedef TUtil<f32> TUtilf;\n}\n\n\n#endif\n/* end \"JSystem/JGeometry/Util.h\" */\n/* \"include\\JSystem\\JGeometry\\Vec.h\" line 4 \"types.h\" */\n/* end \"types.h\" */\n\nnamespace JGeometry {\n    inline void setTVec3f(register const f32 *src, register f32 *dst)\n    {\n        register f32 xy, z;\n        __asm {\n            // clang-format off\n            psq_l xy, 0(src), 0, 0\n            lfs z, 8(src)\n            psq_st xy, 0(dst), 0, 0\n            stfs z, 8(dst)\n            // clang-format on\n        }\n    }\n\n    inline void negateInternal(register const f32 *src, register f32 *dst)\n    {\n        register f32 xy;\n        __asm {\n            // clang-format off\n            psq_l xy, 0(src), 0, 0\n            ps_neg xy, xy\n            psq_st xy, 0(dst), 0, 0\n            // clang-format on\n        }\n        dst[2] = -src[2];\n    }\n\n    inline void mulInternal(register const f32 *vec1, register const f32 *vec2, register f32 *dst) \n    {\n        register f32 xy1, xy2, res;\n        __asm {\n            // clang-format off\n            psq_l xy1, 0(vec1), 0, 0\n            psq_l xy2, 0(vec2), 0, 0\n            ps_mul res, xy1, xy2\n            psq_st res, 0(dst), 0, 0\n            // clang-format on\n        }\n        dst[2] = vec1[2] * vec2[2];\n    }\n\n    template <typename T>\n    class TVec2\n    {\n    public:\n        TVec2() {}\n        TVec2(T X, T Y) { set(X, Y); }\n\n        void zero() { x = y = 0; }\n\n        template <typename TY>\n        void set(TY X, TY Y)\n        {\n            x = X;\n            y = Y;\n        }\n\n        void set(const TVec2 &other)\n        {\n            x = other.x;\n            y = other.y;\n        }\n\n        void setMin(const TVec2<f32> &min)\n        {\n            if (x >= min.x)\n                x = min.x;\n            if (y >= min.y)\n                y = min.y;\n        }\n\n        void setMax(const TVec2<f32> &max)\n        {\n            if (x <= max.x)\n                x = max.x;\n            if (y <= max.y)\n                y = max.y;\n        }\n\n        void add(const TVec2<T> &other)\n        {\n            x += other.x;\n            y += other.y;\n        }\n\n        void scale(T scalar) {\n            x *= scalar;\n            y *= scalar;\n        }\n\n        f32 dot(const TVec2<T> &other) const { return x * other.x + y * other.y; }\n        f32 length() const { return TUtilf::sqrt(squared()); }\n        f32 squared() const { return dot(*this); }\n\n        f32 normalize()\n        {\n            f32 this_squared = squared();\n            if (this_squared <= TUtilf::epsilon())\n                return 0.0f;\n            else\n            {\n                f32 invsqrt = TUtilf::inv_sqrt(this_squared);\n                scale(invsqrt);\n                return invsqrt * this_squared;\n            }\n        }\n\n        /** @fabricated */\n        // TVec2<T> adding(const TVec2<T>& other) { return TVec2<T>(x + other.x, y + other.y); }\n\n        bool isAbove(const TVec2<T> &other) const { return (x >= other.x) && (y >= other.y) ? true : false; }\n\n        T x;\n        T y;\n    };\n\n    template <typename T>\n    class TVec3\n    {\n    public:\n        // constructors\n        TVec3() {}\n        TVec3(const TVec3<f32> &other) { setTVec3f((const f32 *)&other, (f32 *)this); }\n        TVec3(const Vec &other) { setTVec3f((const f32 *)&other, (f32 *)this); }\n\n        template <typename TY>\n        TVec3(TY X, TY Y, TY Z) { set(X, Y, Z); }\n\n        // getters/setters\n        bool equals(const TVec3<f32> &other) \n        {\n            bool equal = false;\n            if (x == other.x && y == other.y && z == other.z)\n            {\n                equal = true;\n            }\n            return equal;\n        }\n\n        bool isZero() const { return (squared() <= TUtilf::epsilon()); }\n\n        template <typename TY>\n        void set(TY X, TY Y, TY Z)\n        {\n            x = X;\n            y = Y;\n            z = Z;\n        }\n\n        template <typename TY>\n        void set(const TVec3<TY> &src)\n        {\n            x = src.x;\n            y = src.y;\n            z = src.z;\n        }\n\n        template <typename TY>\n        void setAll(TY val)\n        {\n            x = val;\n            y = val;\n            z = val;\n        }\n\n        f32 setLength(f32 length)\n        {\n            if (length <= TUtilf::epsilon())\n            {\n                return 0.0f;\n            }\n            else\n            {\n                f32 invsqrt = TUtilf::inv_sqrt(length);\n                scale(invsqrt);\n                return invsqrt * length;\n            }\n        }\n        void setLength(const TVec3 &operand, f32 length);\n        void setMax(const TVec3 &other);\n        void setMin(const TVec3 &other);\n        void setNormal(const TVec3 &, const TVec3 &, const TVec3 &);\n\n        void zero() { x = y = z = 0; }        \n\n        // operators\n        TVec3 &operator=(const TVec3 &other) {\n            setTVec3f((const f32*)&other, (f32 *)this);\n            return *this;\n        }\n\n        /*void operator+(const TVec3 &operand)\n        {\n            add(operand);\n            return *this;\n        }*/\n\n        /*TVec3 &operator*(float scalar) const\n        {\n            TVec3 scaled(*this);\n            scaled *= scalar;\n            TVec3(scaled);\n        }*/\n\n        TVec3 &operator+=(const TVec3 &operand)\n        {\n            add(operand);\n            return *this;\n        }\n\n        TVec3 &operator-=(const TVec3 &operand)\n        {\n            sub(operand);\n            return *this;\n        }\n\n        TVec3 &operator*=(float scalar)\n        {\n            scale(scalar);\n            return *this;\n        }\n\n        TVec3 &operator/=(float divisor)\n        {\n            div(divisor);\n            return *this;\n        }\n\n        // simple math operations\n\n        void add(const TVec3 &operand) { JMathInlineVEC::PSVECAdd((const Vec *)this, (Vec *)&operand, (Vec *)this); }\n        void add(const TVec3 &vec1, const TVec3 &vec2) { JMathInlineVEC::PSVECAdd((const Vec *)&vec1, (const Vec *)&vec2, (Vec *)this); }\n        \n        void sub(const TVec3<T> &translate) { JMathInlineVEC::PSVECSubtract((const Vec *)this, (const Vec *)&translate, (Vec *)this); }\n        void sub(const TVec3 &base, const TVec3 &translate) { JMathInlineVEC::PSVECSubtract((const Vec *)&base, (const Vec *)&translate, (Vec *)this); }\n\n        void negate() { negateInternal((const f32 *)this, (f32 *)this); }\n        void negate(const TVec3 &other) { negateInternal((const f32 *)&other, (f32 *)this); }\n\n        void mul(const TVec3 &multiplier) { mulInternal((const f32 *)this, (const f32 *)multiplier, (f32 *)this); }\n        void mul(const TVec3 &vec1, const TVec3 &vec2) { mulInternal((const f32 *)vec1, (const f32 *)vec2, (f32 *)this); }\n\n        void scale(f32 scalar) { JMathInlineVEC::PSVECScale((const Vec *)this, (Vec *)this, scalar); }\n        void scale(f32 scalar, const TVec3 &operand) { JMathInlineVEC::PSVECScale((const Vec *)&operand, (Vec *)this, scalar); }\n\n        void scaleAdd(f32 scalar, const TVec3 &operand, const TVec3 &translate) { JMAVECScaleAdd((const Vec *)&operand, (const Vec *)&translate, (Vec *)this, scalar); }\n\n        void div(f32 divisor) { return scale(TUtilf::invert(divisor)); }\n        void div(f32 divisor, const TVec3 &operand) { return scale(TUtilf::invert(divisor), operand); }\n\n        f32 squared() const { return JMathInlineVEC::PSVECSquareMag((Vec *)this); }\n        f32 squaredZX() const { return dotZX(this); }\n        // more complex math operations\n\n        void cross(const TVec3 &vec1, const TVec3 &vec2) { PSVECCrossProduct((const Vec *)&vec1, (const Vec *)&vec2, (Vec *)this); }\n        f32 dot(const TVec3 &operand) const { return JMathInlineVEC::PSVECDotProduct((const Vec *)this, (Vec *)&operand); }\n        f32 dotZX(const TVec3 &operand) const { return x * operand.x + z * operand.z; }\n        f32 length() const { return PSVECMag((Vec *)this); }\n\n        f32 angle(TVec3 vec2)\n        {\n            TVec3 crossp;\n            crossp.cross(*this, vec2);\n\n            f32 ang = TUtilf::atan2(crossp.length(), dot(vec2));\n\n            return TUtilf::abs(ang);\n        }\n\n        f32 normalize()\n        {\n            f32 this_squared = squared();\n            if (this_squared <= TUtilf::epsilon())\n                return 0.0f;\n            else\n            {\n                f32 invsqrt = TUtilf::inv_sqrt(this_squared);\n                scale(invsqrt);\n                return invsqrt * this_squared;\n            }\n        }\n\n        T x;\n        T y;\n        T z;\n    };\n    typedef TVec2<f32> TVec2f;\n    typedef TVec3<f32> TVec3f;\n}\n\n#endif\n/* end \"JSystem/JGeometry/Vec.h\" */\n/* \"include\\JSystem\\JGeometry.h\" line 4 \"JSystem/JGeometry/Quat.h\" */\n#ifndef JGEOMETRY_QUAT_H\n#define JGEOMETRY_QUAT_H\n\n/* \"include\\JSystem\\JGeometry\\Quat.h\" line 3 \"JSystem/JGeometry/Vec.h\" */\n/* end \"JSystem/JGeometry/Vec.h\" */\n/* \"include\\JSystem\\JGeometry\\Quat.h\" line 4 \"types.h\" */\n/* end \"types.h\" */\n\nnamespace JGeometry {\n    template <typename T>\n    struct TQuat4\n    {\n    public:\n        /* Constructors */\n        inline TQuat4() {}\n\n        template <typename T>\n        TQuat4(T _x, T _y, T _z, T _w)\n        {\n            x = _x;\n            y = _y;\n            z = _z;\n            w = _w;\n        }\n\n        /* General operations */\n        void normalize();\n        void normalize(const TQuat4<T> &rSrc);\n\n        void getXDir(TVec3<T> &rDest) const;\n        void getYDir(TVec3<T> &rDest) const;\n        void getZDir(TVec3<T> &rDest) const;\n\n        void getEuler(TVec3<T> &rDest) const;\n        void setEuler(T _x, T _y, T _z);\n        void setEulerZ(T _z);\n\n        void setRotate(const TVec3<T> &, const TVec3<T> &, T);\n        void setRotate(const TVec3<T> &, const TVec3<T> &);\n        void setRotate(const TVec3<T> &, f32);\n        void rotate(TVec3f &rDest) const;\n\n        void slerp(const TQuat4<T> &, const TQuat4<T>, T);\n        void slerp(const TQuat4<T> &, T);\n        void transform(const TVec3<T> &, TVec3<T> &rDest);\n        void transform(TVec3<T> &rDest);\n\n        /* Operators */\n        TQuat4<T> &operator=(const TQuat4<T> &rSrc);\n\n        T x, y, z, w;\n    };\n\n    typedef TQuat4<f32> TQuat4f;\n}\n\n#endif\n/* end \"JSystem/JGeometry/Quat.h\" */\n/* \"include\\JSystem\\JGeometry.h\" line 5 \"JSystem/JGeometry/Matrix.h\" */\n#ifndef JGEOMETRY_MATRIX_H\n#define JGEOMETRY_MATRIX_H\n\n/* \"include\\JSystem\\JGeometry\\Matrix.h\" line 3 \"JSystem/JGeometry/Vec.h\" */\n/* end \"JSystem/JGeometry/Vec.h\" */\n/* \"include\\JSystem\\JGeometry\\Matrix.h\" line 4 \"JSystem/JGeometry/Quat.h\" */\n/* end \"JSystem/JGeometry/Quat.h\" */\n\n/* \"include\\JSystem\\JGeometry\\Matrix.h\" line 6 \"types.h\" */\n/* end \"types.h\" */\n\nnamespace JGeometry {\n    template <typename T>\n    struct SMatrix34C\n    {\n    public:\n        SMatrix34C() {}\n        void set(const MtxPtr);\n        void set(const SMatrix34C<T> &rSrc);\n        void set(T rxx, T ryx, T rzx, T tx, T rxy, T ryy, T rzy, T ty, T rxz, T ryz, T rzz, T tz);\n\n        void scale(T);\n\n        inline void setInline(const SMatrix34C<T> &rSrc)\n        {\n            register const SMatrix34C<T> *pSrc = &rSrc;\n            register SMatrix34C<T> *pDest = this;\n            register f32 rzztz;\n            register f32 rxzyz;\n            register f32 rzyty;\n            register f32 rxyyy;\n            register f32 rzxtx;\n            register f32 rxxyx;\n\n            __asm {\n                // clang-format off\n                psq_l     rxxyx, 0(pSrc), 0, 0\n                psq_l     rzxtx, 8(pSrc), 0, 0\n                psq_l     rxyyy, 0x10(pSrc), 0, 0\n                psq_l     rzyty, 0x18(pSrc), 0, 0\n                psq_l     rxzyz, 0x20(pSrc), 0, 0\n                psq_l     rzztz, 0x28(pSrc), 0, 0\n                psq_st    rxxyx, 0(pDest), 0, 0\n                psq_st    rzxtx, 8(pDest), 0, 0\n                psq_st    rxyyy, 0x10(pDest), 0, 0\n                psq_st    rzyty, 0x18(pDest), 0, 0\n                psq_st    rxzyz, 0x20(pDest), 0, 0\n                psq_st    rzztz, 0x28(pDest), 0, 0\n                // clang-format on\n            }\n            ;\n        }\n\n        inline void setInline(const MtxPtr rSrc)\n        {\n            register const MtxPtr pSrc = rSrc;\n            register SMatrix34C<T> *pDest = this;\n            register f32 rzztz;\n            register f32 rxzyz;\n            register f32 rzyty;\n            register f32 rxyyy;\n            register f32 rzxtx;\n            register f32 rxxyx;\n\n            __asm {\n                // clang-format off\n                psq_l     rxxyx, 0(pSrc), 0, 0\n                psq_l     rzxtx, 8(pSrc), 0, 0\n                psq_l     rxyyy, 0x10(pSrc), 0, 0\n                psq_l     rzyty, 0x18(pSrc), 0, 0\n                psq_l     rxzyz, 0x20(pSrc), 0, 0\n                psq_l     rzztz, 0x28(pSrc), 0, 0\n                psq_st    rxxyx, 0(pDest), 0, 0\n                psq_st    rzxtx, 8(pDest), 0, 0\n                psq_st    rxyyy, 0x10(pDest), 0, 0\n                psq_st    rzyty, 0x18(pDest), 0, 0\n                psq_st    rxzyz, 0x20(pDest), 0, 0\n                psq_st    rzztz, 0x28(pDest), 0, 0\n                // clang-format on\n            }\n            ;\n        }\n\n        inline void setInline_2(MtxPtr rSrc)\n        {\n            register MtxPtr pSrc = rSrc;\n            register SMatrix34C<T> *pDest = this;\n            register f32 rzztz;\n            register f32 rxzyz;\n            register f32 rzyty;\n            register f32 rxyyy;\n            register f32 rzxtx;\n            register f32 rxxyx;\n\n            __asm {\n                // clang-format off\n                psq_l     rxxyx, 0(pSrc), 0, 0\n                psq_l     rzxtx, 8(pSrc), 0, 0\n                psq_l     rxyyy, 0x10(pSrc), 0, 0\n                psq_st    rxxyx, 0(pDest), 0, 0\n                psq_l     rzyty, 0x18(pSrc), 0, 0\n                psq_st    rzxtx, 8(pDest), 0, 0\n                psq_l     rxzyz, 0x20(pSrc), 0, 0\n                psq_st    rxyyy, 0x10(pDest), 0, 0\n                psq_l     rzztz, 0x28(pSrc), 0, 0\n                psq_st    rzyty, 0x18(pDest), 0, 0\n                psq_st    rxzyz, 0x20(pDest), 0, 0\n                psq_st    rzztz, 0x28(pDest), 0, 0\n                // clang-format on\n            }\n            ;\n        }\n\n        T &ref(u32 i, u32 j) { return mMtx[i][j]; }\n\n        inline Mtx *toMtx()\n        {\n            return (Mtx *)mMtx;\n        }\n\n        inline const Mtx *toCMtx() const\n        {\n            return (const Mtx *)mMtx;\n        }\n\n        operator MtxPtr() const { return (MtxPtr)mMtx; }\n\n        T mMtx[3][4];\n    };\n\n    typedef SMatrix34C<f32> TSMtxf;\n\n    template <typename T>\n    struct TMatrix34 : public T\n    {\n    public:\n        void identity() // TODO: OK?\n        {\n            const T zero = (T)0;\n            ref(2, 3) = zero;\n            ref(1, 3) = zero;\n            ref(0, 3) = zerof;\n\n            ref(1, 2) = zero;\n            ref(0, 2) = zero;\n\n            ref(2, 1) = zero;\n            ref(0, 1) = zero;\n            ref(2, 0) = zero;\n            ref(1, 0) = zero;\n\n            const T one = TUtil<T>::one();\n            ref(2, 2) = one;\n            ref(1, 1) = one;\n            ref(0, 0) = one;\n        }\n        void concat(const T &rSrcA, const T &rSrcB);\n        void concat(const T &rSrc);\n        void invert(const TMatrix34<T> &rDest);\n\n        void mult(const TVec3f &rSrc, TVec3f &rDest) const;\n\n        void multTranspose(const TVec3f &a1, const TVec3f &a2) const;\n    };\n\n    template <class T>\n    struct TRotation3 : public T\n    {\n    public:\n        TRotation3() {}\n        void identity33();\n\n        void getXDir(TVec3f &rDest) const\n        {\n            rDest.set<f32>(mMtx[0][0], mMtx[1][0], mMtx[2][0]);\n        };\n\n        void getYDir(TVec3f &rDest) const\n        {\n            rDest.set<f32>(mMtx[0][1], mMtx[1][1], mMtx[2][1]);\n        };\n\n        void getZDir(TVec3f &rDest) const\n        {\n            rDest.set<f32>(mMtx[0][2], mMtx[1][2], mMtx[2][2]);\n        };\n\n        void getXYZDir(TVec3f &rDestX, TVec3f &rDestY, TVec3f &rDestZ) const;\n        void setXDir(const TVec3f &rSrc);\n        void setXDir(f32 x, f32 y, f32 z);\n        void setYDir(const TVec3f &rSrc);\n        void setYDir(f32 x, f32 y, f32 z);\n        void setZDir(const TVec3f &rSrc);\n        void setZDir(f32 x, f32 y, f32 z);\n        void setXYZDir(const TVec3f &rSrcX, const TVec3f &rSrcY, const TVec3f &rSrcZ)\n        {\n            ref(0, 0) = rSrcX.x;\n            ref(1, 0) = rSrcX.y;\n            ref(2, 0) = rSrcX.z;\n            ref(0, 1) = rSrcY.x;\n            ref(1, 1) = rSrcY.y;\n            ref(2, 1) = rSrcY.z;\n            ref(0, 2) = rSrcZ.x;\n            ref(1, 2) = rSrcZ.y;\n            ref(2, 2) = rSrcZ.z;\n        }\n\n        void getEuler(TVec3f &rDest) const;\n        void getEulerXYZ(TVec3f &rDest) const;\n        void setEulerY(f32 val);\n        void setEulerZ(f32 val);\n\n        void getQuat(TQuat4f &rDest) const;\n        void setQuat(const TQuat4f &rSrc);\n\n        void getScale(TVec3f &rDest) const;\n        void setScale(const TVec3f &rSrc);\n\n        void setRotate(const TVec3f &, const TVec3f &);\n        void setRotate(const TVec3f &, f32);\n\n        void mult33(TVec3f &) const;\n        void mult33(const TVec3f &, TVec3f &) const;\n\n        inline void getXDirInline(TVec3f &rDest) const\n        {\n            f32 z = mMtx[2][0];\n            f32 y = mMtx[1][0];\n            f32 x = mMtx[0][0];\n            rDest.set(x, y, z);\n        }\n\n#ifdef NON_MATCHING\n        inline void mult33Inline(const TVec3f &rSrc, TVec3f &rDest) const\n        {\n            rDest.set<f32>(\n                rSrc.z * mMtx[0][2] + (rSrc.y * mMtx[0][0] + (rSrc.x * mMtx[0][1])),\n                rSrc.z * mMtx[1][2] + (rSrc.y * mMtx[1][0] + (rSrc.x * mMtx[1][1])),\n                rSrc.z * mMtx[2][2] + (rSrc.y * mMtx[2][0] + (rSrc.x * mMtx[2][1])));\n        }\n#endif\n    };\n\n    template <class T>\n    struct TPosition3 : public TRotation3<T>\n    {\n    public:\n        TPosition3() {}\n        void getTrans(TVec3f &rDest) const;\n        void setTrans(const TVec3f &rSrc);\n        void setTrans(f32 x, f32 y, f32 z);\n        void zeroTrans()\n        {\n            ref(0, 3) = 0.0f;\n            ref(1, 3) = 0.0f;\n            ref(2, 3) = 0.0f;\n        }\n\n        void makeRotate(const TVec3f &, f32);\n        void makeQuat(const TQuat4f &rSrc);\n        void setPositionFromLookAt(const TPosition3<T> &rLookAt);\n        void setQT(const TQuat4f &rSrcQuat, const TVec3f &rSrcTrans);\n\n        inline void getTransInline(TVec3f &rDest) const\n        {\n            f32 z = mMtx[2][3];\n            f32 y = mMtx[1][3];\n            f32 x = mMtx[0][3];\n            rDest.set(x, y, z);\n        }\n    };\n\n    typedef TMatrix34<TSMtxf> TMtx34f;\n    typedef TRotation3<TMtx34f> TRot3f;\n    typedef TPosition3<TMtx34f> TPos3f;\n}\n\n#endif\n/* end \"JSystem/JGeometry/Matrix.h\" */\n/* \"include\\JSystem\\JGeometry.h\" line 6 \"JSystem/JGeometry/Box.h\" */\n#ifndef JGEOMETRY_BOX_H\n#define JGEOMETRY_BOX_H\n\n/* \"include\\JSystem\\JGeometry\\Box.h\" line 3 \"JSystem/JGeometry/Vec.h\" */\n/* end \"JSystem/JGeometry/Vec.h\" */\n/* \"include\\JSystem\\JGeometry\\Box.h\" line 4 \"types.h\" */\n/* end \"types.h\" */\n\nnamespace JGeometry {\n    // Size: 0x10\n    template <class T>\n    struct TBox\n    {\n        TBox()\n            : i(), f()\n        {\n        }\n        TBox(const TBox &other)\n            : i(other.f), f(other.y)\n        {\n        }\n\n        T i, f;\n    };\n\n    // clang-format off\n    template<> struct TBox<TVec2<f32> > {\n    f32 getWidth() const { return f.x - i.x; }\n    f32 getHeight() const { return f.y - i.y; }\n\n    bool isValid() const { return f.isAbove(i); }\n\n    void addPos(f32 x, f32 y) {\n        addPos(TVec2<f32>(x, y));\n    }\n\n    void addPos(const TVec2<f32>& pos) {\n        i.add(pos);\n        f.add(pos);\n    }\n\n    bool intersect(const TBox<TVec2<f32> >& other) {\n        i.setMax(other.i);\n        f.setMin(other.f);\n        return isValid();\n    }\n\n    TVec2<f32> i, f;\n};\n\ntemplate <typename T>\nstruct TBox2 : TBox<TVec2<T> > {\n    TBox2() {}\n    TBox2(const TVec2<f32>& i, const TVec2<f32> f) { set(i, f); }\n    TBox2(f32 x0, f32 y0, f32 x1, f32 y1) { set(x0, y0, x1, y1); }\n\tTBox2(f32 x0, f32 y0, TVec2<f32>& f) { set(x0, y0, x0 + f.x, y0 + f.y);\t}\n\tTBox2(f32 val)\n\t{\n\t\tf.y = val;\n\t\tf.x = val;\n\t\ti.y = val;\n\t\ti.x = val;\n\t}\n\n    void absolute() {\n        if (!this->isValid()) {\n            TBox2<T> box(*this);\n            this->i.setMin(box.i);\n            this->i.setMin(box.f);\n            this->f.setMax(box.i);\n            this->f.setMax(box.f);\n        }\n    }\n\n\t// /** @fabricated */\n\t// TBox2<T>& addingPos(TBox2<T>& result, const TVec2<T>& pos) {\n\t// \treturn TBox2<T>(i.adding(pos), f.adding(pos));\n\t// }\n\n    void set(const TBox2& other) { set(other.i, other.f); }\n    void set(const TVec2<f32>& i, const TVec2<f32>& f) { this->i.set(i), this->f.set(f); }\n    void set(f32 x0, f32 y0, f32 x1, f32 y1) { i.set(x0, y0); f.set(x1, y1); }\n};\n\n    // clang-format on\n\n\n    template <typename T>\n    struct TBox3\n    {\n        T minX;\n        T minY;\n        T minZ;\n        T maxX;\n        T maxY;\n        T maxZ;\n    };\n\n    template <typename T>\n    class TDirBox3\n    {\n    public:\n        TVec3<T> _0;\n        TVec3<T> _C;\n        TVec3<T> _18;\n        TVec3<T> _24;\n        TVec3<T> _30;\n    };\n\n    typedef TBox2<f32> TBox2f;\n    typedef TBox3<f32> TBox3f;\n    typedef TBox3<TVec3f> TBoxVec3f;\n    typedef TDirBox3<f32> TDirBox3f;\n}\n\n#endif\n/* end \"JSystem/JGeometry/Box.h\" */\n/* \"include\\JSystem\\JGeometry.h\" line 7 \"JSystem/JGeometry/Util.h\" */\n/* end \"JSystem/JGeometry/Util.h\" */\n\n#endif\n/* end \"JSystem/JGeometry.h\" */\n/* \"include\\JSystem\\JAudio\\Interface\\JAIAudible.h\" line 4 \"JSystem/JAudio/System/JASSoundParams.h\" */\n#ifndef JAUDIO_JASSOUNDPARAMS_H\n#define JAUDIO_JASSOUNDPARAMS_H\n\n/* \"include\\JSystem\\JAudio\\System\\JASSoundParams.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\nstruct JASSoundParams\n{\n    JASSoundParams() { init(); }\n\n    void clamp();\n    void combine(const JASSoundParams &other);\n    void combine(const JASSoundParams &other1, const JASSoundParams &other2);\n    void combine(const JASSoundParams &other1, const JASSoundParams &other2, const JASSoundParams &other3);\n    void combine(const JASSoundParams &other1, const JASSoundParams &other2, const JASSoundParams &other3, const JASSoundParams &other4);\n    void print() const;\n\n    void init()\n    {\n        initVolume();\n        initPitch();\n        initFxMix();\n        initPan();\n        initDolby();\n    }\n\n    void initVolume() { mVolume = 1.0f; }\n    void initFxMix() { mFxMix = 0.0f; }\n    void initPitch() { mPitch = 1.0f; }\n    void initPan() { mPan = 0.5f; }\n    void initDolby() { mDolby = 0.0f; }\n\n    void clampVolume()\n    {\n        if (mVolume < 0.0f)\n            mVolume = 0.0f;\n        else if (mVolume > 1.0f)\n            mVolume = 1.0f;\n    }\n    void clampFxMix(void)\n    {\n        if (mFxMix < 0.0f)\n            mFxMix = 0.0f;\n        else if (mFxMix > 1.0f)\n            mFxMix = 1.0f;\n    }\n    void clampPitch()\n    {\n        if (mPitch < 0.0f)\n            mPitch = 0.0f;\n        else if (mPitch > 8.0f)\n            mPitch = 8.0f;\n    }\n    void clampPan()\n    {\n        if (mPan < 0.0f)\n            mPan = 0.0f;\n        else if (mPan > 1.0f)\n            mPan = 1.0f;\n    }\n    void clampDolby()\n    {\n        if (mDolby < 0.0f)\n            mDolby = 0.0f;\n        else if (mDolby > 1.0f)\n            mDolby = 1.0f;\n    }\n\n    f32 mVolume;\n    f32 mFxMix;\n    f32 mPitch;\n    f32 mPan;\n    f32 mDolby;\n};\n\n#endif/* end \"JSystem/JAudio/System/JASSoundParams.h\" */\n\nclass JAIAudible\n{\npublic:\n    virtual ~JAIAudible();\n    virtual JASSoundParams *getOuterParams(int) = 0;\n    virtual void calc() = 0;\n\n    JGeometry::TVec3f &getPos() { return mPos; }\n    void setPos(const JGeometry::TVec3f &other) { mPos.set(other); }\n\n    JGeometry::TVec3f mPos;\n};\n\n#endif /* JAUDIO_JAIAUDIBLE_H *//* end \"JSystem/JAudio/Interface/JAIAudible.h\" */\n/* \"include\\JSystem\\JAudio\\Interface\\JAISound.h\" line 5 \"JSystem/JAudio/Interface/JAISoundParams.h\" */\n#ifndef JAUDIO_JAISOUNDPARAMS_H\n#define JAUDIO_JAISOUNDPARAMS_H\n\n/* \"include\\JSystem\\JAudio\\Interface\\JAISoundParams.h\" line 3 \"JSystem/JAudio/System/JASSoundParams.h\" */\n/* end \"JSystem/JAudio/System/JASSoundParams.h\" */\n\nstruct JAISoundParamsProperty\n{\n    void init()\n    {\n        _0 = 1.0f;\n        _4 = 0.0f;\n        field_0x8 = 1.0f;\n    }\n\n    f32 _0;\n    f32 _4;\n    f32 field_0x8;\n}; // Size: 0xC\n\nstruct JAISoundParamsTransition\n{\n    struct TTransition\n    {\n        void zero()\n        {\n            _0 = 0.0f;\n            mCount = 0;\n            _4 = 0.0f;\n        }\n\n        void set(f32 newValue, f32 intensity, u32 fadeCount)\n        {\n            mCount = fadeCount;\n            _0 = (newValue - intensity) / mCount;\n            _4 = newValue;\n        }\n\n        f32 apply(f32 param)\n        {\n            if (mCount > 1)\n            {\n                mCount--;\n                param += _0;\n            }\n            else\n            {\n                if (mCount == 1)\n                {\n                    mCount = 0;\n                    param = _4;\n                }\n            }\n            return param;\n        }\n\n        f32 _0;\n        f32 _4;\n        u32 mCount;\n    }; // Size: 0xC\n\n    void init()\n    {\n        mVolume.zero();\n        mPitch.zero();\n        mFxMix.zero();\n        mPan.zero();\n        mDolby.zero();\n    }\n\n    void apply(JASSoundParams *pParams)\n    {\n        pParams->mVolume = mVolume.apply(pParams->mVolume);\n        pParams->mPitch = mPitch.apply(pParams->mPitch);\n        pParams->mFxMix = mFxMix.apply(pParams->mFxMix);\n        pParams->mDolby = mDolby.apply(pParams->mDolby);\n        pParams->mPan = mPan.apply(pParams->mPan);\n    }\n\n    TTransition mVolume;\n    TTransition mPitch;\n    TTransition mFxMix;\n    TTransition mPan;\n    TTransition mDolby;\n}; // Size: 0x3C\n\nstruct JAISoundParamsMove\n{\n    JAISoundParamsMove() : mParams() {}\n\n    void init()\n    {\n        mParams.init();\n        mTransition.init();\n    }\n\n    void calc() { mTransition.apply(&mParams); }\n\n    void moveVolume(f32, u32);\n    void movePitch(f32, u32);\n    void moveFxMix(f32, u32);\n    void movePan(f32, u32);\n    void moveDolby(f32, u32);\n\n    JASSoundParams mParams;\n    JAISoundParamsTransition mTransition;\n}; // Size: 0x50\n\nstruct JAISoundParams\n{\n    JAISoundParams() : mMove() {}\n    void mixOutAll(JASSoundParams const &, JASSoundParams *, f32);\n\n    void init()\n    {\n        mMove.init();\n        mProperty.init();\n    }\n\n    JAISoundParamsProperty mProperty;\n    JAISoundParamsMove mMove;\n}; // Size: 0x5C\n\n#endif /* JAUDIO_JAISOUNDPARAMS_H *//* end \"JSystem/JAudio/Interface/JAISoundParams.h\" */\n/* \"include\\JSystem\\JAudio\\Interface\\JAISound.h\" line 6 \"JSystem/JAudio/System/JASTrack.h\" */\n#ifndef JAUDIO_JASTRACK_H\n#define JAUDIO_JASTRACK_H\n\n/* \"include\\JSystem\\JAudio\\System\\JASTrack.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n/* \"include\\JSystem\\JAudio\\System\\JASTrack.h\" line 4 \"JSystem/JAudio/System/JASSoundParams.h\" */\n/* end \"JSystem/JAudio/System/JASSoundParams.h\" */\n\nclass JASChannel;\n\nclass JASTrack\n{\npublic:\n    class MoveParam_\n    {\n        MoveParam_(); // 0x800a0270\n    };\n    class TChannelMgr\n    {\n        TChannelMgr(JASTrack *); // 0x800a3e4c\n        void init();             // 0x800a3ec0\n        void releaseAll();       // 0x800a3f30\n        void noteOff(u32, u16);  // 0x800a3fac\n        void setPauseFlag(bool); // 0x800a4088\n    };\n    class TList\n    {\n        void append(JASTrack *); // 0x800a3c3c\n        void seqMain();          // 0x800a3cf0\n        virtual ~TList(); // 0x800a42d8\n    };\n\n    JASTrack();                                                                // 0x800a018c\n    ~JASTrack();                                                               // 0x800a0288\n    void setChannelMgrCount(u32);                                              // 0x800a0374\n    void init();                                                               // 0x800a0544\n    void initTimed();                                                          // 0x800a09e8\n    void assignExtBuffer(u32, JASSoundParams *);                               // 0x800a0a5c\n    void setSeqData(void *, u32);                                              // 0x800a0af4\n    void startSeq();                                                           // 0x800a0b8c\n    void stopSeq();                                                            // 0x800a0c64\n    void start();                                                              // 0x800a0ca8\n    void close();                                                              // 0x800a0d60\n    void connectChild(u32, JASTrack *);                                        // 0x800a10e4\n    void closeChild(u32);                                                      // 0x800a1190\n    void openChild(u32);                                                       // 0x800a12ec\n    void connectBus(int, int);                                                 // 0x800a1820\n    void setLatestKey(u8);                                                     // 0x800a18b0\n    void noteOn(u32, u32, u32);                                                // 0x800a18ec\n    void gateOn(u32, u32, f32, u32);                                           // 0x800a1ac0\n    void noteOff(u32, u16);                                                    // 0x800a1cf8\n    void checkNoteStop(u32) const;                                             // 0x800a1db8\n    void overwriteOsc(JASChannel *);                                           // 0x800a1e74\n    void updateTimedParam();                                                   // 0x800a1f28\n    void updateTrack(f32);                                                     // 0x800a2014\n    void updateTempo();                                                        // 0x800a21b4\n    void updateSeq(bool, f32);                                                 // 0x800a2250\n    void seqTimeToDspTime(f32);                                                // 0x800a2578\n    void setParam(u32, f32, u32);                                              // 0x800a2614\n    void noteOffAll(u16);                                                      // 0x800a26d0\n    void mute(bool);                                                           // 0x800a29a0\n    //void setOscTable(u32, const JASOscillator::Point *);                       // 0x800a29d8\n    void setOscAdsr(s16, s16, s16, s16, u16);                                  // 0x800a2a74\n    void setFIR(const s16 *);                                                  // 0x800a2acc\n    void setIIR(const s16 *);                                                  // 0x800a2b2c\n    void readPortSelf(u32);                                                    // 0x800a2b80\n    void writePortSelf(u32, u16);                                              // 0x800a2ba4\n    void writePort(u32, u16);                                                  // 0x800a2bc8\n    void readPort(u32);                                                        // 0x800a2c2c\n    void pause(bool);                                                          // 0x800a2c50\n    void getTransposeTotal() const;                                            // 0x800a2d38\n    void isMute() const;                                                       // 0x800a2ea8\n    void setTempo(u16);                                                        // 0x800a3028\n    void setTempoRate(f32);                                                    // 0x800a30b8\n    void setTimebase(u16);                                                     // 0x800a3148\n    //void channelUpdateCallback(u32, JASChannel *, JASDsp::TChannel *, void *); // 0x800a31d8\n    void getRootTrack();                                                       // 0x800a3350\n    void tickProc();                                                           // 0x800a3368\n    void seqMain();                                                            // 0x800a3afc\n    // Inline/Unused\n    // void JASThreadingModel::InterruptsDisable<JASMemPool_MultiThreaded<TChannelMgr>>::Lock::~InterruptsDisable();\n    // void inherit(const JASTrack &);\n    // void setAutoMixingMode();\n    // void getVolume() const;\n    // void getPitch() const;\n    // void getPan() const;\n    // void getFxmix() const;\n    // void getDolby() const;\n    // void channelStart(TChannelMgr *, unsigned long, unsigned long, unsigned long);\n    // void setOscParam(unsigned long, const JASOscillator::Data &);\n    // void setChannelPauseFlag(bool);\n    // void updateChannel(JASChannel *, JASDsp::TChannel *);\n    // void getChannelCount() const;\n    // void JGadget::TLinkList<JASTrack, -584>::~TLinkList();\n    // void JASGlobalInstance<JASDefaultBankTable>::~JASGlobalInstance();\n\n    // Data\n    static s16 sAdsTable[12];         // 0x80369df0\n    //static sEnvOsc;            // 0x80369e08, combination of u32 and f32\n    //void sPitchEnvOsc;      // 0x80369e20\n    //void sDefaultBankTable; // 0x803fac24\n    //void sTrackList;        // 0x803fb070\n};\n\n#endif\n/* end \"JSystem/JAudio/System/JASTrack.h\" */\n\n/* \"include\\JSystem\\JAudio\\Interface\\JAISound.h\" line 8 \"types.h\" */\n/* end \"types.h\" */\n\nclass JAISound;\n\nclass JAISoundHandle\n{\npublic:\n    JAISoundHandle() { sound_ = NULL; }\n\n    JAISound *getSound()\n    {\n#line 41\n        JUT_ASSERT(sound_ != 0);\n        return sound_;\n    }\n\n    JAISound *operator->()\n    {\n#line 58\n        JUT_ASSERT(sound_ != 0)\n        return sound_;\n    }\n\n    operator bool() const { return isSoundAttached(); }\n\n    bool isSoundAttached() const { return sound_ != NULL; }\n\nprivate:\n    JAISound *sound_;\n};\n\nclass JAISoundID\n{\npublic:\n    JAISoundID() {}\n    JAISoundID(u32 id)\n    {\n        mID = id;\n    }\n    void setID(u32 id) { mID = id; }\n\n    void setAnonymous()\n    {\n        mID = 0xffffffff;\n    }\n\n    bool isAnonymous() const\n    {\n        return mID != 0xffffffff;\n    }\n\nprivate:\n    u32 mID;\n};\n\nstruct JAISoundStatus_ {\n    void init()\n    {\n        _0.pack = 0;\n        _1.pack = 0;\n        state.pack16 = 0;\n        user_data = 0;\n    }\n\n    bool isAlive() { return state.pack != 6; }\n    bool isDead() { return state.pack == 6; }\n    bool isPlaying() { return state.pack == 5; }\n    bool isMute() { return _0.flags.mute; }\n    bool isPaused() { return _0.flags.paused; }\n    void pauseWhenOut() { _1.flags.flag6 = 1;}\n\n    union\n    {\n        struct\n        {\n            u8 mute : 1;\n            u8 paused : 1;\n            u8 flag3 : 1;\n            u8 flag4 : 1;\n            u8 flag5 : 1;\n            u8 flag6 : 1;\n            u8 flag7 : 1;\n            u8 flag8 : 1;\n        } flags;\n        u8 pack;\n    } _0;\n\n    union\n    {\n        struct\n        {\n            u8 flag1 : 1;\n            u8 flag2 : 1;\n            u8 flag3 : 1;\n            u8 flag4 : 1;\n            u8 flag5 : 1;\n            u8 flag6 : 1;\n            u8 flag7 : 1;\n            u8 flag8 : 1;\n        } flags;\n        u8 pack;\n    } _1;\n\n    struct\n    {\n        struct\n        {\n            u8 flag1 : 1;\n            u8 flag2 : 1;\n            u8 animationState : 2;\n            u8 flag5 : 1;\n            u8 flag6 : 1;\n            u8 flag7 : 1;\n            u8 flag8 : 1;\n        } flags;\n        u8 pack;\n        u16 pack16; // HUH\n    } state;\n    u32 user_data;\n};\n\nstruct JAISoundFader\n{\n    void forceIn()\n    {\n        mIntensity = 1.0f;\n        mTransition.zero();\n    }\n    void forceOut()\n    {\n        mIntensity = 0.0f;\n        mTransition.zero();\n    }\n    void fadeIn(u32 fadeCount)\n    {\n        if (fadeCount == 0)\n            forceIn();\n        else\n            mTransition.set(1.0f, mIntensity, fadeCount);\n    }\n    void fadeOut(u32 fadeCount)\n    {\n        if (fadeCount != 0)\n            mTransition.set(0.0f, mIntensity, fadeCount);\n        else\n            forceOut();\n    }\n    void fadeInFromOut(u32 fadeCount)\n    {\n        mIntensity = 0.0f;\n        fadeIn(fadeCount);\n    }\n    bool isOut() { return (mTransition.mCount == 0 && mIntensity < 0.01f); }\n    void calc() { mIntensity = mTransition.apply(mIntensity); }\n    f32 getIntensity() { return mIntensity; }\n\n    f32 mIntensity;\n    JAISoundParamsTransition::TTransition mTransition;\n}; // Size: 0x10\n\nclass JAIAudible;\nclass JAIAudience;\nclass JAISe;\nclass JAISeq;\nclass JAISoundChild;\nclass JAIStream;\nclass JAITempoMgr;\n\nclass JAISound\n{\npublic:\n    void releaseHandle();\n    void attachHandle(JAISoundHandle *);\n    JAISound();\n    void start_JAISound_(JAISoundID, JGeometry::TVec3f const *, JAIAudience *);\n    bool acceptsNewAudible() const;\n    void newAudible(JGeometry::TVec3f const &, JGeometry::TVec3f const *, u32,\n                                   JAIAudience *);\n    void stop();\n    void stop(u32 fadeout);\n    void die_JAISound_();\n    void increasePrepareCount_JAISound_();\n    bool calc_JAISound_();\n    void initTrack_JAISound_(JASTrack *);\n\n    virtual s32 getNumChild() const = 0;\n    virtual JAISoundChild *getChild(int) = 0;\n    virtual void releaseChild(int) = 0;\n    virtual JAISe *asSe();\n    virtual JAISeq *asSeq();\n    virtual JAIStream *asStream();\n    virtual JASTrack *getTrack() = 0;\n    virtual JASTrack *getChildTrack(int) = 0;\n    virtual JAITempoMgr *getTempoMgr() = 0;\n    virtual bool JAISound_tryDie_() = 0;\n\n    JAISoundID getID() const;\n    u8 getAnimationState() const { return status_.state.flags.animationState; }\n    bool isAnimated() const { return getAnimationState() != 0; }\n    void setAnimationState(u8 pState)\n    {\n        status_.state.flags.animationState = pState;\n    }\n    u32 getUserData() const { return status_.user_data; }\n    void setUserData(u32 pUserData) { status_.user_data = pUserData; }\n    JAIAudible *getAudible() const { return audible_; }\n    bool isHandleAttached() const { return handle_ != NULL; }\n    bool hasLifeTime() const { return status_._1.flags.flag2; }\n    void removeLifeTime_() { status_._1.flags.flag1 = false; }\n    void stop_JAISound_()\n    {\n        status_.state.flags.flag5 = 0;\n        status_.state.flags.flag1 = 1;\n    }\n    bool isStopping()\n    {\n        bool isStopping = false;\n        if (status_.state.flags.flag1)\n        {\n            isStopping = !status_.state.flags.flag5 || fader_.isOut();\n        }\n        return isStopping;\n    }\n\n    void pause(bool doPause)\n    {\n        status_._0.flags.paused = doPause;\n    }\n\n    void updateLifeTime(u32 newLifeTime)\n    {\n        if (lifeTime_ < newLifeTime)\n        {\n            lifeTime_ = newLifeTime;\n        }\n    }\n\n    void setLifeTime(u32 newLifeTime, bool pause)\n    {\n        lifeTime_ = newLifeTime;\n        setComesBack(pause);\n        status_._1.flags.flag2 = 1;\n    }\n\n    void setComesBack(bool pause)\n    {\n        status_._1.flags.flag1 = 1;\n        if (pause)\n        {\n            status_.pauseWhenOut();\n        }\n    }\n\n    bool setPos(const JGeometry::TVec3f &pos)\n    {\n        if (audible_ != NULL)\n        {\n            audible_->setPos(pos);\n        }\n        return audible_ != NULL;\n    }\n\n    void fadeIn(u32 fadeCount)\n    {\n        fader_.fadeInFromOut(fadeCount);\n        return;\n    }\n\n    s32 getCount() const { return count_; }\n\n    JAISoundParamsMove &getAuxiliary() { return params_.mMove; }\n\nprivate:\n    JAISoundHandle *handle_;\n    JAIAudible *audible_;\n    JAIAudience *audience_;\n    u32 lifeTime_;\n    s32 prepareCount_;\n    JAISoundID soundID_;\n    JAISoundStatus_ status_;\n    JAISoundFader fader_;\n    u32 priority_;\n    s32 count_;\n    JAISoundParams params_;\n}; // Size: 0x98\n\n#endif/* end \"JSystem/JAudio/Interface/JAISound.h\" */\n\nstruct JAISeqData\n{\n    JAISeqData(void *param_0, u32 param_1)\n    {\n        _0 = param_0;\n        _4 = param_1;\n    }\n\n    void set(void *param_0, u32 param_1)\n    {\n        _0 = param_0;\n        _4 = param_1;\n    }\n\n    void *_0;\n    u32 _4;\n};\n\nstruct JAISeqDataRegion\n{\n    bool intersects(JAISeqData &seqData) const\n    {\n        if (_0 + _4 < (u32)seqData._0)\n        {\n            return false;\n        }\n        if ((u32)seqData._0 + seqData._4 < _0)\n        {\n            return false;\n        }\n        return true;\n    }\n\n    u32 _0;\n    u32 _4;\n};\n\nstruct JAISeqDataUser\n{\n    virtual ~JAISeqDataUser();\n    virtual bool isUsingSeqData(JAISeqDataRegion const &) = 0;\n    virtual int releaseSeqData(JAISeqDataRegion const &) = 0;\n};\n\nstruct JAISeqDataMgr\n{\n    enum SeqDataReturnValue\n    {\n        SeqDataReturnValue_0 = 0,\n        SeqDataReturnValue_1 = 1,\n        SeqDataReturnValue_2 = 2\n    };\n    virtual ~JAISeqDataMgr();\n    virtual SeqDataReturnValue getSeqData(JAISoundID, JAISeqData *) = 0;\n    virtual int releaseSeqData() = 0;\n    virtual bool setSeqDataUser(JAISeqDataUser *) = 0;\n};\n\n#endif /* JAUDIO_JAISEQDATAMGR_H *//* end \"JSystem/JAudio/Interface/JAISeqDataMgr.h\" */\n/* \"include\\JSystem\\JAudio\\JAUSectionHeap.h\" line 4 \"JSystem/JAudio/Interface/JAISound.h\" */\n/* end \"JSystem/JAudio/Interface/JAISound.h\" */\n/* \"include\\JSystem\\JAudio\\JAUSectionHeap.h\" line 5 \"JSystem/JAudio/System/JASGadget.h\" */\n#ifndef JAUDIO_JASGADGET_H\n#define JAUDIO_JASGADGET_H\n\n/* \"include\\JSystem\\JAudio\\System\\JASGadget.h\" line 3 \"string.h\" */\n/* end \"string.h\" */\n/* \"include\\JSystem\\JAudio\\System\\JASGadget.h\" line 4 \"JSystem/JUtility/JUTDbg.h\" */\n/* end \"JSystem/JUtility/JUTDbg.h\" */\n\ntemplate <class T>\nclass JASGlobalInstance\n{\npublic:\n    JASGlobalInstance(T *inst)\n    {\n        sInstance = inst;\n    }\n\n    JASGlobalInstance(bool param_1)\n    {\n        if (param_1)\n        {\n#line 186\n            JUT_ASSERT(sInstance == 0);\n            sInstance = (T *)this;\n        }\n    }\n\n    ~JASGlobalInstance()\n    {\n        if (sInstance == (T *)this)\n        {\n            sInstance = NULL;\n        }\n    }\n\n    static T *getInstance() { return sInstance; }\n\n    static T *sInstance;\n};\n\ntemplate <class T>\nclass JASPtrTable\n{\npublic:\n    JASPtrTable(T **table, u32 size)\n    {\n        mTable = table;\n        mSize = size;\n        memset(mTable, 0, size * 4);\n    }\n    T *get(u32 index)\n    {\n        if (index >= mSize)\n            return NULL;\n        return mTable[index];\n    }\n    T *get(u32 index) const\n    {\n        if (index >= mSize)\n            return NULL;\n\n        return mTable[index];\n    }\n    void set(u32 index, T *value)\n    {\n#line 229\n        JUT_ASSERT(index < mSize);\n        mTable[index] = value;\n    }\n\nprivate:\n    T **mTable;\n    u32 mSize;\n};\n\ntemplate <class T, size_t N>\nclass JASPtrArray : public JASPtrTable<T>\n{\npublic:\n    JASPtrArray() : JASPtrTable<T>(mArray, N) {}\n\nprivate:\n    T *mArray[N];\n};\n\n#endif /* JAUDIO_JASGADGET_H *//* end \"JSystem/JAudio/System/JASGadget.h\" */\n/* \"include\\JSystem\\JAudio\\JAUSectionHeap.h\" line 6 \"JSystem/JAudio/JAUBankTable.h\" */\n#ifndef JAUBANKTABLE_H\n#define JAUBANKTABLE_H\n\n/* \"include\\JSystem\\JAudio\\JAUBankTable.h\" line 3 \"JSystem/JAudio/System/JASGadget.h\" */\n/* end \"JSystem/JAudio/System/JASGadget.h\" */\n/* \"include\\JSystem\\JAudio\\JAUBankTable.h\" line 4 \"JSystem/JAudio/System/JASBankList.h\" */\n#ifndef JAUDIO_JASBANKLIST_H\n#define JAUDIO_JASBANKLIST_H\n\n/* \"include\\JSystem\\JAudio\\System\\JASBankList.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\nclass JASBank;\n\nclass JASBankList\n{\npublic:\n    virtual JASBank *getBank(u32 param_0) const = 0;\n};\n\n#endif /* JAUDIO_JASBANKLIST_H *//* end \"JSystem/JAudio/System/JASBankList.h\" */\n/* \"include\\JSystem\\JAudio\\JAUBankTable.h\" line 5 \"JSystem/JSupport/JSUList.h\" */\n/* end \"JSystem/JSupport/JSUList.h\" */\n\nclass JASBank;\nclass JAUBankTable : public JASBankList\n{\npublic:\n    JAUBankTable(u32 param_0, JASBank **param_1, u32 param_2) : mBankPtrTable(param_1, param_2)\n    {\n        field_0xc = param_0;\n    }\n    JASBank *getBank(u32) const;\n\n    JASBank *getBank(u32 param_0) { return mBankPtrTable.get(param_0); }\n    void registBank(u32 param_0, JASBank *param_1) { mBankPtrTable.set(param_0, param_1); }\n\n    JASPtrTable<JASBank> mBankPtrTable; // 04\n    u32 field_0xc;\n};\n\nclass JAUBankTableLink : public JSULink<JAUBankTable>, public JAUBankTable\n{\npublic:\n    JAUBankTableLink(u32 param_0, JASBank **param_1, u32 param_2) : JSULink<JAUBankTable>(this), JAUBankTable(param_0, param_1, param_2) {}\n};\n\nstruct JAUBankTableDictionary : JSUList<JAUBankTable>\n{\n   void appendBankTable(JSULink<JAUBankTable> *);\n};\n\nclass JASWaveBank;\nclass JAUWaveBankTable : private JASPtrArray<JASWaveBank, 255>\n{\npublic:\n    JASWaveBank *getWaveBank(u32 index) { return get(index); }\n    JASWaveBank *getWaveBank(u32 index) const { return get(index); }\n    void registWaveBank(u32 index, JASWaveBank *bank) { set(index, bank); }\n};\n\n#endif /* JAUBANKTABLE_H *//* end \"JSystem/JAudio/JAUBankTable.h\" */\n/* \"include\\JSystem\\JAudio\\JAUSectionHeap.h\" line 7 \"JSystem/JAudio/JAUSeqDataBlockMgr.h\" */\n#ifndef JAUDIO_JAUSEQDATABLOCKMGR_H\n#define JAUDIO_JAUSEQDATABLOCKMGR_H\n\n/* \"include\\JSystem\\JAudio\\JAUSeqDataBlockMgr.h\" line 3 \"JSystem/JAudio/Interface/JAISound.h\" */\n/* end \"JSystem/JAudio/Interface/JAISound.h\" */\n/* \"include\\JSystem\\JAudio\\JAUSeqDataBlockMgr.h\" line 4 \"JSystem/JSupport/JSUList.h\" */\n/* end \"JSystem/JSupport/JSUList.h\" */\n\nclass JAISeqData;\nclass JAISeqDataUser;\nclass JKRArchive;\n\nstruct JAUSeqDataBlock\n{\n    JAUSeqDataBlock();\n\n    JSULink<JAUSeqDataBlock> _0;\n    JAISoundID _10;\n    u8 *_14;\n    u32 _18;\n    int _1c;\n};\n\nclass JAUSeqDataBlocks\n{\npublic:\n    void getSeqData(JAISoundID);\n    void seekFreeBlock(u32);\n    void append(JSULink<JAUSeqDataBlock> *);\n    void remove(JSULink<JAUSeqDataBlock> *);\n    void hasFailedBlock(JAISoundID);\n\n    JSUList<JAUSeqDataBlock> _0;\n};\n\nclass JAUDynamicSeqDataBlocks\n{\npublic:\n    JAUDynamicSeqDataBlocks();\n    void setSeqDataArchive(JKRArchive *);\n    s32 getSeqData(JAISoundID, JAISeqDataUser *, JAISeqData *, bool);\n    bool appendDynamicSeqDataBlock(JAUSeqDataBlock *);\n    bool loadDynamicSeq(JAISoundID, bool, JAISeqDataUser *);\n    void releaseIdleDynamicSeqDataBlock(JAISeqDataUser *);\n    void releaseIdleDynamicSeqDataBlock_(JAISeqDataUser *, u32);\n    void rearrangeLoadingSeqs_();\n\n    JKRArchive *getSeqDataArchive() { return seqDataArchive_; }\n\n    JAUSeqDataBlocks _0;\n    JAUSeqDataBlocks _c;\n    JAUSeqDataBlocks _18;\n    JKRArchive *seqDataArchive_; // 24\n};\n\n#endif /* JAUDIO_JAUSEQDATABLOCKMGR_H *//* end \"JSystem/JAudio/JAUSeqDataBlockMgr.h\" */\n/* \"include\\JSystem\\JAudio\\JAUSectionHeap.h\" line 8 \"JSystem/JKernel/JKRDisposer.h\" */\n/* end \"JSystem/JKernel/JKRDisposer.h\" */\n/* \"include\\JSystem\\JAudio\\JAUSectionHeap.h\" line 9 \"std/bitset.h\" */\n#ifndef MSL_BITSET_H_\n#define MSL_BITSET_H_\n\n/* \"include\\std\\bitset.h\" line 3 \"algorithm\" */\n#ifndef _STD_ALGORITHM_H\n#define _STD_ALGORITHM_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\algorithm\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n/* \"libs\\PowerPC_EABI_Support\\include\\algorithm\" line 5 \"iterator\" */\n#ifndef _STD_ITERATOR_H\n#define _STD_ITERATOR_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\iterator\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\nnamespace std {\ntypedef long ptrdiff_t;\n\nstruct input_iterator_tag {\n};\nstruct output_iterator_tag {\n};\nstruct forward_iterator_tag : public input_iterator_tag {\n};\nstruct bidirectional_iterator_tag : public forward_iterator_tag {\n};\nstruct randomAccess_iterator_tag : public bidirectional_iterator_tag {\n};\n\ntemplate <typename Iterator>\nstruct iterator_traits {\n\ttypedef typename Iterator::difference_type difference_type;\n\ttypedef typename Iterator::value_type value_type;\n\ttypedef typename Iterator::pointer pointer;\n\ttypedef typename Iterator::reference reference;\n\ttypedef typename Iterator::iterator_category iterator_category;\n};\n\ntemplate <typename IteratorTag, typename ValueType, typename DifferenceType = ptrdiff_t, typename Pointer = ValueType*,\n          typename Reference = ValueType&>\nstruct iterator {\n\ttypedef IteratorTag iterator_category;\n\ttypedef ValueType value_type;\n\ttypedef DifferenceType difference_type;\n\ttypedef Pointer pointer;\n\ttypedef Reference reference;\n};\n} // namespace std\n\n#endif\n/* end \"iterator\" */\n\nnamespace std\n{\n\ttemplate <class InputIterator>\n\tinline s32\n\t__distance(InputIterator first, InputIterator last, input_iterator_tag)\n\t{\n\t\ts32 result = 0;\n\t\tfor (; first != last; ++first)\n\t\t\t++result;\n\t\treturn result;\n\t}\n\n\ttemplate <class InputIterator>\n\tinline s32\n\tdistance(InputIterator first, InputIterator last)\n\t{\n\t\tinput_iterator_tag tag;\n\t\treturn __distance(first, last, tag);\n\t}\n\n\ttemplate <typename InputIterator, typename Predicate>\n\tinline InputIterator find_if(InputIterator first, InputIterator last, Predicate p)\n\t{\n\t\tfor (; first != last && !p(*first); ++first)\n\t\t{\n\t\t}\n\t\treturn first;\n\t}\n\n\ttemplate <typename ForwardIterator, typename Element, typename Predicate>\n\tForwardIterator upper_bound(ForwardIterator first, ForwardIterator last, const Element &value, Predicate predicate);\n} // namespace std\n\n#endif\n/* end \"algorithm\" */\n/* \"include\\std\\bitset.h\" line 4 \"stdio.h\" */\n/* end \"stdio.h\" */\n/* \"include\\std\\bitset.h\" line 5 \"stdlib.h\" */\n#ifndef _STDLIB_H\n#define _STDLIB_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\stdlib.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\n/* \"libs\\PowerPC_EABI_Support\\include\\stdlib.h\" line 8 \"PowerPC_EABI_Support/MSL_C/MSL_Common/alloc.h\" */\n#ifndef _MSL_ALLOC_H\n#define _MSL_ALLOC_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\alloc.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\nvoid free(void*);\n\n#endif\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/alloc.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\stdlib.h\" line 9 \"PowerPC_EABI_Support/MSL_C/MSL_Common/arith.h\" */\n#ifndef _MSL_COMMON_ARITH_H\n#define _MSL_COMMON_ARITH_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\arith.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n\tint quot; /* quotient */\n\tint rem;  /* remainder */\n} div_t;\n\nint abs(int __x);\nlong labs(long __x);\ndiv_t div(s32 __numer, s32 __denom);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/arith.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\stdlib.h\" line 10 \"PowerPC_EABI_Support/MSL_C/MSL_Common/mbstring.h\" */\n#ifndef _MSL_MBSTRING_H\n#define _MSL_MBSTRING_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\mbstring.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint __mbtowc_noconv(wchar_t*, const char*, size_t);\nint __wctomb_noconv(char*, wchar_t);\nsize_t wcstombs(char* s, const wchar_t* pwcs, size_t n);\nint mbstowcs(wchar_t* pwc, const char* s, size_t n);\nint wctomb(char* s, wchar_t wchar);\nstatic int unicode_to_UTF8(char* s, wchar_t wchar);\nint mbtowc(wchar_t* pwc, const char* s, size_t n);\nstatic int is_utf8_complete(const char* s, size_t n);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/mbstring.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\stdlib.h\" line 11 \"PowerPC_EABI_Support/MSL_C/MSL_Common/rand.h\" */\n#ifndef _MSL_RAND_H\n#define _MSL_RAND_H\n\n/* \"libs\\PowerPC_EABI_Support\\include\\PowerPC_EABI_Support\\MSL_C\\MSL_Common\\rand.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // ifdef __cplusplus\n\nint rand();\nvoid srand(u32 seed);\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/rand.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\stdlib.h\" line 12 \"PowerPC_EABI_Support/MSL_C/MSL_Common/strtold.h\" */\n#ifndef _MSL_STRTOLD_H\n#define _MSL_STRTOLD_H\n\nlong double __strtold(int max_width, int (*ReadProc)(void*, int, int), void* ReadProcArg, int* chars_scanned, int* overflow);\n\n#endif\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/strtold.h\" */\n/* \"libs\\PowerPC_EABI_Support\\include\\stdlib.h\" line 13 \"PowerPC_EABI_Support/MSL_C/MSL_Common/strtoul.h\" */\n#ifndef _MSL_STRTOUL_H\n#define _MSL_STRTOUL_H\n\nunsigned long __strtoul(int base, int max_width, int (*ReadProc)(void*, int, int), void* ReadProcArg, int* chars_scanned, int* negative,\n                        int* overflow);\nunsigned long long __strtoull(int base, int max_width, int (*ReadProc)(void*, int, int), void* ReadProcArg, int* chars_scanned,\n                              int* negative, int* overflow);\nint atoi(const char* str);\n\n#endif\n/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/strtoul.h\" */\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif\n/* end \"stdlib.h\" */\n/* \"include\\std\\bitset.h\" line 6 \"PowerPC_EABI_Support/MSL_C/MSL_Common/abort_exit.h\" */\n#ifndef ABORT_EXIT_H\n#define ABORT_EXIT_H\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif // ifdef __cplusplus\n\nvoid abort();\nvoid exit(int status);\nvoid __exit(int status);\n\n#ifdef __cplusplus\n};\n#endif // ifdef __cplusplus\n\n#endif/* end \"PowerPC_EABI_Support/MSL_C/MSL_Common/abort_exit.h\" */\n\nnamespace std\n{\n    // TODO: where does this go?\n    inline void __msl_error(const char *param_0)\n    {\n        fprintf(stderr, param_0);\n        abort();\n    }\n\n    template <size_t N>\n    class __bitset_base\n    {\n    public:\n        __bitset_base();\n\n        bool test(size_t pos) const;\n        bool any() const;\n        void set(size_t pos, bool val);\n        void reset(size_t pos);\n\n    private:\n        size_t data[N];\n    };\n\n    template <size_t N>\n    __bitset_base<N>::__bitset_base()\n    {\n        std::fill(data, data + N, 0);\n    }\n\n    template <size_t N>\n    bool __bitset_base<N>::test(size_t pos) const\n    {\n        size_t i = pos / (sizeof(size_t) * 8);\n        size_t mask = 1 << (pos % (sizeof(size_t) * 8));\n        return data[i] & mask;\n    }\n\n    template <size_t N>\n    void __bitset_base<N>::set(size_t pos, bool val)\n    {\n        size_t i = pos / (sizeof(size_t) * 8);\n        size_t mask = 1 << (pos % (sizeof(size_t) * 8));\n        if (val)\n        {\n            data[i] |= mask;\n        }\n        else\n        {\n            data[i] &= ~mask;\n        }\n    }\n\n    template <size_t N>\n    void __bitset_base<N>::reset(size_t pos)\n    {\n        size_t i = pos / (sizeof(size_t) * 8);\n        size_t mask = 1 << (pos % (sizeof(size_t) * 8));\n        data[i] &= ~mask;\n    }\n\n    template <size_t N>\n    class bitset : private __bitset_base<(N - 1) / (sizeof(size_t) * 8) + 1>\n    {\n    public:\n        typedef __bitset_base<(N - 1) / (sizeof(size_t) * 8) + 1> base;\n\n        bitset(){};\n\n        void set(size_t pos, bool val)\n        {\n            if (pos >= N)\n            {\n                __msl_error(\"index out of range of bitset::set\");\n            }\n            base::set(pos, val);\n        }\n        void reset(size_t pos)\n        {\n            if (pos >= N)\n            {\n                __msl_error(\"index out of range of bitset::reset\");\n            }\n            base::reset(pos);\n        }\n        bool test(size_t pos) const\n        {\n            if (pos >= N)\n            {\n                __msl_error(\"index out of range of bitset::test\");\n            }\n            return base::test(pos);\n        }\n        bool any() const;\n    };\n} // namespace std\n\n#endif/* end \"std/bitset.h\" */\n\nclass JAIStreamDataMgr;\nclass JASVoiceBank;\nclass JAUBankTableLink;\nclass JAUDisposer_;\nclass JAUSectionHeap;\nclass JAUSoundTable;\nclass JAUSoundNameTable;\nclass JKRArchive;\nclass JKRSolidHeap;\n\nclass JAUSection : public JKRDisposer, protected JSULink<JAUSection>\n{\npublic:\n    struct TSectionData\n    {\n        TSectionData();\n        void resetRegisteredBankTables();\n        void resetRegisteredWaveBankTables();\n\n        JAUDynamicSeqDataBlocks _00;               //\n        JSUList<JAUSeqDataBlock> _28;              //\n        std::bitset<255> registeredWaveBankTables; // 34\n        std::bitset<255> registeredBankTables;     // 54\n        JAUBankTableDictionary _74;                //\n        JAISeqDataMgr *_80;                        //\n        const void *mBstDst;                       // 84\n        const void *mBstnDst;                      // 88\n        JSUList<JAUDisposer_> _8c;                 //\n        s32 _98;                                   //\n        int _9c;                                   //\n        int _a0;                                   //\n    };\n\n    JAUSection(JAUSectionHeap *, u32, s32);\n    virtual ~JAUSection();\n    virtual void dispose();\n\n    void finishBuild();\n    JAUSoundTable *newSoundTable(void const *, u32, bool);\n    JAUSoundNameTable *newSoundNameTable(void const *, u32, bool);\n    JAIStreamDataMgr *newStreamFileTable(void const *, bool);\n    JAISeqDataMgr *newSeSeqCollection(void const *, u32);\n    u8 *newStaticSeqDataBlock_(JAISoundID, u32);\n    bool newStaticSeqData(JAISoundID, void const *, u32);\n    bool newStaticSeqData(JAISoundID);\n    void *newCopy(void const *data, u32 size, s32 alignment);\n    JASWaveBank *newWaveBank(u32, void const *);\n    bool loadWaveArc(u32, u32);\n    JASBank *newBank(void const *, u32);\n    JASVoiceBank *newVoiceBank(u32, u32);\n    bool beginNewBankTable(u32, u32);\n    JAUBankTable *endNewBankTable();\n\n    bool isBuilding() { return _2c; }\n    bool isOpen();\n    JAUSectionHeap *asSectionHeap() { return (JAUSection *)sectionHeap_ == this ? sectionHeap_ : NULL; }\n    JKRHeap *getHeap_();\n\n    u32 _28;                              //\n    bool _2c;                             //\n    JAUSectionHeap *sectionHeap_;         // 30\n    JAUBankTableLink *buildingBankTable_; // 34\n    TSectionData data_;                   // 38\n};\n\nclass JAUSectionHeap : public JAUSection, JASGlobalInstance<JAUSectionHeap>, JAISeqDataMgr\n{\npublic:\n    struct TSectionHeapData\n    {\n        TSectionHeapData();\n\n        JAUWaveBankTable waveBankTable;    // 000\n        JAISeqDataUser *seqDataUser;       // 404 page error\n        JAUDynamicSeqDataBlocks _408;      // 408\n        JAISeqDataMgr *seSeqDataMgr_;      // 430\n        JAIStreamDataMgr *streamDataMgr_;  // 434\n        JAUSoundTable *soundTable;         // 438\n        JAUSoundNameTable *soundNameTable; // 43C\n    };\n\n    void setSeqDataArchive(JKRArchive *);\n    bool loadDynamicSeq(JAISoundID, bool);\n    void releaseIdleDynamicSeqDataBlock();\n    JAUSectionHeap(JKRSolidHeap *, bool, s32);\n    JAUSection *getOpenSection();\n    bool setSeqDataUser(JAISeqDataUser *);\n    bool newDynamicSeqBlock(u32);\n    SeqDataReturnValue getSeqData(JAISoundID, JAISeqData *);\n    int releaseSeqData();\n    ~JAUSectionHeap();\n\n    JAUWaveBankTable &getWaveBankTable() { return sectionHeapData_.waveBankTable; }\n\n    JKRHeap *heap_;                    // E0\n    int _e4;                           //\n    JSUList<JAUSection> sectionList_;  // E8\n    TSectionHeapData sectionHeapData_; // F4\n};\n\ninline JKRHeap *JAUSection::getHeap_() { return sectionHeap_->heap_; }\ninline bool JAUSection::isOpen() { return this == sectionHeap_->getOpenSection(); }\n\nJAUSectionHeap *JAUNewSectionHeap(bool);\n\n#endif /* JAUDIO_JAUSECTIONHEAP_H *//* end \"JSystem/JAudio/JAUSectionHeap.h\" */\n\n/* \"include\\Inagaki\\GameAudioMain.h\" line 6 \"Inagaki/GameAudioFxConfig.h\" */\n#ifndef GAMEAUDIOFXCONFIG_H\n#define GAMEAUDIOFXCONFIG_H\n\n/* \"include\\Inagaki\\GameAudioFxConfig.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n/* \"include\\Inagaki\\GameAudioFxConfig.h\" line 4 \"JSystem/JKernel/JKRHeap.h\" */\n/* end \"JSystem/JKernel/JKRHeap.h\" */\n/* \"include\\Inagaki\\GameAudioFxConfig.h\" line 5 \"JSystem/JAudio/System/JASDsp.h\" */\n#ifndef JAUDIO_JASDSP_H\n#define JAUDIO_JASDSP_H\n\n/* \"include\\JSystem\\JAudio\\System\\JASDsp.h\" line 3 \"types.h\" */\n/* end \"types.h\" */\n\n/* \"include\\JSystem\\JAudio\\System\\JASDsp.h\" line 5 \"JSystem/JUtility/JUTAssert.h\" */\n/* end \"JSystem/JUtility/JUTAssert.h\" */\n\nstruct JASWaveInfo;\n\nnamespace JASDsp\n{\n    // typedef s16 Fxline[0x10];\n    /** @fabricated */\n    struct Fxline\n    {\n        u16 _00;    // _00\n        u16 _02;    // _02\n        s16 *_04;   // _04\n        u16 _08;    // _08\n        u16 _0A;    // _0A\n        u16 _0C;    // _0C\n        u16 _0E;    // _0E\n        u16 mFilterTable[8]; // _10\n\n        // u16 _12;  // _12\n        // u16 _14;  // _14\n        // u16 _16;  // _16\n        // u16 _18;  // _18\n        // u16 _1A;  // _1A\n        // u16 _1C;  // _1C\n        // u16 _1E;  // _1E\n    };\n\n    struct FxlineConfig_\n    {\n        u8 _00;              // _00\n        s16 _02;             // _02\n        s16 _04;             // _04\n        s16 _06;             // _06\n        s16 _08;             // _08\n        u32 mBufCount;       // _0C\n        s16 mFilterTable[8]; // _10\n    };\n\n    struct TChannel\n    {\n        /**\n         * @fabricated\n         * probably mixer\n         */\n        struct TChannel_0x10\n        {\n            u16 _00;\n            s16 _02;\n            u16 _04;\n            u16 _06;\n        };\n\n        void init();\n        void playStart();\n        void playStop();\n        void replyFinishRequest();\n        void forceStop();\n        bool isFinish() const;\n        void setWaveInfo(const JASWaveInfo &, u32, u32);\n        void setOscInfo(u32);\n        void initAutoMixer();\n        void setAutoMixer(u16, u8, u8, u8, u8);\n        void setPitch(u16);\n        void setMixerInitDelayMax(u8);\n        void setMixerInitVolume(u8, s16);\n        void setMixerInitDelaySamples(u8, u8);\n        void setMixerDelaySamples(u8, u8);\n        void setMixerVolume(u8, s16);\n        void setPauseFlag(u8);\n        void flush();\n        void initFilter();\n        void setFilterMode(u16);\n        void setIIRFilterParam(s16 *);\n        void setFIR8FilterParam(s16 *);\n        void setDistFilter(s16);\n        void setBusConnect(u8, u8);\n\n        // unused/inlined:\n        bool isActive() const;\n        u16 getBlockCounter() const;\n        u16 getRemainSamples() const;\n        void updateAMVolume(u16);\n        void updateAMPan(u8, u8);\n        void updateAMFX(u8);\n\n        u16 mIsActive;   // _00\n        u16 mIsFinished; // _02\n        s16 mPitch;      // _04\n        s16 _06;\n        u16 _08;                 // _08\n        u16 _0A;                 // _0A\n        u16 mPauseFlag;          // _0C\n        u16 mMixerInitDelayMax;  // _0E\n        TChannel_0x10 _10[4];    // _10 (unknown length)\n        u8 _30[0x20];            // _30\n        u16 _50;                 // _50\n        u16 _52;                 // _52\n        u16 _54;                 // _54\n        u16 _56;                 // _56\n        u16 _58;                 // _58\n        u8 _5C[4];               // _5C\n        u16 _60;                 // _60\n        u16 _62;                 // _62\n        u16 _64;                 // _64\n        u16 _66;                 // _66\n        u32 _68;                 // _68\n        u8 _6C[0xC];             // _6C\n        u16 _78[4];              // _78\n        u16 _80[0x14];           // _80\n        u16 _A8[4];              // _A8\n        u16 _B0[0x10];           // _B0\n        u8 _D0[0x30];            // _D0\n        u16 _100;                // _100\n        u16 _102;                // _102\n        s16 _104;                // _104\n        s16 _106;                // _106\n        u16 mFilterMode;         // _108\n        u16 mForcedStop;         // _10A\n        u32 _10C;                // _10C\n        u32 _110;                // _110\n        u32 _114;                // _114\n        u32 _118;                // _118\n        u32 _11C;                // _11C\n        s16 mFir8FilterParam[8]; // _120\n        u8 _130[0x18];           // _130\n        s16 mIirFilterParam[4];  // _148\n        s16 mDistFilter;         // _150\n    };\n\n    void boot(void (*)(void *));\n    void releaseHalt(u32);\n    void finishWork(u16);\n    void syncFrame(u32, u32, u32);\n    void setDSPMixerLevel(f32);\n    f32 getDSPMixerLevel();\n    TChannel *getDSPHandle(int index);\n    void invalChannelAll();\n    void initBuffer();\n    bool setFXLine(u8, s16 *, JASDsp::FxlineConfig_ *);\n\n    // unused/inlined:\n    void getDSPHandleNc(int);\n    void setFilterTable(s16 *, s16 *, u32);\n    void flushBuffer();\n    void flushChannelAll();\n    void cacheChannelAll();\n    Fxline &getFXHandle(u8);\n    void getFXHandleNc(u8);\n    void changeFXLineParam(u8, u8, u32);\n\n    extern u8 *CH_BUF;\n    extern Fxline *FX_BUF;\n    extern f32 sDSPVolume;\n    extern const s16 SEND_TABLE[12];\n    extern const u16 DSPADPCM_FILTER[32];\n    extern const u16 DSPRES_FILTER[640];\n\n} // namespace JASDsp\n\nstruct JASDSPChannel\n{\n    typedef s32 (*Callback)(u32, JASDsp::TChannel *, void *);\n    JASDSPChannel();\n    void free();\n    void start();\n    void drop();\n    static void initAll();\n    static JASDSPChannel *alloc(u8, Callback, void *);\n    static JASDSPChannel *allocForce(u8, Callback, void *);\n    void setPriority(u8);\n    static JASDSPChannel *getLowestChannel(int);\n    void updateProc();\n    static void updateAll();\n    static bool killActiveChannel();\n    static JASDSPChannel *getHandle(u32 index);\n\n    // unused/inlined:\n    static JASDSPChannel *getLowestActiveChannel();\n    void getNumUse();\n    void getNumFree();\n    void getNumBreak();\n\n    s32 _00;\n    s16 _04;\n    u32 _08;\n    u32 _0C;\n    Callback _10;\n    void *_14;\n    JASDsp::TChannel *_18;\n\n    static JASDSPChannel *sDspChannels;\n};\n\nu16 DSP_CreateMap2(u32);\n\n// unused/inlined:\nvoid DSP_CreateMap();\n\n#endif\n/* end \"JSystem/JAudio/System/JASDsp.h\" */\n\n// maybe merge with GameAudioMain?\n\nnamespace GameAudio\n{\n    extern JASDsp::FxlineConfig_ Non[4];\n    extern JASDsp::FxlineConfig_ Hall[4];\n    extern JASDsp::FxlineConfig_ Room[4];\n    extern JASDsp::FxlineConfig_ Canyon[4];\n\n    class FxLineConfig \n    {\n    public:\n        FxLineConfig(JKRHeap *heap);\n        void set(u8 lineNum);\n\n    private:\n        u8 mNum;\n        JASDsp::FxlineConfig_ *mConfig[4];\n        s16 *mBuf[4];\n    };\n}\n\n#endif\n/* end \"Inagaki/GameAudioFxConfig.h\" */\n/* \"include\\Inagaki\\GameAudioMain.h\" line 7 \"Inagaki/GameSoundTable.h\" */\n#ifndef GAMESOUNDTABLE_H\n#define GAMESOUNDTABLE_H\n\n/* \"include\\Inagaki\\GameSoundTable.h\" line 3 \"JSystem/JAudio/Interface/JAISoundInfo.h\" */\n#ifndef JAUDIO_JAISOUNDINFO_H\n#define JAUDIO_JAISOUNDINFO_H\n\n/* \"include\\JSystem\\JAudio\\Interface\\JAISoundInfo.h\" line 3 \"JSystem/JAudio/Interface/JAISound.h\" */\n/* end \"JSystem/JAudio/Interface/JAISound.h\" */\n/* \"include\\JSystem\\JAudio\\Interface\\JAISoundInfo.h\" line 4 \"JSystem/JAudio/System/JASGadget.h\" */\n/* end \"JSystem/JAudio/System/JASGadget.h\" */\n\nstruct JAISoundInfo : public JASGlobalInstance<JAISoundInfo>\n{\n    JAISoundInfo(bool);\n    virtual u32 getSoundType(JAISoundID) const = 0;\n    virtual int getCategory(JAISoundID) const = 0;\n    virtual u32 getPriority(JAISoundID) const = 0;\n    virtual void getSeInfo(JAISoundID, JAISe *) const = 0;\n    virtual void getSeqInfo(JAISoundID, JAISeq *) const = 0;\n    virtual void getStreamInfo(JAISoundID, JAIStream *) const = 0;\n    virtual ~JAISoundInfo();\n};\n\n#endif /* JAUDIO_JAISOUNDINFO_H *//* end \"JSystem/JAudio/Interface/JAISoundInfo.h\" */\n/* \"include\\Inagaki\\GameSoundTable.h\" line 4 \"JSystem/JAudio/Interface/JAIStreamDataMgr.h\" */\n#ifndef JAUDIO_JAISTREAMDATAMGR_H\n#define JAUDIO_JAISTREAMDATAMGR_H\n\n/* \"include\\JSystem\\JAudio\\Interface\\JAIStreamDataMgr.h\" line 3 \"JSystem/JAudio/Interface/JAISound.h\" */\n/* end \"JSystem/JAudio/Interface/JAISound.h\" */\n\nstruct JAIStreamDataMgr\n{\n    virtual s32 getStreamFileEntry(JAISoundID) = 0;\n    virtual ~JAIStreamDataMgr();\n};\n\nstruct JAIStreamAramMgr\n{\n    virtual void *newStreamAram(u32 *) = 0;\n    virtual void deleteStreamAram(u32) = 0;\n    virtual ~JAIStreamAramMgr();\n};\n\n#endif /* JAUDIO_JAISTREAMDATAMGR_H *//* end \"JSystem/JAudio/Interface/JAIStreamDataMgr.h\" */\n/* \"include\\Inagaki\\GameSoundTable.h\" line 5 \"JSystem/JAudio/JAUSoundInfo.h\" */\n#ifndef JAUDIO_JAUSOUNDINFO_H\n#define JAUDIO_JAUSOUNDINFO_H\n\n/* \"include\\JSystem\\JAudio\\JAUSoundInfo.h\" line 3 \"JSystem/JAudio/Interface/JAISound.h\" */\n/* end \"JSystem/JAudio/Interface/JAISound.h\" */\n/* \"include\\JSystem\\JAudio\\JAUSoundInfo.h\" line 4 \"JSystem/JAudio/System/JASGadget.h\" */\n/* end \"JSystem/JAudio/System/JASGadget.h\" */\n\nclass JAUSoundInfo : public JASGlobalInstance<JAUSoundInfo>\n{\npublic:\n    JAUSoundInfo(bool param_0) : JASGlobalInstance<JAUSoundInfo>(param_0) {}\n    virtual void getAudibleSw(JAISoundID) const = 0;\n    virtual u16 getBgmSeqResourceID(JAISoundID) const = 0;\n};\n\n#endif /* JAUDIO_JAUSOUNDINFO_H *//* end \"JSystem/JAudio/JAUSoundInfo.h\" */\n\nnamespace GameAudio\n{\n    class CustomSoundTable : public JAISoundInfo, public JAUSoundInfo, public JAIStreamDataMgr, public JASGlobalInstance<CustomSoundTable>\n    {\n    public:\n        virtual u32 getSoundType(JAISoundID) const;\n        virtual int getCategory(JAISoundID) const;\n        virtual u32 getPriority(JAISoundID) const;\n        virtual void getSeInfo(JAISoundID, JAISe *) const;\n        virtual void getSeqInfo(JAISoundID, JAISeq *) const ;\n        virtual void getStreamInfo(JAISoundID, JAIStream *) const;\n\n        virtual ~CustomSoundTable();\n        virtual void getAudibleSw(JAISoundID) const;\n        virtual u16 getBgmSeqResourceID(JAISoundID) const;\n        \n        virtual u8 getPTrack(JAISoundID) const;\n        virtual u32 getSwBit(JAISoundID&) const;\n        virtual u8 getLevelFlag(JAISoundID) const;\n        virtual s32 getStreamFileEntry(JAISoundID);\n    };\n}\n\n#endif/* end \"Inagaki/GameSoundTable.h\" */\n/* \"include\\Inagaki\\GameAudioMain.h\" line 8 \"types.h\" */\n/* end \"types.h\" */\n\nnamespace GameAudio\n{\n    class CustomMgr;\n    class CameraMgr;\n\n    class Main\n    {\n    public:\n        enum WS_ID // Data from GCKart.daa, might not be correct\n        {\n            STREAM0, // NINTENDO_LOGO_MARIO_WS_START?\n            STREAM1, // SE_WS_START?\n            STREAM2, // not used\n            STREAM3  // TANAKA_BGM_WS_START?\n        };\n\n        enum PAUSE_STATUS\n        {\n            // TODO\n        };\n\n        void init(JKRSolidHeap *, u32, void *, void *, u32);\n        void startSystemSe(u32 id);\n        void startRaceSystemSe(u32 id);\n        void initRaceSound();\n        void bootDSP();\n        void setBgmVolume(f32);\n        bool isActive();\n        bool isWaveLoaded(WS_ID);\n        void frameWork();\n        void setMasterVolume(s8);\n        void setOutputMode(u32);\n        void resetAudio(u32);\n        void resumeAudio();\n        f32 getMasterVolumeValue();\n        f32 getTHPOptionVolume() { return getMasterVolumeValue() / 2; };\n\n        JAUSectionHeap *getSectionHeap() { return mSectionHeap; }\n        CustomSoundTable *getSoundTable() { return mTable; }\n\n        static Main *getAudio() { return msBasic; };\n\n        static Main *msBasic;\n\n    private:\n        CustomMgr *mMgr;              // 00\n        u8 _04[0xC - 0x4];            //\n        CustomSoundTable *mTable;     // 0C\n        u8 _10[4];                    //\n        JAUSectionHeap *mSectionHeap; // 14\n        u8 _18[0x44 - 0x18];          //\n        FxLineConfig *mConfig;        // 44\n        u8 _48[4];                    //\n        PAUSE_STATUS mPauseStatus;    // 4C\n        u8 _50[0x64 - 0x50];          //\n        CameraMgr *mCamera;           // 64\n        u8 _68[0xa8 - 0x68];          //\n\n    }; // Size: 0xa8\n\n    namespace Parameters\n    {\n        extern u8 getDemoMode();\n        extern void setDemoMode(u8);\n    }\n}\n\n#define GetGameAudioMain() GameAudio::Main::getAudio()\n#define GameAudioMain GameAudio::Main\n#define GameAudioParameters GameAudio::Parameters\n\n#endif\n\nnamespace GameAudio\n{\n    class Common\n    {\n    public:\n        static f32 panDeform(f32, f32);\n        static f32 setMultiPlayModePan(u8); // this is a getter, not a setter\n        static u32 changeRandomId(u32, u32);\n    };\n\n    class Random\n    {\n    public:\n        static void setSeed(u32 seed);\n        static u32 getRandomU32();\n        static u32 getSignalEngineRandomU32();\n\n    private:\n        static JMath::TRandom_<JMath::TRandom_fast_> sRandom;\n        static JMath::TRandom_<JMath::TRandom_fast_> sSignalEngineRandom;\n    };\n}", "diff_flags": [], "diff_label": "GameAudioCommon", "libraries": []}