{"compiler": "mwcc_233_144", "compiler_flags": "-lang=c++ -nodefaults -Cpp_exceptions off -RTTI off -fp hard -O4,p -use_lmw_stmw on", "source_code": "\n#define EPSILON 0.00000001f\n\n\nvoid DTPlayer::normalize(Vec* src, Vec* dst) {\n    //according to dwarf info there should only be one float here named \"a\"\n    float a = 1.0f / sqrtf(src->magnitude());\n    dst->x = src->x * a;\n    dst->y = src->y * a;\n    dst->z = src->z * a;\n}\n", "context": "// r2 is  8051E360\n// r13 is 8051C680\n\ntypedef int BOOL;\n\ntypedef signed char s8;\ntypedef signed short s16;\ntypedef signed long s32;\ntypedef signed long long s64;\ntypedef unsigned char u8;\ntypedef unsigned short u16;\ntypedef unsigned int uint;\ntypedef unsigned long u32;\ntypedef unsigned long size_t;\ntypedef unsigned long long u64;\n\ntypedef volatile u8 vu8;\ntypedef volatile u16 vu16;\ntypedef volatile u32 vu32;\ntypedef volatile u64 vu64;\ntypedef volatile s8 vs8;\ntypedef volatile s16 vs16;\ntypedef volatile s32 vs32;\ntypedef volatile s64 vs64;\n\ntypedef float f32;\ntypedef double f64;\ntypedef volatile f32 vf32;\ntypedef volatile f64 vf64;\n\ntypedef u32 unknown;\n\n// Basic defines to allow newer-like C++ code to be written\n#define TRUE  1\n#define FALSE 0\n#define NULL  0\n#define nullptr 0\n\nstatic inline f32 sqrtf(f32 x)\n{\n\tstatic const double _half  = .5;\n\tstatic const double _three = 3.0;\n\tvolatile float y;\n\tif (x > 0.0f) {\n\n\t\tdouble guess = __frsqrte((double)x);                         // returns an approximation to\n\t\tguess        = _half * guess * (_three - guess * guess * x); // now have 12 sig bits\n\t\tguess        = _half * guess * (_three - guess * guess * x); // now have 24 sig bits\n\t\tguess        = _half * guess * (_three - guess * guess * x); // now have 32 sig bits\n        guess        = _half * guess * (_three - guess * guess * x); // now have 48 sig bits\n\t\ty            = (float)(x * guess);\n\t\treturn y;\n\t}\n\treturn x;\n}\n\nextern \"C\"{\n\ntypedef struct PADStatus{\n    u16 button; //0x0\n    s8 stickX; //0x2\n    s8 stickY; //0x3\n    s8 substickX; //0x4\n    s8 substickY; //0x5\n    u8 triggerLeft; //0x6\n    u8 triggerRight; //0x7\n    u8 analogA; //0x8\n    u8 analogB; //0x9\n    s8 err; //0xA\n    u8 unkB[5]; //padding?\n} PADStatus;\n\n\ntypedef struct GXTexObj GXTexObj;\ntypedef struct GXRenderModeObj GXRenderModeObj;\ntypedef struct GXFifoObj GXFifoObj;\n\n/**\n * Pack value into bitfield.\n * Value is shifted to the specified bit position.\n */\n#define GX_BITSET(field, pos, size, value)                                     \\\n\t__rlwimi((field), (value), 31 - (pos) - (size) + 1, (pos), (pos) + (size)-1)\n\n/**\n * Pack value into bitfield.\n * Value is not shifted, only masked.\n */\n#define GX_BITSET_TRUNC(field, mb, size, value)                                \\\n\t__rlwimi((field), (value), 0, (mb), (mb) + (size)-1)\n\n/**\n * Common types used throughout many GX files.\n * To avoid circular depencies, common structures and all enums have been moved\n * here. Everything is organized in alphabetical order.\n */\n\n//! TODO: Many GX functions use 8-bit booleans.\n//! As those files are decompiled, update prototypes that use u8 -> GXBool8,\n//! so it is evident to callers that the 8-bit value is meant to be TRUE/FALSE\ntypedef unsigned char GXBool;\n\n/**\n * Common structs\n */\n\ntypedef struct _GXColor {\n\tu8 r, g, b, a;\n} GXColor;\n\ntypedef struct _GXColorS10 {\n\ts16 r, g, b, a;\n} GXColorS10;\n\n/**\n * Common enums\n */\n\ntypedef enum _GXAlphaOp {\n\tGX_AOP_AND,\n\tGX_AOP_OR,\n\tGX_AOP_XOR,\n\tGX_AOP_XNOR,\n\n\tGX_MAX_ALPHAOP\n} GXAlphaOp;\n\ntypedef enum _GXAlphaReadMode{\n\tGX_READ_00,\n\tGX_READ_FF,\n\tGX_READ_NONE\n} GXAlphaReadMode;\n\ntypedef enum _GXAnisotropy {\n\tGX_ANISO_1,\n\tGX_ANISO_2,\n\tGX_ANISO_4,\n\n\tGX_MAX_ANISOTROPY\n} GXAnisotropy;\n\ntypedef enum _GXAttnFn {\n\tGX_AF_SPEC,\n\tGX_AF_SPOT,\n\tGX_AF_NONE,\n} GXAttnFn;\n\ntypedef enum _GXAttr {\n\tGX_VA_PNMTXIDX,\n\tGX_VA_TEX0MTXIDX,\n\tGX_VA_TEX1MTXIDX,\n\tGX_VA_TEX2MTXIDX,\n\tGX_VA_TEX3MTXIDX,\n\tGX_VA_TEX4MTXIDX,\n\tGX_VA_TEX5MTXIDX,\n\tGX_VA_TEX6MTXIDX,\n\tGX_VA_TEX7MTXIDX,\n\tGX_VA_POS,\n\tGX_VA_NRM,\n\tGX_VA_CLR0,\n\tGX_VA_CLR1,\n\tGX_VA_TEX0,\n\tGX_VA_TEX1,\n\tGX_VA_TEX2,\n\tGX_VA_TEX3,\n\tGX_VA_TEX4,\n\tGX_VA_TEX5,\n\tGX_VA_TEX6,\n\tGX_VA_TEX7,\n\tGX_POS_MTX_ARRAY,\n\tGX_NRM_MTX_ARRAY,\n\tGX_TEX_MTX_ARRAY,\n\tGX_LIGHT_ARRAY,\n\tGX_VA_NBT,\n\n\tGX_VA_MAX_ATTR,\n\tGX_VA_NULL = 255\n} GXAttr;\n\ntypedef enum _GXAttrType{\n\tGX_NONE,\n\tGX_DIRECT,\n\tGX_INDEX8,\n\tGX_INDEX16\n} GXAttrType;\n\ntypedef enum _GXBlendFactor {\n\tGX_BL_ZERO,\n\tGX_BL_ONE,\n\tGX_BL_SRCCLR,\n\tGX_BL_INVSRCCLR,\n\tGX_BL_SRCALPHA,\n\tGX_BL_INVSRCALPHA,\n\tGX_BL_DSTALPHA,\n\tGX_BL_INVDSTALPHA,\n\n\tGX_BL_DSTCLR = GX_BL_SRCCLR,\n\tGX_BL_INVDSTCLR = GX_BL_INVSRCCLR\n} GXBlendFactor;\n\ntypedef enum _GXBlendMode {\n\tGX_BM_NONE,\n\tGX_BM_BLEND,\n\tGX_BM_LOGIC,\n\tGX_BM_SUBTRACT,\n\n\tGX_MAX_BLENDMODE\n} GXBlendMode;\n\ntypedef enum _GXChannelID {\n\tGX_COLOR0,\n\tGX_COLOR1,\n\tGX_ALPHA0,\n\tGX_ALPHA1,\n\tGX_COLOR0A0,\n\tGX_COLOR1A1,\n\tGX_COLOR_ZERO,\n\tGX_ALPHA_BUMP,\n\tGX_ALPHA_BUMPN,\n\n\tGX_COLOR_NULL = 255\n} GXChannelID;\n\ntypedef enum _GXCITexFmt{\n\tGX_TF_C4 = 8,\n\tGX_TF_C8,\n\tGX_TF_C14X2\n} GXCITexFmt;\n\ntypedef enum _GXClipMode {\n\t// \"ClipDisable\" in XF mem, so 0 = enable\n\tGX_CLIP_ENABLE,\n\tGX_CLIP_DISABLE,\n} GXClipMode;\n\ntypedef enum _GXColorSrc {\n\tGX_SRC_REG,\n\tGX_SRC_VTX\n} GXColorSrc;\n\ntypedef enum _GXCompare {\n\tGX_NEVER,\n\tGX_LESS,\n\tGX_EQUAL,\n\tGX_LEQUAL,\n\tGX_GREATER,\n\tGX_NEQUAL,\n\tGX_GEQUAL,\n\tGX_ALWAYS\n} GXCompare;\n\ntypedef enum _GXCompCnt{\n\tGX_POS_XY = 0,\n\tGX_POS_XYZ,\n\n\tGX_NRM_XYZ = 0,\n\tGX_NRM_NBT,\n\tGX_NRM_NBT3,\n\n\tGX_CLR_RGB = 0,\n\tGX_CLR_RGBA,\n\n\tGX_TEX_S = 0,\n\tGX_TEX_ST\n} GXCompCnt;\n\ntypedef enum _GXCompType{\n\tGX_U8 = 0,\n\tGX_S8,\n\tGX_U16,\n\tGX_S16,\n\tGX_F32,\n\n\tGX_RGB565 = 0,\n\tGX_RGB8,\n\tGX_RGBX8,\n\tGX_RGBA4,\n\tGX_RGBA6,\n\tGX_RGBA8\n} GXCompType;\n\ntypedef enum _GXCopyMode{\n\tGX_COPY_PROGRESSIVE = 0,\n\tGX_COPY_INTLC_EVEN = 2,\n\tGX_COPY_INTLC_ODD = 3\n} GXCopyMode;\n\ntypedef enum _GXCullMode {\n\tGX_CULL_NONE,\n\tGX_CULL_FRONT,\n\tGX_CULL_BACK,\n\tGX_CULL_ALL\n} GXCullMode;\n\ntypedef enum _GXDiffuseFn {\n\tGX_DF_NONE,\n\tGX_DF_SIGN,\n\tGX_DF_CLAMP\n} GXDiffuseFn;\n\ntypedef enum _GXDistAttnFn {\n\tGX_DA_OFF,\n\tGX_DA_GENTLE,\n\tGX_DA_MEDIUM,\n\tGX_DA_STEEP\n} GXDistAttnFn;\n\ntypedef enum _GXFBClamp{\n\tGX_CLAMP_NONE,\n\tGX_CLAMP_TOP,\n\tGX_CLAMP_BOTTOM\n} GXFBClamp;\n\ntypedef enum _GXFogType{\n\tGX_FOG_NONE,\n\n\tGX_FOG_LIN = 2,\n\tGX_FOG_EXP = 4,\n\tGX_FOG_EXP2 = 5,\n\tGX_FOG_REVEXP = 6,\n\tGX_FOG_REVEXP2 = 7,\n} GXFogType;\n\ntypedef enum _GXGamma{\n\tGX_GM_1_0,\n\tGX_GM_1_7,\n\tGX_GM_2_2\n} GXGamma;\n\ntypedef enum _GXIndTexAlphaSel {\n\tGX_ITBA_OFF,\n\tGX_ITBA_S,\n\tGX_ITBA_T,\n\tGX_ITBA_U,\n\n\tGX_MAX_ITBALPHA\n} GXIndTexAlphaSel;\n\ntypedef enum _GXIndTexBiasSel {\n\tGX_ITB_NONE,\n\tGX_ITB_S,\n\tGX_ITB_T,\n\tGX_ITB_ST,\n\tGX_ITB_U,\n\tGX_ITB_SU,\n\tGX_ITB_TU,\n\tGX_ITB_STU,\n\n\tGX_MAX_ITBIAS\n} GXIndTexBiasSel;\n\ntypedef enum _GXIndTexFormat {\n\tGX_ITF_8,\n\tGX_ITF_5,\n\tGX_ITF_4,\n\tGX_ITF_3,\n\n\tGX_MAX_ITFORMAT\n} GXIndTexFormat;\n\ntypedef enum _GXIndTexMtxID {\n\tGX_ITM_OFF,\n\tGX_ITM_0,\n\tGX_ITM_1,\n\tGX_ITM_2,\n\n\tGX_ITM_S0 = 5,\n\tGX_ITM_S1,\n\tGX_ITM_S2,\n\n\tGX_ITM_T0 = 9,\n\tGX_ITM_T1,\n\tGX_ITM_T2,\n} GXIndTexMtxID;\n\ntypedef enum _GXIndTexScale {\n\tGX_ITS_1,\n\tGX_ITS_2,\n\tGX_ITS_4,\n\tGX_ITS_8,\n\tGX_ITS_16,\n\tGX_ITS_32,\n\tGX_ITS_64,\n\tGX_ITS_128,\n\tGX_ITS_256,\n\n\tGX_MAX_ITSCALE\n} GXIndTexScale;\n\ntypedef enum _GXIndTexStageID {\n\tGX_INDTEXSTAGE0,\n\tGX_INDTEXSTAGE1,\n\tGX_INDTEXSTAGE2,\n\tGX_INDTEXSTAGE3,\n\n\tGX_MAX_INDTEXSTAGE\n} GXIndTexStageID;\n\ntypedef enum _GXIndTexWrap {\n\tGX_ITW_OFF,\n\tGX_ITW_256,\n\tGX_ITW_128,\n\tGX_ITW_64,\n\tGX_ITW_32,\n\tGX_ITW_16,\n\tGX_ITW_0,\n\n\tGX_MAX_ITWRAP,\n} GXIndTexWrap;\n\ntypedef enum _GXLightID {\n\tGX_LIGHT0 = 1,\n\tGX_LIGHT1 = 2,\n\tGX_LIGHT2 = 4,\n\tGX_LIGHT3 = 8,\n\tGX_LIGHT4 = 16,\n\tGX_LIGHT5 = 32,\n\tGX_LIGHT6 = 64,\n\tGX_LIGHT7 = 128,\n\n\tGX_MAX_LIGHT = 256,\n\tGX_LIGHT_NULL = 0\n} GXLightID;\n\n\ntypedef enum _GXLogicOp {\n\tGX_LO_CLEAR,\n\tGX_LO_AND,\n\tGX_LO_REVAND,\n\tGX_LO_COPY,\n\tGX_LO_INVAND,\n\tGX_LO_NOOP,\n\tGX_LO_XOR,\n\tGX_LO_OR,\n\tGX_LO_NOR,\n\tGX_LO_EQUIV,\n\tGX_LO_INV,\n\tGX_LO_REVOR,\n\tGX_LO_INVCOPY,\n\tGX_LO_INVOR,\n\tGX_LO_NAND,\n\tGX_LO_SET\n} GXLogicOp;\n\ntypedef enum _GXMiscToken{\n\tGX_MT_XF_FLUSH = 1,\n\tGX_MT_DL_SAVE_CONTEXT = 2,\n\t\n\tGX_MT_NULL = 0\n} GXMiscToken;\n\ntypedef enum _GXPerf0{\n\tGX_PERF0_VERTICES,\n\tGX_PERF0_CLIP_VTX,\n\tGX_PERF0_CLIP_CLKS,\n\tGX_PERF0_XF_WAIT_IN,\n\tGX_PERF0_XF_WAIT_OUT,\n\tGX_PERF0_XF_XFRM_CLKS,\n\tGX_PERF0_XF_LIT_CLKS,\n\tGX_PERF0_XF_BOT_CLKS,\n\tGX_PERF0_XF_REGLD_CLKS,\n\tGX_PERF0_XF_REGRD_CLKS,\n\tGX_PERF0_CLIP_RATIO,\n\tGX_PERF0_TRIANGLES,\n\tGX_PERF0_TRIANGLES_CULLED,\n\tGX_PERF0_TRIANGLES_PASSED,\n\tGX_PERF0_TRIANGLES_SCISSORED,\n\tGX_PERF0_TRIANGLES_0TEX,\n\tGX_PERF0_TRIANGLES_1TEX,\n\tGX_PERF0_TRIANGLES_2TEX,\n\tGX_PERF0_TRIANGLES_3TEX,\n\tGX_PERF0_TRIANGLES_4TEX,\n\tGX_PERF0_TRIANGLES_5TEX,\n\tGX_PERF0_TRIANGLES_6TEX,\n\tGX_PERF0_TRIANGLES_7TEX,\n\tGX_PERF0_TRIANGLES_8TEX,\n\tGX_PERF0_TRIANGLES_0CLR,\n\tGX_PERF0_TRIANGLES_1CLR,\n\tGX_PERF0_TRIANGLES_2CLR,\n\tGX_PERF0_QUAD_0CVG,\n\tGX_PERF0_QUAD_NON0CVG,\n\tGX_PERF0_QUAD_1CVG,\n\tGX_PERF0_QUAD_2CVG,\n\tGX_PERF0_QUAD_3CVG,\n\tGX_PERF0_QUAD_4CVG,\n\tGX_PERF0_AVG_QUAD_CNT,\n\tGX_PERF0_CLOCKS,\n\tGX_PERF0_NONE\n} GXPerf0;\n\ntypedef enum _GXPerf1{\n\tGX_PERF1_TEXELS,\n\tGX_PERF1_TX_IDLE,\n\tGX_PERF1_TX_REGS,\n\tGX_PERF1_TX_MEMSTALL,\n\tGX_PERF1_TC_CHECK1_2,\n\tGX_PERF1_TC_CHECK3_4,\n\tGX_PERF1_TC_CHECK5_6,\n\tGX_PERF1_TC_CHECK7_8,\n\tGX_PERF1_TC_MISS,\n\tGX_PERF1_VC_ELEMQ_FULL,\n\tGX_PERF1_VC_MISSQ_FULL,\n\tGX_PERF1_VC_MEMREQ_FULL,\n\tGX_PERF1_VC_STATUS7,\n\tGX_PERF1_VC_MISSREP_FULL,\n\tGX_PERF1_VC_STREAMBUF_LOW,\n\tGX_PERF1_VC_ALL_STALLS,\n\tGX_PERF1_VERTICES,\n\tGX_PERF1_FIFO_REQ,\n\tGX_PERF1_CALL_REQ,\n\tGX_PERF1_VC_MISS_REQ,\n\tGX_PERF1_CP_ALL_REQ,\n\tGX_PERF1_CLOCKS,\n\tGX_PERF1_NONE\n} GXPerf1;\n\ntypedef enum _GXPixelFmt{\n\tGX_PF_RGB8_Z24,\n\tGX_PF_RGBA6_Z24,\n\tGX_PF_RGB565_Z16,\n\tGX_PF_Z24,\n\tGX_PF_Y8,\n\tGX_PF_U8,\n\tGX_PF_V8,\n\tGX_PF_YUV420\n} GXPixelFmt;\n\ntypedef enum _GXPrimitive {\n\tGX_POINTS = 0xB8,\n\tGX_LINES = 0xA8,\n\tGX_LINESTRIP = 0xB0,\n\tGX_TRIANGLES = 0x90,\n\tGX_TRIANGLESTRIP = 0x98,\n\tGX_TRIANGLEFAN = 0xA0,\n\tGX_QUADS = 0x80,\n} GXPrimitive;\n\ntypedef enum _GXProjectionType {\n\tGX_PERSPECTIVE,\n\tGX_ORTHOGRAPHIC\n} GXProjectionType;\n\n\ntypedef enum _GXSpotFn {\n\tGX_SP_OFF,\n\tGX_SP_FLAT,\n\tGX_SP_COS,\n\tGX_SP_COS2,\n\tGX_SP_SHARP,\n\tGX_SP_RING1,\n\tGX_SP_RING2\n} GXSpotFn;\n\ntypedef enum _GXTevAlphaArg {\n\tGX_CA_APREV,\n\tGX_CA_A0,\n\tGX_CA_A1,\n\tGX_CA_A2,\n\tGX_CA_TEXA,\n\tGX_CA_RASA,\n\tGX_CA_KONST,\n\tGX_CA_ZERO,\n\tGX_CA_ONE\n} GXTevAlphaArg;\n\n\ntypedef enum _GXTevBias {\n\tGX_TB_ZERO,\n\tGX_TB_ADDHALF,\n\tGX_TB_SUBHALF,\n\n\tGX_MAX_TEVBIAS\n} GXTevBias;\n\ntypedef enum _GXTevColorArg {\n\tGX_CC_CPREV,\n\tGX_CC_APREV,\n\tGX_CC_C0,\n\tGX_CC_A0,\n\tGX_CC_C1,\n\tGX_CC_A1,\n\tGX_CC_C2,\n\tGX_CC_A2,\n\tGX_CC_TEXC,\n\tGX_CC_TEXA,\n\tGX_CC_RASC,\n\tGX_CC_RASA,\n\tGX_CC_ONE,\n\tGX_CC_HALF,\n\tGX_CC_KONST,\n\tGX_CC_ZERO,\n\tGX_CC_TEXRRR,\n\tGX_CC_TEXGGG,\n\tGX_CC_TEXBBB,\n\n\tGX_CC_QUARTER = GX_CC_KONST\n} GXTevColorArg;\n\ntypedef enum _GXTevColorChan {\n\tGX_CH_RED,\n\tGX_CH_GREEN,\n\tGX_CH_BLUE,\n\tGX_CH_ALPHA\n} GXTevColorChan;\n\ntypedef enum _GXTevKAlphaSel {\n\tGX_TEV_KASEL_1,\n\tGX_TEV_KASEL_7_8,\n\tGX_TEV_KASEL_3_4,\n\tGX_TEV_KASEL_5_8,\n\tGX_TEV_KASEL_1_2,\n\tGX_TEV_KASEL_3_8,\n\tGX_TEV_KASEL_1_4,\n\tGX_TEV_KASEL_1_8,\n\n\tGX_TEV_KASEL_K0_R = 16,\n\tGX_TEV_KASEL_K1_R,\n\tGX_TEV_KASEL_K2_R,\n\tGX_TEV_KASEL_K3_R,\n\tGX_TEV_KASEL_K0_G,\n\tGX_TEV_KASEL_K1_G,\n\tGX_TEV_KASEL_K2_G,\n\tGX_TEV_KASEL_K3_G,\n\tGX_TEV_KASEL_K0_B,\n\tGX_TEV_KASEL_K1_B,\n\tGX_TEV_KASEL_K2_B,\n\tGX_TEV_KASEL_K3_B,\n\tGX_TEV_KASEL_K0_A,\n\tGX_TEV_KASEL_K1_A,\n\tGX_TEV_KASEL_K2_A,\n\tGX_TEV_KASEL_K3_A\n} GXTevKAlphaSel;\n\ntypedef enum _GXTevKColorID {\n\tGX_KCOLOR0,\n\tGX_KCOLOR1,\n\tGX_KCOLOR2,\n\tGX_KCOLOR3,\n\n\tGX_MAX_KCOLOR\n} GXTevKColorID;\n\ntypedef enum _GXTevKColorSel {\n\tGX_TEV_KCSEL_1,\n\tGX_TEV_KCSEL_7_8,\n\tGX_TEV_KCSEL_3_4,\n\tGX_TEV_KCSEL_5_8,\n\tGX_TEV_KCSEL_1_2,\n\tGX_TEV_KCSEL_3_8,\n\tGX_TEV_KCSEL_1_4,\n\tGX_TEV_KCSEL_1_8,\n\n\tGX_TEV_KCSEL_K0 = 12,\n\tGX_TEV_KCSEL_K1,\n\tGX_TEV_KCSEL_K2,\n\tGX_TEV_KCSEL_K3,\n\tGX_TEV_KCSEL_K0_R,\n\tGX_TEV_KCSEL_K1_R,\n\tGX_TEV_KCSEL_K2_R,\n\tGX_TEV_KCSEL_K3_R,\n\tGX_TEV_KCSEL_K0_G,\n\tGX_TEV_KCSEL_K1_G,\n\tGX_TEV_KCSEL_K2_G,\n\tGX_TEV_KCSEL_K3_G,\n\tGX_TEV_KCSEL_K0_B,\n\tGX_TEV_KCSEL_K1_B,\n\tGX_TEV_KCSEL_K2_B,\n\tGX_TEV_KCSEL_K3_B,\n\tGX_TEV_KCSEL_K0_A,\n\tGX_TEV_KCSEL_K1_A,\n\tGX_TEV_KCSEL_K2_A,\n\tGX_TEV_KCSEL_K3_A\n} GXTevKColorSel;\n\ntypedef enum _GXTevMode{\n\tGX_MODULATE,\n\tGX_DECAL,\n\tGX_BLEND,\n\tGX_REPLACE,\n\tGX_PASSCLR\n} GXTevMode;\n\ntypedef enum _GXTevOp {\n\tGX_TEV_ADD,\n\tGX_TEV_SUB,\n\n\tGX_TEV_COMP_R8_GT = 8,\n\tGX_TEV_COMP_R8_EQ,\n\tGX_TEV_COMP_GR16_GT,\n\tGX_TEV_COMP_GR16_EQ,\n\tGX_TEV_COMP_BGR24_GT,\n\tGX_TEV_COMP_BGR24_EQ,\n\tGX_TEV_COMP_RGB8_GT,\n\tGX_TEV_COMP_RGB8_EQ,\n\n\tGX_TEV_COMP_A8_GT = GX_TEV_COMP_RGB8_GT,\n\tGX_TEV_COMP_A8_EQ = GX_TEV_COMP_RGB8_EQ\n} GXTevOp;\n\ntypedef enum _GXTevRegID {\n\tGX_TEVPREV,\n\tGX_TEVREG0,\n\tGX_TEVREG1,\n\tGX_TEVREG2,\n\n\tGX_MAX_TEVREG\n} GXTevRegID;\n\ntypedef enum _GXTevScale {\n\tGX_CS_SCALE_1,\n\tGX_CS_SCALE_2,\n\tGX_CS_SCALE_4,\n\tGX_CS_DIVIDE_2,\n\n\tGX_MAX_TEVSCALE\n} GXTevScale;\n\ntypedef enum _GXTevStageID {\n\tGX_TEVSTAGE0,\n\tGX_TEVSTAGE1,\n\tGX_TEVSTAGE2,\n\tGX_TEVSTAGE3,\n\tGX_TEVSTAGE4,\n\tGX_TEVSTAGE5,\n\tGX_TEVSTAGE6,\n\tGX_TEVSTAGE7,\n\tGX_TEVSTAGE8,\n\tGX_TEVSTAGE9,\n\tGX_TEVSTAGE10,\n\tGX_TEVSTAGE11,\n\tGX_TEVSTAGE12,\n\tGX_TEVSTAGE13,\n\tGX_TEVSTAGE14,\n\tGX_TEVSTAGE15,\n\n\tGX_MAX_TEVSTAGE\n} GXTevStageID;\n\n\ntypedef enum _GXTevSwapSel {\n\tGX_TEV_SWAP0,\n\tGX_TEV_SWAP1,\n\tGX_TEV_SWAP2,\n\tGX_TEV_SWAP3,\n\n\tGX_MAX_TEVSWAP\n} GXTevSwapSel;\n\ntypedef enum _GXTexCacheSize{\n\tGX_TEXCACHE_32K,\n\tGX_TEXCACHE_128K,\n\tGX_TEXCACHE_512K,\n\tGX_TEXCACHE_NONE\n} GXTexCacheSize;\n\ntypedef enum _GXTexCoordID {\n\tGX_TEXCOORD0,\n\tGX_TEXCOORD1,\n\tGX_TEXCOORD2,\n\tGX_TEXCOORD3,\n\tGX_TEXCOORD4,\n\tGX_TEXCOORD5,\n\tGX_TEXCOORD6,\n\tGX_TEXCOORD7,\n\n\tGX_MAX_TEXCOORD,\n\tGX_TEXCOORD_NULL = 255\n} GXTexCoordID;\n\ntypedef enum _GXTexFilter {\n\tGX_NEAR,\n\tGX_LINEAR,\n\tGX_NEAR_MIP_NEAR,\n\tGX_LIN_MIP_NEAR,\n\tGX_NEAR_MIP_LIN,\n\tGX_LIN_MIP_LIN,\n} GXTexFilter;\n\ntypedef enum _GXTexFmt {\n\tGX_TF_I4,\n\tGX_TF_I8,\n\tGX_TF_IA4,\n\tGX_TF_IA8,\n\tGX_TF_RGB565,\n\tGX_TF_RGB5A3,\n\tGX_TF_RGBA8,\n\tGX_TF_CMPR = 14,\n\n\tGX_CTF_R4 = 32,\n\tGX_CTF_RA4 = 34,\n\tGX_CTF_RA8 = 35,\n\tGX_CTF_YUVA8 = 38,\n\tGX_CTF_A8 = 39,\n\tGX_CTF_R8 = 40,\n\tGX_CTF_G8 = 41,\n\tGX_CTF_B8 = 42,\n\tGX_CTF_RG8 = 43,\n\tGX_CTF_GB8 = 44,\n\n\tGX_TF_Z8 = 17,\n\tGX_TF_Z16 = 19,\n\tGX_TF_Z24X8 = 22,\n\n\tGX_CTF_Z4 = 48,\n\tGX_CTF_Z8M = 57,\n\tGX_CTF_Z8L = 58,\n\tGX_CTF_Z16L = 60,\n\n\tGX_TF_A8 = GX_CTF_A8\n} GXTexFmt;\n\ntypedef enum _GXTexGenSrc {\n\tGX_TG_POS,\n\tGX_TG_NRM,\n\tGX_TG_BINRM,\n\tGX_TG_TANGENT,\n\tGX_TG_TEX0,\n\tGX_TG_TEX1,\n\tGX_TG_TEX2,\n\tGX_TG_TEX3,\n\tGX_TG_TEX4,\n\tGX_TG_TEX5,\n\tGX_TG_TEX6,\n\tGX_TG_TEX7,\n\tGX_TG_TEXCOORD0,\n\tGX_TG_TEXCOORD1,\n\tGX_TG_TEXCOORD2,\n\tGX_TG_TEXCOORD3,\n\tGX_TG_TEXCOORD4,\n\tGX_TG_TEXCOORD5,\n\tGX_TG_TEXCOORD6,\n\tGX_TG_COLOR0,\n\tGX_TG_COLOR1,\n} GXTexGenSrc;\n\n\ntypedef enum _GXTexGenType {\n\tGX_TG_MTX3x4,\n\tGX_TG_MTX2x4,\n\tGX_TG_BUMP0,\n\tGX_TG_BUMP1,\n\tGX_TG_BUMP2,\n\tGX_TG_BUMP3,\n\tGX_TG_BUMP4,\n\tGX_TG_BUMP5,\n\tGX_TG_BUMP6,\n\tGX_TG_BUMP7,\n\tGX_TG_SRTG\n} GXTexGenType;\n\ntypedef enum _GXTexMapID {\n\tGX_TEXMAP0,\n\tGX_TEXMAP1,\n\tGX_TEXMAP2,\n\tGX_TEXMAP3,\n\tGX_TEXMAP4,\n\tGX_TEXMAP5,\n\tGX_TEXMAP6,\n\tGX_TEXMAP7,\n\tGX_MAX_TEXMAP,\n\n\tGX_TEXMAP_NULL = 255,\n\tGX_TEX_DISABLE\n} GXTexMapID;\n\ntypedef enum _GXTexMtx {\n\t// Any dimension (in standard XF matrix memory)\n\tGX_TEXMTX0 = 30,\n\tGX_TEXMTX1 = 33,\n\tGX_TEXMTX2 = 36,\n\tGX_TEXMTX3 = 39,\n\tGX_TEXMTX4 = 42,\n\tGX_TEXMTX5 = 45,\n\tGX_TEXMTX6 = 48,\n\tGX_TEXMTX7 = 51,\n\tGX_TEXMTX8 = 54,\n\tGX_TEXMTX9 = 57,\n\tGX_IDENTITY = 60\n} GXTexMtx;\n\ntypedef enum _GXTexMtxType{\n\tGX_MTX3x4,\n\tGX_MTX2x4,\n} GXTexMtxType;\n\ntypedef enum _GXTexWrapMode {\n\tGX_CLAMP,\n\tGX_REPEAT,\n\tGX_MIRROR,\n\n\tGX_MAX_TEXWRAPMODE\n} GXTexWrapMode;\n\ntypedef enum _GXTlutFmt {\n\tGX_TL_IA8,\n\tGX_TL_RGB565,\n\tGX_TL_RGB5A3,\n\n\tGX_MAX_TLUTFMT\n} GXTlutFmt;\n\ntypedef enum _GXTlutSize{\n\tGX_TLUT_16 = 1,\n\tGX_TLUT_32 = 2,\n\tGX_TLUT_64 = 4,\n\tGX_TLUT_128 = 8,\n\tGX_TLUT_256 = 16,\n\tGX_TLUT_512 = 32,\n\tGX_TLUT_1K = 64,\n\tGX_TLUT_2K = 128,\n\tGX_TLUT_4K = 256,\n\tGX_TLUT_8K = 512,\n\tGX_TLUT_16K = 1024,\n} GXTlutSize;\n\ntypedef enum _GXVCachePerf{\n\tGX_VC_POS,\n\tGX_VC_NRM,\n\tGX_VC_CLR0,\n\tGX_VC_CLR1,\n\tGX_VC_TEX0,\n\tGX_VC_TEX1,\n\tGX_VC_TEX2,\n\tGX_VC_TEX3,\n\tGX_VC_TEX4,\n\tGX_VC_TEX5,\n\tGX_VC_TEX6,\n\tGX_VC_TEX7,\n\tGX_VC_ALL = 15\n} GXVCachePerf;\n\ntypedef enum _GXVtxFmt{\n\tGX_VTXFMT0,\n\tGX_VTXFMT1,\n\tGX_VTXFMT2,\n\tGX_VTXFMT3,\n\tGX_VTXFMT4,\n\tGX_VTXFMT5,\n\tGX_VTXFMT6,\n\tGX_VTXFMT7,\n\tGX_MAX_VTXFMT\n} GXVtxFmt;\n\ntypedef enum _GXZFmt16{\n\tGX_ZC_LINEAR,\n\tGX_ZC_NEAR,\n\tGX_ZC_MID,\n\tGX_ZC_FAR\n} GXZFmt16;\n\ntypedef enum _GXZTexOp{\n\tGX_ZT_DISABLE,\n\tGX_ZT_ADD,\n\tGX_ZT_REPLACE,\n\n\tGX_MAX_ZTEXOP\n} GXZTexOp;\n\n\ntypedef enum VITVMode{\n    VI_TVMODE_NTSC_INT = 0,\n    VI_TVMODE_NTSC_DS,\n    VI_TVMODE_NTSC_PROG,\n    VI_TVMODE_PAL_INT = 4,\n    VI_TVMODE_PAL_DS,\n    VI_TVMODE_MPAL_INT = 8,\n    VI_TVMODE_MPAL_DS,\n    VI_TVMODE_DEBUG_INT = 12\n} VITVMode;\n\ntypedef enum VIXFBMode{\n    VI_XFBMODE_SF,\n    VI_XFBMODE_DF\n} VIXFBMode;\n\n\ntypedef void (*DVDAsyncCallback)(s32, struct DVDFileInfo*);\ntypedef void (*DVDCBAsyncCallback)(s32, struct DVDCommandBlock*);\n\ntypedef struct DVDDiskID {\n  char gameName[4];\n  char company[2];\n  u8 diskNumber;\n  u8 gameVersion;\n  u8 streaming;\n  u8 streamingBufSize;\n  u8 padding[22];\n} DVDDiskID;\n\ntypedef struct DVDCommandBlock {\n  DVDCommandBlock* next;\n  DVDCommandBlock* prev;\n  u32 command;\n  s32 state;\n  u32 offset;\n  u32 length;\n  void* addr;\n  u32 currTransferSize;\n  u32 transferredSize;\n  DVDDiskID* id;\n  DVDCBAsyncCallback callback;\n  void* userData;\n} DVDCommandBlock;\n\ntypedef struct DVDFileInfo{\n    DVDCommandBlock cb;\n    u32 startAddr;\n    u32 length;\n    DVDAsyncCallback callback;\n} DVDFileInfo;\n\n}\n\n\n\nstruct Vec {\n    f32 x;\n    f32 y;\n    f32 z;\n\n    inline float magnitude(){\n        return x*x + y*y + z*z + 0.00000001f;\n    }\n};\n\ntypedef Vec Point3d;\n\ntypedef float Mtx[3][4];\ntypedef float Mtx44[4][4];\n\n\n\nclass CSong{\npublic:\n\ts32 m_SongId;\n\tu32 m_SeqId;\n\tu8* m_buffer;\n\ts32 m_flag;\n\n\tCSong(const CSong&); //unused\n\tCSong();\n\n\ts32 InitBuffer(s32 size); //unused\n\tvoid DeleteBuffer();\n\ts32 ReadBuffer(s32 songId, char* filename);\n\ts32 PlaySong(u16 songGroupId);\n\tvoid DelayDeleteBuffer();\n\ts32 GetSongValid(); //unused\n};\n\nstruct _SND_REVHI_DELAYLINE{\n\ts32 inPoint; //0x0\n\ts32 outPoint; //0x4\n\ts32 length; //0x8\n\tfloat* inputs; //0xC\n\tfloat lastOutput; //0x10\n};\n\nstruct _SND_REVHI_WORK{\n\t_SND_REVHI_DELAYLINE AP[9]; //0x0\n\t_SND_REVHI_DELAYLINE C[9]; //0xB4\n\tfloat allPassCoeff; //0x168\n\tfloat combCoef[9]; //0x16C\n\tfloat lpLastout[3]; //0x190\n\tfloat level; //0x19C\n\tfloat damping; //0x1A0\n\tfloat preDelayTime; //0x1A4\n\tfloat crosstalk; //0x1A8\n\tfloat* preDelayLine[3]; //0x1AC\n\tfloat* preDelayPtr[3]; //0x1B8\n};\n\nstruct SND_AUX_REVERBHI{\n\t_SND_REVHI_WORK rv; //0x0\n\tu8 tempDisableFX; //0x1C4\n\tu8 unk1C5[3]; //filler?\n\tfloat coloration; //0x1C8\n\tfloat mix; //0x1CC\n\tfloat time; //0x1D0\n\tfloat damping; //0x1D4\n\tfloat preDelay; //0x1D8\n\tfloat crosstalk; //0x1DC\n};\n\nstruct _SND_CHORUS_SRCINFO{\n\ts32* dest; //0x0\n\ts32* smpBase; //0x4\n\ts32* old; //0x8\n\tu32 posLo; //0xC\n\tu32 posHi; //0x10\n\tu32 pitchLo; //0x14\n\tu32 pitchHi; //0x18\n\tu32 trigger; //0x1C\n\tu32 target; //0x20\n};\n\nstruct _SND_CHORUS_WORK{\n\ts32* lastLeft[3]; //0x0\n\ts32* lastRight[3]; //0xC\n\ts32* lastSur[3]; //0x18\n\tu8 currentLast; //0x24\n\tu8 unk25[3]; //filler?\n\ts32 oldLeft[4]; //0x28\n\ts32 oldRight[4]; //0x38\n\ts32 oldSur[4]; //0x48\n\tu32 currentPosLo; //0x58\n\tu32 currentPosHi; //0x5C\n\ts32 pitchOffset; //0x60\n\tu32 pitchOffsetPeriodCount; //0x64\n\tu32 pitchOffsetPeriod; //0x68\n\t_SND_CHORUS_SRCINFO src; //0x6C\n};\n\nstruct SND_AUX_CHORUS{\n\t_SND_CHORUS_WORK work; //0x0\n\tu32 baseDelay; //0x90\n\tu32 variation; //0x94\n\tu32 period; //0x98\n};\n\nclass DAudio{\nprivate:\n\tu32 m_aramMemArray[2]; //0x0\n\tu8* m_poolBuffer; //0x8\n\tu8* m_projBuffer; //0xC\n\tu8* m_sampBuffer; //0x10\n\tu8* m_sdirBuffer; //0x14\n\tCSong* m_curSong; //0x18\n\tu16 m_songGroupId; //0x1C\n\ts8 m_sequenceMute; //0x1E\n\ts8 m_seMute; //0x1F\n\ts8 m_muteAll; //0x20\n\tu8 unk21[3]; //padding\n\tSND_AUX_REVERBHI revH; //0x24\n\tSND_AUX_CHORUS cho; //0x204\n\npublic:\n\ts32 m_autoDemoFlag; //0x2A0\n\n\n\tDAudio(const DAudio&);\n\tDAudio();\n\t~DAudio();\n\n\ts32 Initialize();\n\ts32 ReadMusyXData(u8**, char*);\n\ts32 ReadPoolData(char*);\n\ts32 ReadProjData(char*);\n\ts32 ReadSdirData(char*);\n\ts32 ReadSampData(char*);\n\ts32 PushGroupData(u16);\n\tvoid FreeSampBuffer();\n\ts32 InitSongBuffer();\n\ts32 ReadDataAll(DVDFileInfo*, void*);\n\ts32 PlaySongFadeOut();\n\ts32 PlaySong(CSong*);\n\tvoid Coin();\n\tvoid DoorOpen();\n\tvoid DoorKnock();\n\tvoid Jump();\n\tvoid Fall();\n\tvoid SetSongGroupId(u16);\n\tvoid SetAutoDemo(s32);\n\tvoid MuteAll(s32);\n\ts32 SongStop();\n\tvoid Manager();\n\tvoid SetMuteSequence(s32);\n\tvoid SetMuteSe(s32);\n\ts32 GetMuteSequence();\n\ts32 GetMuteSe();\n\tvoid ResetFade();\n\tvoid Quit();\n\tvoid* ReadDataAlloc(char*);\n};\n\n\nenum DG_RENDMAN_TARGET_MODE{\n\tDGR_TARGET_POSITION,\n\tDGR_TARGET_VECTOR\n};\n\nenum RendManDrawMode{\n\tRMDM_ONCE,\n\tRMDM_MORE\n};\n\nenum DU_DVD_OPEN_MODE{\n\tDUD_OM_SEQUENTIAL_ALIGN,\n\tDUD_OM_RANDOM_ALIGN,\n\tDUD_OM_SEQUENTIAL_NOALIGN,\n\tDUD_OM_RANDOM_NOALIGN\n};\n\nclass DUDvd{\nprivate:\n\tDVDFileInfo* m_Info; //0x0\n\tu32 m_FileSize; //0x4\n\tu32 m_BufSize; //0x8\n\tu32 m_FilePointer; //0xC\n\tu8* m_Buf; //0x10\n\tDU_DVD_OPEN_MODE m_OpenMode; //0x14\n\n\t//typedef in dwarf, but likely originally a static var?\n\tstatic u8 m_InitDVD;\n\npublic:\n\tDUDvd(const DUDvd&);\n\tDUDvd(char* szFileName, DU_DVD_OPEN_MODE openmode);\n\tDUDvd();\n\t~DUDvd();\n\n\tvoid Close();\n\tu8* Open(char* szFileName, DU_DVD_OPEN_MODE openmode);\n\tu32 FileSize();\n\tvoid Read(void* buf, u32 length, s32 offset);\n\nprivate:\n\tvoid InitDVD();\n\tvoid Init();\n};\n\n\nclass DGPosition{\nprotected:\n\tVec m_Position; //0x0\n\tVec m_Rotation; //0xC\n\tVec m_Scale; //0x18\n\tMtx m_Trans; //0x24\n\tu8 m_TransFlag; //0x54\n\tu8 unk55[3]; //padding\n\npublic:\n\tDGPosition(const DGPosition&);\n\tDGPosition();\n\t~DGPosition();\n\n\tvoid GetTransMtx(Mtx& transmtx);\n\n\tvoid SetPosition(const Vec& pos);\n\tvoid AddPosition(const Vec& add);\n\tvoid DirectionalAddPosition(Vec& add);\n\tVec GetPosition();\n\n\tvoid SetRotation(const Vec& rot);\n\tvoid AddRotation(const Vec& add);\n\tVec GetRotation();\n\tvoid LimitRotation();\n\n\tvoid SetScale(const Vec& scale);\n\tvoid AddScale(const Vec& add);\n\tVec GetScale();\n\n\tvoid GetDirectionalVec(Vec& src, Vec& dst);\n};\n\nclass DGTexture{\nprivate:\n\tu16 m_ReferCount; //0x0\n\tu8 unk2[2]; //padding\n\tu8* m_TexImage; //0x4\n\tu16 m_Width; //0x8\n\tu16 m_Height; //0xA\n\tGXTexFmt m_TexFormat; //0xC\n\tu8 m_MipLevel; //0x10\n\tu8 unk11[3]; //padding\n\npublic:\n\tDGTexture(const DGTexture&);\n\tDGTexture();\n\t~DGTexture();\n\n\tu8 LoadDTX(char* szFileName);\n\tu16 IncRefer();\n\tu16 DecRefer();\n\tvoid* GetImagePtr();\n\tu16 GetWidth();\n\tu16 GetHeight();\n\tGXTexFmt GetFormat();\n\tu8 GetMipLevel();\n};\n\nclass DGTexMan{\nprivate:\n    u16 m_MaxTextureNum; //0x0\n    u16 m_TextureNum; //0x2\n    u16 m_TexturePointer; //0x4\n    u8 unk5[2]; //padding\n    char* m_TexNameTable; //0x8\n    DGTexture** m_TextureTable; //0xC\n    u8 m_EnableMipMap; //0x10\n    u8 m_EnableExpensiveMipMap; //0x11\n    u8 unk12[2]; //padding\n\npublic:\n    DGTexMan(const DGTexMan&);\n    DGTexMan();\n    DGTexMan(u16 MaxTextureNum);\n    ~DGTexMan();\n\n    DGTexture* GetTexture(u16 htex);\n    u16 LoadTexture(const char* szFileName);\n    u16 AttachTexture(u16 htex);\n    void DetachTexture(u16 htex);\n    u8 InitTexObj(GXTexObj* texobj, u16 htex, GXTexWrapMode wrapS, GXTexWrapMode wrapT);\n    u16 GetWidth(u16 htex);\n    u16 GetHeight(u16 htex);\n    void EnableMipMap(u8 mip);\n    void EnableExpensiveMipMap(u8 mip);\n\nprivate:\n    u16 AddTexture(const char* szFileName, DGTexture* Texture);\n    void DeleteTexture(u16 htex);\n    u16 GetTextureHandle(const char* szFileName);\n};\n\nclass DGObject{\nprivate:\n\tu16 m_ReferCount; //0x0\n\tDGTexMan* m_TexMan; //0x4\n\n\tGXAttrType m_VIAT; //0x8\n\tGXAttrType m_NIAT; //0xC\n\tGXAttrType m_CIAT; //0x10\n\tGXAttrType m_TIAT; //0x14\n\n\tGXCompCnt m_VCompCnt; //0x18\n\tGXCompType m_VCompType; //0x1C\n\tu8 m_VFixPoint; //0x20\n\tu8 m_VStride; //0x21\n\tu8 unk22[2]; //padding\n\n\tGXCompCnt m_NCompCnt; //0x24\n\tGXCompType m_NCompType; //0x28\n\tu8 m_NFixPoint; //0x2C\n\tu8 m_NStride; //0x2D\n\tu8 unk2E[2]; //padding\n\n\tGXCompCnt m_CCompCnt; //0x30\n\tGXCompType m_CCompType; //0x34\n\tu8 m_CStride; //0x38\n\tu8 unk39[3]; //padding\n\n\tGXCompCnt m_TCompCnt; //0x3C\n\tGXCompType m_TCompType; //0x40\n\tu8 m_TFixPoint; //0x44\n\tu8 m_TStride; //0x45\n\tu8 unk46[2]; //padding\n\n\tu8* m_ArrayImg; //0x48\n\tu32 m_ArrayImgSize; //0x4C\n\tvoid* m_NormalArrayImg; //0x50\n\tvoid* m_ColorArrayImg; //0x54\n\tvoid* m_TexUVArrayImg; //0x58\n\tu8* m_ObjSteram; //0x5C\n\tu8* m_DispList; //0x60\n\n\tu16 m_TexTrans[8]; //0x64\n\tu16 m_uTexWrap; //0x74\n\tu16 m_vTexWrap; //0x76\n\tu8* m_PartsBlock; //0x78\n\npublic:\n\t//referred to as a typedef in dwarf\n\tstatic u32 lineMode;\n\n\tDGObject(const DGObject&);\n\tDGObject(DGTexMan* TexMan);\n\t~DGObject();\n\n\tvoid Draw();\n\tu16 IncRefer();\n\tu16 DecRefer();\n\tu8 LoadNDMPartsBlock(DUDvd& File);\n\tvoid MakeTexTransTable(u16* GlobalTexTable);\n\tu8* GetPartsBlock();\n\tu8 IsNull();\n\tvoid SetLineMode(int); //not in the cpp file according to dwarf\n\tint GetLineMode(); //not in the cpp file according to dwarf\n\nprivate:\n\tvoid SetArrayFormat(u16 VertexArrayFormat, u16 NormalArrayFormat, u16 ColorArrayFormat, u16 TexUVArrayFormat);\n\tvoid ExecuteObjStream();\n\tvoid oscmdExtend0(u8*& OSPtr);\n\tvoid oscmdVtxDesc(u8*& OSPtr);\n\tvoid oscmdTevDirect(u8*& OSPtr);\n\tvoid oscmdTevOrder(u8*& OSPtr);\n\tvoid oscmdTevStages(u8*& OSPtr);\n\tvoid oscmdTexGens(u8*& OSPtr);\n\tvoid oscmdTevColorInOp(u8*& OSPtr);\n\tvoid oscmdTevAlphaInOp(u8*& OSPtr);\n\tvoid oscmdTevColor(u8*& OSPtr);\n\tvoid oscmdBlendMode(u8*& OSPtr);\n\tvoid oscmdTexCoordGen(u8*& OSPtr);\n\tvoid oscmdIndStages(u8*& OSPtr);\n\tvoid oscmdIndTexOrder(u8*& OSPtr);\n\tvoid oscmdIndTexCoordScale(u8*& OSPtr);\n\tvoid oscmdExtendF(u8*& OSPtr);\n\tvoid oscmdDisplayList(u8*& OSPtr);\n\tvoid oscmdZMode(u8*& OSPtr);\n\tvoid oscmdIndBumpXYZ(u8*& OSPtr);\n\tvoid oscmdDrawLine(u8*& OSPtr);\n};\n\nclass DGObjMan{\nprivate:\n\tu16 m_MaxObjectNum; //0x0\n\tu16 m_ObjectNum; //0x2\n\tDGObject** m_ObjectTable; //0x4\n\npublic:\n\tDGObjMan(const DGObjMan&);\n\tDGObjMan(u16 MaxObjectNum);\n\t~DGObjMan();\n\n\tu16 AddObject(DGObject* object);\n\tDGObject* GetObject(u16 hobj);\n\tu16 AttachObject(u16 hobj);\n\tvoid DetachObject(u16 hobj);\n\nprivate:\n\tvoid DeleteObject(u16 hobj);\n};\n\n\nclass DGCamera : DGPosition{\nprivate:\n\tMtx44 m_ProjectionMtx; //0x58\n\tMtx m_LightProjectionMtx; //0x98\n\tMtx m_LightProjectionMtxYInverse; //0xC8\n\tfloat m_ZNear; //0xF8\n\tfloat m_ZFar; //0xFC\n\tVec m_CamUp; //0x100\n\tVec m_TargetPos; //0x10C\n\tDG_RENDMAN_TARGET_MODE m_TargetMode; //0x118\n\tGXColor m_FogColor; //0x11C\n\tGXFogType m_FogType; //0x120\n\tfloat m_FogNear; //0x124\n\tfloat m_FogFar; //0x128\n\npublic:\n\tDGCamera(const DGCamera&);\n\tDGCamera();\n\t~DGCamera();\n\n\tvoid SetCamera(Mtx& viewmtx);\n\tvoid SetProjectionMtx();\n\tvoid GetViewMtx(Mtx& viewmtx);\n\tvoid SetLightFrustum(float height, float width, float znear);\n\tvoid GetLightMtx(Mtx& texpromtx);\n\tvoid GetLightMtxYInverse(Mtx& texpromtx);\n\tvoid SetCameraFrustum(float height, float width, float znear, float zfar);\n\tvoid SetCameraFrustumUpper(float height, float width, float znear, float zfar);\n\tvoid SetCameraFrustumLower(float height, float width, float znear, float zfar, float xfbheight);\n\tvoid SetCamUp(Vec up);\n\tvoid SetTargetPos(Vec targetpos);\n\tVec GetTargetPos();\n\tvoid SetTargetMode(DG_RENDMAN_TARGET_MODE mode);\n\tvoid SetFogType(GXFogType type);\n\tvoid SetFogRange(float fognear, float fogfar);\n\tvoid SetFogRangeRatio(float fognear, float fogfar);\n\tvoid SetFogColor(const GXColor& color);\n};\n\nclass DGTexPro{\nprivate:\n\tDGTexMan* m_TexMan; //0x0\n\tu16 m_HTex; //0x4\n\tu8 unk5[2]; //padding\n\tGXTexWrapMode m_WrapS; //0x8\n\tGXTexWrapMode m_WrapT; //0xC\n\tDGCamera* m_Camera; //0x10\n\tvoid* m_DirectTexImage; //0x14\n\tu16 m_DirectTexWidth; //0x18\n\tu16 m_DirectTexHeight; //0x1A\n\tGXTexFmt m_DirectTexFormat; //0x1C\n\tu8 m_DirectTexMipLevel; //0x20\n\tu8 unk21[3]; //padding\n\npublic:\n\tDGTexPro(const DGTexPro&);\n\tDGTexPro(DGTexMan* TexMan);\n\tDGTexPro(DGTexMan* TexMan, const char* szFileName);\n\t~DGTexPro();\n\n\tvoid SetCamera(DGCamera* camera);\n\tu8 InitTexObj(GXTexObj* texobj);\n\tvoid GetLightMtx(Mtx& LightMtx);\n\tvoid SetDirectTex(void* image, u16 width, u16 height, GXTexFmt fmt, u8 miplevel);\n};\n\n\nclass DGRendState{\npublic:\n\tMtx m_Viewmtx; //0x0\n\tMtx m_Worldmtx; //0x30\n\tDGCamera* m_Camera; //0x60\n\tu32 m_CH_COLOR0A0; //0x64\n\tu32 m_CH_COLOR1A1; //0x68\n\tGXColor m_LightChannel0_AmbColor; //0x6C\n\tGXColor m_LightChannel0_MatColor; //0x70\n\tGXColor m_LightChannel1_AmbColor; //0x74\n\tGXColor m_LightChannel1_MatColor; //0x78\n\tu8 m_ChannelNum; //0x7C\n\tu8 m_ExistBlendParts; //0x7D\n\tu8 m_RendBlendParts; //0x7E\n\tu8 unk7F; //padding\n\tDGTexPro* m_TexProjection[8]; //0x80\n\n\tDGRendState(const DGRendState&);\n\tDGRendState();\n\t~DGRendState();\n\n\tvoid SetChan0AmbColor(GXColor& AmbColor);\n\tvoid SetChan0MatColor(GXColor& MatColor);\n\tvoid SetChan1AmbColor(GXColor& AmbColor);\n\tvoid SetChan1MatColor(GXColor& MatColor);\n\tvoid SetNumChans(u8 channum);\n};\n\nclass DGLight{\nprivate:\n\tVec m_Position; //0x0\n\tVec m_Direction; //0xC\n\tGXColor m_LightColor; //0x18\n\tVec m_DistanceAttenuation; //0x1C\n\tVec m_AngleAttenuation; //0x28\n\tu8 m_AmbientVtx; //0x34\n\tu8 m_MaterialVtx; //0x35\n\tu8 m_SpotLight; //0x36\n\tu8 m_SpecularLight; //0x37\n\tfloat m_Shininess; //0x38\n\npublic:\n\tDGLight(const DGLight&);\n\tDGLight();\n\t~DGLight();\n\n\tvoid SetLight(GXLightID lid, DGRendState& RendState);\n\tVec SetPosition(const Vec& pos);\n\tVec AddPosition(const Vec& add);\n\tVec GetPosition();\n\tvoid SetDirection(const Vec& dir);\n\tvoid SetDirectionFromObserve(Vec& pos);\n\tVec GetDirection();\n\tvoid SetLightColor(const GXColor& color);\n\tGXColor GetLightColor();\n\tvoid EnableSpecularLight(u8 flag);\n\tvoid SetShininess(float shininess);\n\tvoid EnableSpotLight(u8 flag);\n\tvoid SetDistanceAttenuation(float k0, float k1, float k2);\n\tvoid SetDistanceAttenuation_0(float p0);\n\tvoid SetDistanceAttenuation_1(float p0, float d1, float p1);\n\tvoid SetDistanceAttenuation_2(float p0, float d1, float p1);\n\tvoid SetDistanceAttenuation_3(float p0, float d1, float p1, float d2, float p2);\n\tvoid SetAngleAttenuation(float a0, float a1, float a2);\n\tvoid SetAngleAttenuation_Flat(float cutoff, float p0); //2nd param name isn't in dwarf for some reason\n\tvoid SetAngleAttenuation_Cos(float cutoff, float p0);\n\tvoid SetAngleAttenuation_Cos2(float cutoff, float p0);\n};\n\n\nclass DGParts;\n\nstruct tagPARTS_LIST{\n\ttagPARTS_LIST* next; //0x0\n\ttagPARTS_LIST* prev; //0x4\n\tDGParts* parts; //0x8\n\n\ttagPARTS_LIST(const tagPARTS_LIST&);\n\ttagPARTS_LIST();\n};\n\nclass DGParts : DGPosition{\nprivate:\n\tDGObjMan* m_ObjMan; //0x58\n\ttagPARTS_LIST* m_PartsList; //0x5C\n\tchar* m_Name; //0x60\n\tu16 m_HObject; //0x64\n\tu8 m_LightChannel_Amb; //0x66\n\tu8 m_LightChannel_Mat; //0x67\n\tGXColor m_LightChannel_AmbColor; //0x68\n\tGXColor m_LightChannel_MatColor; //0x6C\n\tu8 m_Blend; //0x70\n\tu8 m_Culling_Front; //0x71\n\tu8 m_Culling_Back; //0x72\n\tu8 m_Visible; //0x73\n\tu8 m_VisibleChild; //0x74\n\tu8 m_Specular; //0x75\n\tu8 m_EnvMap; //0x76\n\tu8 m_EnableChannels; //0x77\n\tu8 m_SpecMap; //0x78\n\tu8 m_BumpMap; //0x79\n\tu8 m_TextureProjection; //0x7A\n\tu8 m_EnableLightingD; //0x7B\n\tu8 m_EnableLightingS; //0x7C\n\tVec m_WorldPosition; //0x80\n\npublic:\n\tDGParts(const DGParts&);\n\tDGParts(DGObjMan* objman);\n\t~DGParts();\n\n\tvoid AddPartsList(DGParts* parts);\n\tDGParts* CullPartsListStr(const char* ChildName);\n\tDGParts* CullPartsListNo(u16 ChildNo);\n\tDGParts* GetPartsPtr(const char* name, u8& flag);\n\tDGParts* GetPartsPtr(u16& no);\n\tchar* GetNamePtr();\n\tu16 NumOfChild();\n\tvoid Draw(DGRendState& RendState);\n\tvoid SetVisible(u8 visible);\n\tu8 GetVisible();\n\tvoid SetVisibleChild(u8 visible);\n\tu8 GetVisibleChild();\n\tu8 CreateInstance(u8*& ClassPtr);\n\tvoid SetWorldPosition(Mtx& Trans);\n\tVec GetWorldPosition();\n\nprivate:\n\tvoid AllDeletePartsList();\n};\n\n\n\nclass DGModel : DGPosition {\nprivate:\n\tDGObjMan* m_ObjMan; //0x58\n\nprotected:\n\tDGParts* m_Parts; //0x5C\n\npublic:\n\tDGModel(const DGModel&);\n\tDGModel(DGObjMan* objman);\n\t~DGModel();\n\n\tDGParts* GetPartsPtr(const char* name);\n\tDGParts* GetPartsPtr(u16 no);\n\tvoid Draw(DGRendState& RendState);\n\tu8 CreateInstance(u8* MasterModel);\n\tvoid SetPartsWorldPosition();\n\tVec GetPartsWorldPosition(const char* PartsName);\n};\n\nstruct tagRENDERING_LIST{\n\ttagRENDERING_LIST* next; //0x0\n\ttagRENDERING_LIST* prev; //0x4\n\tDGModel* model; //0x8\n\n\ttagRENDERING_LIST(const tagRENDERING_LIST&);\n\ttagRENDERING_LIST();\n};\n\nclass DGRendMan{\nprivate:\n\ttagRENDERING_LIST* m_RList; //0x0\n\tDGLight* m_LightList[8]; //0x4\n\tDGCamera* m_Camera; //0x24\n\tDGTexPro* m_TexProjection[8]; //0x28\n\npublic:\n\t//these variables are referred to as typedefs, but probably are static vars?\n\tstatic VITVMode m_progressive;\n\n\tstatic u16 m_AdjustForOverscanH;\n\tstatic u16 m_AdjustForOverscanW;\n\n\tstatic GXGamma m_DispCopyGamma;\n\tstatic u16 m_DispCopyDstH;\n\tstatic u16 m_DispCopyDstW;\n\tstatic float m_DispCopyYScale;\n\tstatic u16 m_DispCopySrcH;\n\tstatic u16 m_DispCopySrcW;\n\tstatic u16 m_DispCopySrcY;\n\tstatic u16 m_DispCopySrcX;\n\n\tstatic float m_ViewportF;\n\tstatic float m_ViewportN;\n\tstatic float m_ViewportH;\n\tstatic float m_ViewportW;\n\tstatic float m_ViewportY;\n\tstatic float m_ViewportX;\n\n\tstatic u32 m_ScissorH;\n\tstatic u32 m_ScissorW;\n\tstatic u32 m_ScissorY;\n\tstatic u32 m_ScissorX;\n\n\tstatic u32 m_BGZValue;\n\tstatic GXColor m_BGColor;\n\n\tstatic void* m_FrameBuf2;\n\tstatic void* m_FrameBuf1;\n\tstatic void* m_CurrentBuf;\n\n\tstatic GXRenderModeObj* m_RenderMode;\n\tstatic GXRenderModeObj* m_BaseRenderMode;\n\tstatic u8 m_ChangeRenderModeFlag;\n\n\tstatic GXFifoObj* m_GpFIFO_Obj;\n\tstatic void* m_GpFIFO;\n\tstatic u32 m_GpFIFO_Size;\n\n\tstatic u8 m_DrawReadyFlag;\n\tstatic u8 m_FirstFrameFlag;\n\tstatic u8 m_InstanceNum;\n\n\n\tDGRendMan(const DGRendMan&);\n\tDGRendMan();\n\tDGRendMan(u32 FifoSize);\n\t~DGRendMan();\n\n\tvoid DrawBegin();\n\tvoid DrawEnd(u8 cpy, u8 vsnc);\n\tvoid Draw(RendManDrawMode mode);\n\n\tvoid CopyRenderingBuffer(u8 lower);\n\n\tvoid AddModel(DGModel* model);\n\tvoid AddLight(DGLight* light);\n\tvoid AddCamera(DGCamera* camera);\n\n\tvoid SetTexProjection(u8 no, DGTexPro* texpro);\n\n\tvoid SetScissor(u32 x, u32 y, u32 w, u32 h);\n\tvoid SetScissorDefault();\n\n\tvoid SetViewport(float x, float y, float w, float h, float n, float f);\n\tvoid SetViewportDefault();\n\n\tvoid SetRenderMode(GXRenderModeObj* rendermode);\n\tGXRenderModeObj* GetBaseRenderMode();\n\n\tvoid SetDispCopySrc(u16 x, u16 y, u16 w, u16 h);\n\tvoid SetDispCopySrcDefault();\n\n\tvoid SetDispCopyYScale(float s);\n\tvoid SetDispCopyYScaleDefault();\n\n\tvoid SetDispCopyDst(u16 w, u16 h);\n\tvoid SetDispCopyDstDefault();\n\n\tvoid SetDispCopyGamma(GXGamma gamma);\n\tGXGamma GetDispCopyGamma();\n\n\tvoid SetAdjustForOverscan(u16 w, u16 h);\n\tvoid SetAdjustForOverscanDefault();\n\n\tvoid SetBGColor(GXColor bgcolor);\n\tvoid SetBGZValue(u32 zvalue);\n\tu16 GetxfbHeight();\n\tvoid* GetCurrentBuf();\n\nprivate:\n\tvoid ClearRenderingList();\n\tvoid DisplaySetting();\n};\n\n\nclass DGAniModel : DGModel {\nprivate:\n\tu8 m_UseAniModel; //0x60\n\tu8 unk61; //padding\n\tu16 m_AniTypeNum; //0x62\n\tchar* m_AniTypeName; //0x64\n\tu16* m_AniPartsNum; //0x68\n\tDGParts*** m_AniParts; //0x6C\n\tu16 m_NowHAniType; //0x70\n\tu16 m_NowPatNo; //0x72\n\npublic:\n\tDGAniModel(const DGAniModel&);\n\tDGAniModel(DGObjMan* objman);\n\t~DGAniModel();\n\n\tu8 ReconstructToAnimodelStruct();\n\tu16 GetAniType(const char* AniTypeName);\n\tu16 NumOfAniTypePat(u16 hAniType);\n\tvoid SetAniPat(u16 hAniType, u16 PatNo);\n\tu16 GetNowAniType();\n\tu16 GetNowAniPat();\n\nprivate:\n\tvoid DeleteAniModelArray();\n};\n\nclass DGFont{\nprivate:\n\tDGTexMan* m_TexMan; //0x0\n\tu16 m_HTex; //0x4\n\tu16 m_TexWidth; //0x6\n\tu16 m_TexHeight; //0x8\n\tu8 m_FontWidth; //0xA\n\tu8 m_FontHeight; //0xB\n\tu8 m_Sequence; //0xC\n\tchar m_Start; //0xD\n\tchar m_End; //0xE\n\tu8 unkF; //padding\n\ts16 m_RetPosX; //0x10\n\ts16 m_PosX; //0x12\n\ts16 m_PosY; //0x14\n\ts16 m_Size; //0x16\n\tGXColor m_Color; //0x18\n\tu8 m_Ready; //0x1C\n\tu8 unk1D[3]; //padding\n\npublic:\n\tDGFont(const DGFont&);\n\tDGFont(DGTexMan* TexMan, const char* szFileName, u8 width, u8 height, u8 sequence, char start, char end);\n\t~DGFont();\n\n\tvoid Begin(DGRendMan* rman);\n\tvoid End();\n\tvoid StrOut(const char* str);\n\tvoid SetPosition(s16 x, s16 y);\n\tvoid SetSize(s16 s);\n\tvoid SetColor(u8 r, u8 g, u8 b, u8 a);\n\nprivate:\n\tvoid CharOut(char character);\n};\n\nclass DGModelMan{\nprivate:\n\tDGObjMan* m_ObjMan; //0x0\n\tDGTexMan* m_TexMan; //0x4\n\tu16 m_MaxMaterModelNum; //0x8\n\tu16 m_MsterModelNum; //0xA\n\tu16 m_MsterModelPointer; //0xC\n\tu8** m_MasterModelTable; //0x10\n\nprotected:\n\tu8 m_Lock; //0x14\n\tu8 unk15[3]; //padding\n\npublic:\n\tDGModelMan(const DGModelMan&);\n\tDGModelMan();\n\tDGModelMan(u16 MaxMaterModelNum, u16 MaxTextureNum, u16 MaxObjectNum);\n\t~DGModelMan();\n\n\tDGModel* CreateInstance(u16 ModelHandle);\n\tDGAniModel* CreateAnimeInstance(u16 ModelHandle);\n\tu16 LoadNDM(char* szFileName);\n\tu16 LoadDuplicateNDM(char* szFileName);\n\tvoid DeleteMasterModel(u16 ModelHandle);\n\tDGFont* LoadFont(const char* szFileName, u8 width, u8 height, u8 sequence, char start, char end);\n\tDGTexPro* LoadTexPro(const char* szFileName);\n\tvoid EnableMipMap(u8 mip);\n\tvoid EnableExpensiveMipMap(u8 mip);\n\nprivate:\n\tu16 AddMasterModel(u8* ModelClass);\n\tvoid DestroyMasterModel(u16 ModelHandle);\n\tu16 IncRefer(u16 ModelHandle);\n\tu16 DecRefer(u16 ModelHandle);\n};\n\n\n\nclass DTHit{\nprivate:\n\ts8 _step; //0x0\n\ts8 _room_number; //0x1\n\tu8 unk2[2]; //padding\n\n\tstruct{\n\t\tvoid* _ground_hit_data; //0x0\n\t\tu32 _ground_status; //0x4\n\t\tvoid* _roof_hit_data; //0x8\n\t\tu32 _roof_status; //0xC\n\t\tvoid* _wall_hit_data[8]; //0x10\n\t\tu32 _wall_status[8]; //0x30\n\t\tu8 _wall_wp; //0x50\n\t\tu8 unk51[3]; //padding\n\t} _last_hit; //0x4\n\n\tstruct{\n\t\tvoid* _bgh_top; //0x0\n\t\tvoid* _header_top; //0x4\n\t\tu32 _num_of_status; //0x8\n\t\tu32* _map_list; //0xC\n\t\tfloat _area_size; //0x10\n\t\tu32 _num_of_area[2]; //0x14\n\t\tfloat _area_offset[2]; //0x1C\n\t} _hit_data[8]; //0x58\n\npublic:\n\tDTHit(const DTHit&);\n\tDTHit();\n\t~DTHit();\n\n\ts8 set_current_room_number(s8 room_number);\n\ts8 get_current_room_number();\n\ts8 set_hit_data(s8 room_number, void* hit_data_address);\n\tvoid* get_hit_data(s8 room_number);\n\ts8 check_ground(Vec* check_position, float* graund_y); //typo\n\ts8 check_roof(Vec* check_position, float* roof_y);\n\ts8 check_wall(Vec* check_position, float range, Vec* new_position, s8 camera_flag);\n\tu32 get_ground_status();\n\tvoid* get_ground_data();\n\tu32 get_roof_status();\n\tvoid* get_roof_data();\n\tu8 get_wall_hit_count();\n\tu32* get_wall_status();\n\tvoid* get_wall_data();\n\nprivate:\n\ts8 _wall_check_one_area(float range, s8 camera_flag, u32 area_index, Vec* ans_pos);\n\ts8 _check_range(Vec* pos, float range, u32 status_id, void* hit, s8 camera_flag);\n\ts8 _check_roof_y_pos(Vec* check_position, float* roof_y, void* hit);\n\ts8 _check_y_pos(Vec* check_position, float* graund_y, void* hit); //typo\n};\n\n\nclass DTPad{\nprivate:\n\tu32 ResetReq; //0x0\n\tu32 count; //0x4\n\nprotected:\n\tPADStatus prepad[3]; //0x8\n\tPADStatus pad[3]; //0x38\n\npublic:\n\tDTPad(const DTPad&);\n\tDTPad();\n\t~DTPad();\n\n\tvoid Read();\n\ts8 StickX(u16 id);\n\ts8 StickY(u16 id);\n\ts8 SubStickX(u16 id);\n\ts8 SubStickY(u16 id);\n\tint IsTrg(u16 id, u16 key);\n\tint IsCnd(u16 id, u16 key);\n\tint IsTrp(u16 id, u16 key);\n\tint IsPush(u16 id, u16 key);\n\tint IsStickTrg(u16 id, u16 stk);\n\tPADStatus* GetPADStatus(u8 padNo);\n};\n\nclass DTLight{\nprotected:\n\tDGLight light[8]; //0x0\n\n\n\tvoid SettingMpol();\n\tvoid SettingEnve();\n\tvoid SettingSpil();\n\tvoid SettingCine();\n\tvoid SettingCave();\n\tvoid SettingDome();\n\tvoid SettingHang();\n\tvoid SettingEntr();\n\npublic:\n\tDTLight(const DTLight&);\n\tDTLight();\n\t~DTLight();\n\n\tvoid Setting(u8 stageNo);\n\tvoid SetKuriboLight();\n};\n\nclass DTCamera : DGCamera{\nprivate:\n\ts8 _mode; //0x12C\n\ts8 _step; //0x12D\n\ts8 _movie_play_mode; //0x12E\n\tu8 unk12F; //padding\n\n\tstruct{\n\t\tfloat _t[2]; //0x0\n\t\tfloat _pos[2][3][3]; //0x8\n\t\tfloat _speed[2]; //0x50\n\t} _spline; //0x130\n\n\tstruct{\n\t\tfloat _eye_hight; //0x0\n\t\tfloat _eye_distance; //0x4\n\t\tfloat _at_hight; //0x8\n\t\tfloat _at_distance; //0xC\n\t} _offset; //0x188\n\n\n\tstruct{\n\t\tfloat _rol_speed; //0x0\n\t\tfloat _target_y_rol; //0x4\n\t\tfloat _rol_offset; //0x8\n\t\tfloat _hight_offset; //0xC\n\t\tVec oi_pos[2]; //0x10\n\t\tfloat oi_speed; //0x28\n\t\ts8 oi_counter; //0x2C\n\t\tu8 unk2D; //padding\n\t\tu16 old_button; //0x2E\n\t} _trail; //0x198\n\n\tstruct{\n\t\tVec _main_stick; //0x0\n\t\tVec _sub_stick; //0xC\n\t\tVec _delta; //0x18\n\t\tVec _at_offset; //0x24\n\t\tVec _eye_pos; //0x30\n\t\tfloat _rotation[3]; //0x3C\n\t\tVec _axis; //0x48\n\t} _detach; //0x1C8\n\n\tstruct{\n\t\tVec _eye_offset; //0x0\n\t\tVec _at_offset; //0xC\n\t\tfloat _old_mario_angle; //0x18\n\t\tfloat _up_angle; //0x1C\n\t} _mario_view; //0x21C\n\n\tstruct{\n\t\ts8 _current_room; //0x0\n\t\tu8 unk1[3]; //padding\n\t\tfloat _speed; //0x4\n\t\tfloat _slow_speed; //0x8\n\t\tvoid* _mcd_top[16]; //0xC\n\t\tvoid* _read_p[2][16]; //0x4C\n\t\tvoid* _data_top_p[2][16]; //0xCC\n\t\tvoid* _data_bottom_p[2][16]; //0x14C\n\t\tu32 _num_of_point[2][16]; //0x1CC\n\t\tu32 _current_point[2][16]; //0x24C\n\t} _movie; //0x23C\n\n\tstruct{\n\t\tu16 _old; //0x0\n\t\tu16 _trg; //0x2\n\t} _pad; //0x408\n\n\tstruct{\n\t\ts8 _enable_flag; //0x0\n\t\ts8 _wall_hit_flag; //0x1\n\t\tu8 unk2[2]; //padding\n\t\tvoid* _bgh; //0x4\n\t\tfloat _offset; //0x8\n\t\tfloat _range; //0xC\n\t} _hit; //0x50C\n\n\tstruct{\n\t\ts8 mode; //0x0\n\t\ts8 old_mode; //0x1\n\t\tu8 unk2[2]; //padding\n\t\tfloat speed[2]; //0x4\n\t} _spil; //0x51C\n\npublic:\n\tDTCamera(const DTCamera&);\n\tDTCamera();\n\t~DTCamera();\n\n\ts8 set_mode(s8 new_mode);\n\ts8 get_mode();\n\tvoid set_speed(float speed, float at_speed, float movie_hi_speed, float movie_lo_speed);\n\tfloat get_speed();\n\tfloat get_at_speed();\n\tfloat get_movie_hi_speed();\n\tfloat get_movie_lo_speed();\n\tvoid set_eye_offset(float eye_hight, float eye_distance);\n\tvoid get_eye_offset(float* eye_hight, float* eye_distance);\n\tvoid set_at_offset(float at_hight, float at_distance);\n\tvoid get_at_offset(float* at_hight, float* at_distance);\n\tvoid set_trail_rol_speed(float rol_speed);\n\tfloat get_trail_rol_speed();\n\tvoid set_mario_view_offset(Vec* eye_offset, Vec* at_offset);\n\tvoid get_mario_view_offset(Vec* eye_offset, Vec* at_offset);\n\ts8 set_current_room_number(s8 set_current_room_number);\n\ts8 get_current_room_number();\n\ts8 set_mcd_data(s8 room_number, void* mcd_data_address);\n\tvoid* get_mcd_data(s8 room_number);\n\tvoid set_bgh_handle(void* bgh_handle);\n\tvoid* get_bgh_handle();\n\tvoid set_hit_enable_flag(s8 enable_flag);\n\ts8 get_hit_enable_flag();\n\ts8 iGetMoviePlayMode();\n\tvoid move(float mario_angle, PADStatus* pad, Vec* mario_position);\n\tvoid move(Vec* mario_position, float mario_angle, Vec* pipe_position, s8 mode); //1st param name is missing in dwarf\n\tvoid move(Vec* mario_position, float mario_angle, Vec*, Vec*); //last 2 param names aren't in dwarf\n\tvoid move(PADStatus* pad, Vec* mario_position, float mario_angle);\n\tvoid move(PADStatus* pad);\n\ts8 move(PADStatus* pad, float* t, s8 pause_mode);\n\tvoid move(s8 game_mode, Vec* mario_position, float mario_angle, PADStatus* pad);\n\tvoid move();\n\nprivate:\n\tfloat _Vec2Angle(float x, float z);\n\tvoid _get_spil_eye_pos(Vec* mario_position, Vec* next_position);\n\tvoid _get_pipe_at_pos(Vec* pipe_position, Vec* next_position);\n\tvoid _get_pipe_eye_pos(Vec* pipe_position, float mario_angle, Vec* next_position);\n\tvoid init_spline_table(Vec* pos, s8 eyeat);\n\ts8 _check_abs(float a, float b);\n\ts8 _check_bg(Vec* pos);\n\tvoid _get_pad_trg(PADStatus* pad);\n\tvoid set_trail_offset(PADStatus* pad);\n\tvoid set_mario_view_sub_rol(PADStatus* pad);\n\tvoid set_mario_view_home_keep(Vec* mario_position, float mario_angle);\n\tfloat iabs(float value);\n\tvoid get_mario_view_home(Vec* home_eye_position, Vec* home_at_position, Vec* mario_position, float mario_angle);\n\ts8 go_mario_view_home(Vec* mario_position, float mario_angle);\n\tvoid get_next_rotation(float mario_angle, s8 stick_flag);\n\tvoid set_detach_at();\n\tvoid set_detach_eye();\n\tvoid get_delta(PADStatus* pad);\n\tvoid normalize(Vec* src, Vec* dst);\n\tfloat get_spline(float t, float p0, float p1, float p2);\n\tvoid get_next_at_position(Vec* next_position, Vec* mario_position);\n\tvoid get_next_position(Vec* next_position, Vec* mario_position);\n\tvoid shift_pos_r(Vec* next_position, s8 eyeat);\n\tvoid shift_pos(Vec* next_position, s8 eyeat);\n};\n\nclass DTGimmick{\nprivate:\n\tu16 num_of_coin; //0x0\n\nprotected:\n\tu8 doorCnt; //0x2\n\tu8 unk3; //padding\n\tDGParts* doorCL; //0x4\n\tDGParts* doorCR; //0x8\n\tDGParts* doorNL; //0xC\n\tDGParts* doorNR; //0x10\n\tfloat fogTime; //0x14\n\tfloat fogCount; //0x18\n\tu8 fadeFlag; //0x1C\n\tu8 titleFlag; //0x1D\n\tu8 unk1E[2]; //padding\n\tfloat title_time; //0x20\n\tu8 openingFlag; //0x24\n\ts8 mm; //0x25\n\ts8 premm; //0x26\n\ts8 mmcount; //0x27\n\tu8 boxStep; //0x28\n\tu8 boxCount; //0x29\n\tu8 unk2A[2]; //padding\n\tVec wpos; //0x2C\n\n\tfloat Randomf32();\n\tu8 Random();\n\t\n\tvoid FadeAction();\n\tvoid SetDoorMpol(u8 doorNo);\n\tvoid SetDoorEnve(u8 doorNo);\n\tvoid SetDoorSpil(u8 doorNo);\n\tvoid SetDoorCine(u8 doorNo);\n\tvoid SetDoorDome(u8 doorNo);\n\tvoid SetDoorHang(u8 doorNo);\n\tvoid SetDoorEntr(u8 doorNo);\n\tvoid DoorAction();\n\tvoid ActionMpol();\n\tvoid ActionEnve();\n\tvoid ActionSpil();\n\tvoid ActionCine();\n\tvoid ActionCave();\n\tvoid ActionDome();\n\tvoid ActionHang();\n\tvoid ActionEntr();\n\tvoid MovieModeDraw(u32 offsetY);\n\npublic:\n\tDTGimmick(const DTGimmick&);\n\tDTGimmick();\n\t~DTGimmick();\n\n\tvoid Action(u8 stageNo);\n\tvoid DoorOpen(u8 stageNo, u8 doorNo);\n\tvoid DoorClose(u8 stageNo, u8 doorNo);\n\tvoid FadeIn();\n\tvoid FadeOut();\n\tint IsFadeIn();\n\tint IsFadeOut();\n\tvoid CoinInit();\n\tvoid CoinDrop();\n\tvoid CoinDraw();\n\tvoid CoinExit();\n\tu8 IsAllOffCoin();\n\tu16 GetNumOfCoin();\n\tvoid AddNumOfCoin(s16 add_value);\n\tvoid TitleOn(u8 stageNo);\n\tvoid TitleOff();\n\tvoid TitleAction();\n\tvoid OpeningTitleOn();\n\tvoid OpeningTitleAction();\n\tvoid MovieAction(u32 offsetY);\n};\n\nclass DTPlayer{\nprotected:\n\tDGAniModel* model; //0x0\n\tu16 anitype; //0x4\n\tu16 patnum; //0x6\n\tu16 ani_time; //0x8\n\tu16 actNo; //0xA\n\tu16 actCount; //0xC\n\tu16 actFlag; //0xE\n\tu16 unkF; //padding\n\tVec pos; //0x10\n\tVec angle; //0x1C\n\ts8 stickX; //0x28\n\ts8 stickY; //0x29\n\ts8 stick_flag; //0x2A\n\tu8 unk2B; //padding\n\tDGTexPro* dummyPro; //0x2C\n\tDGTexPro* shadowPro; //0x30\n\tDGCamera shadowCam; //0x34\n\tu32 shadowSize; //0x160\n\tu8* shadowTex; //0x164\n\tDGTexPro* spilshadowPro; //0x168\n\tDGCamera spilshadowCam; //0x16C\n\tu8 spilshadowTex; //0x298\n\tfloat jumppow; //0x29C\n\tVec _door_start; //0x2A0\n\tVec _door_end; //0x2AC\n\ts8 _next_room_number; //0x2B8\n\tu8 unk2B9[3]; //padding\n\tu32 _exit_status; //0x2BC\n\ts8 _ground_hit_flag; //0x2C0\n\ts8 _dokan_hit_flag; //0x2C1\n\tu16 _wait_timer; //0x2C2\n\tu8 unk2C3; //padding\n\tu8 rolling; //0x2C4\n\tu8 unk2C5[3]; //padding\n\n\n\tvoid act_movie_spil();\n\tvoid act_movie_spil_init();\n\tvoid act_spil();\n\tvoid act_spil_init();\n\tvoid act_mpol();\n\tvoid act_mpol_init();\n\tvoid act_opening();\n\tvoid act_opening_init();\n\tvoid act_go_enter_next();\n\tvoid act_go_enter_init();\n\tvoid act_dokan_in();\n\tvoid act_dokan_in_init();\n\tvoid act_dokan_out();\n\tvoid act_dokan_out_init();\n\tvoid act_open();\n\tvoid act_open_init();\n\tvoid act_walk();\n\tvoid act_walk_init();\n\tvoid act_idle2();\n\tvoid act_idle2_init();\n\tvoid act_idle();\n\tvoid act_idle_init();\n\tvoid act_init();\n\n\tvoid DirectionalAddPosition(Vec& add);\n\tu8 HitFloor();\n\tvoid Rolling(u8 off);\n\tvoid normalize(Vec* src, Vec* dst);\n\n\tvoid _iSetDoorStartEnd(float* door_pos);\n\ts8 _iCheckDoor();\n\ts8 _iPointMove(Vec* goal, float speed);\n\tvoid _iSetDokanCenter(float* current_dokan_pos, float* next_dokan_pos);\n\ts8 _iCheckDokan();\n\n\tfloat GetCamAngle();\n\tfloat Vec2Angle(float x, float z);\n\tvoid stickCheck();\n\tvoid PlayerMove(float speed);\n\tint RevAnimation(int clamp);\n\tint Animation(int clamp);\n\tvoid SetAnimation(u8 name);\n\npublic:\n\tDTPlayer(const DTPlayer&);\n\tDTPlayer();\n\t~DTPlayer();\n\n\tvoid InitAction();\n\tvoid OpeningInit();\n\tvoid MpolModeInit();\n\tvoid SpilModeInit();\n\tVec* GetPosition();\n\tvoid SetPosition(Vec p);\n\tvoid SetRotation(Vec p);\n\tfloat GetAngle();\n\tvoid CreateShadow();\n\tDGTexPro* GetShadowPro(int dummy);\n\tvoid CreateSpilShadow();\n\tDGTexPro* GetSpilShadowPro(int dummy);\n\tu8 Action();\n\tVec GetSpilShadowCamPos();\n};\n\nclass DMainSystem{\nprivate:\n    u8 _stimer; //0x0\n    u8 _step[2]; //0x1\n    u8 _save_step[2]; //0x3\n    s8 _cursol_pos[2]; //0x5\n    s8 _cursol_wait; //0x7\n    s8 _old_stick[2]; //0x8\n    s8 _stage_no; //0xA\n    s8 _mode_no; //0xB\n    s8 _mipmap_mode; //0xC\n    s8 _tv_mode; //0xD\n    s8 _old_tv_mode; //0xE\n    s8 _fog_sw; //0xf\n    s8 _movie_camera_rcd; //0x10\n    s8 _sys_inf_disp_flag; //0x11\n    s8 _meter_disp_flag; //0x12\n    s8 _perf0_type; //0x13\n    s8 _perf1_type; //0x14\n    u8 unk15; //filler?\n    s16 _console_step; //0x16\n    s8 _route_counter; //0x18\n    s8 _old_route_counter; //0x19\n    u8 _resetFlag; //0x1a\n    u8 _resetButton; //0x1b\n    u32 _resetTime; //0x1c\n    DTPad _pad; //0x20\n    DTCamera _cam; //0x88\n    DTLight _light; //0x5b0\n    DTGimmick _gim; //0x790\n    DTPlayer _player; //0x7c8\n\n    struct {\n        s8 flag; //0x0\n        u8 next_room_no; //0x1\n        u8 old_room_no; //0x2\n        u8 open_door_no; //0x3\n        Vec door_start; //0x4\n        Vec door_end; //0x10\n    } _go_next_room; //0xa90\n\npublic:\n    s32 free_mem_size; //0xaac\n    DTHit _hit; //0xab0\n    DGAniModel* mario_model; //0xc28\n    u16 mario_hm; //0xc2c\n    u8 unkC2E[2]; //filler?\n\n    struct{\n        s8 load_status; //0x0\n        u8 unk1[3]; //filler?\n        void* datBGH; //0x4\n        void* datMCD; //0x8\n        DGModel* model[32]; //0xC\n        u16 hm[32]; //0x8C\n    } stage[8]; //0xc30\n\n    struct{\n        s16 film_cnt; //0x0\n        u8 unk2[2]; //filler\n        DGTexPro* texpro[75]; //0x4\n        DGTexPro* star; //0x130\n        DGTexPro* hart; //0x134\n        DGTexPro* mirrorpro; //0x138\n        DGCamera cam; //0x13C\n        DGLight light; //0x5EC\n        u8 mirrorbuf[0x20000]; //0x6A0\n\n        //These only appear in DTPlayer.cpp in the DWARF info\n        //__ct__Q211DMainSystem22@class$149DTPlayer_cppFv\n        //__ct__Q211DMainSystem22@class$149DTPlayer_cppFRCQ211DMainSystem22@class$149DTPlayer_cpp\n        //__dt__Q211DMainSystem22@class$149DTPlayer_cppFv\n    } cinema; //0x1290\n\n    DGRendMan rend_man; //0x21930\n    DGModelMan model_man; //0x219c0\n    DGFont* sysFont; //0x219d8\n    DGFont* title_bg; //0x219dc\n    DGFont* movie_icon; //0x219e0\n    DGCamera sysCam; //0x219e4\n    CSong song[9]; //0x21b10\n\n\n    DMainSystem(const DMainSystem&);\n    DMainSystem();\n    ~DMainSystem();\n\n    void MainLoop();\n    void _StepProc();\n    void iSysInit();\n    void iBeforeRender();\n    void iDoneRender();\n    void GetStageOffset(u8 stage_no, Vec* pos, Vec* rol);\n    void iSetFogSw(s8 sw);\n    void iCoinDrop();\n    DGFont* GetDGFontTitle();\n    DTPad* GetDTPad();\n    DTCamera* GetDTCamera();\n    DTHit* GetDTHit();\n    u8 GetStimer();\n    u8 GetRoomNumber();\n    s8 iGetGameMode();\n    void iSystemInitProc();\n    s8 iGetOldTvMode();\n    Vec GetSpilShadowCamPos();\n    s8 iGetMoviePlayMode();\n    DGModel* GetStageModel(u8, u8); //dwarf missing param names\n    u16 GetStageHandle(u8, u8); //dwarf missing param names\n    DGAniModel* GetPlayerModel();\n    s8 iIsAllOffCoin();\n    void iGoNextRoom(u8 next_stage_no, u8 open_door_no, Vec* door_start, Vec* door_end);\n    s8 iCheckReady();\n    void iCheckIn();\n    void iMpolDoorOpen();\n    void iMpolDoorClose();\n    void iGoNextPipe(u8 next_stage_no, Vec* pipe_pos, Vec* next_pipe_pos);\n    s8 iGetLoadStatus(s8); //dwarf missing param names\n\nprivate:\n    void _Reset();\n    void _LoadRequestMpol(s8 mode);\n    void _LoadRequestEnve();\n    void _LoadRequestSpil();\n    void _LoadRequestCine();\n    void _LoadRequestCave();\n    void _LoadRequestDome();\n    void _LoadRequestHang();\n    void _LoadRequestEntr();\n    void _Draw_Opening();\n\n    void _DelMpol();\n    void _DelEnve();\n    void _DelSpil();\n    void _DelCine();\n    void _DelCave();\n    void _DelDome();\n    void _DelHang();\n    void _DelEntr();\n\n    void _Draw_Mpol(s8 mario_flag);\n    void _Draw_Enve(s8 mario_flag);\n    void _Draw_Spil(s8 mario_flag);\n    void _Draw_Cine(s8 mario_flag);\n    void _Draw_Cave(s8 mario_flag);\n    void _Draw_Dome(s8 mario_flag);\n    void _Draw_Hang(s8 mario_flag);\n    void _Draw_Entr(s8 mario_flag);\n\n    void _Step_Movie_Mpol();\n    void _Step_Movie_Enve();\n    void _Step_Movie_Spil();\n    void _Step_Movie_Cine();\n    void _Step_Movie_Cave();\n    void _Step_Movie_Dome();\n    void _Step_Movie_Hang();\n    void _Step_Movie_Entr();\n    void _Step_Movie_All();\n    void _Step_Ending();\n    void _Step_Opening();\n    void _Step_Mpol();\n    void _Step_Enve();\n    void _Step_Spil();\n    void _Step_Cine();\n    void _Step_Cave();\n    void _Step_Dome();\n    void _Step_Hang();\n    void _Step_Entr();\n    void _Step_Pause_Menu();\n    void _Step_Movie_Select_Menu();\n    void _Step_Room_Select_Menu();\n    void _Step_Main_Menu();\n    void _Step_Init_System();\n\n    void _ModifiNumOfCoint();\n    void _FreeRequestRoomFile(s8 stage_no);\n    void _LoadRequestRoomFile(s8 stage_no);\n    void _iConsoleDraw(s8 pas_cnt);\n    void _iChangeTvMode();\n    void _iSetCaveFog();\n    void _iSetKriboPos();\n    void _iCinemaProjectionProc();\n    void _iSetPlanePos();\n    void _iCineProInit();\n    void _CheckMoveRoom();\n    void _DrawOldStage();\n    void _DispNowLoding();\n    void _FileManager();\n    void _DispSysInfo();\n    void _CheckSubMenu();\n    s8 _DeleteAllStage();\n    void _SetMipMap();\n    void _RoomCameraMoveProc();\n    void _iSetStagePos(s8 stage_no);\n    void _iSetCameraPos(s8 stage_no);\n    void _iSetMarioPosRol(s8 stage_no);\n    void _CursolMove(s8 max, s16 y);\n    void iCheckLoadStatus();\n    void _disp_meter();\n};\n\n\n//Memory allocation functions\nvoid* mAlloc(size_t blocksize);\nvoid mFree(void* block);\n\nvoid operator delete(void* block){\n\tmFree(block);\n}\n\n\n", "diff_flags": [], "diff_label": "normalize__8DTPlayerFP3VecP3Vec", "libraries": []}