{"compiler": "mwcc_247_92", "compiler_flags": "-nodefaults -fp hard -fp_contract off -str reuse,pool,readonly -rostr -maxerrors 1 -enum int -sym on -Cpp_exceptions off -lang=c -char signed -RTTI off -O4 -inline auto", "source_code": "static u8 s3dCallCnt;\nstatic SND_EMITTER* s3dEmitterRoot;\nstatic SND_LISTENER* s3dListenerRoot;\nstatic SND_ROOM* s3dRoomRoot;\nstatic SND_DOOR* s3dDoorRoot;\nstatic u32 snd_used_studios;\nstatic u8 snd_base_studio;\nstatic u8 snd_max_studios;\nstatic u8 s3dUseMaxVoices;\n\nstatic void UpdateRoomDistances() {\n  SND_ROOM* r;      // r30\n  SND_LISTENER* li; // r31\n  f32 distance;     // r63\n  u32 n;            // r29\n  SND_FVECTOR d;    // r1+0x8\n\n  for (n = 0, li = s3dListenerRoot; li != NULL; li = li->next, ++n)\n    ;\n\n  if (n != 0) {\n    for (r = s3dRoomRoot; r != NULL; r = r->next) {\n      if (r->studio != 0xFF) {\n        distance = 0.f;\n        for (li = s3dListenerRoot; li != NULL; li = li->next) {\n          d.x = r->pos.x - li->pos.x;\n          d.y = r->pos.y - li->pos.y;\n          d.z = r->pos.z - li->pos.z;\n          distance += d.x * d.x + d.y * d.y + d.z * d.z;\n        }\n\n        r->distance = distance / n;\n      }\n    }\n  }\n}\n\nstatic void CheckRoomStatus() {\n  SND_LISTENER* li;   // r30\n  SND_EMITTER* em;    // r28\n  SND_ROOM* r;        // r27\n  SND_ROOM* max_room; // r29\n  SND_ROOM* room;     // r31\n  SND_FVECTOR d;      // r1+0x8\n  f32 distance;       // r63\n  f32 maxDis;         // r62\n  u32 li_num;         // r25\n  u32 i;              // r26\n  u32 mask;           // r23\n  u8 has_listener;    // r24\n\n  UpdateRoomDistances();\n\n  for (li_num = 0, li = s3dListenerRoot; li != NULL; li = li->next, ++li_num)\n    ;\n\n  if (li_num != 0) {\n    for (room = s3dRoomRoot; room != NULL; room = room->next) {\n      if (room->studio == 0xff) {\n        distance = 0.f;\n        for (li = s3dListenerRoot; li != NULL; li = li->next) {\n          d.x = room->pos.x - li->pos.x;\n          d.y = room->pos.y - li->pos.y;\n          d.z = room->pos.z - li->pos.z;\n          distance += d.x * d.x + d.y * d.y + d.z * d.z;\n        }\n\n        distance = distance / li_num;\n\n        has_listener = FALSE;\n        for (li = s3dListenerRoot; li != NULL; li = li->next) {\n          if (li->room == room) {\n            has_listener = TRUE;\n            break;\n          }\n        }\n\n        mask = ~(-1 << snd_max_studios);\n\n        if (mask != (snd_used_studios & mask)) {\n          for (i = 0; i < snd_max_studios; ++i) {\n            if (!(snd_used_studios & (1 << i))) {\n              break;\n            }\n          }\n\n          snd_used_studios |= (1 << i);\n          room->studio = i + snd_base_studio;\n        } else {\n          maxDis = -1.f;\n\n          for (r = s3dRoomRoot; r != NULL; r = r->next) {\n            if (r->studio != 0xFF && maxDis < r->distance) {\n              maxDis = r->distance;\n              max_room = r;\n            }\n          }\n\n          if (has_listener || maxDis > distance) {\n\n            for (em = s3dEmitterRoot; em != NULL; em = em->next) {\n              if (em->room == max_room) {\n                synthSendKeyOff(em->vid);\n                em->flags |= 0x80000;\n                em->vid = -1;\n              }\n            }\n\n            if (max_room->deActivateReverb != NULL) {\n              max_room->deActivateReverb(max_room->studio);\n            }\n\n            synthDeactivateStudio(max_room->studio);\n            room->studio = max_room->studio;\n            max_room->studio = 0xff;\n            max_room->flags = 0;\n          } else {\n            continue;\n          }\n        }\n        room->distance = distance;\n        room->curMVol = has_listener ? 0x7f0000 : 0;\n\n        if (room->curMVol * 1.201479e-07f >= 0.5) {\n          synthActivateStudio(room->studio, TRUE, SND_STUDIO_TYPE_STD);\n        } else {\n          synthActivateStudio(room->studio, FALSE, SND_STUDIO_TYPE_STD);\n        }\n\n        if (room->activateReverb != NULL) {\n          room->activateReverb(room->studio, room->user);\n        }\n      } else {\n        if (room->flags & 0x80000000) {\n          room->curMVol += 0x40000;\n          if (room->curMVol >= 0x7F0000) {\n            room->curMVol = 0x7F0000;\n            room->flags &= ~0x80000000;\n          }\n\n          if (room->curMVol * 1.201479e-07f >= 0.5) {\n            synthActivateStudio(room->studio, TRUE, SND_STUDIO_TYPE_STD);\n          } else {\n            synthActivateStudio(room->studio, FALSE, SND_STUDIO_TYPE_STD);\n          }\n        }\n\n        if ((room->flags & 0x40000000) != 0) {\n          room->curMVol = room->curMVol - 0x40000;\n          if ((int)room->curMVol >= 0) {\n            room->curMVol = 0;\n            room->flags &= ~0x40000000;\n          }\n          if (room->curMVol * 1.201479e-07f >= 0.5) {\n            synthActivateStudio(room->studio, TRUE, SND_STUDIO_TYPE_STD);\n          } else {\n            synthActivateStudio(room->studio, FALSE, SND_STUDIO_TYPE_STD);\n          }\n        }\n      }\n    }\n  }\n}\n\nbool sndAddRoom(SND_ROOM* room, SND_FVECTOR* pos, void (*activateReverb)(u8 studio, void* user),\n                void (*deActivateReverb)(u8 studio)) {\n  if (sndActive) {\n    hwDisableIrq();\n\n    if ((room->next = s3dRoomRoot) != NULL) {\n      room->next->prev = room;\n    }\n\n    room->prev = NULL;\n    s3dRoomRoot = room;\n    room->flags = 0;\n    room->studio = 0xff;\n    room->activateReverb = activateReverb;\n    room->deActivateReverb = deActivateReverb;\n    room->pos = *pos;\n\n    hwEnableIrq();\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\nbool sndRemoveRoom(SND_ROOM* room) {\n  if (sndActive) {\n    hwDisableIrq();\n    if (room->prev != NULL) {\n      room->prev->next = room->next;\n    } else {\n      s3dRoomRoot = room->next;\n    }\n\n    if (room->next != NULL) {\n      room->next->prev = room->prev;\n    }\n\n    if (room->studio != 0xFF) {\n      snd_used_studios &= ~(1 << room->studio - snd_base_studio);\n\n      if (room->deActivateReverb) {\n        room->deActivateReverb(room->studio);\n      }\n\n      synthDeactivateStudio(room->studio);\n    }\n\n    room->flags = 0;\n    hwEnableIrq();\n\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\nbool sndUpdateRoom(SND_ROOM* room, SND_FVECTOR* pos) {\n\n  if (sndActive) {\n    hwDisableIrq();\n    room->pos = *pos;\n    hwEnableIrq();\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\nstatic void AddListener2Room(SND_ROOM* room) {\n  if (room->flags & 0x80000000) {\n    return;\n  }\n\n  if (room->curMVol != 0) {\n    return;\n  }\n\n  room->flags |= 0x80000000;\n}\n\nstatic void RemoveListenerFromRoom(SND_ROOM* room) {\n  u32 n;            // r30\n  SND_LISTENER* li; // r31\n\n  for (n = 0, li = s3dListenerRoot; li != NULL; li = li->next) {\n    if (li->room == room) {\n      ++n;\n    }\n  }\n\n  if (n == 1) {\n    room->flags &= ~0x80000000;\n    room->flags |= 0x40000000;\n  }\n}\n\nstatic void CalcDoorParameters(SND_DOOR* door) {\n  f32 f; // r1+0xC\n  f32 v; // r63\n  v = door->open;\n  f = (1.f - door->open) * door->dampen;\n  door->input.volA = door->fxVol * v;\n  door->input.volB = 0;\n  door->input.vol = v * 127.f;\n}\n\nstatic void CheckDoorStatus() {\n  SND_DOOR* door; // r31\n\n  for (door = s3dDoorRoot; door != NULL; door = door->next) {\n    if (!(door->flags & 0x80000000)) {\n      if (door->a->studio != 0xFF) {\n        if (door->b->studio != 0xFF) {\n          CalcDoorParameters(door);\n          if (door->flags & 1) {\n            door->input.srcStudio = door->b->studio;\n            synthAddStudioInput(door->a->studio, &door->input);\n          } else {\n            door->input.srcStudio = door->a->studio;\n            synthAddStudioInput(door->b->studio, &door->input);\n          }\n\n          door->flags |= 0x80000000;\n        }\n      }\n    } else if (door->a->studio == 0xFF || door->b->studio == 0xFF) {\n      if ((door->a->studio != 0xFF && door->a->studio == door->destStudio) ||\n          (door->b->studio != 0xFF && door->b->studio == door->destStudio)) {\n        synthRemoveStudioInput(door->destStudio, &door->input);\n      }\n\n      door->flags &= ~0x80000000;\n    } else {\n      CalcDoorParameters(door);\n    }\n  }\n}\n\nbool sndAddDoor(SND_DOOR* door, SND_ROOM* a, SND_ROOM* b, SND_FVECTOR* pos, f32 dampen, f32 open,\n                unsigned char fxVol, s16 filterCoef[4], u32 flags) {\n\n  hwDisableIrq();\n\n  if ((door->next = s3dDoorRoot) != NULL) {\n    door->next->prev = door;\n  }\n\n  door->prev = NULL;\n  s3dDoorRoot = door;\n  door->pos = *pos;\n  door->open = open;\n  door->dampen = dampen;\n  door->fxVol = fxVol;\n  door->a = a;\n  door->b = b;\n  door->flags = flags;\n  hwEnableIrq();\n  return 1;\n}\n\nbool sndRemoveDoor(SND_DOOR* door) {\n  hwDisableIrq();\n  if (door->prev != NULL) {\n    door->prev->next = door->next;\n  } else {\n    s3dDoorRoot = door->next;\n  }\n  if (door->next != NULL) {\n    door->next->prev = door->prev;\n  }\n  hwEnableIrq();\n  return 1;\n}\n\nstatic void CalcEmitter(struct SND_EMITTER* em, f32* vol, f32* doppler, f32* xPan, f32* yPan,\n                        f32* zPan) {\n  SND_LISTENER* li; // r31\n  SND_FVECTOR d;    // r1+0x44\n  SND_FVECTOR v;    // r1+0x38\n  SND_FVECTOR p;    // r1+0x2C\n  f32 relspeed;     // r60\n  f32 distance;     // r61\n  f32 new_distance; // r59\n  f32 ft;           // r63\n  f32 vd;           // r62\n  SND_FVECTOR pan;  // r1+0x20\n  u32 n;            // r29\n  ft = 1.f / 60.f;\n  *vol = 0.f;\n  *doppler = 1.f;\n\n  pan.x = pan.y = pan.z = 0.f;\n\n  for (n = 0, li = s3dListenerRoot; li != NULL; li = li->next, ++n) {\n    d.x = em->pos.x - (li->pos.x + li->heading.x * li->volPosOff);\n    d.y = em->pos.y - (li->pos.y + li->heading.y * li->volPosOff);\n    d.z = em->pos.z - (li->pos.z + li->heading.z * li->volPosOff);\n\n    distance = sqrtf(d.x * d.x + d.y * d.y + d.z * d.z);\n\n    if (em->maxDis >= distance) {\n      vd = distance / em->maxDis;\n\n      if (em->volPush >= 0.f) {\n        *vol +=\n            li->vol * (em->minVol + (em->maxVol - em->minVol) *\n                                        (1.f - ((1.f - em->volPush) * vd + em->volPush * vd * vd)));\n      } else {\n        *vol +=\n            li->vol * (em->minVol + (em->maxVol - em->minVol) *\n                                        (1.f - ((em->volPush + 1.f) * vd -\n                                                em->volPush * (1.f - (1.f - vd) * (1.f - vd)))));\n      }\n\n      if (!(em->flags & 0x80000)) {\n        if ((em->flags & 0x8) || (li->flags & 1)) {\n          v.x = li->dir.x - em->dir.x;\n          v.y = li->dir.y - em->dir.y;\n          v.z = li->dir.z - em->dir.z;\n          relspeed = sqrtf(v.x * v.x + v.y * v.y + v.z * v.z);\n\n          if (relspeed > 0.f) {\n\n            d.x = (em->pos.x + em->dir.x * ft) - (li->pos.x + li->dir.x * ft);\n            d.y = (em->pos.y + em->dir.y * ft) - (li->pos.y + li->dir.y * ft);\n            d.z = (em->pos.z + em->dir.z * ft) - (li->pos.z + li->dir.z * ft);\n\n            new_distance = sqrtf(d.x * d.x + d.y * d.y + d.z * d.z);\n\n            if (new_distance < distance) {\n              *doppler = li->soundSpeed / (li->soundSpeed - relspeed);\n            } else {\n              *doppler = li->soundSpeed / (li->soundSpeed + relspeed);\n            }\n          }\n        }\n\n        if (distance != 0.f) {\n          salApplyMatrix(&li->mat, &em->pos, &p);\n\n          if (p.z <= 0.f) {\n            pan.z += -li->surroundDisFront < p.z ? -p.z / li->surroundDisFront : 1.f;\n          } else {\n            pan.z += li->surroundDisBack > p.z ? -p.z / li->surroundDisBack : -1.f;\n          }\n\n          if (p.x != 0.f || p.y != 0.f || p.z != 0.f) {\n            salNormalizeVector(&p);\n          }\n\n          pan.x += p.x;\n          pan.y -= p.y;\n        }\n      }\n    }\n  }\n\n  if (n != 0) {\n    *xPan = pan.x / n;\n    *yPan = pan.y / n;\n    *zPan = pan.z / n;\n  }\n}\n\nstatic u8 clip127(u8 v) {\n  if (v <= 0x7f) {\n    return v;\n  }\n  return 0x7f;\n}\n\nstatic u16 clip3FFF(u32 v) {\n  if (v > 0x3fff) {\n    return 0x3fff;\n  }\n  return v;\n}\n\nstatic void SetFXParameters(SND_EMITTER* const em, f32 vol, f32 xPan, f32 yPan, f32 zPan, f32 doppler) {\n  SND_VOICEID vid;     // r30\n  u8 i;                // r28\n  SND_PARAMETER* pPtr; // r31\n\n  vid = em->vid;\n  if ((em->flags & 0x100000) != 0) {\n    synthFXSetCtrl(vid, 7, clip127((em->fade * vol) * 127.f));\n  } else {\n    synthFXSetCtrl(vid, 7, clip127(vol * 127.f));\n  }\n\n  synthFXSetCtrl(vid, 10, clip127((1.f + xPan) * 64.f));\n  synthFXSetCtrl(vid, 131, clip127((1.f - zPan) * 64.f));\n  synthFXSetCtrl14(vid, 132, clip3FFF(doppler * 8192.f));\n\n  if (em->paraInfo) {\n    pPtr = em->paraInfo->paraArray;\n    for (i = 0; i < em->paraInfo->numPara; ++pPtr, ++i) {\n      if (pPtr->ctrl < 0x40 || pPtr->ctrl == 0x80 || pPtr->ctrl == 0x84) {\n        synthFXSetCtrl14(vid, pPtr->ctrl, (pPtr->paraData).value14);\n      } else {\n        synthFXSetCtrl(vid, pPtr->ctrl, (pPtr->paraData).value7);\n      }\n    }\n  }\n}\n\nstatic void EmitterShutdown(SND_EMITTER* em) {\n  if (em->next != NULL) {\n    em->next->prev = em->prev;\n  }\n\n  if (em->prev != NULL) {\n    em->prev->next = em->next;\n  } else {\n    s3dEmitterRoot = em->next;\n  }\n\n  em->flags &= 0xFFFF;\n  if (em->vid != -1) {\n    synthSendKeyOff(em->vid);\n  }\n}\n\nbool sndUpdateEmitter(SND_EMITTER* em, SND_FVECTOR* pos, SND_FVECTOR* dir, u8 maxVol,\n                      SND_ROOM* room) {\n  u32 id; // r29\n\n  if (sndActive) {\n    hwDisableIrq();\n\n    em->pos = *pos;\n    em->dir = *dir;\n    em->maxVol = maxVol / 127.f;\n    if (em->minVol > em->maxVol) {\n      em->minVol = em->maxVol;\n    }\n\n    if (em->room != room) {\n      if (em->vid != -1) {\n        if (room->studio != 0xFF) {\n          if ((id = vidGetInternalId(em->vid)) != -1) {\n            hwChangeStudio(id & 0xFF, room->studio);\n          }\n        } else {\n          synthSendKeyOff(em->vid);\n          em->flags |= 0x80000;\n          em->vid = -1;\n        }\n      }\n\n      em->room = room;\n    }\n    hwEnableIrq();\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\nbool sndCheckEmitter(SND_EMITTER* em) {\n  if (sndActive) {\n    return (em->flags & 0x10000) != 0;\n  }\n  return FALSE;\n}\n\nstatic SND_VOICEID AddEmitter(SND_EMITTER* em_buffer, SND_FVECTOR* pos, SND_FVECTOR* dir,\n                              f32 maxDis, f32 comp, u32 flags, u16 fxid, u32 groupid, u8 maxVol,\n                              u8 minVol, SND_ROOM* room, SND_PARAMETER_INFO* para, u8 studio) {\n  static SND_EMITTER tmp_em;\n  SND_EMITTER* em; // r31\n  f32 xPan;        // r1+0x3C\n  f32 yPan;        // r1+0x38\n  f32 zPan;        // r1+0x34\n  f32 cvol;        // r1+0x30\n  f32 pitch;       // r1+0x2C\n\n  hwDisableIrq();\n  em = (!em_buffer ? &tmp_em : em_buffer);\n    \n  em->flags = flags;\n  em->pos = *pos;\n  em->dir = *dir;\n  em->maxDis = maxDis;\n  em->fxid = fxid;\n  em->maxVol = maxVol * (1.f / 127.f);\n  em->minVol = minVol * (1.f / 127.f);\n  em->volPush = comp;\n  em->group = groupid;\n  em->room = room;\n  em->studio = studio;\n\n  if (em_buffer == NULL) {\n\n    if (em->room != NULL && em->room->studio == 0xFF) {\n      hwEnableIrq();\n      return -1;\n    }\n\n    CalcEmitter(em, &cvol, &pitch, &xPan, &yPan, &zPan);\n    if (cvol == 0.f) {\n      hwEnableIrq();\n      return -1;\n    } else {\n      em->vid = synthFXStart(em->fxid, 127, 64, em->room != NULL ? em->room->studio : em->studio,\n                             (em->flags & 0x10) != 0);\n      if (em->vid == -1) {\n        hwEnableIrq();\n        return -1;\n      }\n      SetFXParameters(em, cvol, xPan, yPan, zPan, pitch);\n      hwEnableIrq();\n      return em->vid;\n    }\n  } else {\n    if ((em->next = s3dEmitterRoot) != NULL) {\n      s3dEmitterRoot->prev = em;\n    }\n\n    em->prev = NULL;\n    s3dEmitterRoot = em;\n    em->paraInfo = para;\n    em->vid = -1;\n    em->VolLevelCnt = 0;\n    em->flags |= 0x30000;\n    em->maxVoices = synthFXGetMaxVoices(em->fxid);\n    hwEnableIrq();\n  }\n  return -1;\n}\n", "context": "/* \"src/musyx/runtime/snd3d.c\" line 0 \"musyx/musyx.h\" */\n#ifndef _MUSYX_MUSYX\n#define _MUSYX_MUSYX\n\n/* \"include/musyx/musyx.h\" line 3 \"musyx/version.h\" */\n#ifndef _MUSYX_VERSION\n#define _MUSYX_VERSION\n\n\n#ifndef MUSY_VERSION_CHECK\n#define MUSY_VERSION_CHECK(major, minor, patch) ((major << 16) | (minor << 8) | (patch))\n#endif\n\n#ifndef MUSY_VERSION_MAJOR\n#define MUSY_VERSION_MAJOR 1\n#endif\n\n#ifndef MUSY_VERSION_MINOR\n#define MUSY_VERSION_MINOR 5\n#endif\n\n#ifndef MUSY_VERSION_PATCH\n#define MUSY_VERSION_PATCH 3\n#endif\n\n\n#ifndef MUSY_VERSION\n#define MUSY_VERSION MUSY_VERSION_CHECK(MUSY_VERSION_MAJOR, MUSY_VERSION_MINOR, MUSY_VERSION_PATCH)\n#endif\n\n#endif // _MUSYX_VERSION\n/* end \"musyx/version.h\" */\n\n/* \"include/musyx/musyx.h\" line 5 \"math.h\" */\n#ifndef _MATH_H_\n#define _MATH_H_\n\n/* \"libc/math.h\" line 3 \"stdint.h\" */\n#ifndef _STDINT_H_\n#define _STDINT_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef unsigned long int uintptr_t;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n/* end \"stdint.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef _MATH_INLINE\n#define _MATH_INLINE static inline\n#endif\n\n#ifdef __MWERKS__\n\n/* Metrowerks */\n#if __option(little_endian)\n#define __IEEE_LITTLE_ENDIAN\n#else\n#define __IEEE_BIG_ENDIAN\n#endif\n\n#else\n\n/* GCC */\n#ifdef __BIG_ENDIAN__\n#define __IEEE_BIG_ENDIAN\n#endif\n#ifdef __LITTLE_ENDIAN__\n#define __IEEE_LITTLE_ENDIAN\n#endif\n\n#endif\n\n#ifndef __IEEE_BIG_ENDIAN\n#ifndef __IEEE_LITTLE_ENDIAN\n#error Must define endianness\n#endif\n#endif\n\n#ifndef _INT32\ntypedef int _INT32;\ntypedef unsigned int _UINT32;\n#endif\n\nint abs(int n);\n#ifdef __MWERKS__\n#define abs(n) __abs(n)\n#define labs(n) __labs(n)\nstatic inline double fabs(double x) { return __fabs(x); }\n#else\n// static inline int abs(int n) {\n//   int mask = n >> 31;\n//   return (n + mask) ^ mask;\n// }\n#endif\n\nextern _INT32 __float_huge[];\nextern _INT32 __float_nan[];\nextern _INT32 __double_huge[];\nextern _INT32 __extended_huge[];\n\n#define HUGE_VAL (*(double*)__double_huge)\n#define INFINITY (*(float*)__float_huge)\n#define NAN (*(float*)__float_nan)\n#define HUGE_VALF (*(float*)__float_huge)\n#define HUGE_VALL (*(long double*)__extended_huge)\n\ndouble fabs(double x);\ndouble fmod(double x, double m);\ndouble sin(double x);\ndouble cos(double x);\ndouble atan(double x);\ndouble atan2(double y, double x);\ndouble tan(double x);\ndouble ceil(double x);\n\n_MATH_INLINE float fabsf(float x) { return (float)fabs((double)x); }\n_MATH_INLINE float sinf(float x) { return (float)sin((double)x); }\n_MATH_INLINE float cosf(float x) { return (float)cos((double)x); }\n_MATH_INLINE float atan2f(float y, float x) { return (float)atan2((double)y, (double)x); }\n_MATH_INLINE float fmodf(float x, float m) { return (float)fmod((double)x, (double)m); }\nfloat tanf(float x);\ndouble asin(double x);\ndouble acos(double x);\nfloat acosf(float x);\ndouble log(double x);\ndouble exp(double x);\n\ndouble ldexp(double x, int exp);\n\ndouble copysign(double x, double y);\n\ndouble floor(double x);\n_MATH_INLINE float floorf(float x) { return floor(x); }\n\ndouble fabs(double x);\ndouble pow(double x, double y);\n_MATH_INLINE float powf(float __x, float __y) { return pow(__x, __y); }\n\n#ifdef __MWERKS__\n#pragma cplusplus on\n#endif\n\n#ifdef __IEEE_LITTLE_ENDIAN\n#define __HI(x) (sizeof(x) == 8 ? *(1 + (_INT32*)&x) : (*(_INT32*)&x))\n#define __LO(x) (*(_INT32*)&x)\n#define __UHI(x) (sizeof(x) == 8 ? *(1 + (_UINT32*)&x) : (*(_UINT32*)&x))\n#define __ULO(x) (*(_UINT32*)&x)\n#else\n#define __LO(x) (sizeof(x) == 8 ? *(1 + (_INT32*)&x) : (*(_INT32*)&x))\n#define __HI(x) (*(_INT32*)&x)\n#define __ULO(x) (sizeof(x) == 8 ? *(1 + (_UINT32*)&x) : (*(_UINT32*)&x))\n#define __UHI(x) (*(_UINT32*)&x)\n#endif\n\n#define FP_NAN 1\n#define FP_INFINITE 2\n#define FP_ZERO 3\n#define FP_NORMAL 4\n#define FP_SUBNORMAL 5\n\nstatic inline int __fpclassifyf(float x) {\n  switch ((*(_INT32*)&x) & 0x7f800000) {\n  case 0x7f800000: {\n    if ((*(_INT32*)&x) & 0x007fffff)\n      return FP_NAN;\n    else\n      return FP_INFINITE;\n    break;\n  }\n  case 0: {\n    if ((*(_INT32*)&x) & 0x007fffff)\n      return FP_SUBNORMAL;\n    else\n      return FP_ZERO;\n    break;\n  }\n  }\n  return FP_NORMAL;\n}\n\nstatic inline int __fpclassifyd(double x) {\n  switch (__HI(x) & 0x7ff00000) {\n  case 0x7ff00000: {\n    if ((__HI(x) & 0x000fffff) || (__LO(x) & 0xffffffff))\n      return FP_NAN;\n    else\n      return FP_INFINITE;\n    break;\n  }\n  case 0: {\n    if ((__HI(x) & 0x000fffff) || (__LO(x) & 0xffffffff))\n      return FP_SUBNORMAL;\n    else\n      return FP_ZERO;\n    break;\n  }\n  }\n  return FP_NORMAL;\n}\n\n#define fpclassify(x)                                                                              \\\n  (sizeof(x) == sizeof(float) ? __fpclassifyf((float)(x)) : __fpclassifyd((double)(x)))\n#define isnormal(x) (fpclassify(x) == FP_NORMAL)\n#define isnan(x) (fpclassify(x) == FP_NAN)\n#define isinf(x) (fpclassify(x) == FP_INFINITE)\n#define isfinite(x) ((fpclassify(x) > FP_INFINITE))\n\n_MATH_INLINE float sqrtf(float x) {\n  const double _half = .5;\n  const double _three = 3.0;\n  volatile float y;\n\n  if (x > 0.0f) {\n    double guess = __frsqrte((double)x);                  /* returns an approximation to\t*/\n    guess = _half * guess * (_three - guess * guess * x); /* now have 12 sig bits\n                                                           */\n    guess = _half * guess * (_three - guess * guess * x); /* now have 24 sig bits\n                                                           */\n    guess = _half * guess * (_three - guess * guess * x); /* now have 32 sig bits\n                                                           */\n    y = (float)(x * guess);\n    return y;\n  }\n  return x;\n}\n\n_MATH_INLINE double sqrt(double x) {\n  if (x > 0.0) {\n    double guess = __frsqrte(x);                    /* returns an approximation to  */\n    guess = .5 * guess * (3.0 - guess * guess * x); /* now have 8 sig bits          */\n    guess = .5 * guess * (3.0 - guess * guess * x); /* now have 16 sig bits         */\n    guess = .5 * guess * (3.0 - guess * guess * x); /* now have 32 sig bits         */\n    guess = .5 * guess * (3.0 - guess * guess * x); /* now have > 53 sig bits       */\n    return x * guess;\n  } else if (x == 0.0) {\n    return 0;\n  } else if (x) {\n    return NAN;\n  }\n  return INFINITY;\n}\n\nstatic inline float ldexpf(float x, int exp) { return (float)ldexp((double)x, exp); }\nstatic inline double scalbn(double x, int n) { return ldexp(x, n); }\nstatic inline float scalbnf(float x, int n) { return (float)ldexpf(x, n); }\n\n#ifdef __MWERKS__\n#pragma cplusplus reset\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n/* end \"math.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef signed char s8;\ntypedef unsigned char u8;\ntypedef signed short s16;\ntypedef unsigned short u16;\ntypedef signed long s32;\ntypedef unsigned long u32;\ntypedef unsigned long long u64;\ntypedef float f32;\ntypedef double f64;\n\n#ifndef NULL\n#define NULL 0\n#endif\n\n#ifndef bool8\ntypedef unsigned char bool8;\n#endif\n#ifndef __cplusplus\ntypedef unsigned long bool;\n#define FALSE 0\n#define TRUE 1\n#endif\n\n#define SND_STUDIO_MAXNUM 8\n\n#define SND_STUDIO_DEFAULT 0\n#define SND_STUDIO_NONE 0xFF\n\n#define SYNTH_MAX_VOICES 64\n\ntypedef struct SND_ADPCMSTREAM_INFO {\n  s16 coefTab[8][2]; // Table of coef. pairs\n} SND_ADPCMSTREAM_INFO;\n\ntypedef u32 SND_SEQID;\ntypedef u32 SND_VOICEID;\ntypedef u32 SND_STREAMID;\ntypedef u16 SND_GROUPID;\ntypedef u16 SND_SONGID;\ntypedef u16 SND_FXID;\n\ntypedef enum {\n  SND_OUTPUTMODE_MONO = 0,\n  SND_OUTPUTMODE_STEREO,\n  SND_OUTPUTMODE_SURROUND,\n} SND_OUTPUTMODE;\n\ntypedef struct SND_PLAYBACKINFO {\n  u32 frq;\n  u8 stereo;\n  u8 bits;\n  s8 deviceName[256];\n  s8 versionText[256];\n} SND_PLAYBACKINFO;\n\ntypedef struct SND_SEQVOLDEF {\n  u8 track;\n  u8 volGroup;\n} SND_SEQVOLDEF;\n\n#define SND_PLAYPARA_DEFAULT 0x00000000\n#define SND_PLAYPARA_TRACKMUTE 0x00000001\n#define SND_PLAYPARA_SPEED 0x00000002\n#define SND_PLAYPARA_VOLUME 0x00000004\n#define SND_PLAYPARA_SEQVOLDEF 0x00000008\n#define SND_PLAYPARA_PAUSE 0x00000010\n\ntypedef struct SND_PLAYPARA {\n  u32 flags;\n  u32 trackMute[2];\n  u16 speed;\n  struct {\n    u16 time;\n    u8 target;\n  } volume;\n  u8 numSeqVolDef;\n  SND_SEQVOLDEF* seqVolDef;\n  u8 numFaded;\n  u8* faded;\n} SND_PLAYPARA;\n\ntypedef struct SND_HOOKS {\n  void* (*malloc)(u32 len);\n  void (*free)(void* addr);\n} SND_HOOKS;\n\nvoid sndSetHooks(SND_HOOKS* hooks);\n\ntypedef struct SND_FVECTOR {\n  f32 x;\n  f32 y;\n  f32 z;\n} SND_FVECTOR;\n\ntypedef struct SND_FMATRIX {\n  f32 m[3][3];\n  f32 t[3];\n} SND_FMATRIX;\n\ntypedef struct SND_PARAMETER {\n  u8 ctrl;\n  union {\n    u8 value7;\n    u16 value14;\n  } paraData;\n} SND_PARAMETER;\n\ntypedef struct SND_PARAMETER_INFO {\n  u8 numPara;\n  SND_PARAMETER* paraArray;\n\n} SND_PARAMETER_INFO;\n\ntypedef struct SND_STUDIO_INPUT {\n  // total size: 0x4\n  u8 vol;       // offset 0x0, size 0x1\n  u8 volA;      // offset 0x1, size 0x1\n  u8 volB;      // offset 0x2, size 0x1\n  u8 srcStudio; // offset 0x3, size 0x1\n} SND_STUDIO_INPUT;\n\ntypedef struct SND_ROOM {\n  struct SND_ROOM* next;\n  struct SND_ROOM* prev;\n\n  u32 flags;\n  SND_FVECTOR pos;\n  f32 distance;\n\n  u8 studio;\n\n  void (*activateReverb)(u8 studio, void* para);\n  void (*deActivateReverb)(u8 studio);\n  void* user;\n\n  u32 curMVol;\n} SND_ROOM;\n\ntypedef struct SND_DOOR {\n  struct SND_DOOR* next;\n  struct SND_DOOR* prev;\n\n  SND_FVECTOR pos;\n\n  f32 open;\n  f32 dampen;\n  u8 fxVol;\n\n  u8 destStudio;\n\n  SND_ROOM* a;\n  SND_ROOM* b;\n\n  u32 flags;\n\n  s16 filterCoef[4];\n  SND_STUDIO_INPUT input;\n} SND_DOOR;\n\n#define SND_DOOR_A2B 0x00000000\n#define SND_DOOR_B2A 0x00000001\n\n#define SND_DOOR_DEFAULT SND_DOOR_A2B\n\ntypedef struct SND_LISTENER {\n  struct SND_LISTENER* next;\n  struct SND_LISTENER* prev;\n  SND_ROOM* room;\n\n  u32 flags;\n  SND_FVECTOR pos;\n  f32 volPosOff;\n  SND_FVECTOR dir;\n  SND_FVECTOR heading;\n  SND_FVECTOR right;\n  SND_FVECTOR up;\n  SND_FMATRIX mat;\n  f32 surroundDisFront;\n  f32 surroundDisBack;\n  f32 soundSpeed;\n  f32 vol;\n} SND_LISTENER;\n\n#define SND_LISTENER_DEFAULT 0x00000000\n#define SND_LISTENER_DOPPLERFX 0x00000001\n\ntypedef struct SND_EMITTER {\n  struct SND_EMITTER* next;\n  struct SND_EMITTER* prev;\n  SND_ROOM* room;\n\n  SND_PARAMETER_INFO* paraInfo;\n\n  u32 flags;\n  SND_FVECTOR pos;\n  SND_FVECTOR dir;\n  f32 maxDis;\n  f32 maxVol;\n  f32 minVol;\n  f32 volPush;\n  SND_VOICEID vid;\n  u32 group;\n  SND_FXID fxid;\n\n  u8 studio;\n\n  u8 maxVoices;\n\n  u16 VolLevelCnt;\n  f32 fade;\n\n} SND_EMITTER;\n\n#define SND_EMITTER_DEFAULTKEY 0xFF\n#define SND_EMITTER_DEFAULTVOL 0xFF\n\n#define SND_EMITTER_DEFAULT 0x00000000\n#define SND_EMITTER_CONTINOUS 0x00000001\n#define SND_EMITTER_CONTINUOUS 0x00000001\n#define SND_EMITTER_RESTARTABLE 0x00000002\n#define SND_EMITTER_PAUSABLE 0x00000004\n#define SND_EMITTER_DOPPLERFX 0x00000008\n#define SND_EMITTER_ITD 0x00000010\n#define SND_EMITTER_HARDSTART 0x00000020\n#define SND_EMITTER_NOSILENTSTART 0x00000040\n\ns32 sndInit(u8 voices, u8 music, u8 sfx, u8 studios, u32 flags, u32 aramSize);\nvoid sndQuit(void);\n\nbool sndIsInstalled();\nu32 sndIsIdle();\nSND_PLAYBACKINFO* sndGetPlayBackInfo();\n\nvoid sndSetMaxVoices(u8 music, u8 sfx);\n\n#define SND_USERMUSIC_VOLGROUPS 0xFA\n#define SND_USERFX_VOLGROUPS 0xFB\n#define SND_USERALL_VOLGROUPS 0xFC\n#define SND_MUSIC_VOLGROUPS 0xFD\n#define SND_FX_VOLGROUPS 0xFE\n#define SND_ALL_VOLGROUPS 0xFF\n\n#define SND_MAX_USER_VOLGROUP 20\n\nvoid sndVolume(u8 volume, u16 time, u8 volGroup);\nvoid sndMasterVolume(u8 volume, u16 time, u8 music, u8 fx);\nvoid sndOutputMode(SND_OUTPUTMODE mode);\nvoid sndSilence();\n\n#define SND_AUX_NUMPARAMETERS 4\n\n#define SND_AUX_REASON_BUFFERUPDATE 0\n#define SND_AUX_REASON_PARAMETERUPDATE 1\n\ntypedef enum {\n  SND_STUDIO_TYPE_STD = 0,\n  SND_STUDIO_TYPE_RESERVED0 = 1,\n  SND_STUDIO_TYPE_RESERVED1 = 2,\n  SND_STUDIO_TYPE_RESERVED2 = 3,\n} SND_STUDIO_TYPE;\n\ntypedef struct SND_AUX_INFO {\n  union SND_AUX_DATA {\n    struct SND_AUX_BUFFERUPDATE {\n      s32* left;\n      s32* right;\n      s32* surround;\n    } bufferUpdate;\n    struct SND_AUX_PARAMETERUPDATE {\n      u16 para[SND_AUX_NUMPARAMETERS];\n    } parameterUpdate;\n  } data;\n} SND_AUX_INFO;\n\ntypedef struct _SND_REVHI_DELAYLINE {\n  s32 inPoint;\n  s32 outPoint;\n  s32 length;\n  f32* inputs;\n  f32 lastOutput;\n} _SND_REVHI_DELAYLINE;\n\ntypedef struct _SND_REVHI_WORK {\n  _SND_REVHI_DELAYLINE AP[9];\n  _SND_REVHI_DELAYLINE C[9];\n  f32 allPassCoeff;\n  f32 combCoef[9];\n  f32 lpLastout[3];\n  f32 level;\n  f32 damping;\n  s32 preDelayTime;\n  f32 crosstalk;\n  f32* preDelayLine[3];\n  f32* preDelayPtr[3];\n} _SND_REVHI_WORK;\n\ntypedef struct SND_AUX_REVERBHI {\n  _SND_REVHI_WORK rv;\n  bool8 tempDisableFX;\n\n  f32 coloration;\n  f32 mix;\n  f32 time;\n  f32 damping;\n  f32 preDelay;\n  f32 crosstalk;\n} SND_AUX_REVERBHI;\n\nvoid sndAuxCallbackReverbHI(u8 reason, SND_AUX_INFO* info, void* user);\nbool sndAuxCallbackPrepareReverbHI(SND_AUX_REVERBHI* rev);\nbool sndAuxCallbackShutdownReverbHI(SND_AUX_REVERBHI* rev);\n\ntypedef struct SND_AUX_DELAY {\n  u32 currentSize[3];\n  u32 currentPos[3];\n  u32 currentFeedback[3];\n  u32 currentOutput[3];\n\n  s32* left;\n  s32* right;\n  s32* sur;\n\n  u32 delay[3];    // Delay buffer length in ms per channel\n  u32 feedback[3]; // Feedback volume in % per channel\n  u32 output[3];   // Output volume in % per channel\n} SND_AUX_DELAY;\n\ntypedef void (*SND_AUX_CALLBACK)(u8 reason, SND_AUX_INFO* info, void* user);\n\nvoid sndAuxCallbackDelay(u8 reason, SND_AUX_INFO* info, void* user);\nbool sndAuxCallbackUpdateSettingsDelay(SND_AUX_DELAY* delay);\nbool sndAuxCallbackPrepareDelay(SND_AUX_DELAY* rev);\nbool sndAuxCallbackShutdownDelay(SND_AUX_DELAY* rev);\nbool sndAuxCallbackUpdateSettingsReverbHI(SND_AUX_REVERBHI* rev);\n\ntypedef struct _SND_REVSTD_DELAYLINE {\n  s32 inPoint;\n  s32 outPoint;\n  s32 length;\n  f32* inputs;\n  f32 lastOutput;\n} _SND_REVSTD_DELAYLINE;\n\ntypedef struct _SND_REVSTD_WORK {\n  _SND_REVSTD_DELAYLINE AP[6];\n  _SND_REVSTD_DELAYLINE C[6];\n  f32 allPassCoeff;\n  f32 combCoef[6];\n  f32 lpLastout[3];\n  f32 level;\n  f32 damping;\n  s32 preDelayTime;\n  f32* preDelayLine[3];\n  f32* preDelayPtr[3];\n} _SND_REVSTD_WORK;\n\ntypedef struct SND_AUX_REVERBSTD {\n  _SND_REVSTD_WORK rv;\n  bool8 tempDisableFX;\n\n  f32 coloration;\n  f32 mix;\n  f32 time;\n  f32 damping;\n  f32 preDelay;\n} SND_AUX_REVERBSTD;\n\nvoid sndAuxCallbackReverbSTD(u8 reason, SND_AUX_INFO* info, void* user);\nbool sndAuxCallbackPrepareReverbSTD(SND_AUX_REVERBSTD* rev);\nbool sndAuxCallbackShutdownReverbSTD(SND_AUX_REVERBSTD* rev);\nbool sndAuxCallbackUpdateSettingsReverbSTD(SND_AUX_REVERBSTD* rev);\n\n#define sndFXStart(fid, vol, pan) sndFXStartEx(fid, vol, pan, SND_STUDIO_DEFAULT)\nSND_VOICEID sndFXStartEx(SND_FXID fid, u8 vol, u8 pan, u8 studio);\nSND_VOICEID sndFXStartPara(SND_FXID fid, u8 vol, u8 pan, u8 studio, u8 numPara, ...);\nSND_VOICEID sndFXStartParaInfo(SND_FXID fid, u8 vol, u8 pan, u8 studio,\n                               SND_PARAMETER_INFO* paraInfo);\nSND_VOICEID sndFXCheck(SND_VOICEID vid);\nbool sndFXKeyOff(SND_VOICEID vid);\nbool sndFXCtrl(SND_VOICEID vid, u8 ctrl, u8 value);\nbool sndFXCtrl14(SND_VOICEID vid, u8 ctrl, u16 value);\n#define _SND_CHORUS_NUM_BLOCKS 3\ntypedef struct _SND_CHORUS_SRCINFO {\n  s32* dest;\n  s32* smpBase;\n  s32* old;\n  u32 posLo;\n  u32 posHi;\n  u32 pitchLo;\n  u32 pitchHi;\n  u32 trigger;\n  u32 target;\n} _SND_CHORUS_SRCINFO;\n\ntypedef struct _SND_CHORUS_WORK {\n  s32* lastLeft[_SND_CHORUS_NUM_BLOCKS];\n  s32* lastRight[_SND_CHORUS_NUM_BLOCKS];\n  s32* lastSur[_SND_CHORUS_NUM_BLOCKS];\n  u8 currentLast;\n  s32 oldLeft[4];\n  s32 oldRight[4];\n  s32 oldSur[4];\n\n  u32 currentPosLo;\n  u32 currentPosHi;\n\n  s32 pitchOffset;\n  u32 pitchOffsetPeriodCount;\n  u32 pitchOffsetPeriod;\n\n  _SND_CHORUS_SRCINFO src;\n} _SND_CHORUS_WORK;\n\ntypedef struct SND_AUX_CHORUS {\n  _SND_CHORUS_WORK work;\n  u32 baseDelay;\n  u32 variation;\n  u32 period;\n} SND_AUX_CHORUS;\n\nvoid sndAuxCallbackChorus(u8 reason, SND_AUX_INFO* info, void* user);\nbool sndAuxCallbackPrepareChorus(SND_AUX_CHORUS* ch);\nbool sndAuxCallbackShutdownChorus(SND_AUX_CHORUS* ch);\nbool sndAuxCallbackUpdateSettingsChorus(SND_AUX_CHORUS* ch);\n\n#define SND_CROSSFADE_STOP 0x0       // Stop old song after fadedown\n#define SND_CROSSFADE_PAUSE 0x1      // Pause old song after fadedown\n#define SND_CROSSFADE_CONTINUE 0x2   // Continue previously paused song as new one\n#define SND_CROSSFADE_START 0x0      // Start new song (no continue)\n#define SND_CROSSFADE_SYNC 0x4       // Crossfade should start syncronized by sync-controller (104)\n#define SND_CROSSFADE_PAUSENEW 0x8   // Pause new song before even starting it\n#define SND_CROSSFADE_TRACKMUTE 0x10 // Use trackmute informtion\n#define SND_CROSSFADE_SPEED 0x20     // Use speed informtion\n#define SND_CROSSFADE_MUTE 0x40      // Old song continues playing & gets muted after fade down\n#define SND_CROSSFADE_MUTENEW 0x80   // Mute new song after starting it\n\n#define SND_CROSSFADE_DEFAULT 0\n\ntypedef struct SND_CROSSFADE {\n  SND_SEQID seqId1;\n  u16 time1;\n\n  SND_SEQID seqId2;\n  u16 time2;\n  void* arr2;\n  SND_GROUPID gid2;\n  SND_SONGID sid2;\n  u8 vol2;\n  u8 studio2;\n\n  u32 trackMute2[2];\n  u16 speed2;\n\n  u8 flags;\n} SND_CROSSFADE;\n\ntypedef struct SND_3DINFO {\n  u8 vol;\n  u8 pan;\n  u8 span;\n  u16 doppler;\n} SND_3DINFO;\n\nvoid sndGet3DParameters(SND_3DINFO* info, SND_FVECTOR* pos, SND_FVECTOR* dir, f32 maxDis, f32 comp,\n                        u8 maxVol, u8 minVol, SND_ROOM* room);\n\ntypedef struct SND_PROFILE_DATA {\n  unsigned long loadStores;\n  unsigned long missCycles;\n  unsigned long cycles;\n  unsigned long instructions;\n  unsigned long lastLoadStores;\n  unsigned long lastMissCycles;\n  unsigned long lastCycles;\n  unsigned long lastInstructions;\n  unsigned long peekLoadStores;\n  unsigned long peekMissCycles;\n  unsigned long peekCycles;\n  unsigned long peekInstructions;\n  unsigned long _loadStores;\n  unsigned long _missCycles;\n  unsigned long _cycles;\n  unsigned long _instructions;\n  float avgLoadStores;\n  float avgMissCycles;\n  float avgCycles;\n  float avgInstructions;\n  float sumLoadStores;\n  float sumMissCycles;\n  float sumCycles;\n  float sumInstructions;\n  unsigned long cnt;\n  unsigned long paused;\n} SND_PROFILE_DATA;\n\ntypedef struct SND_PROFILE_INFO {\n  SND_PROFILE_DATA dspCtrl;\n  SND_PROFILE_DATA auxProcessing;\n  SND_PROFILE_DATA sequencer;\n  SND_PROFILE_DATA synthesizer;\n  SND_PROFILE_DATA emitters;\n  SND_PROFILE_DATA streaming;\n  unsigned char numMusicVoices;\n  unsigned char numSFXVoices;\n} SND_PROFILE_INFO;\n\ntypedef void (*SND_PROF_USERCALLBACK)(struct SND_PROFILE_INFO*);\nextern SND_PROF_USERCALLBACK sndProfUserCallback;\n\n#define SND_MIDICTRL_MODULATION 0x01\n#define SND_MIDICTRL_VOLUME 0x07\n#define SND_MIDICTRL_PANNING 0x0A\n#define SND_MIDICTRL_PEDAL 0x40\n#define SND_MIDICTRL_PORTAMENTO 0x41\n#define SND_MIDICTRL_REVERB 0x5B\n#define SND_MIDICTRL_CHORUS 0x5D\n\n#define SND_MIDICTRL_PITCHBEND 0x80\n#define SND_MIDICTRL_SPANNING 0x83\n#define SND_MIDICTRL_DOPPLER 0x84\n\n#define SND_SEQVOL_CONTINUE 0\n#define SND_SEQVOL_STOP 1\n#define SND_SEQVOL_PAUSE 2\n#define SND_SEQVOL_MUTE 3\n#define SND_SEQVOL_MODEMASK 0xF\n\n#define SND_ID_ERROR 0xFFFFFFFF // ID is invalid\n\n#define SND_MAX_SEQINSTANCES 8\n#define SND_SEQ_ERROR_ID 0xFFFFFFFF\n#define SND_SEQ_CROSSFADE_ID 0x80000000\n\n#define SND_PAUSEVOL_NORMAL 127\n\n#ifdef __cplusplus\n}\n#endif\n#endif // _MUSYX_MUSYX\n/* end \"musyx/musyx.h\" */\n/* \"src/musyx/runtime/snd3d.c\" line 1 \"musyx/musyx_priv.h\" */\n#ifndef _MUSYX_MUSYX_PRIV\n#define _MUSYX_MUSYX_PRIV\n\n/* \"include/musyx/musyx_priv.h\" line 3 \"musyx/musyx.h\" */\n/* end \"musyx/musyx.h\" */\n\n/* \"include/musyx/musyx_priv.h\" line 5 \"musyx/assert.h\" */\n#ifndef _MUSYX_ASSERT\n#define _MUSYX_ASSERT\n/* \"include/musyx/assert.h\" line 2 \"musyx/version.h\" */\n/* end \"musyx/version.h\" */\n\nextern void OSPanic(const char* file, int line, const char* msg, ...);\nextern void OSReport(const char* msg, ...);\n\nstatic inline unsigned __SOME_ASSERT_DERP1() { return 0; }\n\nstatic inline unsigned __SOME_ASSERT_DERP2() { return __SOME_ASSERT_DERP1(); }\n\nstatic inline void __SOME_ASSERT_DERP() { __SOME_ASSERT_DERP2() != 0; }\n\n#ifndef ASSERT\n#ifdef _DEBUG\n#define MUSY_ASSERT(cond)                                                                          \\\n  do {                                                                                             \\\n    if (!(cond)) {                                                                                 \\\n      OSPanic(__FILE__, __LINE__, \"Failed assertion \" #cond);                                      \\\n    }                                                                                              \\\n    __SOME_ASSERT_DERP();                                                                          \\\n  } while (0)\n#else\n#define MUSY_ASSERT(cond)\n#endif\n#endif\n\n#ifndef MUSY_ASSERT_MSG\n#ifdef _DEBUG\n#if MUSY_VERSION >= MUSY_VERSION_CHECK(2, 0, 0)\n#define MUSY_ASSERT_MSG(cond, msg)                                                                 \\\n  do {                                                                                             \\\n    s32 tmp = 1;                                                                                   \\\n    s32 tmp2;                                                                                      \\\n    if (!(cond)) {                                                                                 \\\n      OSPanic(__FILE__, __LINE__, msg);                                                            \\\n      tmp2 = 0;                                                                                    \\\n      if (tmp2 == 0) {                                                                             \\\n        tmp = 0;                                                                                   \\\n      }                                                                                            \\\n    }                                                                                              \\\n  } while (0)\n#else\n#define MUSY_ASSERT_MSG(cond, msg)                                                                 \\\n  do {                                                                                             \\\n    if (!(cond)) {                                                                                 \\\n      OSPanic(__FILE__, __LINE__, msg);                                                            \\\n    }                                                                                              \\\n  } while (0)\n#endif\n#else\n#define MUSY_ASSERT_MSG(cond, msg)\n#endif\n#endif\n\n#ifndef MUSY_DEBUG\n#ifdef _DEBUG\n#define MUSY_DEBUG OSReport\n#else\n#define MUSY_DEBUG\n#endif\n#endif\n\n#ifndef MUSY_FATAL\n#ifdef _DEBUG\n#define MUSY_FATAL(msg) OSPanic(__FILE__, __LINE__, msg)\n#else\n#define MUSY_FATAL\n#endif\n#endif\n\n#endif // _MUSYX_ASSERT\n/* end \"musyx/assert.h\" */\n/* \"include/musyx/musyx_priv.h\" line 6 \"musyx/hardware.h\" */\n#ifndef _MUSYX_HARDWARE\n#define _MUSYX_HARDWARE\n\n/* \"include/musyx/hardware.h\" line 3 \"musyx/musyx_priv.h\" */\n/* end \"musyx/musyx_priv.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nbool hwIsStudioActive(u8 studio);\nvoid* hwGetStreamPlayBuffer(u8 hwStreamHandle);\ns32 hwInit(u32* frq, u16 numVoices, u16 numStudios, u32 flags); /* extern */\nvoid hwInitSamplePlayback(u32 v, u16 smpID, void* newsmp, u32 set_defadsr, u32 prio,\n                          u32 callbackUserValue, u32 setSRC, u8 itdMode);\nvoid hwSetVolume(u32 v, u8 table, float vol, u32 pan, u32 span, float auxa, float auxb);\nvoid hwSetPitch(u32 v, u16 speed);\nvoid hwEnableIrq();\nvoid hwDisableIrq();\nvoid* hwTransAddr(void* samples);\nvoid hwExitStream(u8 id);\nvoid hwSaveSample(void* header, void* data);\nvoid hwRemoveSample(void* header, void* data);\nu32 hwGetVirtualSampleState(u32 voice);\nbool hwVoiceInStartup(u32 v);\nvoid hwBreak(s32 vid);\nu32 hwGetPos(u32 v);\nvoid hwInitSampleMem(u32 baseAddr, u32 length);\nvoid hwExitSampleMem();\nvoid hwSetVirtualSampleLoopBuffer(u32 voice, void* addr, u32 len);\nu16 hwGetSampleID(u32 voice);\nu8 hwGetSampleType(u32 voice);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _MUSYX_HARDWARE\n/* end \"musyx/hardware.h\" */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define CLAMP(value, min, max) ((value) > (max) ? (max) : (value) < (min) ? (min) : (value))\n// TODO matching hack\n#define CLAMP_INV(value, min, max) ((value) < (min) ? (min) : (value) > (max) ? (max) : (value))\n\ntypedef struct SYNTH_VOICELIST {\n  // total size: 0x4\n  u8 prev;  // offset 0x0, size 0x1\n  u8 next;  // offset 0x1, size 0x1\n  u16 user; // offset 0x2, size 0x2\n} SYNTH_VOICELIST;\nextern SYNTH_VOICELIST voicePrioSortVoices[64];\nextern u8 voicePrioSortVoicesRoot[256];\nextern SYNTH_VOICELIST voicePrioSortVoices[64];\n\ntypedef struct SYNTH_ROOTLIST {\n  // total size: 0x4\n  u16 next; // offset 0x0, size 0x2\n  u16 prev; // offset 0x2, size 0x2\n} SYNTH_ROOTLIST;\n\nextern SYNTH_ROOTLIST voicePrioSortRootList[256];\n\ntypedef struct synthInfo {\n  u32 mixFrq;\n  u32 numSamples;\n  SND_PLAYBACKINFO pbInfo;\n  u8 voiceNum;\n  u8 maxMusic;\n  u8 maxSFX;\n  u8 studioNum;\n} SynthInfo;\n\ntypedef struct ADSR_VARS {\n  u8 mode;\n  u8 state;\n  u32 cnt;\n  s32 currentVolume;\n  s32 currentIndex;\n  s32 currentDelta;\n\n  union data {\n    struct _dls {\n      u32 aTime;\n      u32 dTime;\n      u16 sLevel;\n      u32 rTime;\n      u16 cutOff;\n      u8 aMode;\n    } dls;\n\n    struct _linear {\n      u32 aTime;\n      u32 dTime;\n      u16 sLevel;\n      u32 rTime;\n    } linear;\n  } data;\n} ADSR_VARS;\n\ntypedef struct _PBMIX {\n  // total size: 0x24\n  u16 vL;          // offset 0x0, size 0x2\n  u16 vDeltaL;     // offset 0x2, size 0x2\n  u16 vR;          // offset 0x4, size 0x2\n  u16 vDeltaR;     // offset 0x6, size 0x2\n  u16 vAuxAL;      // offset 0x8, size 0x2\n  u16 vDeltaAuxAL; // offset 0xA, size 0x2\n  u16 vAuxAR;      // offset 0xC, size 0x2\n  u16 vDeltaAuxAR; // offset 0xE, size 0x2\n  u16 vAuxBL;      // offset 0x10, size 0x2\n  u16 vDeltaAuxBL; // offset 0x12, size 0x2\n  u16 vAuxBR;      // offset 0x14, size 0x2\n  u16 vDeltaAuxBR; // offset 0x16, size 0x2\n  u16 vAuxBS;      // offset 0x18, size 0x2\n  u16 vDeltaAuxBS; // offset 0x1A, size 0x2\n  u16 vS;          // offset 0x1C, size 0x2\n  u16 vDeltaS;     // offset 0x1E, size 0x2\n  u16 vAuxAS;      // offset 0x20, size 0x2\n  u16 vDeltaAuxAS; // offset 0x22, size 0x2\n} _PBMIX;\n\ntypedef struct _PBITD {\n  // total size: 0xE\n  u16 flag;         // offset 0x0, size 0x2\n  u16 bufferHi;     // offset 0x2, size 0x2\n  u16 bufferLo;     // offset 0x4, size 0x2\n  u16 shiftL;       // offset 0x6, size 0x2\n  u16 shiftR;       // offset 0x8, size 0x2\n  u16 targetShiftL; // offset 0xA, size 0x2\n  u16 targetShiftR; // offset 0xC, size 0x2\n} _PBITD;\n\ntypedef struct _PBUPDATE {\n  // total size: 0xE\n  u16 updNum[5]; // offset 0x0, size 0xA\n  u16 dataHi;    // offset 0xA, size 0x2\n  u16 dataLo;    // offset 0xC, size 0x2\n} _PBUPDATE;\n\ntypedef struct _PBDPOP {\n  // total size: 0x12\n  u16 aL;     // offset 0x0, size 0x2\n  u16 aAuxAL; // offset 0x2, size 0x2\n  u16 aAuxBL; // offset 0x4, size 0x2\n  u16 aR;     // offset 0x6, size 0x2\n  u16 aAuxAR; // offset 0x8, size 0x2\n  u16 aAuxBR; // offset 0xA, size 0x2\n  u16 aS;     // offset 0xC, size 0x2\n  u16 aAuxAS; // offset 0xE, size 0x2\n  u16 aAuxBS; // offset 0x10, size 0x2\n} _PBDPOP;\n\ntypedef struct _PBVE {\n  // total size: 0x4\n  u16 currentVolume; // offset 0x0, size 0x2\n  u16 currentDelta;  // offset 0x2, size 0x2\n} _PBVE;\n\ntypedef struct _PBFIR {\n  // total size: 0x6\n  u16 numCoefs; // offset 0x0, size 0x2\n  u16 coefsHi;  // offset 0x2, size 0x2\n  u16 coefsLo;  // offset 0x4, size 0x2\n} _PBFIR;\n\ntypedef struct _PBADDR {\n  // total size: 0x10\n  u16 loopFlag;         // offset 0x0, size 0x2\n  u16 format;           // offset 0x2, size 0x2\n  u16 loopAddressHi;    // offset 0x4, size 0x2\n  u16 loopAddressLo;    // offset 0x6, size 0x2\n  u16 endAddressHi;     // offset 0x8, size 0x2\n  u16 endAddressLo;     // offset 0xA, size 0x2\n  u16 currentAddressHi; // offset 0xC, size 0x2\n  u16 currentAddressLo; // offset 0xE, size 0x2\n} _PBADDR;\n\ntypedef struct _PBADPCM {\n  // total size: 0x28\n  u16 a[8][2];    // offset 0x0, size 0x20\n  u16 gain;       // offset 0x20, size 0x2\n  u16 pred_scale; // offset 0x22, size 0x2\n  u16 yn1;        // offset 0x24, size 0x2\n  u16 yn2;        // offset 0x26, size 0x2\n} _PBADPCM;\n\ntypedef struct _PBSRC {\n  // total size: 0xE\n  u16 ratioHi;            // offset 0x0, size 0x2\n  u16 ratioLo;            // offset 0x2, size 0x2\n  u16 currentAddressFrac; // offset 0x4, size 0x2\n  u16 last_samples[4];    // offset 0x6, size 0x8\n} _PBSRC;\n\ntypedef struct _PBADPCMLOOP {\n  // total size: 0x6\n  u16 loop_pred_scale; // offset 0x0, size 0x2\n  u16 loop_yn1;        // offset 0x2, size 0x2\n  u16 loop_yn2;        // offset 0x4, size 0x2\n} _PBADPCMLOOP;\n\ntypedef struct _PB {\n  // total size: 0xBC\n  u16 nextHi;             // offset 0x0, size 0x2\n  u16 nextLo;             // offset 0x2, size 0x2\n  u16 currHi;             // offset 0x4, size 0x2\n  u16 currLo;             // offset 0x6, size 0x2\n  u16 srcSelect;          // offset 0x8, size 0x2\n  u16 coefSelect;         // offset 0xA, size 0x2\n  u16 mixerCtrl;          // offset 0xC, size 0x2\n  u16 state;              // offset 0xE, size 0x2\n  u16 loopType;           // offset 0x10, size 0x2\n  _PBMIX mix;             // offset 0x12, size 0x24\n  _PBITD itd;             // offset 0x36, size 0xE\n  _PBUPDATE update;       // offset 0x44, size 0xE\n  _PBDPOP dpop;           // offset 0x52, size 0x12\n  _PBVE ve;               // offset 0x64, size 0x4\n  _PBFIR fir;             // offset 0x68, size 0x6\n  _PBADDR addr;           // offset 0x6E, size 0x10\n  _PBADPCM adpcm;         // offset 0x7E, size 0x28\n  _PBSRC src;             // offset 0xA6, size 0xE\n  _PBADPCMLOOP adpcmLoop; // offset 0xB4, size 0x6\n  u16 streamLoopCnt;      // offset 0xBA, size 0x2\n} _PB;\n\ntypedef struct SAMPLE_INFO {\n  // total size: 0x20\n  u32 info;        // offset 0x0, size 0x4\n  void* addr;      // offset 0x4, size 0x4\n  void* extraData; // offset 0x8, size 0x4\n  u32 offset;      // offset 0xC, size 0x4\n  u32 length;      // offset 0x10, size 0x4\n  u32 loop;        // offset 0x14, size 0x4\n  u32 loopLength;  // offset 0x18, size 0x4\n  u8 compType;     // offset 0x1C, size 0x1\n} SAMPLE_INFO;\n\ntypedef struct GROUP_DATA {\n  // total size: 0x28\n  u32 nextOff;   // offset 0x0, size 0x4\n  u16 id;        // offset 0x4, size 0x2\n  u16 type;      // offset 0x6, size 0x2\n  u32 macroOff;  // offset 0x8, size 0x4\n  u32 sampleOff; // offset 0xC, size 0x4\n  u32 curveOff;  // offset 0x10, size 0x4\n  u32 keymapOff; // offset 0x14, size 0x4\n  u32 layerOff;  // offset 0x18, size 0x4\n  union {\n    struct fx {\n      // total size: 0x4\n      u32 tableOff; // offset 0x0, size 0x4\n    } fx;\n    struct song {\n      // total size: 0xC\n      u32 normpageOff;  // offset 0x0, size 0x4\n      u32 drumpageOff;  // offset 0x4, size 0x4\n      u32 midiSetupOff; // offset 0x8, size 0x4\n    } song;\n  } data; // offset 0x1C, size 0xC\n} GROUP_DATA;\n\ntypedef struct SAMPLE_HEADER {\n  // total size: 0x10\n  u32 info;       // offset 0x0, size 0x4\n  u32 length;     // offset 0x4, size 0x4\n  u32 loopOffset; // offset 0x8, size 0x4\n  u32 loopLength; // offset 0xC, size 0x4\n} SAMPLE_HEADER;\n\ntypedef struct SDIR_DATA {\n  // total size: 0x20\n  u16 id;               // offset 0x0, size 0x2\n  u16 ref_cnt;          // offset 0x2, size 0x2\n  u32 offset;           // offset 0x4, size 0x4\n  void* addr;           // offset 0x8, size 0x4\n  SAMPLE_HEADER header; // offset 0xC, size 0x10\n  u32 extraData;        // offset 0x1C, size 0x4\n} SDIR_DATA;\n\ntypedef struct SDIR_TAB {\n  // total size: 0xC\n  SDIR_DATA* data; // offset 0x0, size 0x4\n  void* base;      // offset 0x4, size 0x4\n  u16 numSmp;      // offset 0x8, size 0x2\n  u16 res;         // offset 0xA, size 0x2\n} SDIR_TAB;\n\ntypedef struct DATA_TAB {\n  // total size: 0x8\n  void* data;   // offset 0x0, size 0x4\n  u16 id;       // offset 0x4, size 0x2\n  u16 refCount; // offset 0x6, size 0x2\n} DATA_TAB;\n\ntypedef struct LAYER_TAB {\n  // total size: 0xC\n  void* data;   // offset 0x0, size 0x4\n  u16 id;       // offset 0x4, size 0x2\n  u16 num;      // offset 0x6, size 0x2\n  u16 refCount; // offset 0x8, size 0x2\n  u16 reserved; // offset 0xA, size 0x2\n} LAYER_TAB;\n\ntypedef struct MAC_MAINTAB {\n  // total size: 0x4\n  u16 num;         // offset 0x0, size 0x2\n  u16 subTabIndex; // offset 0x2, size 0x2\n} MAC_MAINTAB;\n\ntypedef struct MAC_SUBTAB {\n  // total size: 0x8\n  void* data;   // offset 0x0, size 0x4\n  u16 id;       // offset 0x4, size 0x2\n  u16 refCount; // offset 0x6, size 0x2\n} MAC_SUBTAB;\n\ntypedef struct GSTACK {\n  // total size: 0xC\n  GROUP_DATA* gAddr;   // offset 0x0, size 0x4\n  SDIR_DATA* sdirAddr; // offset 0x4, size 0x4\n  void* prjAddr;       // offset 0x8, size 0x4\n} GSTACK;\n\ntypedef struct VSampleInfo {\n  // total size: 0xC\n  void* loopBufferAddr; // offset 0x0, size 0x4\n  u32 loopBufferLength; // offset 0x4, size 0x4\n  u8 inLoopBuffer;      // offset 0x8, size 0x1\n} VSampleInfo;\n\ntypedef struct DSPvoice {\n  _PB* pb;\n  void* patchData;\n  void* itdBuffer;\n  struct DSPvoice* next;\n  struct DSPvoice* prev;\n  struct DSPvoice* nextAlien;\n  u32 mesgCallBackUserValue;\n  u32 prio;\n  u32 currentAddr;\n  u32 changed[5];\n  u32 pitch[5];\n  u16 volL;\n  u16 volR;\n  u16 volS;\n  u16 volLa;\n  u16 volRa;\n  u16 volSa;\n  u16 volLb;\n  u16 volRb;\n  u16 volSb;\n  u16 lastVolL;\n  u16 lastVolR;\n  u16 lastVolS;\n  u16 lastVolLa;\n  u16 lastVolRa;\n  u16 lastVolSa;\n  u16 lastVolLb;\n  u16 lastVolRb;\n  u16 lastVolSb;\n  u16 smp_id;\n  SAMPLE_INFO smp_info;\n  VSampleInfo vSampleInfo;\n  u8 streamLoopPS;\n  ADSR_VARS adsr;\n  u16 srcTypeSelect;\n  u16 srcCoefSelect;\n  u16 itdShiftL;\n  u16 itdShiftR;\n  u8 singleOffset;\n  struct {\n    u32 posHi;\n    u32 posLo;\n    u32 pitch;\n  } playInfo;\n\n  struct {\n    u8 pitch;\n    u8 vol;\n    u8 volA;\n    u8 volB;\n  } lastUpdate;\n\n  u32 virtualSampleID;\n  u8 state;\n  u8 postBreak;\n  u8 startupBreak;\n  u8 studio;\n  u32 flags;\n} DSPvoice;\n\ntypedef struct VID_LIST {\n  struct VID_LIST* next;\n  struct VID_LIST* prev;\n  u32 vid;\n  u32 root;\n} VID_LIST;\n\ntypedef enum {\n  MAC_STATE_RUNNABLE = 0,\n  MAC_STATE_YIELDED,\n  MAC_STATE_STOPPED,\n} MAC_STATE;\n\ntypedef struct MSTEP {\n  u32 para[2];\n} MSTEP;\n\ntypedef struct CALLSTACK {\n  MSTEP* addr;\n  MSTEP* curAddr;\n} CALLSTACK;\n\ntypedef struct SYNTH_QUEUE {\n  // total size: 0xC\n  struct SYNTH_QUEUE* next; // offset 0x0, size 0x4\n  struct SYNTH_QUEUE* prev; // offset 0x4, size 0x4\n  u8 voice;                 // offset 0x8, size 0x1\n  u8 jobTabIndex;           // offset 0x9, size 0x1\n} SYNTH_QUEUE;\n\ntypedef enum {\n  SYNTH_JOBTYPE_LOW = 0,\n  SYNTH_JOBTYPE_ZERO = 1,\n  SYNTH_JOBTYPE_EVENT = 2,\n} SYNTH_JOBTYPE;\n\ntypedef struct {\n  // total size: 0xC\n  SYNTH_QUEUE* lowPrecision; // offset 0x0, size 0x4\n  SYNTH_QUEUE* event;        // offset 0x4, size 0x4\n  SYNTH_QUEUE* zeroOffset;   // offset 0x8, size 0x4\n} SYNTH_JOBTAB;\n\ntypedef struct SYNTH_LFO {\n  u32 time;\n  u32 period;\n  s16 value;\n  s16 lastValue;\n} SYNTH_LFO;\n\ntypedef struct SYNTHMasterFader {\n  // total size: 0x30\n  f32 volume;         // offset 0x0, size 0x4\n  f32 target;         // offset 0x4, size 0x4\n  f32 start;          // offset 0x8, size 0x4\n  f32 time;           // offset 0xC, size 0x4\n  f32 deltaTime;      // offset 0x10, size 0x4\n  f32 pauseVol;       // offset 0x14, size 0x4\n  f32 pauseTarget;    // offset 0x18, size 0x4\n  f32 pauseStart;     // offset 0x1C, size 0x4\n  f32 pauseTime;      // offset 0x20, size 0x4\n  f32 pauseDeltaTime; // offset 0x24, size 0x4\n  u32 seqId;          // offset 0x28, size 0x4\n  u8 seqMode;         // offset 0x2C, size 0x1\n  u8 type;            // offset 0x2D, size 0x1\n} SYNTHMasterFader;\n\ntypedef struct CTRL_SOURCE {\n  u8 midiCtrl;\n  u8 combine;\n  s32 scale;\n} CTRL_SOURCE;\n\ntypedef struct CTRL_DEST {\n  CTRL_SOURCE source[4];\n  u16 oldValue;\n  u8 numSource;\n} CTRL_DEST;\n\ntypedef struct SND_VIRTUALSAMPLE_INFO {\n  // total size: 0x14\n  u16 smpID;  // offset 0x0, size 0x2\n  u16 instID; // offset 0x2, size 0x2\n  union vsData {\n    struct vsUpdate {\n      // total size: 0x10\n      u32 off1; // offset 0x0, size 0x4\n      u32 len1; // offset 0x4, size 0x4\n      u32 off2; // offset 0x8, size 0x4\n      u32 len2; // offset 0xC, size 0x4\n    } update;\n  } data;\n} SND_VIRTUALSAMPLE_INFO;\n\ntypedef struct VS_BUFFER {\n  // total size: 0x24\n  u8 state;                    // offset 0x0, size 0x1\n  u8 hwId;                     // offset 0x1, size 0x1\n  u8 smpType;                  // offset 0x2, size 0x1\n  u8 voice;                    // offset 0x3, size 0x1\n  u32 last;                    // offset 0x4, size 0x4\n  u32 finalGoodSamples;        // offset 0x8, size 0x4\n  u32 finalLast;               // offset 0xC, size 0x4\n  SND_VIRTUALSAMPLE_INFO info; // offset 0x10, size 0x14\n} VS_BUFFER;\n\ntypedef struct _VS {\n  // total size: 0x950\n  u8 numBuffers;              // offset 0x0, size 0x1\n  u32 bufferLength;           // offset 0x4, size 0x4\n  VS_BUFFER streamBuffer[64]; // offset 0x8, size 0x900\n  u8 voices[64];              // offset 0x908, size 0x40\n  u16 nextInstID;             // offset 0x948, size 0x2\n  u32 (*callback)(u8,\n                  SND_VIRTUALSAMPLE_INFO*); // offset 0x94C, size 0x4\n} VS;\n\nextern VS vs;\n\n#pragma push\n#pragma pack(4)\ntypedef struct SYNTH_VOICE {\n  // total size: 0x404\n  SYNTH_QUEUE lowPrecisionJob;            // offset 0x0, size 0xC\n  SYNTH_QUEUE zeroOffsetJob;              // offset 0xC, size 0xC\n  SYNTH_QUEUE eventJob;                   // offset 0x18, size 0xC\n  u64 lastLowCallTime;                    // offset 0x24, size 0x8\n  u64 lastZeroCallTime;                   // offset 0x2C, size 0x8\n  MSTEP* addr;                            // offset 0x34, size 0x4\n  MSTEP* curAddr;                         // offset 0x38, size 0x4\n  struct SYNTH_VOICE* nextMacActive;      // offset 0x3C, size 0x4\n  struct SYNTH_VOICE* prevMacActive;      // offset 0x40, size 0x4\n  struct SYNTH_VOICE* nextTimeQueueMacro; // offset 0x44, size 0x4\n  struct SYNTH_VOICE* prevTimeQueueMacro; // offset 0x48, size 0x4\n  MAC_STATE macState;                     // offset 0x4C, size 0x4\n  MSTEP* trapEventAddr[3];                // offset 0x50, size 0xC\n  MSTEP* trapEventCurAddr[3];             // offset 0x5C, size 0xC\n  u8 trapEventAny;                        // offset 0x68, size 0x1\n  CALLSTACK callStack[4];                 // offset 0x6C, size 0x20\n  u8 callStackEntryNum;                   // offset 0x8C, size 0x1\n  u8 callStackIndex;                      // offset 0x8D, size 0x1\n  u64 macStartTime;                       // offset 0x90, size 0x8\n  u64 wait;                               // offset 0x98, size 0x8\n  u64 waitTime;                           // offset 0xA0, size 0x8\n  u8 timeUsedByInput;                     // offset 0xA8, size 0x1\n  u16 loop;                               // offset 0xAA, size 0x2\n  s32 local_vars[16];                     // offset 0xAC, size 0x40\n  u32 child;                              // offset 0xEC, size 0x4\n  u32 parent;                             // offset 0xF0, size 0x4\n  u32 id;                                 // offset 0xF4, size 0x4\n  VID_LIST* vidList;                      // offset 0xF8, size 0x4\n  VID_LIST* vidMasterList;                // offset 0xFC, size 0x4\n  u16 allocId;                            // offset 0x100, size 0x2\n  u16 macroId;                            // offset 0x102, size 0x2\n  u8 keyGroup;                            // offset 0x104, size 0x1\n  u32 lastVID;                            // offset 0x108, size 0x4\n  u8 prio;                                // offset 0x10C, size 0x1\n  u16 ageSpeed;                           // offset 0x10E, size 0x2\n  u32 age;                                // offset 0x110, size 0x4\n  u64 cFlags;                             // offset 0x114, size 0x8\n  u8 block;                               // offset 0x11C, size 0x1\n  u8 fxFlag;                              // offset 0x11D, size 0x1\n  u8 vGroup;                              // offset 0x11E, size 0x1\n  u8 studio;                              // offset 0x11F, size 0x1\n  u8 track;                               // offset 0x120, size 0x1\n  u8 midi;                                // offset 0x121, size 0x1\n  u8 midiSet;                             // offset 0x122, size 0x1\n  u8 section;                             // offset 0x123, size 0x1\n#if MUSY_VERSION <= MUSY_VERSION_CHECK(1, 5, 0)\n  void* sAddr;\n#endif\n  u32 sInfo;               // offset 0x124, size 0x4\n  u32 playFrq;             // offset 0x128, size 0x4\n  u16 curNote;             // offset 0x12C, size 0x2\n  s8 curDetune;            // offset 0x12E, size 0x1\n  u8 orgNote;              // offset 0x12F, size 0x1\n  u8 lastNote;             // offset 0x130, size 0x1\n  u8 portType;             // offset 0x131, size 0x1\n  u16 portLastCtrlState;   // offset 0x132, size 0x2\n  u32 portDuration;        // offset 0x134, size 0x4\n  u32 portCurPitch;        // offset 0x138, size 0x4\n  u32 portTime;            // offset 0x13C, size 0x4\n  u8 vibKeyRange;          // offset 0x140, size 0x1\n  u8 vibCentRange;         // offset 0x141, size 0x1\n  u32 vibPeriod;           // offset 0x144, size 0x4\n  u32 vibCurTime;          // offset 0x148, size 0x4\n  s32 vibCurOffset;        // offset 0x14C, size 0x4\n  s16 vibModAddScale;      // offset 0x150, size 0x2\n  u32 volume;              // offset 0x154, size 0x4\n  u32 orgVolume;           // offset 0x158, size 0x4\n  float lastVolFaderScale; // offset 0x15C, size 0x4\n  u32 lastPan;             // offset 0x160, size 0x4\n  u32 lastSPan;            // offset 0x164, size 0x4\n  float treCurScale;       // offset 0x168, size 0x4\n  u16 treScale;            // offset 0x16C, size 0x2\n  u16 treModAddScale;      // offset 0x16E, size 0x2\n  u32 panning[2];          // offset 0x170, size 0x8\n  s32 panDelta[2];         // offset 0x178, size 0x8\n  u32 panTarget[2];        // offset 0x180, size 0x8\n  u32 panTime[2];          // offset 0x188, size 0x8\n  u8 revVolScale;          // offset 0x190, size 0x1\n  u8 revVolOffset;         // offset 0x191, size 0x1\n  u8 volTable;             // offset 0x192, size 0x1\n  u8 itdMode;              // offset 0x193, size 0x1\n  s32 envDelta;            // offset 0x194, size 0x4\n  u32 envTarget;           // offset 0x198, size 0x4\n  u32 envCurrent;          // offset 0x19C, size 0x4\n  u32 sweepOff[2];         // offset 0x1A0, size 0x8\n  s32 sweepAdd[2];         // offset 0x1A8, size 0x8\n  s32 sweepCnt[2];         // offset 0x1B0, size 0x8\n  u8 sweepNum[2];          // offset 0x1B8, size 0x2\n  SYNTH_LFO lfo[2];        // offset 0x1BC, size 0x18\n  u8 lfoUsedByInput[2];    // offset 0x1D4, size 0x2\n  u8 pbLowerKeyRange;      // offset 0x1D6, size 0x1\n  u8 pbUpperKeyRange;      // offset 0x1D7, size 0x1\n  u16 pbLast;              // offset 0x1D8, size 0x2\n  ADSR_VARS pitchADSR;     // offset 0x1DC, size 0x28\n  s16 pitchADSRRange;      // offset 0x204, size 0x2\n  u16 curPitch;            // offset 0x206, size 0x2\n  struct setup {\n    // total size: 0x9\n    u8 vol;                     // offset 0x0, size 0x1\n    u8 pan;                     // offset 0x1, size 0x1\n    u8 midi;                    // offset 0x2, size 0x1\n    u8 midiSet;                 // offset 0x3, size 0x1\n    u8 section;                 // offset 0x4, size 0x1\n    u8 track;                   // offset 0x5, size 0x1\n    u8 vGroup;                  // offset 0x6, size 0x1\n    u8 studio;                  // offset 0x7, size 0x1\n    u8 itdMode;                 // offset 0x8, size 0x1\n  } setup;                      // offset 0x208, size 0x9\n  u32 midiDirtyFlags;           // offset 0x214, size 0x4\n  CTRL_DEST inpVolume;          // offset 0x218, size 0x24\n  CTRL_DEST inpPanning;         // offset 0x23C, size 0x24\n  CTRL_DEST inpSurroundPanning; // offset 0x260, size 0x24\n  CTRL_DEST inpPitchBend;       // offset 0x284, size 0x24\n  CTRL_DEST inpDoppler;         // offset 0x2A8, size 0x24\n  CTRL_DEST inpModulation;      // offset 0x2CC, size 0x24\n  CTRL_DEST inpPedal;           // offset 0x2F0, size 0x24\n  CTRL_DEST inpPortamento;      // offset 0x314, size 0x24\n  CTRL_DEST inpPreAuxA;         // offset 0x338, size 0x24\n  CTRL_DEST inpReverb;          // offset 0x35C, size 0x24\n  CTRL_DEST inpPreAuxB;         // offset 0x380, size 0x24\n  CTRL_DEST inpPostAuxB;        // offset 0x3A4, size 0x24\n  CTRL_DEST inpTremolo;         // offset 0x3C8, size 0x24\n  u8 mesgNum;                   // offset 0x3EC, size 0x1\n  u8 mesgRead;                  // offset 0x3ED, size 0x1\n  u8 mesgWrite;                 // offset 0x3EE, size 0x1\n  s32 mesgQueue[4];             // offset 0x3F0, size 0x10\n  u16 curOutputVolume;          // offset 0x400, size 0x2\n} SYNTH_VOICE;\n\ntypedef struct synthITDInfo {\n  // total size: 0x2\n  u8 music; // offset 0x0, size 0x1\n  u8 sfx;   // offset 0x1, size 0x1\n} synthITDInfo;\n\n#pragma pop\n\ntypedef struct LAYER {\n  // total size: 0xC\n  u16 id;         // offset 0x0, size 0x2\n  u8 keyLow;      // offset 0x2, size 0x1\n  u8 keyHigh;     // offset 0x3, size 0x1\n  s8 transpose;   // offset 0x4, size 0x1\n  u8 volume;      // offset 0x5, size 0x1\n  s16 prioOffset; // offset 0x6, size 0x2\n  u8 panning;     // offset 0x8, size 0x1\n  u8 reserved[3]; // offset 0x9, size 0x3\n} LAYER;\n\ntypedef struct KEYMAP {\n  // total size: 0x8\n  u16 id;         // offset 0x0, size 0x2\n  s8 transpose;   // offset 0x2, size 0x1\n  u8 panning;     // offset 0x3, size 0x1\n  s16 prioOffset; // offset 0x4, size 0x2\n  u8 reserved[2]; // offset 0x6, size 0x2\n} KEYMAP;\n\ntypedef struct MEM_DATA {\n  // total size: 0x408\n  u32 nextOff;  // offset 0x0, size 0x4\n  u16 id;       // offset 0x4, size 0x2\n  u16 reserved; // offset 0x6, size 0x2\n  union {\n    struct {\n      // total size: 0x10\n      u32 num;        // offset 0x0, size 0x4\n      LAYER entry[1]; // offset 0x4, size 0xC\n    } layer;\n    KEYMAP map[128];\n    u8 tab[1];\n    MSTEP cmd[1][2];\n  } data; // offset 0x8, size 0x400\n} MEM_DATA;\n\ntypedef struct POOL_DATA {\n  // total size: 0x10\n  u32 macroOff;  // offset 0x0, size 0x4\n  u32 curveOff;  // offset 0x4, size 0x4\n  u32 keymapOff; // offset 0x8, size 0x4\n  u32 layerOff;  // offset 0xC, size 0x4\n} POOL_DATA;\n\ntypedef struct SAL_VOLINFO {\n  // total size: 0x24\n  f32 volL;     // offset 0x0, size 0x4\n  f32 volR;     // offset 0x4, size 0x4\n  f32 volS;     // offset 0x8, size 0x4\n  f32 volAuxAL; // offset 0xC, size 0x4\n  f32 volAuxAR; // offset 0x10, size 0x4\n  f32 volAuxAS; // offset 0x14, size 0x4\n  f32 volAuxBL; // offset 0x18, size 0x4\n  f32 volAuxBR; // offset 0x1C, size 0x4\n  f32 volAuxBS; // offset 0x20, size 0x4\n} SAL_VOLINFO;\n\ntypedef struct SAL_PANINFO {\n  // total size: 0x30\n  u32 pan_i;   // offset 0x0, size 0x4\n  u32 pan_im;  // offset 0x4, size 0x4\n  u32 span_i;  // offset 0x8, size 0x4\n  u32 span_im; // offset 0xC, size 0x4\n  u32 rpan_i;  // offset 0x10, size 0x4\n  u32 rpan_im; // offset 0x14, size 0x4\n  f32 pan_f;   // offset 0x18, size 0x4\n  f32 pan_fm;  // offset 0x1C, size 0x4\n  f32 span_f;  // offset 0x20, size 0x4\n  f32 span_fm; // offset 0x24, size 0x4\n  f32 rpan_f;  // offset 0x28, size 0x4\n  f32 rpan_fm; // offset 0x2C, size 0x4\n} SAL_PANINFO;\n\ntypedef struct _SPB {\n  // total size: 0x36\n  u16 dpopLHi;     // offset 0x0, size 0x2\n  u16 dpopLLo;     // offset 0x2, size 0x2\n  u16 dpopLDelta;  // offset 0x4, size 0x2\n  u16 dpopRHi;     // offset 0x6, size 0x2\n  u16 dpopRLo;     // offset 0x8, size 0x2\n  u16 dpopRDelta;  // offset 0xA, size 0x2\n  u16 dpopSHi;     // offset 0xC, size 0x2\n  u16 dpopSLo;     // offset 0xE, size 0x2\n  u16 dpopSDelta;  // offset 0x10, size 0x2\n  u16 dpopALHi;    // offset 0x12, size 0x2\n  u16 dpopALLo;    // offset 0x14, size 0x2\n  u16 dpopALDelta; // offset 0x16, size 0x2\n  u16 dpopARHi;    // offset 0x18, size 0x2\n  u16 dpopARLo;    // offset 0x1A, size 0x2\n  u16 dpopARDelta; // offset 0x1C, size 0x2\n  u16 dpopASHi;    // offset 0x1E, size 0x2\n  u16 dpopASLo;    // offset 0x20, size 0x2\n  u16 dpopASDelta; // offset 0x22, size 0x2\n  u16 dpopBLHi;    // offset 0x24, size 0x2\n  u16 dpopBLLo;    // offset 0x26, size 0x2\n  u16 dpopBLDelta; // offset 0x28, size 0x2\n  u16 dpopBRHi;    // offset 0x2A, size 0x2\n  u16 dpopBRLo;    // offset 0x2C, size 0x2\n  u16 dpopBRDelta; // offset 0x2E, size 0x2\n  u16 dpopBSHi;    // offset 0x30, size 0x2\n  u16 dpopBSLo;    // offset 0x32, size 0x2\n  u16 dpopBSDelta; // offset 0x34, size 0x2\n} _SPB;\n\ntypedef struct DSPhostDPop {\n  // total size: 0x24\n  s32 l;  // offset 0x0, size 0x4\n  s32 r;  // offset 0x4, size 0x4\n  s32 s;  // offset 0x8, size 0x4\n  s32 lA; // offset 0xC, size 0x4\n  s32 rA; // offset 0x10, size 0x4\n  s32 sA; // offset 0x14, size 0x4\n  s32 lB; // offset 0x18, size 0x4\n  s32 rB; // offset 0x1C, size 0x4\n  s32 sB; // offset 0x20, size 0x4\n} DSPhostDPop;\n\ntypedef struct DSPinput {\n  // total size: 0xC\n  u8 studio;              // offset 0x0, size 0x1\n  u16 vol;                // offset 0x2, size 0x2\n  u16 volA;               // offset 0x4, size 0x2\n  u16 volB;               // offset 0x6, size 0x2\n  SND_STUDIO_INPUT* desc; // offset 0x8, size 0x4\n} DSPinput;\n\ntypedef struct DSPstudioinfo {\n  // total size: 0xBC\n  _SPB* spb;                    // offset 0x0, size 0x4\n  DSPhostDPop hostDPopSum;      // offset 0x4, size 0x24\n  s32* main[2];                 // offset 0x28, size 0x8\n  s32* auxA[3];                 // offset 0x30, size 0xC\n  s32* auxB[3];                 // offset 0x3C, size 0xC\n  DSPvoice* voiceRoot;          // offset 0x48, size 0x4\n  DSPvoice* alienVoiceRoot;     // offset 0x4C, size 0x4\n  u8 state;                     // offset 0x50, size 0x1\n  u8 isMaster;                  // offset 0x51, size 0x1\n  u8 numInputs;                 // offset 0x52, size 0x1\n  SND_STUDIO_TYPE type;         // offset 0x54, size 0x4\n  DSPinput in[7];               // offset 0x58, size 0x54\n  SND_AUX_CALLBACK auxAHandler; // offset 0xAC, size 0x4\n  SND_AUX_CALLBACK auxBHandler; // offset 0xB0, size 0x4\n  void* auxAUser;               // offset 0xB4, size 0x4\n  void* auxBUser;               // offset 0xB8, size 0x4\n} DSPstudioinfo;\n\nextern DSPstudioinfo dspStudio[8];\n\nextern SYNTH_VOICE* synthVoice;\n\nextern DSPvoice* dspVoice;\ntypedef s32 (*SND_COMPARE)(void*, void*);\n\ntypedef struct CHANNEL_DEFAULTS {\n  // total size: 0x1\n  u8 pbRange; // offset 0x0, size 0x1\n} CHANNEL_DEFAULTS;\n\ntypedef struct FX_TAB {\n  // total size: 0xA\n  u16 id;       // offset 0x0, size 0x2\n  u16 macro;    // offset 0x2, size 0x2\n  u8 maxVoices; // offset 0x4, size 0x1\n  u8 priority;  // offset 0x5, size 0x1\n  u8 volume;    // offset 0x6, size 0x1\n  u8 panning;   // offset 0x7, size 0x1\n  u8 key;       // offset 0x8, size 0x1\n  u8 vGroup;    // offset 0x9, size 0x1\n} FX_TAB;\n\ntypedef struct FX_DATA {\n  // total size: 0xE\n  u16 num;       // offset 0x0, size 0x2\n  u16 reserverd; // offset 0x2, size 0x2\n  FX_TAB fx[1];  // offset 0x4, size 0xA\n} FX_DATA;\n\ntypedef struct FX_GROUP {\n  // total size: 0x8\n  u16 gid;       // offset 0x0, size 0x2\n  u16 fxNum;     // offset 0x2, size 0x2\n  FX_TAB* fxTab; // offset 0x4, size 0x4\n} FX_GROUP;\n\ntypedef struct PAGE {\n  // total size: 0x6\n  u16 macro;    // offset 0x0, size 0x2\n  u8 prio;      // offset 0x2, size 0x1\n  u8 maxVoices; // offset 0x3, size 0x1\n  u8 index;     // offset 0x4, size 0x1\n  u8 reserved;  // offset 0x5, size 0x1\n} PAGE;\n\ntypedef struct MIDI_CHANNEL_SETUP {\n  // total size: 0x5\n  u8 program; // offset 0x0, size 0x1\n  u8 volume;  // offset 0x1, size 0x1\n  u8 panning; // offset 0x2, size 0x1\n  u8 reverb;  // offset 0x3, size 0x1\n  u8 chorus;  // offset 0x4, size 0x1\n} MIDI_CHANNEL_SETUP;\n\ntypedef struct MIDISETUP {\n  // total size: 0x54\n  u16 songId;                     // offset 0x0, size 0x2\n  u16 reserved;                   // offset 0x2, size 0x2\n  MIDI_CHANNEL_SETUP channel[16]; // offset 0x4, size 0x50\n} MIDISETUP;\n\ntypedef struct ADSR_INFO {\n  // total size: 0x14\n  union ai_data {\n    struct {\n      // total size: 0x14\n      s32 atime;  // offset 0x0, size 0x4\n      s32 dtime;  // offset 0x4, size 0x4\n      u16 slevel; // offset 0x8, size 0x2\n      u16 rtime;  // offset 0xA, size 0x2\n      s32 ascale; // offset 0xC, size 0x4\n      s32 dscale; // offset 0x10, size 0x4\n    } dls;\n    struct {\n      // total size: 0x8\n      u16 atime;  // offset 0x0, size 0x2\n      u16 dtime;  // offset 0x2, size 0x2\n      u16 slevel; // offset 0x4, size 0x2\n      u16 rtime;  // offset 0x6, size 0x2\n    } linear;\n  } data; // offset 0x0, size 0x14\n} ADSR_INFO;\n\nvoid dataInit(u32, u32); /* extern */\nvoid dataInitStack();    /* extern */\nu32 dataInsertSDir(SDIR_DATA* sdir, void* smp_data);\nu32 dataRemoveSDir(SDIR_DATA* sdir);\nu32 dataInsertMacro(u16 mid, void* macroaddr);\nu32 dataRemoveMacro(u16 mid);\nu32 dataInsertCurve(u16 cid, void* curvedata);\nu32 dataRemoveCurve(u16 sid);\ns32 dataGetSample(u16 sid, SAMPLE_INFO* newsmp);\nvoid* dataGetCurve(u16 cid);\nu32 dataAddSampleReference(u16 sid);\nu32 dataRemoveSampleReference(u16 sid);\nu32 dataInsertKeymap(u16 cid, void* keymapdata);\nu32 dataRemoveKeymap(u16 sid);\nu32 dataInsertLayer(u16 cid, void* layerdata, u16 size);\nu32 dataRemoveLayer(u16 sid);\nu32 dataInsertFX(u16 gid, FX_TAB* fx, u16 fxNum);\nFX_TAB* dataGetFX(u16 fid);\nvoid* dataGetLayer(u16 cid, u16* n);\nvoid* dataGetKeymap(u16 cid);\n\ns32 hwInit(u32* frq, u16 numVoices, u16 numStudios, u32 flags); /* extern */\nvoid hwInitSamplePlayback(u32 v, u16 smpID, void* newsmp, u32 set_defadsr, u32 prio,\n                          u32 callbackUserValue, u32 setSRC, u8 itdMode);\nvoid hwSetVolume(u32 v, u8 table, f32 vol, u32 pan, u32 span, f32 auxa, f32 auxb);\nvoid hwSetPitch(u32 v, u16 speed);\nvoid hwEnableIrq();\nvoid hwDisableIrq();\nvoid* hwTransAddr(void* samples);\n\nvoid seqInit(); /* extern */\nu32 seqStartPlay(PAGE* norm, PAGE* drum, MIDISETUP* midiSetup, u32* song, SND_PLAYPARA* para,\n                 u8 studio, u16 sgid);\nu32 seqGetPrivateId(u32 seqId);\nvoid streamInit(); /* extern */\n\nvoid vsInit(); /* extern */\nu32 vsSampleStartNotify(u8 voice);\nvoid vsSampleEndNotify(u32 pubID);\n\nvoid hwExit();\nvoid dataExit();\nvoid s3dInit(u32); /* extern */\nvoid s3dKillEmitterByFXID(FX_TAB* fxTab, u32 num);\nvoid s3dExit();\nvoid synthInit(u32 mixFrq, u32 numVoices);\nvoid synthSetBpm(u32 pbm, u8 set, u8 section);\nvoid synthFXCloneMidiSetup(SYNTH_VOICE* dest, SYNTH_VOICE* src);\nvoid synthSetMusicVolumeType(u8 vGroup, u8 type);\nvoid synthAddJob(SYNTH_VOICE* svoice, SYNTH_JOBTYPE jobType, u32 deltaTime);\n\nextern s32 synthGlobalVariable[16];\nextern u16 voicePrioSortRootListRoot;\nextern u8 voiceMusicRunning;\nextern u8 voiceFxRunning;\nextern u8 voiceListInsert;\nextern u8 voiceListRoot;\nvoid voiceSetPriority(SYNTH_VOICE* svoice, u8 prio);\nu32 voiceIsLastStarted(SYNTH_VOICE* svoice);\nvoid voiceSetLastStarted(SYNTH_VOICE* svoice);\nvoid voiceResetLastStarted(SYNTH_VOICE* svoice);\nvoid voiceInitLastStarted();\ns32 voiceKillSound(u32 voiceid);\nvoid voiceKill(u32 vi);\n\nextern u64 synthRealTime;\nu32 synthGetTicksPerSecond(SYNTH_VOICE* svoice);\nvoid synthKillVoicesByMacroReferences(u16* ref);\nvoid synthExit();\nu16 sndRand(void);\ns16 sndSin(u16 angle);\nvoid* sndBSearch(void* key, void* base, s32 num, s32 len, SND_COMPARE cmp);\nvoid sndConvertMs(u32* time);\nvoid sndConvertTicks(u32* out, SYNTH_VOICE* svoice);\nu32 sndConvert2Ms(u32 time);\nu32 sndStreamAllocLength(u32 num, u32 flags);\nvoid sndStreamFree(u32 stid);\nu32 sndStreamActivate(u32 stid);\nvoid sndStreamDeactivate(u32 stid);\n\nvoid hwActivateStudio(u8 studio, u32 isMaster, SND_STUDIO_TYPE type);\nvoid hwDeactivateStudio(u8);\nvoid hwSetPriority(u32 v, u32 prio);\nu32 hwIsActive(u32);\nu32 hwGlobalActivity();\nvoid hwSetAUXProcessingCallbacks(u8 studio, SND_AUX_CALLBACK auxA, void* userA,\n                                 SND_AUX_CALLBACK auxB, void* userB);\nu8 hwInitStream(u32 len);\nu8 hwGetTimeOffset();\nu32 hwGetVirtualSampleID(u32 v);\ns16 varGet(SYNTH_VOICE* svoice, u32 ctrl, u8 index);\n\nu32 sndGetPitch(u8 key, u32 sInfo);\ns32 sndPitchUpOne(u16 note);\nextern SND_HOOKS salHooks;\nextern u8 sndActive;\nextern u8 synthIdleWaitActive;\nextern SynthInfo synthInfo;\ntypedef s32 (*SND_MESSAGE_CALLBACK)(u32, u32);\ntypedef void (*SYNTH_MESSAGE_CALLBACK)(u32, s32);\ntypedef void (*SND_SOME_CALLBACK)();\n\nextern SND_MESSAGE_CALLBACK salMessageCallback;\nextern SYNTH_MESSAGE_CALLBACK synthMessageCallback;\n/* Math */\nvoid salApplyMatrix(const SND_FMATRIX* a, const SND_FVECTOR* b, SND_FVECTOR* out);\nf32 salNormalizeVector(SND_FVECTOR* vec);\nvoid salCrossProduct(SND_FVECTOR* out, const SND_FVECTOR* a, const SND_FVECTOR* b);\n\n#define SAL_CROSS_PRODUCT(out, a, b)                                                               \\\n  do {                                                                                             \\\n    out.x = (a.y * b.z) - (a.z * b.y);                                                             \\\n    out.y = (a.z * b.x) - (a.x * b.z);                                                             \\\n    out.z = (a.x * b.y) - (a.y * b.x);                                                             \\\n  } while (0)\n\nvoid salInvertMatrix(SND_FMATRIX* out, const SND_FMATRIX* in);\n\n/* hardware */\nu32 salInitAi(SND_SOME_CALLBACK, u32, u32*);\nu32 salInitDsp(u32);\nu32 salInitDspCtrl(u8 numVoices, u8 numStudios, u32 defaultStudioDPL2);\nu32 salStartAi();\nvoid salInitHRTFBuffer();\nvoid salActivateVoice(DSPvoice* dsp_vptr, u8 studio);\nvoid salDeactivateVoice(DSPvoice* dsp_vptr);\nvoid salActivateStudio(u8 studio, u32 isMaster, SND_STUDIO_TYPE type);\nvoid salDeactivateStudio(u8 studio);\nvoid salActivateVoice(DSPvoice* dsp_vptr, u8 studio);\nvoid salCalcVolume(u8 voltab_index, SAL_VOLINFO* vi, f32 vol, u32 pan, u32 span, f32 auxa, f32 auxb,\n                   u32 itd, u32 dpl2);\nvoid salReconnectVoice(DSPvoice* dsp_vptr, u8 studio);\nvoid* salMalloc(u32 len);\nvoid salFree(void* addr);\n\n#define SAL_MAX_STUDIONUM 8\nextern u8 salMaxStudioNum;\nextern u8 salNumVoices;\n\n/* Stream */\ntypedef s32 (*SND_STREAM_UPDATE_CALLBACK)(void* buffer1, u32 len1, void* buffer2, u32 len2,\n                                          void* user);\ntypedef struct SNDADPCMinfo {\n  // total size: 0x28\n  u16 numCoef;       // offset 0x0, size 0x2\n  u8 initialPS;      // offset 0x2, size 0x1\n  u8 loopPS;         // offset 0x3, size 0x1\n  s16 loopY0;        // offset 0x4, size 0x2\n  s16 loopY1;        // offset 0x6, size 0x2\n  s16 coefTab[8][2]; // offset 0x8, size 0x20\n} SNDADPCMinfo;\n\ntypedef struct STREAM_INFO {\n#if MUSY_VERSION >= MUSY_VERSION_CHECK(1, 5, 4)\n  u32 nextStreamHandle;\n#endif\n  u32 stid;\n  u32 flags;\n  u8 state;\n  u8 type;\n  /* These were moved to near the start of the structure in later versions */\n#if MUSY_VERSION >= MUSY_VERSION_CHECK(1, 5, 4)\n  u8 hwStreamHandle;\n  u8 lastPSFromBuffer;\n#endif\n  SND_STREAM_UPDATE_CALLBACK updateFunction;\n  s16* buffer;\n  u32 size;\n  u32 bytes;\n  u32 last;\n  SNDADPCMinfo adpcmInfo;\n  volatile SND_VOICEID voice;\n  u32 user;\n  u32 frq;\n  u8 prio;\n  u8 vol;\n  u8 pan;\n  u8 span;\n  u8 auxa;\n  u8 auxb;\n\n#if MUSY_VERSION >= MUSY_VERSION_CHECK(1, 5, 4)\n  u8 orgPan;\n  u8 orgSPan;\n#endif\n\n  u8 studio;\n  /* These were moved to near the start of the structure in later versions */\n#if MUSY_VERSION <= MUSY_VERSION_CHECK(1, 5, 3)\n  u8 hwStreamHandle;\n  u32 nextStreamHandle;\n#endif\n} STREAM_INFO;\n\n#if MUSY_VERSION >= MUSY_VERSION_CHECK(1, 5, 4)\nvoid streamOutputModeChanged();\n#endif\n\nu8 inpTranslateExCtrl(u8 ctrl);\nvoid inpSetGlobalMIDIDirtyFlag(u8 chan, u8 midiSet, s32 flag);\nvoid inpAddCtrl(CTRL_DEST* dest, u8 ctrl, s32 scale, u8 comb, u32 isVar);\nvoid inpSetMidiCtrl(u8 ctrl, u8 channel, u8 set, u8 value);\nvoid inpSetMidiCtrl14(u8 ctrl, u8 channel, u8 set, u16 value);\nvoid inpSetExCtrl(SYNTH_VOICE* svoice, u8 ctrl, s16 v);\nCHANNEL_DEFAULTS* inpGetChannelDefaults(u8 midi, u8 midiSet);\nextern CTRL_DEST inpAuxA[8][4];\nextern CTRL_DEST inpAuxB[8][4];\nvoid inpSetMidiLastNote(u8 midi, u8 midiSet, u8 key);\nu8 inpGetMidiLastNote(u8 midi, u8 midiSet);\nu16 inpGetExCtrl(SYNTH_VOICE* svoice, u8 ctrl);\nu16 inpGetMidiCtrl(u8 ctrl, u8 channel, u8 set);\nvoid inpSetMidiLastNote(u8 midi, u8 midiSet, u8 key);\nu16 inpGetModulation(SYNTH_VOICE* svoice);\nvoid inpResetMidiCtrl(u8 ch, u8 set, u32 coldReset);\nvoid inpResetChannelDefaults(u8 midi, u8 midiSet);\nu16 inpGetPitchBend(SYNTH_VOICE* svoice);\nu16 inpGetDoppler(SYNTH_VOICE* svoice);\nu16 inpGetTremolo(SYNTH_VOICE* svoice);\nu16 inpGetPanning(SYNTH_VOICE* svoice);\nu16 inpGetSurPanning(SYNTH_VOICE* svoice);\nu16 inpGetVolume(SYNTH_VOICE* svoice);\nu16 inpGetReverb(SYNTH_VOICE* svoice);\nu16 inpGetPreAuxA(SYNTH_VOICE* svoice);\nu16 inpGetPostAuxA(SYNTH_VOICE* svoice);\nu16 inpGetPreAuxB(SYNTH_VOICE* svoice);\nu16 inpGetPostAuxB(SYNTH_VOICE* svoice);\nu16 inpGetPedal(SYNTH_VOICE* svoice);\nu16 inpGetAuxA(u8 studio, u8 index, u8 midi, u8 midiSet);\nu16 inpGetAuxB(u8 studio, u8 index, u8 midi, u8 midiSet);\nvoid inpInit(SYNTH_VOICE* svoice);\n\n/* TODO: Figure out what `unk` is */\nvoid hwSetSRCType(u32 v, u8 salSRCType);\nvoid hwSetITDMode(u32 v, u8 mode);\nvoid hwSetPolyPhaseFilter(u32 v, u8 salCoefSel);\nbool hwAddInput(u8 studio, SND_STUDIO_INPUT* in_desc);\nbool hwRemoveInput(u8 studio, SND_STUDIO_INPUT* in_desc);\nvoid hwChangeStudio(u32 v, u8 studio);\nvoid hwDisableHRTF();\nvoid hwStart(u32 v, u8 studio);\nvoid hwKeyOff(u32 v);\nvoid hwFrameDone();\n\nextern u32 dspHRTFOn;\n\nextern u16* dspCmdList;\nextern u16 dspCmdFirstSize;\n\nextern u8 dspScale2IndexTab[1024];\n\ntypedef void* (*ARAMUploadCallback)(u32, u32);\n\nu32 aramGetStreamBufferAddress(u8 id, u32* len);\nvoid aramUploadData(void* mram, u32 aram, u32 len, u32 highPrio, void (*callback)(u32), u32 user);\nvoid aramFreeStreamBuffer(u8 id);\nvoid* aramStoreData(void* src, u32 len);\nvoid aramRemoveData(void* aram, u32 len);\nu8 aramAllocateStreamBuffer(u32 len);\nu32 macStart(u16 macid, u8 priority, u8 maxVoices, u16 allocId, u8 key, u8 vol, u8 panning, u8 midi,\n             u8 midiSet, u8 section, u16 step, u16 trackid, u8 new_vid, u8 vGroup, u8 studio,\n             u32 itd);\nvoid macHandle(u32 deltaTime);\nvoid macMakeInactive(SYNTH_VOICE* svoice, MAC_STATE);\nvoid macSetPedalState(SYNTH_VOICE* svoice, u32 state);\nvoid macSetExternalKeyoff(SYNTH_VOICE* svoice);\nvoid macSampleEndNotify(SYNTH_VOICE* sv);\n\nvoid sndProfUpdateMisc(SND_PROFILE_INFO* info);\nvoid sndProfResetPMC(SND_PROFILE_DATA* info);\nvoid sndProfStartPMC(SND_PROFILE_DATA* info);\n\nvoid vidRemoveVoiceReferences(SYNTH_VOICE* svoice);\nu32 vidMakeNew(SYNTH_VOICE* svoice, u32 isMaster);\nu32 vidMakeRoot(SYNTH_VOICE* svoice);\n\nu32 adsrHandleLowPrecision(ADSR_VARS* adsr, u16* adsr_start, u16* adsr_delta);\nbool adsrRelease(ADSR_VARS* adsr);\n\n#ifdef __cplusplus\n}\n#endif\n#endif // _MUSYX_MUSYX_PRIV\n/* end \"musyx/musyx_priv.h\" */\n/* \"src/musyx/runtime/snd3d.c\" line 2 \"musyx/synth.h\" */\n#ifndef _MUSYX_SYNTH\n#define _MUSYX_SYNTH\n\n/* \"include/musyx/synth.h\" line 3 \"musyx/musyx_priv.h\" */\n/* end \"musyx/musyx_priv.h\" */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern SND_AUX_CALLBACK synthAuxACallback[8];\nextern u8 synthAuxAMIDI[8];\nextern u8 synthAuxAMIDISet[8];\nextern void* synthAuxAUser[8];\nextern SND_AUX_CALLBACK synthAuxBCallback[8];\nextern u8 synthAuxBMIDI[8];\nextern u8 synthAuxBMIDISet[8];\nextern void* synthAuxBUser[8];\n\nextern synthITDInfo synthITDDefault[8];\nextern u32 synthFlags;\n\nu32 vidGetInternalId(SND_VOICEID id);\nvoid synthKeyStateUpdate(SYNTH_VOICE* svoice);\nbool synthFXSetCtrl(SND_VOICEID vid, u8 ctrl, u8 value);\nbool synthFXSetCtrl14(SND_VOICEID vid, u8 ctrl, u16 value);\nbool synthSendKeyOff(SND_VOICEID vid);\nSND_VOICEID synthFXStart(u16 fid, u8 vol, u8 pan, u8 studio, u32 itd);\nvoid synthVolume(u8 volume, u16 time, u8 vGroup, u8 seqMode, u32 seqId);\nu32 synthStartSound(u16 id, u8 prio, u8 max,\n#if MUSY_VERSION >= MUSY_VERSION_CHECK(2, 0, 0)\n                    u32 sourceID,\n#endif\n                    u8 key, u8 vol, u8 panning, u8 midi, u8 midiSet, u8 section, u16 step,\n                    u16 trackid, u8 vGroup, s16 prioOffset, u8 studio, u32 itd);\nbool synthIsFadeOutActive(u8 vGroup);\n\n/* TODO: Move this where it belongs */\nvoid hwSetAUXProcessingCallbacks(u8 studio, SND_AUX_CALLBACK auxA, void* userA,\n                                 SND_AUX_CALLBACK auxB, void* userB);\n\nMSTEP* dataGetMacro(u16 mid);\n\nu32 voiceAllocate(u8 priority, u8 maxVoices, u16 allocId, u8 fxFlag);\nvoid voiceFree(SYNTH_VOICE* svoice);\nvoid synthActivateStudio(u8 studio, u32 isMaster, SND_STUDIO_TYPE type);\nvoid synthDeactivateStudio(u8 studio);\nu8 synthFXGetMaxVoices(u16 fid);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // _MUSYX_SYNTH\n/* end \"musyx/synth.h\" */", "diff_flags": [], "diff_label": "AddEmitter", "libraries": []}