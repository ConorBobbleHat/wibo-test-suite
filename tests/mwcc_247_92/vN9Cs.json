{"compiler": "mwcc_247_92", "compiler_flags": "-DMASTER -fp_contract on -RTTI off -nodefaults -Cpp_exceptions off -schedule on -opt level=4,peephole,speed -lang=c++ -char unsigned -str reuse,pool,readonly -fp hard -use_lmw_stmw on -pragma \"cpp_extensions on\" -sym on -enum int -inline off", "source_code": "#pragma section R \".sdata2\" data_mode=near_abs\n\nstatic F32 CalcRecipBlendMax(U16* timeOffs) SYMBOL(CalcRecipBlendMax__FPUs)\n{\n    F32 test, max = 0.0f;\n    while (timeOffs[0] != 0xFFFF) {\n        test = timeOffs[0] / 1024.0f + ((timeOffs[1] == 0) ? (0.0f) : (1.0f / (timeOffs[1] / 1024.0f)));\n        if (test > max) max = test;\n        timeOffs += 2;\n    }\n    if (max == 0.0f)\n        return 0.0f;\n    \n    return 1.0f / max;\n}", "context": "// Decomp attributes\n#define NONMATCHING\n#define SYMBOL(name)\n#define DUMMY_STRING(index, str) static const char* __UNUSED_STRING_##index = str\n#define DUMMY_FUNCTION(name) static void* __UNUSED_FUNCTION_##name = (void*)name\n\n// Dolphin\ntypedef signed char         s8;\ntypedef signed short        s16;\ntypedef signed long         s32;\ntypedef signed long long    s64;\ntypedef unsigned char       u8;\ntypedef unsigned short      u16;\ntypedef unsigned long       u32;\ntypedef unsigned long long  u64;\n\nstruct DVDDiskID\n{\n    char      gameName[4];\n    char      company[2];\n    u8        diskNumber;\n    u8        gameVersion;\n    u8        streaming;\n    u8        streamingBufSize; // 0 = default\n    u8        padding[22];      // 0's are stored\n};\n\ntypedef struct DVDCommandBlock DVDCommandBlock;\n\ntypedef void (*DVDCBCallback)(s32 result, DVDCommandBlock* block);\n\nstruct DVDCommandBlock\n{\n    DVDCommandBlock* next;\n    DVDCommandBlock* prev;\n    u32              command;\n    s32              state;\n    u32              offset;\n    u32              length;\n    void*            addr;\n    u32              currTransferSize;\n    u32              transferredSize;\n    DVDDiskID*       id;\n    DVDCBCallback    callback;\n    void*            userData;\n};\n\ntypedef struct DVDFileInfo  DVDFileInfo;\n\ntypedef void (*DVDCallback)(s32 result, DVDFileInfo* fileInfo);\n\nstruct DVDFileInfo\n{\n    DVDCommandBlock cb;\n    u32             startAddr;      // disk address of file\n    u32             length;         // file size in bytes\n    DVDCallback     callback;\n};\n\n// RenderWare\ntypedef long RwFixed;\ntypedef int  RwInt32;\ntypedef unsigned int RwUInt32;\ntypedef short RwInt16;\ntypedef unsigned short RwUInt16;\ntypedef unsigned char RwUInt8;\ntypedef signed char RwInt8;\ntypedef char RwChar;\ntypedef float RwReal;\ntypedef RwInt32 RwBool;\ntypedef long long RwInt64;\ntypedef unsigned long long RwUInt64;\n\ntypedef struct _RwUInt128 RwUInt128;\ntypedef struct _RwInt128 RwInt128;\n\nstruct _RwUInt128\n{\n    RwUInt64 top;\n    RwUInt64 bottom;\n};\n\nstruct _RwInt128\n{\n    RwInt64 top;\n    RwUInt64 bottom;\n};\n\n// Game\ntypedef signed char S8;\ntypedef signed short S16;\ntypedef signed int S32;\ntypedef signed long long S64;\ntypedef unsigned char U8;\ntypedef unsigned short U16;\ntypedef unsigned int U32;\ntypedef unsigned long long U64;\ntypedef float F32;\ntypedef double F64;\n\n#define NULL 0L\n#define FALSE 0\n#define TRUE !FALSE\n\n#define ALIGNED(a) __attribute__ ((aligned(a)))\n\n#define FORCEENUMSIZEINT ((S32)((~((U32)0))>>1))\n\ntypedef __typeof__(sizeof(0)) size_t;\n\n#define __std(ref) ref\n\ntypedef struct \n{\n\tunsigned int\topen_mode\t\t: 2;\n\tunsigned int\tio_mode\t\t\t: 3;\n\tunsigned int\tbuffer_mode\t\t: 2;\n\tunsigned int\tfile_kind\t\t: 3;\t\t/*- mm 980708 -*/\n\t\n\t#ifndef __NO_WIDE_CHAR\n\t\tunsigned int\tfile_orientation: 2;\n\t#endif /* not __NO_WIDE_CHAR */\n\t\n\tunsigned int\tbinary_io\t\t: 1;\n} __file_modes;\n\ntypedef struct \n{\n\tunsigned int\tio_state\t: 3;\n\tunsigned int\tfree_buffer\t: 1;\n\tunsigned char\teof;\n\tunsigned char\terror;\n} __file_state;\n\ntypedef unsigned long\t__file_handle;\n\ntypedef unsigned long\tfpos_t;\n\ntypedef struct _FILE FILE;\n\ntypedef void (* __idle_proc)  (void);\ntypedef int  (* __pos_proc)   (__file_handle file, fpos_t * position, int mode, __idle_proc idle_proc);     /*- mm 970708 -*/\ntypedef int  (* __io_proc)    (__file_handle file, unsigned char * buff, size_t * count, __idle_proc idle_proc);\ntypedef int\t (* __close_proc) (__file_handle file);\n\n#define __ungetc_buffer_size\t2\n\nstruct _FILE \n{\n\t__file_handle\t\thandle;\n\t__file_modes\t\tmode;\n\t__file_state\t\tstate;\n\t\n\t#ifndef _No_Disk_File_OS_Support\n\t\tunsigned char       is_dynamically_allocated;\t\t\t/*- mm 981007 -*/\n\t#endif  /* not _No_Disk_File_OS_Support */\n\t\n\tunsigned char\t\tchar_buffer;\n\tunsigned char\t\tchar_buffer_overflow;\n\tunsigned char\t\tungetc_buffer[__ungetc_buffer_size];\n\t\n\t#ifndef __NO_WIDE_CHAR\n\t\twchar_t\t\t\t\tungetwc_buffer[__ungetc_buffer_size];\n\t#endif /* not __NO_WIDE_CHAR */\n\t\n\tunsigned long\t\tposition;\n\tunsigned char *\t\tbuffer;\n\tunsigned long\t\tbuffer_size;\n\tunsigned char *\t\tbuffer_ptr;\n\tunsigned long\t\tbuffer_len;\n\tunsigned long\t\tbuffer_alignment;\n\tunsigned long\t\tsaved_buffer_len;\n\tunsigned long\t\tbuffer_pos;\n\t__pos_proc\t\t\tposition_proc;\n\t__io_proc\t\t\tread_proc;\n\t__io_proc\t\t\twrite_proc;\n\t__close_proc\t\tclose_proc;\n\t__idle_proc\t\t\tidle_proc;\n\t\n\t#ifndef _No_Disk_File_OS_Support\n\t\tstruct _FILE *      next_file_struct;\t\t\t\t\t\t/*- mm 981007 -*/\n\t#endif  /* not _No_Disk_File_OS_Support */\n};\n\n#define SEEK_SET\t0\n#define SEEK_CUR\t1\n#define SEEK_END\t2\n\n#define stdin  \t(&__std(__files[0]))   /*- mm 961031 -*/    /*- mm 961203 -*/ /*- mm 000201 -*/\n#define stdout\t(&__std(__files[1]))   /*- mm 961031 -*/    /*- mm 961203 -*/ /*- mm 000201 -*/\n#define stderr\t(&__std(__files[2]))   /*- mm 961031 -*/    /*- mm 961203 -*/ /*- mm 000201 -*/\n\nextern \"C\" FILE __files[];      /*- mm 961031 -*/    /*- mm 961203 -*/\n\nextern \"C\" size_t strlen(const char * );\nextern \"C\" char * strcpy(char * , const char * );\nextern \"C\" void * memset(void * , int , size_t );\nextern \"C\" void * memcpy (void * , const void * , size_t );\nextern \"C\" double atan2(double , double);\nextern \"C\" double fmod(double, double );\nextern \"C\" double floor(double);\nextern \"C\" int rand (void);\nextern \"C\" int isdigit(int c);\nextern \"C\" int fprintf(FILE *  , const char * , ...);\nextern \"C\" int sprintf (char * , const char * , ...);\nextern \"C\" int strcmp (const char * , const char * );\nextern \"C\" char * strncpy(char * , const char * , size_t );\nextern \"C\" char * strcat (char * , const char * );\n\nnamespace std {\n    inline float atan2f(float y, float x) { return atan2(y, x); }\n    inline float floorf(float x) { return floor(x); }\n    inline float fmodf(float x, float y) { return fmod(x, y); }\n}\n\nvoid OSReport ( const char* msg, ... );\n\ntypedef struct RwRGBA RwRGBA;\nstruct RwRGBA\n{\n    RwUInt8 red;    /**< red component */\n    RwUInt8 green;  /**< green component */\n    RwUInt8 blue;   /**< blue component */\n    RwUInt8 alpha;  /**< alpha component */\n};\n\n#define RWALIGN(type, x)   type /* nothing */\n#define rwMATRIXALIGNMENT sizeof(RwUInt32)\n#define rwFRAMEALIGNMENT sizeof(RwUInt32)\n#define rwV4DALIGNMENT sizeof(RwUInt32)\n\nstruct RwV3d\n{\n    RwReal x;   /**< X value */\n    RwReal y;   /**< Y value */\n    RwReal z;   /**< Z value */\n};\n\nstruct RwMatrixTag\n{\n    /* These are padded to be 16 byte quantities per line */\n    RwV3d               right;\n    RwUInt32            flags;\n    RwV3d               up;\n    RwUInt32            pad1;\n    RwV3d               at;\n    RwUInt32            pad2;\n    RwV3d               pos;\n    RwUInt32            pad3;\n};\n\ntypedef struct RwMatrixTag RWALIGN(RwMatrix, rwMATRIXALIGNMENT);\n\nstruct RpAtomic;\n\n#define iabs(x) ((F32)__fabs(x))\n\nF32 isin(F32 f);\n\n#define PI 3.14159265359\n\n#define xdeg2rad(x) (F32)(PI * (x) / 180.0)\n#define xrad2deg(x) (F32)(180.0 * (x) / PI)\n\n#define xmin(a, b) ((a) < (b) ? (a) : (b))\n#define xmax(a, b) ((a) > (b) ? (a) : (b))\n#define xclamp(x, a, b) (xmax((a), xmin((x), (b))))\n#define xlerp(a, b, t) ((a) + (t) * ((b) - (a)))\n\n#define xmin3(a, b, c) (xmin(xmin((a), (b)), (c)))\n#define xmax3(a, b, c) (xmax(xmax((a), (b)), (c)))\n\n#define xalign(x, a) (((x) + (a)) & ~((a) - 1))\n\n#define xsqr(x) ((x) * (x))\n#define xabs(x) iabs(x)\n\n#define xapproxeq(a, b) (xabs((a) - (b)) <= 0.00001f)\n\nF32 xAngleClampFast(F32 a);\nF32 xsqrt(F32 x);\n\n// xMathInlines.h\n// - #include \"xMathInlines.h\" at bottom of xMath.h in release/master\n// - #include \"xMathInlines.h\" in xMath.cpp in debug. Leave the forward declarations in xMath.h\n\n#ifdef DEBUG\n#define XMATHINLINE\n#else\n#define XMATHINLINE inline\n#endif\n\n#line 65\nXMATHINLINE F32 xfmod(F32 x, F32 y) SYMBOL(xfmod__Fff)\n{\n    return std::fmodf(x, y);\n}\n#line 159\nXMATHINLINE F32 xatan2(F32 y, F32 x) SYMBOL(xatan2__Fff)\n{\n    return xAngleClampFast(std::atan2f(y, x));\n}\n\nstruct xVec2\n{\n    F32 x;\n    F32 y;\n};\n\nstruct xVec3\n{\n    union\n    {\n        RwV3d m_RwV3d;\n\n        struct\n        {\n            F32 x;\n            F32 y;\n            F32 z;\n        };\n\n        F32 a[3];\n    };\n\n#line 43\n    xVec3& assign(F32 x, F32 y, F32 z) { this->x = x; this->y = y; this->z = z; return *this; }\n\n#line 64\n    xVec3& cross(const xVec3& c0, const xVec3& c1)\n    {\n        x = c0.y * c1.z - c1.y * c0.z;\n        y = c0.z * c1.x - c1.z * c0.x;\n        z = c0.x * c1.y - c1.x * c0.y;\n        return *this;\n    }\n\n#line 80\n    F32 dot(const xVec3& c) const { return x * c.x + y * c.y + z * c.z; }\n    F32 length() const { return xsqrt(length2()); }\n    F32 length2() const { return xsqr(x) + xsqr(y) + xsqr(z); }\n\n#line 1355\n    void AddScale(const xVec3& d, F32 s) SYMBOL(AddScale__5xVec3FRC5xVec3f)\n    {\n        x += d.x * s;\n        y += d.y * s;\n        z += d.z * s;\n    }\n\n#line 1369\n    void Sub(const xVec3& a, const xVec3& b)\n    {\n        x = a.x - b.x;\n        y = a.y - b.y;\n        z = a.z - b.z;\n    }\n\n#line 1404\n    void ScaleDiff(const xVec3& a, const xVec3& b, F32 scale)\n    {\n        x = scale * (a.x - b.x);\n        y = scale * (a.y - b.y);\n        z = scale * (a.z - b.z);\n    }\n\n#line 1425\n    void Add(const xVec3& a)\n    {\n        x += a.x;\n        y += a.y;\n        z += a.z;\n    }\n\n#line 1481\n    void Scale(F32 scalar)\n    {\n        x *= scalar;\n        y *= scalar;\n        z *= scalar;\n    }\n\n#line 1509\n    F32 Distance(const xVec3& other) const\n    {\n        xVec3 diff;\n        diff.Sub(other, *this);\n        return diff.length();\n    }\n\n#line 1516\n    F32 Distance2(const xVec3& other) const\n    {\n        xVec3 diff;\n        diff.Sub(other, *this);\n        return diff.length2();\n    }\n\n    void AddScale(const xVec3& p, const xVec3& d, F32 s);\n};\n\nvoid xVec3Init(xVec3* v, F32 _x, F32 _y, F32 _z);\nvoid xVec3Sub(xVec3* o, const xVec3* a, const xVec3* b);\nvoid xVec3SMulBy(xVec3* v, F32 s);\nvoid xVec3AddTo(xVec3* a, const xVec3* b);\nvoid xVec3Copy(xVec3* o, const xVec3* v);\nvoid xVec3SMul(xVec3* o, const xVec3* v, F32 s);\nvoid xVec3Inv(xVec3* o, const xVec3* v);\nvoid xVec3Add(xVec3* o, const xVec3* a, const xVec3* b);\n\n#define xVec3AddSMul(o, a, b, s)\\\n    xVec3Add((o), (a), (b));\\\n    xVec3SMul((o), (o), (s));\n\n#define xVec3NormalizeFast(o, v, outlen)                                                           \\\n    do {                                                                                           \\\n        F32 len2 = xsqr((v)->x) + xsqr((v)->y) + xsqr((v)->z);                                     \\\n        if (xapproxeq(len2, 1.0f))                                                                 \\\n        {                                                                                          \\\n            (o)->x = (v)->x;                                                                       \\\n            (o)->y = (v)->y;                                                                       \\\n            (o)->z = (v)->z;                                                                       \\\n            *(outlen) = 1.0f;                                                                      \\\n        }                                                                                          \\\n        else if (xapproxeq(len2, 0.0f))                                                            \\\n        {                                                                                          \\\n            (o)->x = 0.0f;                                                                         \\\n            (o)->y = 1.0f;                                                                         \\\n            (o)->z = 0.0f;                                                                         \\\n            *(outlen) = 0.0f;                                                                      \\\n        }                                                                                          \\\n        else                                                                                       \\\n        {                                                                                          \\\n            *(outlen) = xsqrt(len2);                                                               \\\n            F32 len_inv = 1.0f / *(outlen);                                                        \\\n            (o)->x = (v)->x * len_inv;                                                             \\\n            (o)->y = (v)->y * len_inv;                                                             \\\n            (o)->z = (v)->z * len_inv;                                                             \\\n        }                                                                                          \\\n    } while (0)\n\n#define xVec3NormalizeXZFast(o, v, outlen)                                                         \\\n    do {                                                                                           \\\n        F32 len2 = xsqr((v)->x) + xsqr((v)->z);                                                    \\\n        if (xapproxeq(len2, 1.0f))                                                                 \\\n        {                                                                                          \\\n            (o)->x = (v)->x;                                                                       \\\n            (o)->z = (v)->z;                                                                       \\\n            *(outlen) = 1.0f;                                                                      \\\n        }                                                                                          \\\n        else if (xapproxeq(len2, 0.0f))                                                            \\\n        {                                                                                          \\\n            (o)->x = 0.0f;                                                                         \\\n            (o)->z = 0.0f;                                                                         \\\n            *(outlen) = 0.0f;                                                                      \\\n        }                                                                                          \\\n        else                                                                                       \\\n        {                                                                                          \\\n            *(outlen) = xsqrt(len2);                                                               \\\n            F32 len_inv = 1.0f / *(outlen);                                                        \\\n            (o)->x = (v)->x * len_inv;                                                             \\\n            (o)->z = (v)->z * len_inv;                                                             \\\n        }                                                                                          \\\n    } while (0)\n\n// xVec3Inlines.h\n// - #include \"xVec3Inlines.h\" at bottom of xVec3.h in release/master\n// - #include \"xVec3Inlines.h\" in xVec3.cpp in debug. Leave the forward declarations in xVec3.h\n\n#ifdef DEBUG\n#define XVEC3INLINE\n#else\n#define XVEC3INLINE inline\n#endif\n\n#line 22\nXVEC3INLINE void xVec3Init(xVec3* v, F32 _x, F32 _y, F32 _z) SYMBOL(xVec3Init__FP5xVec3fff)\n{\n    v->x = _x, v->y = _y, v->z = _z;\n}\n#line 154\nXVEC3INLINE void xVec3AddTo(xVec3* a, const xVec3* b) SYMBOL(xVec3AddTo__FP5xVec3PC5xVec3)\n{\n    a->x += b->x, a->y += b->y, a->z += b->z;\n}\n#line 198\nXVEC3INLINE void xVec3Sub(xVec3* o, const xVec3* a, const xVec3* b) SYMBOL(xVec3Sub__FP5xVec3PC5xVec3PC5xVec3)\n{\n    o->x = a->x - b->x, o->y = a->y - b->y, o->z = a->z - b->z;\n}\n#line 247\nXVEC3INLINE void xVec3SMul(xVec3* o, const xVec3* v, F32 s) SYMBOL(xVec3SMul__FP5xVec3PC5xVec3f)\n{\n    o->x = v->x * s, o->y = v->y * s, o->z = v->z * s;\n}\n#line 265\nXVEC3INLINE void xVec3SMulBy(xVec3* v, F32 s) SYMBOL(xVec3SMulBy__FP5xVec3f)\n{\n    v->x *= s, v->y *= s, v->z *= s;\n}\n#line 421\nXVEC3INLINE void xVec3Inv(xVec3* o, const xVec3* v) SYMBOL(xVec3Inv__FP5xVec3PC5xVec3)\n{\n    o->x = -v->x, o->y = -v->y, o->z = -v->z;\n}\n\nstruct xMat3x3\n{\n    xVec3 right;\n    S32 flags;\n    xVec3 up;\n    U32 pad1;\n    xVec3 at;\n    U32 pad2;\n} ALIGNED(16);\n\nstruct xMat4x3 : xMat3x3\n{\n    xVec3 pos;\n    U32 pad3;\n} ALIGNED(16);\n\nstruct xQuat\n{\n    xVec3 v;\n    F32 s;\n};\n\nstruct xBox\n{\n    xVec3 upper;\n    xVec3 lower;\n};\n\nstruct xSphere\n{\n    xVec3 center;\n    F32 r;\n};\n\nstruct xBBox\n{\n    xVec3 center;\n    xBox box;\n};\n\nstruct xCylinder\n{\n    xVec3 center;\n    F32 r;\n    F32 h;\n};\n\nstruct xRay3\n{\n    xVec3 origin;\n    xVec3 dir;\n    F32 min_t;\n    F32 max_t;\n    S32 flags;\n};\n\nstruct xIsect\n{\n    U32 flags;\n    F32 penned;\n    F32 contained;\n    F32 lapped;\n    xVec3 point;\n    xVec3 norm;\n    F32 dist;\n};\n\nextern xVec3 g_O3;\nextern xMat4x3 g_I3;\n\nvoid xMat3x3RotY(xMat3x3* m, F32 t);\nvoid xQuatMul(xQuat* o, const xQuat* a, const xQuat* b);\nvoid xBoxInitBoundOBB(xBox* o, const xBox* b, const xMat4x3* m);\nvoid xMat3x3Tolocal(xVec3* o, const xMat3x3* m, const xVec3* v);\n\n#line 2810\nstatic inline void xMat3x3RMulVec(xVec3* o, const xMat3x3* m, const xVec3* v) SYMBOL(xMat3x3RMulVec__FP5xVec3PC7xMat3x3PC5xVec3)\n{\n#line 2845\n    F32 x = m->right.x * v->x + m->up.x * v->y + m->at.x * v->z;\n    F32 y = m->right.y * v->x + m->up.y * v->y + m->at.y * v->z;\n    F32 z = m->right.z * v->x + m->up.z * v->y + m->at.z * v->z;\n    o->x = x, o->y = y, o->z = z;\n\n}\n\n#line 3638\ninline void xMat4x3ToWorld(xVec3* o, const xMat4x3* m, const xVec3* v) NONMATCHING\n{\n#line 3675\n    xMat3x3RMulVec(o, m, v);\n    o->x += m->pos.x, o->y += m->pos.y, o->z += m->pos.z;\n\n}\n\n#line 3736\ninline void xMat4x3ToLocal(xVec3* o, const xMat4x3* m, const xVec3* v)\n{\n    o->x = v->x - m->pos.x, o->y = v->y - m->pos.y, o->z = v->z - m->pos.z;\n    xMat3x3Tolocal(o, m, o);\n}\n\nvoid iBoxIsectRay(const xBox* b, const xRay3* r, xIsect* isx);\nvoid iSphereIsectRay(const xSphere* s, const xRay3* r, xIsect* isx);\nvoid iSphereIsectVec(const xSphere* s, const xVec3* v, xIsect* isx);\nvoid iBoxIsectVec(const xBox* b, const xVec3* v, xIsect* isx);\n\nstruct xBound;\n\nstruct xQCData\n{\n    S8 xmin;\n    S8 ymin;\n    S8 zmin;\n    S8 zmin_dup;\n    S8 xmax;\n    S8 ymax;\n    S8 zmax;\n    S8 zmax_dup;\n    xVec3 min;\n    xVec3 max;\n};\n\nstruct xQCControl\n{\n    F32 world_xmin;\n    F32 world_ymin;\n    F32 world_zmin;\n    F32 world_xmax;\n    F32 world_ymax;\n    F32 world_zmax;\n    F32 world_xsz;\n    F32 world_ysz;\n    F32 world_zsz;\n    F32 scale_x;\n    F32 scale_y;\n    F32 scale_z;\n    F32 center_x;\n    F32 center_y;\n    F32 center_z;\n};\n\nextern xQCControl xqc_def_ctrl;\n\nvoid xQuickCullForBound(xQCData* q, const xBound* b);\nvoid xQuickCullDebugRegister(const xQCData* q);\nS32 xQuickCullIsects(const xQCData* a, const xQCData* b);\nvoid xQuickCullForSphere(xQCControl* ctrl, xQCData* q, const xSphere* s);\nvoid xQuickCullForBound(xQCControl* ctrl, xQCData* q, const xBound* b);\n\n#line 238\ninline void xQuickCullForBound(xQCData* q, const xBound* b)\n{\n    xQuickCullForBound(&xqc_def_ctrl, q, b);\n}\n\n#line 298\ninline void xQuickCullForSphere(xQCData* q, const xSphere* s)\n{\n    xQuickCullForSphere(&xqc_def_ctrl, q, s);\n}\n\nstruct xBound\n{\n    xQCData qcd;\n    U8 type;\n    U8 pad[3];\n    union\n    {\n        xSphere sph;\n        xBBox box;\n        xCylinder cyl;\n    };\n    xMat4x3* mat;\n};\n\nenum\n{\n    // Present in assert strings\n    k_XBOUNDTYPE_SPHERE = 1,\n    k_XBOUNDTYPE_OBB = 4,\n\n    // Guessed based on context\n    k_XBOUNDTYPE_NONE = 0,\n    k_XBOUNDTYPE_BOX = 2,\n    k_XBOUNDTYPE_CYL = 3\n};\n\nstruct xModelInstance;\n\nstruct xCollis\n{\n    struct tri_data\n    {\n        U32 index;\n        F32 r;\n        F32 d;\n    };\n    U32 flags;\n    U32 oid;\n    void* optr;\n    xModelInstance* mptr;\n    F32 dist;\n    F32 test_dist;\n    xVec3 norm;\n    xVec3 tohit;\n    xVec3 depen;\n    xVec3 hdng;\n    union\n    {\n        struct\n        {\n            F32 t;\n            F32 u;\n            F32 v;\n        } tuv;\n        tri_data tri;\n    };\n};\n\n// Present in assert strings\n#define k_HIT_IT ((U32)(1 << 0))\n#define k_HIT_CALC_HDNG ((U32)(1 << 12))\n#define k_HIT_CALC_TRI ((U32)(1 << 13))\n\n// Guessed based on context\n#define k_HIT_0x10 ((U32)(1 << 4))\n\nU32 xSphereHitsOBB_nu(const xSphere* s, const xBox* b, const xMat4x3* m, xCollis* coll);\nU32 xSphereHitsSphere(const xSphere* a, const xSphere* b, xCollis* coll);\nU32 xSphereHitsBox(const xSphere* a, const xBox* b, xCollis* coll);\nU32 xBoxHitsSphere(const xBox* a, const xSphere* b, xCollis* coll);\nU32 xBoxHitsObb(const xBox* a, const xBox* b, const xMat4x3* mat, xCollis* coll);\nU32 xObbHitsObb(const xBox* a, const xMat4x3* a_mat, const xBox* b, const xMat4x3* b_mat, xCollis* coll);\nU32 xSphereHitsVCylinder(const xSphere* sph, const xCylinder* cyl, xCollis* coll);\nU32 xCylinderHitsSphere(const xCylinder* cyl, const xSphere* sph, xCollis* coll);\nS32 xSphereHitsModel3(const xSphere* b, const xModelInstance* m, xCollis* colls, U8 ncolls, F32 sth);\nbool xSphereHitsOBB(const xSphere& o, const xBox& b, const xMat4x3& mat);\nbool xOBBHitsOBB(const xBox& a, const xMat4x3& amat, const xBox& b, const xMat4x3& bmat);\nbool xSphereHitsBox(const xVec3& c, F32 r, const xBox& b);\n\n#line 706\ninline bool xSphereHitsSphere(const xVec3& loc1, F32 r1, const xVec3& loc2, F32 r2)\n{\n    F32 dist2 = loc2.Distance2(loc1);\n    F32 max_dist = r1 + r2;\n    return dist2 <= xsqr(max_dist);\n}\ninline bool xSphereHitsSphere(const xSphere& o1, const xSphere& o2)\n{\n    return xSphereHitsSphere(o1.center, o1.r, o2.center, o2.r);\n}\n\n\n\n\n\n\n\n\n\n\ninline bool xSphereHitsBox(const xSphere& o, const xBox& b)\n{\n    return xSphereHitsBox(o.center, o.r, b);\n}\n\n\ninline bool xSphereHitsOBB(const xVec3& c, F32 r, const xBox& b, const xMat4x3& mat)\n{\n    xVec3 lc;\n    xMat4x3ToLocal(&lc, &mat, &c);\n    return xSphereHitsBox(lc, r, b);\n}\ninline bool xSphereHitsOBB(const xSphere& o, const xBox& b, const xMat4x3& mat)\n{\n    return xSphereHitsOBB(o.center, o.r, b, mat);\n}\n\n\n\n\n\ninline bool xBoxHitsBox(const xBox& a, const xBox& b)\n{\n    return\n        a.upper.x >= b.lower.x &&\n        a.upper.y >= b.lower.y &&\n        a.upper.z >= b.lower.z &&\n        a.lower.x <= b.upper.x &&\n        a.lower.y <= b.upper.x &&\n        a.lower.z <= b.upper.z;\n}\n\nvoid xDrawSphere2(const xSphere* sph, U32 lod);\nvoid xDrawOBB(const xBox* b, const xMat4x3* m);\nvoid xDrawBox(const xBox* b);\n\nenum xSndHandle\n{\n};\n\nextern U8* g_iAnim_workBuffer;\n\nvoid iAnimInit();\nvoid iAnimEval(void* RawData, F32 time, U32 flags, xVec3* tran, xQuat* quat);\nF32 iAnimDuration(void* RawData);\nU32 iAnimBoneCount(void* RawData);\nvoid iAnimBlend(F32 BlendFactor, F32 BlendRecip, U16* BlendTimeOffset, F32* BoneTable, U32 BoneCount, xVec3* Tran1, xQuat* Quat1, xVec3* Tran2, xQuat* Quat2, xVec3* TranDest, xQuat* QuatDest);\n\nstruct iAnimSKBHeader\n{\n    U32 Magic;\n    void* ExtractedData;\n    U16 BoneCount;\n    U16 TimeCount;\n    U16 KeyCount;\n    U16 TranCount;\n    F32 Scale[3];\n};\n\nS32 _iAnimSKBNumExtract(iAnimSKBHeader* data, U32 bone);\nS32 _iAnimSKBExtractTranslateAxis(iAnimSKBHeader* data, U32 bone, xVec3* tranArray, S32 tranCount, U8* axis);\nvoid _iAnimSKBAdjustTranslate(iAnimSKBHeader* data, U32 bone, F32* starttran, F32* endtran);\nS32 _iAnimSKBExtractYaw(iAnimSKBHeader* data, U32 bone, F32* yawArray, S32 yawCount);\nvoid _iAnimSKBAdjustYaw(iAnimSKBHeader* data, U32 bone, F32 yawStart, F32 yawEnd);\nF32 QuatToYaw(xQuat* q);\n\nstruct xMorphSeqFile\n{\n    U32 Magic;\n    U32 Flags;\n    U32 TimeCount;\n    U32 ModelCount;\n};\n\nF32 xMorphSeqDuration(xMorphSeqFile* seq);\n\nstruct xAnimPhysicsData;\nstruct xAnimFile;\nstruct xAnimMultiFileBase;\nstruct xAnimMultiFileEntry;\nstruct xAnimMultiFile;\nstruct xAnimEffect;\nstruct xAnimActiveEffect;\nstruct xAnimState;\nstruct xAnimTransition;\nstruct xAnimTransitionList;\nstruct xAnimSingle;\nstruct xAnimTable;\nstruct xAnimPlay;\n\nstruct xModelInstance;\nstruct xMemPool;\n\ntypedef U32(*xAnimEffectCallback)(U32, xAnimActiveEffect*, xAnimSingle*, void*);\ntypedef void(*xAnimBeforeEnterCallback)(xAnimPlay*, xAnimState*, void*);\ntypedef void(*xAnimStateCallback)(xAnimState*, xAnimSingle*, void*);\ntypedef void(*xAnimBeforeAnimMatricesCallback)(xAnimPlay*, xQuat*, xVec3*, S32);\ntypedef U32(*xAnimTransitionConditionalCallback)(xAnimTransition*, xAnimSingle*, void*);\ntypedef U32(*xAnimTransitionCallback)(xAnimTransition*, xAnimSingle*, void*);\n\nstruct xAnimPhysicsData\n{\n    xVec3* tranTable;\n    F32* yawTable;\n    S32 tranCount;\n};\n\nstruct xAnimFile\n{\n    xAnimFile* Next;\n    const char* Name;\n    U32 ID;\n    U32 FileFlags;\n    F32 Duration;\n    F32 TimeOffset;\n    U16 BoneCount;\n    U8 NumAnims[2];\n    void** RawData;\n    xAnimPhysicsData* PhysicsData;\n};\n\nenum\n{\n    // Present in assert strings\n    AnimFile_Reverse = 0x1000,\n    AnimFile_BackAndForth = 0x2000,\n\n    // Guessed based on context\n    AnimFile_Bilinear = 0x4000,\n    AnimFile_UseMorphSeq = 0x8000,\n    AnimFile_0x10000 = 0x10000,\n    AnimFile_0x20000 = 0x20000,\n    AnimFile_0x40000 = 0x40000,\n    AnimFile_0x80000 = 0x80000,\n    AnimFile_0xF0000Mask = 0xF0000\n};\n\n#define xAnimFileGetRawDuration(afile) (((afile)->FileFlags & AnimFile_UseMorphSeq) ? xMorphSeqDuration((xMorphSeqFile*)(afile)->RawData[0]) : iAnimDuration((afile)->RawData[0]))\n\nstruct xAnimMultiFileBase\n{\n    U32 Count;\n};\n\nstruct xAnimMultiFileEntry\n{\n    U32 ID;\n    xAnimFile* File;\n};\n\nstruct xAnimMultiFile : xAnimMultiFileBase\n{\n    xAnimMultiFileEntry Files[1];\n};\n\nstruct xAnimEffect\n{\n    xAnimEffect* Next;\n    U16 Flags;\n    U16 Probability;\n    F32 StartTime;\n    F32 EndTime;\n    xAnimEffectCallback Callback;\n};\n\nenum\n{\n    // Guessed based on context\n    AnimEffect_0x1 = 0x1,\n    AnimEffect_0x2 = 0x2,\n    AnimEffect_0x4 = 0x4,\n    AnimEffect_0x8 = 0x8,\n    AnimEffect_0x10 = 0x10,\n    AnimEffect_0x20 = 0x20\n};\n\nstruct xAnimActiveEffect\n{\n    xAnimEffect* Effect;\n    union\n    {\n        U32 Handle;\n        xSndHandle SndHandle;\n    };\n};\n\nstruct xAnimState\n{\n    xAnimState* Next;\n    const char* Name;\n    U32 ID;\n    U32 Flags;\n    U32 UserFlags;\n    F32 Speed;\n    xAnimFile* Data;\n    xAnimEffect* Effects;\n    xAnimTransitionList* Default;\n    xAnimTransitionList* List;\n    F32* BoneBlend;\n    F32* TimeSnap;\n    F32 FadeRecip;\n    U16* FadeOffset;\n    void* CallbackData;\n    xAnimMultiFile* MultiFile;\n    xAnimBeforeEnterCallback BeforeEnter;\n    xAnimStateCallback StateCallback;\n    xAnimBeforeAnimMatricesCallback BeforeAnimMatrices;\n};\n\nenum\n{\n    // Guessed based on context\n    AnimState_0xFMask = 0xF,\n    AnimState_0x10 = 0x10,\n    AnimState_0x20 = 0x20,\n    AnimState_0x30 = 0x30,\n    AnimState_0x40 = 0x40,\n    AnimState_0x70Mask = 0x70,\n    AnimState_0x100 = 0x100,\n    AnimState_0x200 = 0x200,\n    AnimState_0x400 = 0x400,\n    AnimState_0x800 = 0x800,\n\n    // Present in assert strings\n    AnimState_TempUsed = 0x80000000\n};\n\nstruct xAnimTransition\n{\n    xAnimTransition* Next;\n    xAnimState* Dest;\n    xAnimTransitionConditionalCallback Conditional;\n    xAnimTransitionCallback Callback;\n    U32 Flags;\n    U32 UserFlags;\n    F32 SrcTime;\n    F32 DestTime;\n    U16 Priority;\n    U16 QueuePriority;\n    F32 BlendRecip;\n    U16* BlendOffset;\n};\n\nenum\n{\n    // Guessed based on context\n    AnimTransition_0x2 = 0x2,\n    AnimTransition_0x4 = 0x4,\n    AnimTransition_0x8 = 0x8,\n    AnimTransition_0x10 = 0x10,\n    AnimTransition_0x20 = 0x20,\n    AnimTransition_0x40 = 0x40,\n    AnimTransition_0x80 = 0x80,\n    AnimTransition_0x100 = 0x100,\n\n    // Present in assert strings\n    AnimTransition_TempUsed = 0x80000000\n};\n\nstruct xAnimTransitionList\n{\n    xAnimTransitionList* Next;\n    xAnimTransition* T;\n};\n\nstruct xAnimSingle\n{\n    U32 SingleFlags;\n    xAnimState* State;\n    F32 Time;\n    F32 CurrentSpeed;\n    F32 BilinearLerp[2];\n    xAnimEffect* Effect;\n    U32 ActiveCount;\n    F32 LastTime;\n    xAnimActiveEffect* ActiveList;\n    xAnimPlay* Play;\n    xAnimTransition* Sync;\n    xAnimTransition* Tran;\n    xAnimSingle* Blend;\n    F32 BlendFactor;\n    xVec3 PhysDisp;\n    F32 YawDisp;\n    U32 pad[1];\n};\n\nenum\n{\n    // Guessed based on context\n    AnimSingle_0x1 = 0x1,\n    AnimSingle_0x2 = 0x2,\n    AnimSingle_0x4 = 0x4,\n    AnimSingle_0x8000 = 0x8000\n};\n\nstruct xAnimTable\n{\n    const char* Name;\n    xAnimTransition* TransitionList;\n    xAnimState* StateList;\n    U32 AnimIndex;\n    U32 MorphIndex;\n    U32 UserFlags;\n};\n\nstruct xAnimPlay\n{\n    xAnimPlay* Next;\n    U16 NumSingle;\n    U16 BoneCount;\n    xAnimSingle* Single;\n    void* Object;\n    xAnimTable* Table;\n    xMemPool* Pool;\n    xModelInstance* ModelInst;\n    xAnimBeforeAnimMatricesCallback BeforeAnimMatrices;\n};\n\nextern U32 gxAnimUseGrowAlloc;\n\n#define xAnimMemAlloc(size) (gxAnimUseGrowAlloc ? xMEMGROWALLOC((size)) : xMEMALLOC((size)))\n\nxAnimState* xAnimTableGetState(xAnimTable* table, const char* name);\nxAnimState* xAnimTableAddFileID(xAnimTable* table, xAnimFile* file, U32 stateID, U32 subStateID, U32 subStateCount);\nxAnimState* xAnimTableGetStateID(xAnimTable* table, U32 ID);\nvoid xAnimPlayStartTransition(xAnimPlay* play, xAnimTransition* transition);\n\n#line 703\ninline F32 xAnimFileRawTime(xAnimFile* afile, F32 time) SYMBOL(xAnimFileRawTime__FP9xAnimFilef)\n{\n    if ((afile->FileFlags & AnimFile_Reverse) ||\n        ((afile->FileFlags & AnimFile_BackAndForth) &&\n            time > 0.5f * afile->Duration)) {\n        return afile->TimeOffset + afile->Duration - time;\n    }\n    return afile->TimeOffset + time;\n}\n\nvoid iModelAnimMatrices(RpAtomic* model, xQuat* quat, xVec3* tran, RwMatrix* mat);\n\nstruct xModelInstance;\nstruct xModelPool;\nstruct xModelBucket;\nstruct xSurface;\nstruct xLightKit;\nstruct xLight;\n\nstruct xModelPipe\n{\n    U32 Flags;\n    U8 Layer;\n    U8 AlphaDiscard;\n    U16 PipePad;\n};\n\nstruct xModelInstance\n{\n    xModelInstance* Next;\n    xModelInstance* Parent;\n    xModelPool* Pool;\n    xAnimPlay* Anim;\n    RpAtomic* Data;\n    xModelPipe Pipe;\n    U8 InFrustum;\n    U8 TrueClip;\n    S8 sortBias;\n    U8 modelpad;\n    F32 RedMultiplier;\n    F32 GreenMultiplier;\n    F32 BlueMultiplier;\n    F32 Alpha;\n    F32 FadeStart;\n    F32 FadeEnd;\n    xSurface* Surf;\n    xModelBucket** Bucket;\n    xModelInstance* BucketNext;\n    xLightKit* LightKit;\n    xLightKit* LightKitBlend;\n    F32 BlendDuration;\n    F32 BlendTimeRemaining;\n    void* Object;\n    U16 Flags;\n    U8 BoneCount;\n    U8 BoneIndex;\n    U8* BoneRemap;\n    RwMatrix* Mat;\n    xVec3 Scale;\n    xBox animBound;\n    xBox combinedAnimBound;\n    U32 modelID;\n    U32 shadowID;\n    struct\n    {\n        xVec3* verts;\n    } anim_coll;\n    xLight* lights[4];\n    F32 lightsDistance[4];\n};\n\nenum\n{\n    // Guessed based on context\n    ModelInstance_0x4 = 0x4,\n    ModelInstance_0x80 = 0x80,\n    ModelInstance_0x100 = 0x100\n};\n\nstruct xModelPool\n{\n    xModelPool* Next;\n    U32 NumMatrices;\n    xModelInstance* List;\n};\n\nbool xModelIsPreinstanced(const xModelInstance* model);\n\nstruct xModelBucket\n{\n    RpAtomic* Data;\n    RpAtomic* OriginalData;\n    xModelInstance* List;\n    xModelBucket** BackRef;\n    S32 ClipFlags;\n    xModelPipe Pipe;\n};\n\n#define iprintf OSReport\n\nenum en_VERBOSE_MSGLEVEL\n{\n    DBML_NONE,\n    DBML_RELDISP,\n    DBML_DISP,\n    DBML_USER,\n    DBML_ERR,\n    DBML_TIME,\n    DBML_WARN,\n    DBML_VALID,\n    DBML_INFO,\n    DBML_DBG,\n    DBML_TEST,\n    DBML_VDBG,\n    DBML_SPEW\n};\n\n#line 40\nstatic inline void iDebugBreak()\n{\n    asm { opword 0 }\n}\n\nvoid xprintf(const char* fmt, ...);\nvoid xDebug_assert2_info(const char* func, const char* file, U32 line, const char* expr);\nvoid xDebug_assert2(const char* fmt, ...);\nU32 xDebugBoing();\nvoid xDebugStackTrace();\n#if defined(DEBUG) || defined(RELEASE)\nS32 xDebugModeAdd(const char* debugModeName, void(*func)());\n#else\n#define xDebugModeAdd(debugModeName, func)\n#endif\nvoid DBprintf(en_VERBOSE_MSGLEVEL msglvl, const char* fmt, ...);\nvoid xDebugValidateFailed();\n\n#if defined(DEBUG) || defined(RELEASE)\n#define xDEBUGMSGFMT(fmt, ...)                                                                            \\\n    do {                                                                                           \\\n\t    DBprintf(DBML_DBG, (fmt), __VA_ARGS__);                                                   \\\n    } while (0)\n\n#define xDEBUGMSG(fmt)                                                                            \\\n    do {                                                                                           \\\n\t    DBprintf(DBML_DBG, (fmt));                                                   \\\n    } while (0)\n\n#define xWARNFMT(fmt, ...)                                                                            \\\n    do {                                                                                           \\\n\t    DBprintf(DBML_WARN, (fmt), __VA_ARGS__);                                                   \\\n    } while (0)\n\n#define xWARN(fmt)                                                                            \\\n    do {                                                                                           \\\n\t    DBprintf(DBML_WARN, (fmt));                                                   \\\n    } while (0)\n\n#define xVALIDATE(expr)                                                                            \\\n    do {                                                                                           \\\n        if (!(expr)) {                                                                             \\\n            static int been_here;                                                                  \\\n            if (!been_here) {                                                                      \\\n                DBprintf(DBML_VALID, \"%s(%d) : (\" #expr \") in '%s'\\n\", __FILE__, __LINE__, __FUNCTION__);\\\n                xDebugValidateFailed();                                                            \\\n                been_here = 1;                                                                     \\\n            }                                                                                      \\\n        }                                                                                          \\\n    } while (0)\n\n#define xVERBOSEFMT(fmt, ...)                                                                            \\\n    do {                                                                                           \\\n\t    DBprintf(DBML_VDBG, (fmt), __VA_ARGS__);                                                   \\\n    } while (0)\n\n#define xVERBOSE(fmt)                                                                            \\\n    do {                                                                                           \\\n\t    DBprintf(DBML_VDBG, (fmt));                                                   \\\n    } while (0)\n\n#define _xASSERTERROR(expr, exprstr, msg)                                                          \\\n    do {                                                                                           \\\n        if (!(expr)) {                                                                             \\\n            xDebug_assert2_info(__FUNCTION__, __FILE__, __LINE__, exprstr);                        \\\n            xDebug_assert2(msg);                                                                   \\\n            xDebugStackTrace();                                                                    \\\n            if (xDebugBoing()) iDebugBreak();                                                      \\\n        }                                                                                          \\\n    } while (0)\n\n#define _xASSERTFMT(expr, exprstr, msg, ...)                                                       \\\n    do {                                                                                           \\\n        if (!(expr)) {                                                                             \\\n            xDebug_assert2_info(__FUNCTION__, __FILE__, __LINE__, exprstr);                        \\\n            xDebug_assert2(msg, __VA_ARGS__);                                                      \\\n            xDebugStackTrace();                                                                    \\\n            if (xDebugBoing()) iDebugBreak();                                                      \\\n        }                                                                                          \\\n    } while (0)\n\n#define xASSERTFMT(expr, msg, ...) _xASSERTFMT(expr, #expr, msg, __VA_ARGS__)\n#define xASSERT(expr) xASSERTFMT(expr, \"%s\", #expr)\n#define xASSERTERROR(expr, msg) _xASSERTERROR(expr, #expr, msg)\n#define xASSERTWARN(expr, msg) xASSERTFMT(expr, \"%s\", msg)\n#define xASSERTALWAYS(msg) _xASSERTFMT(0, \"*always*\", \"%s\", msg)\n\n#define xASSERTEQ(l, r)                                                                            \\\n    do {                                                                                           \\\n        size_t il = (l);                                                                           \\\n        size_t ir = (r);                                                                           \\\n        xASSERTFMT(il == ir, \"%s\", #l \"==\" #r);                                                    \\\n    } while (0)\n#else\n#define xDEBUGMSGFMT(fmt, ...)\n#define xDEBUGMSG(fmt)\n#define xWARNFMT(fmt, ...)\n#define xWARN(fmt)\n#define xVALIDATE(expr)\n#define xVERBOSEFMT(fmt, ...)\n#define xVERBOSE(fmt)\n#define xASSERTFMT(expr, msg, ...)\n#define xASSERT(expr)\n#define xASSERTERROR(expr, msg)\n#define xASSERTWARN(expr, msg)\n#define xASSERTALWAYS(msg)\n#define xASSERTEQ(l, r)\n#endif\n\nstruct substr\n{\n    const char* text;\n    size_t size;\n};\n\n#undef __FILE__\n#define __FILE__ \"xDebugTweak.h\"\n\nstruct tweak_info;\n\nstruct tweak_callback\n{\n    void(*on_change)(tweak_info&);\n    void(*on_select)(tweak_info&);\n    void(*on_unselect)(tweak_info&);\n    void(*on_start_edit)(tweak_info&);\n    void(*on_stop_edit)(tweak_info&);\n    void(*on_expand)(tweak_info&);\n    void(*on_collapse)(tweak_info&);\n    void(*on_update)(tweak_info&);\n    void(*convert_mem_to_tweak)(tweak_info&, void*);\n    void(*convert_tweak_to_mem)(tweak_info&, void*);\n};\n\nstruct tweak_info\n{\n    substr name;\n    void* value;\n    const tweak_callback* cb;\n    void* context;\n    U8 type;\n    U8 value_size;\n    U16 flags;\n    union\n    {\n        struct\n        {\n            S32 value_def;\n            S32 value_min;\n            S32 value_max;\n        } int_context;\n        struct\n        {\n            U32 value_def;\n            U32 value_min;\n            U32 value_max;\n        } uint_context;\n        struct\n        {\n            F32 value_def;\n            F32 value_min;\n            F32 value_max;\n        } float_context;\n        struct\n        {\n            bool value_def;\n        } bool_context;\n        struct\n        {\n            U32 value_def;\n            U32 labels_size;\n            const char** labels;\n            void* values;\n        } select_context;\n        struct\n        {\n            U32 value_def;\n            U32 mask;\n        } flag_context;\n        struct\n        {\n            U8 pad[16];\n        } all_context;\n    };\n};\n\nenum\n{\n    // Present in assert strings\n    DTF_BUFFER = 0x2,\n\n    // Guessed based on context\n    DTF_0x1 = 0x1\n};\n\nvoid xDebugRemoveTweak(const char* name);\nvoid xDebugAddFlagTweak(const char* name, S32* v, S32 mask, const tweak_callback* cb, void* context, U32 flags);\n\ntemplate <class value_type, class range_type>\nstatic inline void _t_auto_tweak(const char* prefix, const char* name, value_type* v, range_type vmin, range_type vmax, const tweak_callback* cb, void* context, U32 flags, bool process);\n\n#define xDEBUGAUTOTWEAK(prefix, name, v, vmin, vmax) _t_auto_tweak((prefix), (name), (v), (vmin), (vmax), NULL, NULL, 0, true)\n\nextern tweak_callback cb_tweak_convert_degrees;\n\nnamespace auto_tweak {\n    template <class value_type, class range_type>\n    static inline void add_tweak(const char* name, value_type* v, range_type vmin, range_type vmax, const tweak_callback* cb, void* context, U32 flags);\n}\n\n#define xDEBUGAUTORANGETWEAK(prefix, name, v, vmin, vmax, cb, context, flags)                      \\\n    do {                                                                                           \\\n        char _buffer[128];                                                                         \\\n        strcpy(_buffer, (prefix));                                                                 \\\n        strcat(_buffer, (name));                                                                   \\\n        auto_tweak::add_tweak(_buffer, (v), (vmin), (vmax), (cb), (context), (flags));             \\\n    } while (0)\n\n#define xDEBUGAUTOVEC3TWEAK(prefix, name, v, cb, context, flags)                                   \\\n    do {                                                                                           \\\n        char _buffer[128];                                                                         \\\n        strcpy(_buffer, (prefix));                                                                 \\\n        strcat(_buffer, (name));                                                                   \\\n        auto_tweak::add_tweak(_buffer, (v), 0, 0, (cb), (context), (flags));                       \\\n    } while (0)\n\n#define xDEBUGAUTOFLAGTWEAK(prefix, name, v, mask, cb, context, flags)                             \\\n    do {                                                                                           \\\n        char _buffer[128];                                                                         \\\n        strcpy(_buffer, (prefix));                                                                 \\\n        strcat(_buffer, (name));                                                                   \\\n        xDebugAddFlagTweak(_buffer, (v), (mask), (cb), (context), (flags));                        \\\n    } while (0)\n\ntypedef struct xColor_tag\n{\n    union\n    {\n        struct\n        {\n            U8 r;\n            U8 g;\n            U8 b;\n            U8 a;\n        };\n        RwRGBA rgba;\n    };\n} xColor;\n\nextern xColor g_RED;\nextern xColor g_LIGHT_RED;\nextern xColor g_GREEN;\nextern xColor g_BLUE;\nextern xColor g_DIRTY_BLUE;\nextern xColor g_CYAN;\nextern xColor g_MAGENTA;\nextern xColor g_YELLOW;\nextern xColor g_BLACK;\nextern xColor g_WHITE;\nextern xColor g_GRAY40;\nextern xColor g_GRAY50;\nextern xColor g_GRAY80;\nextern xColor g_CLEAR;\nextern xColor g_NEON_RED;\nextern xColor g_NEON_GREEN;\nextern xColor g_NEON_BLUE;\nextern xColor g_PEACH;\nextern xColor g_FUSCHIA;\nextern xColor g_MAROON;\nextern xColor g_MIDNIGHTBLUE;\nextern xColor g_SEAGREEN;\nextern xColor g_FORESTGREEN;\nextern xColor g_PIMP_GOLD;\nextern xColor g_LIGHT_PIMP_GOLD;\nextern xColor g_ORANGE;\nextern xColor g_KHAKI;\nextern xColor g_LAVENDER;\nextern xColor g_PINK;\nextern xColor g_CHARTREUSE;\nextern xColor g_COLOR_TRYME;\nextern xColor g_COLOR_TRYME2;\nextern xColor g_COLOR_TRYME3;\n\nvoid xDrawSetColor(xColor color);\nvoid xDrawSphere2(const xVec3* pos, F32 r, U32 lod);\nvoid xDrawCone(const xVec3& p1, F32 r1, const xVec3& p2, F32 r2, S32 sides, S32 rings);\n\nvoid* iMemPushTemp(U32 size);\nvoid iMemPopTemp(void* pointer);\n\n#undef __FILE__\n#define __FILE__ \"xMemMgr.h\"\n\nstruct xMemPool\n{\n    void* FreeList;\n    U16 NextOffset;\n    U16 Flags;\n    void* UsedList;\n    void(*InitCB)(xMemPool*, void*);\n    void* Buffer;\n    U16 Size;\n    U16 NumRealloc;\n    U32 Total;\n#ifdef DEBUG\n    U16 Allocated;\n    U16 Pad0;\n#endif\n};\n\nextern U32 gActiveHeap;\n\n#if defined(DEBUG) || defined(RELEASE)\nvoid* xMemGrowAlloc(U32 heapID, U32 size, U32 tag);\n#define xMEMGROWALLOC(size) (xMemGrowAlloc(gActiveHeap, (size), 1))\n#else\nvoid* xMemGrowAlloc(U32 heapID, U32 size);\n#define xMEMGROWALLOC(size) (xMemGrowAlloc(gActiveHeap, (size)))\n#endif\n\n#if defined(DEBUG)\nvoid* xMemAlloc(U32 heapID, U32 size, S32 align, U32 tag, U32 assetID, const char* file, const char* func, S32 line);\n#define xMEMALLOC(size) (xMemAlloc(gActiveHeap, (size), 0, 1, 0, __FILE__, __FUNCTION__, __LINE__))\n#elif defined(RELEASE)\nvoid* xMemAlloc(U32 heapID, U32 size, S32 align, U32 tag);\n#define xMEMALLOC(size) (xMemAlloc(gActiveHeap, (size), 0, 1))\n#else\nvoid* xMemAlloc(U32 heapID, U32 size, S32 align);\n#define xMEMALLOC(size) (xMemAlloc(gActiveHeap, (size), 0))\n#endif\n\nvoid xMemPoolSetup(xMemPool* pool, void* buffer, U32 nextOffset, U32 flags, void(*initCB)(xMemPool*, void*), U32 size, U32 count, U32 numRealloc);\nvoid* xMemPoolAlloc(xMemPool* pool, U32 memtag);\nvoid xMemPoolFree(xMemPool* pool, void* data);\nvoid* xMemScratchPush(U32 size, U32 align = 0);\nvoid xMemScratchPop(void* mem);\n\n#ifdef DEBUG\n#line 388\ninline void* xMemPushTemp(U32 amt, U32, const char* file, const char* func, S32 line) SYMBOL(xMemPushTemp__FUiUiPCcPCci)\n{\n    void* ptr = iMemPushTemp(amt);\n    xASSERTFMT(ptr, \"for %d bytes from %s, in %s line %d\", amt, func, file, line);\n    return ptr;\n}\n#define xMEMPUSHTEMP(amt) (xMemPushTemp((amt), 0, __FILE__, __FUNCTION__, __LINE__))\n#else\n#line 422\ninline void* xMemPushTemp(U32 amt) SYMBOL(xMemPushTemp__FUi)\n{\n    void* ptr = iMemPushTemp(amt);\n    xASSERT(ptr);\n    return ptr;\n}\n#define xMEMPUSHTEMP(amt) (xMemPushTemp((amt)))\n#endif\n\n#define xMEMPOPTEMP(pointer) iMemPopTemp((pointer))\n\nU32 xStrHash(const char* str);\nchar* xStrTokBuffer(const char* string, const char* control, void* buffer);\n\nU32 xrand_GenRandInt32();\n\n#line 80\ninline U32 xrand_RandomInt32()\n{\n    return xrand_GenRandInt32();\n}\n#line 162\ninline F32 xurand() SYMBOL(xurand__Fv)\n{\n    \n    return 2.3283064e-10f * xrand_RandomInt32(); // 0x2F800000\n}\n\nstruct st_SERIAL_CLIENTINFO;\n\nstruct xSerial\n{\nprivate:\n    U32 idtag;\n    S32 baseoff;\n    st_SERIAL_CLIENTINFO* ctxtdata;\n    S32 warned;\n    S32 curele;\n    S32 bitidx;\n    S32 bittally;\n\npublic:\n    S32 Write_b1(S32 bits);\n    S32 Read_b1(S32* bits);\n};\n\nstruct xLinkAsset\n{\n    U16 srcEvent;\n    U16 dstEvent;\n    U32 dstAssetID;\n    F32 param[4];\n    U32 paramWidgetAssetID;\n    U32 chkAssetID;\n};\n\nstruct xBaseAsset\n{\n    U32 id;\n    U8 baseType;\n    U8 linkCount;\n    U16 baseFlags;\n};\n\nstruct xBase;\n\ntypedef void(*xBaseEventCallback)(xBase*, xBase*, U32, F32*, xBase*, U32);\n\nstruct xBase\n{\n    U32 id;\n    U8 baseType;\n    U8 linkCount;\n    U16 baseFlags;\n    const xLinkAsset* link;\n    xBaseEventCallback eventFunc;\n};\n\n// Present in assert strings\n#define k_XBASE_IS_ENTITY ((U16)(1 << 5))\n#define k_XBASE_IS_NPC ((U16)(1 << 8))\n\n// Guessed based on context\n#define k_XBASE_IS_ENABLED ((U16)(1 << 0))\n#define k_XBASE_IS_PERSISTENT ((U16)(1 << 1))\n#define k_XBASE_IS_VALID ((U16)(1 << 2))\n#define k_XBASE_IS_VISIBLE_IN_CUTSCENES ((U16)(1 << 3))\n#define k_XBASE_RECEIVES_SHADOWS ((U16)(1 << 4))\n\n#line 90\ninline void xBaseEnable(xBase* xb)\n{\n    xb->baseFlags |= k_XBASE_IS_ENABLED;\n}\n\ninline void xBaseDisable(xBase* xb)\n{\n    xb->baseFlags &= (U16)~k_XBASE_IS_ENABLED;\n}\n\ninline bool xBaseIsEnabled(const xBase* xb)\n{\n    return xb->baseFlags & k_XBASE_IS_ENABLED;\n}\n\ninline void xBaseValidate(xBase* xb)\n{\n    xb->baseFlags |= k_XBASE_IS_VALID;\n}\n\nextern S32 xent_nqcrejects;\nextern S32 xent_entent;\n\nstruct xDynAsset : xBaseAsset\n{\n    U32 type;\n    U16 version;\n    U16 handle;\n};\n\nstruct tag_xFile;\n\nstruct tag_iFile\n{\n    U32 flags;\n    char path[128];\n    S32 fd;\n    DVDFileInfo file;\n    void(*cb)(tag_xFile*);\n    S32 akey;\n    S32 buffer[8];\n    S32 real_pos;\n};\n\nenum IFILE_READSECTOR_STATUS\n{\n    IFILE_RDSTAT_NOOP,\n    IFILE_RDSTAT_INPROG,\n    IFILE_RDSTAT_DONE,\n    IFILE_RDSTAT_FAIL,\n    IFILE_RDSTAT_QUEUED,\n    IFILE_RDSTAT_EXPIRED\n};\n\nU32 iFileOpen(const char* name, S32 flags, tag_xFile* file);\nU32 iFileClose(tag_xFile* file);\nS32 iFileSeek(tag_xFile* file, S32 offset, S32 whence);\nU32 iFileRead(tag_xFile* file, void* buf, U32 size);\nU32 iFileGetSize(tag_xFile* file);\nU32 iFileFind(const char* name, S32 fileflags, tag_xFile* file);\nvoid iFileGetInfo(tag_xFile* file, U32* starting_sector, U32* size_in_bytes);\nS32 iFileReadAsync(tag_xFile* file, void* buf, U32 asize, void(*dcb)(tag_xFile*), S32);\nIFILE_READSECTOR_STATUS iFileReadAsyncStatus(S32 key, S32* bytes_read);\n\nstruct tag_xFile\n{\n    char relname[32];\n    tag_iFile ps;\n    void* user_data;\n};\n\n#define XFILE_RELNAME_MAX 32\n\nenum XFILE_READSECTOR_STATUS\n{\n    XFILE_RDSTAT_NOOP,\n    XFILE_RDSTAT_INPROG,\n    XFILE_RDSTAT_DONE,\n    XFILE_RDSTAT_FAIL,\n    XFILE_RDSTAT_QUEUED,\n    XFILE_RDSTAT_EXPIRED\n};\n\n#undef __FILE__\n#define __FILE__ \"xFile.h\"\n\n#line 76\ninline void xFileSetUserData(tag_xFile* xf, void* p) { xf->user_data = p; }\ninline void* xFileGetUserData(tag_xFile* xf) { return xf->user_data; }\n\n#line 110\ninline XFILE_READSECTOR_STATUS xFileReadAsyncStatus(S32 key, S32* amtSoFar)\n{\n    XFILE_READSECTOR_STATUS x;\n    IFILE_READSECTOR_STATUS i;\n    \n    \n    xVALIDATE((x=XFILE_RDSTAT_INPROG) == (i=IFILE_RDSTAT_INPROG));\n    xVALIDATE((x=XFILE_RDSTAT_DONE) == (i=IFILE_RDSTAT_DONE));\n    xVALIDATE((x=XFILE_RDSTAT_FAIL) == (i=IFILE_RDSTAT_FAIL));\n    \n    \n    return (XFILE_READSECTOR_STATUS)iFileReadAsyncStatus(key, amtSoFar);\n}\n\nenum en_FIOERRCODES\n{\n    FIOERR_NONE,\n    FIOERR_READFAIL,\n    FIOERR_WRITEFAIL,\n    FIOERR_SEEKFAIL,\n    FIOERR_USERABORT\n};\n\nenum en_BIO_ASYNC_ERRCODES\n{\n    BINIO_ASYNC_FAIL = -1,\n    BINIO_ASYNC_NOOP = 0,\n    BINIO_ASYNC_INPROG,\n    BINIO_ASYNC_DONE,\n    BINIO_ASYNC_FORCEENUMSIZEINT = FORCEENUMSIZEINT\n};\n\nstruct st_FILELOADINFO\n{\n    void(*destroy)(st_FILELOADINFO*);\n    S32(*readBytes)(st_FILELOADINFO*, char*, S32);\n    S32(*readMShorts)(st_FILELOADINFO*, S16*, S32);\n    S32(*readMLongs)(st_FILELOADINFO*, S32*, S32);\n    S32(*readMFloats)(st_FILELOADINFO*, F32*, S32);\n    S32(*readMDoubles)(st_FILELOADINFO*, F64*, S32);\n    S32(*readIShorts)(st_FILELOADINFO*, S16*, S32);\n    S32(*readILongs)(st_FILELOADINFO*, S32*, S32);\n    S32(*readIFloats)(st_FILELOADINFO*, F32*, S32);\n    S32(*readIDoubles)(st_FILELOADINFO*, F64*, S32);\n    S32(*skipBytes)(st_FILELOADINFO*, S32);\n    S32(*seekSpot)(st_FILELOADINFO*, S32);\n    void(*setDoubleBuf)(st_FILELOADINFO*, char*, S32);\n    void(*discardDblBuf)(st_FILELOADINFO*);\n    S32(*asyncIRead)(st_FILELOADINFO*, S32, char*, S32, S32);\n    S32(*asyncMRead)(st_FILELOADINFO*, S32, char*, S32, S32);\n    en_BIO_ASYNC_ERRCODES(*asyncReadStatus)(st_FILELOADINFO*);\n    U32 lockid;\n    en_FIOERRCODES error;\n    U32 basesector;\n    void* privdata;\n    void* xtradata;\n    void* asyndata;\n    S32 filesize;\n    S32 remain;\n    S32 position;\n};\n\ntypedef struct _tagiPad\n{\n    S32 port;\n} iPad;\n\ntypedef struct _tagPadAnalog\n{\n    S8 x;\n    S8 y;\n} PadAnalog;\n\ntypedef enum _tagPadState\n{\n    ePad_Disabled,\n    ePad_Enabled,\n    ePad_Total\n} PadState;\n\ntypedef struct _tagxPad\n{\n    struct analog_data\n    {\n        xVec2 offset;\n        xVec2 dir;\n        F32 mag;\n        F32 ang;\n    };\n\n    U8 value[22];\n    U8 last_value[22];\n    U32 on;\n    U32 pressed;\n    U32 released;\n    PadAnalog analog1;\n    PadAnalog analog2;\n    PadState state;\n    U32 flags;\n    S16 port;\n    S16 slot;\n    iPad context;\n    F32 al2d_timer;\n    F32 ar2d_timer;\n    F32 d_timer;\n    F32 up_tmr[22];\n    F32 down_tmr[22];\n    analog_data analog[2];\n} xPad;\n\nenum xCamCoordType\n{\n    XCAM_COORD_INVALID = -1,\n    XCAM_COORD_CART = 0,\n    XCAM_COORD_CYLINDER,\n    XCAM_COORD_SPHERE,\n    XCAM_COORD_MAX\n};\n\nenum xCamOrientType\n{\n    XCAM_ORIENT_INVALID = -1,\n    XCAM_ORIENT_QUAT = 0,\n    XCAM_ORIENT_EULER,\n    XCAM_ORIENT_MAX\n};\n\nstruct xCamCoordCylinder\n{\n    xVec3 origin;\n    F32 dist;\n    F32 height;\n    F32 theta;\n};\n\nstruct xCamCoordSphere\n{\n    xVec3 origin;\n    F32 dist;\n    xQuat dir;\n};\n\nstruct xCamCoord\n{\n    union\n    {\n        xVec3 cart;\n        xCamCoordCylinder cylinder;\n        xCamCoordSphere sphere;\n    };\n};\n\nstruct xCamOrientEuler\n{\n    F32 yaw;\n    F32 pitch;\n    F32 roll;\n};\n\nstruct xCamOrient\n{\n    union\n    {\n        xQuat quat;\n        xCamOrientEuler euler;\n    };\n};\n\nstruct xCamSpatialInfo\n{\n    xCamCoord coord;\n    xCamOrient orient;\n};\n\nstruct xCamConfigCommon\n{\n    U8 priority;\n    U8 pad1;\n    U8 pad2;\n    U8 pad3;\n    F32 blend_time;\n};\n\nstruct xCamConfigFollow\n{\n    struct zone_data\n    {\n        xVec3 offset;\n        xVec3 face;\n    };\n\n    zone_data zone_rest;\n    zone_data zone_above;\n    zone_data zone_below;\n    F32 speed_zone_offset;\n    F32 speed_zone_face;\n    F32 speed_move_orbit;\n};\n\nstruct xCamGroup;\nstruct zCamSplineCommonMix;\nstruct xScene;\nstruct zCam2Player;\nstruct xCamBlend;\n\nstruct xCam\n{\npublic:\n    xMat4x3 mat;\n    xMat4x3 coll_mat;\n    F32 fov;\n    S32 flags;\n    U32 owner;\n    xCamGroup* group;\n    xPad::analog_data analog;\n    xCamCoordType coord_type;\n    xCamOrientType orient_type;\n    xCamSpatialInfo spatial;\n    xCamSpatialInfo coll_spatial;\n    xCamConfigCommon cfg_common;\n\n    static void scene_enter();\n    static void scene_exit();\n    static void coord_to_world(xVec3& loc, const xVec3& c);\n    static void coord_to_world(xVec3& loc, const xCamCoordCylinder& c);\n    static void coord_to_world(xVec3& loc, const xCamCoordSphere& c);\n    static void orient_to_world(xMat3x3& mat, const xQuat& o);\n    static void orient_to_world(xMat3x3& mat, const xCamOrientEuler& o);\n\n    bool active();\n    void refresh_mat();\n    void refresh_mat(xMat4x3& mat, const xCamSpatialInfo& spatial);\n    void do_update(xScene& scene, F32 dt);\n    bool started() const;\n    \n    virtual xCam* get_final_dest();\n    virtual zCamSplineCommonMix* get_common_mix();\n    virtual void create();\n    virtual void destroy();\n    virtual void start();\n    virtual void stop();\n    virtual void update(xScene& scene, F32 dt) = 0;\n    virtual void pre_update(xScene& scene);\n    virtual void post_update(xScene& scene);\n    virtual xCam* get_next();\n    virtual xCam* find_camera(U32 ownerID);\n    virtual zCam2Player* get_zCam2Player() const;\n    virtual F32 getCameraPlayerAudioBias() const;\n    virtual xCamConfigFollow* config_follow();\n\nprivate:\n    S32 group_flags;\n    xCamBlend* blender;\n\npublic:\n    struct\n    {\n        S32 flags;\n        xColor color[3];\n    } debug;\n\n    void debug_init();\n    void add_tweaks_common(const char* prefix);\n    void add_tweaks_config_follow(const char* prefix);\n\n    virtual void debug_render();\n    virtual void debug_mode_draw();\n    virtual void add_tweaks(const char* prefix);\n\n    friend struct xCamGroup;\n};\n\n// Guessed based on context\n#define k_XCAM_ACTIVE ((U32)(1 << 0))\n#define k_XCAM_0x80 ((U32)(1 << 7))\n\n// Guessed based on context\n#define k_XCAM_GROUP_0x10 ((U32)(1 << 4))\n\n// Guessed based on context\n#define k_XCAM_DEBUG_0x1 ((U32)(1 << 0))\n#define k_XCAM_DEBUG_0x8 ((U32)(1 << 3))\n\nclass xCamTransition;\nstruct xCamTransitionParams;\n\nstruct xCamTransitionParams : xCamConfigCommon\n{\n    xCamTransition* mTransitionObject;\n};\n\nstruct xCamGroup\n{\npublic:\n    xMat4x3 mat;\n    xMat4x3 coll_mat;\n    xVec3 coll_atXZ;\n    F32 cameraPlayerAudioBias;\n    xVec3 vel;\n    F32 fov;\n    F32 fov_default;\n    S32 flags;\n    xCam* primary;\n    xPad::analog_data analog;\n\n    void create();\n    void destroy();\n    void reset();\n    void update(xScene& scene, F32 dt);\n    void stop(xCam& cam);\n    void set_child_flags(S32 add, S32 remove);\n    void transition_to(xCam& cam, const xCamTransitionParams* params, bool force_cut, bool force_restart);\n    void PrintCamMsg(const char* msg, U32 ownerID) const;\n    void set_primary(xCam* toCamera, bool force_restart);\n    xCam* get_blend(xCamTransition* transition, xCam& to);\n    void add(xCam& cam, bool force_cut);\n    void remove(xCam& cam, bool);\n    xCamBlend* grab_blend_cam();\n\nprivate:\n    S32 child_flags;\n    S32 child_flags_mask;\n    xCamBlend* blend_cam[4];\n\n    xCamBlend* create_blend();\n};\n\nclass xCamBias\n{\npublic:\n    void* __vptr;\n\nprotected:\n    bool mIsBiDirectional;\n};\n\nclass xCamTimeBias : public xCamBias\n{\nprivate:\n    F32 bias;\n    F32 time;\n    F32 blendTime;\n};\n\nstruct xCamBlend : xCam\n{\n    xCam* src;\n    xCam* dst;\n    xCamBias* bias;\n    xCamTimeBias timeBias;\n    xCamTransition* transition;\n};\n\nextern bool gxCamShowDebugMessages;\n\nstruct xCamTransitionAsset : xDynAsset\n{\n    U32 mVersion;\n    S32 mType;\n    U32 mFlags;\n    U32 mDestCameraID;\n    union\n    {\n        struct\n        {\n            F32 mTime;\n            F32 mAccel;\n            F32 mDecel;\n        };\n        struct\n        {\n            U32 mSrcCameraID;\n            U32 mCurveID;\n            U32 mTriggerID;\n        };\n    };\n};\n\nstruct zEntTrigger;\n\nclass xCamTransition : public xBase\n{\npublic:\n    const xCamTransitionAsset* mAsset;\n    zEntTrigger* mTransitionVolume;\n    S32 mType;\n\n    bool IsCut();\n\nprivate:\n    bool mActive;\n    xCamBias* mCamBlendBias;\n};\n\nextern F32 SECS_PER_VBLANK;", "diff_flags": [], "diff_label": "CalcRecipBlendMax__FPUs", "libraries": []}