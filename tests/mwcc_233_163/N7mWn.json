{"compiler": "mwcc_233_163", "compiler_flags": "-O4,p -fp hard -inline auto", "source_code": "/* ----------------------------------------------- */\n/* Training File for Metrowerks Decompilation v1.0 */\n/* ----------------------------------------------- */\n\n// This file contains 10 functions to decompile as a test\n// of various compiler knowledge and general decompilation\n// skills. The first one is provided for free. M2C decompiler\n// outputs are provided as the basis for the others. Good luck!\n\n// \"?\"s in the m2c outputs means it is an unknown type; you are\n// expected to replace these with the correct ones (int, long, etc).\n\n// In this architecture (PowerPC), return values are expected to be in r3.\n\n// FREE FUNCTION\nvoid Training_Function1(void) {\n\n}\n\n// HINT: This one is extremely simple. Just fix the function.\nint Training_Function2(void) {\n    return 4;\n}\n\n// HINT: Maybe you have to rewrite this function somehow... is there anything more elegant than direct adding?\nextern int lbl_803ED840[];\n\ns32 Training_Function3(void) {\n    int sum = 0;\n    int i;\n    for(i = 0; i < 4; i++) {\n        sum += lbl_803ED840[i];\n    }\n    return sum;\n}\n\n// HINT: There are no gotos in the answer. Is there some other structure that does the same thing?\nvoid func_803B772C();\nvoid func_803B7730();\nvoid func_803B7734();\n\nvoid Training_Function4(s32 arg0) {\n    while (1) {\n        switch (arg0) {\n            case 0:\n            default:\n                func_803B772C();\n                return;\n            case 1:\n                func_803B7730();\n                return;\n            case 2:\n                func_803B7734();\n                return;\n            case 3:\n                break;\n        }\n    }\n}\n\n// HINT: So close... there must be some other math expressions that does the same thing.\nint Training_Function5(int arg0) {\n    int x = arg0 * 512;\n    x /= 5;\n    return x % 6;\n}\n\n// HINT: This is a famous mathematical problem! It's similar to how Function4 is written though.\ns32 Training_Function6(u32 n) {\n    // Collatz conjecture\n    // Calculate total steps to 1\n    int steps = 0;\n    if (n <= 1) {\n        return 0;\n    }\n    while (n != 1) {\n        // check if arg0 is even/odd\n        switch (n & 1) {\n            case 0:\n                // if even, divide by 2\n                n /= 2;\n                steps++;\n                break;\n            case 1:\n                // if odd, n = (n * 3) + 1\n                n = (n * 3) + 1;\n                steps++;\n                break;\n        }\n    }\n    // return the number of step it took to get to 1\n    return steps;\n}\n\n// HINT: Decompilers are bad at loops.\ns32 func_803B7738(s32);\nextern s32 lbl_803ED850[];\n\ns32 Training_Function7(s32 arg0) {\n    int i = 0;\n    for(i = 0; i < 4; i++) {\n        arg0 += func_803B7738(lbl_803ED850[i]);\n    }\n    for(i = 0; i < 4; i++) {\n        arg0 += func_803B7738(lbl_803ED850[i + 4]);\n    }\n    return arg0;\n}\n\n// HINT: This looks similar to an earlier function...\ns32 Training_Function8(int *arg0) {\n    int sum = 0;\n    int i;\n    for(i = 0; i < 16; i++) {\n        sum += arg0[i];\n    }\n    return sum;\n}\n\n// HINT: Function calls can be fake, and are generated by the compiler for natural math operations, such as converting from floats\n// to non-floats and vice versa.\nu32 func_803228C0(f32);\nextern f32 lbl_804DB2F8;\n\nu32 Training_Function9(f32 arg8) {\n    u32 sum = arg8;\n    do {\n        arg8 += lbl_804DB2F8;\n        sum += (u32)arg8;\n    } while (sum >= 0x1388);\n    return sum;\n}\n\n// HINT: Use everything you have learned up until now - literally.\n/* ==========================================================\nu32 func_803228C0(u32, u32, u32, s32, f32);\ns32 func_803B72F8(s32, u32);\n? func_803B772C();\n? func_803B7730();\n? func_803B7734();\ns32 func_803B7738(s32);\nextern ? lbl_803ED840;\nextern f32 lbl_804DB2F8;\nextern f64 lbl_804DB300;\n\ns32 Training_Function10(void) {\n    u32 sp80;\n    u32 sp7C;\n    u32 sp78;\n    u32 sp74;\n    u32 sp70;\n    u32 sp6C;\n    u32 sp68;\n    u32 sp64;\n    u32 sp60;\n    u32 sp5C;\n    u32 sp58;\n    u32 sp54;\n    u32 sp50;\n    u32 sp4C;\n    u32 sp48;\n    u32 sp44;\n    f32 temp_f31;\n    f32 var_f30;\n    s32 *var_r27;\n    s32 temp_r30_2;\n    s32 temp_r30_3;\n    s32 temp_r6;\n    s32 var_r29;\n    s32 var_r29_2;\n    u32 temp_r30;\n    u32 temp_r30_4;\n    u32 temp_r30_5;\n    u32 var_r28;\n    u32 var_r28_2;\n    void *var_r27_2;\n\n    temp_r30_2 = (lbl_803ED840.unk0 + lbl_803ED840.unk4 + lbl_803ED840.unk8 + lbl_803ED840.unkC + 4) & 3;\nloop_1:\n    if (temp_r30_2 != 2) {\n        if (temp_r30_2 < 2) {\n            if (temp_r30_2 != 0) {\n                if (temp_r30_2 < 0) {\n                    goto block_8;\n                }\n                func_803B7730();\n            } else {\n                goto block_8;\n            }\n        } else {\n            if (temp_r30_2 < 4) {\n                goto loop_1;\n            }\nblock_8:\n            func_803B772C();\n        }\n    } else {\n        func_803B7734();\n    }\n    temp_r30_3 = temp_r30_2 + (((temp_r30_2 << 9) / 5) % 6);\n    temp_r30_4 = temp_r30_3 * func_803B72F8(temp_r30_3, (temp_r30_2 << 9) / 5);\n    var_r29 = 0;\n    var_r28_2 = temp_r30_4;\n    var_r27 = &lbl_803ED840 + 0x10;\n    do {\n        var_r29 += 1;\n        var_r28_2 += func_803B7738(*var_r27);\n        var_r27 += 4;\n    } while (var_r29 < 4);\n    var_r29_2 = 0;\n    var_r27_2 = &lbl_803ED840 + 0x10;\n    do {\n        var_r29_2 += 1;\n        var_r28_2 += func_803B7738(var_r27_2->unk10);\n        var_r27_2 += 4;\n    } while (var_r29_2 < 4);\n    temp_r30_5 = temp_r30_4 / var_r28_2;\n    sp44 = temp_r30_5;\n    sp48 = temp_r30_5;\n    sp4C = temp_r30_5;\n    sp50 = temp_r30_5;\n    sp54 = temp_r30_5;\n    sp58 = temp_r30_5;\n    sp5C = temp_r30_5;\n    sp60 = temp_r30_5;\n    sp64 = temp_r30_5;\n    sp68 = temp_r30_5;\n    sp6C = temp_r30_5;\n    sp70 = temp_r30_5;\n    sp74 = temp_r30_5;\n    sp78 = temp_r30_5;\n    sp7C = temp_r30_5;\n    sp80 = temp_r30_5;\n    temp_r6 = sp44 + sp48 + sp4C + sp50 + sp54 + sp58 + sp5C + sp60 + sp64 + sp68 + sp6C + sp70 + sp74 + sp78 + sp7C + sp80;\n    temp_r30 = temp_r30_5 + temp_r6;\n    var_f30 = temp_r30;\n    temp_f31 = lbl_804DB2F8;\n    var_r28 = func_803228C0(sp80, sp7C, sp74, temp_r6, temp_r30);\n    do {\n        var_f30 += temp_f31;\n        var_r28 += func_803228C0((bitwise u32) var_f30);\n    } while (var_r28 >= 0x1388);\n    return temp_r30 - var_r28;\n}\n============================================================ */\n\n", "context": "typedef unsigned char u8;\ntypedef unsigned short u16;\ntypedef unsigned long u32;\ntypedef unsigned long long u64;\ntypedef signed char s8;\ntypedef short s16;\ntypedef long s32;\ntypedef long long s64;\ntypedef volatile unsigned char vu8;\ntypedef volatile unsigned short vu16;\ntypedef volatile unsigned long vu32;\ntypedef volatile unsigned long long vu64;\ntypedef volatile signed char vs8;\ntypedef volatile short vs16;\ntypedef volatile long vs32;\ntypedef volatile long long vs64;\ntypedef float f32;\ntypedef double f64;\ntypedef unsigned int size_t;\n", "diff_flags": [], "diff_label": "Training_Function1", "libraries": []}