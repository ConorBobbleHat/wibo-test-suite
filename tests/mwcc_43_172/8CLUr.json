{"compiler": "mwcc_43_172", "compiler_flags": "-nodefaults -proc gekko -align powerpc -enum int -fp hardware -Cpp_exceptions off -O4,s -inline auto -pragma \"cats off\" -pragma \"warn_notinlined off\" -maxerrors 1 -nosyspath -fp_contract on -str reuse,pool -func_align 4 -gccinc -sdata 2 -sdata2 2 -pragma \"merge_float_consts on\" -RTTI on -lang=c++", "source_code": "DataNode::DataNode(Symbol sym)\n{\n    type = kDataSymbol;\n    value.symVal = sym;\n}", "context": "class Symbol {\npublic:\n\tconst char *m_string;\n    // Symbol();\n\tSymbol() : m_string(\"\") {}\n\t// Symbol() : m_string(\"\") {}\n\tSymbol(const char *); //ctor pulled from gdrb\n\n\t// methods found in RB2\n\tbool operator!=(const char *);\n\tSymbol *operator=(const Symbol &s) {\n        m_string = s.m_string;\n        return this;\n    }\n\tchar *Str() const;\n\tvoid PreInit(int, int);\n\tvoid Init();\n\tvoid Terminate();\n};\n\nclass String {\npublic:\n\tunsigned int len;\n\tchar *text;\n\n\tString();\n\tString(const char *);\n\tString(Symbol); // fn_80361BC0\n\tString(const String &);\n\tvoid reserve(unsigned int); // fn_80361C90\n\tString(unsigned int, char); // fn_80361D1C\n\n\tvirtual ~String();\n\tvirtual void Print(const char *); // fn_80361E34\n\n\tString operator+(const char *) const; // fn_80361E38\n\tString operator+(char); // fn_80361E7C\n\tString operator+(String *); // fn_80361EC0\n\tString *operator+=(const char *); // fn_80361F04\n\tString *operator+=(const String &); // fn_80361F88\n\tString *operator+=(char); // fn_80361FC4\n\tString *operator=(const char *);\n\tString *operator=(Symbol); // fn_803620B4\n\tString *operator=(const String &); // fn_803620BC\n\n\tchar *operator[](unsigned int); // fn_80362110\n\tchar rcharAt(int); // fn_8036211C\n\tchar *rindex(int); // fn_80362130\n\tbool operator!=(const char *) const; // fn_80362144\n\tbool operator!=(const String &) const; // fn_80362188\n\tbool operator==(const char *) const; // fn_803621BC\n\tbool operator==(const String &) const; // fn_80362200\n\tbool operator<(const String &) const; // fn_80362234\n\tvoid resize(unsigned int); // fn_80362260\n\tint find(char, int); // fn_803622A4\n\tint find(char); // fn_803622E4\n\tint find(const char *) const; // fn_803622F0\n\tint find(const char *, unsigned int) const; // fn_803622F8\n\tint find_first_of(const char *, unsigned int) const; // fn_8036233C\n\tint find_last_of(char) const; // fn_803623A0\n\tint find_last_of(const char *) const; // fn_803623E8\n\tint rfind(const char *) const; // fn_80362478\n\tbool contains(const char *) const; // fn_80362530\n\n\tString substr(unsigned int); // fn_80362660\n\tString substr(unsigned int, unsigned int) const; // fn_8036266C\n\tvoid ToLower();\n\tvoid ToUpper(); // fn_80362730\n\tvoid ReplaceAll(char, char); // fn_80362778\n\tvoid swap(String &); // fn_803627A8\n\tString *replace(unsigned int, unsigned int, const char *); // fn_803627CC\n\tString *erase(); // fn_803628F8\n\tString *erase(unsigned int); // fn_80362908\n\tvoid erase(unsigned int, unsigned int); // fn_80362924\n\tString *insert(int, unsigned int, char); // fn_80362930\n\tString *replace(unsigned int, const char *); // fn_803629F4\n\tString *replace(unsigned int, String *); // fn_80362A00\n\n\t// symbols found in RB2:\n\t// npos__6String, find_first_of__6StringCFPCc\n\n\t// probably inline header methods\n\tunsigned int length() const; // fn_800A6E18\n\tconst char *c_str() const; // fn_8000DB9C\n\tbool empty() const; // fn_8000EC3C\n\t// fn_8000DAC4\n};\n\nclass TextStream {\npublic:\n\tTextStream();\n\tvirtual ~TextStream(); // fn_8000DD10 - generic dtor fn\n\tvirtual void Print(const char *) = 0;\n\n\tTextStream& operator<<(char); // fn_8037A68C\n\tTextStream& operator<<(short); // unused\n\tTextStream& operator<<(int); // fn_8037A6EC\n\tTextStream& operator<<(long); // fn_8037A750\n\tTextStream& operator<<(unsigned int); // fn_8037A7B4\n\tTextStream& operator<<(unsigned short); // fn_8037A818\n\tTextStream& operator<<(unsigned long); // fn_8037A87C\n\tTextStream& operator<<(float); // fn_8037A8E0\n\tTextStream& operator<<(double); // unused\n\tTextStream& operator<<(const char *); // fn_8037A940\n\tTextStream& operator<<(Symbol); // fn_8037A97C\n\tTextStream& operator<<(bool); // fn_8037A9BC\n\tvoid Space(int); // fn_8037AA10\n};\n\nclass DataArray; // forward declaration\nclass DataNode;\nnamespace Hmx {\n    class Object;\n}\n\ntypedef DataNode DataFunc(DataArray *);\n\nunion DataNodeValue {\n\tint intVal;\n\tfloat floatVal;\n\tDataArray *dataArray;\n\tHmx::Object* objVal;\n\tchar *strVal;\n    Symbol symVal;\n\tDataNode* varVal;\n    DataFunc* funcVal;\n    void* miscVal;\n};\n\nenum DataType { /* differs from serialized, for... some reason; i trusted ghidra more that i probably should've, just FYI */\n\tkDataUnhandled = 0,\n\tkDataFloat = 1,\n\tkDataVariable = 2,\n\tkDataFunc = 3,\n\tkDataObject = 4,\n\tkDataSymbol = 5, \n\tkDataInt = 6,\n\tkDataIfdef = 7,\n\tkDataElse = 8,\n\tkDataEndif = 9,\n\tkDataArray = 16,\n\tkDataCommand = 17,\n\tkDataString = 18,\n\tkDataProperty = 19,\n\tkDataGlob = 20,\n\tkDataDefine = 32,\n\tkDataInclude = 33,\n\tkDataMerge = 34,\n\tkDataIfndef = 35,\n\tkDataAutorun = 36,\n\tkDataUndef = 37,\n};\n\nclass BinStream;\n\nclass DataNode {\npublic:\n\tDataNode(); // fn_801C7058\n\tDataNode(int); // fn_8000E128\n    DataNode(float); // fn_800B30B8\n\tDataNode(const DataNode&);\n\tDataNode(const char*); // fn_803231CC\n\tDataNode(const String&); // fn_8032324C\n\tDataNode(Symbol); // fn_8000E114\n\tDataNode(const void*, int);\n\tDataNode(DataArray*, DataType); // fn_80323318\n\tDataNode(DataType, DataNodeValue); // fn_800AB8A8\n\t~DataNode(); // fn_8000DFE4\n\n\tDataNode* Evaluate() const;\n\tint Int(const DataArray*) const; // fn_80322F28\n\tint LiteralInt(const DataArray*) const; // fn_80322F4C\n\tconst char* Sym(const DataArray*) const; // fn_80322F54\n\tSymbol* LiteralSym(const DataArray*) const; // fn_80322F78\n\tSymbol* ForceSym(const DataArray*) const; // fn_80322F80\n\tconst char* Str(const DataArray*) const; // fn_80322FC8\n\tconst char* LiteralStr(const DataArray*) const; // fn_80323004\n\tfloat Float(const DataArray*) const; // fn_80323024\n\tfloat LiteralFloat(const DataArray*) const; // fn_8032307C\n\tDataArray* Array(const DataArray*) const; // fn_8032313C\n\tDataArray* LiteralArray(const DataArray*) const; // fn_80323160\n    DataNode* Var(const DataArray*) const; // fn_80323170\n    Hmx::Object* GetObj(const DataArray*) const;\n\tbool operator==(const DataNode&) const; // fn_80323360\n\tbool operator!=(const DataNode&) const; // fn_80323508\n\tbool NotNull() const; // fn_80323530\n\tDataNode* operator=(const DataNode&); // fn_803235D4\n\tvoid Print(TextStream&, bool) const; // fn_8032364C\n\n    DataFunc* Func(const DataArray*) const;\n    void Save(BinStream &) const; // fn_80323A18\n\tvoid Load(BinStream &); // fn_80323B64\n\n\tDataType GetType() const; // same code as JsonObject::GetJsonObjectStruct()\n\tvoid AssignValue(const DataNode&); // same code as Symbol::operator=(const Symbol&)\n    DataNodeValue GetDataNodeVal() const; // fn_80018808\n\n\tDataNodeValue value;\n\tDataType type;\n};\n\nclass DataArray {\npublic:\n\tDataArray(int);\n\tDataArray(const void*, int);\n\t~DataArray();\n\n\tint Size() const;\n\tvoid Int(int) const;\n\tvoid Insert(int, const DataNode &); // fn_80315CFC\n\tvoid InsertNodes(int, const DataArray*); // fn_80315E1C\n\tvoid Resize(int);\n\tvoid Remove(int);\n\tvoid Remove(const DataNode&);\n\tbool Contains(const DataNode&);\n\tvoid SortNodes(); // fn_80316E84\n\t// void SaveGlob(BinStream&, bool) const; // fn_80317B18\n\t// void LoadGlob(BinStream&, bool); // fn_80317B9C\n    void Save(BinStream &) const; // fn_803171F8\n\tvoid Load(BinStream &);\n\tvoid SaveGlob(BinStream &, bool) const; // fn_80317B18\n\tvoid LoadGlob(BinStream &, bool); // fn_80317B9C\n\n    DataNode Execute();\n    DataNode ExecuteScript(int, Hmx::Object*, const DataArray*, int);\n\n\tvoid IncRefCount(); // fn_800AE758\n\tvoid DecRefCount(); // fn_8000DFC4\n\tint GetNodeCount() const; // fn_8000FDA0\n\tDataNode *GetNodeAtIndex(int) const; // fn_8000DF50\n\tint GetIntAtIndex(int) const; // fn_800A8410\n\tfloat GetFloatAtIndex(int) const; // fn_800D7964\n\tDataNodeValue GetDataNodeValueAtIndex(int) const; // fn_80316258\n\tSymbol* GetSymAtIndex(int) const; // fn_80010140\n\tconst char *GetStrAtIndex(int) const; // fn_8000ECC0\n\tDataArray *GetArrayAtIndex(int) const; // fn_800B27F0\n\tDataNode* GetVarAtIndex(int) const; // fn_800E7878\n\tDataType GetTypeAtIndex(int) const; // fn_80117BAC\n\tSymbol ForceSymAtIndex(int) const; // fn_80119134\n\tvoid Print(TextStream &, DataType, bool) const; // fn_80315A70\n\tvoid SetFileLine(Symbol, int); // fn_80316CB0\n\n    DataArray* GetCommandAtIndex(int) const;\n    short GetLine();\n    char* GetSymbol();\n\n\tDataArray* FindArray(int, bool) const; // fn_803161D4\n\tDataArray* FindArray(Symbol, bool) const; // fn_8031627C\n\tDataArray* FindArray(Symbol, Symbol) const; // fn_803162BC\n\tDataArray* FindArray(Symbol, Symbol, Symbol) const; // fn_80316300\n\tDataArray* FindArray(Symbol, const char*) const; // fn_80316358\n\n\tDataNode* mNodes;\n\tSymbol symbol;\n\tshort mNodeCount;\n\tshort mRefCount;\n\tshort mLine;\n\tshort mUnknown;\n};\n\nnamespace Hmx {\n\tclass Object {\n\tpublic:\n\t\t// TypeProps props;\n        int props; // filler for now\n\t\tint unk8;\n\t\tconst char* name;\n\n\t\tObject(); // fn_8033560c\n\t\tvirtual ~Object(); // fn_803356ec\n\t\tvirtual void RefOwner(); // links to fn_8076F540, which returns void\n\t\tvirtual void Replace(); // fn_80336C88\n\t\t// ObjRef::IsDirPtr // links to fn_8077BAA0, which returns 0\n\t\tvirtual void ClassName(); // fn_800103C8\n\t\tvirtual void SetType(); // fn_800102A0\n\t\tvirtual void Handle(); // fn_80336C94\n\t\tvirtual bool SyncProperty(); // fn_80337B7C\n\t\tvirtual void Save();\n\t\tvirtual void Copy();\n\t\tvirtual void Load();\n\t\tvirtual void Print(); // links to fn_8076F540, which returns void\n\t\tvirtual void Export(); // links to fn_8076F540, which returns void\n\t\tvirtual void V_Unk14(); // links to fn_8076F540, which returns void\n\t\tvirtual void V_Unk15(); // links to fn_8076F540, which returns void\n\t\tvirtual void SetTypeDef();\n\t\tvirtual void SetName(); // fn_80335904\n\t\tvirtual void DataDir(); // fn_803351D0\n\t\tvirtual void PreLoad(); // fn_800AB8B4\n\t\tvirtual void PostLoad(); // links to fn_8076F540, which returns void\n\t\tvirtual void FindPathName(); // fn_80336A84\n\n        DataNode* Property(DataArray*, bool);\n        void SetProperty(DataArray*, const DataNode&);\n        const char* Name() const;\n\t};\n}\n\nclass Rand2 {\npublic:\n\tRand2(int);\n\tint Int();\n\tint num;\n};\n\nclass BinStream {\npublic:\n\tenum SeekType {\n\t\tSeekMode0,\n\t\tSeekMode1,\n\t\tSeekMode2\n\t};\n\n\tBinStream(bool);\n\tvirtual ~BinStream();\n\tvirtual void Flush() = 0;\n\tvirtual int Tell() = 0;\n\tvirtual bool Eof() = 0;\n\tvirtual bool Fail() = 0;\n\tvirtual const char *Name() const; // fn_80342ACC\n\tvirtual int V_Unk6(); // links to fn_8077BAA0, which returns 0\n\tvirtual int V_Unk7(); // links to fn_8077BAA0, which returns 0\n\tvirtual void ReadImpl(void *, int) = 0;\n\tvirtual void WriteImpl(const void *, int) = 0;\n\tvirtual void SeekImpl(\n\t\tint,\n\t\tSeekType) = 0; // the second int should actually be of type BinStream::SeekType\n\n\tbool unk04;\n\tRand2 *unk08;\n\n\t// taken from RB2\n\tBinStream &operator<<(const char *);\n\tBinStream &operator<<(const Symbol &);\n\tBinStream &operator<<(const String &);\n\tBinStream &operator>>(Symbol &);\n\tBinStream &operator>>(String &);\n\n\tvoid WriteEndian(const void *, int);\n\tvoid Write(const void *, int);\n\n\tvoid ReadString(char *, int);\n\tvoid ReadEndian(void *, int);\n\tvoid Read(void *, int);\n\n\tvoid EnableReadEncryption();\n\tvoid EnableWriteEncryption(int);\n\tvoid DisableEncryption();\n\tvoid Seek(int, SeekType);\n\n\t// not taken from RB2, found in the asm\n\tBinStream &operator<<(unsigned int); // fn_800A7638\n\tBinStream &operator>>(unsigned int &); // fn_800A77B4\n\tBinStream& operator>>(float&); // fn_800A77B4 also, because code merging\n\tBinStream &operator>>(unsigned char &); // fn_800A7730\n\tBinStream &operator>>(bool &); // fn_800A7764\n\tBinStream &operator<<(char); // fn_800A75FC\n\tBinStream &operator<<(short); // fn_801CB744\n\tBinStream &operator>>(short &); // fn_801CCA70\n\tBinStream &operator<<(float); // fn_800B95C4\n};\n\nDataNode* EvaluateNodeAtIndex(DataArray*, int);", "diff_flags": [], "diff_label": "DataNode Symbol ctor", "libraries": []}