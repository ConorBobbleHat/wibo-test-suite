{"compiler": "mwcc_20_87", "compiler_flags": "-O4,s -enum int -proc arm946e -gccext,on -fp soft -lang c99 -char signed -inline on,noauto -Cpp_exceptions off -gccinc -interworking -gccdep -MD -g", "source_code": "typedef unsigned char bool;\ntypedef unsigned char byte;\ntypedef long long longlong;\ntypedef unsigned char uchar;\ntypedef unsigned int uint;\ntypedef unsigned int uint3;\ntypedef unsigned long ulong;\ntypedef unsigned long long ulonglong;\ntypedef unsigned char undefined1;\ntypedef unsigned short undefined2;\ntypedef unsigned int undefined4;\ntypedef unsigned long long undefined6;\ntypedef unsigned long long undefined8;\ntypedef unsigned short ushort;\ntypedef int wchar_t;\ntypedef struct PaletteData PaletteData, * PPaletteData;\n\ntypedef struct ImportantPaletteRelatedSubStruct ImportantPaletteRelatedSubStruct, * PImportantPaletteRelatedSubStruct;\n\ntypedef struct RGBA8 RGBA8, * PRGBA8;\n\nstruct RGBA8 {\n    u8 red;\n    u8 green;\n    u8 blue;\n    u8 alpha;\n};\n\nstruct PaletteData {\n    struct ImportantPaletteRelatedSubStruct * unk_pal_related_maybe_owner;\n    s32 nb_color;\n    bool need_update;\n    u8 field3_0x9;\n    u16 fade_opposite;\n    struct RGBA8 flush_colors;\n    u32 unk;\n    void( * refresh_command)(struct PaletteData * );\n    struct RGBA8 * rgba_palette; /* seemingly allocated */\n    u16 * raw_palette;\n    struct PaletteData * previous_palette;\n    struct PaletteData * next_palette;\n};\n\nstruct ImportantPaletteRelatedSubStruct {\n    u32 skip_certain_color_for_effect; /* skip certain color when applying effects when value is 2 (are they the portrait and text box color?) */\n    s32 count; /* number of element in the alloc at offset 0x10 of this struct */\n    u8 field2_0x8;\n    u8 field3_0x9;\n    u8 field4_0xa;\n    u8 field5_0xb;\n    u32 field6_0xc;\n    u16 * palettes; /* 2-byte (BGR5?) colors */\n};\n\nextern unsigned long long __divsi3(int dividend, int divisor);\n\ninline u16 rgb8tobgron16(int blue, int green, int red) {\n    return (ushort)(((u16) blue & 0xf8) << 7) | (ushort)(((u16) green & 0xf8) << 2) | (ushort)((int)(red & 0xf8) >> 3);\n}\n\n// What does ((u32)((int)x >> 7) >> 0x18)) do:\n// a positive/0 number will turn into 0, a negative one will turn into 255\n// rounding up the 24.8 fixed point number if it\u2019s a negative number\n// (so, round toward 0?)\n\n#define round_fixed_24_8_toward_0(x)    (((u32)((s32)(x) >> 7) >> 0x18) + (x))\n\n\nvoid transform_palette_data_with_flush_divide_fade(PaletteData * param_1) {\n\n    u32 fade_opposite = param_1->fade_opposite;\n    u32 skip_some_color = param_1->unk_pal_related_maybe_owner->skip_certain_color_for_effect;\n\n    RGBA8 color;\n    \n    RGBA8* source_color = &param_1->flush_colors;\n    // it gets inlin\n    __memcpy(&color, source_color, 4);\n    RGBA8* source = param_1->rgba_palette;\n    u16* target = param_1->raw_palette;\n    if (fade_opposite >= 0x100) {\n        for (s32 i = 0; i < param_1 -> nb_color; i += 1) {\n            *target = ((source->blue & 0xf8) << 7) | ((source->green & 0xf8) << 2) | ((int)(source->red & 0xf8) >> 3);\n            source += 1;\n            target += 1;\n        }\n    } else {\n        // number ranging from 0 to 0xFE01. Fixed point in 24.8 format\n        //question: how can it be negative?\n        // color_bis.red is in the range of 0 to 0xFF (u8)\n        // fade_bis is in the range 0 to 0xFF (checked in a condition)\n        //conclusion: it can\u2019t\n        //That\u2019s probably a macro that included or an inlined function\n        \n        \n        \n        u32 red_pre_mul = (color.red + (round_fixed_24_8_toward_0((0xff - color.red) * fade_opposite) >> 8)) & 0xffff;\n        u32 green_pre_mul = (color.green + (round_fixed_24_8_toward_0((0xff - color.green) * fade_opposite) >> 8)) & 0xffff;\n        u32 blue_pre_mul = (color.blue + (round_fixed_24_8_toward_0((0xff - color.blue) * fade_opposite) >> 8)) & 0xffff;\n        \n        s32 color_counter = 0;\n        if (skip_some_color == 2) {\n            while (color_counter < param_1 -> nb_color) {\n                s32 loop_counter_tmp_2 = 0;\n                do {\n                    u64 red_specific = __divsi3(source->red * red_pre_mul, 0xff);\n                    u64 blue_specific = __divsi3(source->blue * blue_pre_mul, 0xff);\n                    u64 green_specific = __divsi3(source->green * green_pre_mul, 0xff);\n                    source += 1;\n                    loop_counter_tmp_2 = loop_counter_tmp_2 + 1;\n                    *target = (((u16) blue_specific & 0xf8) << 7) | (((u16) green_specific & 0xf8) << 2) | ((u16) red_specific & 0xf8) >> 3;\n                    color_counter++;\n                    target++;\n                } while (loop_counter_tmp_2 < 0xf0);\n                \n                s32 loop_counter_tmp_3 = 0;\n                do {\n                    loop_counter_tmp_3 = loop_counter_tmp_3 + 1;\n                    *target = (( source->blue & 0xf8) << 7) | (( source->green & 0xf8) << 2) | (( source->red & 0xf8) >> 3);\n                    color_counter++;\n                    source++;\n                    target++;\n                } while (loop_counter_tmp_3 < 0x10);\n            }\n        } else {\n            for (; color_counter < param_1 -> nb_color; color_counter += 1) {\n                u64 red_transformed = __divsi3(source -> red * red_pre_mul, 0xff);\n                u64 green_transformed = __divsi3(source -> blue * blue_pre_mul, 0xff);\n                u64 blue_transformed = __divsi3(source -> green * green_pre_mul, 0xff);\n                //TODO: makes more sense with BGR order, but it match less\n                *target = (((u16) red_transformed & 0xf8) >> 3) | (((u16) blue_transformed & 0xf8) << 7) | (((u16) green_transformed & 0xf8) << 2);\n                source++;\n                target++;\n            }\n        }\n    }\n    return;\n}", "context": "typedef unsigned char u8;\ntypedef unsigned short int u16;\ntypedef unsigned long u32;\n\ntypedef signed char s8;\ntypedef signed short int s16;\ntypedef signed long s32;\n\ntypedef unsigned long long int u64;\ntypedef signed long long int s64;\n\ntypedef volatile u8 vu8;\ntypedef volatile u16 vu16;\ntypedef volatile u32 vu32;\ntypedef volatile u64 vu64;\n\ntypedef volatile s8 vs8;\ntypedef volatile s16 vs16;\ntypedef volatile s32 vs32;\ntypedef volatile s64 vs64;\n\ntypedef float f32;\ntypedef volatile f32 vf32;\n\ntypedef u8 REGType8;\ntypedef u16 REGType16;\ntypedef u32 REGType32;\ntypedef u64 REGType64;\n\ntypedef vu8 REGType8v;\ntypedef vu16 REGType16v;\ntypedef vu32 REGType32v;\ntypedef vu64 REGType64v;\n\ntypedef int BOOL;\n\n#define TRUE 1\n#define FALSE 0\n#define NULL ((void *)0)", "diff_flags": [], "diff_label": "transform_palette_data_with_flush_divide_fade", "libraries": []}